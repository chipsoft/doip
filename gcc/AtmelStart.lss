
AtmelStart.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         0000ba3c  00000000  00000000  00010000  2**4
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .relocate     00000080  20000000  0000ba3c  00020000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bkupram      00000000  47000000  47000000  00020080  2**0
                  CONTENTS
  3 .qspi         00000000  04000000  04000000  00020080  2**0
                  CONTENTS
  4 .bss          0001638c  20000080  0000bac0  00020080  2**5
                  ALLOC
  5 .stack        00010004  2001640c  00021e4c  00020080  2**0
                  ALLOC
  6 .ARM.attributes 0000002e  00000000  00000000  00020080  2**0
                  CONTENTS, READONLY
  7 .comment      00000049  00000000  00000000  000200ae  2**0
                  CONTENTS, READONLY
  8 .debug_info   000471d3  00000000  00000000  000200f7  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
  9 .debug_abbrev 00009027  00000000  00000000  000672ca  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 10 .debug_loc    0001d53a  00000000  00000000  000702f1  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 11 .debug_aranges 00001ab8  00000000  00000000  0008d82b  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 12 .debug_ranges 00003078  00000000  00000000  0008f2e3  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 13 .debug_macro  0003f330  00000000  00000000  0009235b  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 14 .debug_line   00033732  00000000  00000000  000d168b  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 15 .debug_str    0012f888  00000000  00000000  00104dbd  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 16 .debug_frame  00005854  00000000  00000000  00234648  2**2
                  CONTENTS, READONLY, DEBUGGING, OCTETS

Disassembly of section .text:

00000000 <exception_table>:
       0:	10 64 02 20 b9 48 00 00 b5 48 00 00 b5 48 00 00     .d. .H...H...H..
      10:	b5 48 00 00 b5 48 00 00 b5 48 00 00 00 00 00 00     .H...H...H......
	...
      2c:	35 9d 00 00 b5 48 00 00 00 00 00 00 bd 9d 00 00     5....H..........
      3c:	1d 9e 00 00 b5 48 00 00 b5 48 00 00 b5 48 00 00     .....H...H...H..
      4c:	b5 48 00 00 b5 48 00 00 b5 48 00 00 b5 48 00 00     .H...H...H...H..
      5c:	b5 48 00 00 b5 48 00 00 b5 48 00 00 b5 48 00 00     .H...H...H...H..
      6c:	b5 48 00 00 b5 48 00 00 b5 48 00 00 b5 48 00 00     .H...H...H...H..
      7c:	b5 48 00 00 b5 48 00 00 b5 48 00 00 b5 48 00 00     .H...H...H...H..
      8c:	b5 48 00 00 b5 48 00 00 b5 48 00 00 b5 48 00 00     .H...H...H...H..
      9c:	b5 48 00 00 b5 48 00 00 b5 48 00 00 b5 48 00 00     .H...H...H...H..
      ac:	b5 48 00 00 b5 48 00 00 b5 48 00 00 b5 48 00 00     .H...H...H...H..
      bc:	b5 48 00 00 b5 48 00 00 b5 48 00 00 b5 48 00 00     .H...H...H...H..
      cc:	b5 48 00 00 b5 48 00 00 b5 48 00 00 b5 48 00 00     .H...H...H...H..
      dc:	b5 48 00 00 b5 48 00 00 b5 48 00 00 00 00 00 00     .H...H...H......
	...
      f4:	dd 89 00 00 b5 48 00 00 b5 48 00 00 b5 48 00 00     .....H...H...H..
     104:	b5 48 00 00 b5 48 00 00 b5 48 00 00 b5 48 00 00     .H...H...H...H..
     114:	b5 48 00 00 b5 48 00 00 b5 48 00 00 b5 48 00 00     .H...H...H...H..
     124:	b5 48 00 00 b5 48 00 00 b5 48 00 00 b5 48 00 00     .H...H...H...H..
     134:	b5 48 00 00 b5 48 00 00 b5 48 00 00 b5 48 00 00     .H...H...H...H..
     144:	b5 48 00 00 b5 48 00 00 b5 48 00 00 b5 48 00 00     .H...H...H...H..
     154:	b5 48 00 00 b5 48 00 00 b5 48 00 00 b5 48 00 00     .H...H...H...H..
     164:	b5 48 00 00 b5 48 00 00 b5 48 00 00 b5 48 00 00     .H...H...H...H..
     174:	b5 48 00 00 b5 48 00 00 b5 48 00 00 b5 48 00 00     .H...H...H...H..
     184:	b5 48 00 00 b5 48 00 00 b5 48 00 00 d1 85 00 00     .H...H...H......
     194:	b5 48 00 00 b5 48 00 00 b5 48 00 00 b5 48 00 00     .H...H...H...H..
     1a4:	b5 48 00 00 b5 48 00 00 b5 48 00 00 b5 48 00 00     .H...H...H...H..
     1b4:	b5 48 00 00 b5 48 00 00 b5 48 00 00 b5 48 00 00     .H...H...H...H..
     1c4:	b5 48 00 00 b5 48 00 00 b5 48 00 00 b5 48 00 00     .H...H...H...H..
     1d4:	b5 48 00 00 b5 48 00 00 b5 48 00 00 b5 48 00 00     .H...H...H...H..
     1e4:	b5 48 00 00 b5 48 00 00 b5 48 00 00 b5 48 00 00     .H...H...H...H..
     1f4:	b5 48 00 00 b5 48 00 00 b5 48 00 00 b5 48 00 00     .H...H...H...H..
     204:	b5 48 00 00 b5 48 00 00 b5 48 00 00 b5 48 00 00     .H...H...H...H..
     214:	b5 48 00 00 b5 48 00 00 b5 48 00 00 b5 48 00 00     .H...H...H...H..
     224:	b5 48 00 00 b5 48 00 00 b5 48 00 00 b5 48 00 00     .H...H...H...H..
     234:	b5 48 00 00 b5 48 00 00 b5 48 00 00 b5 48 00 00     .H...H...H...H..
     244:	b5 48 00 00 b5 48 00 00 b5 48 00 00 b5 48 00 00     .H...H...H...H..
     254:	b5 48 00 00 b5 48 00 00 b5 48 00 00 b5 48 00 00     .H...H...H...H..

00000264 <__do_global_dtors_aux>:
     264:	b510      	push	{r4, lr}
     266:	4c05      	ldr	r4, [pc, #20]	; (27c <__do_global_dtors_aux+0x18>)
     268:	7823      	ldrb	r3, [r4, #0]
     26a:	b933      	cbnz	r3, 27a <__do_global_dtors_aux+0x16>
     26c:	4b04      	ldr	r3, [pc, #16]	; (280 <__do_global_dtors_aux+0x1c>)
     26e:	b113      	cbz	r3, 276 <__do_global_dtors_aux+0x12>
     270:	4804      	ldr	r0, [pc, #16]	; (284 <__do_global_dtors_aux+0x20>)
     272:	f3af 8000 	nop.w
     276:	2301      	movs	r3, #1
     278:	7023      	strb	r3, [r4, #0]
     27a:	bd10      	pop	{r4, pc}
     27c:	20000080 	.word	0x20000080
     280:	00000000 	.word	0x00000000
     284:	0000ba3c 	.word	0x0000ba3c

00000288 <frame_dummy>:
     288:	b508      	push	{r3, lr}
     28a:	4b03      	ldr	r3, [pc, #12]	; (298 <frame_dummy+0x10>)
     28c:	b11b      	cbz	r3, 296 <frame_dummy+0xe>
     28e:	4903      	ldr	r1, [pc, #12]	; (29c <frame_dummy+0x14>)
     290:	4803      	ldr	r0, [pc, #12]	; (2a0 <frame_dummy+0x18>)
     292:	f3af 8000 	nop.w
     296:	bd08      	pop	{r3, pc}
     298:	00000000 	.word	0x00000000
     29c:	20000084 	.word	0x20000084
     2a0:	0000ba3c 	.word	0x0000ba3c

000002a4 <stdio_io_init>:

/** IO descriptor for STDIO access. */
static struct io_descriptor *stdio_io = NULL;

void stdio_io_init(struct io_descriptor *io)
{
     2a4:	b570      	push	{r4, r5, r6, lr}
#if defined(__GNUC__)
	/* Specify that stdout and stdin should not be buffered. */
	setbuf(stdout, NULL);
     2a6:	4e07      	ldr	r6, [pc, #28]	; (2c4 <stdio_io_init+0x20>)
     2a8:	4d07      	ldr	r5, [pc, #28]	; (2c8 <stdio_io_init+0x24>)
     2aa:	6833      	ldr	r3, [r6, #0]
{
     2ac:	4604      	mov	r4, r0
	setbuf(stdout, NULL);
     2ae:	2100      	movs	r1, #0
     2b0:	6898      	ldr	r0, [r3, #8]
     2b2:	47a8      	blx	r5
	setbuf(stdin, NULL);
     2b4:	6833      	ldr	r3, [r6, #0]
     2b6:	2100      	movs	r1, #0
     2b8:	6858      	ldr	r0, [r3, #4]
     2ba:	47a8      	blx	r5
	 * and AVR GCC library:
	 * - printf() emits one character at a time.
	 * - getchar() requests only 1 byte to exit.
	 */
#endif
	stdio_io = io;
     2bc:	4b03      	ldr	r3, [pc, #12]	; (2cc <stdio_io_init+0x28>)
     2be:	601c      	str	r4, [r3, #0]
}
     2c0:	bd70      	pop	{r4, r5, r6, pc}
     2c2:	bf00      	nop
     2c4:	2000001c 	.word	0x2000001c
     2c8:	0000a491 	.word	0x0000a491
     2cc:	2000009c 	.word	0x2000009c

000002d0 <stdio_io_read>:
	stdio_io = io;
}

int32_t stdio_io_read(uint8_t *buf, const int32_t len)
{
	if (stdio_io == NULL) {
     2d0:	4a04      	ldr	r2, [pc, #16]	; (2e4 <stdio_io_read+0x14>)
{
     2d2:	4603      	mov	r3, r0
	if (stdio_io == NULL) {
     2d4:	6810      	ldr	r0, [r2, #0]
     2d6:	b118      	cbz	r0, 2e0 <stdio_io_read+0x10>
		return 0;
	}
	return io_read(stdio_io, buf, len);
     2d8:	b28a      	uxth	r2, r1
     2da:	4619      	mov	r1, r3
     2dc:	4b02      	ldr	r3, [pc, #8]	; (2e8 <stdio_io_read+0x18>)
     2de:	4718      	bx	r3
}
     2e0:	4770      	bx	lr
     2e2:	bf00      	nop
     2e4:	2000009c 	.word	0x2000009c
     2e8:	00006329 	.word	0x00006329

000002ec <stdio_io_write>:

int32_t stdio_io_write(const uint8_t *buf, const int32_t len)
{
	if (stdio_io == NULL) {
     2ec:	4a04      	ldr	r2, [pc, #16]	; (300 <stdio_io_write+0x14>)
{
     2ee:	4603      	mov	r3, r0
	if (stdio_io == NULL) {
     2f0:	6810      	ldr	r0, [r2, #0]
     2f2:	b118      	cbz	r0, 2fc <stdio_io_write+0x10>
		return 0;
	}
	return io_write(stdio_io, buf, len);
     2f4:	b28a      	uxth	r2, r1
     2f6:	4619      	mov	r1, r3
     2f8:	4b02      	ldr	r3, [pc, #8]	; (304 <stdio_io_write+0x18>)
     2fa:	4718      	bx	r3
}
     2fc:	4770      	bx	lr
     2fe:	bf00      	nop
     300:	2000009c 	.word	0x2000009c
     304:	000062f9 	.word	0x000062f9

00000308 <prvCopyDataToQueue>:

#endif /* configUSE_TRACE_FACILITY */
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue(Queue_t *const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition)
{
     308:	b570      	push	{r4, r5, r6, lr}
     30a:	4615      	mov	r5, r2
	BaseType_t xReturn = pdFALSE;

	if (pxQueue->uxItemSize == (UBaseType_t)0) {
     30c:	6c02      	ldr	r2, [r0, #64]	; 0x40
{
     30e:	4604      	mov	r4, r0
	if (pxQueue->uxItemSize == (UBaseType_t)0) {
     310:	b96a      	cbnz	r2, 32e <prvCopyDataToQueue+0x26>
#if (configUSE_MUTEXES == 1)
		{
			if (pxQueue->uxQueueType == queueQUEUE_IS_MUTEX) {
     312:	6806      	ldr	r6, [r0, #0]
     314:	b10e      	cbz	r6, 31a <prvCopyDataToQueue+0x12>
	BaseType_t xReturn = pdFALSE;
     316:	2500      	movs	r5, #0
     318:	e004      	b.n	324 <prvCopyDataToQueue+0x1c>
				/* The mutex is no longer being held. */
				xReturn                = xTaskPriorityDisinherit((void *)pxQueue->pxMutexHolder);
     31a:	6840      	ldr	r0, [r0, #4]
     31c:	4b16      	ldr	r3, [pc, #88]	; (378 <prvCopyDataToQueue+0x70>)
     31e:	4798      	blx	r3
				pxQueue->pxMutexHolder = NULL;
     320:	6066      	str	r6, [r4, #4]
				xReturn                = xTaskPriorityDisinherit((void *)pxQueue->pxMutexHolder);
     322:	4605      	mov	r5, r0
		} else {
			mtCOVERAGE_TEST_MARKER();
		}
	}

	++(pxQueue->uxMessagesWaiting);
     324:	6ba3      	ldr	r3, [r4, #56]	; 0x38
     326:	3301      	adds	r3, #1
     328:	63a3      	str	r3, [r4, #56]	; 0x38

	return xReturn;
}
     32a:	4628      	mov	r0, r5
     32c:	bd70      	pop	{r4, r5, r6, pc}
	} else if (xPosition == queueSEND_TO_BACK) {
     32e:	4b13      	ldr	r3, [pc, #76]	; (37c <prvCopyDataToQueue+0x74>)
     330:	b95d      	cbnz	r5, 34a <prvCopyDataToQueue+0x42>
		(void)memcpy((void *)pxQueue->pcWriteTo,
     332:	6880      	ldr	r0, [r0, #8]
     334:	4798      	blx	r3
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
     336:	68a3      	ldr	r3, [r4, #8]
     338:	6c22      	ldr	r2, [r4, #64]	; 0x40
     33a:	4413      	add	r3, r2
		if (pxQueue->pcWriteTo >= pxQueue->pcTail) /*lint !e946 MISRA exception justified as comparison of pointers is
     33c:	6862      	ldr	r2, [r4, #4]
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
     33e:	60a3      	str	r3, [r4, #8]
		if (pxQueue->pcWriteTo >= pxQueue->pcTail) /*lint !e946 MISRA exception justified as comparison of pointers is
     340:	4293      	cmp	r3, r2
     342:	d3e8      	bcc.n	316 <prvCopyDataToQueue+0xe>
			pxQueue->pcWriteTo = pxQueue->pcHead;
     344:	6823      	ldr	r3, [r4, #0]
     346:	60a3      	str	r3, [r4, #8]
     348:	e7ec      	b.n	324 <prvCopyDataToQueue+0x1c>
		(void)memcpy((void *)pxQueue->u.pcReadFrom,
     34a:	68c0      	ldr	r0, [r0, #12]
     34c:	4798      	blx	r3
		pxQueue->u.pcReadFrom -= pxQueue->uxItemSize;
     34e:	6c22      	ldr	r2, [r4, #64]	; 0x40
     350:	68e3      	ldr	r3, [r4, #12]
     352:	4251      	negs	r1, r2
     354:	1a9b      	subs	r3, r3, r2
		if (pxQueue->u.pcReadFrom
     356:	6822      	ldr	r2, [r4, #0]
		pxQueue->u.pcReadFrom -= pxQueue->uxItemSize;
     358:	60e3      	str	r3, [r4, #12]
		if (pxQueue->u.pcReadFrom
     35a:	4293      	cmp	r3, r2
			pxQueue->u.pcReadFrom = (pxQueue->pcTail - pxQueue->uxItemSize);
     35c:	bf3e      	ittt	cc
     35e:	6863      	ldrcc	r3, [r4, #4]
     360:	185b      	addcc	r3, r3, r1
     362:	60e3      	strcc	r3, [r4, #12]
		if (xPosition == queueOVERWRITE) {
     364:	2d02      	cmp	r5, #2
     366:	d1d6      	bne.n	316 <prvCopyDataToQueue+0xe>
			if (pxQueue->uxMessagesWaiting > (UBaseType_t)0) {
     368:	6ba3      	ldr	r3, [r4, #56]	; 0x38
     36a:	2b00      	cmp	r3, #0
     36c:	d0d3      	beq.n	316 <prvCopyDataToQueue+0xe>
				--(pxQueue->uxMessagesWaiting);
     36e:	6ba3      	ldr	r3, [r4, #56]	; 0x38
     370:	3b01      	subs	r3, #1
     372:	63a3      	str	r3, [r4, #56]	; 0x38
     374:	e7cf      	b.n	316 <prvCopyDataToQueue+0xe>
     376:	bf00      	nop
     378:	00009371 	.word	0x00009371
     37c:	0000a349 	.word	0x0000a349

00000380 <prvNotifyQueueSetContainer>:
	/*-----------------------------------------------------------*/

#if (configUSE_QUEUE_SETS == 1)

static BaseType_t prvNotifyQueueSetContainer(const Queue_t *const pxQueue, const BaseType_t xCopyPosition)
{
     380:	b537      	push	{r0, r1, r2, r4, r5, lr}
	Queue_t *  pxQueueSetContainer = pxQueue->pxQueueSetContainer;
     382:	6d44      	ldr	r4, [r0, #84]	; 0x54
{
     384:	9001      	str	r0, [sp, #4]
     386:	460a      	mov	r2, r1
	BaseType_t xReturn             = pdFALSE;

	/* This function must be called form a critical section. */

	configASSERT(pxQueueSetContainer);
     388:	b944      	cbnz	r4, 39c <prvNotifyQueueSetContainer+0x1c>

portFORCE_INLINE static void vPortRaiseBASEPRI(void)
{
	uint32_t ulNewBASEPRI;

	__asm volatile("	mov %0, %1												\n"
     38a:	f04f 0380 	mov.w	r3, #128	; 0x80
     38e:	f383 8811 	msr	BASEPRI, r3
     392:	f3bf 8f6f 	isb	sy
     396:	f3bf 8f4f 	dsb	sy
     39a:	e7fe      	b.n	39a <prvNotifyQueueSetContainer+0x1a>
	configASSERT(pxQueueSetContainer->uxMessagesWaiting < pxQueueSetContainer->uxLength);
     39c:	6ba1      	ldr	r1, [r4, #56]	; 0x38
     39e:	6be3      	ldr	r3, [r4, #60]	; 0x3c
     3a0:	4299      	cmp	r1, r3
     3a2:	d308      	bcc.n	3b6 <prvNotifyQueueSetContainer+0x36>
     3a4:	f04f 0380 	mov.w	r3, #128	; 0x80
     3a8:	f383 8811 	msr	BASEPRI, r3
     3ac:	f3bf 8f6f 	isb	sy
     3b0:	f3bf 8f4f 	dsb	sy
     3b4:	e7fe      	b.n	3b4 <prvNotifyQueueSetContainer+0x34>

	if (pxQueueSetContainer->uxMessagesWaiting < pxQueueSetContainer->uxLength) {
     3b6:	6ba1      	ldr	r1, [r4, #56]	; 0x38
     3b8:	428b      	cmp	r3, r1
     3ba:	d917      	bls.n	3ec <prvNotifyQueueSetContainer+0x6c>
		traceQUEUE_SEND(pxQueueSetContainer);

		/* The data copied is the handle of the queue that contains data. */
		xReturn = prvCopyDataToQueue(pxQueueSetContainer, &pxQueue, xCopyPosition);
     3bc:	4b0c      	ldr	r3, [pc, #48]	; (3f0 <prvNotifyQueueSetContainer+0x70>)
     3be:	a901      	add	r1, sp, #4
     3c0:	4620      	mov	r0, r4
     3c2:	4798      	blx	r3

		if (pxQueueSetContainer->xTxLock == queueUNLOCKED) {
     3c4:	6ca3      	ldr	r3, [r4, #72]	; 0x48
     3c6:	3301      	adds	r3, #1
		xReturn = prvCopyDataToQueue(pxQueueSetContainer, &pxQueue, xCopyPosition);
     3c8:	4605      	mov	r5, r0
		if (pxQueueSetContainer->xTxLock == queueUNLOCKED) {
     3ca:	d10b      	bne.n	3e4 <prvNotifyQueueSetContainer+0x64>
			if (listLIST_IS_EMPTY(&(pxQueueSetContainer->xTasksWaitingToReceive)) == pdFALSE) {
     3cc:	6a63      	ldr	r3, [r4, #36]	; 0x24
     3ce:	b133      	cbz	r3, 3de <prvNotifyQueueSetContainer+0x5e>
				if (xTaskRemoveFromEventList(&(pxQueueSetContainer->xTasksWaitingToReceive)) != pdFALSE) {
     3d0:	4b08      	ldr	r3, [pc, #32]	; (3f4 <prvNotifyQueueSetContainer+0x74>)
     3d2:	f104 0024 	add.w	r0, r4, #36	; 0x24
     3d6:	4798      	blx	r3
					/* The task waiting has a higher priority. */
					xReturn = pdTRUE;
     3d8:	2800      	cmp	r0, #0
     3da:	bf18      	it	ne
     3dc:	2501      	movne	r5, #1
	} else {
		mtCOVERAGE_TEST_MARKER();
	}

	return xReturn;
}
     3de:	4628      	mov	r0, r5
     3e0:	b003      	add	sp, #12
     3e2:	bd30      	pop	{r4, r5, pc}
			(pxQueueSetContainer->xTxLock)++;
     3e4:	6ca3      	ldr	r3, [r4, #72]	; 0x48
     3e6:	3301      	adds	r3, #1
     3e8:	64a3      	str	r3, [r4, #72]	; 0x48
     3ea:	e7f8      	b.n	3de <prvNotifyQueueSetContainer+0x5e>
	BaseType_t xReturn             = pdFALSE;
     3ec:	2500      	movs	r5, #0
	return xReturn;
     3ee:	e7f6      	b.n	3de <prvNotifyQueueSetContainer+0x5e>
     3f0:	00000309 	.word	0x00000309
     3f4:	000091a1 	.word	0x000091a1

000003f8 <prvCopyDataFromQueue>:
{
     3f8:	4603      	mov	r3, r0
     3fa:	b410      	push	{r4}
	if (pxQueue->uxItemSize != (UBaseType_t)0) {
     3fc:	6c1a      	ldr	r2, [r3, #64]	; 0x40
{
     3fe:	4608      	mov	r0, r1
	if (pxQueue->uxItemSize != (UBaseType_t)0) {
     400:	b16a      	cbz	r2, 41e <prvCopyDataFromQueue+0x26>
		pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
     402:	68dc      	ldr	r4, [r3, #12]
		if (pxQueue->u.pcReadFrom >= pxQueue->pcTail) /*lint !e946 MISRA exception justified as use of the relational
     404:	6859      	ldr	r1, [r3, #4]
		pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
     406:	4414      	add	r4, r2
		if (pxQueue->u.pcReadFrom >= pxQueue->pcTail) /*lint !e946 MISRA exception justified as use of the relational
     408:	428c      	cmp	r4, r1
			pxQueue->u.pcReadFrom = pxQueue->pcHead;
     40a:	bf28      	it	cs
     40c:	6819      	ldrcs	r1, [r3, #0]
		pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
     40e:	60dc      	str	r4, [r3, #12]
			pxQueue->u.pcReadFrom = pxQueue->pcHead;
     410:	bf28      	it	cs
     412:	60d9      	strcs	r1, [r3, #12]
		(void)memcpy((void *)pvBuffer,
     414:	68d9      	ldr	r1, [r3, #12]
}
     416:	f85d 4b04 	ldr.w	r4, [sp], #4
		(void)memcpy((void *)pvBuffer,
     41a:	4b02      	ldr	r3, [pc, #8]	; (424 <prvCopyDataFromQueue+0x2c>)
     41c:	4718      	bx	r3
}
     41e:	f85d 4b04 	ldr.w	r4, [sp], #4
     422:	4770      	bx	lr
     424:	0000a349 	.word	0x0000a349

00000428 <prvUnlockQueue>:
{
     428:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	taskENTER_CRITICAL();
     42c:	4e1f      	ldr	r6, [pc, #124]	; (4ac <prvUnlockQueue+0x84>)
						if (xTaskRemoveFromEventList(&(pxQueue->xTasksWaitingToReceive)) != pdFALSE) {
     42e:	4d20      	ldr	r5, [pc, #128]	; (4b0 <prvUnlockQueue+0x88>)
						vTaskMissedYield();
     430:	4f20      	ldr	r7, [pc, #128]	; (4b4 <prvUnlockQueue+0x8c>)
					if (prvNotifyQueueSetContainer(pxQueue, queueSEND_TO_BACK) == pdTRUE) {
     432:	f8df 8088 	ldr.w	r8, [pc, #136]	; 4bc <prvUnlockQueue+0x94>
{
     436:	4604      	mov	r4, r0
	taskENTER_CRITICAL();
     438:	47b0      	blx	r6
		while (pxQueue->xTxLock > queueLOCKED_UNMODIFIED) {
     43a:	6ca3      	ldr	r3, [r4, #72]	; 0x48
     43c:	2b00      	cmp	r3, #0
     43e:	dc14      	bgt.n	46a <prvUnlockQueue+0x42>
		pxQueue->xTxLock = queueUNLOCKED;
     440:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
     444:	64a3      	str	r3, [r4, #72]	; 0x48
	taskEXIT_CRITICAL();
     446:	4d1c      	ldr	r5, [pc, #112]	; (4b8 <prvUnlockQueue+0x90>)
				if (xTaskRemoveFromEventList(&(pxQueue->xTasksWaitingToSend)) != pdFALSE) {
     448:	4f19      	ldr	r7, [pc, #100]	; (4b0 <prvUnlockQueue+0x88>)
					vTaskMissedYield();
     44a:	f8df 8068 	ldr.w	r8, [pc, #104]	; 4b4 <prvUnlockQueue+0x8c>
	taskEXIT_CRITICAL();
     44e:	47a8      	blx	r5
	taskENTER_CRITICAL();
     450:	47b0      	blx	r6
				if (xTaskRemoveFromEventList(&(pxQueue->xTasksWaitingToSend)) != pdFALSE) {
     452:	f104 0610 	add.w	r6, r4, #16
		while (pxQueue->xRxLock > queueLOCKED_UNMODIFIED) {
     456:	6c63      	ldr	r3, [r4, #68]	; 0x44
     458:	2b00      	cmp	r3, #0
     45a:	dc1b      	bgt.n	494 <prvUnlockQueue+0x6c>
		pxQueue->xRxLock = queueUNLOCKED;
     45c:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
     460:	6463      	str	r3, [r4, #68]	; 0x44
	taskEXIT_CRITICAL();
     462:	462b      	mov	r3, r5
}
     464:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
	taskEXIT_CRITICAL();
     468:	4718      	bx	r3
				if (pxQueue->pxQueueSetContainer != NULL) {
     46a:	6d63      	ldr	r3, [r4, #84]	; 0x54
     46c:	b14b      	cbz	r3, 482 <prvUnlockQueue+0x5a>
					if (prvNotifyQueueSetContainer(pxQueue, queueSEND_TO_BACK) == pdTRUE) {
     46e:	2100      	movs	r1, #0
     470:	4620      	mov	r0, r4
     472:	47c0      	blx	r8
     474:	2801      	cmp	r0, #1
     476:	d100      	bne.n	47a <prvUnlockQueue+0x52>
						vTaskMissedYield();
     478:	47b8      	blx	r7
			--(pxQueue->xTxLock);
     47a:	6ca3      	ldr	r3, [r4, #72]	; 0x48
     47c:	3b01      	subs	r3, #1
     47e:	64a3      	str	r3, [r4, #72]	; 0x48
     480:	e7db      	b.n	43a <prvUnlockQueue+0x12>
					if (listLIST_IS_EMPTY(&(pxQueue->xTasksWaitingToReceive)) == pdFALSE) {
     482:	6a63      	ldr	r3, [r4, #36]	; 0x24
     484:	2b00      	cmp	r3, #0
     486:	d0db      	beq.n	440 <prvUnlockQueue+0x18>
						if (xTaskRemoveFromEventList(&(pxQueue->xTasksWaitingToReceive)) != pdFALSE) {
     488:	f104 0024 	add.w	r0, r4, #36	; 0x24
     48c:	47a8      	blx	r5
     48e:	2800      	cmp	r0, #0
     490:	d0f3      	beq.n	47a <prvUnlockQueue+0x52>
     492:	e7f1      	b.n	478 <prvUnlockQueue+0x50>
			if (listLIST_IS_EMPTY(&(pxQueue->xTasksWaitingToSend)) == pdFALSE) {
     494:	6923      	ldr	r3, [r4, #16]
     496:	2b00      	cmp	r3, #0
     498:	d0e0      	beq.n	45c <prvUnlockQueue+0x34>
				if (xTaskRemoveFromEventList(&(pxQueue->xTasksWaitingToSend)) != pdFALSE) {
     49a:	4630      	mov	r0, r6
     49c:	47b8      	blx	r7
     49e:	b100      	cbz	r0, 4a2 <prvUnlockQueue+0x7a>
					vTaskMissedYield();
     4a0:	47c0      	blx	r8
				--(pxQueue->xRxLock);
     4a2:	6c63      	ldr	r3, [r4, #68]	; 0x44
     4a4:	3b01      	subs	r3, #1
     4a6:	6463      	str	r3, [r4, #68]	; 0x44
     4a8:	e7d5      	b.n	456 <prvUnlockQueue+0x2e>
     4aa:	bf00      	nop
     4ac:	00009d55 	.word	0x00009d55
     4b0:	000091a1 	.word	0x000091a1
     4b4:	000092c5 	.word	0x000092c5
     4b8:	00009d95 	.word	0x00009d95
     4bc:	00000381 	.word	0x00000381

000004c0 <xQueueGenericReset>:
{
     4c0:	b538      	push	{r3, r4, r5, lr}
     4c2:	460d      	mov	r5, r1
	configASSERT(pxQueue);
     4c4:	4604      	mov	r4, r0
     4c6:	b940      	cbnz	r0, 4da <xQueueGenericReset+0x1a>
     4c8:	f04f 0380 	mov.w	r3, #128	; 0x80
     4cc:	f383 8811 	msr	BASEPRI, r3
     4d0:	f3bf 8f6f 	isb	sy
     4d4:	f3bf 8f4f 	dsb	sy
     4d8:	e7fe      	b.n	4d8 <xQueueGenericReset+0x18>
	taskENTER_CRITICAL();
     4da:	4b18      	ldr	r3, [pc, #96]	; (53c <xQueueGenericReset+0x7c>)
     4dc:	4798      	blx	r3
		pxQueue->pcTail            = pxQueue->pcHead + (pxQueue->uxLength * pxQueue->uxItemSize);
     4de:	e9d4 310f 	ldrd	r3, r1, [r4, #60]	; 0x3c
     4e2:	6822      	ldr	r2, [r4, #0]
		pxQueue->pcWriteTo         = pxQueue->pcHead;
     4e4:	60a2      	str	r2, [r4, #8]
		pxQueue->pcTail            = pxQueue->pcHead + (pxQueue->uxLength * pxQueue->uxItemSize);
     4e6:	434b      	muls	r3, r1
     4e8:	18d0      	adds	r0, r2, r3
		pxQueue->u.pcReadFrom      = pxQueue->pcHead + ((pxQueue->uxLength - (UBaseType_t)1U) * pxQueue->uxItemSize);
     4ea:	1a5b      	subs	r3, r3, r1
     4ec:	4413      	add	r3, r2
		pxQueue->pcTail            = pxQueue->pcHead + (pxQueue->uxLength * pxQueue->uxItemSize);
     4ee:	6060      	str	r0, [r4, #4]
		pxQueue->u.pcReadFrom      = pxQueue->pcHead + ((pxQueue->uxLength - (UBaseType_t)1U) * pxQueue->uxItemSize);
     4f0:	60e3      	str	r3, [r4, #12]
		pxQueue->uxMessagesWaiting = (UBaseType_t)0U;
     4f2:	2000      	movs	r0, #0
		pxQueue->xRxLock           = queueUNLOCKED;
     4f4:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
		pxQueue->uxMessagesWaiting = (UBaseType_t)0U;
     4f8:	63a0      	str	r0, [r4, #56]	; 0x38
		pxQueue->xRxLock           = queueUNLOCKED;
     4fa:	6463      	str	r3, [r4, #68]	; 0x44
		pxQueue->xTxLock           = queueUNLOCKED;
     4fc:	64a3      	str	r3, [r4, #72]	; 0x48
		if (xNewQueue == pdFALSE) {
     4fe:	b9ad      	cbnz	r5, 52c <xQueueGenericReset+0x6c>
			if (listLIST_IS_EMPTY(&(pxQueue->xTasksWaitingToSend)) == pdFALSE) {
     500:	6923      	ldr	r3, [r4, #16]
     502:	b17b      	cbz	r3, 524 <xQueueGenericReset+0x64>
				if (xTaskRemoveFromEventList(&(pxQueue->xTasksWaitingToSend)) == pdTRUE) {
     504:	4b0e      	ldr	r3, [pc, #56]	; (540 <xQueueGenericReset+0x80>)
     506:	f104 0010 	add.w	r0, r4, #16
     50a:	4798      	blx	r3
     50c:	2801      	cmp	r0, #1
     50e:	d109      	bne.n	524 <xQueueGenericReset+0x64>
					queueYIELD_IF_USING_PREEMPTION();
     510:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
     514:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
     518:	f8c3 2d04 	str.w	r2, [r3, #3332]	; 0xd04
     51c:	f3bf 8f4f 	dsb	sy
     520:	f3bf 8f6f 	isb	sy
	taskEXIT_CRITICAL();
     524:	4b07      	ldr	r3, [pc, #28]	; (544 <xQueueGenericReset+0x84>)
     526:	4798      	blx	r3
}
     528:	2001      	movs	r0, #1
     52a:	bd38      	pop	{r3, r4, r5, pc}
			vListInitialise(&(pxQueue->xTasksWaitingToSend));
     52c:	f104 0010 	add.w	r0, r4, #16
     530:	4d05      	ldr	r5, [pc, #20]	; (548 <xQueueGenericReset+0x88>)
     532:	47a8      	blx	r5
			vListInitialise(&(pxQueue->xTasksWaitingToReceive));
     534:	f104 0024 	add.w	r0, r4, #36	; 0x24
     538:	47a8      	blx	r5
     53a:	e7f3      	b.n	524 <xQueueGenericReset+0x64>
     53c:	00009d55 	.word	0x00009d55
     540:	000091a1 	.word	0x000091a1
     544:	00009d95 	.word	0x00009d95
     548:	00001dfd 	.word	0x00001dfd

0000054c <xQueueGenericCreate>:
{
     54c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
     54e:	460d      	mov	r5, r1
     550:	4617      	mov	r7, r2
	configASSERT(uxQueueLength > (UBaseType_t)0);
     552:	4606      	mov	r6, r0
     554:	b940      	cbnz	r0, 568 <xQueueGenericCreate+0x1c>
     556:	f04f 0380 	mov.w	r3, #128	; 0x80
     55a:	f383 8811 	msr	BASEPRI, r3
     55e:	f3bf 8f6f 	isb	sy
     562:	f3bf 8f4f 	dsb	sy
     566:	e7fe      	b.n	566 <xQueueGenericCreate+0x1a>
	if (uxItemSize == (UBaseType_t)0) {
     568:	b179      	cbz	r1, 58a <xQueueGenericCreate+0x3e>
		xQueueSizeInBytes = (size_t)(uxQueueLength * uxItemSize)
     56a:	4348      	muls	r0, r1
     56c:	3001      	adds	r0, #1
	pxNewQueue = (Queue_t *)pvPortMalloc(sizeof(Queue_t) + xQueueSizeInBytes);
     56e:	4b11      	ldr	r3, [pc, #68]	; (5b4 <xQueueGenericCreate+0x68>)
     570:	3058      	adds	r0, #88	; 0x58
     572:	4798      	blx	r3
	if (pxNewQueue != NULL) {
     574:	4604      	mov	r4, r0
     576:	b950      	cbnz	r0, 58e <xQueueGenericCreate+0x42>
     578:	f04f 0380 	mov.w	r3, #128	; 0x80
     57c:	f383 8811 	msr	BASEPRI, r3
     580:	f3bf 8f6f 	isb	sy
     584:	f3bf 8f4f 	dsb	sy
	configASSERT(xReturn);
     588:	e7fe      	b.n	588 <xQueueGenericCreate+0x3c>
		xQueueSizeInBytes = (size_t)0;
     58a:	4608      	mov	r0, r1
     58c:	e7ef      	b.n	56e <xQueueGenericCreate+0x22>
		if (uxItemSize == (UBaseType_t)0) {
     58e:	b175      	cbz	r5, 5ae <xQueueGenericCreate+0x62>
			pxNewQueue->pcHead = ((int8_t *)pxNewQueue) + sizeof(Queue_t);
     590:	f100 0358 	add.w	r3, r0, #88	; 0x58
     594:	6023      	str	r3, [r4, #0]
		pxNewQueue->uxItemSize = uxItemSize;
     596:	e9c4 650f 	strd	r6, r5, [r4, #60]	; 0x3c
		(void)xQueueGenericReset(pxNewQueue, pdTRUE);
     59a:	4b07      	ldr	r3, [pc, #28]	; (5b8 <xQueueGenericCreate+0x6c>)
     59c:	2101      	movs	r1, #1
     59e:	4620      	mov	r0, r4
     5a0:	4798      	blx	r3
			pxNewQueue->pxQueueSetContainer = NULL;
     5a2:	2300      	movs	r3, #0
			pxNewQueue->ucQueueType = ucQueueType;
     5a4:	f884 7050 	strb.w	r7, [r4, #80]	; 0x50
			pxNewQueue->pxQueueSetContainer = NULL;
     5a8:	6563      	str	r3, [r4, #84]	; 0x54
}
     5aa:	4620      	mov	r0, r4
     5ac:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
     5ae:	4603      	mov	r3, r0
     5b0:	e7f0      	b.n	594 <xQueueGenericCreate+0x48>
     5b2:	bf00      	nop
     5b4:	00001d01 	.word	0x00001d01
     5b8:	000004c1 	.word	0x000004c1

000005bc <xQueueCreateCountingSemaphore>:
{
     5bc:	b510      	push	{r4, lr}
     5be:	460c      	mov	r4, r1
	configASSERT(uxMaxCount != 0);
     5c0:	b940      	cbnz	r0, 5d4 <xQueueCreateCountingSemaphore+0x18>
     5c2:	f04f 0380 	mov.w	r3, #128	; 0x80
     5c6:	f383 8811 	msr	BASEPRI, r3
     5ca:	f3bf 8f6f 	isb	sy
     5ce:	f3bf 8f4f 	dsb	sy
     5d2:	e7fe      	b.n	5d2 <xQueueCreateCountingSemaphore+0x16>
	configASSERT(uxInitialCount <= uxMaxCount);
     5d4:	4288      	cmp	r0, r1
     5d6:	d208      	bcs.n	5ea <xQueueCreateCountingSemaphore+0x2e>
     5d8:	f04f 0380 	mov.w	r3, #128	; 0x80
     5dc:	f383 8811 	msr	BASEPRI, r3
     5e0:	f3bf 8f6f 	isb	sy
     5e4:	f3bf 8f4f 	dsb	sy
     5e8:	e7fe      	b.n	5e8 <xQueueCreateCountingSemaphore+0x2c>
	xHandle = xQueueGenericCreate(uxMaxCount, queueSEMAPHORE_QUEUE_ITEM_LENGTH, queueQUEUE_TYPE_COUNTING_SEMAPHORE);
     5ea:	4b08      	ldr	r3, [pc, #32]	; (60c <xQueueCreateCountingSemaphore+0x50>)
     5ec:	2202      	movs	r2, #2
     5ee:	2100      	movs	r1, #0
     5f0:	4798      	blx	r3
	if (xHandle != NULL) {
     5f2:	b108      	cbz	r0, 5f8 <xQueueCreateCountingSemaphore+0x3c>
		((Queue_t *)xHandle)->uxMessagesWaiting = uxInitialCount;
     5f4:	6384      	str	r4, [r0, #56]	; 0x38
}
     5f6:	bd10      	pop	{r4, pc}
     5f8:	f04f 0380 	mov.w	r3, #128	; 0x80
     5fc:	f383 8811 	msr	BASEPRI, r3
     600:	f3bf 8f6f 	isb	sy
     604:	f3bf 8f4f 	dsb	sy
	configASSERT(xHandle);
     608:	e7fe      	b.n	608 <xQueueCreateCountingSemaphore+0x4c>
     60a:	bf00      	nop
     60c:	0000054d 	.word	0x0000054d

00000610 <xQueueGenericSend>:
{
     610:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
     614:	b085      	sub	sp, #20
     616:	4689      	mov	r9, r1
     618:	9201      	str	r2, [sp, #4]
     61a:	461e      	mov	r6, r3
	configASSERT(pxQueue);
     61c:	4604      	mov	r4, r0
     61e:	b940      	cbnz	r0, 632 <xQueueGenericSend+0x22>
     620:	f04f 0380 	mov.w	r3, #128	; 0x80
     624:	f383 8811 	msr	BASEPRI, r3
     628:	f3bf 8f6f 	isb	sy
     62c:	f3bf 8f4f 	dsb	sy
     630:	e7fe      	b.n	630 <xQueueGenericSend+0x20>
	configASSERT(!((pvItemToQueue == NULL) && (pxQueue->uxItemSize != (UBaseType_t)0U)));
     632:	b951      	cbnz	r1, 64a <xQueueGenericSend+0x3a>
     634:	6c03      	ldr	r3, [r0, #64]	; 0x40
     636:	b143      	cbz	r3, 64a <xQueueGenericSend+0x3a>
     638:	f04f 0380 	mov.w	r3, #128	; 0x80
     63c:	f383 8811 	msr	BASEPRI, r3
     640:	f3bf 8f6f 	isb	sy
     644:	f3bf 8f4f 	dsb	sy
     648:	e7fe      	b.n	648 <xQueueGenericSend+0x38>
	configASSERT(!((xCopyPosition == queueOVERWRITE) && (pxQueue->uxLength != 1)));
     64a:	2e02      	cmp	r6, #2
     64c:	d10b      	bne.n	666 <xQueueGenericSend+0x56>
     64e:	6be3      	ldr	r3, [r4, #60]	; 0x3c
     650:	2b01      	cmp	r3, #1
     652:	d008      	beq.n	666 <xQueueGenericSend+0x56>
     654:	f04f 0380 	mov.w	r3, #128	; 0x80
     658:	f383 8811 	msr	BASEPRI, r3
     65c:	f3bf 8f6f 	isb	sy
     660:	f3bf 8f4f 	dsb	sy
     664:	e7fe      	b.n	664 <xQueueGenericSend+0x54>
		configASSERT(!((xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED) && (xTicksToWait != 0)));
     666:	4b46      	ldr	r3, [pc, #280]	; (780 <xQueueGenericSend+0x170>)
     668:	4798      	blx	r3
     66a:	4680      	mov	r8, r0
     66c:	b950      	cbnz	r0, 684 <xQueueGenericSend+0x74>
     66e:	9b01      	ldr	r3, [sp, #4]
     670:	b153      	cbz	r3, 688 <xQueueGenericSend+0x78>
     672:	f04f 0380 	mov.w	r3, #128	; 0x80
     676:	f383 8811 	msr	BASEPRI, r3
     67a:	f3bf 8f6f 	isb	sy
     67e:	f3bf 8f4f 	dsb	sy
     682:	e7fe      	b.n	682 <xQueueGenericSend+0x72>
     684:	f04f 0800 	mov.w	r8, #0
		taskENTER_CRITICAL();
     688:	f8df a11c 	ldr.w	sl, [pc, #284]	; 7a8 <xQueueGenericSend+0x198>
     68c:	4f3d      	ldr	r7, [pc, #244]	; (784 <xQueueGenericSend+0x174>)
     68e:	46d3      	mov	fp, sl
     690:	e041      	b.n	716 <xQueueGenericSend+0x106>
						if (listLIST_IS_EMPTY(&(pxQueue->xTasksWaitingToReceive)) == pdFALSE) {
     692:	6a63      	ldr	r3, [r4, #36]	; 0x24
     694:	b123      	cbz	r3, 6a0 <xQueueGenericSend+0x90>
							if (xTaskRemoveFromEventList(&(pxQueue->xTasksWaitingToReceive)) == pdTRUE) {
     696:	4b3c      	ldr	r3, [pc, #240]	; (788 <xQueueGenericSend+0x178>)
     698:	f104 0024 	add.w	r0, r4, #36	; 0x24
     69c:	4798      	blx	r3
     69e:	e04d      	b.n	73c <xQueueGenericSend+0x12c>
						} else if (xYieldRequired != pdFALSE) {
     6a0:	2800      	cmp	r0, #0
     6a2:	d14d      	bne.n	740 <xQueueGenericSend+0x130>
				taskEXIT_CRITICAL();
     6a4:	47b8      	blx	r7
				return pdPASS;
     6a6:	2001      	movs	r0, #1
}
     6a8:	b005      	add	sp, #20
     6aa:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
				if (xTicksToWait == (TickType_t)0) {
     6ae:	9d01      	ldr	r5, [sp, #4]
     6b0:	b915      	cbnz	r5, 6b8 <xQueueGenericSend+0xa8>
					taskEXIT_CRITICAL();
     6b2:	47b8      	blx	r7
			return errQUEUE_FULL;
     6b4:	2000      	movs	r0, #0
     6b6:	e7f7      	b.n	6a8 <xQueueGenericSend+0x98>
				} else if (xEntryTimeSet == pdFALSE) {
     6b8:	f1b8 0f00 	cmp.w	r8, #0
     6bc:	d102      	bne.n	6c4 <xQueueGenericSend+0xb4>
					vTaskSetTimeOutState(&xTimeOut);
     6be:	4b33      	ldr	r3, [pc, #204]	; (78c <xQueueGenericSend+0x17c>)
     6c0:	a802      	add	r0, sp, #8
     6c2:	4798      	blx	r3
		taskEXIT_CRITICAL();
     6c4:	47b8      	blx	r7
		vTaskSuspendAll();
     6c6:	4b32      	ldr	r3, [pc, #200]	; (790 <xQueueGenericSend+0x180>)
     6c8:	f8df 80e0 	ldr.w	r8, [pc, #224]	; 7ac <xQueueGenericSend+0x19c>
     6cc:	4d31      	ldr	r5, [pc, #196]	; (794 <xQueueGenericSend+0x184>)
     6ce:	4798      	blx	r3
		prvLockQueue(pxQueue);
     6d0:	47d8      	blx	fp
     6d2:	6c63      	ldr	r3, [r4, #68]	; 0x44
     6d4:	3301      	adds	r3, #1
     6d6:	bf04      	itt	eq
     6d8:	2300      	moveq	r3, #0
     6da:	6463      	streq	r3, [r4, #68]	; 0x44
     6dc:	6ca3      	ldr	r3, [r4, #72]	; 0x48
     6de:	3301      	adds	r3, #1
     6e0:	bf04      	itt	eq
     6e2:	2300      	moveq	r3, #0
     6e4:	64a3      	streq	r3, [r4, #72]	; 0x48
     6e6:	47b8      	blx	r7
		if (xTaskCheckForTimeOut(&xTimeOut, &xTicksToWait) == pdFALSE) {
     6e8:	4b2b      	ldr	r3, [pc, #172]	; (798 <xQueueGenericSend+0x188>)
     6ea:	a901      	add	r1, sp, #4
     6ec:	a802      	add	r0, sp, #8
     6ee:	4798      	blx	r3
     6f0:	2800      	cmp	r0, #0
     6f2:	d140      	bne.n	776 <xQueueGenericSend+0x166>
	taskENTER_CRITICAL();
     6f4:	47d8      	blx	fp
		if (pxQueue->uxMessagesWaiting == pxQueue->uxLength) {
     6f6:	6ba2      	ldr	r2, [r4, #56]	; 0x38
     6f8:	6be3      	ldr	r3, [r4, #60]	; 0x3c
     6fa:	429a      	cmp	r2, r3
     6fc:	d12b      	bne.n	756 <xQueueGenericSend+0x146>
	taskEXIT_CRITICAL();
     6fe:	47b8      	blx	r7
				vTaskPlaceOnEventList(&(pxQueue->xTasksWaitingToSend), xTicksToWait);
     700:	9901      	ldr	r1, [sp, #4]
     702:	4b26      	ldr	r3, [pc, #152]	; (79c <xQueueGenericSend+0x18c>)
     704:	f104 0010 	add.w	r0, r4, #16
     708:	4798      	blx	r3
				prvUnlockQueue(pxQueue);
     70a:	4620      	mov	r0, r4
     70c:	47c0      	blx	r8
				if (xTaskResumeAll() == pdFALSE) {
     70e:	47a8      	blx	r5
     710:	b330      	cbz	r0, 760 <xQueueGenericSend+0x150>
     712:	f04f 0801 	mov.w	r8, #1
		taskENTER_CRITICAL();
     716:	47d0      	blx	sl
			if ((pxQueue->uxMessagesWaiting < pxQueue->uxLength) || (xCopyPosition == queueOVERWRITE)) {
     718:	6ba2      	ldr	r2, [r4, #56]	; 0x38
     71a:	6be3      	ldr	r3, [r4, #60]	; 0x3c
     71c:	429a      	cmp	r2, r3
     71e:	d301      	bcc.n	724 <xQueueGenericSend+0x114>
     720:	2e02      	cmp	r6, #2
     722:	d1c4      	bne.n	6ae <xQueueGenericSend+0x9e>
				xYieldRequired = prvCopyDataToQueue(pxQueue, pvItemToQueue, xCopyPosition);
     724:	4b1e      	ldr	r3, [pc, #120]	; (7a0 <xQueueGenericSend+0x190>)
     726:	4632      	mov	r2, r6
     728:	4649      	mov	r1, r9
     72a:	4620      	mov	r0, r4
     72c:	4798      	blx	r3
					if (pxQueue->pxQueueSetContainer != NULL) {
     72e:	6d63      	ldr	r3, [r4, #84]	; 0x54
     730:	2b00      	cmp	r3, #0
     732:	d0ae      	beq.n	692 <xQueueGenericSend+0x82>
						if (prvNotifyQueueSetContainer(pxQueue, xCopyPosition) == pdTRUE) {
     734:	4b1b      	ldr	r3, [pc, #108]	; (7a4 <xQueueGenericSend+0x194>)
     736:	4631      	mov	r1, r6
     738:	4620      	mov	r0, r4
     73a:	4798      	blx	r3
							if (xTaskRemoveFromEventList(&(pxQueue->xTasksWaitingToReceive)) == pdTRUE) {
     73c:	2801      	cmp	r0, #1
     73e:	d1b1      	bne.n	6a4 <xQueueGenericSend+0x94>
							queueYIELD_IF_USING_PREEMPTION();
     740:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
     744:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
     748:	f8c3 2d04 	str.w	r2, [r3, #3332]	; 0xd04
     74c:	f3bf 8f4f 	dsb	sy
     750:	f3bf 8f6f 	isb	sy
     754:	e7a6      	b.n	6a4 <xQueueGenericSend+0x94>
	taskEXIT_CRITICAL();
     756:	47b8      	blx	r7
				prvUnlockQueue(pxQueue);
     758:	4620      	mov	r0, r4
     75a:	47c0      	blx	r8
				(void)xTaskResumeAll();
     75c:	47a8      	blx	r5
     75e:	e7d8      	b.n	712 <xQueueGenericSend+0x102>
					portYIELD_WITHIN_API();
     760:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
     764:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
     768:	f8c3 2d04 	str.w	r2, [r3, #3332]	; 0xd04
     76c:	f3bf 8f4f 	dsb	sy
     770:	f3bf 8f6f 	isb	sy
     774:	e7cd      	b.n	712 <xQueueGenericSend+0x102>
			prvUnlockQueue(pxQueue);
     776:	4620      	mov	r0, r4
     778:	47c0      	blx	r8
			(void)xTaskResumeAll();
     77a:	47a8      	blx	r5
     77c:	e79a      	b.n	6b4 <xQueueGenericSend+0xa4>
     77e:	bf00      	nop
     780:	000092d5 	.word	0x000092d5
     784:	00009d95 	.word	0x00009d95
     788:	000091a1 	.word	0x000091a1
     78c:	00009221 	.word	0x00009221
     790:	00008d85 	.word	0x00008d85
     794:	00008e99 	.word	0x00008e99
     798:	00009249 	.word	0x00009249
     79c:	000090e9 	.word	0x000090e9
     7a0:	00000309 	.word	0x00000309
     7a4:	00000381 	.word	0x00000381
     7a8:	00009d55 	.word	0x00009d55
     7ac:	00000429 	.word	0x00000429

000007b0 <xQueueGenericSendFromISR>:
{
     7b0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
     7b4:	460f      	mov	r7, r1
     7b6:	4616      	mov	r6, r2
     7b8:	461d      	mov	r5, r3
	configASSERT(pxQueue);
     7ba:	4604      	mov	r4, r0
     7bc:	b940      	cbnz	r0, 7d0 <xQueueGenericSendFromISR+0x20>
     7be:	f04f 0380 	mov.w	r3, #128	; 0x80
     7c2:	f383 8811 	msr	BASEPRI, r3
     7c6:	f3bf 8f6f 	isb	sy
     7ca:	f3bf 8f4f 	dsb	sy
     7ce:	e7fe      	b.n	7ce <xQueueGenericSendFromISR+0x1e>
	configASSERT(!((pvItemToQueue == NULL) && (pxQueue->uxItemSize != (UBaseType_t)0U)));
     7d0:	b951      	cbnz	r1, 7e8 <xQueueGenericSendFromISR+0x38>
     7d2:	6c03      	ldr	r3, [r0, #64]	; 0x40
     7d4:	b143      	cbz	r3, 7e8 <xQueueGenericSendFromISR+0x38>
     7d6:	f04f 0380 	mov.w	r3, #128	; 0x80
     7da:	f383 8811 	msr	BASEPRI, r3
     7de:	f3bf 8f6f 	isb	sy
     7e2:	f3bf 8f4f 	dsb	sy
     7e6:	e7fe      	b.n	7e6 <xQueueGenericSendFromISR+0x36>
	configASSERT(!((xCopyPosition == queueOVERWRITE) && (pxQueue->uxLength != 1)));
     7e8:	2d02      	cmp	r5, #2
     7ea:	d10b      	bne.n	804 <xQueueGenericSendFromISR+0x54>
     7ec:	6be3      	ldr	r3, [r4, #60]	; 0x3c
     7ee:	2b01      	cmp	r3, #1
     7f0:	d008      	beq.n	804 <xQueueGenericSendFromISR+0x54>
     7f2:	f04f 0380 	mov.w	r3, #128	; 0x80
     7f6:	f383 8811 	msr	BASEPRI, r3
     7fa:	f3bf 8f6f 	isb	sy
     7fe:	f3bf 8f4f 	dsb	sy
     802:	e7fe      	b.n	802 <xQueueGenericSendFromISR+0x52>
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
     804:	4b1d      	ldr	r3, [pc, #116]	; (87c <xQueueGenericSendFromISR+0xcc>)
     806:	4798      	blx	r3

portFORCE_INLINE static uint32_t ulPortRaiseBASEPRI(void)
{
	uint32_t ulOriginalBASEPRI, ulNewBASEPRI;

	__asm volatile("	mrs %0, basepri											\n"
     808:	f3ef 8811 	mrs	r8, BASEPRI
     80c:	f04f 0380 	mov.w	r3, #128	; 0x80
     810:	f383 8811 	msr	BASEPRI, r3
     814:	f3bf 8f6f 	isb	sy
     818:	f3bf 8f4f 	dsb	sy
		if ((pxQueue->uxMessagesWaiting < pxQueue->uxLength) || (xCopyPosition == queueOVERWRITE)) {
     81c:	6ba2      	ldr	r2, [r4, #56]	; 0x38
     81e:	6be3      	ldr	r3, [r4, #60]	; 0x3c
     820:	429a      	cmp	r2, r3
     822:	d301      	bcc.n	828 <xQueueGenericSendFromISR+0x78>
     824:	2d02      	cmp	r5, #2
     826:	d126      	bne.n	876 <xQueueGenericSendFromISR+0xc6>
			(void)prvCopyDataToQueue(pxQueue, pvItemToQueue, xCopyPosition);
     828:	4b15      	ldr	r3, [pc, #84]	; (880 <xQueueGenericSendFromISR+0xd0>)
     82a:	462a      	mov	r2, r5
     82c:	4639      	mov	r1, r7
     82e:	4620      	mov	r0, r4
     830:	4798      	blx	r3
			if (pxQueue->xTxLock == queueUNLOCKED) {
     832:	6ca3      	ldr	r3, [r4, #72]	; 0x48
     834:	3301      	adds	r3, #1
     836:	d11a      	bne.n	86e <xQueueGenericSendFromISR+0xbe>
					if (pxQueue->pxQueueSetContainer != NULL) {
     838:	6d63      	ldr	r3, [r4, #84]	; 0x54
     83a:	b13b      	cbz	r3, 84c <xQueueGenericSendFromISR+0x9c>
						if (prvNotifyQueueSetContainer(pxQueue, xCopyPosition) == pdTRUE) {
     83c:	4b11      	ldr	r3, [pc, #68]	; (884 <xQueueGenericSendFromISR+0xd4>)
     83e:	4629      	mov	r1, r5
     840:	4620      	mov	r0, r4
     842:	4798      	blx	r3
     844:	2801      	cmp	r0, #1
     846:	d00a      	beq.n	85e <xQueueGenericSendFromISR+0xae>
			xReturn = pdPASS;
     848:	2001      	movs	r0, #1
     84a:	e00c      	b.n	866 <xQueueGenericSendFromISR+0xb6>
						if (listLIST_IS_EMPTY(&(pxQueue->xTasksWaitingToReceive)) == pdFALSE) {
     84c:	6a63      	ldr	r3, [r4, #36]	; 0x24
     84e:	2b00      	cmp	r3, #0
     850:	d0fa      	beq.n	848 <xQueueGenericSendFromISR+0x98>
							if (xTaskRemoveFromEventList(&(pxQueue->xTasksWaitingToReceive)) != pdFALSE) {
     852:	4b0d      	ldr	r3, [pc, #52]	; (888 <xQueueGenericSendFromISR+0xd8>)
     854:	f104 0024 	add.w	r0, r4, #36	; 0x24
     858:	4798      	blx	r3
     85a:	2800      	cmp	r0, #0
     85c:	d0f4      	beq.n	848 <xQueueGenericSendFromISR+0x98>
							if (pxHigherPriorityTaskWoken != NULL) {
     85e:	2e00      	cmp	r6, #0
     860:	d0f2      	beq.n	848 <xQueueGenericSendFromISR+0x98>
								*pxHigherPriorityTaskWoken = pdTRUE;
     862:	2001      	movs	r0, #1
     864:	6030      	str	r0, [r6, #0]
}
/*-----------------------------------------------------------*/

portFORCE_INLINE static void vPortSetBASEPRI(uint32_t ulNewMaskValue)
{
	__asm volatile("	msr basepri, %0	" ::"r"(ulNewMaskValue));
     866:	f388 8811 	msr	BASEPRI, r8
}
     86a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
				++(pxQueue->xTxLock);
     86e:	6ca3      	ldr	r3, [r4, #72]	; 0x48
     870:	3301      	adds	r3, #1
     872:	64a3      	str	r3, [r4, #72]	; 0x48
     874:	e7e8      	b.n	848 <xQueueGenericSendFromISR+0x98>
			xReturn = errQUEUE_FULL;
     876:	2000      	movs	r0, #0
     878:	e7f5      	b.n	866 <xQueueGenericSendFromISR+0xb6>
     87a:	bf00      	nop
     87c:	00009f5d 	.word	0x00009f5d
     880:	00000309 	.word	0x00000309
     884:	00000381 	.word	0x00000381
     888:	000091a1 	.word	0x000091a1

0000088c <xQueueGiveFromISR>:
{
     88c:	b570      	push	{r4, r5, r6, lr}
     88e:	460d      	mov	r5, r1
	configASSERT(pxQueue);
     890:	4604      	mov	r4, r0
     892:	b940      	cbnz	r0, 8a6 <xQueueGiveFromISR+0x1a>
	__asm volatile("	mov %0, %1												\n"
     894:	f04f 0380 	mov.w	r3, #128	; 0x80
     898:	f383 8811 	msr	BASEPRI, r3
     89c:	f3bf 8f6f 	isb	sy
     8a0:	f3bf 8f4f 	dsb	sy
     8a4:	e7fe      	b.n	8a4 <xQueueGiveFromISR+0x18>
	configASSERT(pxQueue->uxItemSize == 0);
     8a6:	6c03      	ldr	r3, [r0, #64]	; 0x40
     8a8:	b143      	cbz	r3, 8bc <xQueueGiveFromISR+0x30>
     8aa:	f04f 0380 	mov.w	r3, #128	; 0x80
     8ae:	f383 8811 	msr	BASEPRI, r3
     8b2:	f3bf 8f6f 	isb	sy
     8b6:	f3bf 8f4f 	dsb	sy
     8ba:	e7fe      	b.n	8ba <xQueueGiveFromISR+0x2e>
	configASSERT(!((pxQueue->uxQueueType == queueQUEUE_IS_MUTEX) && (pxQueue->pxMutexHolder != NULL)));
     8bc:	6803      	ldr	r3, [r0, #0]
     8be:	b953      	cbnz	r3, 8d6 <xQueueGiveFromISR+0x4a>
     8c0:	6843      	ldr	r3, [r0, #4]
     8c2:	b143      	cbz	r3, 8d6 <xQueueGiveFromISR+0x4a>
     8c4:	f04f 0380 	mov.w	r3, #128	; 0x80
     8c8:	f383 8811 	msr	BASEPRI, r3
     8cc:	f3bf 8f6f 	isb	sy
     8d0:	f3bf 8f4f 	dsb	sy
     8d4:	e7fe      	b.n	8d4 <xQueueGiveFromISR+0x48>
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
     8d6:	4b1b      	ldr	r3, [pc, #108]	; (944 <xQueueGiveFromISR+0xb8>)
     8d8:	4798      	blx	r3
	__asm volatile("	mrs %0, basepri											\n"
     8da:	f3ef 8611 	mrs	r6, BASEPRI
     8de:	f04f 0380 	mov.w	r3, #128	; 0x80
     8e2:	f383 8811 	msr	BASEPRI, r3
     8e6:	f3bf 8f6f 	isb	sy
     8ea:	f3bf 8f4f 	dsb	sy
		if (pxQueue->uxMessagesWaiting < pxQueue->uxLength) {
     8ee:	6ba2      	ldr	r2, [r4, #56]	; 0x38
     8f0:	6be3      	ldr	r3, [r4, #60]	; 0x3c
     8f2:	429a      	cmp	r2, r3
     8f4:	d223      	bcs.n	93e <xQueueGiveFromISR+0xb2>
			++(pxQueue->uxMessagesWaiting);
     8f6:	6ba3      	ldr	r3, [r4, #56]	; 0x38
     8f8:	3301      	adds	r3, #1
     8fa:	63a3      	str	r3, [r4, #56]	; 0x38
			if (pxQueue->xTxLock == queueUNLOCKED) {
     8fc:	6ca3      	ldr	r3, [r4, #72]	; 0x48
     8fe:	3301      	adds	r3, #1
     900:	d119      	bne.n	936 <xQueueGiveFromISR+0xaa>
					if (pxQueue->pxQueueSetContainer != NULL) {
     902:	6d63      	ldr	r3, [r4, #84]	; 0x54
     904:	b13b      	cbz	r3, 916 <xQueueGiveFromISR+0x8a>
						if (prvNotifyQueueSetContainer(pxQueue, queueSEND_TO_BACK) == pdTRUE) {
     906:	4b10      	ldr	r3, [pc, #64]	; (948 <xQueueGiveFromISR+0xbc>)
     908:	2100      	movs	r1, #0
     90a:	4620      	mov	r0, r4
     90c:	4798      	blx	r3
     90e:	2801      	cmp	r0, #1
     910:	d00a      	beq.n	928 <xQueueGiveFromISR+0x9c>
			xReturn = pdPASS;
     912:	2001      	movs	r0, #1
     914:	e00c      	b.n	930 <xQueueGiveFromISR+0xa4>
						if (listLIST_IS_EMPTY(&(pxQueue->xTasksWaitingToReceive)) == pdFALSE) {
     916:	6a63      	ldr	r3, [r4, #36]	; 0x24
     918:	2b00      	cmp	r3, #0
     91a:	d0fa      	beq.n	912 <xQueueGiveFromISR+0x86>
							if (xTaskRemoveFromEventList(&(pxQueue->xTasksWaitingToReceive)) != pdFALSE) {
     91c:	4b0b      	ldr	r3, [pc, #44]	; (94c <xQueueGiveFromISR+0xc0>)
     91e:	f104 0024 	add.w	r0, r4, #36	; 0x24
     922:	4798      	blx	r3
     924:	2800      	cmp	r0, #0
     926:	d0f4      	beq.n	912 <xQueueGiveFromISR+0x86>
							if (pxHigherPriorityTaskWoken != NULL) {
     928:	2d00      	cmp	r5, #0
     92a:	d0f2      	beq.n	912 <xQueueGiveFromISR+0x86>
								*pxHigherPriorityTaskWoken = pdTRUE;
     92c:	2001      	movs	r0, #1
     92e:	6028      	str	r0, [r5, #0]
	__asm volatile("	msr basepri, %0	" ::"r"(ulNewMaskValue));
     930:	f386 8811 	msr	BASEPRI, r6
}
     934:	bd70      	pop	{r4, r5, r6, pc}
				++(pxQueue->xTxLock);
     936:	6ca3      	ldr	r3, [r4, #72]	; 0x48
     938:	3301      	adds	r3, #1
     93a:	64a3      	str	r3, [r4, #72]	; 0x48
     93c:	e7e9      	b.n	912 <xQueueGiveFromISR+0x86>
			xReturn = errQUEUE_FULL;
     93e:	2000      	movs	r0, #0
     940:	e7f6      	b.n	930 <xQueueGiveFromISR+0xa4>
     942:	bf00      	nop
     944:	00009f5d 	.word	0x00009f5d
     948:	00000381 	.word	0x00000381
     94c:	000091a1 	.word	0x000091a1

00000950 <xQueueGenericReceive>:
{
     950:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
     954:	b085      	sub	sp, #20
     956:	4688      	mov	r8, r1
     958:	9201      	str	r2, [sp, #4]
     95a:	4699      	mov	r9, r3
	configASSERT(pxQueue);
     95c:	4604      	mov	r4, r0
     95e:	b940      	cbnz	r0, 972 <xQueueGenericReceive+0x22>
	__asm volatile("	mov %0, %1												\n"
     960:	f04f 0380 	mov.w	r3, #128	; 0x80
     964:	f383 8811 	msr	BASEPRI, r3
     968:	f3bf 8f6f 	isb	sy
     96c:	f3bf 8f4f 	dsb	sy
     970:	e7fe      	b.n	970 <xQueueGenericReceive+0x20>
	configASSERT(!((pvBuffer == NULL) && (pxQueue->uxItemSize != (UBaseType_t)0U)));
     972:	b951      	cbnz	r1, 98a <xQueueGenericReceive+0x3a>
     974:	6c03      	ldr	r3, [r0, #64]	; 0x40
     976:	b143      	cbz	r3, 98a <xQueueGenericReceive+0x3a>
     978:	f04f 0380 	mov.w	r3, #128	; 0x80
     97c:	f383 8811 	msr	BASEPRI, r3
     980:	f3bf 8f6f 	isb	sy
     984:	f3bf 8f4f 	dsb	sy
     988:	e7fe      	b.n	988 <xQueueGenericReceive+0x38>
		configASSERT(!((xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED) && (xTicksToWait != 0)));
     98a:	4b49      	ldr	r3, [pc, #292]	; (ab0 <xQueueGenericReceive+0x160>)
     98c:	4798      	blx	r3
     98e:	4607      	mov	r7, r0
     990:	b950      	cbnz	r0, 9a8 <xQueueGenericReceive+0x58>
     992:	9b01      	ldr	r3, [sp, #4]
     994:	b14b      	cbz	r3, 9aa <xQueueGenericReceive+0x5a>
     996:	f04f 0380 	mov.w	r3, #128	; 0x80
     99a:	f383 8811 	msr	BASEPRI, r3
     99e:	f3bf 8f6f 	isb	sy
     9a2:	f3bf 8f4f 	dsb	sy
     9a6:	e7fe      	b.n	9a6 <xQueueGenericReceive+0x56>
     9a8:	2700      	movs	r7, #0
		taskENTER_CRITICAL();
     9aa:	f8df b134 	ldr.w	fp, [pc, #308]	; ae0 <xQueueGenericReceive+0x190>
     9ae:	4d41      	ldr	r5, [pc, #260]	; (ab4 <xQueueGenericReceive+0x164>)
     9b0:	46da      	mov	sl, fp
     9b2:	e051      	b.n	a58 <xQueueGenericReceive+0x108>
					if (listLIST_IS_EMPTY(&(pxQueue->xTasksWaitingToReceive)) == pdFALSE) {
     9b4:	6a63      	ldr	r3, [r4, #36]	; 0x24
					pxQueue->u.pcReadFrom = pcOriginalReadPosition;
     9b6:	60e6      	str	r6, [r4, #12]
					if (listLIST_IS_EMPTY(&(pxQueue->xTasksWaitingToReceive)) == pdFALSE) {
     9b8:	b12b      	cbz	r3, 9c6 <xQueueGenericReceive+0x76>
						if (xTaskRemoveFromEventList(&(pxQueue->xTasksWaitingToReceive)) != pdFALSE) {
     9ba:	4b3f      	ldr	r3, [pc, #252]	; (ab8 <xQueueGenericReceive+0x168>)
     9bc:	f104 0024 	add.w	r0, r4, #36	; 0x24
     9c0:	4798      	blx	r3
     9c2:	2800      	cmp	r0, #0
     9c4:	d165      	bne.n	a92 <xQueueGenericReceive+0x142>
				taskEXIT_CRITICAL();
     9c6:	47a8      	blx	r5
				return pdPASS;
     9c8:	2001      	movs	r0, #1
}
     9ca:	b005      	add	sp, #20
     9cc:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
				if (xTicksToWait == (TickType_t)0) {
     9d0:	9e01      	ldr	r6, [sp, #4]
     9d2:	b916      	cbnz	r6, 9da <xQueueGenericReceive+0x8a>
					taskEXIT_CRITICAL();
     9d4:	47a8      	blx	r5
			return errQUEUE_EMPTY;
     9d6:	2000      	movs	r0, #0
     9d8:	e7f7      	b.n	9ca <xQueueGenericReceive+0x7a>
				} else if (xEntryTimeSet == pdFALSE) {
     9da:	b917      	cbnz	r7, 9e2 <xQueueGenericReceive+0x92>
					vTaskSetTimeOutState(&xTimeOut);
     9dc:	4b37      	ldr	r3, [pc, #220]	; (abc <xQueueGenericReceive+0x16c>)
     9de:	a802      	add	r0, sp, #8
     9e0:	4798      	blx	r3
		taskEXIT_CRITICAL();
     9e2:	47a8      	blx	r5
		vTaskSuspendAll();
     9e4:	4b36      	ldr	r3, [pc, #216]	; (ac0 <xQueueGenericReceive+0x170>)
     9e6:	4f37      	ldr	r7, [pc, #220]	; (ac4 <xQueueGenericReceive+0x174>)
     9e8:	4e37      	ldr	r6, [pc, #220]	; (ac8 <xQueueGenericReceive+0x178>)
     9ea:	4798      	blx	r3
		prvLockQueue(pxQueue);
     9ec:	47d0      	blx	sl
     9ee:	6c63      	ldr	r3, [r4, #68]	; 0x44
     9f0:	3301      	adds	r3, #1
     9f2:	bf04      	itt	eq
     9f4:	2300      	moveq	r3, #0
     9f6:	6463      	streq	r3, [r4, #68]	; 0x44
     9f8:	6ca3      	ldr	r3, [r4, #72]	; 0x48
     9fa:	3301      	adds	r3, #1
     9fc:	bf04      	itt	eq
     9fe:	2300      	moveq	r3, #0
     a00:	64a3      	streq	r3, [r4, #72]	; 0x48
     a02:	47a8      	blx	r5
		if (xTaskCheckForTimeOut(&xTimeOut, &xTicksToWait) == pdFALSE) {
     a04:	4b31      	ldr	r3, [pc, #196]	; (acc <xQueueGenericReceive+0x17c>)
     a06:	a901      	add	r1, sp, #4
     a08:	a802      	add	r0, sp, #8
     a0a:	4798      	blx	r3
     a0c:	2800      	cmp	r0, #0
     a0e:	d14b      	bne.n	aa8 <xQueueGenericReceive+0x158>
	taskENTER_CRITICAL();
     a10:	47d0      	blx	sl
		if (pxQueue->uxMessagesWaiting == (UBaseType_t)0) {
     a12:	6ba3      	ldr	r3, [r4, #56]	; 0x38
     a14:	b9db      	cbnz	r3, a4e <xQueueGenericReceive+0xfe>
	taskEXIT_CRITICAL();
     a16:	47a8      	blx	r5
					if (pxQueue->uxQueueType == queueQUEUE_IS_MUTEX) {
     a18:	6823      	ldr	r3, [r4, #0]
     a1a:	b923      	cbnz	r3, a26 <xQueueGenericReceive+0xd6>
						taskENTER_CRITICAL();
     a1c:	47d0      	blx	sl
							vTaskPriorityInherit((void *)pxQueue->pxMutexHolder);
     a1e:	6860      	ldr	r0, [r4, #4]
     a20:	4b2b      	ldr	r3, [pc, #172]	; (ad0 <xQueueGenericReceive+0x180>)
     a22:	4798      	blx	r3
						taskEXIT_CRITICAL();
     a24:	47a8      	blx	r5
				vTaskPlaceOnEventList(&(pxQueue->xTasksWaitingToReceive), xTicksToWait);
     a26:	9901      	ldr	r1, [sp, #4]
     a28:	4b2a      	ldr	r3, [pc, #168]	; (ad4 <xQueueGenericReceive+0x184>)
     a2a:	f104 0024 	add.w	r0, r4, #36	; 0x24
     a2e:	4798      	blx	r3
				prvUnlockQueue(pxQueue);
     a30:	4620      	mov	r0, r4
     a32:	47b8      	blx	r7
				if (xTaskResumeAll() == pdFALSE) {
     a34:	47b0      	blx	r6
     a36:	b970      	cbnz	r0, a56 <xQueueGenericReceive+0x106>
					portYIELD_WITHIN_API();
     a38:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
     a3c:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
     a40:	f8c3 2d04 	str.w	r2, [r3, #3332]	; 0xd04
     a44:	f3bf 8f4f 	dsb	sy
     a48:	f3bf 8f6f 	isb	sy
     a4c:	e003      	b.n	a56 <xQueueGenericReceive+0x106>
	taskEXIT_CRITICAL();
     a4e:	47a8      	blx	r5
				prvUnlockQueue(pxQueue);
     a50:	4620      	mov	r0, r4
     a52:	47b8      	blx	r7
				(void)xTaskResumeAll();
     a54:	47b0      	blx	r6
     a56:	2701      	movs	r7, #1
		taskENTER_CRITICAL();
     a58:	47d8      	blx	fp
			if (pxQueue->uxMessagesWaiting > (UBaseType_t)0) {
     a5a:	6ba3      	ldr	r3, [r4, #56]	; 0x38
     a5c:	2b00      	cmp	r3, #0
     a5e:	d0b7      	beq.n	9d0 <xQueueGenericReceive+0x80>
				prvCopyDataFromQueue(pxQueue, pvBuffer);
     a60:	4b1d      	ldr	r3, [pc, #116]	; (ad8 <xQueueGenericReceive+0x188>)
				pcOriginalReadPosition = pxQueue->u.pcReadFrom;
     a62:	68e6      	ldr	r6, [r4, #12]
				prvCopyDataFromQueue(pxQueue, pvBuffer);
     a64:	4641      	mov	r1, r8
     a66:	4620      	mov	r0, r4
     a68:	4798      	blx	r3
				if (xJustPeeking == pdFALSE) {
     a6a:	f1b9 0f00 	cmp.w	r9, #0
     a6e:	d1a1      	bne.n	9b4 <xQueueGenericReceive+0x64>
					--(pxQueue->uxMessagesWaiting);
     a70:	6ba3      	ldr	r3, [r4, #56]	; 0x38
     a72:	3b01      	subs	r3, #1
     a74:	63a3      	str	r3, [r4, #56]	; 0x38
						if (pxQueue->uxQueueType == queueQUEUE_IS_MUTEX) {
     a76:	6823      	ldr	r3, [r4, #0]
     a78:	b913      	cbnz	r3, a80 <xQueueGenericReceive+0x130>
							    = (int8_t *)pvTaskIncrementMutexHeldCount(); /*lint !e961 Cast is not redundant as
     a7a:	4b18      	ldr	r3, [pc, #96]	; (adc <xQueueGenericReceive+0x18c>)
     a7c:	4798      	blx	r3
     a7e:	6060      	str	r0, [r4, #4]
					if (listLIST_IS_EMPTY(&(pxQueue->xTasksWaitingToSend)) == pdFALSE) {
     a80:	6923      	ldr	r3, [r4, #16]
     a82:	2b00      	cmp	r3, #0
     a84:	d09f      	beq.n	9c6 <xQueueGenericReceive+0x76>
						if (xTaskRemoveFromEventList(&(pxQueue->xTasksWaitingToSend)) == pdTRUE) {
     a86:	4b0c      	ldr	r3, [pc, #48]	; (ab8 <xQueueGenericReceive+0x168>)
     a88:	f104 0010 	add.w	r0, r4, #16
     a8c:	4798      	blx	r3
     a8e:	2801      	cmp	r0, #1
     a90:	d199      	bne.n	9c6 <xQueueGenericReceive+0x76>
							queueYIELD_IF_USING_PREEMPTION();
     a92:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
     a96:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
     a9a:	f8c3 2d04 	str.w	r2, [r3, #3332]	; 0xd04
     a9e:	f3bf 8f4f 	dsb	sy
     aa2:	f3bf 8f6f 	isb	sy
     aa6:	e78e      	b.n	9c6 <xQueueGenericReceive+0x76>
			prvUnlockQueue(pxQueue);
     aa8:	4620      	mov	r0, r4
     aaa:	47b8      	blx	r7
			(void)xTaskResumeAll();
     aac:	47b0      	blx	r6
     aae:	e792      	b.n	9d6 <xQueueGenericReceive+0x86>
     ab0:	000092d5 	.word	0x000092d5
     ab4:	00009d95 	.word	0x00009d95
     ab8:	000091a1 	.word	0x000091a1
     abc:	00009221 	.word	0x00009221
     ac0:	00008d85 	.word	0x00008d85
     ac4:	00000429 	.word	0x00000429
     ac8:	00008e99 	.word	0x00008e99
     acc:	00009249 	.word	0x00009249
     ad0:	000092f5 	.word	0x000092f5
     ad4:	000090e9 	.word	0x000090e9
     ad8:	000003f9 	.word	0x000003f9
     adc:	000093fd 	.word	0x000093fd
     ae0:	00009d55 	.word	0x00009d55

00000ae4 <vQueueDelete>:
	configASSERT(pxQueue);
     ae4:	b940      	cbnz	r0, af8 <vQueueDelete+0x14>
     ae6:	f04f 0380 	mov.w	r3, #128	; 0x80
     aea:	f383 8811 	msr	BASEPRI, r3
     aee:	f3bf 8f6f 	isb	sy
     af2:	f3bf 8f4f 	dsb	sy
     af6:	e7fe      	b.n	af6 <vQueueDelete+0x12>
	vPortFree(pxQueue);
     af8:	4b00      	ldr	r3, [pc, #0]	; (afc <vQueueDelete+0x18>)
     afa:	4718      	bx	r3
     afc:	00001db5 	.word	0x00001db5

00000b00 <vQueueWaitForMessageRestricted>:
{
     b00:	b570      	push	{r4, r5, r6, lr}
     b02:	4604      	mov	r4, r0
	prvLockQueue(pxQueue);
     b04:	4b0e      	ldr	r3, [pc, #56]	; (b40 <vQueueWaitForMessageRestricted+0x40>)
{
     b06:	460d      	mov	r5, r1
     b08:	4616      	mov	r6, r2
	prvLockQueue(pxQueue);
     b0a:	4798      	blx	r3
     b0c:	6c63      	ldr	r3, [r4, #68]	; 0x44
     b0e:	3301      	adds	r3, #1
     b10:	bf04      	itt	eq
     b12:	2300      	moveq	r3, #0
     b14:	6463      	streq	r3, [r4, #68]	; 0x44
     b16:	6ca3      	ldr	r3, [r4, #72]	; 0x48
     b18:	3301      	adds	r3, #1
     b1a:	bf04      	itt	eq
     b1c:	2300      	moveq	r3, #0
     b1e:	64a3      	streq	r3, [r4, #72]	; 0x48
     b20:	4b08      	ldr	r3, [pc, #32]	; (b44 <vQueueWaitForMessageRestricted+0x44>)
     b22:	4798      	blx	r3
	if (pxQueue->uxMessagesWaiting == (UBaseType_t)0U) {
     b24:	6ba3      	ldr	r3, [r4, #56]	; 0x38
     b26:	b92b      	cbnz	r3, b34 <vQueueWaitForMessageRestricted+0x34>
		vTaskPlaceOnEventListRestricted(&(pxQueue->xTasksWaitingToReceive), xTicksToWait, xWaitIndefinitely);
     b28:	4b07      	ldr	r3, [pc, #28]	; (b48 <vQueueWaitForMessageRestricted+0x48>)
     b2a:	4632      	mov	r2, r6
     b2c:	4629      	mov	r1, r5
     b2e:	f104 0024 	add.w	r0, r4, #36	; 0x24
     b32:	4798      	blx	r3
	prvUnlockQueue(pxQueue);
     b34:	4620      	mov	r0, r4
     b36:	4b05      	ldr	r3, [pc, #20]	; (b4c <vQueueWaitForMessageRestricted+0x4c>)
}
     b38:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	prvUnlockQueue(pxQueue);
     b3c:	4718      	bx	r3
     b3e:	bf00      	nop
     b40:	00009d55 	.word	0x00009d55
     b44:	00009d95 	.word	0x00009d95
     b48:	00009145 	.word	0x00009145
     b4c:	00000429 	.word	0x00000429

00000b50 <_sbrk>:
extern caddr_t _sbrk(int incr)
{
	static unsigned char *heap = NULL;
	unsigned char *       prev_heap;

	if (heap == NULL) {
     b50:	4a04      	ldr	r2, [pc, #16]	; (b64 <_sbrk+0x14>)
     b52:	6811      	ldr	r1, [r2, #0]
{
     b54:	4603      	mov	r3, r0
	if (heap == NULL) {
     b56:	b909      	cbnz	r1, b5c <_sbrk+0xc>
		heap = (unsigned char *)&_end;
     b58:	4903      	ldr	r1, [pc, #12]	; (b68 <_sbrk+0x18>)
     b5a:	6011      	str	r1, [r2, #0]
	}
	prev_heap = heap;
     b5c:	6810      	ldr	r0, [r2, #0]

	heap += incr;
     b5e:	4403      	add	r3, r0
     b60:	6013      	str	r3, [r2, #0]

	return (caddr_t)prev_heap;
}
     b62:	4770      	bx	lr
     b64:	200000a0 	.word	0x200000a0
     b68:	20026410 	.word	0x20026410

00000b6c <_close>:
 */
extern int _close(int file)
{
	(void)file;
	return -1;
}
     b6c:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
     b70:	4770      	bx	lr

00000b72 <_fstat>:
 * \brief Replacement of C library of _fstat
 */
extern int _fstat(int file, struct stat *st)
{
	(void)file;
	st->st_mode = S_IFCHR;
     b72:	f44f 5300 	mov.w	r3, #8192	; 0x2000
     b76:	604b      	str	r3, [r1, #4]

	return 0;
}
     b78:	2000      	movs	r0, #0
     b7a:	4770      	bx	lr

00000b7c <_isatty>:
 */
extern int _isatty(int file)
{
	(void)file;
	return 1;
}
     b7c:	2001      	movs	r0, #1
     b7e:	4770      	bx	lr

00000b80 <_lseek>:
 */
extern int _lseek(int file, int ptr, int dir)
{
	(void)file, (void)ptr, (void)dir;
	return 0;
}
     b80:	2000      	movs	r0, #0
     b82:	4770      	bx	lr

00000b84 <icmp_send_response>:
 *          p->payload pointing to the IP header
 * @param type Type of the ICMP header
 * @param code Code of the ICMP header
 */
static void icmp_send_response(struct pbuf *p, u8_t type, u8_t code)
{
     b84:	e92d 41ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, lr}
	/* we can use the echo header here */
	struct icmp_echo_hdr *icmphdr;
	ip_addr_t             iphdr_src;

	/* ICMP header + IP header + 8 bytes of data */
	q = pbuf_alloc(PBUF_IP, sizeof(struct icmp_echo_hdr) + IP_HLEN + ICMP_DEST_UNREACH_DATASIZE, PBUF_RAM);
     b88:	4b1b      	ldr	r3, [pc, #108]	; (bf8 <icmp_send_response+0x74>)
{
     b8a:	4604      	mov	r4, r0
     b8c:	4688      	mov	r8, r1
     b8e:	4616      	mov	r6, r2
	q = pbuf_alloc(PBUF_IP, sizeof(struct icmp_echo_hdr) + IP_HLEN + ICMP_DEST_UNREACH_DATASIZE, PBUF_RAM);
     b90:	2124      	movs	r1, #36	; 0x24
     b92:	2200      	movs	r2, #0
     b94:	2001      	movs	r0, #1
     b96:	4798      	blx	r3
	if (q == NULL) {
     b98:	4605      	mov	r5, r0
     b9a:	b350      	cbz	r0, bf2 <icmp_send_response+0x6e>
		return;
	}
	LWIP_ASSERT("check that first pbuf can hold icmp message",
	            (q->len >= (sizeof(struct icmp_echo_hdr) + IP_HLEN + ICMP_DEST_UNREACH_DATASIZE)));

	iphdr = (struct ip_hdr *)p->payload;
     b9c:	6867      	ldr	r7, [r4, #4]
	ip_addr_debug_print(ICMP_DEBUG, &(iphdr->src));
	LWIP_DEBUGF(ICMP_DEBUG, (" to "));
	ip_addr_debug_print(ICMP_DEBUG, &(iphdr->dest));
	LWIP_DEBUGF(ICMP_DEBUG, ("\n"));

	icmphdr        = (struct icmp_echo_hdr *)q->payload;
     b9e:	6844      	ldr	r4, [r0, #4]
	icmphdr->type  = type;
	icmphdr->code  = code;
	icmphdr->id    = 0;
     ba0:	2300      	movs	r3, #0
     ba2:	7123      	strb	r3, [r4, #4]
     ba4:	7163      	strb	r3, [r4, #5]
	icmphdr->seqno = 0;
     ba6:	71a3      	strb	r3, [r4, #6]
     ba8:	71e3      	strb	r3, [r4, #7]
	icmphdr->type  = type;
     baa:	f884 8000 	strb.w	r8, [r4]
	icmphdr->code  = code;
     bae:	7066      	strb	r6, [r4, #1]

	/* copy fields from original packet */
	SMEMCPY(
     bb0:	463b      	mov	r3, r7
     bb2:	f104 0208 	add.w	r2, r4, #8
     bb6:	f107 011c 	add.w	r1, r7, #28
     bba:	f853 0b04 	ldr.w	r0, [r3], #4
     bbe:	f842 0b04 	str.w	r0, [r2], #4
     bc2:	428b      	cmp	r3, r1
     bc4:	d1f9      	bne.n	bba <icmp_send_response+0x36>
	    (u8_t *)q->payload + sizeof(struct icmp_echo_hdr), (u8_t *)p->payload, IP_HLEN + ICMP_DEST_UNREACH_DATASIZE);

	/* calculate checksum */
	icmphdr->chksum = 0;
     bc6:	2600      	movs	r6, #0
	icmphdr->chksum = inet_chksum(icmphdr, q->len);
     bc8:	8969      	ldrh	r1, [r5, #10]
     bca:	4b0c      	ldr	r3, [pc, #48]	; (bfc <icmp_send_response+0x78>)
	icmphdr->chksum = 0;
     bcc:	70a6      	strb	r6, [r4, #2]
     bce:	70e6      	strb	r6, [r4, #3]
	icmphdr->chksum = inet_chksum(icmphdr, q->len);
     bd0:	4620      	mov	r0, r4
     bd2:	4798      	blx	r3
     bd4:	8060      	strh	r0, [r4, #2]
	ICMP_STATS_INC(icmp.xmit);
	/* increase number of messages attempted to send */
	snmp_inc_icmpoutmsgs();
	/* increase number of destination unreachable messages attempted to send */
	snmp_inc_icmpouttimeexcds();
	ip_addr_copy(iphdr_src, iphdr->src);
     bd6:	68fb      	ldr	r3, [r7, #12]
     bd8:	9303      	str	r3, [sp, #12]
	ip_output(q, NULL, &iphdr_src, ICMP_TTL, 0, IP_PROTO_ICMP);
     bda:	2301      	movs	r3, #1
     bdc:	e9cd 6300 	strd	r6, r3, [sp]
     be0:	4c07      	ldr	r4, [pc, #28]	; (c00 <icmp_send_response+0x7c>)
     be2:	23ff      	movs	r3, #255	; 0xff
     be4:	aa03      	add	r2, sp, #12
     be6:	4631      	mov	r1, r6
     be8:	4628      	mov	r0, r5
     bea:	47a0      	blx	r4
	pbuf_free(q);
     bec:	4b05      	ldr	r3, [pc, #20]	; (c04 <icmp_send_response+0x80>)
     bee:	4628      	mov	r0, r5
     bf0:	4798      	blx	r3
}
     bf2:	b004      	add	sp, #16
     bf4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
     bf8:	0000313d 	.word	0x0000313d
     bfc:	00008415 	.word	0x00008415
     c00:	000065f9 	.word	0x000065f9
     c04:	000030e5 	.word	0x000030e5

00000c08 <icmp_input>:
{
     c08:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	iphdr = (struct ip_hdr *)p->payload;
     c0c:	6846      	ldr	r6, [r0, #4]
	if (pbuf_header(p, -hlen) || (p->tot_len < sizeof(u16_t) * 2)) {
     c0e:	4f45      	ldr	r7, [pc, #276]	; (d24 <icmp_input+0x11c>)
	hlen  = IPH_HL(iphdr) * 4;
     c10:	7835      	ldrb	r5, [r6, #0]
     c12:	f8df 8134 	ldr.w	r8, [pc, #308]	; d48 <icmp_input+0x140>
     c16:	f005 050f 	and.w	r5, r5, #15
     c1a:	00ad      	lsls	r5, r5, #2
{
     c1c:	b087      	sub	sp, #28
	if (pbuf_header(p, -hlen) || (p->tot_len < sizeof(u16_t) * 2)) {
     c1e:	f1c5 0a00 	rsb	sl, r5, #0
     c22:	fa0f fa8a 	sxth.w	sl, sl
{
     c26:	9105      	str	r1, [sp, #20]
	if (pbuf_header(p, -hlen) || (p->tot_len < sizeof(u16_t) * 2)) {
     c28:	4651      	mov	r1, sl
{
     c2a:	4604      	mov	r4, r0
	if (pbuf_header(p, -hlen) || (p->tot_len < sizeof(u16_t) * 2)) {
     c2c:	47b8      	blx	r7
     c2e:	b998      	cbnz	r0, c58 <icmp_input+0x50>
     c30:	8923      	ldrh	r3, [r4, #8]
     c32:	2b03      	cmp	r3, #3
     c34:	d910      	bls.n	c58 <icmp_input+0x50>
	type = *((u8_t *)p->payload);
     c36:	6863      	ldr	r3, [r4, #4]
	switch (type) {
     c38:	781b      	ldrb	r3, [r3, #0]
     c3a:	2b08      	cmp	r3, #8
     c3c:	d10c      	bne.n	c58 <icmp_input+0x50>
		if (ip_addr_ismulticast(&current_iphdr_dest)) {
     c3e:	f8df b100 	ldr.w	fp, [pc, #256]	; d40 <icmp_input+0x138>
		if (ip_addr_isbroadcast(&current_iphdr_dest, inp)) {
     c42:	9905      	ldr	r1, [sp, #20]
		if (ip_addr_ismulticast(&current_iphdr_dest)) {
     c44:	f8db 0000 	ldr.w	r0, [fp]
		if (ip_addr_isbroadcast(&current_iphdr_dest, inp)) {
     c48:	4a37      	ldr	r2, [pc, #220]	; (d28 <icmp_input+0x120>)
		if (ip_addr_ismulticast(&current_iphdr_dest)) {
     c4a:	f000 09f0 	and.w	r9, r0, #240	; 0xf0
		if (ip_addr_isbroadcast(&current_iphdr_dest, inp)) {
     c4e:	4790      	blx	r2
     c50:	b910      	cbnz	r0, c58 <icmp_input+0x50>
		if (!accepted) {
     c52:	f1b9 0fe0 	cmp.w	r9, #224	; 0xe0
     c56:	d105      	bne.n	c64 <icmp_input+0x5c>
	pbuf_free(p);
     c58:	4620      	mov	r0, r4
     c5a:	4643      	mov	r3, r8
}
     c5c:	b007      	add	sp, #28
     c5e:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	pbuf_free(p);
     c62:	4718      	bx	r3
		if (p->tot_len < sizeof(struct icmp_echo_hdr)) {
     c64:	8923      	ldrh	r3, [r4, #8]
     c66:	2b07      	cmp	r3, #7
     c68:	d9f6      	bls.n	c58 <icmp_input+0x50>
		if (inet_chksum_pbuf(p) != 0) {
     c6a:	4b30      	ldr	r3, [pc, #192]	; (d2c <icmp_input+0x124>)
     c6c:	4620      	mov	r0, r4
     c6e:	4798      	blx	r3
     c70:	2800      	cmp	r0, #0
     c72:	d1f1      	bne.n	c58 <icmp_input+0x50>
		if (pbuf_header(p, (PBUF_IP_HLEN + PBUF_LINK_HLEN))) {
     c74:	2124      	movs	r1, #36	; 0x24
     c76:	4620      	mov	r0, r4
	hlen  = IPH_HL(iphdr) * 4;
     c78:	b22d      	sxth	r5, r5
		if (pbuf_header(p, (PBUF_IP_HLEN + PBUF_LINK_HLEN))) {
     c7a:	47b8      	blx	r7
     c7c:	2800      	cmp	r0, #0
     c7e:	d04a      	beq.n	d16 <icmp_input+0x10e>
			if (pbuf_header(p, hlen)) {
     c80:	4629      	mov	r1, r5
     c82:	4620      	mov	r0, r4
     c84:	47b8      	blx	r7
     c86:	4602      	mov	r2, r0
     c88:	2800      	cmp	r0, #0
     c8a:	d1e5      	bne.n	c58 <icmp_input+0x50>
			r = pbuf_alloc(PBUF_LINK, p->tot_len, PBUF_RAM);
     c8c:	8921      	ldrh	r1, [r4, #8]
     c8e:	4b28      	ldr	r3, [pc, #160]	; (d30 <icmp_input+0x128>)
     c90:	2002      	movs	r0, #2
     c92:	4798      	blx	r3
			if (r == NULL) {
     c94:	4681      	mov	r9, r0
     c96:	2800      	cmp	r0, #0
     c98:	d0de      	beq.n	c58 <icmp_input+0x50>
			if (pbuf_copy(r, p) != ERR_OK) {
     c9a:	4a26      	ldr	r2, [pc, #152]	; (d34 <icmp_input+0x12c>)
     c9c:	4621      	mov	r1, r4
     c9e:	4790      	blx	r2
     ca0:	2800      	cmp	r0, #0
     ca2:	d1d9      	bne.n	c58 <icmp_input+0x50>
			if (pbuf_header(r, -hlen)) {
     ca4:	4651      	mov	r1, sl
     ca6:	4648      	mov	r0, r9
			iphdr = (struct ip_hdr *)r->payload;
     ca8:	f8d9 6004 	ldr.w	r6, [r9, #4]
			if (pbuf_header(r, -hlen)) {
     cac:	47b8      	blx	r7
     cae:	2800      	cmp	r0, #0
     cb0:	d1d2      	bne.n	c58 <icmp_input+0x50>
			pbuf_free(p);
     cb2:	4620      	mov	r0, r4
     cb4:	47c0      	blx	r8
			p = r;
     cb6:	464c      	mov	r4, r9
		ip_addr_copy(iphdr->src, *ip_current_dest_addr());
     cb8:	f8db 3000 	ldr.w	r3, [fp]
		iecho = (struct icmp_echo_hdr *)p->payload;
     cbc:	6862      	ldr	r2, [r4, #4]
		ip_addr_copy(iphdr->src, *ip_current_dest_addr());
     cbe:	60f3      	str	r3, [r6, #12]
		ip_addr_copy(iphdr->dest, *ip_current_src_addr());
     cc0:	4b1d      	ldr	r3, [pc, #116]	; (d38 <icmp_input+0x130>)
     cc2:	681b      	ldr	r3, [r3, #0]
     cc4:	6133      	str	r3, [r6, #16]
		ICMPH_TYPE_SET(iecho, ICMP_ER);
     cc6:	2300      	movs	r3, #0
     cc8:	7013      	strb	r3, [r2, #0]
		if (iecho->chksum >= PP_HTONS(0xffffU - (ICMP_ECHO << 8))) {
     cca:	8853      	ldrh	r3, [r2, #2]
     ccc:	f64f 71f6 	movw	r1, #65526	; 0xfff6
     cd0:	428b      	cmp	r3, r1
			iecho->chksum += PP_HTONS(ICMP_ECHO << 8) + 1;
     cd2:	bf8c      	ite	hi
     cd4:	3309      	addhi	r3, #9
			iecho->chksum += PP_HTONS(ICMP_ECHO << 8);
     cd6:	3308      	addls	r3, #8
     cd8:	b29b      	uxth	r3, r3
     cda:	8053      	strh	r3, [r2, #2]
		IPH_TTL_SET(iphdr, ICMP_TTL);
     cdc:	f04f 0aff 	mov.w	sl, #255	; 0xff
		IPH_CHKSUM_SET(iphdr, 0);
     ce0:	2300      	movs	r3, #0
     ce2:	72b3      	strb	r3, [r6, #10]
     ce4:	72f3      	strb	r3, [r6, #11]
		IPH_CHKSUM_SET(iphdr, inet_chksum(iphdr, IP_HLEN));
     ce6:	2114      	movs	r1, #20
     ce8:	4b14      	ldr	r3, [pc, #80]	; (d3c <icmp_input+0x134>)
		IPH_TTL_SET(iphdr, ICMP_TTL);
     cea:	f886 a008 	strb.w	sl, [r6, #8]
		IPH_CHKSUM_SET(iphdr, inet_chksum(iphdr, IP_HLEN));
     cee:	4630      	mov	r0, r6
     cf0:	4798      	blx	r3
		if (pbuf_header(p, hlen)) {
     cf2:	4629      	mov	r1, r5
		IPH_CHKSUM_SET(iphdr, inet_chksum(iphdr, IP_HLEN));
     cf4:	8170      	strh	r0, [r6, #10]
		if (pbuf_header(p, hlen)) {
     cf6:	4620      	mov	r0, r4
     cf8:	47b8      	blx	r7
     cfa:	4602      	mov	r2, r0
     cfc:	2800      	cmp	r0, #0
     cfe:	d1ab      	bne.n	c58 <icmp_input+0x50>
			ret = ip_output_if(p, ip_current_dest_addr(), IP_HDRINCL, ICMP_TTL, 0, IP_PROTO_ICMP, inp);
     d00:	9b05      	ldr	r3, [sp, #20]
     d02:	9302      	str	r3, [sp, #8]
     d04:	2301      	movs	r3, #1
     d06:	e9cd 0300 	strd	r0, r3, [sp]
     d0a:	490d      	ldr	r1, [pc, #52]	; (d40 <icmp_input+0x138>)
     d0c:	4d0d      	ldr	r5, [pc, #52]	; (d44 <icmp_input+0x13c>)
     d0e:	4653      	mov	r3, sl
     d10:	4620      	mov	r0, r4
     d12:	47a8      	blx	r5
	pbuf_free(p);
     d14:	e7a0      	b.n	c58 <icmp_input+0x50>
			if (pbuf_header(p, -(s16_t)(PBUF_IP_HLEN + PBUF_LINK_HLEN))) {
     d16:	f06f 0123 	mvn.w	r1, #35	; 0x23
     d1a:	4620      	mov	r0, r4
     d1c:	47b8      	blx	r7
     d1e:	2800      	cmp	r0, #0
     d20:	d0ca      	beq.n	cb8 <icmp_input+0xb0>
     d22:	e799      	b.n	c58 <icmp_input+0x50>
     d24:	0000308d 	.word	0x0000308d
     d28:	00008a1b 	.word	0x00008a1b
     d2c:	00008425 	.word	0x00008425
     d30:	0000313d 	.word	0x0000313d
     d34:	000032f1 	.word	0x000032f1
     d38:	20011108 	.word	0x20011108
     d3c:	00008415 	.word	0x00008415
     d40:	20011104 	.word	0x20011104
     d44:	0000650d 	.word	0x0000650d
     d48:	000030e5 	.word	0x000030e5

00000d4c <icmp_dest_unreach>:
{
     d4c:	460a      	mov	r2, r1
	icmp_send_response(p, ICMP_DUR, t);
     d4e:	4b01      	ldr	r3, [pc, #4]	; (d54 <icmp_dest_unreach+0x8>)
     d50:	2103      	movs	r1, #3
     d52:	4718      	bx	r3
     d54:	00000b85 	.word	0x00000b85

00000d58 <icmp_time_exceeded>:
{
     d58:	460a      	mov	r2, r1
	icmp_send_response(p, ICMP_TE, t);
     d5a:	4b01      	ldr	r3, [pc, #4]	; (d60 <icmp_time_exceeded+0x8>)
     d5c:	210b      	movs	r1, #11
     d5e:	4718      	bx	r3
     d60:	00000b85 	.word	0x00000b85

00000d64 <lwip_htons>:
 * @param n u16_t in host byte order
 * @return n in network byte order
 */
u16_t lwip_htons(u16_t n)
{
	return ((n & 0xff) << 8) | ((n & 0xff00) >> 8);
     d64:	ba40      	rev16	r0, r0
}
     d66:	b280      	uxth	r0, r0
     d68:	4770      	bx	lr

00000d6a <lwip_ntohs>:
     d6a:	ba40      	rev16	r0, r0
     d6c:	b280      	uxth	r0, r0
     d6e:	4770      	bx	lr

00000d70 <lwip_htonl>:
 * @return n in network byte order
 */
u32_t lwip_htonl(u32_t n)
{
	return ((n & 0xff) << 24) | ((n & 0xff00) << 8) | ((n & 0xff0000UL) >> 8) | ((n & 0xff000000UL) >> 24);
}
     d70:	ba00      	rev	r0, r0
     d72:	4770      	bx	lr

00000d74 <lwip_ntohl>:
 * @param n u32_t in network byte order
 * @return n in host byte order
 */
u32_t lwip_ntohl(u32_t n)
{
	return lwip_htonl(n);
     d74:	4b00      	ldr	r3, [pc, #0]	; (d78 <lwip_ntohl+0x4>)
     d76:	4718      	bx	r3
     d78:	00000d71 	.word	0x00000d71

00000d7c <netbuf_delete>:
 * Deallocate a netbuf allocated by netbuf_new().
 *
 * @param buf pointer to a netbuf allocated by netbuf_new()
 */
void netbuf_delete(struct netbuf *buf)
{
     d7c:	b510      	push	{r4, lr}
	if (buf != NULL) {
     d7e:	4604      	mov	r4, r0
     d80:	b160      	cbz	r0, d9c <netbuf_delete+0x20>
		if (buf->p != NULL) {
     d82:	6800      	ldr	r0, [r0, #0]
     d84:	b120      	cbz	r0, d90 <netbuf_delete+0x14>
			pbuf_free(buf->p);
     d86:	4b06      	ldr	r3, [pc, #24]	; (da0 <netbuf_delete+0x24>)
     d88:	4798      	blx	r3
			buf->p = buf->ptr = NULL;
     d8a:	2300      	movs	r3, #0
     d8c:	e9c4 3300 	strd	r3, r3, [r4]
		}
		memp_free(MEMP_NETBUF, buf);
     d90:	4621      	mov	r1, r4
     d92:	4b04      	ldr	r3, [pc, #16]	; (da4 <netbuf_delete+0x28>)
	}
}
     d94:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		memp_free(MEMP_NETBUF, buf);
     d98:	2006      	movs	r0, #6
     d9a:	4718      	bx	r3
}
     d9c:	bd10      	pop	{r4, pc}
     d9e:	bf00      	nop
     da0:	000030e5 	.word	0x000030e5
     da4:	00004c1d 	.word	0x00004c1d

00000da8 <netbuf_free>:
 * Free the packet buffer included in a netbuf
 *
 * @param buf pointer to the netbuf which contains the packet buffer to free
 */
void netbuf_free(struct netbuf *buf)
{
     da8:	b510      	push	{r4, lr}
	LWIP_ERROR("netbuf_free: invalid buf", (buf != NULL), return;);
     daa:	4604      	mov	r4, r0
     dac:	b900      	cbnz	r0, db0 <netbuf_free+0x8>
     dae:	e7fe      	b.n	dae <netbuf_free+0x6>
	if (buf->p != NULL) {
     db0:	6800      	ldr	r0, [r0, #0]
     db2:	b108      	cbz	r0, db8 <netbuf_free+0x10>
		pbuf_free(buf->p);
     db4:	4b02      	ldr	r3, [pc, #8]	; (dc0 <netbuf_free+0x18>)
     db6:	4798      	blx	r3
	}
	buf->p = buf->ptr = NULL;
     db8:	2300      	movs	r3, #0
     dba:	e9c4 3300 	strd	r3, r3, [r4]
}
     dbe:	bd10      	pop	{r4, pc}
     dc0:	000030e5 	.word	0x000030e5

00000dc4 <netbuf_ref>:
 * @param size size of the data
 * @return ERR_OK if data is referenced
 *         ERR_MEM if data couldn't be referenced due to lack of memory
 */
err_t netbuf_ref(struct netbuf *buf, const void *dataptr, u16_t size)
{
     dc4:	b570      	push	{r4, r5, r6, lr}
     dc6:	460e      	mov	r6, r1
     dc8:	4615      	mov	r5, r2
	LWIP_ERROR("netbuf_ref: invalid buf", (buf != NULL), return ERR_ARG;);
     dca:	4604      	mov	r4, r0
     dcc:	b900      	cbnz	r0, dd0 <netbuf_ref+0xc>
     dce:	e7fe      	b.n	dce <netbuf_ref+0xa>
	if (buf->p != NULL) {
     dd0:	6800      	ldr	r0, [r0, #0]
     dd2:	b108      	cbz	r0, dd8 <netbuf_ref+0x14>
		pbuf_free(buf->p);
     dd4:	4b09      	ldr	r3, [pc, #36]	; (dfc <netbuf_ref+0x38>)
     dd6:	4798      	blx	r3
	}
	buf->p = pbuf_alloc(PBUF_TRANSPORT, 0, PBUF_REF);
     dd8:	2100      	movs	r1, #0
     dda:	4b09      	ldr	r3, [pc, #36]	; (e00 <netbuf_ref+0x3c>)
     ddc:	2202      	movs	r2, #2
     dde:	4608      	mov	r0, r1
     de0:	4798      	blx	r3
     de2:	6020      	str	r0, [r4, #0]
	if (buf->p == NULL) {
     de4:	b918      	cbnz	r0, dee <netbuf_ref+0x2a>
		buf->ptr = NULL;
     de6:	6060      	str	r0, [r4, #4]
		return ERR_MEM;
     de8:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
	}
	buf->p->payload = (void *)dataptr;
	buf->p->len = buf->p->tot_len = size;
	buf->ptr                      = buf->p;
	return ERR_OK;
}
     dec:	bd70      	pop	{r4, r5, r6, pc}
	buf->p->payload = (void *)dataptr;
     dee:	6046      	str	r6, [r0, #4]
	buf->p->len = buf->p->tot_len = size;
     df0:	8105      	strh	r5, [r0, #8]
     df2:	8145      	strh	r5, [r0, #10]
	buf->ptr                      = buf->p;
     df4:	6060      	str	r0, [r4, #4]
	return ERR_OK;
     df6:	2000      	movs	r0, #0
     df8:	e7f8      	b.n	dec <netbuf_ref+0x28>
     dfa:	bf00      	nop
     dfc:	000030e5 	.word	0x000030e5
     e00:	0000313d 	.word	0x0000313d

00000e04 <ETHERNET_PHY_0_init>:
#include <ethernet_phy_main.h>

struct ethernet_phy_descriptor ETHERNET_PHY_0_desc;

void ETHERNET_PHY_0_init(void)
{
     e04:	b510      	push	{r4, lr}
	mac_async_enable(&COMMUNICATION_IO);
     e06:	4905      	ldr	r1, [pc, #20]	; (e1c <ETHERNET_PHY_0_init+0x18>)
     e08:	4b05      	ldr	r3, [pc, #20]	; (e20 <ETHERNET_PHY_0_init+0x1c>)
     e0a:	4608      	mov	r0, r1
     e0c:	4798      	blx	r3
	ethernet_phy_init(&ETHERNET_PHY_0_desc, &COMMUNICATION_IO, CONF_ETHERNET_PHY_0_IEEE8023_MII_PHY_ADDRESS);
#if CONF_ETHERNET_PHY_0_IEEE8023_MII_CONTROL_REG0_SETTING == 1
	ethernet_phy_write_reg(&ETHERNET_PHY_0_desc, MDIO_REG0_BMCR, CONF_ETHERNET_PHY_0_IEEE8023_MII_CONTROL_REG0);
#endif /* CONF_ETHERNET_PHY_0_IEEE8023_MII_CONTROL_REG0_SETTING */
}
     e0e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	ethernet_phy_init(&ETHERNET_PHY_0_desc, &COMMUNICATION_IO, CONF_ETHERNET_PHY_0_IEEE8023_MII_PHY_ADDRESS);
     e12:	4902      	ldr	r1, [pc, #8]	; (e1c <ETHERNET_PHY_0_init+0x18>)
     e14:	4803      	ldr	r0, [pc, #12]	; (e24 <ETHERNET_PHY_0_init+0x20>)
     e16:	4b04      	ldr	r3, [pc, #16]	; (e28 <ETHERNET_PHY_0_init+0x24>)
     e18:	2200      	movs	r2, #0
     e1a:	4718      	bx	r3
     e1c:	2000a520 	.word	0x2000a520
     e20:	00004c71 	.word	0x00004c71
     e24:	200000a4 	.word	0x200000a4
     e28:	00000fd5 	.word	0x00000fd5

00000e2c <ethernet_phys_init>:
}

void ethernet_phys_init(void)
{

	ETHERNET_PHY_0_init();
     e2c:	4b00      	ldr	r3, [pc, #0]	; (e30 <ethernet_phys_init+0x4>)
     e2e:	4718      	bx	r3
     e30:	00000e05 	.word	0x00000e05

00000e34 <usart_sync_write>:
 * \param[in] length The number of bytes to write
 *
 * \return The number of bytes written.
 */
static int32_t usart_sync_write(struct io_descriptor *const io_descr, const uint8_t *const buf, const uint16_t length)
{
     e34:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
     e38:	460e      	mov	r6, r1
     e3a:	4615      	mov	r5, r2
	uint32_t                      offset = 0;
	struct usart_sync_descriptor *descr  = CONTAINER_OF(io_descr, struct usart_sync_descriptor, io);

	ASSERT(io_descr && buf && length);
     e3c:	4604      	mov	r4, r0
     e3e:	b118      	cbz	r0, e48 <usart_sync_write+0x14>
     e40:	b329      	cbz	r1, e8e <usart_sync_write+0x5a>
     e42:	1e10      	subs	r0, r2, #0
     e44:	bf18      	it	ne
     e46:	2001      	movne	r0, #1
     e48:	4912      	ldr	r1, [pc, #72]	; (e94 <usart_sync_write+0x60>)
     e4a:	4b13      	ldr	r3, [pc, #76]	; (e98 <usart_sync_write+0x64>)
	while (!_usart_sync_is_ready_to_send(&descr->device))
     e4c:	4f13      	ldr	r7, [pc, #76]	; (e9c <usart_sync_write+0x68>)
	ASSERT(io_descr && buf && length);
     e4e:	22f1      	movs	r2, #241	; 0xf1
     e50:	4798      	blx	r3
	while (!_usart_sync_is_ready_to_send(&descr->device))
     e52:	3408      	adds	r4, #8
     e54:	46b9      	mov	r9, r7
     e56:	4620      	mov	r0, r4
     e58:	47b8      	blx	r7
     e5a:	2800      	cmp	r0, #0
     e5c:	d0fb      	beq.n	e56 <usart_sync_write+0x22>
		;
	do {
		_usart_sync_write_byte(&descr->device, buf[offset]);
     e5e:	f8df 8044 	ldr.w	r8, [pc, #68]	; ea4 <usart_sync_write+0x70>
	uint32_t                      offset = 0;
     e62:	2700      	movs	r7, #0
		_usart_sync_write_byte(&descr->device, buf[offset]);
     e64:	5df1      	ldrb	r1, [r6, r7]
     e66:	4620      	mov	r0, r4
     e68:	47c0      	blx	r8
		while (!_usart_sync_is_ready_to_send(&descr->device))
     e6a:	4620      	mov	r0, r4
     e6c:	47c8      	blx	r9
     e6e:	2800      	cmp	r0, #0
     e70:	d0fb      	beq.n	e6a <usart_sync_write+0x36>
			;
	} while (++offset < length);
     e72:	3701      	adds	r7, #1
     e74:	42bd      	cmp	r5, r7
     e76:	d8f5      	bhi.n	e64 <usart_sync_write+0x30>
     e78:	2d00      	cmp	r5, #0
	while (!_usart_sync_is_transmit_done(&descr->device))
     e7a:	4e09      	ldr	r6, [pc, #36]	; (ea0 <usart_sync_write+0x6c>)
	} while (++offset < length);
     e7c:	bf08      	it	eq
     e7e:	2501      	moveq	r5, #1
	while (!_usart_sync_is_transmit_done(&descr->device))
     e80:	4620      	mov	r0, r4
     e82:	47b0      	blx	r6
     e84:	2800      	cmp	r0, #0
     e86:	d0fb      	beq.n	e80 <usart_sync_write+0x4c>
		;
	return (int32_t)offset;
}
     e88:	4628      	mov	r0, r5
     e8a:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
	ASSERT(io_descr && buf && length);
     e8e:	4608      	mov	r0, r1
     e90:	e7da      	b.n	e48 <usart_sync_write+0x14>
     e92:	bf00      	nop
     e94:	0000b5ec 	.word	0x0000b5ec
     e98:	00008a15 	.word	0x00008a15
     e9c:	00007d57 	.word	0x00007d57
     ea0:	00007d61 	.word	0x00007d61
     ea4:	00007d49 	.word	0x00007d49

00000ea8 <usart_sync_read>:
 * \param[in] length The size of a buffer
 *
 * \return The number of bytes read.
 */
static int32_t usart_sync_read(struct io_descriptor *const io_descr, uint8_t *const buf, const uint16_t length)
{
     ea8:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
     eac:	460e      	mov	r6, r1
     eae:	4615      	mov	r5, r2
	uint32_t                      offset = 0;
	struct usart_sync_descriptor *descr  = CONTAINER_OF(io_descr, struct usart_sync_descriptor, io);

	ASSERT(io_descr && buf && length);
     eb0:	4604      	mov	r4, r0
     eb2:	b118      	cbz	r0, ebc <usart_sync_read+0x14>
     eb4:	b1e9      	cbz	r1, ef2 <usart_sync_read+0x4a>
     eb6:	1e10      	subs	r0, r2, #0
     eb8:	bf18      	it	ne
     eba:	2001      	movne	r0, #1
     ebc:	490e      	ldr	r1, [pc, #56]	; (ef8 <usart_sync_read+0x50>)
     ebe:	4b0f      	ldr	r3, [pc, #60]	; (efc <usart_sync_read+0x54>)
	do {
		while (!_usart_sync_is_byte_received(&descr->device))
     ec0:	f8df 903c 	ldr.w	r9, [pc, #60]	; f00 <usart_sync_read+0x58>
			;
		buf[offset] = _usart_sync_read_byte(&descr->device);
     ec4:	f8df 803c 	ldr.w	r8, [pc, #60]	; f04 <usart_sync_read+0x5c>
	ASSERT(io_descr && buf && length);
     ec8:	f44f 7286 	mov.w	r2, #268	; 0x10c
     ecc:	4798      	blx	r3
	uint32_t                      offset = 0;
     ece:	2700      	movs	r7, #0
		while (!_usart_sync_is_byte_received(&descr->device))
     ed0:	3408      	adds	r4, #8
     ed2:	4620      	mov	r0, r4
     ed4:	47c8      	blx	r9
     ed6:	2800      	cmp	r0, #0
     ed8:	d0fb      	beq.n	ed2 <usart_sync_read+0x2a>
		buf[offset] = _usart_sync_read_byte(&descr->device);
     eda:	4620      	mov	r0, r4
     edc:	47c0      	blx	r8
     ede:	55f0      	strb	r0, [r6, r7]
	} while (++offset < length);
     ee0:	3701      	adds	r7, #1
     ee2:	42bd      	cmp	r5, r7
     ee4:	d8f5      	bhi.n	ed2 <usart_sync_read+0x2a>
     ee6:	2d00      	cmp	r5, #0

	return (int32_t)offset;
}
     ee8:	bf14      	ite	ne
     eea:	4628      	movne	r0, r5
     eec:	2001      	moveq	r0, #1
     eee:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
	ASSERT(io_descr && buf && length);
     ef2:	4608      	mov	r0, r1
     ef4:	e7e2      	b.n	ebc <usart_sync_read+0x14>
     ef6:	bf00      	nop
     ef8:	0000b5ec 	.word	0x0000b5ec
     efc:	00008a15 	.word	0x00008a15
     f00:	00007d6b 	.word	0x00007d6b
     f04:	00007d4f 	.word	0x00007d4f

00000f08 <usart_sync_init>:
{
     f08:	b538      	push	{r3, r4, r5, lr}
     f0a:	460d      	mov	r5, r1
	ASSERT(descr && hw);
     f0c:	4604      	mov	r4, r0
     f0e:	b110      	cbz	r0, f16 <usart_sync_init+0xe>
     f10:	1e08      	subs	r0, r1, #0
     f12:	bf18      	it	ne
     f14:	2001      	movne	r0, #1
     f16:	4907      	ldr	r1, [pc, #28]	; (f34 <usart_sync_init+0x2c>)
     f18:	4b07      	ldr	r3, [pc, #28]	; (f38 <usart_sync_init+0x30>)
     f1a:	2234      	movs	r2, #52	; 0x34
     f1c:	4798      	blx	r3
	init_status = _usart_sync_init(&descr->device, hw);
     f1e:	4b07      	ldr	r3, [pc, #28]	; (f3c <usart_sync_init+0x34>)
     f20:	4629      	mov	r1, r5
     f22:	f104 0008 	add.w	r0, r4, #8
     f26:	4798      	blx	r3
	if (init_status) {
     f28:	b918      	cbnz	r0, f32 <usart_sync_init+0x2a>
	descr->io.read  = usart_sync_read;
     f2a:	4b05      	ldr	r3, [pc, #20]	; (f40 <usart_sync_init+0x38>)
     f2c:	6063      	str	r3, [r4, #4]
	descr->io.write = usart_sync_write;
     f2e:	4b05      	ldr	r3, [pc, #20]	; (f44 <usart_sync_init+0x3c>)
     f30:	6023      	str	r3, [r4, #0]
}
     f32:	bd38      	pop	{r3, r4, r5, pc}
     f34:	0000b5ec 	.word	0x0000b5ec
     f38:	00008a15 	.word	0x00008a15
     f3c:	00007d09 	.word	0x00007d09
     f40:	00000ea9 	.word	0x00000ea9
     f44:	00000e35 	.word	0x00000e35

00000f48 <usart_sync_enable>:
{
     f48:	b510      	push	{r4, lr}
	ASSERT(descr);
     f4a:	4604      	mov	r4, r0
     f4c:	3800      	subs	r0, #0
     f4e:	bf18      	it	ne
     f50:	2001      	movne	r0, #1
     f52:	4905      	ldr	r1, [pc, #20]	; (f68 <usart_sync_enable+0x20>)
     f54:	4b05      	ldr	r3, [pc, #20]	; (f6c <usart_sync_enable+0x24>)
     f56:	2253      	movs	r2, #83	; 0x53
     f58:	4798      	blx	r3
	_usart_sync_enable(&descr->device);
     f5a:	f104 0008 	add.w	r0, r4, #8
     f5e:	4b04      	ldr	r3, [pc, #16]	; (f70 <usart_sync_enable+0x28>)
     f60:	4798      	blx	r3
}
     f62:	2000      	movs	r0, #0
     f64:	bd10      	pop	{r4, pc}
     f66:	bf00      	nop
     f68:	0000b5ec 	.word	0x0000b5ec
     f6c:	00008a15 	.word	0x00008a15
     f70:	00007d35 	.word	0x00007d35

00000f74 <_read>:
#include <stdio.h>

int __attribute__((weak)) _read(int file, char *ptr, int len); /* Remove GCC compiler warning */

int __attribute__((weak)) _read(int file, char *ptr, int len)
{
     f74:	b508      	push	{r3, lr}
     f76:	4603      	mov	r3, r0
     f78:	4608      	mov	r0, r1
     f7a:	4611      	mov	r1, r2
	int n = 0;

	if (file != 0) {
     f7c:	b923      	cbnz	r3, f88 <_read+0x14>
		return -1;
	}

	n = stdio_io_read((uint8_t *)ptr, len);
     f7e:	4b04      	ldr	r3, [pc, #16]	; (f90 <_read+0x1c>)
     f80:	4798      	blx	r3
	if (n < 0) {
     f82:	ea40 70e0 	orr.w	r0, r0, r0, asr #31
		return -1;
	}

	return n;
}
     f86:	bd08      	pop	{r3, pc}
		return -1;
     f88:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
     f8c:	e7fb      	b.n	f86 <_read+0x12>
     f8e:	bf00      	nop
     f90:	000002d1 	.word	0x000002d1

00000f94 <_gclk_init_generators_by_fref>:

void _gclk_init_generators_by_fref(uint32_t bm)
{

#if CONF_GCLK_GENERATOR_0_CONFIG == 1
	if (bm & (1ul << 0)) {
     f94:	07c3      	lsls	r3, r0, #31
     f96:	d507      	bpl.n	fa8 <_gclk_init_generators_by_fref+0x14>
}

static inline void hri_gclk_write_GENCTRL_reg(const void *const hw, uint8_t index, hri_gclk_genctrl_reg_t data)
{
	GCLK_CRITICAL_SECTION_ENTER();
	((Gclk *)hw)->GENCTRL[index].reg = data;
     f98:	4b04      	ldr	r3, [pc, #16]	; (fac <_gclk_init_generators_by_fref+0x18>)
     f9a:	4a05      	ldr	r2, [pc, #20]	; (fb0 <_gclk_init_generators_by_fref+0x1c>)
     f9c:	621a      	str	r2, [r3, #32]
	while (((Gclk *)hw)->SYNCBUSY.reg & reg) {
     f9e:	f643 72fd 	movw	r2, #16381	; 0x3ffd
     fa2:	6859      	ldr	r1, [r3, #4]
     fa4:	4211      	tst	r1, r2
     fa6:	d1fc      	bne.n	fa2 <_gclk_init_generators_by_fref+0xe>
		        | (CONF_GCLK_GEN_11_DIVSEL << GCLK_GENCTRL_DIVSEL_Pos) | (CONF_GCLK_GEN_11_OE << GCLK_GENCTRL_OE_Pos)
		        | (CONF_GCLK_GEN_11_OOV << GCLK_GENCTRL_OOV_Pos) | (CONF_GCLK_GEN_11_IDC << GCLK_GENCTRL_IDC_Pos)
		        | (CONF_GCLK_GENERATOR_11_CONFIG << GCLK_GENCTRL_GENEN_Pos) | CONF_GCLK_GEN_11_SOURCE);
	}
#endif
}
     fa8:	4770      	bx	lr
     faa:	bf00      	nop
     fac:	40001c00 	.word	0x40001c00
     fb0:	00010101 	.word	0x00010101

00000fb4 <stdio_redirect_init>:
	/* Print welcome message */
	printf("\r\nHello ATMEL World!\r\n");
}

void stdio_redirect_init(void)
{
     fb4:	b510      	push	{r4, lr}

	usart_sync_enable(&TARGET_IO);
     fb6:	4c04      	ldr	r4, [pc, #16]	; (fc8 <stdio_redirect_init+0x14>)
     fb8:	4b04      	ldr	r3, [pc, #16]	; (fcc <stdio_redirect_init+0x18>)
     fba:	4620      	mov	r0, r4
     fbc:	4798      	blx	r3
	stdio_io_init(&TARGET_IO.io);
     fbe:	4620      	mov	r0, r4
     fc0:	4b03      	ldr	r3, [pc, #12]	; (fd0 <stdio_redirect_init+0x1c>)
}
     fc2:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	stdio_io_init(&TARGET_IO.io);
     fc6:	4718      	bx	r3
     fc8:	2000a514 	.word	0x2000a514
     fcc:	00000f49 	.word	0x00000f49
     fd0:	000002a5 	.word	0x000002a5

00000fd4 <ethernet_phy_init>:
/**
 * \brief Perform a HW initialization to the PHY
 */
int32_t ethernet_phy_init(struct ethernet_phy_descriptor *const descr, struct mac_async_descriptor *const mac,
                          uint16_t addr)
{
     fd4:	b570      	push	{r4, r5, r6, lr}
     fd6:	460d      	mov	r5, r1
     fd8:	4616      	mov	r6, r2
	ASSERT(descr && mac && (addr <= 0x1F));
     fda:	4604      	mov	r4, r0
     fdc:	b120      	cbz	r0, fe8 <ethernet_phy_init+0x14>
     fde:	b159      	cbz	r1, ff8 <ethernet_phy_init+0x24>
     fe0:	2a1f      	cmp	r2, #31
     fe2:	bf8c      	ite	hi
     fe4:	2000      	movhi	r0, #0
     fe6:	2001      	movls	r0, #1
     fe8:	4904      	ldr	r1, [pc, #16]	; (ffc <ethernet_phy_init+0x28>)
     fea:	4b05      	ldr	r3, [pc, #20]	; (1000 <ethernet_phy_init+0x2c>)
     fec:	222a      	movs	r2, #42	; 0x2a
     fee:	4798      	blx	r3

	descr->mac  = mac;
     ff0:	6025      	str	r5, [r4, #0]
	descr->addr = addr;
     ff2:	80a6      	strh	r6, [r4, #4]
	return ERR_NONE;
}
     ff4:	2000      	movs	r0, #0
     ff6:	bd70      	pop	{r4, r5, r6, pc}
	ASSERT(descr && mac && (addr <= 0x1F));
     ff8:	4608      	mov	r0, r1
     ffa:	e7f5      	b.n	fe8 <ethernet_phy_init+0x14>
     ffc:	0000b608 	.word	0x0000b608
    1000:	00008a15 	.word	0x00008a15

00001004 <ethernet_phy_get_link_status>:

/**
 * \brief Get PHY link status
 */
int32_t ethernet_phy_get_link_status(struct ethernet_phy_descriptor *const descr, bool *status)
{
    1004:	b537      	push	{r0, r1, r2, r4, r5, lr}
    1006:	460d      	mov	r5, r1
	int32_t  rst;
	uint16_t val;

	ASSERT(descr && descr->mac && status);
    1008:	4604      	mov	r4, r0
    100a:	b120      	cbz	r0, 1016 <ethernet_phy_get_link_status+0x12>
    100c:	6800      	ldr	r0, [r0, #0]
    100e:	b110      	cbz	r0, 1016 <ethernet_phy_get_link_status+0x12>
    1010:	1e08      	subs	r0, r1, #0
    1012:	bf18      	it	ne
    1014:	2001      	movne	r0, #1
    1016:	4909      	ldr	r1, [pc, #36]	; (103c <ethernet_phy_get_link_status+0x38>)
    1018:	4b09      	ldr	r3, [pc, #36]	; (1040 <ethernet_phy_get_link_status+0x3c>)
    101a:	22a9      	movs	r2, #169	; 0xa9
    101c:	4798      	blx	r3
	rst = mac_async_read_phy_reg(descr->mac, descr->addr, MDIO_REG1_BMSR, &val);
    101e:	88a1      	ldrh	r1, [r4, #4]
    1020:	6820      	ldr	r0, [r4, #0]
    1022:	4c08      	ldr	r4, [pc, #32]	; (1044 <ethernet_phy_get_link_status+0x40>)
    1024:	f10d 0306 	add.w	r3, sp, #6
    1028:	2201      	movs	r2, #1
    102a:	47a0      	blx	r4
	if (rst == ERR_NONE) {
    102c:	b920      	cbnz	r0, 1038 <ethernet_phy_get_link_status+0x34>
		*status = (val & MDIO_REG1_BIT_LINK_STATUS) ? true : false;
    102e:	f8bd 3006 	ldrh.w	r3, [sp, #6]
    1032:	f3c3 0380 	ubfx	r3, r3, #2, #1
    1036:	702b      	strb	r3, [r5, #0]
	}
	return rst;
}
    1038:	b003      	add	sp, #12
    103a:	bd30      	pop	{r4, r5, pc}
    103c:	0000b608 	.word	0x0000b608
    1040:	00008a15 	.word	0x00008a15
    1044:	00004db5 	.word	0x00004db5

00001048 <sys_timeout>:
#if LWIP_DEBUG_TIMERNAMES
void sys_timeout_debug(u32_t msecs, sys_timeout_handler handler, void *arg, const char *handler_name)
#else  /* LWIP_DEBUG_TIMERNAMES */
void sys_timeout(u32_t msecs, sys_timeout_handler handler, void *arg)
#endif /* LWIP_DEBUG_TIMERNAMES */
{
    1048:	b570      	push	{r4, r5, r6, lr}
	struct sys_timeo *timeout, *t;

	timeout = (struct sys_timeo *)memp_malloc(MEMP_SYS_TIMEOUT);
    104a:	4b14      	ldr	r3, [pc, #80]	; (109c <sys_timeout+0x54>)
{
    104c:	4604      	mov	r4, r0
	timeout = (struct sys_timeo *)memp_malloc(MEMP_SYS_TIMEOUT);
    104e:	200a      	movs	r0, #10
{
    1050:	460e      	mov	r6, r1
    1052:	4615      	mov	r5, r2
	timeout = (struct sys_timeo *)memp_malloc(MEMP_SYS_TIMEOUT);
    1054:	4798      	blx	r3
	if (timeout == NULL) {
    1056:	b140      	cbz	r0, 106a <sys_timeout+0x22>
	LWIP_DEBUGF(
	    TIMERS_DEBUG,
	    ("sys_timeout: %p msecs=%" U32_F " handler=%s arg=%p\n", (void *)timeout, msecs, handler_name, (void *)arg));
#endif /* LWIP_DEBUG_TIMERNAMES */

	if (next_timeout == NULL) {
    1058:	4911      	ldr	r1, [pc, #68]	; (10a0 <sys_timeout+0x58>)
	timeout->time = msecs;
    105a:	6044      	str	r4, [r0, #4]
	timeout->next = NULL;
    105c:	2300      	movs	r3, #0
    105e:	6003      	str	r3, [r0, #0]
	if (next_timeout == NULL) {
    1060:	680b      	ldr	r3, [r1, #0]
	timeout->arg  = arg;
    1062:	e9c0 6502 	strd	r6, r5, [r0, #8]
	if (next_timeout == NULL) {
    1066:	b90b      	cbnz	r3, 106c <sys_timeout+0x24>
	}

	if (next_timeout->time > msecs) {
		next_timeout->time -= msecs;
		timeout->next = next_timeout;
		next_timeout  = timeout;
    1068:	6008      	str	r0, [r1, #0]
				t->next       = timeout;
				break;
			}
		}
	}
}
    106a:	bd70      	pop	{r4, r5, r6, pc}
	if (next_timeout->time > msecs) {
    106c:	685a      	ldr	r2, [r3, #4]
    106e:	42a2      	cmp	r2, r4
    1070:	d903      	bls.n	107a <sys_timeout+0x32>
		next_timeout->time -= msecs;
    1072:	1b12      	subs	r2, r2, r4
    1074:	605a      	str	r2, [r3, #4]
		timeout->next = next_timeout;
    1076:	6003      	str	r3, [r0, #0]
    1078:	e7f6      	b.n	1068 <sys_timeout+0x20>
			timeout->time -= t->time;
    107a:	685a      	ldr	r2, [r3, #4]
    107c:	6841      	ldr	r1, [r0, #4]
    107e:	461e      	mov	r6, r3
			if (t->next == NULL || t->next->time > timeout->time) {
    1080:	681b      	ldr	r3, [r3, #0]
			timeout->time -= t->time;
    1082:	1a8d      	subs	r5, r1, r2
    1084:	6045      	str	r5, [r0, #4]
			if (t->next == NULL || t->next->time > timeout->time) {
    1086:	b12b      	cbz	r3, 1094 <sys_timeout+0x4c>
    1088:	685c      	ldr	r4, [r3, #4]
    108a:	42a5      	cmp	r5, r4
    108c:	d2f5      	bcs.n	107a <sys_timeout+0x32>
					t->next->time -= timeout->time;
    108e:	4422      	add	r2, r4
    1090:	1a52      	subs	r2, r2, r1
    1092:	605a      	str	r2, [r3, #4]
				timeout->next = t->next;
    1094:	6003      	str	r3, [r0, #0]
				t->next       = timeout;
    1096:	6030      	str	r0, [r6, #0]
				break;
    1098:	e7e7      	b.n	106a <sys_timeout+0x22>
    109a:	bf00      	nop
    109c:	00004c01 	.word	0x00004c01
    10a0:	200000ac 	.word	0x200000ac

000010a4 <tcp_timer_needed>:
	if (!tcpip_tcp_timer_active && (tcp_active_pcbs || tcp_tw_pcbs)) {
    10a4:	4b08      	ldr	r3, [pc, #32]	; (10c8 <tcp_timer_needed+0x24>)
    10a6:	685a      	ldr	r2, [r3, #4]
    10a8:	b962      	cbnz	r2, 10c4 <tcp_timer_needed+0x20>
    10aa:	4a08      	ldr	r2, [pc, #32]	; (10cc <tcp_timer_needed+0x28>)
    10ac:	6812      	ldr	r2, [r2, #0]
    10ae:	b912      	cbnz	r2, 10b6 <tcp_timer_needed+0x12>
    10b0:	4a07      	ldr	r2, [pc, #28]	; (10d0 <tcp_timer_needed+0x2c>)
    10b2:	6812      	ldr	r2, [r2, #0]
    10b4:	b132      	cbz	r2, 10c4 <tcp_timer_needed+0x20>
		tcpip_tcp_timer_active = 1;
    10b6:	2201      	movs	r2, #1
    10b8:	605a      	str	r2, [r3, #4]
		sys_timeout(TCP_TMR_INTERVAL, tcpip_tcp_timer, NULL);
    10ba:	4906      	ldr	r1, [pc, #24]	; (10d4 <tcp_timer_needed+0x30>)
    10bc:	4b06      	ldr	r3, [pc, #24]	; (10d8 <tcp_timer_needed+0x34>)
    10be:	2200      	movs	r2, #0
    10c0:	20fa      	movs	r0, #250	; 0xfa
    10c2:	4718      	bx	r3
}
    10c4:	4770      	bx	lr
    10c6:	bf00      	nop
    10c8:	200000ac 	.word	0x200000ac
    10cc:	20014950 	.word	0x20014950
    10d0:	20014958 	.word	0x20014958
    10d4:	000010dd 	.word	0x000010dd
    10d8:	00001049 	.word	0x00001049

000010dc <tcpip_tcp_timer>:
	tcp_tmr();
    10dc:	4b09      	ldr	r3, [pc, #36]	; (1104 <tcpip_tcp_timer+0x28>)
{
    10de:	b510      	push	{r4, lr}
	tcp_tmr();
    10e0:	4798      	blx	r3
	if (tcp_active_pcbs || tcp_tw_pcbs) {
    10e2:	4b09      	ldr	r3, [pc, #36]	; (1108 <tcpip_tcp_timer+0x2c>)
    10e4:	681b      	ldr	r3, [r3, #0]
    10e6:	b913      	cbnz	r3, 10ee <tcpip_tcp_timer+0x12>
    10e8:	4b08      	ldr	r3, [pc, #32]	; (110c <tcpip_tcp_timer+0x30>)
    10ea:	681b      	ldr	r3, [r3, #0]
    10ec:	b133      	cbz	r3, 10fc <tcpip_tcp_timer+0x20>
}
    10ee:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		sys_timeout(TCP_TMR_INTERVAL, tcpip_tcp_timer, NULL);
    10f2:	4907      	ldr	r1, [pc, #28]	; (1110 <tcpip_tcp_timer+0x34>)
    10f4:	4b07      	ldr	r3, [pc, #28]	; (1114 <tcpip_tcp_timer+0x38>)
    10f6:	2200      	movs	r2, #0
    10f8:	20fa      	movs	r0, #250	; 0xfa
    10fa:	4718      	bx	r3
		tcpip_tcp_timer_active = 0;
    10fc:	4a06      	ldr	r2, [pc, #24]	; (1118 <tcpip_tcp_timer+0x3c>)
    10fe:	6053      	str	r3, [r2, #4]
}
    1100:	bd10      	pop	{r4, pc}
    1102:	bf00      	nop
    1104:	00007141 	.word	0x00007141
    1108:	20014950 	.word	0x20014950
    110c:	20014958 	.word	0x20014958
    1110:	000010dd 	.word	0x000010dd
    1114:	00001049 	.word	0x00001049
    1118:	200000ac 	.word	0x200000ac

0000111c <sys_timeouts_init>:
{
    111c:	b510      	push	{r4, lr}
	sys_timeout(IP_TMR_INTERVAL, ip_reass_timer, NULL);
    111e:	490c      	ldr	r1, [pc, #48]	; (1150 <sys_timeouts_init+0x34>)
    1120:	4c0c      	ldr	r4, [pc, #48]	; (1154 <sys_timeouts_init+0x38>)
    1122:	2200      	movs	r2, #0
    1124:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
    1128:	47a0      	blx	r4
	sys_timeout(ARP_TMR_INTERVAL, arp_timer, NULL);
    112a:	490b      	ldr	r1, [pc, #44]	; (1158 <sys_timeouts_init+0x3c>)
    112c:	2200      	movs	r2, #0
    112e:	f241 3088 	movw	r0, #5000	; 0x1388
    1132:	47a0      	blx	r4
	sys_timeout(DHCP_COARSE_TIMER_MSECS, dhcp_timer_coarse, NULL);
    1134:	4909      	ldr	r1, [pc, #36]	; (115c <sys_timeouts_init+0x40>)
    1136:	2200      	movs	r2, #0
    1138:	f64e 2060 	movw	r0, #60000	; 0xea60
    113c:	47a0      	blx	r4
	sys_timeout(DHCP_FINE_TIMER_MSECS, dhcp_timer_fine, NULL);
    113e:	4623      	mov	r3, r4
    1140:	4907      	ldr	r1, [pc, #28]	; (1160 <sys_timeouts_init+0x44>)
}
    1142:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	sys_timeout(DHCP_FINE_TIMER_MSECS, dhcp_timer_fine, NULL);
    1146:	2200      	movs	r2, #0
    1148:	f44f 70fa 	mov.w	r0, #500	; 0x1f4
    114c:	4718      	bx	r3
    114e:	bf00      	nop
    1150:	000011d1 	.word	0x000011d1
    1154:	00001049 	.word	0x00001049
    1158:	000011ad 	.word	0x000011ad
    115c:	00001189 	.word	0x00001189
    1160:	00001165 	.word	0x00001165

00001164 <dhcp_timer_fine>:
{
    1164:	b510      	push	{r4, lr}
	dhcp_fine_tmr();
    1166:	4b05      	ldr	r3, [pc, #20]	; (117c <dhcp_timer_fine+0x18>)
    1168:	4798      	blx	r3
}
    116a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	sys_timeout(DHCP_FINE_TIMER_MSECS, dhcp_timer_fine, NULL);
    116e:	4904      	ldr	r1, [pc, #16]	; (1180 <dhcp_timer_fine+0x1c>)
    1170:	4b04      	ldr	r3, [pc, #16]	; (1184 <dhcp_timer_fine+0x20>)
    1172:	2200      	movs	r2, #0
    1174:	f44f 70fa 	mov.w	r0, #500	; 0x1f4
    1178:	4718      	bx	r3
    117a:	bf00      	nop
    117c:	00006141 	.word	0x00006141
    1180:	00001165 	.word	0x00001165
    1184:	00001049 	.word	0x00001049

00001188 <dhcp_timer_coarse>:
{
    1188:	b510      	push	{r4, lr}
	dhcp_coarse_tmr();
    118a:	4b05      	ldr	r3, [pc, #20]	; (11a0 <dhcp_timer_coarse+0x18>)
    118c:	4798      	blx	r3
}
    118e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	sys_timeout(DHCP_COARSE_TIMER_MSECS, dhcp_timer_coarse, NULL);
    1192:	4904      	ldr	r1, [pc, #16]	; (11a4 <dhcp_timer_coarse+0x1c>)
    1194:	4b04      	ldr	r3, [pc, #16]	; (11a8 <dhcp_timer_coarse+0x20>)
    1196:	2200      	movs	r2, #0
    1198:	f64e 2060 	movw	r0, #60000	; 0xea60
    119c:	4718      	bx	r3
    119e:	bf00      	nop
    11a0:	00006015 	.word	0x00006015
    11a4:	00001189 	.word	0x00001189
    11a8:	00001049 	.word	0x00001049

000011ac <arp_timer>:
{
    11ac:	b510      	push	{r4, lr}
	etharp_tmr();
    11ae:	4b05      	ldr	r3, [pc, #20]	; (11c4 <arp_timer+0x18>)
    11b0:	4798      	blx	r3
}
    11b2:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	sys_timeout(ARP_TMR_INTERVAL, arp_timer, NULL);
    11b6:	4904      	ldr	r1, [pc, #16]	; (11c8 <arp_timer+0x1c>)
    11b8:	4b04      	ldr	r3, [pc, #16]	; (11cc <arp_timer+0x20>)
    11ba:	2200      	movs	r2, #0
    11bc:	f241 3088 	movw	r0, #5000	; 0x1388
    11c0:	4718      	bx	r3
    11c2:	bf00      	nop
    11c4:	00004f35 	.word	0x00004f35
    11c8:	000011ad 	.word	0x000011ad
    11cc:	00001049 	.word	0x00001049

000011d0 <ip_reass_timer>:
{
    11d0:	b510      	push	{r4, lr}
	ip_reass_tmr();
    11d2:	4b05      	ldr	r3, [pc, #20]	; (11e8 <ip_reass_timer+0x18>)
    11d4:	4798      	blx	r3
}
    11d6:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	sys_timeout(IP_TMR_INTERVAL, ip_reass_timer, NULL);
    11da:	4904      	ldr	r1, [pc, #16]	; (11ec <ip_reass_timer+0x1c>)
    11dc:	4b04      	ldr	r3, [pc, #16]	; (11f0 <ip_reass_timer+0x20>)
    11de:	2200      	movs	r2, #0
    11e0:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
    11e4:	4718      	bx	r3
    11e6:	bf00      	nop
    11e8:	00002b1d 	.word	0x00002b1d
    11ec:	000011d1 	.word	0x000011d1
    11f0:	00001049 	.word	0x00001049

000011f4 <sys_untimeout>:
 *
 * @param handler callback function that would be called by the timeout
 * @param arg callback argument that would be passed to handler
 */
void sys_untimeout(sys_timeout_handler handler, void *arg)
{
    11f4:	b470      	push	{r4, r5, r6}
	struct sys_timeo *prev_t, *t;

	if (next_timeout == NULL) {
    11f6:	4d10      	ldr	r5, [pc, #64]	; (1238 <sys_untimeout+0x44>)
{
    11f8:	460c      	mov	r4, r1
	if (next_timeout == NULL) {
    11fa:	6829      	ldr	r1, [r5, #0]
    11fc:	b1d1      	cbz	r1, 1234 <sys_untimeout+0x40>
		return;
	}

	for (t = next_timeout, prev_t = NULL; t != NULL; prev_t = t, t = t->next) {
    11fe:	2200      	movs	r2, #0
		if ((t->h == handler) && (t->arg == arg)) {
    1200:	688b      	ldr	r3, [r1, #8]
    1202:	4283      	cmp	r3, r0
    1204:	680b      	ldr	r3, [r1, #0]
    1206:	d112      	bne.n	122e <sys_untimeout+0x3a>
    1208:	68ce      	ldr	r6, [r1, #12]
    120a:	42a6      	cmp	r6, r4
    120c:	d10f      	bne.n	122e <sys_untimeout+0x3a>
			/* We have a match */
			/* Unlink from previous in list */
			if (prev_t == NULL) {
    120e:	b962      	cbnz	r2, 122a <sys_untimeout+0x36>
				next_timeout = t->next;
    1210:	602b      	str	r3, [r5, #0]
			} else {
				prev_t->next = t->next;
			}
			/* If not the last one, add time of this one back to next */
			if (t->next != NULL) {
    1212:	680b      	ldr	r3, [r1, #0]
    1214:	b11b      	cbz	r3, 121e <sys_untimeout+0x2a>
				t->next->time += t->time;
    1216:	685a      	ldr	r2, [r3, #4]
    1218:	6848      	ldr	r0, [r1, #4]
    121a:	4402      	add	r2, r0
    121c:	605a      	str	r2, [r3, #4]
			memp_free(MEMP_SYS_TIMEOUT, t);
			return;
		}
	}
	return;
}
    121e:	bc70      	pop	{r4, r5, r6}
			memp_free(MEMP_SYS_TIMEOUT, t);
    1220:	4b06      	ldr	r3, [pc, #24]	; (123c <sys_untimeout+0x48>)
    1222:	200a      	movs	r0, #10
    1224:	4718      	bx	r3
    1226:	4619      	mov	r1, r3
    1228:	e7ea      	b.n	1200 <sys_untimeout+0xc>
				prev_t->next = t->next;
    122a:	6013      	str	r3, [r2, #0]
    122c:	e7f1      	b.n	1212 <sys_untimeout+0x1e>
	for (t = next_timeout, prev_t = NULL; t != NULL; prev_t = t, t = t->next) {
    122e:	460a      	mov	r2, r1
    1230:	2b00      	cmp	r3, #0
    1232:	d1f8      	bne.n	1226 <sys_untimeout+0x32>
}
    1234:	bc70      	pop	{r4, r5, r6}
    1236:	4770      	bx	lr
    1238:	200000ac 	.word	0x200000ac
    123c:	00004c1d 	.word	0x00004c1d

00001240 <sys_timeouts_mbox_fetch>:
 *
 * @param mbox the mbox to fetch the message from
 * @param msg the place to store the message
 */
void sys_timeouts_mbox_fetch(sys_mbox_t *mbox, void **msg)
{
    1240:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	struct sys_timeo *  tmptimeout;
	sys_timeout_handler handler;
	void *              arg;

again:
	if (!next_timeout) {
    1244:	4c15      	ldr	r4, [pc, #84]	; (129c <sys_timeouts_mbox_fetch+0x5c>)
		time_needed = sys_arch_mbox_fetch(mbox, msg, 0);
	} else {
		if (next_timeout->time > 0) {
			time_needed = sys_arch_mbox_fetch(mbox, msg, next_timeout->time);
    1246:	4f16      	ldr	r7, [pc, #88]	; (12a0 <sys_timeouts_mbox_fetch+0x60>)
{
    1248:	4605      	mov	r5, r0
    124a:	460e      	mov	r6, r1
	if (!next_timeout) {
    124c:	6822      	ldr	r2, [r4, #0]
    124e:	b92a      	cbnz	r2, 125c <sys_timeouts_mbox_fetch+0x1c>
		time_needed = sys_arch_mbox_fetch(mbox, msg, 0);
    1250:	4631      	mov	r1, r6
    1252:	4628      	mov	r0, r5
    1254:	4b12      	ldr	r3, [pc, #72]	; (12a0 <sys_timeouts_mbox_fetch+0x60>)
			} else {
				next_timeout->time = 0;
			}
		}
	}
}
    1256:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
		time_needed = sys_arch_mbox_fetch(mbox, msg, 0);
    125a:	4718      	bx	r3
		if (next_timeout->time > 0) {
    125c:	6852      	ldr	r2, [r2, #4]
    125e:	b96a      	cbnz	r2, 127c <sys_timeouts_mbox_fetch+0x3c>
			tmptimeout   = next_timeout;
    1260:	6821      	ldr	r1, [r4, #0]
			arg          = tmptimeout->arg;
    1262:	e9d1 8902 	ldrd	r8, r9, [r1, #8]
			next_timeout = tmptimeout->next;
    1266:	680b      	ldr	r3, [r1, #0]
    1268:	6023      	str	r3, [r4, #0]
			memp_free(MEMP_SYS_TIMEOUT, tmptimeout);
    126a:	200a      	movs	r0, #10
    126c:	4b0d      	ldr	r3, [pc, #52]	; (12a4 <sys_timeouts_mbox_fetch+0x64>)
    126e:	4798      	blx	r3
			if (handler != NULL) {
    1270:	f1b8 0f00 	cmp.w	r8, #0
    1274:	d0ea      	beq.n	124c <sys_timeouts_mbox_fetch+0xc>
				handler(arg);
    1276:	4648      	mov	r0, r9
    1278:	47c0      	blx	r8
    127a:	e7e7      	b.n	124c <sys_timeouts_mbox_fetch+0xc>
			time_needed = sys_arch_mbox_fetch(mbox, msg, next_timeout->time);
    127c:	4631      	mov	r1, r6
    127e:	4628      	mov	r0, r5
    1280:	47b8      	blx	r7
		if (time_needed == SYS_ARCH_TIMEOUT) {
    1282:	1c42      	adds	r2, r0, #1
			time_needed = sys_arch_mbox_fetch(mbox, msg, next_timeout->time);
    1284:	4603      	mov	r3, r0
		if (time_needed == SYS_ARCH_TIMEOUT) {
    1286:	d0eb      	beq.n	1260 <sys_timeouts_mbox_fetch+0x20>
			if (time_needed < next_timeout->time) {
    1288:	6822      	ldr	r2, [r4, #0]
    128a:	6850      	ldr	r0, [r2, #4]
    128c:	4298      	cmp	r0, r3
				next_timeout->time -= time_needed;
    128e:	bf8b      	itete	hi
    1290:	1ac0      	subhi	r0, r0, r3
				next_timeout->time = 0;
    1292:	2300      	movls	r3, #0
				next_timeout->time -= time_needed;
    1294:	6050      	strhi	r0, [r2, #4]
				next_timeout->time = 0;
    1296:	6053      	strls	r3, [r2, #4]
}
    1298:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    129c:	200000ac 	.word	0x200000ac
    12a0:	00007b51 	.word	0x00007b51
    12a4:	00004c1d 	.word	0x00004c1d

000012a8 <err_tcp>:
 * The application thread has then to decide what to do.
 *
 * @see tcp.h (struct tcp_pcb.err) for parameters
 */
static void err_tcp(void *arg, err_t err)
{
    12a8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	old_state   = conn->state;
	conn->state = NETCONN_NONE;

	/* Notify the user layer about a connection error. Used to signal
	   select. */
	API_EVENT(conn, NETCONN_EVT_ERROR, 0);
    12ac:	6a83      	ldr	r3, [r0, #40]	; 0x28
	old_state   = conn->state;
    12ae:	7846      	ldrb	r6, [r0, #1]
	conn->last_err = err;
    12b0:	7201      	strb	r1, [r0, #8]
	conn->pcb.tcp = NULL;
    12b2:	2200      	movs	r2, #0
{
    12b4:	4604      	mov	r4, r0
    12b6:	460d      	mov	r5, r1
	conn->pcb.tcp = NULL;
    12b8:	6042      	str	r2, [r0, #4]
	conn->state = NETCONN_NONE;
    12ba:	7042      	strb	r2, [r0, #1]
	API_EVENT(conn, NETCONN_EVT_ERROR, 0);
    12bc:	b10b      	cbz	r3, 12c2 <err_tcp+0x1a>
    12be:	2104      	movs	r1, #4
    12c0:	4798      	blx	r3
	/* Try to release selects pending on 'read' or 'write', too.
	   They will get an error if they actually try to read or write. */
	API_EVENT(conn, NETCONN_EVT_RCVPLUS, 0);
    12c2:	6aa3      	ldr	r3, [r4, #40]	; 0x28
    12c4:	b11b      	cbz	r3, 12ce <err_tcp+0x26>
    12c6:	2200      	movs	r2, #0
    12c8:	4611      	mov	r1, r2
    12ca:	4620      	mov	r0, r4
    12cc:	4798      	blx	r3
	API_EVENT(conn, NETCONN_EVT_SENDPLUS, 0);
    12ce:	6aa3      	ldr	r3, [r4, #40]	; 0x28
    12d0:	b11b      	cbz	r3, 12da <err_tcp+0x32>
    12d2:	2200      	movs	r2, #0
    12d4:	2102      	movs	r1, #2
    12d6:	4620      	mov	r0, r4
    12d8:	4798      	blx	r3

	/* pass NULL-message to recvmbox to wake up pending recv */
	if (sys_mbox_valid(&conn->recvmbox)) {
    12da:	f104 0810 	add.w	r8, r4, #16
    12de:	4f14      	ldr	r7, [pc, #80]	; (1330 <err_tcp+0x88>)
    12e0:	4640      	mov	r0, r8
    12e2:	47b8      	blx	r7
    12e4:	b118      	cbz	r0, 12ee <err_tcp+0x46>
		/* use trypost to prevent deadlock */
		sys_mbox_trypost(&conn->recvmbox, NULL);
    12e6:	4b13      	ldr	r3, [pc, #76]	; (1334 <err_tcp+0x8c>)
    12e8:	2100      	movs	r1, #0
    12ea:	4640      	mov	r0, r8
    12ec:	4798      	blx	r3
	}
	/* pass NULL-message to acceptmbox to wake up pending accept */
	if (sys_mbox_valid(&conn->acceptmbox)) {
    12ee:	f104 0814 	add.w	r8, r4, #20
    12f2:	4640      	mov	r0, r8
    12f4:	47b8      	blx	r7
    12f6:	b118      	cbz	r0, 1300 <err_tcp+0x58>
		/* use trypost to preven deadlock */
		sys_mbox_trypost(&conn->acceptmbox, NULL);
    12f8:	4b0e      	ldr	r3, [pc, #56]	; (1334 <err_tcp+0x8c>)
    12fa:	2100      	movs	r1, #0
    12fc:	4640      	mov	r0, r8
    12fe:	4798      	blx	r3
	}

	if ((old_state == NETCONN_WRITE) || (old_state == NETCONN_CLOSE) || (old_state == NETCONN_CONNECT)) {
    1300:	2e01      	cmp	r6, #1
    1302:	d002      	beq.n	130a <err_tcp+0x62>
    1304:	3e03      	subs	r6, #3
    1306:	2e01      	cmp	r6, #1
    1308:	d80f      	bhi.n	132a <err_tcp+0x82>
		/* calling do_writemore/do_close_internal is not necessary
		   since the pcb has already been deleted! */
		int was_nonblocking_connect = IN_NONBLOCKING_CONNECT(conn);
    130a:	7f23      	ldrb	r3, [r4, #28]
		SET_NONBLOCKING_CONNECT(conn, 0);
    130c:	f023 0204 	bic.w	r2, r3, #4

		if (!was_nonblocking_connect) {
    1310:	f013 0304 	ands.w	r3, r3, #4
		SET_NONBLOCKING_CONNECT(conn, 0);
    1314:	7722      	strb	r2, [r4, #28]
		if (!was_nonblocking_connect) {
    1316:	d108      	bne.n	132a <err_tcp+0x82>
			/* set error return code */
			LWIP_ASSERT("conn->current_msg != NULL", conn->current_msg != NULL);
			conn->current_msg->err = err;
    1318:	6a62      	ldr	r2, [r4, #36]	; 0x24
    131a:	7115      	strb	r5, [r2, #4]
			conn->current_msg      = NULL;
			/* wake up the waiting task */
			sys_sem_signal(&conn->op_completed);
    131c:	f104 000c 	add.w	r0, r4, #12
			conn->current_msg      = NULL;
    1320:	6263      	str	r3, [r4, #36]	; 0x24
		}
	} else {
		LWIP_ASSERT("conn->current_msg == NULL", conn->current_msg == NULL);
	}
}
    1322:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
			sys_sem_signal(&conn->op_completed);
    1326:	4b04      	ldr	r3, [pc, #16]	; (1338 <err_tcp+0x90>)
    1328:	4718      	bx	r3
}
    132a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    132e:	bf00      	nop
    1330:	00007bdd 	.word	0x00007bdd
    1334:	00007ae9 	.word	0x00007ae9
    1338:	00007a19 	.word	0x00007a19

0000133c <recv_udp>:
{
    133c:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
    1340:	4617      	mov	r7, r2
    1342:	f8bd 9028 	ldrh.w	r9, [sp, #40]	; 0x28
    1346:	461d      	mov	r5, r3
	if ((conn == NULL) || !sys_mbox_valid(&conn->recvmbox)) {
    1348:	4606      	mov	r6, r0
    134a:	b128      	cbz	r0, 1358 <recv_udp+0x1c>
    134c:	f100 0810 	add.w	r8, r0, #16
    1350:	4b17      	ldr	r3, [pc, #92]	; (13b0 <recv_udp+0x74>)
    1352:	4640      	mov	r0, r8
    1354:	4798      	blx	r3
    1356:	b928      	cbnz	r0, 1364 <recv_udp+0x28>
		pbuf_free(p);
    1358:	4b16      	ldr	r3, [pc, #88]	; (13b4 <recv_udp+0x78>)
    135a:	4638      	mov	r0, r7
}
    135c:	b003      	add	sp, #12
    135e:	e8bd 43f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, lr}
		pbuf_free(p);
    1362:	4718      	bx	r3
	buf = (struct netbuf *)memp_malloc(MEMP_NETBUF);
    1364:	4b14      	ldr	r3, [pc, #80]	; (13b8 <recv_udp+0x7c>)
    1366:	2006      	movs	r0, #6
    1368:	4798      	blx	r3
	if (buf == NULL) {
    136a:	4604      	mov	r4, r0
    136c:	2800      	cmp	r0, #0
    136e:	d0f3      	beq.n	1358 <recv_udp+0x1c>
		buf->ptr = p;
    1370:	e9c0 7700 	strd	r7, r7, [r0]
		ip_addr_set(&buf->addr, addr);
    1374:	b105      	cbz	r5, 1378 <recv_udp+0x3c>
    1376:	682d      	ldr	r5, [r5, #0]
	len = p->tot_len;
    1378:	893a      	ldrh	r2, [r7, #8]
	if (sys_mbox_trypost(&conn->recvmbox, buf) != ERR_OK) {
    137a:	4b10      	ldr	r3, [pc, #64]	; (13bc <recv_udp+0x80>)
		ip_addr_set(&buf->addr, addr);
    137c:	60a5      	str	r5, [r4, #8]
	if (sys_mbox_trypost(&conn->recvmbox, buf) != ERR_OK) {
    137e:	4621      	mov	r1, r4
		buf->port = port;
    1380:	f8a4 900c 	strh.w	r9, [r4, #12]
	if (sys_mbox_trypost(&conn->recvmbox, buf) != ERR_OK) {
    1384:	4640      	mov	r0, r8
	len = p->tot_len;
    1386:	9201      	str	r2, [sp, #4]
	if (sys_mbox_trypost(&conn->recvmbox, buf) != ERR_OK) {
    1388:	4798      	blx	r3
    138a:	9a01      	ldr	r2, [sp, #4]
    138c:	4601      	mov	r1, r0
    138e:	b128      	cbz	r0, 139c <recv_udp+0x60>
		netbuf_delete(buf);
    1390:	4b0b      	ldr	r3, [pc, #44]	; (13c0 <recv_udp+0x84>)
    1392:	4620      	mov	r0, r4
}
    1394:	b003      	add	sp, #12
    1396:	e8bd 43f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, lr}
		netbuf_delete(buf);
    139a:	4718      	bx	r3
		API_EVENT(conn, NETCONN_EVT_RCVPLUS, len);
    139c:	6ab3      	ldr	r3, [r6, #40]	; 0x28
    139e:	b123      	cbz	r3, 13aa <recv_udp+0x6e>
    13a0:	4630      	mov	r0, r6
}
    13a2:	b003      	add	sp, #12
    13a4:	e8bd 43f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, lr}
		API_EVENT(conn, NETCONN_EVT_RCVPLUS, len);
    13a8:	4718      	bx	r3
}
    13aa:	b003      	add	sp, #12
    13ac:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    13b0:	00007bdd 	.word	0x00007bdd
    13b4:	000030e5 	.word	0x000030e5
    13b8:	00004c01 	.word	0x00004c01
    13bc:	00007ae9 	.word	0x00007ae9
    13c0:	00000d7d 	.word	0x00000d7d

000013c4 <setup_tcp>:
 * and their arguments.
 *
 * @param conn the TCP netconn to setup
 */
static void setup_tcp(struct netconn *conn)
{
    13c4:	b507      	push	{r0, r1, r2, lr}
	struct tcp_pcb *pcb;

	pcb = conn->pcb.tcp;
	tcp_arg(pcb, conn);
    13c6:	4b0c      	ldr	r3, [pc, #48]	; (13f8 <setup_tcp+0x34>)
{
    13c8:	4601      	mov	r1, r0
	pcb = conn->pcb.tcp;
    13ca:	6840      	ldr	r0, [r0, #4]
	tcp_arg(pcb, conn);
    13cc:	9001      	str	r0, [sp, #4]
    13ce:	4798      	blx	r3
	tcp_recv(pcb, recv_tcp);
    13d0:	9801      	ldr	r0, [sp, #4]
    13d2:	490a      	ldr	r1, [pc, #40]	; (13fc <setup_tcp+0x38>)
    13d4:	4b0a      	ldr	r3, [pc, #40]	; (1400 <setup_tcp+0x3c>)
    13d6:	4798      	blx	r3
	tcp_sent(pcb, sent_tcp);
    13d8:	9801      	ldr	r0, [sp, #4]
    13da:	490a      	ldr	r1, [pc, #40]	; (1404 <setup_tcp+0x40>)
    13dc:	4b0a      	ldr	r3, [pc, #40]	; (1408 <setup_tcp+0x44>)
    13de:	4798      	blx	r3
	tcp_poll(pcb, poll_tcp, 4);
    13e0:	9801      	ldr	r0, [sp, #4]
    13e2:	490a      	ldr	r1, [pc, #40]	; (140c <setup_tcp+0x48>)
    13e4:	4b0a      	ldr	r3, [pc, #40]	; (1410 <setup_tcp+0x4c>)
    13e6:	2204      	movs	r2, #4
    13e8:	4798      	blx	r3
	tcp_err(pcb, err_tcp);
    13ea:	490a      	ldr	r1, [pc, #40]	; (1414 <setup_tcp+0x50>)
    13ec:	9801      	ldr	r0, [sp, #4]
    13ee:	4b0a      	ldr	r3, [pc, #40]	; (1418 <setup_tcp+0x54>)
}
    13f0:	b003      	add	sp, #12
    13f2:	f85d eb04 	ldr.w	lr, [sp], #4
	tcp_err(pcb, err_tcp);
    13f6:	4718      	bx	r3
    13f8:	00006b2d 	.word	0x00006b2d
    13fc:	0000152d 	.word	0x0000152d
    1400:	00006b31 	.word	0x00006b31
    1404:	000016ad 	.word	0x000016ad
    1408:	00006b37 	.word	0x00006b37
    140c:	000016fd 	.word	0x000016fd
    1410:	00006b45 	.word	0x00006b45
    1414:	000012a9 	.word	0x000012a9
    1418:	00006b3b 	.word	0x00006b3b

0000141c <do_close_internal>:
	LWIP_ASSERT("this is for tcp netconns only", (conn->type == NETCONN_TCP));
	LWIP_ASSERT("conn must be in state NETCONN_CLOSE", (conn->state == NETCONN_CLOSE));
	LWIP_ASSERT("pcb already closed", (conn->pcb.tcp != NULL));
	LWIP_ASSERT("conn->current_msg != NULL", conn->current_msg != NULL);

	shut    = conn->current_msg->msg.sd.shut;
    141c:	6a43      	ldr	r3, [r0, #36]	; 0x24
{
    141e:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	shut    = conn->current_msg->msg.sd.shut;
    1422:	7a1d      	ldrb	r5, [r3, #8]
	shut_tx = shut & NETCONN_SHUT_WR;
	/* shutting down both ends is the same as closing */
	close = shut == NETCONN_SHUT_RDWR;

	/* Set back some callback pointers */
	if (close) {
    1424:	2d03      	cmp	r5, #3
{
    1426:	4604      	mov	r4, r0
	shut_rx = shut & NETCONN_SHUT_RD;
    1428:	f005 0701 	and.w	r7, r5, #1
	shut_tx = shut & NETCONN_SHUT_WR;
    142c:	f005 0602 	and.w	r6, r5, #2
	if (close) {
    1430:	d103      	bne.n	143a <do_close_internal+0x1e>
		tcp_arg(conn->pcb.tcp, NULL);
    1432:	6840      	ldr	r0, [r0, #4]
    1434:	4b31      	ldr	r3, [pc, #196]	; (14fc <do_close_internal+0xe0>)
    1436:	2100      	movs	r1, #0
    1438:	4798      	blx	r3
	}
	if (conn->pcb.tcp->state == LISTEN) {
    143a:	6860      	ldr	r0, [r4, #4]
    143c:	7e03      	ldrb	r3, [r0, #24]
    143e:	2b01      	cmp	r3, #1
    1440:	d10a      	bne.n	1458 <do_close_internal+0x3c>
		tcp_accept(conn->pcb.tcp, NULL);
    1442:	4b2f      	ldr	r3, [pc, #188]	; (1500 <do_close_internal+0xe4>)
    1444:	2100      	movs	r1, #0
    1446:	4798      	blx	r3
			tcp_poll(conn->pcb.tcp, NULL, 4);
			tcp_err(conn->pcb.tcp, NULL);
		}
	}
	/* Try to close the connection */
	if (close) {
    1448:	2d03      	cmp	r5, #3
    144a:	d01d      	beq.n	1488 <do_close_internal+0x6c>
		err = tcp_close(conn->pcb.tcp);
	} else {
		err = tcp_shutdown(conn->pcb.tcp, shut_rx, shut_tx);
    144c:	6860      	ldr	r0, [r4, #4]
    144e:	4b2d      	ldr	r3, [pc, #180]	; (1504 <do_close_internal+0xe8>)
    1450:	4632      	mov	r2, r6
    1452:	4639      	mov	r1, r7
    1454:	4798      	blx	r3
    1456:	e01a      	b.n	148e <do_close_internal+0x72>
		if (shut_rx) {
    1458:	b137      	cbz	r7, 1468 <do_close_internal+0x4c>
			tcp_recv(conn->pcb.tcp, NULL);
    145a:	4b2b      	ldr	r3, [pc, #172]	; (1508 <do_close_internal+0xec>)
    145c:	2100      	movs	r1, #0
    145e:	4798      	blx	r3
			tcp_accept(conn->pcb.tcp, NULL);
    1460:	6860      	ldr	r0, [r4, #4]
    1462:	4b27      	ldr	r3, [pc, #156]	; (1500 <do_close_internal+0xe4>)
    1464:	2100      	movs	r1, #0
    1466:	4798      	blx	r3
		if (shut_tx) {
    1468:	b11e      	cbz	r6, 1472 <do_close_internal+0x56>
			tcp_sent(conn->pcb.tcp, NULL);
    146a:	6860      	ldr	r0, [r4, #4]
    146c:	4b27      	ldr	r3, [pc, #156]	; (150c <do_close_internal+0xf0>)
    146e:	2100      	movs	r1, #0
    1470:	4798      	blx	r3
		if (close) {
    1472:	2d03      	cmp	r5, #3
    1474:	d1ea      	bne.n	144c <do_close_internal+0x30>
			tcp_poll(conn->pcb.tcp, NULL, 4);
    1476:	6860      	ldr	r0, [r4, #4]
    1478:	4b25      	ldr	r3, [pc, #148]	; (1510 <do_close_internal+0xf4>)
    147a:	2100      	movs	r1, #0
    147c:	2204      	movs	r2, #4
    147e:	4798      	blx	r3
			tcp_err(conn->pcb.tcp, NULL);
    1480:	6860      	ldr	r0, [r4, #4]
    1482:	4b24      	ldr	r3, [pc, #144]	; (1514 <do_close_internal+0xf8>)
    1484:	2100      	movs	r1, #0
    1486:	4798      	blx	r3
		err = tcp_close(conn->pcb.tcp);
    1488:	6860      	ldr	r0, [r4, #4]
    148a:	4b23      	ldr	r3, [pc, #140]	; (1518 <do_close_internal+0xfc>)
    148c:	4798      	blx	r3
	}
	if (err == ERR_OK) {
    148e:	bb10      	cbnz	r0, 14d6 <do_close_internal+0xba>
		/* Closing succeeded */
		conn->current_msg->err = ERR_OK;
    1490:	6a63      	ldr	r3, [r4, #36]	; 0x24
		conn->current_msg      = NULL;
		conn->state            = NETCONN_NONE;
		if (close) {
    1492:	2d03      	cmp	r5, #3
		conn->current_msg->err = ERR_OK;
    1494:	7118      	strb	r0, [r3, #4]
		conn->current_msg      = NULL;
    1496:	6260      	str	r0, [r4, #36]	; 0x24
		conn->state            = NETCONN_NONE;
    1498:	7060      	strb	r0, [r4, #1]
		if (close) {
    149a:	d10d      	bne.n	14b8 <do_close_internal+0x9c>
			/* Set back some callback pointers as conn is going away */
			conn->pcb.tcp = NULL;
			/* Trigger select() in socket layer. Make sure everybody notices activity
			 on the connection, error first! */
			API_EVENT(conn, NETCONN_EVT_ERROR, 0);
    149c:	6aa3      	ldr	r3, [r4, #40]	; 0x28
			conn->pcb.tcp = NULL;
    149e:	6060      	str	r0, [r4, #4]
			API_EVENT(conn, NETCONN_EVT_ERROR, 0);
    14a0:	b11b      	cbz	r3, 14aa <do_close_internal+0x8e>
    14a2:	4602      	mov	r2, r0
    14a4:	2104      	movs	r1, #4
    14a6:	4620      	mov	r0, r4
    14a8:	4798      	blx	r3
		}
		if (shut_rx) {
			API_EVENT(conn, NETCONN_EVT_RCVPLUS, 0);
    14aa:	6aa3      	ldr	r3, [r4, #40]	; 0x28
    14ac:	b133      	cbz	r3, 14bc <do_close_internal+0xa0>
    14ae:	2200      	movs	r2, #0
    14b0:	4611      	mov	r1, r2
    14b2:	4620      	mov	r0, r4
    14b4:	4798      	blx	r3
    14b6:	e001      	b.n	14bc <do_close_internal+0xa0>
		if (shut_rx) {
    14b8:	2f00      	cmp	r7, #0
    14ba:	d1f6      	bne.n	14aa <do_close_internal+0x8e>
		}
		if (shut_tx) {
    14bc:	b12e      	cbz	r6, 14ca <do_close_internal+0xae>
			API_EVENT(conn, NETCONN_EVT_SENDPLUS, 0);
    14be:	6aa3      	ldr	r3, [r4, #40]	; 0x28
    14c0:	b11b      	cbz	r3, 14ca <do_close_internal+0xae>
    14c2:	2200      	movs	r2, #0
    14c4:	2102      	movs	r1, #2
    14c6:	4620      	mov	r0, r4
    14c8:	4798      	blx	r3
		}
		/* wake up the application task */
		sys_sem_signal(&conn->op_completed);
    14ca:	f104 000c 	add.w	r0, r4, #12
    14ce:	4b13      	ldr	r3, [pc, #76]	; (151c <do_close_internal+0x100>)
		tcp_arg(conn->pcb.tcp, conn);
		/* don't restore recv callback: we don't want to receive any more data */
	}
	/* If closing didn't succeed, we get called again either
	   from poll_tcp or from sent_tcp */
}
    14d0:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
		sys_sem_signal(&conn->op_completed);
    14d4:	4718      	bx	r3
		tcp_sent(conn->pcb.tcp, sent_tcp);
    14d6:	6860      	ldr	r0, [r4, #4]
    14d8:	4911      	ldr	r1, [pc, #68]	; (1520 <do_close_internal+0x104>)
    14da:	4b0c      	ldr	r3, [pc, #48]	; (150c <do_close_internal+0xf0>)
    14dc:	4798      	blx	r3
		tcp_poll(conn->pcb.tcp, poll_tcp, 4);
    14de:	6860      	ldr	r0, [r4, #4]
    14e0:	4910      	ldr	r1, [pc, #64]	; (1524 <do_close_internal+0x108>)
    14e2:	4b0b      	ldr	r3, [pc, #44]	; (1510 <do_close_internal+0xf4>)
    14e4:	2204      	movs	r2, #4
    14e6:	4798      	blx	r3
		tcp_err(conn->pcb.tcp, err_tcp);
    14e8:	6860      	ldr	r0, [r4, #4]
    14ea:	490f      	ldr	r1, [pc, #60]	; (1528 <do_close_internal+0x10c>)
    14ec:	4b09      	ldr	r3, [pc, #36]	; (1514 <do_close_internal+0xf8>)
    14ee:	4798      	blx	r3
		tcp_arg(conn->pcb.tcp, conn);
    14f0:	6860      	ldr	r0, [r4, #4]
    14f2:	4b02      	ldr	r3, [pc, #8]	; (14fc <do_close_internal+0xe0>)
    14f4:	4621      	mov	r1, r4
}
    14f6:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
		tcp_arg(conn->pcb.tcp, conn);
    14fa:	4718      	bx	r3
    14fc:	00006b2d 	.word	0x00006b2d
    1500:	00006b41 	.word	0x00006b41
    1504:	00007171 	.word	0x00007171
    1508:	00006b31 	.word	0x00006b31
    150c:	00006b37 	.word	0x00006b37
    1510:	00006b45 	.word	0x00006b45
    1514:	00006b3b 	.word	0x00006b3b
    1518:	00007029 	.word	0x00007029
    151c:	00007a19 	.word	0x00007a19
    1520:	000016ad 	.word	0x000016ad
    1524:	000016fd 	.word	0x000016fd
    1528:	000012a9 	.word	0x000012a9

0000152c <recv_tcp>:
{
    152c:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    1530:	4688      	mov	r8, r1
    1532:	4615      	mov	r5, r2
    1534:	461f      	mov	r7, r3
	if (conn == NULL) {
    1536:	4606      	mov	r6, r0
    1538:	b350      	cbz	r0, 1590 <recv_tcp+0x64>
	if (!sys_mbox_valid(&conn->recvmbox)) {
    153a:	f100 0910 	add.w	r9, r0, #16
    153e:	4b17      	ldr	r3, [pc, #92]	; (159c <recv_tcp+0x70>)
    1540:	4648      	mov	r0, r9
    1542:	4798      	blx	r3
    1544:	4604      	mov	r4, r0
    1546:	b960      	cbnz	r0, 1562 <recv_tcp+0x36>
		if (p != NULL) {
    1548:	b91d      	cbnz	r5, 1552 <recv_tcp+0x26>
		return ERR_OK;
    154a:	2400      	movs	r4, #0
}
    154c:	4620      	mov	r0, r4
    154e:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
			tcp_recved(pcb, p->tot_len);
    1552:	4640      	mov	r0, r8
    1554:	8929      	ldrh	r1, [r5, #8]
    1556:	4b12      	ldr	r3, [pc, #72]	; (15a0 <recv_tcp+0x74>)
    1558:	4798      	blx	r3
			pbuf_free(p);
    155a:	4b12      	ldr	r3, [pc, #72]	; (15a4 <recv_tcp+0x78>)
    155c:	4628      	mov	r0, r5
    155e:	4798      	blx	r3
    1560:	e7f4      	b.n	154c <recv_tcp+0x20>
	NETCONN_SET_SAFE_ERR(conn, err);
    1562:	f996 3008 	ldrsb.w	r3, [r6, #8]
    1566:	3309      	adds	r3, #9
    1568:	bfa8      	it	ge
    156a:	7237      	strbge	r7, [r6, #8]
	if (p != NULL) {
    156c:	b175      	cbz	r5, 158c <recv_tcp+0x60>
		len = p->tot_len;
    156e:	892f      	ldrh	r7, [r5, #8]
	if (sys_mbox_trypost(&conn->recvmbox, p) != ERR_OK) {
    1570:	4b0d      	ldr	r3, [pc, #52]	; (15a8 <recv_tcp+0x7c>)
    1572:	4629      	mov	r1, r5
    1574:	4648      	mov	r0, r9
    1576:	4798      	blx	r3
    1578:	4604      	mov	r4, r0
    157a:	b960      	cbnz	r0, 1596 <recv_tcp+0x6a>
		API_EVENT(conn, NETCONN_EVT_RCVPLUS, len);
    157c:	6ab3      	ldr	r3, [r6, #40]	; 0x28
    157e:	2b00      	cmp	r3, #0
    1580:	d0e3      	beq.n	154a <recv_tcp+0x1e>
    1582:	4601      	mov	r1, r0
    1584:	463a      	mov	r2, r7
    1586:	4630      	mov	r0, r6
    1588:	4798      	blx	r3
    158a:	e7df      	b.n	154c <recv_tcp+0x20>
		len = 0;
    158c:	462f      	mov	r7, r5
    158e:	e7ef      	b.n	1570 <recv_tcp+0x44>
		return ERR_VAL;
    1590:	f06f 0405 	mvn.w	r4, #5
    1594:	e7da      	b.n	154c <recv_tcp+0x20>
		return ERR_MEM;
    1596:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
    159a:	e7d7      	b.n	154c <recv_tcp+0x20>
    159c:	00007bdd 	.word	0x00007bdd
    15a0:	00006a81 	.word	0x00006a81
    15a4:	000030e5 	.word	0x000030e5
    15a8:	00007ae9 	.word	0x00007ae9

000015ac <do_writemore.isra.0>:
 *
 * @param conn netconn (that is currently in state NETCONN_WRITE) to process
 * @return ERR_OK
 *         ERR_MEM if LWIP_TCPIP_CORE_LOCKING=1 and sending hasn't yet finished
 */
static err_t do_writemore(struct netconn *conn)
    15ac:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    15b0:	4604      	mov	r4, r0
	err_t  err;
	void * dataptr;
	u16_t  len, available;
	u8_t   write_finished = 0;
	size_t diff;
	u8_t   dontblock = netconn_is_nonblocking(conn) || (conn->current_msg->msg.w.apiflags & NETCONN_DONTBLOCK);
    15b2:	6a40      	ldr	r0, [r0, #36]	; 0x24
    15b4:	7f26      	ldrb	r6, [r4, #28]
    15b6:	7c03      	ldrb	r3, [r0, #16]
			conn->current_msg->msg.w.len = conn->write_offset;
		}
	} else
#endif /* LWIP_SO_SNDTIMEO */
	{
		dataptr = (u8_t *)conn->current_msg->msg.w.dataptr + conn->write_offset;
    15b8:	6a25      	ldr	r5, [r4, #32]
    15ba:	6881      	ldr	r1, [r0, #8]
    15bc:	f003 0204 	and.w	r2, r3, #4
    15c0:	f006 0602 	and.w	r6, r6, #2
    15c4:	4316      	orrs	r6, r2
		diff    = conn->current_msg->msg.w.len - conn->write_offset;
    15c6:	68c2      	ldr	r2, [r0, #12]
#endif
			apiflags |= TCP_WRITE_FLAG_MORE;
		} else {
			len = (u16_t)diff;
		}
		available = tcp_sndbuf(conn->pcb.tcp);
    15c8:	6860      	ldr	r0, [r4, #4]
		diff    = conn->current_msg->msg.w.len - conn->write_offset;
    15ca:	1b52      	subs	r2, r2, r5
		if (diff > 0xffffUL) { /* max_u16_t */
    15cc:	f5b2 3f80 	cmp.w	r2, #65536	; 0x10000
		dataptr = (u8_t *)conn->current_msg->msg.w.dataptr + conn->write_offset;
    15d0:	4429      	add	r1, r5
		available = tcp_sndbuf(conn->pcb.tcp);
    15d2:	f8b0 5066 	ldrh.w	r5, [r0, #102]	; 0x66
			len = 0xffff;
    15d6:	bf2a      	itet	cs
    15d8:	f64f 72ff 	movwcs	r2, #65535	; 0xffff
			len = (u16_t)diff;
    15dc:	b292      	uxthcc	r2, r2
			apiflags |= TCP_WRITE_FLAG_MORE;
    15de:	f043 0302 	orrcs.w	r3, r3, #2
		if (available < len) {
    15e2:	4295      	cmp	r5, r2
    15e4:	d230      	bcs.n	1648 <do_writemore.isra.0+0x9c>
			/* don't try to write more than sendbuf */
			len = available;
			if (dontblock) {
    15e6:	b11e      	cbz	r6, 15f0 <do_writemore.isra.0+0x44>
				if (!len) {
    15e8:	b925      	cbnz	r5, 15f4 <do_writemore.isra.0+0x48>
					err = ERR_WOULDBLOCK;
    15ea:	f06f 0706 	mvn.w	r7, #6
    15ee:	e00a      	b.n	1606 <do_writemore.isra.0+0x5a>
				}
			} else {
#if LWIP_TCPIP_CORE_LOCKING
				conn->flags |= NETCONN_FLAG_WRITE_DELAYED;
#endif
				apiflags |= TCP_WRITE_FLAG_MORE;
    15f0:	f043 0302 	orr.w	r3, r3, #2
			}
		}
		LWIP_ASSERT("do_writemore: invalid length!", ((conn->write_offset + len) <= conn->current_msg->msg.w.len));
		err = tcp_write(conn->pcb.tcp, dataptr, len, apiflags);
    15f4:	4f2a      	ldr	r7, [pc, #168]	; (16a0 <do_writemore.isra.0+0xf4>)
    15f6:	462a      	mov	r2, r5
    15f8:	47b8      	blx	r7
		/* if OK or memory error, check available space */
		if ((err == ERR_OK) || (err == ERR_MEM)) {
    15fa:	1c43      	adds	r3, r0, #1
    15fc:	b2db      	uxtb	r3, r3
    15fe:	2b01      	cmp	r3, #1
		err = tcp_write(conn->pcb.tcp, dataptr, len, apiflags);
    1600:	4607      	mov	r7, r0
		if ((err == ERR_OK) || (err == ERR_MEM)) {
    1602:	d83e      	bhi.n	1682 <do_writemore.isra.0+0xd6>
		err_mem:
			if (dontblock && (len < conn->current_msg->msg.w.len)) {
    1604:	b316      	cbz	r6, 164c <do_writemore.isra.0+0xa0>
    1606:	6a63      	ldr	r3, [r4, #36]	; 0x24
    1608:	68db      	ldr	r3, [r3, #12]
    160a:	429d      	cmp	r5, r3
    160c:	d21e      	bcs.n	164c <do_writemore.isra.0+0xa0>
				/* non-blocking write did not write everything: mark the pcb non-writable
				   and let poll_tcp check writable space to mark the pcb writable again */
				API_EVENT(conn, NETCONN_EVT_SENDMINUS, len);
    160e:	6aa3      	ldr	r3, [r4, #40]	; 0x28
    1610:	b11b      	cbz	r3, 161a <do_writemore.isra.0+0x6e>
    1612:	462a      	mov	r2, r5
    1614:	2103      	movs	r1, #3
    1616:	4620      	mov	r0, r4
    1618:	4798      	blx	r3
				conn->flags |= NETCONN_FLAG_CHECK_WRITESPACE;
    161a:	7f23      	ldrb	r3, [r4, #28]
    161c:	f043 0310 	orr.w	r3, r3, #16
    1620:	7723      	strb	r3, [r4, #28]
				   let select mark this pcb as non-writable. */
				API_EVENT(conn, NETCONN_EVT_SENDMINUS, len);
			}
		}

		if (err == ERR_OK) {
    1622:	bb37      	cbnz	r7, 1672 <do_writemore.isra.0+0xc6>
			conn->write_offset += len;
    1624:	6a22      	ldr	r2, [r4, #32]
			if ((conn->write_offset == conn->current_msg->msg.w.len) || dontblock) {
    1626:	6a63      	ldr	r3, [r4, #36]	; 0x24
			conn->write_offset += len;
    1628:	4415      	add	r5, r2
			if ((conn->write_offset == conn->current_msg->msg.w.len) || dontblock) {
    162a:	68da      	ldr	r2, [r3, #12]
			conn->write_offset += len;
    162c:	6225      	str	r5, [r4, #32]
			if ((conn->write_offset == conn->current_msg->msg.w.len) || dontblock) {
    162e:	4295      	cmp	r5, r2
    1630:	d000      	beq.n	1634 <do_writemore.isra.0+0x88>
    1632:	b11e      	cbz	r6, 163c <do_writemore.isra.0+0x90>
				/* return sent length */
				conn->current_msg->msg.w.len = conn->write_offset;
    1634:	60dd      	str	r5, [r3, #12]
				/* everything was written */
				write_finished     = 1;
				conn->write_offset = 0;
    1636:	2300      	movs	r3, #0
    1638:	6223      	str	r3, [r4, #32]
				write_finished     = 1;
    163a:	2601      	movs	r6, #1
			}
			tcp_output(conn->pcb.tcp);
    163c:	6860      	ldr	r0, [r4, #4]
    163e:	4b19      	ldr	r3, [pc, #100]	; (16a4 <do_writemore.isra.0+0xf8>)
    1640:	4798      	blx	r3
			   the error to the application thread. */
			write_finished               = 1;
			conn->current_msg->msg.w.len = 0;
		}
	}
	if (write_finished) {
    1642:	bb0e      	cbnz	r6, 1688 <do_writemore.isra.0+0xdc>
#if LWIP_TCPIP_CORE_LOCKING
	else
		return ERR_MEM;
#endif
	return ERR_OK;
}
    1644:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    1648:	4615      	mov	r5, r2
    164a:	e7d3      	b.n	15f4 <do_writemore.isra.0+0x48>
			} else if ((tcp_sndbuf(conn->pcb.tcp) <= TCP_SNDLOWAT)
    164c:	6863      	ldr	r3, [r4, #4]
    164e:	f8b3 1066 	ldrh.w	r1, [r3, #102]	; 0x66
    1652:	f640 3267 	movw	r2, #2919	; 0xb67
    1656:	4291      	cmp	r1, r2
    1658:	d903      	bls.n	1662 <do_writemore.isra.0+0xb6>
			           || (tcp_sndqueuelen(conn->pcb.tcp) >= TCP_SNDQUEUELOWAT)) {
    165a:	f8b3 3068 	ldrh.w	r3, [r3, #104]	; 0x68
    165e:	2b04      	cmp	r3, #4
    1660:	d9df      	bls.n	1622 <do_writemore.isra.0+0x76>
				API_EVENT(conn, NETCONN_EVT_SENDMINUS, len);
    1662:	6aa3      	ldr	r3, [r4, #40]	; 0x28
    1664:	2b00      	cmp	r3, #0
    1666:	d0dc      	beq.n	1622 <do_writemore.isra.0+0x76>
    1668:	462a      	mov	r2, r5
    166a:	2103      	movs	r1, #3
    166c:	4620      	mov	r0, r4
    166e:	4798      	blx	r3
    1670:	e7d7      	b.n	1622 <do_writemore.isra.0+0x76>
		} else if ((err == ERR_MEM) && !dontblock) {
    1672:	1c7b      	adds	r3, r7, #1
    1674:	d105      	bne.n	1682 <do_writemore.isra.0+0xd6>
    1676:	b926      	cbnz	r6, 1682 <do_writemore.isra.0+0xd6>
			tcp_output(conn->pcb.tcp);
    1678:	6860      	ldr	r0, [r4, #4]
    167a:	4b0a      	ldr	r3, [pc, #40]	; (16a4 <do_writemore.isra.0+0xf8>)
}
    167c:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
			tcp_output(conn->pcb.tcp);
    1680:	4718      	bx	r3
			conn->current_msg->msg.w.len = 0;
    1682:	6a63      	ldr	r3, [r4, #36]	; 0x24
    1684:	2200      	movs	r2, #0
    1686:	60da      	str	r2, [r3, #12]
		conn->current_msg->err = err;
    1688:	6a63      	ldr	r3, [r4, #36]	; 0x24
    168a:	711f      	strb	r7, [r3, #4]
		conn->current_msg      = NULL;
    168c:	2300      	movs	r3, #0
    168e:	6263      	str	r3, [r4, #36]	; 0x24
		conn->state            = NETCONN_NONE;
    1690:	7063      	strb	r3, [r4, #1]
			sys_sem_signal(&conn->op_completed);
    1692:	f104 000c 	add.w	r0, r4, #12
    1696:	4b04      	ldr	r3, [pc, #16]	; (16a8 <do_writemore.isra.0+0xfc>)
}
    1698:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
			sys_sem_signal(&conn->op_completed);
    169c:	4718      	bx	r3
    169e:	bf00      	nop
    16a0:	00001ffd 	.word	0x00001ffd
    16a4:	000024a5 	.word	0x000024a5
    16a8:	00007a19 	.word	0x00007a19

000016ac <sent_tcp>:
{
    16ac:	b538      	push	{r3, r4, r5, lr}
	if (conn->state == NETCONN_WRITE) {
    16ae:	7843      	ldrb	r3, [r0, #1]
    16b0:	2b01      	cmp	r3, #1
{
    16b2:	4604      	mov	r4, r0
    16b4:	4615      	mov	r5, r2
	if (conn->state == NETCONN_WRITE) {
    16b6:	d119      	bne.n	16ec <sent_tcp+0x40>
		do_writemore(conn);
    16b8:	4b0e      	ldr	r3, [pc, #56]	; (16f4 <sent_tcp+0x48>)
		do_close_internal(conn);
    16ba:	4798      	blx	r3
		if ((conn->pcb.tcp != NULL) && (tcp_sndbuf(conn->pcb.tcp) > TCP_SNDLOWAT)
    16bc:	6863      	ldr	r3, [r4, #4]
    16be:	b19b      	cbz	r3, 16e8 <sent_tcp+0x3c>
    16c0:	f8b3 1066 	ldrh.w	r1, [r3, #102]	; 0x66
    16c4:	f640 3267 	movw	r2, #2919	; 0xb67
    16c8:	4291      	cmp	r1, r2
    16ca:	d90d      	bls.n	16e8 <sent_tcp+0x3c>
		    && (tcp_sndqueuelen(conn->pcb.tcp) < TCP_SNDQUEUELOWAT)) {
    16cc:	f8b3 3068 	ldrh.w	r3, [r3, #104]	; 0x68
    16d0:	2b04      	cmp	r3, #4
    16d2:	d809      	bhi.n	16e8 <sent_tcp+0x3c>
			conn->flags &= ~NETCONN_FLAG_CHECK_WRITESPACE;
    16d4:	7f23      	ldrb	r3, [r4, #28]
    16d6:	f023 0310 	bic.w	r3, r3, #16
    16da:	7723      	strb	r3, [r4, #28]
			API_EVENT(conn, NETCONN_EVT_SENDPLUS, len);
    16dc:	6aa3      	ldr	r3, [r4, #40]	; 0x28
    16de:	b11b      	cbz	r3, 16e8 <sent_tcp+0x3c>
    16e0:	462a      	mov	r2, r5
    16e2:	2102      	movs	r1, #2
    16e4:	4620      	mov	r0, r4
    16e6:	4798      	blx	r3
}
    16e8:	2000      	movs	r0, #0
    16ea:	bd38      	pop	{r3, r4, r5, pc}
	} else if (conn->state == NETCONN_CLOSE) {
    16ec:	2b04      	cmp	r3, #4
    16ee:	d1e5      	bne.n	16bc <sent_tcp+0x10>
		do_close_internal(conn);
    16f0:	4b01      	ldr	r3, [pc, #4]	; (16f8 <sent_tcp+0x4c>)
    16f2:	e7e2      	b.n	16ba <sent_tcp+0xe>
    16f4:	000015ad 	.word	0x000015ad
    16f8:	0000141d 	.word	0x0000141d

000016fc <poll_tcp>:
{
    16fc:	b510      	push	{r4, lr}
	if (conn->state == NETCONN_WRITE) {
    16fe:	7843      	ldrb	r3, [r0, #1]
    1700:	2b01      	cmp	r3, #1
{
    1702:	4604      	mov	r4, r0
	if (conn->state == NETCONN_WRITE) {
    1704:	d11b      	bne.n	173e <poll_tcp+0x42>
		do_writemore(conn);
    1706:	4b10      	ldr	r3, [pc, #64]	; (1748 <poll_tcp+0x4c>)
		do_close_internal(conn);
    1708:	4798      	blx	r3
	if (conn->flags & NETCONN_FLAG_CHECK_WRITESPACE) {
    170a:	7f23      	ldrb	r3, [r4, #28]
    170c:	06da      	lsls	r2, r3, #27
    170e:	d514      	bpl.n	173a <poll_tcp+0x3e>
		if ((conn->pcb.tcp != NULL) && (tcp_sndbuf(conn->pcb.tcp) > TCP_SNDLOWAT)
    1710:	6862      	ldr	r2, [r4, #4]
    1712:	b192      	cbz	r2, 173a <poll_tcp+0x3e>
    1714:	f8b2 0066 	ldrh.w	r0, [r2, #102]	; 0x66
    1718:	f640 3167 	movw	r1, #2919	; 0xb67
    171c:	4288      	cmp	r0, r1
    171e:	d90c      	bls.n	173a <poll_tcp+0x3e>
		    && (tcp_sndqueuelen(conn->pcb.tcp) < TCP_SNDQUEUELOWAT)) {
    1720:	f8b2 2068 	ldrh.w	r2, [r2, #104]	; 0x68
    1724:	2a04      	cmp	r2, #4
    1726:	d808      	bhi.n	173a <poll_tcp+0x3e>
			conn->flags &= ~NETCONN_FLAG_CHECK_WRITESPACE;
    1728:	f023 0310 	bic.w	r3, r3, #16
    172c:	7723      	strb	r3, [r4, #28]
			API_EVENT(conn, NETCONN_EVT_SENDPLUS, 0);
    172e:	6aa3      	ldr	r3, [r4, #40]	; 0x28
    1730:	b11b      	cbz	r3, 173a <poll_tcp+0x3e>
    1732:	2200      	movs	r2, #0
    1734:	2102      	movs	r1, #2
    1736:	4620      	mov	r0, r4
    1738:	4798      	blx	r3
}
    173a:	2000      	movs	r0, #0
    173c:	bd10      	pop	{r4, pc}
	} else if (conn->state == NETCONN_CLOSE) {
    173e:	2b04      	cmp	r3, #4
    1740:	d1e3      	bne.n	170a <poll_tcp+0xe>
		do_close_internal(conn);
    1742:	4b02      	ldr	r3, [pc, #8]	; (174c <poll_tcp+0x50>)
    1744:	e7e0      	b.n	1708 <poll_tcp+0xc>
    1746:	bf00      	nop
    1748:	000015ad 	.word	0x000015ad
    174c:	0000141d 	.word	0x0000141d

00001750 <do_newconn>:
{
    1750:	b570      	push	{r4, r5, r6, lr}
	msg->err = ERR_OK;
    1752:	2300      	movs	r3, #0
	if (msg->conn->pcb.tcp == NULL) {
    1754:	6805      	ldr	r5, [r0, #0]
	msg->err = ERR_OK;
    1756:	7103      	strb	r3, [r0, #4]
	if (msg->conn->pcb.tcp == NULL) {
    1758:	686b      	ldr	r3, [r5, #4]
{
    175a:	4604      	mov	r4, r0
	if (msg->conn->pcb.tcp == NULL) {
    175c:	b9bb      	cbnz	r3, 178e <do_newconn+0x3e>
	switch (NETCONNTYPE_GROUP(msg->conn->type)) {
    175e:	782b      	ldrb	r3, [r5, #0]
    1760:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
    1764:	2b10      	cmp	r3, #16
    1766:	d018      	beq.n	179a <do_newconn+0x4a>
    1768:	2b20      	cmp	r3, #32
    176a:	d120      	bne.n	17ae <do_newconn+0x5e>
		msg->conn->pcb.udp = udp_new();
    176c:	4b11      	ldr	r3, [pc, #68]	; (17b4 <do_newconn+0x64>)
    176e:	4798      	blx	r3
		if (msg->conn->pcb.udp == NULL) {
    1770:	6822      	ldr	r2, [r4, #0]
		msg->conn->pcb.udp = udp_new();
    1772:	6068      	str	r0, [r5, #4]
		if (msg->conn->pcb.udp == NULL) {
    1774:	6850      	ldr	r0, [r2, #4]
    1776:	b910      	cbnz	r0, 177e <do_newconn+0x2e>
			msg->err = ERR_MEM;
    1778:	23ff      	movs	r3, #255	; 0xff
		msg->err = ERR_VAL;
    177a:	7123      	strb	r3, [r4, #4]
		break;
    177c:	e007      	b.n	178e <do_newconn+0x3e>
		if (msg->conn->type == NETCONN_UDPNOCHKSUM) {
    177e:	7813      	ldrb	r3, [r2, #0]
		udp_recv(msg->conn->pcb.udp, recv_udp, msg->conn);
    1780:	490d      	ldr	r1, [pc, #52]	; (17b8 <do_newconn+0x68>)
		if (msg->conn->type == NETCONN_UDPNOCHKSUM) {
    1782:	2b22      	cmp	r3, #34	; 0x22
			udp_setflags(msg->conn->pcb.udp, UDP_FLAGS_NOCHKSUM);
    1784:	bf04      	itt	eq
    1786:	2301      	moveq	r3, #1
    1788:	7403      	strbeq	r3, [r0, #16]
		udp_recv(msg->conn->pcb.udp, recv_udp, msg->conn);
    178a:	4b0c      	ldr	r3, [pc, #48]	; (17bc <do_newconn+0x6c>)
    178c:	4798      	blx	r3
	TCPIP_APIMSG_ACK(msg);
    178e:	6820      	ldr	r0, [r4, #0]
    1790:	4b0b      	ldr	r3, [pc, #44]	; (17c0 <do_newconn+0x70>)
}
    1792:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	TCPIP_APIMSG_ACK(msg);
    1796:	300c      	adds	r0, #12
    1798:	4718      	bx	r3
		msg->conn->pcb.tcp = tcp_new();
    179a:	4b0a      	ldr	r3, [pc, #40]	; (17c4 <do_newconn+0x74>)
    179c:	4798      	blx	r3
    179e:	6068      	str	r0, [r5, #4]
		if (msg->conn->pcb.tcp == NULL) {
    17a0:	6820      	ldr	r0, [r4, #0]
    17a2:	6843      	ldr	r3, [r0, #4]
    17a4:	2b00      	cmp	r3, #0
    17a6:	d0e7      	beq.n	1778 <do_newconn+0x28>
		setup_tcp(msg->conn);
    17a8:	4b07      	ldr	r3, [pc, #28]	; (17c8 <do_newconn+0x78>)
    17aa:	4798      	blx	r3
		break;
    17ac:	e7ef      	b.n	178e <do_newconn+0x3e>
		msg->err = ERR_VAL;
    17ae:	23fa      	movs	r3, #250	; 0xfa
    17b0:	e7e3      	b.n	177a <do_newconn+0x2a>
    17b2:	bf00      	nop
    17b4:	0000487d 	.word	0x0000487d
    17b8:	0000133d 	.word	0x0000133d
    17bc:	00004845 	.word	0x00004845
    17c0:	00007a19 	.word	0x00007a19
    17c4:	00007391 	.word	0x00007391
    17c8:	000013c5 	.word	0x000013c5

000017cc <netconn_alloc>:
{
    17cc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	conn = (struct netconn *)memp_malloc(MEMP_NETCONN);
    17ce:	4b17      	ldr	r3, [pc, #92]	; (182c <netconn_alloc+0x60>)
{
    17d0:	4605      	mov	r5, r0
	conn = (struct netconn *)memp_malloc(MEMP_NETCONN);
    17d2:	2007      	movs	r0, #7
{
    17d4:	460e      	mov	r6, r1
	conn = (struct netconn *)memp_malloc(MEMP_NETCONN);
    17d6:	4798      	blx	r3
	if (conn == NULL) {
    17d8:	4604      	mov	r4, r0
    17da:	b320      	cbz	r0, 1826 <netconn_alloc+0x5a>
	conn->last_err = ERR_OK;
    17dc:	2100      	movs	r1, #0
	if (sys_sem_new(&conn->op_completed, 0) != ERR_OK) {
    17de:	f100 070c 	add.w	r7, r0, #12
	conn->last_err = ERR_OK;
    17e2:	7201      	strb	r1, [r0, #8]
	conn->type     = t;
    17e4:	7005      	strb	r5, [r0, #0]
	conn->pcb.tcp  = NULL;
    17e6:	6041      	str	r1, [r0, #4]
	if (sys_sem_new(&conn->op_completed, 0) != ERR_OK) {
    17e8:	4b11      	ldr	r3, [pc, #68]	; (1830 <netconn_alloc+0x64>)
    17ea:	4638      	mov	r0, r7
    17ec:	4798      	blx	r3
    17ee:	b940      	cbnz	r0, 1802 <netconn_alloc+0x36>
	if (sys_mbox_new(&conn->recvmbox, size) != ERR_OK) {
    17f0:	2110      	movs	r1, #16
    17f2:	4b10      	ldr	r3, [pc, #64]	; (1834 <netconn_alloc+0x68>)
    17f4:	1860      	adds	r0, r4, r1
    17f6:	4798      	blx	r3
    17f8:	4605      	mov	r5, r0
    17fa:	b140      	cbz	r0, 180e <netconn_alloc+0x42>
		sys_sem_free(&conn->op_completed);
    17fc:	4b0e      	ldr	r3, [pc, #56]	; (1838 <netconn_alloc+0x6c>)
    17fe:	4638      	mov	r0, r7
    1800:	4798      	blx	r3
	memp_free(MEMP_NETCONN, conn);
    1802:	4621      	mov	r1, r4
    1804:	4b0d      	ldr	r3, [pc, #52]	; (183c <netconn_alloc+0x70>)
    1806:	2007      	movs	r0, #7
    1808:	4798      	blx	r3
	return NULL;
    180a:	2400      	movs	r4, #0
    180c:	e00b      	b.n	1826 <netconn_alloc+0x5a>
	sys_mbox_set_invalid(&conn->acceptmbox);
    180e:	4b0c      	ldr	r3, [pc, #48]	; (1840 <netconn_alloc+0x74>)
    1810:	f104 0014 	add.w	r0, r4, #20
    1814:	4798      	blx	r3
	conn->current_msg  = NULL;
    1816:	e9c4 5609 	strd	r5, r6, [r4, #36]	; 0x24
	conn->socket = -1;
    181a:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
	conn->state = NETCONN_NONE;
    181e:	7065      	strb	r5, [r4, #1]
	conn->socket = -1;
    1820:	61a3      	str	r3, [r4, #24]
	conn->write_offset = 0;
    1822:	6225      	str	r5, [r4, #32]
	conn->flags = 0;
    1824:	7725      	strb	r5, [r4, #28]
}
    1826:	4620      	mov	r0, r4
    1828:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    182a:	bf00      	nop
    182c:	00004c01 	.word	0x00004c01
    1830:	000079a9 	.word	0x000079a9
    1834:	00007a9d 	.word	0x00007a9d
    1838:	00007a09 	.word	0x00007a09
    183c:	00004c1d 	.word	0x00004c1d
    1840:	00007be1 	.word	0x00007be1

00001844 <netconn_free>:
{
    1844:	b513      	push	{r0, r1, r4, lr}
	sys_sem_free(&conn->op_completed);
    1846:	4b07      	ldr	r3, [pc, #28]	; (1864 <netconn_free+0x20>)
{
    1848:	4604      	mov	r4, r0
	sys_sem_free(&conn->op_completed);
    184a:	300c      	adds	r0, #12
    184c:	9001      	str	r0, [sp, #4]
    184e:	4798      	blx	r3
	sys_sem_set_invalid(&conn->op_completed);
    1850:	9801      	ldr	r0, [sp, #4]
    1852:	4b05      	ldr	r3, [pc, #20]	; (1868 <netconn_free+0x24>)
    1854:	4798      	blx	r3
	memp_free(MEMP_NETCONN, conn);
    1856:	4b05      	ldr	r3, [pc, #20]	; (186c <netconn_free+0x28>)
    1858:	4621      	mov	r1, r4
    185a:	2007      	movs	r0, #7
}
    185c:	b002      	add	sp, #8
    185e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	memp_free(MEMP_NETCONN, conn);
    1862:	4718      	bx	r3
    1864:	00007a09 	.word	0x00007a09
    1868:	00007a95 	.word	0x00007a95
    186c:	00004c1d 	.word	0x00004c1d

00001870 <netconn_drain>:
{
    1870:	e92d 47f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, r9, sl, lr}
	if (sys_mbox_valid(&conn->recvmbox)) {
    1874:	f100 0510 	add.w	r5, r0, #16
{
    1878:	4604      	mov	r4, r0
	if (sys_mbox_valid(&conn->recvmbox)) {
    187a:	4f24      	ldr	r7, [pc, #144]	; (190c <netconn_drain+0x9c>)
    187c:	4628      	mov	r0, r5
    187e:	47b8      	blx	r7
    1880:	b180      	cbz	r0, 18a4 <netconn_drain+0x34>
		while (sys_mbox_tryfetch(&conn->recvmbox, &mem) != SYS_MBOX_EMPTY) {
    1882:	f8df 8094 	ldr.w	r8, [pc, #148]	; 1918 <netconn_drain+0xa8>
				netbuf_delete((struct netbuf *)mem);
    1886:	f8df 909c 	ldr.w	r9, [pc, #156]	; 1924 <netconn_drain+0xb4>
					pbuf_free(p);
    188a:	f8df a09c 	ldr.w	sl, [pc, #156]	; 1928 <netconn_drain+0xb8>
		while (sys_mbox_tryfetch(&conn->recvmbox, &mem) != SYS_MBOX_EMPTY) {
    188e:	a901      	add	r1, sp, #4
    1890:	4628      	mov	r0, r5
    1892:	47c0      	blx	r8
    1894:	3001      	adds	r0, #1
    1896:	d11b      	bne.n	18d0 <netconn_drain+0x60>
		sys_mbox_free(&conn->recvmbox);
    1898:	4b1d      	ldr	r3, [pc, #116]	; (1910 <netconn_drain+0xa0>)
    189a:	4628      	mov	r0, r5
    189c:	4798      	blx	r3
		sys_mbox_set_invalid(&conn->recvmbox);
    189e:	4b1d      	ldr	r3, [pc, #116]	; (1914 <netconn_drain+0xa4>)
    18a0:	4628      	mov	r0, r5
    18a2:	4798      	blx	r3
	if (sys_mbox_valid(&conn->acceptmbox)) {
    18a4:	3414      	adds	r4, #20
    18a6:	4620      	mov	r0, r4
    18a8:	47b8      	blx	r7
    18aa:	b170      	cbz	r0, 18ca <netconn_drain+0x5a>
		while (sys_mbox_tryfetch(&conn->acceptmbox, &mem) != SYS_MBOX_EMPTY) {
    18ac:	4e1a      	ldr	r6, [pc, #104]	; (1918 <netconn_drain+0xa8>)
				tcp_abort(newconn->pcb.tcp);
    18ae:	4f1b      	ldr	r7, [pc, #108]	; (191c <netconn_drain+0xac>)
			netconn_free(newconn);
    18b0:	f8df 8078 	ldr.w	r8, [pc, #120]	; 192c <netconn_drain+0xbc>
		while (sys_mbox_tryfetch(&conn->acceptmbox, &mem) != SYS_MBOX_EMPTY) {
    18b4:	a901      	add	r1, sp, #4
    18b6:	4620      	mov	r0, r4
    18b8:	47b0      	blx	r6
    18ba:	3001      	adds	r0, #1
    18bc:	d119      	bne.n	18f2 <netconn_drain+0x82>
		sys_mbox_free(&conn->acceptmbox);
    18be:	4b14      	ldr	r3, [pc, #80]	; (1910 <netconn_drain+0xa0>)
    18c0:	4620      	mov	r0, r4
    18c2:	4798      	blx	r3
		sys_mbox_set_invalid(&conn->acceptmbox);
    18c4:	4b13      	ldr	r3, [pc, #76]	; (1914 <netconn_drain+0xa4>)
    18c6:	4620      	mov	r0, r4
    18c8:	4798      	blx	r3
}
    18ca:	b002      	add	sp, #8
    18cc:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
			if (conn->type == NETCONN_TCP) {
    18d0:	7823      	ldrb	r3, [r4, #0]
				if (mem != NULL) {
    18d2:	9e01      	ldr	r6, [sp, #4]
			if (conn->type == NETCONN_TCP) {
    18d4:	2b10      	cmp	r3, #16
    18d6:	d109      	bne.n	18ec <netconn_drain+0x7c>
				if (mem != NULL) {
    18d8:	2e00      	cmp	r6, #0
    18da:	d0d8      	beq.n	188e <netconn_drain+0x1e>
					if (conn->pcb.tcp != NULL) {
    18dc:	6860      	ldr	r0, [r4, #4]
    18de:	b110      	cbz	r0, 18e6 <netconn_drain+0x76>
						tcp_recved(conn->pcb.tcp, p->tot_len);
    18e0:	8931      	ldrh	r1, [r6, #8]
    18e2:	4b0f      	ldr	r3, [pc, #60]	; (1920 <netconn_drain+0xb0>)
    18e4:	4798      	blx	r3
					pbuf_free(p);
    18e6:	4630      	mov	r0, r6
    18e8:	47d0      	blx	sl
    18ea:	e7d0      	b.n	188e <netconn_drain+0x1e>
				netbuf_delete((struct netbuf *)mem);
    18ec:	4630      	mov	r0, r6
    18ee:	47c8      	blx	r9
    18f0:	e7cd      	b.n	188e <netconn_drain+0x1e>
			struct netconn *newconn = (struct netconn *)mem;
    18f2:	9d01      	ldr	r5, [sp, #4]
			netconn_drain(newconn);
    18f4:	4628      	mov	r0, r5
    18f6:	f7ff ffbb 	bl	1870 <netconn_drain>
			if (newconn->pcb.tcp != NULL) {
    18fa:	6868      	ldr	r0, [r5, #4]
    18fc:	b110      	cbz	r0, 1904 <netconn_drain+0x94>
				tcp_abort(newconn->pcb.tcp);
    18fe:	47b8      	blx	r7
				newconn->pcb.tcp = NULL;
    1900:	2300      	movs	r3, #0
    1902:	606b      	str	r3, [r5, #4]
			netconn_free(newconn);
    1904:	4628      	mov	r0, r5
    1906:	47c0      	blx	r8
    1908:	e7d4      	b.n	18b4 <netconn_drain+0x44>
    190a:	bf00      	nop
    190c:	00007bdd 	.word	0x00007bdd
    1910:	00007abd 	.word	0x00007abd
    1914:	00007be1 	.word	0x00007be1
    1918:	00007bb5 	.word	0x00007bb5
    191c:	00007275 	.word	0x00007275
    1920:	00006a81 	.word	0x00006a81
    1924:	00000d7d 	.word	0x00000d7d
    1928:	000030e5 	.word	0x000030e5
    192c:	00001845 	.word	0x00001845

00001930 <accept_function>:
{
    1930:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
	if (!sys_mbox_valid(&conn->acceptmbox)) {
    1934:	f100 0814 	add.w	r8, r0, #20
{
    1938:	4606      	mov	r6, r0
	if (!sys_mbox_valid(&conn->acceptmbox)) {
    193a:	4b25      	ldr	r3, [pc, #148]	; (19d0 <accept_function+0xa0>)
    193c:	4640      	mov	r0, r8
{
    193e:	460f      	mov	r7, r1
    1940:	4615      	mov	r5, r2
	if (!sys_mbox_valid(&conn->acceptmbox)) {
    1942:	4798      	blx	r3
    1944:	2800      	cmp	r0, #0
    1946:	d040      	beq.n	19ca <accept_function+0x9a>
	newconn = netconn_alloc(conn->type, conn->callback);
    1948:	6ab1      	ldr	r1, [r6, #40]	; 0x28
    194a:	7830      	ldrb	r0, [r6, #0]
    194c:	4b21      	ldr	r3, [pc, #132]	; (19d4 <accept_function+0xa4>)
    194e:	4798      	blx	r3
	if (newconn == NULL) {
    1950:	4604      	mov	r4, r0
    1952:	2800      	cmp	r0, #0
    1954:	d02c      	beq.n	19b0 <accept_function+0x80>
	setup_tcp(newconn);
    1956:	4b20      	ldr	r3, [pc, #128]	; (19d8 <accept_function+0xa8>)
	newconn->pcb.tcp = newpcb;
    1958:	6047      	str	r7, [r0, #4]
	setup_tcp(newconn);
    195a:	4798      	blx	r3
	newconn->last_err = err;
    195c:	7225      	strb	r5, [r4, #8]
	if (sys_mbox_trypost(&conn->acceptmbox, newconn) != ERR_OK) {
    195e:	4b1f      	ldr	r3, [pc, #124]	; (19dc <accept_function+0xac>)
    1960:	4621      	mov	r1, r4
    1962:	4640      	mov	r0, r8
    1964:	4798      	blx	r3
    1966:	4605      	mov	r5, r0
    1968:	b328      	cbz	r0, 19b6 <accept_function+0x86>
		struct tcp_pcb *pcb = newconn->pcb.tcp;
    196a:	6860      	ldr	r0, [r4, #4]
		tcp_arg(pcb, NULL);
    196c:	4b1c      	ldr	r3, [pc, #112]	; (19e0 <accept_function+0xb0>)
    196e:	9001      	str	r0, [sp, #4]
    1970:	2100      	movs	r1, #0
    1972:	4798      	blx	r3
		tcp_recv(pcb, NULL);
    1974:	9801      	ldr	r0, [sp, #4]
    1976:	4b1b      	ldr	r3, [pc, #108]	; (19e4 <accept_function+0xb4>)
    1978:	2100      	movs	r1, #0
    197a:	4798      	blx	r3
		tcp_sent(pcb, NULL);
    197c:	9801      	ldr	r0, [sp, #4]
    197e:	4b1a      	ldr	r3, [pc, #104]	; (19e8 <accept_function+0xb8>)
    1980:	2100      	movs	r1, #0
    1982:	4798      	blx	r3
		tcp_poll(pcb, NULL, 4);
    1984:	2204      	movs	r2, #4
    1986:	9801      	ldr	r0, [sp, #4]
    1988:	4b18      	ldr	r3, [pc, #96]	; (19ec <accept_function+0xbc>)
    198a:	2100      	movs	r1, #0
    198c:	4798      	blx	r3
		tcp_err(pcb, NULL);
    198e:	2100      	movs	r1, #0
    1990:	9801      	ldr	r0, [sp, #4]
    1992:	4b17      	ldr	r3, [pc, #92]	; (19f0 <accept_function+0xc0>)
    1994:	4798      	blx	r3
		newconn->pcb.tcp = NULL;
    1996:	2300      	movs	r3, #0
		sys_mbox_free(&newconn->recvmbox);
    1998:	f104 0010 	add.w	r0, r4, #16
		newconn->pcb.tcp = NULL;
    199c:	6063      	str	r3, [r4, #4]
		sys_mbox_free(&newconn->recvmbox);
    199e:	4b15      	ldr	r3, [pc, #84]	; (19f4 <accept_function+0xc4>)
    19a0:	9001      	str	r0, [sp, #4]
    19a2:	4798      	blx	r3
		sys_mbox_set_invalid(&newconn->recvmbox);
    19a4:	9801      	ldr	r0, [sp, #4]
    19a6:	4b14      	ldr	r3, [pc, #80]	; (19f8 <accept_function+0xc8>)
    19a8:	4798      	blx	r3
		netconn_free(newconn);
    19aa:	4b14      	ldr	r3, [pc, #80]	; (19fc <accept_function+0xcc>)
    19ac:	4620      	mov	r0, r4
    19ae:	4798      	blx	r3
		return ERR_MEM;
    19b0:	f04f 35ff 	mov.w	r5, #4294967295	; 0xffffffff
    19b4:	e005      	b.n	19c2 <accept_function+0x92>
		API_EVENT(conn, NETCONN_EVT_RCVPLUS, 0);
    19b6:	6ab3      	ldr	r3, [r6, #40]	; 0x28
    19b8:	b11b      	cbz	r3, 19c2 <accept_function+0x92>
    19ba:	4602      	mov	r2, r0
    19bc:	4601      	mov	r1, r0
    19be:	4630      	mov	r0, r6
    19c0:	4798      	blx	r3
}
    19c2:	4628      	mov	r0, r5
    19c4:	b002      	add	sp, #8
    19c6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		return ERR_VAL;
    19ca:	f06f 0505 	mvn.w	r5, #5
    19ce:	e7f8      	b.n	19c2 <accept_function+0x92>
    19d0:	00007bdd 	.word	0x00007bdd
    19d4:	000017cd 	.word	0x000017cd
    19d8:	000013c5 	.word	0x000013c5
    19dc:	00007ae9 	.word	0x00007ae9
    19e0:	00006b2d 	.word	0x00006b2d
    19e4:	00006b31 	.word	0x00006b31
    19e8:	00006b37 	.word	0x00006b37
    19ec:	00006b45 	.word	0x00006b45
    19f0:	00006b3b 	.word	0x00006b3b
    19f4:	00007abd 	.word	0x00007abd
    19f8:	00007be1 	.word	0x00007be1
    19fc:	00001845 	.word	0x00001845

00001a00 <do_delconn>:
{
    1a00:	b510      	push	{r4, lr}
    1a02:	4604      	mov	r4, r0
	if ((msg->conn->state != NETCONN_NONE) && (msg->conn->state != NETCONN_LISTEN)
    1a04:	6800      	ldr	r0, [r0, #0]
    1a06:	7843      	ldrb	r3, [r0, #1]
    1a08:	b183      	cbz	r3, 1a2c <do_delconn+0x2c>
    1a0a:	3b02      	subs	r3, #2
    1a0c:	2b01      	cmp	r3, #1
    1a0e:	d90d      	bls.n	1a2c <do_delconn+0x2c>
		msg->err = ERR_INPROGRESS;
    1a10:	23fb      	movs	r3, #251	; 0xfb
    1a12:	7123      	strb	r3, [r4, #4]
	if (sys_sem_valid(&msg->conn->op_completed)) {
    1a14:	6820      	ldr	r0, [r4, #0]
    1a16:	4b1b      	ldr	r3, [pc, #108]	; (1a84 <do_delconn+0x84>)
    1a18:	300c      	adds	r0, #12
    1a1a:	4798      	blx	r3
    1a1c:	2800      	cmp	r0, #0
    1a1e:	d030      	beq.n	1a82 <do_delconn+0x82>
		sys_sem_signal(&msg->conn->op_completed);
    1a20:	6820      	ldr	r0, [r4, #0]
    1a22:	4b19      	ldr	r3, [pc, #100]	; (1a88 <do_delconn+0x88>)
}
    1a24:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		sys_sem_signal(&msg->conn->op_completed);
    1a28:	300c      	adds	r0, #12
    1a2a:	4718      	bx	r3
		netconn_drain(msg->conn);
    1a2c:	4b17      	ldr	r3, [pc, #92]	; (1a8c <do_delconn+0x8c>)
    1a2e:	4798      	blx	r3
		if (msg->conn->pcb.tcp != NULL) {
    1a30:	6823      	ldr	r3, [r4, #0]
    1a32:	6858      	ldr	r0, [r3, #4]
    1a34:	b168      	cbz	r0, 1a52 <do_delconn+0x52>
			switch (NETCONNTYPE_GROUP(msg->conn->type)) {
    1a36:	781a      	ldrb	r2, [r3, #0]
    1a38:	f002 02f0 	and.w	r2, r2, #240	; 0xf0
    1a3c:	2a10      	cmp	r2, #16
    1a3e:	d016      	beq.n	1a6e <do_delconn+0x6e>
    1a40:	2a20      	cmp	r2, #32
    1a42:	d103      	bne.n	1a4c <do_delconn+0x4c>
				msg->conn->pcb.udp->recv_arg = NULL;
    1a44:	2300      	movs	r3, #0
    1a46:	61c3      	str	r3, [r0, #28]
				udp_remove(msg->conn->pcb.udp);
    1a48:	4b11      	ldr	r3, [pc, #68]	; (1a90 <do_delconn+0x90>)
    1a4a:	4798      	blx	r3
			msg->conn->pcb.tcp = NULL;
    1a4c:	6823      	ldr	r3, [r4, #0]
    1a4e:	2200      	movs	r2, #0
    1a50:	605a      	str	r2, [r3, #4]
		API_EVENT(msg->conn, NETCONN_EVT_RCVPLUS, 0);
    1a52:	6820      	ldr	r0, [r4, #0]
    1a54:	6a83      	ldr	r3, [r0, #40]	; 0x28
    1a56:	b113      	cbz	r3, 1a5e <do_delconn+0x5e>
    1a58:	2200      	movs	r2, #0
    1a5a:	4611      	mov	r1, r2
    1a5c:	4798      	blx	r3
		API_EVENT(msg->conn, NETCONN_EVT_SENDPLUS, 0);
    1a5e:	6820      	ldr	r0, [r4, #0]
    1a60:	6a83      	ldr	r3, [r0, #40]	; 0x28
    1a62:	2b00      	cmp	r3, #0
    1a64:	d0d6      	beq.n	1a14 <do_delconn+0x14>
    1a66:	2200      	movs	r2, #0
    1a68:	2102      	movs	r1, #2
    1a6a:	4798      	blx	r3
    1a6c:	e7d2      	b.n	1a14 <do_delconn+0x14>
				msg->conn->state       = NETCONN_CLOSE;
    1a6e:	2204      	movs	r2, #4
    1a70:	705a      	strb	r2, [r3, #1]
				msg->msg.sd.shut       = NETCONN_SHUT_RDWR;
    1a72:	2203      	movs	r2, #3
    1a74:	7222      	strb	r2, [r4, #8]
				do_close_internal(msg->conn);
    1a76:	4618      	mov	r0, r3
				msg->conn->current_msg = msg;
    1a78:	625c      	str	r4, [r3, #36]	; 0x24
}
    1a7a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
				do_close_internal(msg->conn);
    1a7e:	4b05      	ldr	r3, [pc, #20]	; (1a94 <do_delconn+0x94>)
    1a80:	4718      	bx	r3
}
    1a82:	bd10      	pop	{r4, pc}
    1a84:	00007a91 	.word	0x00007a91
    1a88:	00007a19 	.word	0x00007a19
    1a8c:	00001871 	.word	0x00001871
    1a90:	0000484d 	.word	0x0000484d
    1a94:	0000141d 	.word	0x0000141d

00001a98 <do_bind>:
{
    1a98:	b510      	push	{r4, lr}
	if (ERR_IS_FATAL(msg->conn->last_err)) {
    1a9a:	6803      	ldr	r3, [r0, #0]
    1a9c:	f993 2008 	ldrsb.w	r2, [r3, #8]
    1aa0:	f112 0f09 	cmn.w	r2, #9
{
    1aa4:	4604      	mov	r4, r0
	if (ERR_IS_FATAL(msg->conn->last_err)) {
    1aa6:	da06      	bge.n	1ab6 <do_bind+0x1e>
		msg->err = msg->conn->last_err;
    1aa8:	7102      	strb	r2, [r0, #4]
	TCPIP_APIMSG_ACK(msg);
    1aaa:	6820      	ldr	r0, [r4, #0]
    1aac:	4b0d      	ldr	r3, [pc, #52]	; (1ae4 <do_bind+0x4c>)
}
    1aae:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	TCPIP_APIMSG_ACK(msg);
    1ab2:	300c      	adds	r0, #12
    1ab4:	4718      	bx	r3
		msg->err = ERR_VAL;
    1ab6:	22fa      	movs	r2, #250	; 0xfa
    1ab8:	7102      	strb	r2, [r0, #4]
		if (msg->conn->pcb.tcp != NULL) {
    1aba:	6858      	ldr	r0, [r3, #4]
    1abc:	2800      	cmp	r0, #0
    1abe:	d0f4      	beq.n	1aaa <do_bind+0x12>
			switch (NETCONNTYPE_GROUP(msg->conn->type)) {
    1ac0:	781b      	ldrb	r3, [r3, #0]
    1ac2:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
    1ac6:	2b10      	cmp	r3, #16
    1ac8:	d007      	beq.n	1ada <do_bind+0x42>
    1aca:	2b20      	cmp	r3, #32
    1acc:	d1ed      	bne.n	1aaa <do_bind+0x12>
				msg->err = udp_bind(msg->conn->pcb.udp, msg->msg.bc.ipaddr, msg->msg.bc.port);
    1ace:	89a2      	ldrh	r2, [r4, #12]
    1ad0:	68a1      	ldr	r1, [r4, #8]
    1ad2:	4b05      	ldr	r3, [pc, #20]	; (1ae8 <do_bind+0x50>)
				msg->err = tcp_bind(msg->conn->pcb.tcp, msg->msg.bc.ipaddr, msg->msg.bc.port);
    1ad4:	4798      	blx	r3
    1ad6:	7120      	strb	r0, [r4, #4]
				break;
    1ad8:	e7e7      	b.n	1aaa <do_bind+0x12>
				msg->err = tcp_bind(msg->conn->pcb.tcp, msg->msg.bc.ipaddr, msg->msg.bc.port);
    1ada:	89a2      	ldrh	r2, [r4, #12]
    1adc:	68a1      	ldr	r1, [r4, #8]
    1ade:	4b03      	ldr	r3, [pc, #12]	; (1aec <do_bind+0x54>)
    1ae0:	e7f8      	b.n	1ad4 <do_bind+0x3c>
    1ae2:	bf00      	nop
    1ae4:	00007a19 	.word	0x00007a19
    1ae8:	00004615 	.word	0x00004615
    1aec:	00006935 	.word	0x00006935

00001af0 <do_listen>:
{
    1af0:	b570      	push	{r4, r5, r6, lr}
	if (ERR_IS_FATAL(msg->conn->last_err)) {
    1af2:	6803      	ldr	r3, [r0, #0]
    1af4:	f993 2008 	ldrsb.w	r2, [r3, #8]
    1af8:	f112 0f09 	cmn.w	r2, #9
{
    1afc:	4604      	mov	r4, r0
	if (ERR_IS_FATAL(msg->conn->last_err)) {
    1afe:	da06      	bge.n	1b0e <do_listen+0x1e>
		msg->err = msg->conn->last_err;
    1b00:	7102      	strb	r2, [r0, #4]
	TCPIP_APIMSG_ACK(msg);
    1b02:	6820      	ldr	r0, [r4, #0]
    1b04:	4b24      	ldr	r3, [pc, #144]	; (1b98 <do_listen+0xa8>)
}
    1b06:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	TCPIP_APIMSG_ACK(msg);
    1b0a:	300c      	adds	r0, #12
    1b0c:	4718      	bx	r3
		msg->err = ERR_CONN;
    1b0e:	22f3      	movs	r2, #243	; 0xf3
    1b10:	7102      	strb	r2, [r0, #4]
		if (msg->conn->pcb.tcp != NULL) {
    1b12:	6858      	ldr	r0, [r3, #4]
    1b14:	2800      	cmp	r0, #0
    1b16:	d0f4      	beq.n	1b02 <do_listen+0x12>
			if (msg->conn->type == NETCONN_TCP) {
    1b18:	781a      	ldrb	r2, [r3, #0]
    1b1a:	2a10      	cmp	r2, #16
    1b1c:	d13a      	bne.n	1b94 <do_listen+0xa4>
				if (msg->conn->state == NETCONN_NONE) {
    1b1e:	785b      	ldrb	r3, [r3, #1]
    1b20:	2b00      	cmp	r3, #0
    1b22:	d1ee      	bne.n	1b02 <do_listen+0x12>
					struct tcp_pcb *lpcb = tcp_listen(msg->conn->pcb.tcp);
    1b24:	4b1d      	ldr	r3, [pc, #116]	; (1b9c <do_listen+0xac>)
    1b26:	21ff      	movs	r1, #255	; 0xff
    1b28:	4798      	blx	r3
					if (lpcb == NULL) {
    1b2a:	4605      	mov	r5, r0
    1b2c:	b910      	cbnz	r0, 1b34 <do_listen+0x44>
						msg->err = ERR_MEM;
    1b2e:	23ff      	movs	r3, #255	; 0xff
				msg->err = ERR_ARG;
    1b30:	7123      	strb	r3, [r4, #4]
    1b32:	e7e6      	b.n	1b02 <do_listen+0x12>
						if (sys_mbox_valid(&msg->conn->recvmbox)) {
    1b34:	6820      	ldr	r0, [r4, #0]
    1b36:	4e1a      	ldr	r6, [pc, #104]	; (1ba0 <do_listen+0xb0>)
    1b38:	3010      	adds	r0, #16
    1b3a:	47b0      	blx	r6
    1b3c:	b138      	cbz	r0, 1b4e <do_listen+0x5e>
							sys_mbox_free(&msg->conn->recvmbox);
    1b3e:	6820      	ldr	r0, [r4, #0]
    1b40:	4b18      	ldr	r3, [pc, #96]	; (1ba4 <do_listen+0xb4>)
    1b42:	3010      	adds	r0, #16
    1b44:	4798      	blx	r3
							sys_mbox_set_invalid(&msg->conn->recvmbox);
    1b46:	6820      	ldr	r0, [r4, #0]
    1b48:	4b17      	ldr	r3, [pc, #92]	; (1ba8 <do_listen+0xb8>)
    1b4a:	3010      	adds	r0, #16
    1b4c:	4798      	blx	r3
						if (!sys_mbox_valid(&msg->conn->acceptmbox)) {
    1b4e:	6820      	ldr	r0, [r4, #0]
						msg->err = ERR_OK;
    1b50:	2300      	movs	r3, #0
    1b52:	7123      	strb	r3, [r4, #4]
						if (!sys_mbox_valid(&msg->conn->acceptmbox)) {
    1b54:	3014      	adds	r0, #20
    1b56:	47b0      	blx	r6
    1b58:	b928      	cbnz	r0, 1b66 <do_listen+0x76>
							msg->err = sys_mbox_new(&msg->conn->acceptmbox, DEFAULT_ACCEPTMBOX_SIZE);
    1b5a:	6820      	ldr	r0, [r4, #0]
    1b5c:	4b13      	ldr	r3, [pc, #76]	; (1bac <do_listen+0xbc>)
    1b5e:	2110      	movs	r1, #16
    1b60:	3014      	adds	r0, #20
    1b62:	4798      	blx	r3
    1b64:	7120      	strb	r0, [r4, #4]
						if (msg->err == ERR_OK) {
    1b66:	f994 3004 	ldrsb.w	r3, [r4, #4]
    1b6a:	b963      	cbnz	r3, 1b86 <do_listen+0x96>
							msg->conn->state   = NETCONN_LISTEN;
    1b6c:	6821      	ldr	r1, [r4, #0]
    1b6e:	2302      	movs	r3, #2
    1b70:	704b      	strb	r3, [r1, #1]
							msg->conn->pcb.tcp = lpcb;
    1b72:	604d      	str	r5, [r1, #4]
							tcp_arg(msg->conn->pcb.tcp, msg->conn);
    1b74:	4628      	mov	r0, r5
    1b76:	4b0e      	ldr	r3, [pc, #56]	; (1bb0 <do_listen+0xc0>)
    1b78:	4798      	blx	r3
							tcp_accept(msg->conn->pcb.tcp, accept_function);
    1b7a:	6823      	ldr	r3, [r4, #0]
    1b7c:	490d      	ldr	r1, [pc, #52]	; (1bb4 <do_listen+0xc4>)
    1b7e:	6858      	ldr	r0, [r3, #4]
    1b80:	4b0d      	ldr	r3, [pc, #52]	; (1bb8 <do_listen+0xc8>)
    1b82:	4798      	blx	r3
    1b84:	e7bd      	b.n	1b02 <do_listen+0x12>
							tcp_close(lpcb);
    1b86:	4b0d      	ldr	r3, [pc, #52]	; (1bbc <do_listen+0xcc>)
    1b88:	4628      	mov	r0, r5
    1b8a:	4798      	blx	r3
							msg->conn->pcb.tcp = NULL;
    1b8c:	6823      	ldr	r3, [r4, #0]
    1b8e:	2200      	movs	r2, #0
    1b90:	605a      	str	r2, [r3, #4]
    1b92:	e7b6      	b.n	1b02 <do_listen+0x12>
				msg->err = ERR_ARG;
    1b94:	23f2      	movs	r3, #242	; 0xf2
    1b96:	e7cb      	b.n	1b30 <do_listen+0x40>
    1b98:	00007a19 	.word	0x00007a19
    1b9c:	000069ad 	.word	0x000069ad
    1ba0:	00007bdd 	.word	0x00007bdd
    1ba4:	00007abd 	.word	0x00007abd
    1ba8:	00007be1 	.word	0x00007be1
    1bac:	00007a9d 	.word	0x00007a9d
    1bb0:	00006b2d 	.word	0x00006b2d
    1bb4:	00001931 	.word	0x00001931
    1bb8:	00006b41 	.word	0x00006b41
    1bbc:	00007029 	.word	0x00007029

00001bc0 <do_send>:
{
    1bc0:	b570      	push	{r4, r5, r6, lr}
	if (ERR_IS_FATAL(msg->conn->last_err)) {
    1bc2:	6803      	ldr	r3, [r0, #0]
    1bc4:	f993 2008 	ldrsb.w	r2, [r3, #8]
    1bc8:	f112 0f09 	cmn.w	r2, #9
{
    1bcc:	4604      	mov	r4, r0
	if (ERR_IS_FATAL(msg->conn->last_err)) {
    1bce:	da06      	bge.n	1bde <do_send+0x1e>
		msg->err = msg->conn->last_err;
    1bd0:	7102      	strb	r2, [r0, #4]
	TCPIP_APIMSG_ACK(msg);
    1bd2:	6820      	ldr	r0, [r4, #0]
    1bd4:	4b0d      	ldr	r3, [pc, #52]	; (1c0c <do_send+0x4c>)
}
    1bd6:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	TCPIP_APIMSG_ACK(msg);
    1bda:	300c      	adds	r0, #12
    1bdc:	4718      	bx	r3
		msg->err = ERR_CONN;
    1bde:	22f3      	movs	r2, #243	; 0xf3
    1be0:	7102      	strb	r2, [r0, #4]
		if (msg->conn->pcb.tcp != NULL) {
    1be2:	6858      	ldr	r0, [r3, #4]
    1be4:	2800      	cmp	r0, #0
    1be6:	d0f4      	beq.n	1bd2 <do_send+0x12>
			switch (NETCONNTYPE_GROUP(msg->conn->type)) {
    1be8:	781b      	ldrb	r3, [r3, #0]
    1bea:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
    1bee:	2b20      	cmp	r3, #32
    1bf0:	d1ef      	bne.n	1bd2 <do_send+0x12>
				if (ip_addr_isany(&msg->msg.b->addr)) {
    1bf2:	68a2      	ldr	r2, [r4, #8]
    1bf4:	6893      	ldr	r3, [r2, #8]
					msg->err = udp_send(msg->conn->pcb.udp, msg->msg.b->p);
    1bf6:	6811      	ldr	r1, [r2, #0]
				if (ip_addr_isany(&msg->msg.b->addr)) {
    1bf8:	b91b      	cbnz	r3, 1c02 <do_send+0x42>
					msg->err = udp_send(msg->conn->pcb.udp, msg->msg.b->p);
    1bfa:	4b05      	ldr	r3, [pc, #20]	; (1c10 <do_send+0x50>)
    1bfc:	4798      	blx	r3
					msg->err = udp_sendto(msg->conn->pcb.udp, msg->msg.b->p, &msg->msg.b->addr, msg->msg.b->port);
    1bfe:	7120      	strb	r0, [r4, #4]
    1c00:	e7e7      	b.n	1bd2 <do_send+0x12>
    1c02:	8993      	ldrh	r3, [r2, #12]
    1c04:	4d03      	ldr	r5, [pc, #12]	; (1c14 <do_send+0x54>)
    1c06:	3208      	adds	r2, #8
    1c08:	47a8      	blx	r5
    1c0a:	e7f8      	b.n	1bfe <do_send+0x3e>
    1c0c:	00007a19 	.word	0x00007a19
    1c10:	000047e1 	.word	0x000047e1
    1c14:	000047ad 	.word	0x000047ad

00001c18 <do_recv>:
	msg->err = ERR_OK;
    1c18:	2300      	movs	r3, #0
{
    1c1a:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	msg->err = ERR_OK;
    1c1e:	7103      	strb	r3, [r0, #4]
	if (msg->conn->pcb.tcp != NULL) {
    1c20:	6803      	ldr	r3, [r0, #0]
    1c22:	685a      	ldr	r2, [r3, #4]
{
    1c24:	4604      	mov	r4, r0
	if (msg->conn->pcb.tcp != NULL) {
    1c26:	b182      	cbz	r2, 1c4a <do_recv+0x32>
		if (msg->conn->type == NETCONN_TCP) {
    1c28:	781b      	ldrb	r3, [r3, #0]
    1c2a:	2b10      	cmp	r3, #16
    1c2c:	d10d      	bne.n	1c4a <do_recv+0x32>
				u32_t remaining = msg->msg.r.len;
    1c2e:	6885      	ldr	r5, [r0, #8]
					tcp_recved(msg->conn->pcb.tcp, recved);
    1c30:	4f09      	ldr	r7, [pc, #36]	; (1c58 <do_recv+0x40>)
    1c32:	f64f 78ff 	movw	r8, #65535	; 0xffff
					u16_t recved = (remaining > 0xffff) ? 0xffff : (u16_t)remaining;
    1c36:	4545      	cmp	r5, r8
					tcp_recved(msg->conn->pcb.tcp, recved);
    1c38:	6823      	ldr	r3, [r4, #0]
    1c3a:	462e      	mov	r6, r5
    1c3c:	bf28      	it	cs
    1c3e:	4646      	movcs	r6, r8
    1c40:	6858      	ldr	r0, [r3, #4]
    1c42:	b2b1      	uxth	r1, r6
    1c44:	47b8      	blx	r7
				} while (remaining != 0);
    1c46:	1bad      	subs	r5, r5, r6
    1c48:	d1f5      	bne.n	1c36 <do_recv+0x1e>
	TCPIP_APIMSG_ACK(msg);
    1c4a:	6820      	ldr	r0, [r4, #0]
    1c4c:	4b03      	ldr	r3, [pc, #12]	; (1c5c <do_recv+0x44>)
}
    1c4e:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
	TCPIP_APIMSG_ACK(msg);
    1c52:	300c      	adds	r0, #12
    1c54:	4718      	bx	r3
    1c56:	bf00      	nop
    1c58:	00006a81 	.word	0x00006a81
    1c5c:	00007a19 	.word	0x00007a19

00001c60 <do_write>:
 * Called from netconn_write
 *
 * @param msg the api_msg_msg pointing to the connection
 */
void do_write(struct api_msg_msg *msg)
{
    1c60:	4603      	mov	r3, r0
	if (ERR_IS_FATAL(msg->conn->last_err)) {
    1c62:	6800      	ldr	r0, [r0, #0]
    1c64:	f990 2008 	ldrsb.w	r2, [r0, #8]
    1c68:	f112 0f09 	cmn.w	r2, #9
    1c6c:	da03      	bge.n	1c76 <do_write+0x16>
#else  /* LWIP_TCP */
			msg->err = ERR_VAL;
#endif /* LWIP_TCP */
#if (LWIP_UDP || LWIP_RAW)
		} else {
			msg->err = ERR_VAL;
    1c6e:	711a      	strb	r2, [r3, #4]
#endif /* (LWIP_UDP || LWIP_RAW) */
		}
	}
	TCPIP_APIMSG_ACK(msg);
    1c70:	300c      	adds	r0, #12
    1c72:	4b0a      	ldr	r3, [pc, #40]	; (1c9c <do_write+0x3c>)
    1c74:	4718      	bx	r3
		if (msg->conn->type == NETCONN_TCP) {
    1c76:	7802      	ldrb	r2, [r0, #0]
    1c78:	2a10      	cmp	r2, #16
    1c7a:	d10d      	bne.n	1c98 <do_write+0x38>
			if (msg->conn->state != NETCONN_NONE) {
    1c7c:	7842      	ldrb	r2, [r0, #1]
    1c7e:	b10a      	cbz	r2, 1c84 <do_write+0x24>
				msg->err = ERR_INPROGRESS;
    1c80:	22fb      	movs	r2, #251	; 0xfb
    1c82:	e7f4      	b.n	1c6e <do_write+0xe>
			} else if (msg->conn->pcb.tcp != NULL) {
    1c84:	6841      	ldr	r1, [r0, #4]
    1c86:	b129      	cbz	r1, 1c94 <do_write+0x34>
				msg->conn->state = NETCONN_WRITE;
    1c88:	2101      	movs	r1, #1
				msg->conn->write_offset = 0;
    1c8a:	e9c0 2308 	strd	r2, r3, [r0, #32]
				msg->conn->state = NETCONN_WRITE;
    1c8e:	7041      	strb	r1, [r0, #1]
				do_writemore(msg->conn);
    1c90:	4b03      	ldr	r3, [pc, #12]	; (1ca0 <do_write+0x40>)
    1c92:	4718      	bx	r3
				msg->err = ERR_CONN;
    1c94:	22f3      	movs	r2, #243	; 0xf3
    1c96:	e7ea      	b.n	1c6e <do_write+0xe>
			msg->err = ERR_VAL;
    1c98:	22fa      	movs	r2, #250	; 0xfa
    1c9a:	e7e8      	b.n	1c6e <do_write+0xe>
    1c9c:	00007a19 	.word	0x00007a19
    1ca0:	000015ad 	.word	0x000015ad

00001ca4 <do_getaddr>:
 *
 * @param msg the api_msg_msg pointing to the connection
 */
void do_getaddr(struct api_msg_msg *msg)
{
	if (msg->conn->pcb.ip != NULL) {
    1ca4:	6801      	ldr	r1, [r0, #0]
    1ca6:	684b      	ldr	r3, [r1, #4]
{
    1ca8:	b430      	push	{r4, r5}
	if (msg->conn->pcb.ip != NULL) {
    1caa:	b1bb      	cbz	r3, 1cdc <do_getaddr+0x38>
		*(msg->msg.ad.ipaddr) = (msg->msg.ad.local ? msg->conn->pcb.ip->local_ip : msg->conn->pcb.ip->remote_ip);
    1cac:	7c04      	ldrb	r4, [r0, #16]
    1cae:	6882      	ldr	r2, [r0, #8]
    1cb0:	b17c      	cbz	r4, 1cd2 <do_getaddr+0x2e>
    1cb2:	681d      	ldr	r5, [r3, #0]
    1cb4:	6015      	str	r5, [r2, #0]

		msg->err = ERR_OK;
    1cb6:	2200      	movs	r2, #0
    1cb8:	7102      	strb	r2, [r0, #4]
		switch (NETCONNTYPE_GROUP(msg->conn->type)) {
    1cba:	780a      	ldrb	r2, [r1, #0]
    1cbc:	f002 02f0 	and.w	r2, r2, #240	; 0xf0
    1cc0:	2a10      	cmp	r2, #16
    1cc2:	d015      	beq.n	1cf0 <do_getaddr+0x4c>
    1cc4:	2a20      	cmp	r2, #32
    1cc6:	d10b      	bne.n	1ce0 <do_getaddr+0x3c>
			}
			break;
#endif /* LWIP_RAW */
#if LWIP_UDP
		case NETCONN_UDP:
			if (msg->msg.ad.local) {
    1cc8:	b12c      	cbz	r4, 1cd6 <do_getaddr+0x32>
				*(msg->msg.ad.port) = msg->conn->pcb.udp->local_port;
    1cca:	68c2      	ldr	r2, [r0, #12]
    1ccc:	8a5b      	ldrh	r3, [r3, #18]
			break;
#endif /* LWIP_UDP */
#if LWIP_TCP
		case NETCONN_TCP:
			*(msg->msg.ad.port)
			    = (msg->msg.ad.local ? msg->conn->pcb.tcp->local_port : msg->conn->pcb.tcp->remote_port);
    1cce:	8013      	strh	r3, [r2, #0]
			break;
    1cd0:	e006      	b.n	1ce0 <do_getaddr+0x3c>
		*(msg->msg.ad.ipaddr) = (msg->msg.ad.local ? msg->conn->pcb.ip->local_ip : msg->conn->pcb.ip->remote_ip);
    1cd2:	685d      	ldr	r5, [r3, #4]
    1cd4:	e7ee      	b.n	1cb4 <do_getaddr+0x10>
				if ((msg->conn->pcb.udp->flags & UDP_FLAGS_CONNECTED) == 0) {
    1cd6:	7c1a      	ldrb	r2, [r3, #16]
    1cd8:	0752      	lsls	r2, r2, #29
    1cda:	d406      	bmi.n	1cea <do_getaddr+0x46>
					msg->err = ERR_CONN;
    1cdc:	23f3      	movs	r3, #243	; 0xf3
    1cde:	7103      	strb	r3, [r0, #4]
		}
	} else {
		msg->err = ERR_CONN;
	}
	TCPIP_APIMSG_ACK(msg);
}
    1ce0:	bc30      	pop	{r4, r5}
	TCPIP_APIMSG_ACK(msg);
    1ce2:	4b06      	ldr	r3, [pc, #24]	; (1cfc <do_getaddr+0x58>)
    1ce4:	f101 000c 	add.w	r0, r1, #12
    1ce8:	4718      	bx	r3
					*(msg->msg.ad.port) = msg->conn->pcb.udp->remote_port;
    1cea:	68c2      	ldr	r2, [r0, #12]
    1cec:	8a9b      	ldrh	r3, [r3, #20]
    1cee:	e7ee      	b.n	1cce <do_getaddr+0x2a>
			    = (msg->msg.ad.local ? msg->conn->pcb.tcp->local_port : msg->conn->pcb.tcp->remote_port);
    1cf0:	b114      	cbz	r4, 1cf8 <do_getaddr+0x54>
    1cf2:	8b5b      	ldrh	r3, [r3, #26]
			*(msg->msg.ad.port)
    1cf4:	68c2      	ldr	r2, [r0, #12]
    1cf6:	e7ea      	b.n	1cce <do_getaddr+0x2a>
			    = (msg->msg.ad.local ? msg->conn->pcb.tcp->local_port : msg->conn->pcb.tcp->remote_port);
    1cf8:	8b9b      	ldrh	r3, [r3, #28]
    1cfa:	e7fb      	b.n	1cf4 <do_getaddr+0x50>
    1cfc:	00007a19 	.word	0x00007a19

00001d00 <pvPortMalloc>:
		pxIterator->pxNextFreeBlock      = pxBlockToInsert;                                                            \
	}
/*-----------------------------------------------------------*/

void *pvPortMalloc(size_t xWantedSize)
{
    1d00:	b570      	push	{r4, r5, r6, lr}
	BlockLink_t *     pxBlock, *pxPreviousBlock, *pxNewBlockLink;
	static BaseType_t xHeapHasBeenInitialised = pdFALSE;
	void *            pvReturn                = NULL;

	vTaskSuspendAll();
    1d02:	4b26      	ldr	r3, [pc, #152]	; (1d9c <pvPortMalloc+0x9c>)
{
    1d04:	4604      	mov	r4, r0
	vTaskSuspendAll();
    1d06:	4798      	blx	r3
	{
		/* If this is the first call to malloc then the heap will require
		initialisation to setup the list of free blocks. */
		if (xHeapHasBeenInitialised == pdFALSE) {
    1d08:	4b25      	ldr	r3, [pc, #148]	; (1da0 <pvPortMalloc+0xa0>)
    1d0a:	6898      	ldr	r0, [r3, #8]
    1d0c:	b970      	cbnz	r0, 1d2c <pvPortMalloc+0x2c>
	xStart.pxNextFreeBlock = (void *)pucAlignedHeap;
	xStart.xBlockSize      = (size_t)0;

	/* xEnd is used to mark the end of the list of free blocks. */
	xEnd.xBlockSize      = configADJUSTED_HEAP_SIZE;
	xEnd.pxNextFreeBlock = NULL;
    1d0e:	4619      	mov	r1, r3
	                             & (~((portPOINTER_SIZE_TYPE)portBYTE_ALIGNMENT_MASK)));
    1d10:	4a24      	ldr	r2, [pc, #144]	; (1da4 <pvPortMalloc+0xa4>)
	xEnd.pxNextFreeBlock = NULL;
    1d12:	f841 0f0c 	str.w	r0, [r1, #12]!
	                             & (~((portPOINTER_SIZE_TYPE)portBYTE_ALIGNMENT_MASK)));
    1d16:	f022 0207 	bic.w	r2, r2, #7
	xEnd.xBlockSize      = configADJUSTED_HEAP_SIZE;
    1d1a:	f24a 4508 	movw	r5, #41992	; 0xa408
	xStart.xBlockSize      = (size_t)0;
    1d1e:	e9c3 2000 	strd	r2, r0, [r3]

	/* To start with there is a single free block that is sized to take up the
	entire heap space. */
	pxFirstFreeBlock                  = (void *)pucAlignedHeap;
	pxFirstFreeBlock->xBlockSize      = configADJUSTED_HEAP_SIZE;
	pxFirstFreeBlock->pxNextFreeBlock = &xEnd;
    1d22:	e9c2 1500 	strd	r1, r5, [r2]
			xHeapHasBeenInitialised = pdTRUE;
    1d26:	2201      	movs	r2, #1
	xEnd.xBlockSize      = configADJUSTED_HEAP_SIZE;
    1d28:	611d      	str	r5, [r3, #16]
			xHeapHasBeenInitialised = pdTRUE;
    1d2a:	609a      	str	r2, [r3, #8]
		if (xWantedSize > 0) {
    1d2c:	b12c      	cbz	r4, 1d3a <pvPortMalloc+0x3a>
			xWantedSize += heapSTRUCT_SIZE;
    1d2e:	3408      	adds	r4, #8
			if ((xWantedSize & portBYTE_ALIGNMENT_MASK) != 0) {
    1d30:	0762      	lsls	r2, r4, #29
				xWantedSize += (portBYTE_ALIGNMENT - (xWantedSize & portBYTE_ALIGNMENT_MASK));
    1d32:	bf1c      	itt	ne
    1d34:	f024 0407 	bicne.w	r4, r4, #7
    1d38:	3408      	addne	r4, #8
		if ((xWantedSize > 0) && (xWantedSize < configADJUSTED_HEAP_SIZE)) {
    1d3a:	1e61      	subs	r1, r4, #1
    1d3c:	f24a 4206 	movw	r2, #41990	; 0xa406
    1d40:	4291      	cmp	r1, r2
    1d42:	d829      	bhi.n	1d98 <pvPortMalloc+0x98>
			pxBlock         = xStart.pxNextFreeBlock;
    1d44:	681b      	ldr	r3, [r3, #0]
			pxPreviousBlock = &xStart;
    1d46:	4816      	ldr	r0, [pc, #88]	; (1da0 <pvPortMalloc+0xa0>)
			while ((pxBlock->xBlockSize < xWantedSize) && (pxBlock->pxNextFreeBlock != NULL)) {
    1d48:	6859      	ldr	r1, [r3, #4]
    1d4a:	42a1      	cmp	r1, r4
    1d4c:	d201      	bcs.n	1d52 <pvPortMalloc+0x52>
    1d4e:	681a      	ldr	r2, [r3, #0]
    1d50:	b9fa      	cbnz	r2, 1d92 <pvPortMalloc+0x92>
			if (pxBlock != &xEnd) {
    1d52:	4a15      	ldr	r2, [pc, #84]	; (1da8 <pvPortMalloc+0xa8>)
    1d54:	4293      	cmp	r3, r2
    1d56:	d01f      	beq.n	1d98 <pvPortMalloc+0x98>
				pvReturn = (void *)(((uint8_t *)pxPreviousBlock->pxNextFreeBlock) + heapSTRUCT_SIZE);
    1d58:	6805      	ldr	r5, [r0, #0]
				pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;
    1d5a:	681e      	ldr	r6, [r3, #0]
    1d5c:	6006      	str	r6, [r0, #0]
				if ((pxBlock->xBlockSize - xWantedSize) > heapMINIMUM_BLOCK_SIZE) {
    1d5e:	1b09      	subs	r1, r1, r4
    1d60:	2910      	cmp	r1, #16
				pvReturn = (void *)(((uint8_t *)pxPreviousBlock->pxNextFreeBlock) + heapSTRUCT_SIZE);
    1d62:	f105 0508 	add.w	r5, r5, #8
				if ((pxBlock->xBlockSize - xWantedSize) > heapMINIMUM_BLOCK_SIZE) {
    1d66:	d90b      	bls.n	1d80 <pvPortMalloc+0x80>
					pxNewBlockLink = (void *)(((uint8_t *)pxBlock) + xWantedSize);
    1d68:	1918      	adds	r0, r3, r4
					prvInsertBlockIntoFreeList((pxNewBlockLink));
    1d6a:	3a0c      	subs	r2, #12
					pxNewBlockLink->xBlockSize = pxBlock->xBlockSize - xWantedSize;
    1d6c:	6041      	str	r1, [r0, #4]
					pxBlock->xBlockSize        = xWantedSize;
    1d6e:	605c      	str	r4, [r3, #4]
					prvInsertBlockIntoFreeList((pxNewBlockLink));
    1d70:	6844      	ldr	r4, [r0, #4]
    1d72:	4611      	mov	r1, r2
    1d74:	6812      	ldr	r2, [r2, #0]
    1d76:	6856      	ldr	r6, [r2, #4]
    1d78:	42a6      	cmp	r6, r4
    1d7a:	d3fa      	bcc.n	1d72 <pvPortMalloc+0x72>
    1d7c:	6002      	str	r2, [r0, #0]
    1d7e:	6008      	str	r0, [r1, #0]
				xFreeBytesRemaining -= pxBlock->xBlockSize;
    1d80:	490a      	ldr	r1, [pc, #40]	; (1dac <pvPortMalloc+0xac>)
    1d82:	685b      	ldr	r3, [r3, #4]
    1d84:	680a      	ldr	r2, [r1, #0]
    1d86:	1ad2      	subs	r2, r2, r3
    1d88:	600a      	str	r2, [r1, #0]
	(void)xTaskResumeAll();
    1d8a:	4b09      	ldr	r3, [pc, #36]	; (1db0 <pvPortMalloc+0xb0>)
    1d8c:	4798      	blx	r3
}
    1d8e:	4628      	mov	r0, r5
    1d90:	bd70      	pop	{r4, r5, r6, pc}
    1d92:	4618      	mov	r0, r3
    1d94:	4613      	mov	r3, r2
    1d96:	e7d7      	b.n	1d48 <pvPortMalloc+0x48>
	void *            pvReturn                = NULL;
    1d98:	2500      	movs	r5, #0
    1d9a:	e7f6      	b.n	1d8a <pvPortMalloc+0x8a>
    1d9c:	00008d85 	.word	0x00008d85
    1da0:	200000b4 	.word	0x200000b4
    1da4:	200000d0 	.word	0x200000d0
    1da8:	200000c0 	.word	0x200000c0
    1dac:	20000000 	.word	0x20000000
    1db0:	00008e99 	.word	0x00008e99

00001db4 <vPortFree>:
{
    1db4:	b570      	push	{r4, r5, r6, lr}
	if (pv != NULL) {
    1db6:	4604      	mov	r4, r0
    1db8:	b1b0      	cbz	r0, 1de8 <vPortFree+0x34>
		vTaskSuspendAll();
    1dba:	4b0c      	ldr	r3, [pc, #48]	; (1dec <vPortFree+0x38>)
		puc -= heapSTRUCT_SIZE;
    1dbc:	f1a0 0508 	sub.w	r5, r0, #8
		vTaskSuspendAll();
    1dc0:	4798      	blx	r3
			prvInsertBlockIntoFreeList(((BlockLink_t *)pxLink));
    1dc2:	f854 1c04 	ldr.w	r1, [r4, #-4]
    1dc6:	4b0a      	ldr	r3, [pc, #40]	; (1df0 <vPortFree+0x3c>)
    1dc8:	461a      	mov	r2, r3
    1dca:	681b      	ldr	r3, [r3, #0]
    1dcc:	6858      	ldr	r0, [r3, #4]
    1dce:	4288      	cmp	r0, r1
    1dd0:	d3fa      	bcc.n	1dc8 <vPortFree+0x14>
    1dd2:	f844 3c08 	str.w	r3, [r4, #-8]
    1dd6:	6015      	str	r5, [r2, #0]
			xFreeBytesRemaining += pxLink->xBlockSize;
    1dd8:	4a06      	ldr	r2, [pc, #24]	; (1df4 <vPortFree+0x40>)
    1dda:	6813      	ldr	r3, [r2, #0]
    1ddc:	440b      	add	r3, r1
    1dde:	6013      	str	r3, [r2, #0]
}
    1de0:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		(void)xTaskResumeAll();
    1de4:	4b04      	ldr	r3, [pc, #16]	; (1df8 <vPortFree+0x44>)
    1de6:	4718      	bx	r3
}
    1de8:	bd70      	pop	{r4, r5, r6, pc}
    1dea:	bf00      	nop
    1dec:	00008d85 	.word	0x00008d85
    1df0:	200000b4 	.word	0x200000b4
    1df4:	20000000 	.word	0x20000000
    1df8:	00008e99 	.word	0x00008e99

00001dfc <vListInitialise>:
void vListInitialise(List_t *const pxList)
{
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = (ListItem_t *)&(
    1dfc:	f100 0308 	add.w	r3, r0, #8
	    pxList->xListEnd); /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is
	                          checked and valid. */

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
    1e00:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = (ListItem_t *)&(pxList->xListEnd); /*lint !e826 !e740 The mini list structure is used as
    1e04:	e9c0 2302 	strd	r2, r3, [r0, #8]
	pxList->pxIndex = (ListItem_t *)&(
    1e08:	6043      	str	r3, [r0, #4]
	                                                                the list end to save RAM.  This is checked and
	                                                                valid. */
	pxList->xListEnd.pxPrevious = (ListItem_t *)&(
    1e0a:	6103      	str	r3, [r0, #16]
	    pxList->xListEnd); /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is
	                          checked and valid. */

	pxList->uxNumberOfItems = (UBaseType_t)0U;
    1e0c:	2300      	movs	r3, #0
    1e0e:	6003      	str	r3, [r0, #0]

	/* Write known values into the list if
	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
	listSET_LIST_INTEGRITY_CHECK_1_VALUE(pxList);
	listSET_LIST_INTEGRITY_CHECK_2_VALUE(pxList);
}
    1e10:	4770      	bx	lr

00001e12 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem(ListItem_t *const pxItem)
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
    1e12:	2300      	movs	r3, #0
    1e14:	6103      	str	r3, [r0, #16]

	/* Write known values into the list item if
	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
	listSET_FIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE(pxItem);
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE(pxItem);
}
    1e16:	4770      	bx	lr

00001e18 <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd(List_t *const pxList, ListItem_t *const pxNewListItem)
{
	ListItem_t *const pxIndex = pxList->pxIndex;
    1e18:	6843      	ldr	r3, [r0, #4]
	listTEST_LIST_ITEM_INTEGRITY(pxNewListItem);

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext     = pxIndex;
    1e1a:	604b      	str	r3, [r1, #4]
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
    1e1c:	689a      	ldr	r2, [r3, #8]
    1e1e:	608a      	str	r2, [r1, #8]

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
    1e20:	689a      	ldr	r2, [r3, #8]
    1e22:	6051      	str	r1, [r2, #4]
	pxIndex->pxPrevious         = pxNewListItem;
    1e24:	6099      	str	r1, [r3, #8]

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = (void *)pxList;

	(pxList->uxNumberOfItems)++;
    1e26:	6803      	ldr	r3, [r0, #0]
	pxNewListItem->pvContainer = (void *)pxList;
    1e28:	6108      	str	r0, [r1, #16]
	(pxList->uxNumberOfItems)++;
    1e2a:	3301      	adds	r3, #1
    1e2c:	6003      	str	r3, [r0, #0]
}
    1e2e:	4770      	bx	lr

00001e30 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert(List_t *const pxList, ListItem_t *const pxNewListItem)
{
    1e30:	b530      	push	{r4, r5, lr}
	ListItem_t *     pxIterator;
	const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
    1e32:	680c      	ldr	r4, [r1, #0]
	new list item should be placed after it.  This ensures that TCB's which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if (xValueOfInsertion == portMAX_DELAY) {
    1e34:	1c63      	adds	r3, r4, #1
    1e36:	d10a      	bne.n	1e4e <vListInsert+0x1e>
		pxIterator = pxList->xListEnd.pxPrevious;
    1e38:	6903      	ldr	r3, [r0, #16]
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext             = pxIterator->pxNext;
    1e3a:	685a      	ldr	r2, [r3, #4]
    1e3c:	604a      	str	r2, [r1, #4]
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
    1e3e:	6091      	str	r1, [r2, #8]
	pxNewListItem->pxPrevious         = pxIterator;
    1e40:	608b      	str	r3, [r1, #8]
	pxIterator->pxNext                = pxNewListItem;
    1e42:	6059      	str	r1, [r3, #4]

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = (void *)pxList;

	(pxList->uxNumberOfItems)++;
    1e44:	6803      	ldr	r3, [r0, #0]
	pxNewListItem->pvContainer = (void *)pxList;
    1e46:	6108      	str	r0, [r1, #16]
	(pxList->uxNumberOfItems)++;
    1e48:	3301      	adds	r3, #1
    1e4a:	6003      	str	r3, [r0, #0]
}
    1e4c:	bd30      	pop	{r4, r5, pc}
		for (pxIterator = (ListItem_t *)&(pxList->xListEnd); pxIterator->pxNext->xItemValue <= xValueOfInsertion;
    1e4e:	f100 0208 	add.w	r2, r0, #8
    1e52:	4613      	mov	r3, r2
    1e54:	6852      	ldr	r2, [r2, #4]
    1e56:	6815      	ldr	r5, [r2, #0]
    1e58:	42a5      	cmp	r5, r4
    1e5a:	d9fa      	bls.n	1e52 <vListInsert+0x22>
    1e5c:	e7ed      	b.n	1e3a <vListInsert+0xa>

00001e5e <uxListRemove>:
{
	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	List_t *const pxList = (List_t *)pxItemToRemove->pvContainer;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    1e5e:	e9d0 1201 	ldrd	r1, r2, [r0, #4]
	List_t *const pxList = (List_t *)pxItemToRemove->pvContainer;
    1e62:	6903      	ldr	r3, [r0, #16]
	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    1e64:	608a      	str	r2, [r1, #8]
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    1e66:	6051      	str	r1, [r2, #4]

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if (pxList->pxIndex == pxItemToRemove) {
    1e68:	6859      	ldr	r1, [r3, #4]
    1e6a:	4281      	cmp	r1, r0
		pxList->pxIndex = pxItemToRemove->pxPrevious;
    1e6c:	bf08      	it	eq
    1e6e:	605a      	streq	r2, [r3, #4]
	} else {
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
    1e70:	2200      	movs	r2, #0
    1e72:	6102      	str	r2, [r0, #16]
	(pxList->uxNumberOfItems)--;
    1e74:	6818      	ldr	r0, [r3, #0]
    1e76:	3801      	subs	r0, #1
    1e78:	6018      	str	r0, [r3, #0]

	return pxList->uxNumberOfItems;
}
    1e7a:	4770      	bx	lr

00001e7c <tcp_pbuf_prealloc>:
 * @param
 */
#if TCP_OVERSIZE
static struct pbuf *tcp_pbuf_prealloc(pbuf_layer layer, u16_t length, u16_t max_length, u16_t *oversize,
                                      struct tcp_pcb *pcb, u8_t apiflags, u8_t first_seg)
{
    1e7c:	b570      	push	{r4, r5, r6, lr}
    1e7e:	460c      	mov	r4, r1
	LWIP_UNUSED_ARG(apiflags);
	LWIP_UNUSED_ARG(first_seg);
	/* always create MSS-sized pbufs */
	alloc = max_length;
#else  /* LWIP_NETIF_TX_SINGLE_PBUF */
	if (length < max_length) {
    1e80:	4294      	cmp	r4, r2
{
    1e82:	461e      	mov	r6, r3
    1e84:	f89d 1018 	ldrb.w	r1, [sp, #24]
    1e88:	9b04      	ldr	r3, [sp, #16]
	if (length < max_length) {
    1e8a:	d21d      	bcs.n	1ec8 <tcp_pbuf_prealloc+0x4c>
		 *
		 * Did the user set TCP_WRITE_FLAG_MORE?
		 *
		 * Will the Nagle algorithm defer transmission of this segment?
		 */
		if ((apiflags & TCP_WRITE_FLAG_MORE)
    1e8c:	f89d 5014 	ldrb.w	r5, [sp, #20]
    1e90:	07ad      	lsls	r5, r5, #30
    1e92:	d407      	bmi.n	1ea4 <tcp_pbuf_prealloc+0x28>
		    || (!(pcb->flags & TF_NODELAY) && (!first_seg || pcb->unsent != NULL || pcb->unacked != NULL))) {
    1e94:	7f9d      	ldrb	r5, [r3, #30]
    1e96:	066d      	lsls	r5, r5, #25
    1e98:	d416      	bmi.n	1ec8 <tcp_pbuf_prealloc+0x4c>
    1e9a:	b119      	cbz	r1, 1ea4 <tcp_pbuf_prealloc+0x28>
    1e9c:	6ed9      	ldr	r1, [r3, #108]	; 0x6c
    1e9e:	b909      	cbnz	r1, 1ea4 <tcp_pbuf_prealloc+0x28>
    1ea0:	6f1b      	ldr	r3, [r3, #112]	; 0x70
    1ea2:	b18b      	cbz	r3, 1ec8 <tcp_pbuf_prealloc+0x4c>
			alloc = LWIP_MIN(max_length, LWIP_MEM_ALIGN_SIZE(length + TCP_OVERSIZE));
    1ea4:	f204 55b7 	addw	r5, r4, #1463	; 0x5b7
    1ea8:	f025 0103 	bic.w	r1, r5, #3
    1eac:	428a      	cmp	r2, r1
    1eae:	bfa8      	it	ge
    1eb0:	460a      	movge	r2, r1
    1eb2:	b291      	uxth	r1, r2
		}
	}
#endif /* LWIP_NETIF_TX_SINGLE_PBUF */
	p = pbuf_alloc(layer, alloc, PBUF_RAM);
    1eb4:	4b05      	ldr	r3, [pc, #20]	; (1ecc <tcp_pbuf_prealloc+0x50>)
    1eb6:	2200      	movs	r2, #0
    1eb8:	4798      	blx	r3
	if (p == NULL) {
    1eba:	b120      	cbz	r0, 1ec6 <tcp_pbuf_prealloc+0x4a>
		return NULL;
	}
	LWIP_ASSERT("need unchained pbuf", p->next == NULL);
	*oversize = p->len - length;
    1ebc:	8943      	ldrh	r3, [r0, #10]
    1ebe:	1b1b      	subs	r3, r3, r4
    1ec0:	8033      	strh	r3, [r6, #0]
	/* trim p->len to the currently used size */
	p->len = p->tot_len = length;
    1ec2:	8104      	strh	r4, [r0, #8]
    1ec4:	8144      	strh	r4, [r0, #10]
	return p;
}
    1ec6:	bd70      	pop	{r4, r5, r6, pc}
    1ec8:	4621      	mov	r1, r4
    1eca:	e7f3      	b.n	1eb4 <tcp_pbuf_prealloc+0x38>
    1ecc:	0000313d 	.word	0x0000313d

00001ed0 <tcp_create_segment>:
{
    1ed0:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    1ed4:	4680      	mov	r8, r0
    1ed6:	469a      	mov	sl, r3
	if ((seg = (struct tcp_seg *)memp_malloc(MEMP_TCP_SEG)) == NULL) {
    1ed8:	2003      	movs	r0, #3
    1eda:	4b28      	ldr	r3, [pc, #160]	; (1f7c <tcp_create_segment+0xac>)
{
    1edc:	f89d 9028 	ldrb.w	r9, [sp, #40]	; 0x28
    1ee0:	460e      	mov	r6, r1
    1ee2:	4617      	mov	r7, r2
	if ((seg = (struct tcp_seg *)memp_malloc(MEMP_TCP_SEG)) == NULL) {
    1ee4:	4798      	blx	r3
	u8_t            optlen = LWIP_TCP_OPT_LENGTH(optflags);
    1ee6:	ea4f 0b89 	mov.w	fp, r9, lsl #2
    1eea:	fa5f f58b 	uxtb.w	r5, fp
	if ((seg = (struct tcp_seg *)memp_malloc(MEMP_TCP_SEG)) == NULL) {
    1eee:	4604      	mov	r4, r0
    1ef0:	b928      	cbnz	r0, 1efe <tcp_create_segment+0x2e>
		pbuf_free(p);
    1ef2:	4b23      	ldr	r3, [pc, #140]	; (1f80 <tcp_create_segment+0xb0>)
    1ef4:	4630      	mov	r0, r6
    1ef6:	4798      	blx	r3
}
    1ef8:	4620      	mov	r0, r4
    1efa:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
	seg->flags = optflags;
    1efe:	f880 900a 	strb.w	r9, [r0, #10]
	seg->len   = p->tot_len - optlen;
    1f02:	8933      	ldrh	r3, [r6, #8]
	seg->next  = NULL;
    1f04:	f04f 0900 	mov.w	r9, #0
	seg->len   = p->tot_len - optlen;
    1f08:	eba3 030b 	sub.w	r3, r3, fp
	seg->p     = p;
    1f0c:	e9c0 9600 	strd	r9, r6, [r0]
	seg->len   = p->tot_len - optlen;
    1f10:	8103      	strh	r3, [r0, #8]
	if (pbuf_header(p, TCP_HLEN)) {
    1f12:	2114      	movs	r1, #20
    1f14:	4630      	mov	r0, r6
    1f16:	4b1b      	ldr	r3, [pc, #108]	; (1f84 <tcp_create_segment+0xb4>)
    1f18:	4798      	blx	r3
    1f1a:	4606      	mov	r6, r0
    1f1c:	b120      	cbz	r0, 1f28 <tcp_create_segment+0x58>
		tcp_seg_free(seg);
    1f1e:	4620      	mov	r0, r4
    1f20:	4b19      	ldr	r3, [pc, #100]	; (1f88 <tcp_create_segment+0xb8>)
    1f22:	4798      	blx	r3
		return NULL;
    1f24:	464c      	mov	r4, r9
    1f26:	e7e7      	b.n	1ef8 <tcp_create_segment+0x28>
	seg->tcphdr        = (struct tcp_hdr *)seg->p->payload;
    1f28:	6863      	ldr	r3, [r4, #4]
	seg->tcphdr->src   = htons(pcb->local_port);
    1f2a:	f8df 9064 	ldr.w	r9, [pc, #100]	; 1f90 <tcp_create_segment+0xc0>
	seg->tcphdr        = (struct tcp_hdr *)seg->p->payload;
    1f2e:	f8d3 b004 	ldr.w	fp, [r3, #4]
	seg->tcphdr->src   = htons(pcb->local_port);
    1f32:	f8b8 001a 	ldrh.w	r0, [r8, #26]
	seg->tcphdr        = (struct tcp_hdr *)seg->p->payload;
    1f36:	f8c4 b00c 	str.w	fp, [r4, #12]
	seg->tcphdr->src   = htons(pcb->local_port);
    1f3a:	47c8      	blx	r9
    1f3c:	f8ab 0000 	strh.w	r0, [fp]
	seg->tcphdr->dest  = htons(pcb->remote_port);
    1f40:	f8b8 001c 	ldrh.w	r0, [r8, #28]
    1f44:	f8d4 b00c 	ldr.w	fp, [r4, #12]
    1f48:	47c8      	blx	r9
	seg->tcphdr->seqno = htonl(seqno);
    1f4a:	4b10      	ldr	r3, [pc, #64]	; (1f8c <tcp_create_segment+0xbc>)
	seg->tcphdr->dest  = htons(pcb->remote_port);
    1f4c:	f8ab 0002 	strh.w	r0, [fp, #2]
	seg->tcphdr->seqno = htonl(seqno);
    1f50:	4650      	mov	r0, sl
    1f52:	f8d4 800c 	ldr.w	r8, [r4, #12]
	TCPH_HDRLEN_FLAGS_SET(seg->tcphdr, (5 + optlen / 4), flags);
    1f56:	02ad      	lsls	r5, r5, #10
	seg->tcphdr->seqno = htonl(seqno);
    1f58:	4798      	blx	r3
	TCPH_HDRLEN_FLAGS_SET(seg->tcphdr, (5 + optlen / 4), flags);
    1f5a:	f505 45a0 	add.w	r5, r5, #20480	; 0x5000
    1f5e:	f405 4570 	and.w	r5, r5, #61440	; 0xf000
	seg->tcphdr->seqno = htonl(seqno);
    1f62:	f8c8 0004 	str.w	r0, [r8, #4]
	TCPH_HDRLEN_FLAGS_SET(seg->tcphdr, (5 + optlen / 4), flags);
    1f66:	ea45 0007 	orr.w	r0, r5, r7
    1f6a:	f8d4 800c 	ldr.w	r8, [r4, #12]
    1f6e:	47c8      	blx	r9
	seg->tcphdr->urgp = 0;
    1f70:	68e3      	ldr	r3, [r4, #12]
	TCPH_HDRLEN_FLAGS_SET(seg->tcphdr, (5 + optlen / 4), flags);
    1f72:	f8a8 000c 	strh.w	r0, [r8, #12]
	seg->tcphdr->urgp = 0;
    1f76:	749e      	strb	r6, [r3, #18]
    1f78:	74de      	strb	r6, [r3, #19]
	return seg;
    1f7a:	e7bd      	b.n	1ef8 <tcp_create_segment+0x28>
    1f7c:	00004c01 	.word	0x00004c01
    1f80:	000030e5 	.word	0x000030e5
    1f84:	0000308d 	.word	0x0000308d
    1f88:	00006ac1 	.word	0x00006ac1
    1f8c:	00000d71 	.word	0x00000d71
    1f90:	00000d65 	.word	0x00000d65

00001f94 <tcp_output_alloc_header.constprop.0>:
	struct pbuf *   p = pbuf_alloc(PBUF_IP, TCP_HLEN + optlen + datalen, PBUF_RAM);
    1f94:	3114      	adds	r1, #20
static struct pbuf *tcp_output_alloc_header(struct tcp_pcb *pcb, u16_t optlen, u16_t datalen,
    1f96:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	struct pbuf *   p = pbuf_alloc(PBUF_IP, TCP_HLEN + optlen + datalen, PBUF_RAM);
    1f9a:	4b15      	ldr	r3, [pc, #84]	; (1ff0 <tcp_output_alloc_header.constprop.0+0x5c>)
static struct pbuf *tcp_output_alloc_header(struct tcp_pcb *pcb, u16_t optlen, u16_t datalen,
    1f9c:	4605      	mov	r5, r0
    1f9e:	4690      	mov	r8, r2
	struct pbuf *   p = pbuf_alloc(PBUF_IP, TCP_HLEN + optlen + datalen, PBUF_RAM);
    1fa0:	b289      	uxth	r1, r1
    1fa2:	2200      	movs	r2, #0
    1fa4:	2001      	movs	r0, #1
    1fa6:	4798      	blx	r3
	if (p != NULL) {
    1fa8:	4606      	mov	r6, r0
    1faa:	b1e8      	cbz	r0, 1fe8 <tcp_output_alloc_header.constprop.0+0x54>
		tcphdr        = (struct tcp_hdr *)p->payload;
    1fac:	6844      	ldr	r4, [r0, #4]
		tcphdr->src   = htons(pcb->local_port);
    1fae:	4f11      	ldr	r7, [pc, #68]	; (1ff4 <tcp_output_alloc_header.constprop.0+0x60>)
    1fb0:	8b68      	ldrh	r0, [r5, #26]
    1fb2:	47b8      	blx	r7
    1fb4:	8020      	strh	r0, [r4, #0]
		tcphdr->dest  = htons(pcb->remote_port);
    1fb6:	8ba8      	ldrh	r0, [r5, #28]
    1fb8:	47b8      	blx	r7
		tcphdr->ackno = htonl(pcb->rcv_nxt);
    1fba:	4b0f      	ldr	r3, [pc, #60]	; (1ff8 <tcp_output_alloc_header.constprop.0+0x64>)
		tcphdr->dest  = htons(pcb->remote_port);
    1fbc:	8060      	strh	r0, [r4, #2]
		tcphdr->seqno = seqno_be;
    1fbe:	f8c4 8004 	str.w	r8, [r4, #4]
		tcphdr->ackno = htonl(pcb->rcv_nxt);
    1fc2:	6aa8      	ldr	r0, [r5, #40]	; 0x28
    1fc4:	4798      	blx	r3
    1fc6:	60a0      	str	r0, [r4, #8]
		TCPH_HDRLEN_FLAGS_SET(tcphdr, (5 + optlen / 4), TCP_ACK);
    1fc8:	f245 0010 	movw	r0, #20496	; 0x5010
    1fcc:	47b8      	blx	r7
    1fce:	81a0      	strh	r0, [r4, #12]
		tcphdr->wnd    = htons(pcb->rcv_ann_wnd);
    1fd0:	8de8      	ldrh	r0, [r5, #46]	; 0x2e
    1fd2:	47b8      	blx	r7
		tcphdr->chksum = 0;
    1fd4:	2300      	movs	r3, #0
    1fd6:	7423      	strb	r3, [r4, #16]
    1fd8:	7463      	strb	r3, [r4, #17]
		tcphdr->urgp   = 0;
    1fda:	74a3      	strb	r3, [r4, #18]
    1fdc:	74e3      	strb	r3, [r4, #19]
		pcb->rcv_ann_right_edge = pcb->rcv_nxt + pcb->rcv_ann_wnd;
    1fde:	8dea      	ldrh	r2, [r5, #46]	; 0x2e
    1fe0:	6aab      	ldr	r3, [r5, #40]	; 0x28
		tcphdr->wnd    = htons(pcb->rcv_ann_wnd);
    1fe2:	81e0      	strh	r0, [r4, #14]
		pcb->rcv_ann_right_edge = pcb->rcv_nxt + pcb->rcv_ann_wnd;
    1fe4:	4413      	add	r3, r2
    1fe6:	632b      	str	r3, [r5, #48]	; 0x30
}
    1fe8:	4630      	mov	r0, r6
    1fea:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    1fee:	bf00      	nop
    1ff0:	0000313d 	.word	0x0000313d
    1ff4:	00000d65 	.word	0x00000d65
    1ff8:	00000d71 	.word	0x00000d71

00001ffc <tcp_write>:
 * - TCP_WRITE_FLAG_COPY (0x01) data will be copied into memory belonging to the stack
 * - TCP_WRITE_FLAG_MORE (0x02) for TCP connection, PSH flag will be set on last segment sent,
 * @return ERR_OK if enqueued, another err_t on error
 */
err_t tcp_write(struct tcp_pcb *pcb, const void *arg, u16_t len, u8_t apiflags)
{
    1ffc:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    2000:	ed2d 8b02 	vpush	{d8}
    2004:	b08d      	sub	sp, #52	; 0x34
    2006:	4604      	mov	r4, r0
    2008:	9306      	str	r3, [sp, #24]
	u16_t           pos = 0; /* position in 'arg' data */
	u16_t           queuelen;
	u8_t            optlen   = 0;
	u8_t            optflags = 0;
#if TCP_OVERSIZE
	u16_t oversize      = 0;
    200a:	2300      	movs	r3, #0
{
    200c:	4617      	mov	r7, r2
	u16_t oversize      = 0;
    200e:	f8ad 302e 	strh.w	r3, [sp, #46]	; 0x2e
#endif /* LWIP_NETIF_TX_SINGLE_PBUF */

	LWIP_DEBUGF(
	    TCP_OUTPUT_DEBUG,
	    ("tcp_write(pcb=%p, data=%p, len=%" U16_F ", apiflags=%" U16_F ")\n", (void *)pcb, arg, len, (u16_t)apiflags));
	LWIP_ERROR("tcp_write: arg == NULL (programmer violates API)", arg != NULL, return ERR_ARG;);
    2012:	9105      	str	r1, [sp, #20]
    2014:	b901      	cbnz	r1, 2018 <tcp_write+0x1c>
    2016:	e7fe      	b.n	2016 <tcp_write+0x1a>
	if ((pcb->state != ESTABLISHED) && (pcb->state != CLOSE_WAIT) && (pcb->state != SYN_SENT)
    2018:	7e03      	ldrb	r3, [r0, #24]
    201a:	2b07      	cmp	r3, #7
    201c:	d003      	beq.n	2026 <tcp_write+0x2a>
    201e:	3b02      	subs	r3, #2
    2020:	2b02      	cmp	r3, #2
    2022:	f200 8172 	bhi.w	230a <tcp_write+0x30e>
	} else if (len == 0) {
    2026:	b177      	cbz	r7, 2046 <tcp_write+0x4a>
	if (len > pcb->snd_buf) {
    2028:	f8b4 3066 	ldrh.w	r3, [r4, #102]	; 0x66
    202c:	42bb      	cmp	r3, r7
    202e:	d206      	bcs.n	203e <tcp_write+0x42>
		pcb->flags |= TF_NAGLEMEMERR;
    2030:	7fa3      	ldrb	r3, [r4, #30]
    2032:	f063 037f 	orn	r3, r3, #127	; 0x7f
    2036:	77a3      	strb	r3, [r4, #30]
	}
	if (pcb->snd_queuelen != 0) {
		LWIP_ASSERT("tcp_write: valid queue length", pcb->unacked != NULL || pcb->unsent != NULL);
	}
	LWIP_DEBUGF(TCP_QLEN_DEBUG | LWIP_DBG_STATE, ("tcp_write: %" S16_F " (with mem err)\n", pcb->snd_queuelen));
	return ERR_MEM;
    2038:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    203c:	e167      	b.n	230e <tcp_write+0x312>
	if ((pcb->snd_queuelen >= TCP_SND_QUEUELEN) || (pcb->snd_queuelen > TCP_SNDQUEUELEN_OVERFLOW)) {
    203e:	f8b4 3068 	ldrh.w	r3, [r4, #104]	; 0x68
    2042:	2b07      	cmp	r3, #7
    2044:	d8f4      	bhi.n	2030 <tcp_write+0x34>
	u16_t mss_local = LWIP_MIN(pcb->mss, pcb->snd_wnd_max / 2);
    2046:	f8b4 3062 	ldrh.w	r3, [r4, #98]	; 0x62
    204a:	8ee2      	ldrh	r2, [r4, #54]	; 0x36
	if (pcb->unsent != NULL) {
    204c:	f8d4 806c 	ldr.w	r8, [r4, #108]	; 0x6c
	u16_t mss_local = LWIP_MIN(pcb->mss, pcb->snd_wnd_max / 2);
    2050:	085b      	lsrs	r3, r3, #1
    2052:	4293      	cmp	r3, r2
    2054:	bf28      	it	cs
    2056:	4613      	movcs	r3, r2
    2058:	9307      	str	r3, [sp, #28]
	queuelen = pcb->snd_queuelen;
    205a:	f8b4 3068 	ldrh.w	r3, [r4, #104]	; 0x68
    205e:	9304      	str	r3, [sp, #16]
	if (pcb->unsent != NULL) {
    2060:	f1b8 0f00 	cmp.w	r8, #0
    2064:	d105      	bne.n	2072 <tcp_write+0x76>
	struct tcp_seg *last_unsent = NULL, *seg = NULL, *prev_seg = NULL, *queue = NULL;
    2066:	46c2      	mov	sl, r8
	struct pbuf *   concat_p    = NULL;
    2068:	46c1      	mov	r9, r8
	u16_t oversize_used = 0;
    206a:	4645      	mov	r5, r8
	u16_t           pos = 0; /* position in 'arg' data */
    206c:	4646      	mov	r6, r8
    206e:	e05a      	b.n	2126 <tcp_write+0x12a>
    2070:	46c8      	mov	r8, r9
		for (last_unsent = pcb->unsent; last_unsent->next != NULL; last_unsent = last_unsent->next)
    2072:	f8d8 9000 	ldr.w	r9, [r8]
    2076:	46c2      	mov	sl, r8
    2078:	f1b9 0f00 	cmp.w	r9, #0
    207c:	d1f8      	bne.n	2070 <tcp_write+0x74>
		unsent_optlen = LWIP_TCP_OPT_LENGTH(last_unsent->flags);
    207e:	f898 300a 	ldrb.w	r3, [r8, #10]
		oversize = pcb->unsent_oversize;
    2082:	f8b4 506a 	ldrh.w	r5, [r4, #106]	; 0x6a
		unsent_optlen = LWIP_TCP_OPT_LENGTH(last_unsent->flags);
    2086:	009a      	lsls	r2, r3, #2
    2088:	f013 0f02 	tst.w	r3, #2
    208c:	f002 0104 	and.w	r1, r2, #4
		space         = mss_local - (last_unsent->len + unsent_optlen);
    2090:	f8b8 3008 	ldrh.w	r3, [r8, #8]
    2094:	9a07      	ldr	r2, [sp, #28]
    2096:	eba2 0203 	sub.w	r2, r2, r3
		unsent_optlen = LWIP_TCP_OPT_LENGTH(last_unsent->flags);
    209a:	bf14      	ite	ne
    209c:	200c      	movne	r0, #12
    209e:	2000      	moveq	r0, #0
		space         = mss_local - (last_unsent->len + unsent_optlen);
    20a0:	1a52      	subs	r2, r2, r1
    20a2:	1a12      	subs	r2, r2, r0
    20a4:	b292      	uxth	r2, r2
		if (oversize > 0) {
    20a6:	2d00      	cmp	r5, #0
    20a8:	d047      	beq.n	213a <tcp_write+0x13e>
			oversize_used = oversize < len ? oversize : len;
    20aa:	42bd      	cmp	r5, r7
    20ac:	4629      	mov	r1, r5
    20ae:	bf28      	it	cs
    20b0:	4639      	movcs	r1, r7
			oversize -= oversize_used;
    20b2:	1a6d      	subs	r5, r5, r1
			space -= oversize_used;
    20b4:	1a52      	subs	r2, r2, r1
			oversize -= oversize_used;
    20b6:	f8ad 502e 	strh.w	r5, [sp, #46]	; 0x2e
			space -= oversize_used;
    20ba:	b292      	uxth	r2, r2
			pos += oversize_used;
    20bc:	460d      	mov	r5, r1
		if ((pos < len) && (space > 0) && (last_unsent->len > 0)) {
    20be:	42bd      	cmp	r5, r7
    20c0:	f080 80e7 	bcs.w	2292 <tcp_write+0x296>
    20c4:	2a00      	cmp	r2, #0
    20c6:	f000 80e2 	beq.w	228e <tcp_write+0x292>
    20ca:	2b00      	cmp	r3, #0
    20cc:	f000 80df 	beq.w	228e <tcp_write+0x292>
			u16_t seglen = space < len - pos ? space : len - pos;
    20d0:	eba7 0805 	sub.w	r8, r7, r5
			if (apiflags & TCP_WRITE_FLAG_COPY) {
    20d4:	9b06      	ldr	r3, [sp, #24]
			u16_t seglen = space < len - pos ? space : len - pos;
    20d6:	4590      	cmp	r8, r2
    20d8:	bfa8      	it	ge
    20da:	4690      	movge	r8, r2
			if (apiflags & TCP_WRITE_FLAG_COPY) {
    20dc:	07db      	lsls	r3, r3, #31
			u16_t seglen = space < len - pos ? space : len - pos;
    20de:	fa1f f688 	uxth.w	r6, r8
			if (apiflags & TCP_WRITE_FLAG_COPY) {
    20e2:	d52c      	bpl.n	213e <tcp_write+0x142>
				if ((concat_p = tcp_pbuf_prealloc(PBUF_RAW, seglen, space, &oversize, pcb, apiflags, 1)) == NULL) {
    20e4:	2301      	movs	r3, #1
    20e6:	9302      	str	r3, [sp, #8]
    20e8:	9b06      	ldr	r3, [sp, #24]
    20ea:	f8df b248 	ldr.w	fp, [pc, #584]	; 2334 <tcp_write+0x338>
    20ee:	e9cd 4300 	strd	r4, r3, [sp]
    20f2:	4631      	mov	r1, r6
    20f4:	f10d 032e 	add.w	r3, sp, #46	; 0x2e
    20f8:	2003      	movs	r0, #3
    20fa:	47d8      	blx	fp
    20fc:	4683      	mov	fp, r0
    20fe:	2800      	cmp	r0, #0
    2100:	f000 8100 	beq.w	2304 <tcp_write+0x308>
				TCP_DATA_COPY2(concat_p->payload, (u8_t *)arg + pos, seglen, &concat_chksum, &concat_chksum_swapped);
    2104:	9b05      	ldr	r3, [sp, #20]
    2106:	6840      	ldr	r0, [r0, #4]
    2108:	1959      	adds	r1, r3, r5
    210a:	4632      	mov	r2, r6
    210c:	4b82      	ldr	r3, [pc, #520]	; (2318 <tcp_write+0x31c>)
    210e:	4798      	blx	r3
			queuelen += pbuf_clen(concat_p);
    2110:	4b82      	ldr	r3, [pc, #520]	; (231c <tcp_write+0x320>)
    2112:	4658      	mov	r0, fp
    2114:	4798      	blx	r3
    2116:	9b04      	ldr	r3, [sp, #16]
    2118:	4403      	add	r3, r0
			pos += seglen;
    211a:	442e      	add	r6, r5
			queuelen += pbuf_clen(concat_p);
    211c:	b29b      	uxth	r3, r3
			pos += seglen;
    211e:	b2b6      	uxth	r6, r6
			queuelen += pbuf_clen(concat_p);
    2120:	9304      	str	r3, [sp, #16]
    2122:	46d0      	mov	r8, sl
    2124:	46d9      	mov	r9, fp
		if (apiflags & TCP_WRITE_FLAG_COPY) {
    2126:	9b06      	ldr	r3, [sp, #24]
    2128:	f04f 0b00 	mov.w	fp, #0
    212c:	f003 0301 	and.w	r3, r3, #1
    2130:	ee08 3a10 	vmov	s16, r3
    2134:	f8cd b020 	str.w	fp, [sp, #32]
    2138:	e083      	b.n	2242 <tcp_write+0x246>
	struct tcp_seg *last_unsent = NULL, *seg = NULL, *prev_seg = NULL, *queue = NULL;
    213a:	46a8      	mov	r8, r5
    213c:	e7bf      	b.n	20be <tcp_write+0xc2>
				if ((concat_p = pbuf_alloc(PBUF_RAW, seglen, PBUF_ROM)) == NULL) {
    213e:	4b78      	ldr	r3, [pc, #480]	; (2320 <tcp_write+0x324>)
    2140:	2201      	movs	r2, #1
    2142:	4631      	mov	r1, r6
    2144:	2003      	movs	r0, #3
    2146:	4798      	blx	r3
    2148:	4683      	mov	fp, r0
    214a:	2800      	cmp	r0, #0
    214c:	f000 80da 	beq.w	2304 <tcp_write+0x308>
				concat_p->payload = (u8_t *)arg + pos;
    2150:	9b05      	ldr	r3, [sp, #20]
    2152:	442b      	add	r3, r5
    2154:	6043      	str	r3, [r0, #4]
    2156:	e7db      	b.n	2110 <tcp_write+0x114>
		u16_t        seglen  = left > max_len ? max_len : left;
    2158:	9a07      	ldr	r2, [sp, #28]
		u16_t        left    = len - pos;
    215a:	1bbb      	subs	r3, r7, r6
		u16_t        seglen  = left > max_len ? max_len : left;
    215c:	b29b      	uxth	r3, r3
    215e:	4293      	cmp	r3, r2
    2160:	bf28      	it	cs
    2162:	4613      	movcs	r3, r2
    2164:	ee08 3a90 	vmov	s17, r3
		if (apiflags & TCP_WRITE_FLAG_COPY) {
    2168:	ee18 3a10 	vmov	r3, s16
    216c:	b313      	cbz	r3, 21b4 <tcp_write+0x1b8>
			if ((p = tcp_pbuf_prealloc(
    216e:	fabb f38b 	clz	r3, fp
    2172:	095b      	lsrs	r3, r3, #5
    2174:	9302      	str	r3, [sp, #8]
    2176:	9b06      	ldr	r3, [sp, #24]
    2178:	f8df 81b8 	ldr.w	r8, [pc, #440]	; 2334 <tcp_write+0x338>
    217c:	e9cd 4300 	strd	r4, r3, [sp]
    2180:	ee18 1a90 	vmov	r1, s17
    2184:	f10d 032e 	add.w	r3, sp, #46	; 0x2e
    2188:	2000      	movs	r0, #0
    218a:	47c0      	blx	r8
    218c:	4680      	mov	r8, r0
    218e:	b358      	cbz	r0, 21e8 <tcp_write+0x1ec>
			TCP_DATA_COPY2((char *)p->payload + optlen, (u8_t *)arg + pos, seglen, &chksum, &chksum_swapped);
    2190:	9b05      	ldr	r3, [sp, #20]
    2192:	6840      	ldr	r0, [r0, #4]
    2194:	1999      	adds	r1, r3, r6
    2196:	ee18 2a90 	vmov	r2, s17
    219a:	4b5f      	ldr	r3, [pc, #380]	; (2318 <tcp_write+0x31c>)
    219c:	4798      	blx	r3
		queuelen += pbuf_clen(p);
    219e:	4b5f      	ldr	r3, [pc, #380]	; (231c <tcp_write+0x320>)
    21a0:	4640      	mov	r0, r8
    21a2:	4798      	blx	r3
    21a4:	9b04      	ldr	r3, [sp, #16]
    21a6:	4403      	add	r3, r0
    21a8:	b29b      	uxth	r3, r3
		if ((queuelen > TCP_SND_QUEUELEN) || (queuelen > TCP_SNDQUEUELEN_OVERFLOW)) {
    21aa:	2b08      	cmp	r3, #8
		queuelen += pbuf_clen(p);
    21ac:	9304      	str	r3, [sp, #16]
		if ((queuelen > TCP_SND_QUEUELEN) || (queuelen > TCP_SNDQUEUELEN_OVERFLOW)) {
    21ae:	d931      	bls.n	2214 <tcp_write+0x218>
			pbuf_free(p);
    21b0:	4640      	mov	r0, r8
    21b2:	e017      	b.n	21e4 <tcp_write+0x1e8>
			if ((p2 = pbuf_alloc(PBUF_TRANSPORT, seglen, PBUF_ROM)) == NULL) {
    21b4:	ee18 1a90 	vmov	r1, s17
    21b8:	ee18 0a10 	vmov	r0, s16
    21bc:	4b58      	ldr	r3, [pc, #352]	; (2320 <tcp_write+0x324>)
    21be:	2201      	movs	r2, #1
    21c0:	4798      	blx	r3
    21c2:	b188      	cbz	r0, 21e8 <tcp_write+0x1ec>
			p2->payload = (u8_t *)arg + pos;
    21c4:	9a05      	ldr	r2, [sp, #20]
			if ((p = pbuf_alloc(PBUF_TRANSPORT, optlen, PBUF_RAM)) == NULL) {
    21c6:	4b56      	ldr	r3, [pc, #344]	; (2320 <tcp_write+0x324>)
			p2->payload = (u8_t *)arg + pos;
    21c8:	9009      	str	r0, [sp, #36]	; 0x24
    21ca:	4432      	add	r2, r6
    21cc:	6042      	str	r2, [r0, #4]
			if ((p = pbuf_alloc(PBUF_TRANSPORT, optlen, PBUF_RAM)) == NULL) {
    21ce:	ee18 1a10 	vmov	r1, s16
    21d2:	ee18 2a10 	vmov	r2, s16
    21d6:	ee18 0a10 	vmov	r0, s16
    21da:	4798      	blx	r3
    21dc:	9b09      	ldr	r3, [sp, #36]	; 0x24
    21de:	4680      	mov	r8, r0
    21e0:	b9a0      	cbnz	r0, 220c <tcp_write+0x210>
				pbuf_free(p2);
    21e2:	4618      	mov	r0, r3
			pbuf_free(p);
    21e4:	4b4f      	ldr	r3, [pc, #316]	; (2324 <tcp_write+0x328>)
    21e6:	4798      	blx	r3
	pcb->flags |= TF_NAGLEMEMERR;
    21e8:	7fa3      	ldrb	r3, [r4, #30]
    21ea:	f063 037f 	orn	r3, r3, #127	; 0x7f
    21ee:	77a3      	strb	r3, [r4, #30]
	if (concat_p != NULL) {
    21f0:	f1b9 0f00 	cmp.w	r9, #0
    21f4:	d002      	beq.n	21fc <tcp_write+0x200>
		pbuf_free(concat_p);
    21f6:	4b4b      	ldr	r3, [pc, #300]	; (2324 <tcp_write+0x328>)
    21f8:	4648      	mov	r0, r9
    21fa:	4798      	blx	r3
	if (queue != NULL) {
    21fc:	f1bb 0f00 	cmp.w	fp, #0
    2200:	f43f af1a 	beq.w	2038 <tcp_write+0x3c>
		tcp_segs_free(queue);
    2204:	4b48      	ldr	r3, [pc, #288]	; (2328 <tcp_write+0x32c>)
    2206:	4658      	mov	r0, fp
    2208:	4798      	blx	r3
    220a:	e715      	b.n	2038 <tcp_write+0x3c>
			pbuf_cat(p /*header*/, p2 /*data*/);
    220c:	4619      	mov	r1, r3
    220e:	4b47      	ldr	r3, [pc, #284]	; (232c <tcp_write+0x330>)
    2210:	4798      	blx	r3
    2212:	e7c4      	b.n	219e <tcp_write+0x1a2>
		if ((seg = tcp_create_segment(pcb, p, 0, pcb->snd_lbb + pos, optflags)) == NULL) {
    2214:	6de3      	ldr	r3, [r4, #92]	; 0x5c
    2216:	2200      	movs	r2, #0
    2218:	4641      	mov	r1, r8
    221a:	9200      	str	r2, [sp, #0]
    221c:	f8df 8118 	ldr.w	r8, [pc, #280]	; 2338 <tcp_write+0x33c>
    2220:	4433      	add	r3, r6
    2222:	4620      	mov	r0, r4
    2224:	47c0      	blx	r8
    2226:	4680      	mov	r8, r0
    2228:	2800      	cmp	r0, #0
    222a:	d0dd      	beq.n	21e8 <tcp_write+0x1ec>
		if (queue == NULL) {
    222c:	f1bb 0f00 	cmp.w	fp, #0
    2230:	d02b      	beq.n	228a <tcp_write+0x28e>
			prev_seg->next = seg;
    2232:	9b08      	ldr	r3, [sp, #32]
    2234:	6018      	str	r0, [r3, #0]
		pos += seglen;
    2236:	ee18 3a90 	vmov	r3, s17
    223a:	441e      	add	r6, r3
    223c:	b2b6      	uxth	r6, r6
    223e:	f8cd 8020 	str.w	r8, [sp, #32]
	while (pos < len) {
    2242:	42be      	cmp	r6, r7
    2244:	d388      	bcc.n	2158 <tcp_write+0x15c>
    2246:	464b      	mov	r3, r9
    2248:	46d9      	mov	r9, fp
	if (oversize_used > 0) {
    224a:	b14d      	cbz	r5, 2260 <tcp_write+0x264>
		for (p = last_unsent->p; p; p = p->next) {
    224c:	f8da 6004 	ldr.w	r6, [sl, #4]
				TCP_DATA_COPY((char *)p->payload + p->len, arg, oversize_used, last_unsent);
    2250:	f8df b0c4 	ldr.w	fp, [pc, #196]	; 2318 <tcp_write+0x31c>
		for (p = last_unsent->p; p; p = p->next) {
    2254:	b9fe      	cbnz	r6, 2296 <tcp_write+0x29a>
		last_unsent->len += oversize_used;
    2256:	f8ba 2008 	ldrh.w	r2, [sl, #8]
    225a:	4415      	add	r5, r2
    225c:	f8aa 5008 	strh.w	r5, [sl, #8]
	pcb->unsent_oversize = oversize;
    2260:	f8bd 202e 	ldrh.w	r2, [sp, #46]	; 0x2e
    2264:	f8a4 206a 	strh.w	r2, [r4, #106]	; 0x6a
	if (concat_p != NULL) {
    2268:	b343      	cbz	r3, 22bc <tcp_write+0x2c0>
		pbuf_cat(last_unsent->p, concat_p);
    226a:	4a30      	ldr	r2, [pc, #192]	; (232c <tcp_write+0x330>)
    226c:	f8da 0004 	ldr.w	r0, [sl, #4]
    2270:	9305      	str	r3, [sp, #20]
    2272:	4619      	mov	r1, r3
    2274:	4790      	blx	r2
		last_unsent->len += concat_p->tot_len;
    2276:	9b05      	ldr	r3, [sp, #20]
    2278:	f8ba 2008 	ldrh.w	r2, [sl, #8]
    227c:	891b      	ldrh	r3, [r3, #8]
    227e:	4413      	add	r3, r2
    2280:	f8aa 3008 	strh.w	r3, [sl, #8]
		last_unsent->next = queue;
    2284:	f8ca 9000 	str.w	r9, [sl]
    2288:	e01d      	b.n	22c6 <tcp_write+0x2ca>
    228a:	4683      	mov	fp, r0
    228c:	e7d3      	b.n	2236 <tcp_write+0x23a>
    228e:	462e      	mov	r6, r5
    2290:	e749      	b.n	2126 <tcp_write+0x12a>
	struct pbuf *   concat_p    = NULL;
    2292:	2300      	movs	r3, #0
    2294:	e7d9      	b.n	224a <tcp_write+0x24e>
			p->tot_len += oversize_used;
    2296:	8932      	ldrh	r2, [r6, #8]
    2298:	442a      	add	r2, r5
    229a:	8132      	strh	r2, [r6, #8]
			if (p->next == NULL) {
    229c:	6832      	ldr	r2, [r6, #0]
    229e:	b95a      	cbnz	r2, 22b8 <tcp_write+0x2bc>
				TCP_DATA_COPY((char *)p->payload + p->len, arg, oversize_used, last_unsent);
    22a0:	f8b6 c00a 	ldrh.w	ip, [r6, #10]
    22a4:	6870      	ldr	r0, [r6, #4]
    22a6:	9905      	ldr	r1, [sp, #20]
    22a8:	9307      	str	r3, [sp, #28]
    22aa:	462a      	mov	r2, r5
    22ac:	4460      	add	r0, ip
    22ae:	47d8      	blx	fp
				p->len += oversize_used;
    22b0:	8972      	ldrh	r2, [r6, #10]
    22b2:	9b07      	ldr	r3, [sp, #28]
    22b4:	442a      	add	r2, r5
    22b6:	8172      	strh	r2, [r6, #10]
		for (p = last_unsent->p; p; p = p->next) {
    22b8:	6836      	ldr	r6, [r6, #0]
    22ba:	e7cb      	b.n	2254 <tcp_write+0x258>
	if (last_unsent == NULL) {
    22bc:	f1ba 0f00 	cmp.w	sl, #0
    22c0:	d1e0      	bne.n	2284 <tcp_write+0x288>
		pcb->unsent = queue;
    22c2:	f8c4 906c 	str.w	r9, [r4, #108]	; 0x6c
	pcb->snd_lbb += len;
    22c6:	6de3      	ldr	r3, [r4, #92]	; 0x5c
	pcb->snd_buf -= len;
    22c8:	f8b4 2066 	ldrh.w	r2, [r4, #102]	; 0x66
	pcb->snd_lbb += len;
    22cc:	443b      	add	r3, r7
    22ce:	65e3      	str	r3, [r4, #92]	; 0x5c
	pcb->snd_buf -= len;
    22d0:	1bd7      	subs	r7, r2, r7
	pcb->snd_queuelen = queuelen;
    22d2:	9b04      	ldr	r3, [sp, #16]
	pcb->snd_buf -= len;
    22d4:	f8a4 7066 	strh.w	r7, [r4, #102]	; 0x66
	pcb->snd_queuelen = queuelen;
    22d8:	f8a4 3068 	strh.w	r3, [r4, #104]	; 0x68
	if (seg != NULL && seg->tcphdr != NULL && ((apiflags & TCP_WRITE_FLAG_MORE) == 0)) {
    22dc:	f1b8 0f00 	cmp.w	r8, #0
    22e0:	d00e      	beq.n	2300 <tcp_write+0x304>
    22e2:	f8d8 000c 	ldr.w	r0, [r8, #12]
    22e6:	b190      	cbz	r0, 230e <tcp_write+0x312>
    22e8:	9b06      	ldr	r3, [sp, #24]
    22ea:	f013 0402 	ands.w	r4, r3, #2
    22ee:	d107      	bne.n	2300 <tcp_write+0x304>
		TCPH_SET_FLAG(seg->tcphdr, TCP_PSH);
    22f0:	8985      	ldrh	r5, [r0, #12]
    22f2:	4b0f      	ldr	r3, [pc, #60]	; (2330 <tcp_write+0x334>)
    22f4:	2008      	movs	r0, #8
    22f6:	4798      	blx	r3
    22f8:	f8d8 300c 	ldr.w	r3, [r8, #12]
    22fc:	4328      	orrs	r0, r5
    22fe:	8198      	strh	r0, [r3, #12]
	return ERR_OK;
    2300:	2000      	movs	r0, #0
    2302:	e004      	b.n	230e <tcp_write+0x312>
	struct tcp_seg *last_unsent = NULL, *seg = NULL, *prev_seg = NULL, *queue = NULL;
    2304:	f04f 0b00 	mov.w	fp, #0
    2308:	e76e      	b.n	21e8 <tcp_write+0x1ec>
		return ERR_CONN;
    230a:	f06f 000c 	mvn.w	r0, #12
}
    230e:	b00d      	add	sp, #52	; 0x34
    2310:	ecbd 8b02 	vpop	{d8}
    2314:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    2318:	0000a349 	.word	0x0000a349
    231c:	000032a1 	.word	0x000032a1
    2320:	0000313d 	.word	0x0000313d
    2324:	000030e5 	.word	0x000030e5
    2328:	00006ae5 	.word	0x00006ae5
    232c:	000032bb 	.word	0x000032bb
    2330:	00000d65 	.word	0x00000d65
    2334:	00001e7d 	.word	0x00001e7d
    2338:	00001ed1 	.word	0x00001ed1

0000233c <tcp_enqueue_flags>:

	LWIP_ASSERT("tcp_enqueue_flags: need either TCP_SYN or TCP_FIN in flags (programmer violates API)",
	            (flags & (TCP_SYN | TCP_FIN)) != 0);

	/* check for configured max queuelen and possible overflow */
	if ((pcb->snd_queuelen >= TCP_SND_QUEUELEN) || (pcb->snd_queuelen > TCP_SNDQUEUELEN_OVERFLOW)) {
    233c:	f8b0 3068 	ldrh.w	r3, [r0, #104]	; 0x68
    2340:	2b07      	cmp	r3, #7
{
    2342:	b573      	push	{r0, r1, r4, r5, r6, lr}
    2344:	4604      	mov	r4, r0
    2346:	460d      	mov	r5, r1
	if ((pcb->snd_queuelen >= TCP_SND_QUEUELEN) || (pcb->snd_queuelen > TCP_SNDQUEUELEN_OVERFLOW)) {
    2348:	d906      	bls.n	2358 <tcp_enqueue_flags+0x1c>
	}
	LWIP_ASSERT("tcp_enqueue_flags: check that first pbuf can hold optlen", (p->len >= optlen));

	/* Allocate memory for tcp_seg, and fill in fields. */
	if ((seg = tcp_create_segment(pcb, p, flags, pcb->snd_lbb, optflags)) == NULL) {
		pcb->flags |= TF_NAGLEMEMERR;
    234a:	7fa3      	ldrb	r3, [r4, #30]
    234c:	f063 037f 	orn	r3, r3, #127	; 0x7f
    2350:	77a3      	strb	r3, [r4, #30]
		return ERR_MEM;
    2352:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    2356:	e034      	b.n	23c2 <tcp_enqueue_flags+0x86>
	if (pcb->snd_buf == 0) {
    2358:	f8b0 3066 	ldrh.w	r3, [r0, #102]	; 0x66
	if (flags & TCP_SYN) {
    235c:	f3c1 0640 	ubfx	r6, r1, #1, #1
	optlen = LWIP_TCP_OPT_LENGTH(optflags);
    2360:	00b1      	lsls	r1, r6, #2
	if (pcb->snd_buf == 0) {
    2362:	2b00      	cmp	r3, #0
    2364:	d0f5      	beq.n	2352 <tcp_enqueue_flags+0x16>
	if ((p = pbuf_alloc(PBUF_TRANSPORT, optlen, PBUF_RAM)) == NULL) {
    2366:	2200      	movs	r2, #0
    2368:	4b1a      	ldr	r3, [pc, #104]	; (23d4 <tcp_enqueue_flags+0x98>)
    236a:	4610      	mov	r0, r2
    236c:	4798      	blx	r3
    236e:	4601      	mov	r1, r0
    2370:	2800      	cmp	r0, #0
    2372:	d0ea      	beq.n	234a <tcp_enqueue_flags+0xe>
	if ((seg = tcp_create_segment(pcb, p, flags, pcb->snd_lbb, optflags)) == NULL) {
    2374:	9600      	str	r6, [sp, #0]
    2376:	6de3      	ldr	r3, [r4, #92]	; 0x5c
    2378:	4e17      	ldr	r6, [pc, #92]	; (23d8 <tcp_enqueue_flags+0x9c>)
    237a:	462a      	mov	r2, r5
    237c:	4620      	mov	r0, r4
    237e:	47b0      	blx	r6
    2380:	2800      	cmp	r0, #0
    2382:	d0e2      	beq.n	234a <tcp_enqueue_flags+0xe>
	             ntohl(seg->tcphdr->seqno),
	             ntohl(seg->tcphdr->seqno) + TCP_TCPLEN(seg),
	             (u16_t)flags));

	/* Now append seg to pcb->unsent queue */
	if (pcb->unsent == NULL) {
    2384:	6ee3      	ldr	r3, [r4, #108]	; 0x6c
    2386:	b9f3      	cbnz	r3, 23c6 <tcp_enqueue_flags+0x8a>
		pcb->unsent = seg;
    2388:	66e0      	str	r0, [r4, #108]	; 0x6c
			;
		useg->next = seg;
	}
#if TCP_OVERSIZE
	/* The new unsent tail has no space */
	pcb->unsent_oversize = 0;
    238a:	2300      	movs	r3, #0
#endif /* TCP_OVERSIZE */

	/* SYN and FIN bump the sequence number */
	if ((flags & TCP_SYN) || (flags & TCP_FIN)) {
    238c:	07aa      	lsls	r2, r5, #30
	pcb->unsent_oversize = 0;
    238e:	f8a4 306a 	strh.w	r3, [r4, #106]	; 0x6a
	if ((flags & TCP_SYN) || (flags & TCP_FIN)) {
    2392:	d007      	beq.n	23a4 <tcp_enqueue_flags+0x68>
		pcb->snd_lbb++;
    2394:	6de3      	ldr	r3, [r4, #92]	; 0x5c
    2396:	3301      	adds	r3, #1
    2398:	65e3      	str	r3, [r4, #92]	; 0x5c
		/* optlen does not influence snd_buf */
		pcb->snd_buf--;
    239a:	f8b4 3066 	ldrh.w	r3, [r4, #102]	; 0x66
    239e:	3b01      	subs	r3, #1
    23a0:	f8a4 3066 	strh.w	r3, [r4, #102]	; 0x66
	}
	if (flags & TCP_FIN) {
    23a4:	07eb      	lsls	r3, r5, #31
		pcb->flags |= TF_FIN;
    23a6:	bf42      	ittt	mi
    23a8:	7fa3      	ldrbmi	r3, [r4, #30]
    23aa:	f043 0320 	orrmi.w	r3, r3, #32
    23ae:	77a3      	strbmi	r3, [r4, #30]
	}

	/* update number of segments on the queues */
	pcb->snd_queuelen += pbuf_clen(seg->p);
    23b0:	6840      	ldr	r0, [r0, #4]
    23b2:	4b0a      	ldr	r3, [pc, #40]	; (23dc <tcp_enqueue_flags+0xa0>)
    23b4:	4798      	blx	r3
    23b6:	f8b4 3068 	ldrh.w	r3, [r4, #104]	; 0x68
    23ba:	4418      	add	r0, r3
    23bc:	f8a4 0068 	strh.w	r0, [r4, #104]	; 0x68
	LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_enqueue_flags: %" S16_F " (after enqueued)\n", pcb->snd_queuelen));
	if (pcb->snd_queuelen != 0) {
		LWIP_ASSERT("tcp_enqueue_flags: invalid queue length", pcb->unacked != NULL || pcb->unsent != NULL);
	}

	return ERR_OK;
    23c0:	2000      	movs	r0, #0
}
    23c2:	b002      	add	sp, #8
    23c4:	bd70      	pop	{r4, r5, r6, pc}
		for (useg = pcb->unsent; useg->next != NULL; useg = useg->next)
    23c6:	461a      	mov	r2, r3
    23c8:	681b      	ldr	r3, [r3, #0]
    23ca:	2b00      	cmp	r3, #0
    23cc:	d1fb      	bne.n	23c6 <tcp_enqueue_flags+0x8a>
		useg->next = seg;
    23ce:	6010      	str	r0, [r2, #0]
    23d0:	e7db      	b.n	238a <tcp_enqueue_flags+0x4e>
    23d2:	bf00      	nop
    23d4:	0000313d 	.word	0x0000313d
    23d8:	00001ed1 	.word	0x00001ed1
    23dc:	000032a1 	.word	0x000032a1

000023e0 <tcp_send_fin>:
{
    23e0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	if (pcb->unsent != NULL) {
    23e4:	6ec4      	ldr	r4, [r0, #108]	; 0x6c
{
    23e6:	4605      	mov	r5, r0
	if (pcb->unsent != NULL) {
    23e8:	b14c      	cbz	r4, 23fe <tcp_send_fin+0x1e>
		for (last_unsent = pcb->unsent; last_unsent->next != NULL; last_unsent = last_unsent->next)
    23ea:	4627      	mov	r7, r4
    23ec:	6824      	ldr	r4, [r4, #0]
    23ee:	2c00      	cmp	r4, #0
    23f0:	d1fb      	bne.n	23ea <tcp_send_fin+0xa>
		if ((TCPH_FLAGS(last_unsent->tcphdr) & (TCP_SYN | TCP_FIN | TCP_RST)) == 0) {
    23f2:	68fb      	ldr	r3, [r7, #12]
    23f4:	8998      	ldrh	r0, [r3, #12]
    23f6:	4b0c      	ldr	r3, [pc, #48]	; (2428 <tcp_send_fin+0x48>)
    23f8:	4798      	blx	r3
    23fa:	0743      	lsls	r3, r0, #29
    23fc:	d005      	beq.n	240a <tcp_send_fin+0x2a>
	return tcp_enqueue_flags(pcb, TCP_FIN);
    23fe:	4628      	mov	r0, r5
    2400:	4b0a      	ldr	r3, [pc, #40]	; (242c <tcp_send_fin+0x4c>)
}
    2402:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
	return tcp_enqueue_flags(pcb, TCP_FIN);
    2406:	2101      	movs	r1, #1
    2408:	4718      	bx	r3
			TCPH_SET_FLAG(last_unsent->tcphdr, TCP_FIN);
    240a:	68fb      	ldr	r3, [r7, #12]
    240c:	2001      	movs	r0, #1
    240e:	899e      	ldrh	r6, [r3, #12]
    2410:	4b07      	ldr	r3, [pc, #28]	; (2430 <tcp_send_fin+0x50>)
    2412:	4798      	blx	r3
    2414:	68fb      	ldr	r3, [r7, #12]
    2416:	4330      	orrs	r0, r6
    2418:	8198      	strh	r0, [r3, #12]
			pcb->flags |= TF_FIN;
    241a:	7fab      	ldrb	r3, [r5, #30]
    241c:	f043 0320 	orr.w	r3, r3, #32
    2420:	77ab      	strb	r3, [r5, #30]
}
    2422:	4620      	mov	r0, r4
    2424:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    2428:	00000d6b 	.word	0x00000d6b
    242c:	0000233d 	.word	0x0000233d
    2430:	00000d65 	.word	0x00000d65

00002434 <tcp_send_empty_ack>:
/** Send an ACK without data.
 *
 * @param pcb Protocol control block for the TCP connection to send the ACK
 */
err_t tcp_send_empty_ack(struct tcp_pcb *pcb)
{
    2434:	b5f0      	push	{r4, r5, r6, r7, lr}
	if (pcb->flags & TF_TIMESTAMP) {
		optlen = LWIP_TCP_OPT_LENGTH(TF_SEG_OPTS_TS);
	}
#endif

	p = tcp_output_alloc_header(pcb, optlen, 0, htonl(pcb->snd_nxt));
    2436:	4b16      	ldr	r3, [pc, #88]	; (2490 <tcp_send_empty_ack+0x5c>)
{
    2438:	b085      	sub	sp, #20
    243a:	4604      	mov	r4, r0
	p = tcp_output_alloc_header(pcb, optlen, 0, htonl(pcb->snd_nxt));
    243c:	6d00      	ldr	r0, [r0, #80]	; 0x50
    243e:	4798      	blx	r3
    2440:	4b14      	ldr	r3, [pc, #80]	; (2494 <tcp_send_empty_ack+0x60>)
    2442:	4602      	mov	r2, r0
    2444:	2100      	movs	r1, #0
    2446:	4620      	mov	r0, r4
    2448:	4798      	blx	r3
	if (p == NULL) {
    244a:	4605      	mov	r5, r0
    244c:	b1e8      	cbz	r0, 248a <tcp_send_empty_ack+0x56>
		return ERR_BUF;
	}
	tcphdr = (struct tcp_hdr *)p->payload;
	LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_output: sending ACK for %" U32_F "\n", pcb->rcv_nxt));
	/* remove ACK flags from the PCB, as we send an empty ACK now */
	pcb->flags &= ~(TF_ACK_DELAY | TF_ACK_NOW);
    244e:	7fa3      	ldrb	r3, [r4, #30]
	tcphdr = (struct tcp_hdr *)p->payload;
    2450:	6846      	ldr	r6, [r0, #4]
		tcp_build_timestamp_option(pcb, (u32_t *)(tcphdr + 1));
	}
#endif

#if CHECKSUM_GEN_TCP
	tcphdr->chksum = inet_chksum_pseudo(p, &(pcb->local_ip), &(pcb->remote_ip), IP_PROTO_TCP, p->tot_len);
    2452:	4f11      	ldr	r7, [pc, #68]	; (2498 <tcp_send_empty_ack+0x64>)
	pcb->flags &= ~(TF_ACK_DELAY | TF_ACK_NOW);
    2454:	f023 0303 	bic.w	r3, r3, #3
    2458:	77a3      	strb	r3, [r4, #30]
	tcphdr->chksum = inet_chksum_pseudo(p, &(pcb->local_ip), &(pcb->remote_ip), IP_PROTO_TCP, p->tot_len);
    245a:	8903      	ldrh	r3, [r0, #8]
    245c:	9300      	str	r3, [sp, #0]
    245e:	1d22      	adds	r2, r4, #4
    2460:	4621      	mov	r1, r4
    2462:	2306      	movs	r3, #6
    2464:	9203      	str	r2, [sp, #12]
    2466:	47b8      	blx	r7
#endif
#if LWIP_NETIF_HWADDRHINT
	ip_output_hinted(p, &(pcb->local_ip), &(pcb->remote_ip), pcb->ttl, pcb->tos, IP_PROTO_TCP, &(pcb->addr_hint));
#else  /* LWIP_NETIF_HWADDRHINT*/
	ip_output(p, &(pcb->local_ip), &(pcb->remote_ip), pcb->ttl, pcb->tos, IP_PROTO_TCP);
    2468:	2306      	movs	r3, #6
	tcphdr->chksum = inet_chksum_pseudo(p, &(pcb->local_ip), &(pcb->remote_ip), IP_PROTO_TCP, p->tot_len);
    246a:	8230      	strh	r0, [r6, #16]
	ip_output(p, &(pcb->local_ip), &(pcb->remote_ip), pcb->ttl, pcb->tos, IP_PROTO_TCP);
    246c:	9301      	str	r3, [sp, #4]
    246e:	7a63      	ldrb	r3, [r4, #9]
    2470:	9300      	str	r3, [sp, #0]
    2472:	7aa3      	ldrb	r3, [r4, #10]
    2474:	9a03      	ldr	r2, [sp, #12]
    2476:	4621      	mov	r1, r4
    2478:	4628      	mov	r0, r5
    247a:	4c08      	ldr	r4, [pc, #32]	; (249c <tcp_send_empty_ack+0x68>)
    247c:	47a0      	blx	r4
#endif /* LWIP_NETIF_HWADDRHINT*/
	pbuf_free(p);
    247e:	4b08      	ldr	r3, [pc, #32]	; (24a0 <tcp_send_empty_ack+0x6c>)
    2480:	4628      	mov	r0, r5
    2482:	4798      	blx	r3

	return ERR_OK;
    2484:	2000      	movs	r0, #0
}
    2486:	b005      	add	sp, #20
    2488:	bdf0      	pop	{r4, r5, r6, r7, pc}
		return ERR_BUF;
    248a:	f06f 0001 	mvn.w	r0, #1
    248e:	e7fa      	b.n	2486 <tcp_send_empty_ack+0x52>
    2490:	00000d71 	.word	0x00000d71
    2494:	00001f95 	.word	0x00001f95
    2498:	00008385 	.word	0x00008385
    249c:	000065f9 	.word	0x000065f9
    24a0:	000030e5 	.word	0x000030e5

000024a4 <tcp_output>:
 * @param pcb Protocol control block for the TCP connection to send data
 * @return ERR_OK if data has been sent or nothing to send
 *         another err_t on error
 */
err_t tcp_output(struct tcp_pcb *pcb)
{
    24a4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}

	/* First, check if we are invoked by the TCP input processing
	   code. If so, we do not output anything. Instead, we rely on the
	   input processing code to call us when input processing is done
	   with. */
	if (tcp_input_pcb == pcb) {
    24a8:	4b93      	ldr	r3, [pc, #588]	; (26f8 <tcp_output+0x254>)
    24aa:	681b      	ldr	r3, [r3, #0]
    24ac:	4283      	cmp	r3, r0
{
    24ae:	b085      	sub	sp, #20
    24b0:	4604      	mov	r4, r0
	if (tcp_input_pcb == pcb) {
    24b2:	d048      	beq.n	2546 <tcp_output+0xa2>
		return ERR_OK;
	}

	wnd = LWIP_MIN(pcb->snd_wnd, pcb->cwnd);
    24b4:	f8b0 3060 	ldrh.w	r3, [r0, #96]	; 0x60
    24b8:	f8b0 804c 	ldrh.w	r8, [r0, #76]	; 0x4c

	seg = pcb->unsent;
    24bc:	6ec5      	ldr	r5, [r0, #108]	; 0x6c
	wnd = LWIP_MIN(pcb->snd_wnd, pcb->cwnd);
    24be:	4598      	cmp	r8, r3
    24c0:	bf28      	it	cs
    24c2:	4698      	movcs	r8, r3
	 * because the ->unsent queue is empty or because the window does
	 * not allow it), construct an empty ACK segment and send it.
	 *
	 * If data is to be sent, we will just piggyback the ACK (see below).
	 */
	if (pcb->flags & TF_ACK_NOW && (seg == NULL || ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len > wnd)) {
    24c4:	7f83      	ldrb	r3, [r0, #30]
    24c6:	079a      	lsls	r2, r3, #30
    24c8:	d510      	bpl.n	24ec <tcp_output+0x48>
    24ca:	b92d      	cbnz	r5, 24d8 <tcp_output+0x34>
		return tcp_send_empty_ack(pcb);
    24cc:	4b8b      	ldr	r3, [pc, #556]	; (26fc <tcp_output+0x258>)
    24ce:	4620      	mov	r0, r4
	}
#endif /* TCP_OVERSIZE */

	pcb->flags &= ~TF_NAGLEMEMERR;
	return ERR_OK;
}
    24d0:	b005      	add	sp, #20
    24d2:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
		return tcp_send_empty_ack(pcb);
    24d6:	4718      	bx	r3
	if (pcb->flags & TF_ACK_NOW && (seg == NULL || ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len > wnd)) {
    24d8:	68eb      	ldr	r3, [r5, #12]
    24da:	6858      	ldr	r0, [r3, #4]
    24dc:	4b88      	ldr	r3, [pc, #544]	; (2700 <tcp_output+0x25c>)
    24de:	4798      	blx	r3
    24e0:	892b      	ldrh	r3, [r5, #8]
    24e2:	6ca2      	ldr	r2, [r4, #72]	; 0x48
    24e4:	1a9b      	subs	r3, r3, r2
    24e6:	4418      	add	r0, r3
    24e8:	4540      	cmp	r0, r8
    24ea:	d8ef      	bhi.n	24cc <tcp_output+0x28>
	useg = pcb->unacked;
    24ec:	6f27      	ldr	r7, [r4, #112]	; 0x70
	if (useg != NULL) {
    24ee:	bb7f      	cbnz	r7, 2550 <tcp_output+0xac>
	while (seg != NULL && ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len <= wnd) {
    24f0:	4e83      	ldr	r6, [pc, #524]	; (2700 <tcp_output+0x25c>)
    24f2:	b305      	cbz	r5, 2536 <tcp_output+0x92>
    24f4:	68eb      	ldr	r3, [r5, #12]
    24f6:	6858      	ldr	r0, [r3, #4]
    24f8:	47b0      	blx	r6
    24fa:	892b      	ldrh	r3, [r5, #8]
    24fc:	6ca2      	ldr	r2, [r4, #72]	; 0x48
    24fe:	1a9b      	subs	r3, r3, r2
    2500:	4418      	add	r0, r3
    2502:	4540      	cmp	r0, r8
    2504:	d817      	bhi.n	2536 <tcp_output+0x92>
		if ((tcp_do_output_nagle(pcb) == 0) && ((pcb->flags & (TF_NAGLEMEMERR | TF_FIN)) == 0)) {
    2506:	6f23      	ldr	r3, [r4, #112]	; 0x70
    2508:	b333      	cbz	r3, 2558 <tcp_output+0xb4>
    250a:	7fa2      	ldrb	r2, [r4, #30]
    250c:	f012 0f44 	tst.w	r2, #68	; 0x44
    2510:	d122      	bne.n	2558 <tcp_output+0xb4>
    2512:	6ee3      	ldr	r3, [r4, #108]	; 0x6c
    2514:	b12b      	cbz	r3, 2522 <tcp_output+0x7e>
    2516:	6819      	ldr	r1, [r3, #0]
    2518:	b9f1      	cbnz	r1, 2558 <tcp_output+0xb4>
    251a:	8919      	ldrh	r1, [r3, #8]
    251c:	8ee3      	ldrh	r3, [r4, #54]	; 0x36
    251e:	4299      	cmp	r1, r3
    2520:	d21a      	bcs.n	2558 <tcp_output+0xb4>
    2522:	f8b4 3066 	ldrh.w	r3, [r4, #102]	; 0x66
    2526:	b1bb      	cbz	r3, 2558 <tcp_output+0xb4>
    2528:	f8b4 3068 	ldrh.w	r3, [r4, #104]	; 0x68
    252c:	2b07      	cmp	r3, #7
    252e:	d813      	bhi.n	2558 <tcp_output+0xb4>
    2530:	f012 0fa0 	tst.w	r2, #160	; 0xa0
    2534:	d110      	bne.n	2558 <tcp_output+0xb4>
	if (pcb->unsent == NULL) {
    2536:	6ee3      	ldr	r3, [r4, #108]	; 0x6c
    2538:	b90b      	cbnz	r3, 253e <tcp_output+0x9a>
		pcb->unsent_oversize = 0;
    253a:	f8a4 306a 	strh.w	r3, [r4, #106]	; 0x6a
	pcb->flags &= ~TF_NAGLEMEMERR;
    253e:	7fa3      	ldrb	r3, [r4, #30]
    2540:	f003 037f 	and.w	r3, r3, #127	; 0x7f
    2544:	77a3      	strb	r3, [r4, #30]
}
    2546:	2000      	movs	r0, #0
    2548:	b005      	add	sp, #20
    254a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    254e:	461f      	mov	r7, r3
		for (; useg->next != NULL; useg = useg->next)
    2550:	683b      	ldr	r3, [r7, #0]
    2552:	2b00      	cmp	r3, #0
    2554:	d1fb      	bne.n	254e <tcp_output+0xaa>
    2556:	e7cb      	b.n	24f0 <tcp_output+0x4c>
		pcb->unsent = seg->next;
    2558:	682b      	ldr	r3, [r5, #0]
    255a:	66e3      	str	r3, [r4, #108]	; 0x6c
		if (pcb->state != SYN_SENT) {
    255c:	7e23      	ldrb	r3, [r4, #24]
    255e:	2b02      	cmp	r3, #2
    2560:	d00d      	beq.n	257e <tcp_output+0xda>
			TCPH_SET_FLAG(seg->tcphdr, TCP_ACK);
    2562:	68eb      	ldr	r3, [r5, #12]
    2564:	2010      	movs	r0, #16
    2566:	f8b3 a00c 	ldrh.w	sl, [r3, #12]
    256a:	4b66      	ldr	r3, [pc, #408]	; (2704 <tcp_output+0x260>)
    256c:	4798      	blx	r3
    256e:	68eb      	ldr	r3, [r5, #12]
    2570:	ea4a 0000 	orr.w	r0, sl, r0
    2574:	8198      	strh	r0, [r3, #12]
			pcb->flags &= ~(TF_ACK_DELAY | TF_ACK_NOW);
    2576:	7fa3      	ldrb	r3, [r4, #30]
    2578:	f023 0303 	bic.w	r3, r3, #3
    257c:	77a3      	strb	r3, [r4, #30]
	/** @bug Exclude retransmitted segments from this count. */
	snmp_inc_tcpoutsegs();

	/* The TCP header has already been constructed, but the ackno and
	 wnd fields remain. */
	seg->tcphdr->ackno = htonl(pcb->rcv_nxt);
    257e:	6aa0      	ldr	r0, [r4, #40]	; 0x28
    2580:	f8df a194 	ldr.w	sl, [pc, #404]	; 2718 <tcp_output+0x274>
    2584:	f8d5 b00c 	ldr.w	fp, [r5, #12]
    2588:	47d0      	blx	sl

	/* advertise our receive window size in this TCP segment */
	seg->tcphdr->wnd = htons(pcb->rcv_ann_wnd);
    258a:	4b5e      	ldr	r3, [pc, #376]	; (2704 <tcp_output+0x260>)
	seg->tcphdr->ackno = htonl(pcb->rcv_nxt);
    258c:	f8cb 0008 	str.w	r0, [fp, #8]
	seg->tcphdr->wnd = htons(pcb->rcv_ann_wnd);
    2590:	8de0      	ldrh	r0, [r4, #46]	; 0x2e
    2592:	f8d5 b00c 	ldr.w	fp, [r5, #12]
    2596:	4798      	blx	r3

	pcb->rcv_ann_right_edge = pcb->rcv_nxt + pcb->rcv_ann_wnd;
    2598:	8de2      	ldrh	r2, [r4, #46]	; 0x2e
    259a:	6aa3      	ldr	r3, [r4, #40]	; 0x28
	seg->tcphdr->wnd = htons(pcb->rcv_ann_wnd);
    259c:	f8ab 000e 	strh.w	r0, [fp, #14]
	pcb->rcv_ann_right_edge = pcb->rcv_nxt + pcb->rcv_ann_wnd;
    25a0:	4413      	add	r3, r2
    25a2:	6323      	str	r3, [r4, #48]	; 0x30

	/* Add any requested options.  NB MSS option is only set on SYN
	   packets, so ignore it here */
	opts = (u32_t *)(void *)(seg->tcphdr + 1);
	if (seg->flags & TF_SEG_OPTS_MSS) {
    25a4:	7aab      	ldrb	r3, [r5, #10]
    25a6:	07db      	lsls	r3, r3, #31
		u16_t mss;
#if TCP_CALCULATE_EFF_SEND_MSS
		mss = tcp_eff_send_mss(TCP_MSS, &pcb->remote_ip);
    25a8:	f104 0904 	add.w	r9, r4, #4
	if (seg->flags & TF_SEG_OPTS_MSS) {
    25ac:	d50b      	bpl.n	25c6 <tcp_output+0x122>
		mss = tcp_eff_send_mss(TCP_MSS, &pcb->remote_ip);
    25ae:	4b56      	ldr	r3, [pc, #344]	; (2708 <tcp_output+0x264>)
	opts = (u32_t *)(void *)(seg->tcphdr + 1);
    25b0:	f8d5 b00c 	ldr.w	fp, [r5, #12]
		mss = tcp_eff_send_mss(TCP_MSS, &pcb->remote_ip);
    25b4:	4649      	mov	r1, r9
    25b6:	f240 50b4 	movw	r0, #1460	; 0x5b4
    25ba:	4798      	blx	r3
#else  /* TCP_CALCULATE_EFF_SEND_MSS */
		mss = TCP_MSS;
#endif /* TCP_CALCULATE_EFF_SEND_MSS */
		*opts = TCP_BUILD_MSS_OPTION(mss);
    25bc:	f040 7001 	orr.w	r0, r0, #33816576	; 0x2040000
    25c0:	47d0      	blx	sl
    25c2:	f8cb 0014 	str.w	r0, [fp, #20]
	}
#endif

	/* Set retransmission timer running if it is not currently enabled
	   This must be set before checking the route. */
	if (pcb->rtime == -1) {
    25c6:	f9b4 3034 	ldrsh.w	r3, [r4, #52]	; 0x34
    25ca:	3301      	adds	r3, #1
		pcb->rtime = 0;
    25cc:	bf04      	itt	eq
    25ce:	2300      	moveq	r3, #0
    25d0:	86a3      	strheq	r3, [r4, #52]	; 0x34
	}

	/* If we don't have a local IP address, we get one by
	   calling ip_route(). */
	if (ip_addr_isany(&(pcb->local_ip))) {
    25d2:	6823      	ldr	r3, [r4, #0]
    25d4:	b933      	cbnz	r3, 25e4 <tcp_output+0x140>
		netif = ip_route(&(pcb->remote_ip));
    25d6:	4b4d      	ldr	r3, [pc, #308]	; (270c <tcp_output+0x268>)
    25d8:	4648      	mov	r0, r9
    25da:	4798      	blx	r3
		if (netif == NULL) {
    25dc:	2800      	cmp	r0, #0
    25de:	d033      	beq.n	2648 <tcp_output+0x1a4>
			return;
		}
		ip_addr_copy(pcb->local_ip, netif->ip_addr);
    25e0:	6843      	ldr	r3, [r0, #4]
    25e2:	6023      	str	r3, [r4, #0]
	}

	if (pcb->rttest == 0) {
    25e4:	6ba3      	ldr	r3, [r4, #56]	; 0x38
    25e6:	b933      	cbnz	r3, 25f6 <tcp_output+0x152>
		pcb->rttest = tcp_ticks;
    25e8:	4949      	ldr	r1, [pc, #292]	; (2710 <tcp_output+0x26c>)
		pcb->rtseq  = ntohl(seg->tcphdr->seqno);
    25ea:	68eb      	ldr	r3, [r5, #12]
		pcb->rttest = tcp_ticks;
    25ec:	6809      	ldr	r1, [r1, #0]
    25ee:	63a1      	str	r1, [r4, #56]	; 0x38
		pcb->rtseq  = ntohl(seg->tcphdr->seqno);
    25f0:	6858      	ldr	r0, [r3, #4]
    25f2:	47b0      	blx	r6
    25f4:	63e0      	str	r0, [r4, #60]	; 0x3c
	LWIP_DEBUGF(TCP_OUTPUT_DEBUG,
	            ("tcp_output_segment: %" U32_F ":%" U32_F "\n",
	             htonl(seg->tcphdr->seqno),
	             htonl(seg->tcphdr->seqno) + seg->len));

	len = (u16_t)((u8_t *)seg->tcphdr - (u8_t *)seg->p->payload);
    25f6:	6868      	ldr	r0, [r5, #4]
    25f8:	f8d5 a00c 	ldr.w	sl, [r5, #12]
    25fc:	6843      	ldr	r3, [r0, #4]
		}
#endif /* TCP_CHECKSUM_ON_COPY_SANITY_CHECK */
	}
#else  /* TCP_CHECKSUM_ON_COPY */
	seg->tcphdr->chksum
	    = inet_chksum_pseudo(seg->p, &(pcb->local_ip), &(pcb->remote_ip), IP_PROTO_TCP, seg->p->tot_len);
    25fe:	f8df b11c 	ldr.w	fp, [pc, #284]	; 271c <tcp_output+0x278>
	seg->p->payload = seg->tcphdr;
    2602:	f8c0 a004 	str.w	sl, [r0, #4]
	len = (u16_t)((u8_t *)seg->tcphdr - (u8_t *)seg->p->payload);
    2606:	ebaa 0303 	sub.w	r3, sl, r3
    260a:	b299      	uxth	r1, r3
	seg->p->len -= len;
    260c:	8943      	ldrh	r3, [r0, #10]
    260e:	1a5b      	subs	r3, r3, r1
    2610:	8143      	strh	r3, [r0, #10]
	seg->p->tot_len -= len;
    2612:	8903      	ldrh	r3, [r0, #8]
    2614:	1a5b      	subs	r3, r3, r1
    2616:	b29b      	uxth	r3, r3
	seg->tcphdr->chksum = 0;
    2618:	2100      	movs	r1, #0
	seg->p->tot_len -= len;
    261a:	8103      	strh	r3, [r0, #8]
	    = inet_chksum_pseudo(seg->p, &(pcb->local_ip), &(pcb->remote_ip), IP_PROTO_TCP, seg->p->tot_len);
    261c:	464a      	mov	r2, r9
	seg->tcphdr->chksum = 0;
    261e:	f88a 1010 	strb.w	r1, [sl, #16]
    2622:	f88a 1011 	strb.w	r1, [sl, #17]
	    = inet_chksum_pseudo(seg->p, &(pcb->local_ip), &(pcb->remote_ip), IP_PROTO_TCP, seg->p->tot_len);
    2626:	9300      	str	r3, [sp, #0]
    2628:	4621      	mov	r1, r4
    262a:	2306      	movs	r3, #6
    262c:	47d8      	blx	fp
	TCP_STATS_INC(tcp.xmit);

#if LWIP_NETIF_HWADDRHINT
	ip_output_hinted(seg->p, &(pcb->local_ip), &(pcb->remote_ip), pcb->ttl, pcb->tos, IP_PROTO_TCP, &(pcb->addr_hint));
#else  /* LWIP_NETIF_HWADDRHINT*/
	ip_output(seg->p, &(pcb->local_ip), &(pcb->remote_ip), pcb->ttl, pcb->tos, IP_PROTO_TCP);
    262e:	2306      	movs	r3, #6
	    = inet_chksum_pseudo(seg->p, &(pcb->local_ip), &(pcb->remote_ip), IP_PROTO_TCP, seg->p->tot_len);
    2630:	f8aa 0010 	strh.w	r0, [sl, #16]
	ip_output(seg->p, &(pcb->local_ip), &(pcb->remote_ip), pcb->ttl, pcb->tos, IP_PROTO_TCP);
    2634:	9301      	str	r3, [sp, #4]
    2636:	7a63      	ldrb	r3, [r4, #9]
    2638:	9300      	str	r3, [sp, #0]
    263a:	6868      	ldr	r0, [r5, #4]
    263c:	7aa3      	ldrb	r3, [r4, #10]
    263e:	f8df a0e0 	ldr.w	sl, [pc, #224]	; 2720 <tcp_output+0x27c>
    2642:	464a      	mov	r2, r9
    2644:	4621      	mov	r1, r4
    2646:	47d0      	blx	sl
		snd_nxt = ntohl(seg->tcphdr->seqno) + TCP_TCPLEN(seg);
    2648:	68eb      	ldr	r3, [r5, #12]
    264a:	f8df a0d8 	ldr.w	sl, [pc, #216]	; 2724 <tcp_output+0x280>
    264e:	6858      	ldr	r0, [r3, #4]
    2650:	47b0      	blx	r6
    2652:	892a      	ldrh	r2, [r5, #8]
    2654:	68eb      	ldr	r3, [r5, #12]
    2656:	9203      	str	r2, [sp, #12]
    2658:	4683      	mov	fp, r0
    265a:	8998      	ldrh	r0, [r3, #12]
    265c:	47d0      	blx	sl
    265e:	9a03      	ldr	r2, [sp, #12]
    2660:	f010 0303 	ands.w	r3, r0, #3
    2664:	bf18      	it	ne
    2666:	2301      	movne	r3, #1
    2668:	441a      	add	r2, r3
    266a:	eb02 030b 	add.w	r3, r2, fp
		if (TCP_SEQ_LT(pcb->snd_nxt, snd_nxt)) {
    266e:	6d22      	ldr	r2, [r4, #80]	; 0x50
    2670:	1ad2      	subs	r2, r2, r3
    2672:	2a00      	cmp	r2, #0
			pcb->snd_nxt = snd_nxt;
    2674:	bfb8      	it	lt
    2676:	6523      	strlt	r3, [r4, #80]	; 0x50
		if (TCP_TCPLEN(seg) > 0) {
    2678:	68eb      	ldr	r3, [r5, #12]
    267a:	4652      	mov	r2, sl
    267c:	8998      	ldrh	r0, [r3, #12]
    267e:	f8b5 a008 	ldrh.w	sl, [r5, #8]
    2682:	4790      	blx	r2
    2684:	f010 0003 	ands.w	r0, r0, #3
    2688:	bf18      	it	ne
    268a:	2001      	movne	r0, #1
    268c:	eb10 0f0a 	cmn.w	r0, sl
    2690:	d02d      	beq.n	26ee <tcp_output+0x24a>
			seg->next = NULL;
    2692:	2300      	movs	r3, #0
    2694:	602b      	str	r3, [r5, #0]
			if (pcb->unacked == NULL) {
    2696:	6f23      	ldr	r3, [r4, #112]	; 0x70
    2698:	b913      	cbnz	r3, 26a0 <tcp_output+0x1fc>
				pcb->unacked = seg;
    269a:	6725      	str	r5, [r4, #112]	; 0x70
					useg->next = seg;
    269c:	462f      	mov	r7, r5
    269e:	e014      	b.n	26ca <tcp_output+0x226>
				if (TCP_SEQ_LT(ntohl(seg->tcphdr->seqno), ntohl(useg->tcphdr->seqno))) {
    26a0:	68eb      	ldr	r3, [r5, #12]
    26a2:	6858      	ldr	r0, [r3, #4]
    26a4:	47b0      	blx	r6
    26a6:	68fb      	ldr	r3, [r7, #12]
    26a8:	4682      	mov	sl, r0
    26aa:	6858      	ldr	r0, [r3, #4]
    26ac:	47b0      	blx	r6
    26ae:	ebaa 0000 	sub.w	r0, sl, r0
    26b2:	2800      	cmp	r0, #0
    26b4:	da19      	bge.n	26ea <tcp_output+0x246>
					struct tcp_seg **cur_seg = &(pcb->unacked);
    26b6:	f104 0a70 	add.w	sl, r4, #112	; 0x70
					while (*cur_seg && TCP_SEQ_LT(ntohl((*cur_seg)->tcphdr->seqno), ntohl(seg->tcphdr->seqno))) {
    26ba:	f8da 3000 	ldr.w	r3, [sl]
    26be:	b933      	cbnz	r3, 26ce <tcp_output+0x22a>
					seg->next  = (*cur_seg);
    26c0:	f8da 3000 	ldr.w	r3, [sl]
    26c4:	602b      	str	r3, [r5, #0]
					(*cur_seg) = seg;
    26c6:	f8ca 5000 	str.w	r5, [sl]
		seg = pcb->unsent;
    26ca:	6ee5      	ldr	r5, [r4, #108]	; 0x6c
    26cc:	e711      	b.n	24f2 <tcp_output+0x4e>
					while (*cur_seg && TCP_SEQ_LT(ntohl((*cur_seg)->tcphdr->seqno), ntohl(seg->tcphdr->seqno))) {
    26ce:	68db      	ldr	r3, [r3, #12]
    26d0:	6858      	ldr	r0, [r3, #4]
    26d2:	47b0      	blx	r6
    26d4:	68eb      	ldr	r3, [r5, #12]
    26d6:	4683      	mov	fp, r0
    26d8:	6858      	ldr	r0, [r3, #4]
    26da:	47b0      	blx	r6
    26dc:	ebab 0000 	sub.w	r0, fp, r0
    26e0:	2800      	cmp	r0, #0
    26e2:	daed      	bge.n	26c0 <tcp_output+0x21c>
						cur_seg = &((*cur_seg)->next);
    26e4:	f8da a000 	ldr.w	sl, [sl]
    26e8:	e7e7      	b.n	26ba <tcp_output+0x216>
					useg->next = seg;
    26ea:	603d      	str	r5, [r7, #0]
    26ec:	e7d6      	b.n	269c <tcp_output+0x1f8>
			tcp_seg_free(seg);
    26ee:	4b09      	ldr	r3, [pc, #36]	; (2714 <tcp_output+0x270>)
    26f0:	4628      	mov	r0, r5
    26f2:	4798      	blx	r3
    26f4:	e7e9      	b.n	26ca <tcp_output+0x226>
    26f6:	bf00      	nop
    26f8:	2000a50c 	.word	0x2000a50c
    26fc:	00002435 	.word	0x00002435
    2700:	00000d75 	.word	0x00000d75
    2704:	00000d65 	.word	0x00000d65
    2708:	0000739d 	.word	0x0000739d
    270c:	00006359 	.word	0x00006359
    2710:	20014948 	.word	0x20014948
    2714:	00006ac1 	.word	0x00006ac1
    2718:	00000d71 	.word	0x00000d71
    271c:	00008385 	.word	0x00008385
    2720:	000065f9 	.word	0x000065f9
    2724:	00000d6b 	.word	0x00000d6b

00002728 <tcp_rst>:
 * @param remote_ip the remote IP address to send the segment to
 * @param local_port the local TCP port to send the segment from
 * @param remote_port the remote TCP port to send the segment to
 */
void tcp_rst(u32_t seqno, u32_t ackno, ip_addr_t *local_ip, ip_addr_t *remote_ip, u16_t local_port, u16_t remote_port)
{
    2728:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    272c:	4682      	mov	sl, r0
    272e:	4689      	mov	r9, r1
    2730:	4617      	mov	r7, r2
    2732:	4698      	mov	r8, r3
	struct pbuf *   p;
	struct tcp_hdr *tcphdr;
	p = pbuf_alloc(PBUF_IP, TCP_HLEN, PBUF_RAM);
    2734:	2200      	movs	r2, #0
    2736:	4b22      	ldr	r3, [pc, #136]	; (27c0 <tcp_rst+0x98>)
{
    2738:	f8bd 6030 	ldrh.w	r6, [sp, #48]	; 0x30
    273c:	f8bd b034 	ldrh.w	fp, [sp, #52]	; 0x34
	p = pbuf_alloc(PBUF_IP, TCP_HLEN, PBUF_RAM);
    2740:	2114      	movs	r1, #20
    2742:	2001      	movs	r0, #1
    2744:	4798      	blx	r3
	if (p == NULL) {
    2746:	4605      	mov	r5, r0
    2748:	2800      	cmp	r0, #0
    274a:	d036      	beq.n	27ba <tcp_rst+0x92>
		LWIP_DEBUGF(TCP_DEBUG, ("tcp_rst: could not allocate memory for pbuf\n"));
		return;
	}
	LWIP_ASSERT("check that first pbuf can hold struct tcp_hdr", (p->len >= sizeof(struct tcp_hdr)));

	tcphdr        = (struct tcp_hdr *)p->payload;
    274c:	6844      	ldr	r4, [r0, #4]
	tcphdr->src   = htons(local_port);
    274e:	4630      	mov	r0, r6
    2750:	4e1c      	ldr	r6, [pc, #112]	; (27c4 <tcp_rst+0x9c>)
    2752:	47b0      	blx	r6
    2754:	8020      	strh	r0, [r4, #0]
	tcphdr->dest  = htons(remote_port);
    2756:	4658      	mov	r0, fp
    2758:	47b0      	blx	r6
    275a:	8060      	strh	r0, [r4, #2]
	tcphdr->seqno = htonl(seqno);
    275c:	4650      	mov	r0, sl
    275e:	f8df a070 	ldr.w	sl, [pc, #112]	; 27d0 <tcp_rst+0xa8>
    2762:	47d0      	blx	sl
    2764:	6060      	str	r0, [r4, #4]
	tcphdr->ackno = htonl(ackno);
    2766:	4648      	mov	r0, r9
    2768:	47d0      	blx	sl
    276a:	60a0      	str	r0, [r4, #8]
	TCPH_HDRLEN_FLAGS_SET(tcphdr, TCP_HLEN / 4, TCP_RST | TCP_ACK);
    276c:	f245 0014 	movw	r0, #20500	; 0x5014
    2770:	47b0      	blx	r6
	tcphdr->wnd    = PP_HTONS(TCP_WND);
    2772:	2316      	movs	r3, #22
    2774:	73a3      	strb	r3, [r4, #14]
    2776:	f06f 032f 	mvn.w	r3, #47	; 0x2f
    277a:	2600      	movs	r6, #0
    277c:	73e3      	strb	r3, [r4, #15]
	tcphdr->chksum = 0;
	tcphdr->urgp   = 0;

#if CHECKSUM_GEN_TCP
	tcphdr->chksum = inet_chksum_pseudo(p, local_ip, remote_ip, IP_PROTO_TCP, p->tot_len);
    277e:	892b      	ldrh	r3, [r5, #8]
	TCPH_HDRLEN_FLAGS_SET(tcphdr, TCP_HLEN / 4, TCP_RST | TCP_ACK);
    2780:	81a0      	strh	r0, [r4, #12]
	tcphdr->chksum = 0;
    2782:	7426      	strb	r6, [r4, #16]
    2784:	7466      	strb	r6, [r4, #17]
	tcphdr->urgp   = 0;
    2786:	74a6      	strb	r6, [r4, #18]
    2788:	74e6      	strb	r6, [r4, #19]
	tcphdr->chksum = inet_chksum_pseudo(p, local_ip, remote_ip, IP_PROTO_TCP, p->tot_len);
    278a:	4642      	mov	r2, r8
    278c:	9300      	str	r3, [sp, #0]
    278e:	4639      	mov	r1, r7
    2790:	f8df 9040 	ldr.w	r9, [pc, #64]	; 27d4 <tcp_rst+0xac>
    2794:	2306      	movs	r3, #6
    2796:	4628      	mov	r0, r5
    2798:	47c8      	blx	r9
#endif
	TCP_STATS_INC(tcp.xmit);
	snmp_inc_tcpoutrsts();
	/* Send output with hardcoded TTL since we have no access to the pcb */
	ip_output(p, local_ip, remote_ip, TCP_TTL, 0, IP_PROTO_TCP);
    279a:	2306      	movs	r3, #6
	tcphdr->chksum = inet_chksum_pseudo(p, local_ip, remote_ip, IP_PROTO_TCP, p->tot_len);
    279c:	8220      	strh	r0, [r4, #16]
	ip_output(p, local_ip, remote_ip, TCP_TTL, 0, IP_PROTO_TCP);
    279e:	4642      	mov	r2, r8
    27a0:	e9cd 6300 	strd	r6, r3, [sp]
    27a4:	4c08      	ldr	r4, [pc, #32]	; (27c8 <tcp_rst+0xa0>)
    27a6:	23ff      	movs	r3, #255	; 0xff
    27a8:	4639      	mov	r1, r7
    27aa:	4628      	mov	r0, r5
    27ac:	47a0      	blx	r4
	pbuf_free(p);
    27ae:	4b07      	ldr	r3, [pc, #28]	; (27cc <tcp_rst+0xa4>)
    27b0:	4628      	mov	r0, r5
	LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_rst: seqno %" U32_F " ackno %" U32_F ".\n", seqno, ackno));
}
    27b2:	b003      	add	sp, #12
    27b4:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	pbuf_free(p);
    27b8:	4718      	bx	r3
}
    27ba:	b003      	add	sp, #12
    27bc:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    27c0:	0000313d 	.word	0x0000313d
    27c4:	00000d65 	.word	0x00000d65
    27c8:	000065f9 	.word	0x000065f9
    27cc:	000030e5 	.word	0x000030e5
    27d0:	00000d71 	.word	0x00000d71
    27d4:	00008385 	.word	0x00008385

000027d8 <tcp_rexmit_rto>:
 */
void tcp_rexmit_rto(struct tcp_pcb *pcb)
{
	struct tcp_seg *seg;

	if (pcb->unacked == NULL) {
    27d8:	6f02      	ldr	r2, [r0, #112]	; 0x70
{
    27da:	b410      	push	{r4}
	if (pcb->unacked == NULL) {
    27dc:	b192      	cbz	r2, 2804 <tcp_rexmit_rto+0x2c>
    27de:	4613      	mov	r3, r2
		return;
	}

	/* Move all unacked segments to the head of the unsent queue */
	for (seg = pcb->unacked; seg->next != NULL; seg = seg->next)
    27e0:	4619      	mov	r1, r3
    27e2:	681b      	ldr	r3, [r3, #0]
    27e4:	2b00      	cmp	r3, #0
    27e6:	d1fb      	bne.n	27e0 <tcp_rexmit_rto+0x8>
		;
	/* concatenate unsent queue after unacked queue */
	seg->next = pcb->unsent;
    27e8:	6ec4      	ldr	r4, [r0, #108]	; 0x6c
    27ea:	600c      	str	r4, [r1, #0]
	/* unsent queue is the concatenated queue (of unacked, unsent) */
	pcb->unsent = pcb->unacked;
	/* unacked queue is now empty */
	pcb->unacked = NULL;
    27ec:	e9c0 231b 	strd	r2, r3, [r0, #108]	; 0x6c
	/* last unsent hasn't changed, no need to reset unsent_oversize */

	/* increment number of retransmissions */
	++pcb->nrtx;
    27f0:	f890 2046 	ldrb.w	r2, [r0, #70]	; 0x46

	/* Don't take any RTT measurements after retransmitting. */
	pcb->rttest = 0;
    27f4:	6383      	str	r3, [r0, #56]	; 0x38
	++pcb->nrtx;
    27f6:	3201      	adds	r2, #1
    27f8:	f880 2046 	strb.w	r2, [r0, #70]	; 0x46

	/* Do the actual retransmission */
	tcp_output(pcb);
    27fc:	4b03      	ldr	r3, [pc, #12]	; (280c <tcp_rexmit_rto+0x34>)
}
    27fe:	f85d 4b04 	ldr.w	r4, [sp], #4
	tcp_output(pcb);
    2802:	4718      	bx	r3
}
    2804:	f85d 4b04 	ldr.w	r4, [sp], #4
    2808:	4770      	bx	lr
    280a:	bf00      	nop
    280c:	000024a5 	.word	0x000024a5

00002810 <tcp_rexmit>:
 * Called by tcp_receive() for fast retramsmit.
 *
 * @param pcb the tcp_pcb for which to retransmit the first unacked segment
 */
void tcp_rexmit(struct tcp_pcb *pcb)
{
    2810:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	struct tcp_seg * seg;
	struct tcp_seg **cur_seg;

	if (pcb->unacked == NULL) {
    2814:	6f05      	ldr	r5, [r0, #112]	; 0x70
{
    2816:	4604      	mov	r4, r0
	if (pcb->unacked == NULL) {
    2818:	b1ad      	cbz	r5, 2846 <tcp_rexmit+0x36>
	}

	/* Move the first unacked segment to the unsent queue */
	/* Keep the unsent queue sorted. */
	seg          = pcb->unacked;
	pcb->unacked = seg->next;
    281a:	682b      	ldr	r3, [r5, #0]

	cur_seg = &(pcb->unsent);
	while (*cur_seg && TCP_SEQ_LT(ntohl((*cur_seg)->tcphdr->seqno), ntohl(seg->tcphdr->seqno))) {
    281c:	f8df 8044 	ldr.w	r8, [pc, #68]	; 2864 <tcp_rexmit+0x54>
	pcb->unacked = seg->next;
    2820:	6703      	str	r3, [r0, #112]	; 0x70
	cur_seg = &(pcb->unsent);
    2822:	f100 066c 	add.w	r6, r0, #108	; 0x6c
	while (*cur_seg && TCP_SEQ_LT(ntohl((*cur_seg)->tcphdr->seqno), ntohl(seg->tcphdr->seqno))) {
    2826:	6833      	ldr	r3, [r6, #0]
    2828:	b97b      	cbnz	r3, 284a <tcp_rexmit+0x3a>
		cur_seg = &((*cur_seg)->next);
	}
	seg->next = *cur_seg;
    282a:	6833      	ldr	r3, [r6, #0]
    282c:	602b      	str	r3, [r5, #0]
	*cur_seg  = seg;
    282e:	6035      	str	r5, [r6, #0]
#if TCP_OVERSIZE
	if (seg->next == NULL) {
    2830:	682b      	ldr	r3, [r5, #0]
    2832:	b90b      	cbnz	r3, 2838 <tcp_rexmit+0x28>
		/* the retransmitted segment is last in unsent, so reset unsent_oversize */
		pcb->unsent_oversize = 0;
    2834:	f8a4 306a 	strh.w	r3, [r4, #106]	; 0x6a
	}
#endif /* TCP_OVERSIZE */

	++pcb->nrtx;
    2838:	f894 3046 	ldrb.w	r3, [r4, #70]	; 0x46
    283c:	3301      	adds	r3, #1
    283e:	f884 3046 	strb.w	r3, [r4, #70]	; 0x46

	/* Don't take any rtt measurements after retransmitting. */
	pcb->rttest = 0;
    2842:	2300      	movs	r3, #0
    2844:	63a3      	str	r3, [r4, #56]	; 0x38

	/* Do the actual retransmission. */
	snmp_inc_tcpretranssegs();
	/* No need to call tcp_output: we are always called from tcp_input()
	   and thus tcp_output directly returns. */
}
    2846:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	while (*cur_seg && TCP_SEQ_LT(ntohl((*cur_seg)->tcphdr->seqno), ntohl(seg->tcphdr->seqno))) {
    284a:	68db      	ldr	r3, [r3, #12]
    284c:	6858      	ldr	r0, [r3, #4]
    284e:	47c0      	blx	r8
    2850:	68eb      	ldr	r3, [r5, #12]
    2852:	4607      	mov	r7, r0
    2854:	6858      	ldr	r0, [r3, #4]
    2856:	47c0      	blx	r8
    2858:	1a38      	subs	r0, r7, r0
    285a:	2800      	cmp	r0, #0
    285c:	dae5      	bge.n	282a <tcp_rexmit+0x1a>
		cur_seg = &((*cur_seg)->next);
    285e:	6836      	ldr	r6, [r6, #0]
    2860:	e7e1      	b.n	2826 <tcp_rexmit+0x16>
    2862:	bf00      	nop
    2864:	00000d75 	.word	0x00000d75

00002868 <tcp_rexmit_fast>:
 *
 * @param pcb the tcp_pcb for which to retransmit the first unacked segment
 */
void tcp_rexmit_fast(struct tcp_pcb *pcb)
{
	if (pcb->unacked != NULL && !(pcb->flags & TF_INFR)) {
    2868:	6f03      	ldr	r3, [r0, #112]	; 0x70
{
    286a:	b510      	push	{r4, lr}
    286c:	4604      	mov	r4, r0
	if (pcb->unacked != NULL && !(pcb->flags & TF_INFR)) {
    286e:	b30b      	cbz	r3, 28b4 <tcp_rexmit_fast+0x4c>
    2870:	7f83      	ldrb	r3, [r0, #30]
    2872:	075b      	lsls	r3, r3, #29
    2874:	d41e      	bmi.n	28b4 <tcp_rexmit_fast+0x4c>
		LWIP_DEBUGF(TCP_FR_DEBUG,
		            ("tcp_receive: dupacks %" U16_F " (%" U32_F "), fast retransmit %" U32_F "\n",
		             (u16_t)pcb->dupacks,
		             pcb->lastack,
		             ntohl(pcb->unacked->tcphdr->seqno)));
		tcp_rexmit(pcb);
    2876:	4b10      	ldr	r3, [pc, #64]	; (28b8 <tcp_rexmit_fast+0x50>)
    2878:	4798      	blx	r3

		/* Set ssthresh to half of the minimum of the current
		 * cwnd and the advertised window */
		if (pcb->cwnd > pcb->snd_wnd) {
    287a:	f8b4 204c 	ldrh.w	r2, [r4, #76]	; 0x4c
    287e:	f8b4 3060 	ldrh.w	r3, [r4, #96]	; 0x60
    2882:	429a      	cmp	r2, r3
			pcb->ssthresh = pcb->snd_wnd / 2;
    2884:	bf88      	it	hi
    2886:	085a      	lsrhi	r2, r3, #1
		} else {
			pcb->ssthresh = pcb->cwnd / 2;
		}

		/* The minimum value for ssthresh should be 2 MSS */
		if (pcb->ssthresh < 2 * pcb->mss) {
    2888:	8ee3      	ldrh	r3, [r4, #54]	; 0x36
			pcb->ssthresh = pcb->cwnd / 2;
    288a:	bf98      	it	ls
    288c:	0852      	lsrls	r2, r2, #1
		if (pcb->ssthresh < 2 * pcb->mss) {
    288e:	ebb2 0f43 	cmp.w	r2, r3, lsl #1
    2892:	ea4f 0143 	mov.w	r1, r3, lsl #1
    2896:	f8a4 204e 	strh.w	r2, [r4, #78]	; 0x4e
			LWIP_DEBUGF(TCP_FR_DEBUG,
			            ("tcp_receive: The minimum value for ssthresh %" U16_F " should be min 2 mss %" U16_F "...\n",
			             pcb->ssthresh,
			             2 * pcb->mss));
			pcb->ssthresh = 2 * pcb->mss;
    289a:	bfb8      	it	lt
    289c:	f8a4 104e 	strhlt.w	r1, [r4, #78]	; 0x4e
		}

		pcb->cwnd = pcb->ssthresh + 3 * pcb->mss;
    28a0:	f8b4 204e 	ldrh.w	r2, [r4, #78]	; 0x4e
    28a4:	440b      	add	r3, r1
    28a6:	4413      	add	r3, r2
    28a8:	f8a4 304c 	strh.w	r3, [r4, #76]	; 0x4c
		pcb->flags |= TF_INFR;
    28ac:	7fa3      	ldrb	r3, [r4, #30]
    28ae:	f043 0304 	orr.w	r3, r3, #4
    28b2:	77a3      	strb	r3, [r4, #30]
	}
}
    28b4:	bd10      	pop	{r4, pc}
    28b6:	bf00      	nop
    28b8:	00002811 	.word	0x00002811

000028bc <tcp_keepalive>:
 * Called by tcp_slowtmr()
 *
 * @param pcb the tcp_pcb for which to send a keepalive packet
 */
void tcp_keepalive(struct tcp_pcb *pcb)
{
    28bc:	b5f0      	push	{r4, r5, r6, r7, lr}
    28be:	4604      	mov	r4, r0
	            ("tcp_keepalive: tcp_ticks %" U32_F "   pcb->tmr %" U32_F " pcb->keep_cnt_sent %" U16_F "\n",
	             tcp_ticks,
	             pcb->tmr,
	             pcb->keep_cnt_sent));

	p = tcp_output_alloc_header(pcb, 0, 0, htonl(pcb->snd_nxt - 1));
    28c0:	6d00      	ldr	r0, [r0, #80]	; 0x50
    28c2:	4b13      	ldr	r3, [pc, #76]	; (2910 <tcp_keepalive+0x54>)
{
    28c4:	b085      	sub	sp, #20
	p = tcp_output_alloc_header(pcb, 0, 0, htonl(pcb->snd_nxt - 1));
    28c6:	3801      	subs	r0, #1
    28c8:	4798      	blx	r3
    28ca:	4b12      	ldr	r3, [pc, #72]	; (2914 <tcp_keepalive+0x58>)
    28cc:	4602      	mov	r2, r0
    28ce:	2100      	movs	r1, #0
    28d0:	4620      	mov	r0, r4
    28d2:	4798      	blx	r3
	if (p == NULL) {
    28d4:	4605      	mov	r5, r0
    28d6:	b1c8      	cbz	r0, 290c <tcp_keepalive+0x50>
		return;
	}
	tcphdr = (struct tcp_hdr *)p->payload;

#if CHECKSUM_GEN_TCP
	tcphdr->chksum = inet_chksum_pseudo(p, &pcb->local_ip, &pcb->remote_ip, IP_PROTO_TCP, p->tot_len);
    28d8:	8903      	ldrh	r3, [r0, #8]
	tcphdr = (struct tcp_hdr *)p->payload;
    28da:	6846      	ldr	r6, [r0, #4]
	tcphdr->chksum = inet_chksum_pseudo(p, &pcb->local_ip, &pcb->remote_ip, IP_PROTO_TCP, p->tot_len);
    28dc:	4f0e      	ldr	r7, [pc, #56]	; (2918 <tcp_keepalive+0x5c>)
    28de:	9300      	str	r3, [sp, #0]
    28e0:	1d22      	adds	r2, r4, #4
    28e2:	4621      	mov	r1, r4
    28e4:	2306      	movs	r3, #6
    28e6:	9203      	str	r2, [sp, #12]
    28e8:	47b8      	blx	r7

	/* Send output to IP */
#if LWIP_NETIF_HWADDRHINT
	ip_output_hinted(p, &pcb->local_ip, &pcb->remote_ip, pcb->ttl, 0, IP_PROTO_TCP, &(pcb->addr_hint));
#else  /* LWIP_NETIF_HWADDRHINT*/
	ip_output(p, &pcb->local_ip, &pcb->remote_ip, pcb->ttl, 0, IP_PROTO_TCP);
    28ea:	2300      	movs	r3, #0
    28ec:	2206      	movs	r2, #6
	tcphdr->chksum = inet_chksum_pseudo(p, &pcb->local_ip, &pcb->remote_ip, IP_PROTO_TCP, p->tot_len);
    28ee:	8230      	strh	r0, [r6, #16]
	ip_output(p, &pcb->local_ip, &pcb->remote_ip, pcb->ttl, 0, IP_PROTO_TCP);
    28f0:	e9cd 3200 	strd	r3, r2, [sp]
    28f4:	4621      	mov	r1, r4
    28f6:	7aa3      	ldrb	r3, [r4, #10]
    28f8:	9a03      	ldr	r2, [sp, #12]
    28fa:	4c08      	ldr	r4, [pc, #32]	; (291c <tcp_keepalive+0x60>)
    28fc:	4628      	mov	r0, r5
    28fe:	47a0      	blx	r4
#endif /* LWIP_NETIF_HWADDRHINT*/

	pbuf_free(p);
    2900:	4b07      	ldr	r3, [pc, #28]	; (2920 <tcp_keepalive+0x64>)
    2902:	4628      	mov	r0, r5

	LWIP_DEBUGF(TCP_DEBUG, ("tcp_keepalive: seqno %" U32_F " ackno %" U32_F ".\n", pcb->snd_nxt - 1, pcb->rcv_nxt));
}
    2904:	b005      	add	sp, #20
    2906:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
	pbuf_free(p);
    290a:	4718      	bx	r3
}
    290c:	b005      	add	sp, #20
    290e:	bdf0      	pop	{r4, r5, r6, r7, pc}
    2910:	00000d71 	.word	0x00000d71
    2914:	00001f95 	.word	0x00001f95
    2918:	00008385 	.word	0x00008385
    291c:	000065f9 	.word	0x000065f9
    2920:	000030e5 	.word	0x000030e5

00002924 <tcp_zero_window_probe>:
 * Called by tcp_slowtmr()
 *
 * @param pcb the tcp_pcb for which to send a zero-window probe packet
 */
void tcp_zero_window_probe(struct tcp_pcb *pcb)
{
    2924:	e92d 41ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, lr}
	            ("tcp_zero_window_probe: tcp_ticks %" U32_F "   pcb->tmr %" U32_F " pcb->keep_cnt_sent %" U16_F "\n",
	             tcp_ticks,
	             pcb->tmr,
	             pcb->keep_cnt_sent));

	seg = pcb->unacked;
    2928:	6f07      	ldr	r7, [r0, #112]	; 0x70
{
    292a:	4605      	mov	r5, r0

	if (seg == NULL) {
    292c:	b917      	cbnz	r7, 2934 <tcp_zero_window_probe+0x10>
		seg = pcb->unsent;
    292e:	6ec7      	ldr	r7, [r0, #108]	; 0x6c
	}
	if (seg == NULL) {
    2930:	2f00      	cmp	r7, #0
    2932:	d048      	beq.n	29c6 <tcp_zero_window_probe+0xa2>
		return;
	}

	is_fin = ((TCPH_FLAGS(seg->tcphdr) & TCP_FIN) != 0) && (seg->len == 0);
    2934:	68fb      	ldr	r3, [r7, #12]
    2936:	8998      	ldrh	r0, [r3, #12]
    2938:	4b24      	ldr	r3, [pc, #144]	; (29cc <tcp_zero_window_probe+0xa8>)
    293a:	4798      	blx	r3
    293c:	f010 0401 	ands.w	r4, r0, #1
    2940:	bf18      	it	ne
    2942:	893c      	ldrhne	r4, [r7, #8]
	/* we want to send one seqno: either FIN or data (no options) */
	len = is_fin ? 0 : 1;

	p = tcp_output_alloc_header(pcb, 0, len, seg->tcphdr->seqno);
    2944:	68fb      	ldr	r3, [r7, #12]
	is_fin = ((TCPH_FLAGS(seg->tcphdr) & TCP_FIN) != 0) && (seg->len == 0);
    2946:	bf1c      	itt	ne
    2948:	fab4 f484 	clzne	r4, r4
    294c:	0964      	lsrne	r4, r4, #5
	p = tcp_output_alloc_header(pcb, 0, len, seg->tcphdr->seqno);
    294e:	685a      	ldr	r2, [r3, #4]
    2950:	4b1f      	ldr	r3, [pc, #124]	; (29d0 <tcp_zero_window_probe+0xac>)
    2952:	f084 0101 	eor.w	r1, r4, #1
    2956:	4628      	mov	r0, r5
    2958:	4798      	blx	r3
	if (p == NULL) {
    295a:	4606      	mov	r6, r0
    295c:	2800      	cmp	r0, #0
    295e:	d032      	beq.n	29c6 <tcp_zero_window_probe+0xa2>
		LWIP_DEBUGF(TCP_DEBUG, ("tcp_zero_window_probe: no memory for pbuf\n"));
		return;
	}
	tcphdr = (struct tcp_hdr *)p->payload;
    2960:	f8d0 8004 	ldr.w	r8, [r0, #4]

	if (is_fin) {
    2964:	b324      	cbz	r4, 29b0 <tcp_zero_window_probe+0x8c>
		/* FIN segment, no data */
		TCPH_FLAGS_SET(tcphdr, TCP_ACK | TCP_FIN);
    2966:	4b1b      	ldr	r3, [pc, #108]	; (29d4 <tcp_zero_window_probe+0xb0>)
    2968:	f9b8 400c 	ldrsh.w	r4, [r8, #12]
    296c:	2011      	movs	r0, #17
    296e:	4798      	blx	r3
    2970:	f424 547c 	bic.w	r4, r4, #16128	; 0x3f00
    2974:	4320      	orrs	r0, r4
    2976:	f8a8 000c 	strh.w	r0, [r8, #12]
		   Ensure we copy the first TCP data byte: */
		pbuf_copy_partial(seg->p, d, 1, seg->p->tot_len - seg->len);
	}

#if CHECKSUM_GEN_TCP
	tcphdr->chksum = inet_chksum_pseudo(p, &pcb->local_ip, &pcb->remote_ip, IP_PROTO_TCP, p->tot_len);
    297a:	8933      	ldrh	r3, [r6, #8]
    297c:	9300      	str	r3, [sp, #0]
    297e:	1d2a      	adds	r2, r5, #4
    2980:	4629      	mov	r1, r5
    2982:	4c15      	ldr	r4, [pc, #84]	; (29d8 <tcp_zero_window_probe+0xb4>)
    2984:	9203      	str	r2, [sp, #12]
    2986:	2306      	movs	r3, #6
    2988:	4630      	mov	r0, r6
    298a:	47a0      	blx	r4

	/* Send output to IP */
#if LWIP_NETIF_HWADDRHINT
	ip_output_hinted(p, &pcb->local_ip, &pcb->remote_ip, pcb->ttl, 0, IP_PROTO_TCP, &(pcb->addr_hint));
#else  /* LWIP_NETIF_HWADDRHINT*/
	ip_output(p, &pcb->local_ip, &pcb->remote_ip, pcb->ttl, 0, IP_PROTO_TCP);
    298c:	2300      	movs	r3, #0
	tcphdr->chksum = inet_chksum_pseudo(p, &pcb->local_ip, &pcb->remote_ip, IP_PROTO_TCP, p->tot_len);
    298e:	f8a8 0010 	strh.w	r0, [r8, #16]
	ip_output(p, &pcb->local_ip, &pcb->remote_ip, pcb->ttl, 0, IP_PROTO_TCP);
    2992:	2206      	movs	r2, #6
    2994:	e9cd 3200 	strd	r3, r2, [sp]
    2998:	4c10      	ldr	r4, [pc, #64]	; (29dc <tcp_zero_window_probe+0xb8>)
    299a:	7aab      	ldrb	r3, [r5, #10]
    299c:	9a03      	ldr	r2, [sp, #12]
    299e:	4629      	mov	r1, r5
    29a0:	4630      	mov	r0, r6
    29a2:	47a0      	blx	r4
#endif /* LWIP_NETIF_HWADDRHINT*/

	pbuf_free(p);
    29a4:	4b0e      	ldr	r3, [pc, #56]	; (29e0 <tcp_zero_window_probe+0xbc>)
    29a6:	4630      	mov	r0, r6

	LWIP_DEBUGF(TCP_DEBUG,
	            ("tcp_zero_window_probe: seqno %" U32_F " ackno %" U32_F ".\n", pcb->snd_nxt - 1, pcb->rcv_nxt));
}
    29a8:	b004      	add	sp, #16
    29aa:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
	pbuf_free(p);
    29ae:	4718      	bx	r3
		pbuf_copy_partial(seg->p, d, 1, seg->p->tot_len - seg->len);
    29b0:	6878      	ldr	r0, [r7, #4]
    29b2:	893a      	ldrh	r2, [r7, #8]
    29b4:	8903      	ldrh	r3, [r0, #8]
    29b6:	4c0b      	ldr	r4, [pc, #44]	; (29e4 <tcp_zero_window_probe+0xc0>)
    29b8:	1a9b      	subs	r3, r3, r2
    29ba:	b29b      	uxth	r3, r3
    29bc:	2201      	movs	r2, #1
    29be:	f108 0114 	add.w	r1, r8, #20
    29c2:	47a0      	blx	r4
    29c4:	e7d9      	b.n	297a <tcp_zero_window_probe+0x56>
}
    29c6:	b004      	add	sp, #16
    29c8:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    29cc:	00000d6b 	.word	0x00000d6b
    29d0:	00001f95 	.word	0x00001f95
    29d4:	00000d65 	.word	0x00000d65
    29d8:	00008385 	.word	0x00008385
    29dc:	000065f9 	.word	0x000065f9
    29e0:	000030e5 	.word	0x000030e5
    29e4:	00003385 	.word	0x00003385

000029e8 <ip_reass_free_complete_datagram>:
 * @param ipr datagram to free
 * @param prev the previous datagram in the linked list
 * @return the number of pbufs freed
 */
static int ip_reass_free_complete_datagram(struct ip_reassdata *ipr, struct ip_reassdata *prev)
{
    29e8:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
		LWIP_ASSERT("prev->next == ipr", prev->next == ipr);
	}

	snmp_inc_ipreasmfails();
#if LWIP_ICMP
	iprh = (struct ip_reass_helper *)ipr->p->payload;
    29ec:	6846      	ldr	r6, [r0, #4]
    29ee:	6873      	ldr	r3, [r6, #4]
	if (iprh->start == 0) {
    29f0:	889a      	ldrh	r2, [r3, #4]
{
    29f2:	4604      	mov	r4, r0
    29f4:	460f      	mov	r7, r1
	if (iprh->start == 0) {
    29f6:	2a00      	cmp	r2, #0
    29f8:	d12d      	bne.n	2a56 <ip_reass_free_complete_datagram+0x6e>
		/* The first fragment was received, send ICMP time exceeded. */
		/* First, de-queue the first pbuf from r->p. */
		p      = ipr->p;
		ipr->p = iprh->next_pbuf;
    29fa:	681a      	ldr	r2, [r3, #0]
    29fc:	6042      	str	r2, [r0, #4]
		/* Then, copy the original header into it. */
		SMEMCPY(p->payload, &ipr->iphdr, IP_HLEN);
    29fe:	f100 011c 	add.w	r1, r0, #28
    2a02:	f100 0208 	add.w	r2, r0, #8
    2a06:	f852 0b04 	ldr.w	r0, [r2], #4
    2a0a:	f843 0b04 	str.w	r0, [r3], #4
    2a0e:	428a      	cmp	r2, r1
    2a10:	d1f9      	bne.n	2a06 <ip_reass_free_complete_datagram+0x1e>
		icmp_time_exceeded(p, ICMP_TE_FRAG);
    2a12:	4b17      	ldr	r3, [pc, #92]	; (2a70 <ip_reass_free_complete_datagram+0x88>)
    2a14:	2101      	movs	r1, #1
    2a16:	4630      	mov	r0, r6
    2a18:	4798      	blx	r3
		clen = pbuf_clen(p);
    2a1a:	4b16      	ldr	r3, [pc, #88]	; (2a74 <ip_reass_free_complete_datagram+0x8c>)
    2a1c:	4630      	mov	r0, r6
    2a1e:	4798      	blx	r3
		LWIP_ASSERT("pbufs_freed + clen <= 0xffff", pbufs_freed + clen <= 0xffff);
		pbufs_freed += clen;
		pbuf_free(p);
    2a20:	4b15      	ldr	r3, [pc, #84]	; (2a78 <ip_reass_free_complete_datagram+0x90>)
		pbufs_freed += clen;
    2a22:	b285      	uxth	r5, r0
		pbuf_free(p);
    2a24:	4630      	mov	r0, r6
    2a26:	4798      	blx	r3
	}
#endif /* LWIP_ICMP */

	/* First, free all received pbufs.  The individual pbufs need to be released
	   separately as they have not yet been chained */
	p = ipr->p;
    2a28:	6866      	ldr	r6, [r4, #4]
		struct pbuf *pcur;
		iprh = (struct ip_reass_helper *)p->payload;
		pcur = p;
		/* get the next pointer before freeing */
		p    = iprh->next_pbuf;
		clen = pbuf_clen(pcur);
    2a2a:	f8df 8048 	ldr.w	r8, [pc, #72]	; 2a74 <ip_reass_free_complete_datagram+0x8c>
		LWIP_ASSERT("pbufs_freed + clen <= 0xffff", pbufs_freed + clen <= 0xffff);
		pbufs_freed += clen;
		pbuf_free(pcur);
    2a2e:	f8df 9048 	ldr.w	r9, [pc, #72]	; 2a78 <ip_reass_free_complete_datagram+0x90>
	while (p != NULL) {
    2a32:	b996      	cbnz	r6, 2a5a <ip_reass_free_complete_datagram+0x72>
 */
static void ip_reass_dequeue_datagram(struct ip_reassdata *ipr, struct ip_reassdata *prev)
{

	/* dequeue the reass struct  */
	if (reassdatagrams == ipr) {
    2a34:	4e11      	ldr	r6, [pc, #68]	; (2a7c <ip_reass_free_complete_datagram+0x94>)
		/* it was the first in the list */
		reassdatagrams = ipr->next;
    2a36:	6823      	ldr	r3, [r4, #0]
	if (reassdatagrams == ipr) {
    2a38:	6832      	ldr	r2, [r6, #0]
    2a3a:	4294      	cmp	r4, r2
		reassdatagrams = ipr->next;
    2a3c:	bf0c      	ite	eq
    2a3e:	6033      	streq	r3, [r6, #0]
	} else {
		/* it wasn't the first, so it must have a valid 'prev' */
		LWIP_ASSERT("sanity check linked list", prev != NULL);
		prev->next = ipr->next;
    2a40:	603b      	strne	r3, [r7, #0]
	}

	/* now we can free the ip_reass struct */
	memp_free(MEMP_REASSDATA, ipr);
    2a42:	4621      	mov	r1, r4
    2a44:	4b0e      	ldr	r3, [pc, #56]	; (2a80 <ip_reass_free_complete_datagram+0x98>)
    2a46:	2004      	movs	r0, #4
    2a48:	4798      	blx	r3
	ip_reass_pbufcount -= pbufs_freed;
    2a4a:	88b3      	ldrh	r3, [r6, #4]
    2a4c:	1b5b      	subs	r3, r3, r5
    2a4e:	80b3      	strh	r3, [r6, #4]
}
    2a50:	4628      	mov	r0, r5
    2a52:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
	u16_t                   pbufs_freed = 0;
    2a56:	2500      	movs	r5, #0
    2a58:	e7e6      	b.n	2a28 <ip_reass_free_complete_datagram+0x40>
		iprh = (struct ip_reass_helper *)p->payload;
    2a5a:	6873      	ldr	r3, [r6, #4]
		clen = pbuf_clen(pcur);
    2a5c:	4630      	mov	r0, r6
		p    = iprh->next_pbuf;
    2a5e:	f8d3 a000 	ldr.w	sl, [r3]
		clen = pbuf_clen(pcur);
    2a62:	47c0      	blx	r8
		pbufs_freed += clen;
    2a64:	4428      	add	r0, r5
    2a66:	b285      	uxth	r5, r0
		pbuf_free(pcur);
    2a68:	4630      	mov	r0, r6
    2a6a:	47c8      	blx	r9
		p    = iprh->next_pbuf;
    2a6c:	4656      	mov	r6, sl
    2a6e:	e7e0      	b.n	2a32 <ip_reass_free_complete_datagram+0x4a>
    2a70:	00000d59 	.word	0x00000d59
    2a74:	000032a1 	.word	0x000032a1
    2a78:	000030e5 	.word	0x000030e5
    2a7c:	2000a4d8 	.word	0x2000a4d8
    2a80:	00004c1d 	.word	0x00004c1d

00002a84 <ip_reass_remove_oldest_datagram>:
{
    2a84:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
		r               = reassdatagrams;
    2a88:	f8df 8068 	ldr.w	r8, [pc, #104]	; 2af4 <ip_reass_remove_oldest_datagram+0x70>
			pbufs_freed_current = ip_reass_free_complete_datagram(oldest, prev);
    2a8c:	f8df 9068 	ldr.w	r9, [pc, #104]	; 2af8 <ip_reass_remove_oldest_datagram+0x74>
{
    2a90:	4605      	mov	r5, r0
    2a92:	460f      	mov	r7, r1
	int                  pbufs_freed = 0, pbufs_freed_current;
    2a94:	2600      	movs	r6, #0
		other_datagrams = 0;
    2a96:	2400      	movs	r4, #0
		r               = reassdatagrams;
    2a98:	f8d8 3000 	ldr.w	r3, [r8]
		prev            = NULL;
    2a9c:	4621      	mov	r1, r4
		oldest          = NULL;
    2a9e:	4620      	mov	r0, r4
		while (r != NULL) {
    2aa0:	b94b      	cbnz	r3, 2ab6 <ip_reass_remove_oldest_datagram+0x32>
		if (oldest != NULL) {
    2aa2:	b108      	cbz	r0, 2aa8 <ip_reass_remove_oldest_datagram+0x24>
			pbufs_freed_current = ip_reass_free_complete_datagram(oldest, prev);
    2aa4:	47c8      	blx	r9
			pbufs_freed += pbufs_freed_current;
    2aa6:	4406      	add	r6, r0
	} while ((pbufs_freed < pbufs_needed) && (other_datagrams > 1));
    2aa8:	42be      	cmp	r6, r7
    2aaa:	da01      	bge.n	2ab0 <ip_reass_remove_oldest_datagram+0x2c>
    2aac:	2c01      	cmp	r4, #1
    2aae:	dcf2      	bgt.n	2a96 <ip_reass_remove_oldest_datagram+0x12>
}
    2ab0:	4630      	mov	r0, r6
    2ab2:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
			if (!IP_ADDRESSES_AND_ID_MATCH(&r->iphdr, fraghdr)) {
    2ab6:	f8d5 c00c 	ldr.w	ip, [r5, #12]
    2aba:	695a      	ldr	r2, [r3, #20]
    2abc:	4562      	cmp	r2, ip
    2abe:	d109      	bne.n	2ad4 <ip_reass_remove_oldest_datagram+0x50>
    2ac0:	f8d5 c010 	ldr.w	ip, [r5, #16]
    2ac4:	699a      	ldr	r2, [r3, #24]
    2ac6:	4562      	cmp	r2, ip
    2ac8:	d104      	bne.n	2ad4 <ip_reass_remove_oldest_datagram+0x50>
    2aca:	f8b3 c00c 	ldrh.w	ip, [r3, #12]
    2ace:	88aa      	ldrh	r2, [r5, #4]
    2ad0:	4594      	cmp	ip, r2
    2ad2:	d007      	beq.n	2ae4 <ip_reass_remove_oldest_datagram+0x60>
				other_datagrams++;
    2ad4:	3401      	adds	r4, #1
				if (oldest == NULL) {
    2ad6:	b158      	cbz	r0, 2af0 <ip_reass_remove_oldest_datagram+0x6c>
				} else if (r->timer <= oldest->timer) {
    2ad8:	f893 c01f 	ldrb.w	ip, [r3, #31]
    2adc:	7fc2      	ldrb	r2, [r0, #31]
    2ade:	4594      	cmp	ip, r2
    2ae0:	bf98      	it	ls
    2ae2:	4618      	movls	r0, r3
			if (r->next != NULL) {
    2ae4:	681a      	ldr	r2, [r3, #0]
    2ae6:	2a00      	cmp	r2, #0
    2ae8:	bf18      	it	ne
    2aea:	4619      	movne	r1, r3
    2aec:	4613      	mov	r3, r2
    2aee:	e7d7      	b.n	2aa0 <ip_reass_remove_oldest_datagram+0x1c>
    2af0:	4618      	mov	r0, r3
    2af2:	e7f7      	b.n	2ae4 <ip_reass_remove_oldest_datagram+0x60>
    2af4:	2000a4d8 	.word	0x2000a4d8
    2af8:	000029e9 	.word	0x000029e9

00002afc <ipfrag_free_pbuf_custom>:
}

/** Free-callback function to free a 'struct pbuf_custom_ref', called by
 * pbuf_free. */
static void ipfrag_free_pbuf_custom(struct pbuf *p)
{
    2afc:	b510      	push	{r4, lr}
    2afe:	4604      	mov	r4, r0
	struct pbuf_custom_ref *pcr = (struct pbuf_custom_ref *)p;
	LWIP_ASSERT("pcr != NULL", pcr != NULL);
	LWIP_ASSERT("pcr == p", (void *)pcr == (void *)p);
	if (pcr->original != NULL) {
    2b00:	6940      	ldr	r0, [r0, #20]
    2b02:	b108      	cbz	r0, 2b08 <ipfrag_free_pbuf_custom+0xc>
		pbuf_free(pcr->original);
    2b04:	4b03      	ldr	r3, [pc, #12]	; (2b14 <ipfrag_free_pbuf_custom+0x18>)
    2b06:	4798      	blx	r3
	memp_free(MEMP_FRAG_PBUF, p);
    2b08:	4621      	mov	r1, r4
    2b0a:	4b03      	ldr	r3, [pc, #12]	; (2b18 <ipfrag_free_pbuf_custom+0x1c>)
	}
	ip_frag_free_pbuf_custom_ref(pcr);
}
    2b0c:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	memp_free(MEMP_FRAG_PBUF, p);
    2b10:	2005      	movs	r0, #5
    2b12:	4718      	bx	r3
    2b14:	000030e5 	.word	0x000030e5
    2b18:	00004c1d 	.word	0x00004c1d

00002b1c <ip_reass_tmr>:
	r = reassdatagrams;
    2b1c:	4b09      	ldr	r3, [pc, #36]	; (2b44 <ip_reass_tmr+0x28>)
{
    2b1e:	b570      	push	{r4, r5, r6, lr}
	r = reassdatagrams;
    2b20:	6818      	ldr	r0, [r3, #0]
			ip_reass_free_complete_datagram(tmp, prev);
    2b22:	4d09      	ldr	r5, [pc, #36]	; (2b48 <ip_reass_tmr+0x2c>)
	struct ip_reassdata *r, *prev = NULL;
    2b24:	2400      	movs	r4, #0
	while (r != NULL) {
    2b26:	b900      	cbnz	r0, 2b2a <ip_reass_tmr+0xe>
}
    2b28:	bd70      	pop	{r4, r5, r6, pc}
		if (r->timer > 0) {
    2b2a:	7fc3      	ldrb	r3, [r0, #31]
			r    = r->next;
    2b2c:	6806      	ldr	r6, [r0, #0]
		if (r->timer > 0) {
    2b2e:	b123      	cbz	r3, 2b3a <ip_reass_tmr+0x1e>
			r->timer--;
    2b30:	3b01      	subs	r3, #1
    2b32:	77c3      	strb	r3, [r0, #31]
			ip_reass_free_complete_datagram(tmp, prev);
    2b34:	4604      	mov	r4, r0
    2b36:	4630      	mov	r0, r6
    2b38:	e7f5      	b.n	2b26 <ip_reass_tmr+0xa>
    2b3a:	4621      	mov	r1, r4
    2b3c:	47a8      	blx	r5
    2b3e:	4620      	mov	r0, r4
    2b40:	e7f8      	b.n	2b34 <ip_reass_tmr+0x18>
    2b42:	bf00      	nop
    2b44:	2000a4d8 	.word	0x2000a4d8
    2b48:	000029e9 	.word	0x000029e9

00002b4c <ip_reass>:
{
    2b4c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	fraghdr = (struct ip_hdr *)p->payload;
    2b50:	6844      	ldr	r4, [r0, #4]
	if ((IPH_HL(fraghdr) * 4) != IP_HLEN) {
    2b52:	7823      	ldrb	r3, [r4, #0]
    2b54:	f003 030f 	and.w	r3, r3, #15
    2b58:	2b05      	cmp	r3, #5
{
    2b5a:	b085      	sub	sp, #20
    2b5c:	4605      	mov	r5, r0
	if ((IPH_HL(fraghdr) * 4) != IP_HLEN) {
    2b5e:	f040 808f 	bne.w	2c80 <ip_reass+0x134>
	offset = (ntohs(IPH_OFFSET(fraghdr)) & IP_OFFMASK) * 8;
    2b62:	4fa8      	ldr	r7, [pc, #672]	; (2e04 <ip_reass+0x2b8>)
    2b64:	88e0      	ldrh	r0, [r4, #6]
	clen = pbuf_clen(p);
    2b66:	f8df 92c4 	ldr.w	r9, [pc, #708]	; 2e2c <ip_reass+0x2e0>
	if ((ip_reass_pbufcount + clen) > IP_REASS_MAX_PBUFS) {
    2b6a:	f8df a2a4 	ldr.w	sl, [pc, #676]	; 2e10 <ip_reass+0x2c4>
	offset = (ntohs(IPH_OFFSET(fraghdr)) & IP_OFFMASK) * 8;
    2b6e:	47b8      	blx	r7
    2b70:	9002      	str	r0, [sp, #8]
	len    = ntohs(IPH_LEN(fraghdr)) - IPH_HL(fraghdr) * 4;
    2b72:	8860      	ldrh	r0, [r4, #2]
    2b74:	47b8      	blx	r7
    2b76:	9003      	str	r0, [sp, #12]
	clen = pbuf_clen(p);
    2b78:	4628      	mov	r0, r5
	len    = ntohs(IPH_LEN(fraghdr)) - IPH_HL(fraghdr) * 4;
    2b7a:	f894 8000 	ldrb.w	r8, [r4]
	clen = pbuf_clen(p);
    2b7e:	47c8      	blx	r9
	if ((ip_reass_pbufcount + clen) > IP_REASS_MAX_PBUFS) {
    2b80:	f8ba 3004 	ldrh.w	r3, [sl, #4]
    2b84:	f8cd 9004 	str.w	r9, [sp, #4]
    2b88:	4403      	add	r3, r0
    2b8a:	2b0a      	cmp	r3, #10
	clen = pbuf_clen(p);
    2b8c:	4606      	mov	r6, r0
	if ((ip_reass_pbufcount + clen) > IP_REASS_MAX_PBUFS) {
    2b8e:	dc6d      	bgt.n	2c6c <ip_reass+0x120>
	for (ipr = reassdatagrams; ipr != NULL; ipr = ipr->next) {
    2b90:	f8da 9000 	ldr.w	r9, [sl]
	struct ip_reassdata *   ipr_prev = NULL;
    2b94:	f04f 0a00 	mov.w	sl, #0
	for (ipr = reassdatagrams; ipr != NULL; ipr = ipr->next) {
    2b98:	f1b9 0f00 	cmp.w	r9, #0
    2b9c:	d175      	bne.n	2c8a <ip_reass+0x13e>
	ipr = (struct ip_reassdata *)memp_malloc(MEMP_REASSDATA);
    2b9e:	f8df b290 	ldr.w	fp, [pc, #656]	; 2e30 <ip_reass+0x2e4>
    2ba2:	2004      	movs	r0, #4
    2ba4:	47d8      	blx	fp
	if (ipr == NULL) {
    2ba6:	4681      	mov	r9, r0
    2ba8:	b950      	cbnz	r0, 2bc0 <ip_reass+0x74>
		if (ip_reass_remove_oldest_datagram(fraghdr, clen) >= clen) {
    2baa:	4b97      	ldr	r3, [pc, #604]	; (2e08 <ip_reass+0x2bc>)
    2bac:	4631      	mov	r1, r6
    2bae:	4620      	mov	r0, r4
    2bb0:	4798      	blx	r3
    2bb2:	4286      	cmp	r6, r0
    2bb4:	dc64      	bgt.n	2c80 <ip_reass+0x134>
			ipr = (struct ip_reassdata *)memp_malloc(MEMP_REASSDATA);
    2bb6:	2004      	movs	r0, #4
    2bb8:	47d8      	blx	fp
		if (ipr == NULL)
    2bba:	4681      	mov	r9, r0
    2bbc:	2800      	cmp	r0, #0
    2bbe:	d05f      	beq.n	2c80 <ip_reass+0x134>
	memset(ipr, 0, sizeof(struct ip_reassdata));
    2bc0:	221c      	movs	r2, #28
    2bc2:	2100      	movs	r1, #0
    2bc4:	4b91      	ldr	r3, [pc, #580]	; (2e0c <ip_reass+0x2c0>)
    2bc6:	f109 0004 	add.w	r0, r9, #4
    2bca:	4798      	blx	r3
	ipr->timer = IP_REASS_MAXAGE;
    2bcc:	2203      	movs	r2, #3
    2bce:	f889 201f 	strb.w	r2, [r9, #31]
	ipr->next      = reassdatagrams;
    2bd2:	4a8f      	ldr	r2, [pc, #572]	; (2e10 <ip_reass+0x2c4>)
    2bd4:	6811      	ldr	r1, [r2, #0]
    2bd6:	f8c9 1000 	str.w	r1, [r9]
	reassdatagrams = ipr;
    2bda:	f8c2 9000 	str.w	r9, [r2]
	SMEMCPY(&(ipr->iphdr), fraghdr, IP_HLEN);
    2bde:	f109 0108 	add.w	r1, r9, #8
    2be2:	4622      	mov	r2, r4
    2be4:	f104 0014 	add.w	r0, r4, #20
    2be8:	f852 cb04 	ldr.w	ip, [r2], #4
    2bec:	f841 cb04 	str.w	ip, [r1], #4
    2bf0:	4282      	cmp	r2, r0
    2bf2:	d1f9      	bne.n	2be8 <ip_reass+0x9c>
	ip_reass_pbufcount += clen;
    2bf4:	f8df b218 	ldr.w	fp, [pc, #536]	; 2e10 <ip_reass+0x2c4>
    2bf8:	f8bb 0004 	ldrh.w	r0, [fp, #4]
    2bfc:	4406      	add	r6, r0
    2bfe:	f8ab 6004 	strh.w	r6, [fp, #4]
	if ((IPH_OFFSET(fraghdr) & PP_NTOHS(IP_MF)) == 0) {
    2c02:	88e2      	ldrh	r2, [r4, #6]
    2c04:	0693      	lsls	r3, r2, #26
    2c06:	d40f      	bmi.n	2c28 <ip_reass+0xdc>
	len    = ntohs(IPH_LEN(fraghdr)) - IPH_HL(fraghdr) * 4;
    2c08:	9b03      	ldr	r3, [sp, #12]
		ipr->flags |= IP_REASS_FLAG_LASTFRAG;
    2c0a:	f899 201e 	ldrb.w	r2, [r9, #30]
	len    = ntohs(IPH_LEN(fraghdr)) - IPH_HL(fraghdr) * 4;
    2c0e:	f008 000f 	and.w	r0, r8, #15
    2c12:	eba3 0080 	sub.w	r0, r3, r0, lsl #2
		ipr->datagram_len = offset + len;
    2c16:	9b02      	ldr	r3, [sp, #8]
		ipr->flags |= IP_REASS_FLAG_LASTFRAG;
    2c18:	f042 0201 	orr.w	r2, r2, #1
		ipr->datagram_len = offset + len;
    2c1c:	eb00 00c3 	add.w	r0, r0, r3, lsl #3
		ipr->flags |= IP_REASS_FLAG_LASTFRAG;
    2c20:	f889 201e 	strb.w	r2, [r9, #30]
		ipr->datagram_len = offset + len;
    2c24:	f8a9 001c 	strh.w	r0, [r9, #28]
	fraghdr = (struct ip_hdr *)new_p->payload;
    2c28:	686e      	ldr	r6, [r5, #4]
	len     = ntohs(IPH_LEN(fraghdr)) - IPH_HL(fraghdr) * 4;
    2c2a:	8870      	ldrh	r0, [r6, #2]
    2c2c:	47b8      	blx	r7
    2c2e:	7834      	ldrb	r4, [r6, #0]
    2c30:	f004 040f 	and.w	r4, r4, #15
    2c34:	eba0 0484 	sub.w	r4, r0, r4, lsl #2
	offset  = (ntohs(IPH_OFFSET(fraghdr)) & IP_OFFMASK) * 8;
    2c38:	88f0      	ldrh	r0, [r6, #6]
    2c3a:	47b8      	blx	r7
    2c3c:	f3c0 000c 	ubfx	r0, r0, #0, #13
	iprh            = (struct ip_reass_helper *)new_p->payload;
    2c40:	6869      	ldr	r1, [r5, #4]
	for (q = ipr->p; q != NULL;) {
    2c42:	f8d9 6004 	ldr.w	r6, [r9, #4]
	offset  = (ntohs(IPH_OFFSET(fraghdr)) & IP_OFFMASK) * 8;
    2c46:	00c0      	lsls	r0, r0, #3
	len     = ntohs(IPH_LEN(fraghdr)) - IPH_HL(fraghdr) * 4;
    2c48:	b2a4      	uxth	r4, r4
	iprh->next_pbuf = NULL;
    2c4a:	2200      	movs	r2, #0
	iprh->end       = offset + len;
    2c4c:	4404      	add	r4, r0
	iprh->next_pbuf = NULL;
    2c4e:	700a      	strb	r2, [r1, #0]
    2c50:	704a      	strb	r2, [r1, #1]
    2c52:	708a      	strb	r2, [r1, #2]
    2c54:	70ca      	strb	r2, [r1, #3]
	iprh->start     = offset;
    2c56:	8088      	strh	r0, [r1, #4]
	iprh->end       = offset + len;
    2c58:	fa1f fe84 	uxth.w	lr, r4
    2c5c:	80cc      	strh	r4, [r1, #6]
	int                     valid = 1;
    2c5e:	2301      	movs	r3, #1
	for (q = ipr->p; q != NULL;) {
    2c60:	bb3e      	cbnz	r6, 2cb2 <ip_reass+0x166>
		if (iprh_prev != NULL) {
    2c62:	2a00      	cmp	r2, #0
    2c64:	d173      	bne.n	2d4e <ip_reass+0x202>
			ipr->p = new_p;
    2c66:	f8c9 5004 	str.w	r5, [r9, #4]
    2c6a:	e02f      	b.n	2ccc <ip_reass+0x180>
		if (!ip_reass_remove_oldest_datagram(fraghdr, clen) || ((ip_reass_pbufcount + clen) > IP_REASS_MAX_PBUFS))
    2c6c:	4601      	mov	r1, r0
    2c6e:	4b66      	ldr	r3, [pc, #408]	; (2e08 <ip_reass+0x2bc>)
    2c70:	4620      	mov	r0, r4
    2c72:	4798      	blx	r3
    2c74:	b120      	cbz	r0, 2c80 <ip_reass+0x134>
    2c76:	f8ba 3004 	ldrh.w	r3, [sl, #4]
    2c7a:	4433      	add	r3, r6
    2c7c:	2b0a      	cmp	r3, #10
    2c7e:	dd87      	ble.n	2b90 <ip_reass+0x44>
	pbuf_free(p);
    2c80:	4b64      	ldr	r3, [pc, #400]	; (2e14 <ip_reass+0x2c8>)
    2c82:	4628      	mov	r0, r5
    2c84:	4798      	blx	r3
	return NULL;
    2c86:	2400      	movs	r4, #0
    2c88:	e09d      	b.n	2dc6 <ip_reass+0x27a>
		if (IP_ADDRESSES_AND_ID_MATCH(&ipr->iphdr, fraghdr)) {
    2c8a:	68e2      	ldr	r2, [r4, #12]
    2c8c:	f8d9 1014 	ldr.w	r1, [r9, #20]
    2c90:	4291      	cmp	r1, r2
    2c92:	d10a      	bne.n	2caa <ip_reass+0x15e>
    2c94:	6922      	ldr	r2, [r4, #16]
    2c96:	f8d9 1018 	ldr.w	r1, [r9, #24]
    2c9a:	4291      	cmp	r1, r2
    2c9c:	d105      	bne.n	2caa <ip_reass+0x15e>
    2c9e:	f8b9 100c 	ldrh.w	r1, [r9, #12]
    2ca2:	88a2      	ldrh	r2, [r4, #4]
    2ca4:	4291      	cmp	r1, r2
    2ca6:	f000 8092 	beq.w	2dce <ip_reass+0x282>
	for (ipr = reassdatagrams; ipr != NULL; ipr = ipr->next) {
    2caa:	46ca      	mov	sl, r9
    2cac:	f8d9 9000 	ldr.w	r9, [r9]
    2cb0:	e772      	b.n	2b98 <ip_reass+0x4c>
		iprh_tmp = (struct ip_reass_helper *)q->payload;
    2cb2:	6877      	ldr	r7, [r6, #4]
		if (iprh->start < iprh_tmp->start) {
    2cb4:	88bc      	ldrh	r4, [r7, #4]
    2cb6:	42a0      	cmp	r0, r4
    2cb8:	d23d      	bcs.n	2d36 <ip_reass+0x1ea>
			iprh->next_pbuf = q;
    2cba:	600e      	str	r6, [r1, #0]
			if (iprh_prev != NULL) {
    2cbc:	2a00      	cmp	r2, #0
    2cbe:	d0d2      	beq.n	2c66 <ip_reass+0x11a>
				if ((iprh->start < iprh_prev->end) || (iprh->end > iprh_tmp->start)) {
    2cc0:	88d6      	ldrh	r6, [r2, #6]
    2cc2:	4286      	cmp	r6, r0
    2cc4:	d851      	bhi.n	2d6a <ip_reass+0x21e>
    2cc6:	45a6      	cmp	lr, r4
    2cc8:	d84f      	bhi.n	2d6a <ip_reass+0x21e>
				iprh_prev->next_pbuf = new_p;
    2cca:	6015      	str	r5, [r2, #0]
	if ((ipr->flags & IP_REASS_FLAG_LASTFRAG) != 0) {
    2ccc:	f899 201e 	ldrb.w	r2, [r9, #30]
    2cd0:	f012 0401 	ands.w	r4, r2, #1
    2cd4:	d077      	beq.n	2dc6 <ip_reass+0x27a>
		if (valid) {
    2cd6:	2b00      	cmp	r3, #0
    2cd8:	d0d5      	beq.n	2c86 <ip_reass+0x13a>
			if (((struct ip_reass_helper *)ipr->p->payload)->start != 0) {
    2cda:	f8d9 2004 	ldr.w	r2, [r9, #4]
    2cde:	6854      	ldr	r4, [r2, #4]
    2ce0:	88a2      	ldrh	r2, [r4, #4]
    2ce2:	2a00      	cmp	r2, #0
    2ce4:	d1cf      	bne.n	2c86 <ip_reass+0x13a>
				q         = iprh->next_pbuf;
    2ce6:	680a      	ldr	r2, [r1, #0]
				while (q != NULL) {
    2ce8:	2a00      	cmp	r2, #0
    2cea:	d136      	bne.n	2d5a <ip_reass+0x20e>
		ipr->datagram_len += IP_HLEN;
    2cec:	f8b9 201c 	ldrh.w	r2, [r9, #28]
		r = ((struct ip_reass_helper *)ipr->p->payload)->next_pbuf;
    2cf0:	6825      	ldr	r5, [r4, #0]
		ipr->datagram_len += IP_HLEN;
    2cf2:	3214      	adds	r2, #20
    2cf4:	f8a9 201c 	strh.w	r2, [r9, #28]
		SMEMCPY(fraghdr, &ipr->iphdr, IP_HLEN);
    2cf8:	4621      	mov	r1, r4
    2cfa:	f109 0208 	add.w	r2, r9, #8
    2cfe:	f109 001c 	add.w	r0, r9, #28
    2d02:	f852 6b04 	ldr.w	r6, [r2], #4
    2d06:	f841 6b04 	str.w	r6, [r1], #4
    2d0a:	4282      	cmp	r2, r0
    2d0c:	d1f9      	bne.n	2d02 <ip_reass+0x1b6>
		IPH_LEN_SET(fraghdr, htons(ipr->datagram_len));
    2d0e:	4a42      	ldr	r2, [pc, #264]	; (2e18 <ip_reass+0x2cc>)
    2d10:	f8b9 001c 	ldrh.w	r0, [r9, #28]
			pbuf_header(r, -IP_HLEN);
    2d14:	4f41      	ldr	r7, [pc, #260]	; (2e1c <ip_reass+0x2d0>)
			pbuf_cat(p, r);
    2d16:	4e42      	ldr	r6, [pc, #264]	; (2e20 <ip_reass+0x2d4>)
		IPH_LEN_SET(fraghdr, htons(ipr->datagram_len));
    2d18:	4790      	blx	r2
		IPH_OFFSET_SET(fraghdr, 0);
    2d1a:	2200      	movs	r2, #0
		IPH_LEN_SET(fraghdr, htons(ipr->datagram_len));
    2d1c:	8060      	strh	r0, [r4, #2]
		IPH_OFFSET_SET(fraghdr, 0);
    2d1e:	71a2      	strb	r2, [r4, #6]
    2d20:	71e2      	strb	r2, [r4, #7]
		IPH_CHKSUM_SET(fraghdr, 0);
    2d22:	72a2      	strb	r2, [r4, #10]
    2d24:	72e2      	strb	r2, [r4, #11]
		IPH_CHKSUM_SET(fraghdr, inet_chksum(fraghdr, IP_HLEN));
    2d26:	4620      	mov	r0, r4
    2d28:	4a3e      	ldr	r2, [pc, #248]	; (2e24 <ip_reass+0x2d8>)
    2d2a:	2114      	movs	r1, #20
    2d2c:	4790      	blx	r2
    2d2e:	8160      	strh	r0, [r4, #10]
		p = ipr->p;
    2d30:	f8d9 4004 	ldr.w	r4, [r9, #4]
		while (r != NULL) {
    2d34:	e02d      	b.n	2d92 <ip_reass+0x246>
		} else if (iprh->start == iprh_tmp->start) {
    2d36:	d018      	beq.n	2d6a <ip_reass+0x21e>
		} else if (iprh->start < iprh_tmp->end) {
    2d38:	88fe      	ldrh	r6, [r7, #6]
    2d3a:	4286      	cmp	r6, r0
    2d3c:	d815      	bhi.n	2d6a <ip_reass+0x21e>
			if (iprh_prev != NULL) {
    2d3e:	b11a      	cbz	r2, 2d48 <ip_reass+0x1fc>
				if (iprh_prev->end != iprh_tmp->start) {
    2d40:	88d2      	ldrh	r2, [r2, #6]
					valid = 0;
    2d42:	42a2      	cmp	r2, r4
    2d44:	bf18      	it	ne
    2d46:	2300      	movne	r3, #0
		q         = iprh_tmp->next_pbuf;
    2d48:	683e      	ldr	r6, [r7, #0]
    2d4a:	463a      	mov	r2, r7
    2d4c:	e788      	b.n	2c60 <ip_reass+0x114>
			iprh_prev->next_pbuf = new_p;
    2d4e:	6015      	str	r5, [r2, #0]
			if (iprh_prev->end != iprh->start) {
    2d50:	88d2      	ldrh	r2, [r2, #6]
				valid = 0;
    2d52:	4282      	cmp	r2, r0
    2d54:	bf18      	it	ne
    2d56:	2300      	movne	r3, #0
    2d58:	e7b8      	b.n	2ccc <ip_reass+0x180>
					iprh = (struct ip_reass_helper *)q->payload;
    2d5a:	6850      	ldr	r0, [r2, #4]
					if (iprh_prev->end != iprh->start) {
    2d5c:	88c9      	ldrh	r1, [r1, #6]
    2d5e:	8882      	ldrh	r2, [r0, #4]
    2d60:	4291      	cmp	r1, r2
    2d62:	d190      	bne.n	2c86 <ip_reass+0x13a>
					q         = iprh->next_pbuf;
    2d64:	6802      	ldr	r2, [r0, #0]
    2d66:	4601      	mov	r1, r0
    2d68:	e7be      	b.n	2ce8 <ip_reass+0x19c>
	ip_reass_pbufcount -= pbuf_clen(new_p);
    2d6a:	9b01      	ldr	r3, [sp, #4]
    2d6c:	4628      	mov	r0, r5
    2d6e:	4798      	blx	r3
    2d70:	f8bb 3004 	ldrh.w	r3, [fp, #4]
    2d74:	1a18      	subs	r0, r3, r0
    2d76:	f8ab 0004 	strh.w	r0, [fp, #4]
	pbuf_free(new_p);
    2d7a:	e781      	b.n	2c80 <ip_reass+0x134>
			iprh = (struct ip_reass_helper *)r->payload;
    2d7c:	f8d5 8004 	ldr.w	r8, [r5, #4]
			pbuf_header(r, -IP_HLEN);
    2d80:	f06f 0113 	mvn.w	r1, #19
    2d84:	4628      	mov	r0, r5
    2d86:	47b8      	blx	r7
			pbuf_cat(p, r);
    2d88:	4629      	mov	r1, r5
    2d8a:	4620      	mov	r0, r4
    2d8c:	47b0      	blx	r6
			r = iprh->next_pbuf;
    2d8e:	f8d8 5000 	ldr.w	r5, [r8]
		while (r != NULL) {
    2d92:	2d00      	cmp	r5, #0
    2d94:	d1f2      	bne.n	2d7c <ip_reass+0x230>
	if (reassdatagrams == ipr) {
    2d96:	f8db 1000 	ldr.w	r1, [fp]
		reassdatagrams = ipr->next;
    2d9a:	f8d9 2000 	ldr.w	r2, [r9]
	memp_free(MEMP_REASSDATA, ipr);
    2d9e:	4b22      	ldr	r3, [pc, #136]	; (2e28 <ip_reass+0x2dc>)
	if (reassdatagrams == ipr) {
    2da0:	4589      	cmp	r9, r1
		prev->next = ipr->next;
    2da2:	bf18      	it	ne
    2da4:	f8ca 2000 	strne.w	r2, [sl]
	memp_free(MEMP_REASSDATA, ipr);
    2da8:	4649      	mov	r1, r9
    2daa:	f04f 0004 	mov.w	r0, #4
		reassdatagrams = ipr->next;
    2dae:	bf08      	it	eq
    2db0:	f8cb 2000 	streq.w	r2, [fp]
	memp_free(MEMP_REASSDATA, ipr);
    2db4:	4798      	blx	r3
		ip_reass_pbufcount -= pbuf_clen(p);
    2db6:	9b01      	ldr	r3, [sp, #4]
    2db8:	4620      	mov	r0, r4
    2dba:	4798      	blx	r3
    2dbc:	f8bb 3004 	ldrh.w	r3, [fp, #4]
    2dc0:	1a18      	subs	r0, r3, r0
    2dc2:	f8ab 0004 	strh.w	r0, [fp, #4]
}
    2dc6:	4620      	mov	r0, r4
    2dc8:	b005      	add	sp, #20
    2dca:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		if (((ntohs(IPH_OFFSET(fraghdr)) & IP_OFFMASK) == 0) && ((ntohs(IPH_OFFSET(&ipr->iphdr)) & IP_OFFMASK) != 0)) {
    2dce:	88e0      	ldrh	r0, [r4, #6]
    2dd0:	47b8      	blx	r7
    2dd2:	f3c0 000c 	ubfx	r0, r0, #0, #13
    2dd6:	2800      	cmp	r0, #0
    2dd8:	f47f af0c 	bne.w	2bf4 <ip_reass+0xa8>
    2ddc:	f8b9 000e 	ldrh.w	r0, [r9, #14]
    2de0:	47b8      	blx	r7
    2de2:	f3c0 000c 	ubfx	r0, r0, #0, #13
    2de6:	2800      	cmp	r0, #0
    2de8:	f43f af04 	beq.w	2bf4 <ip_reass+0xa8>
			SMEMCPY(&ipr->iphdr, fraghdr, IP_HLEN);
    2dec:	4622      	mov	r2, r4
    2dee:	f109 0108 	add.w	r1, r9, #8
    2df2:	f104 0014 	add.w	r0, r4, #20
    2df6:	f852 cb04 	ldr.w	ip, [r2], #4
    2dfa:	f841 cb04 	str.w	ip, [r1], #4
    2dfe:	4282      	cmp	r2, r0
    2e00:	d1f9      	bne.n	2df6 <ip_reass+0x2aa>
    2e02:	e6f7      	b.n	2bf4 <ip_reass+0xa8>
    2e04:	00000d6b 	.word	0x00000d6b
    2e08:	00002a85 	.word	0x00002a85
    2e0c:	0000a365 	.word	0x0000a365
    2e10:	2000a4d8 	.word	0x2000a4d8
    2e14:	000030e5 	.word	0x000030e5
    2e18:	00000d65 	.word	0x00000d65
    2e1c:	0000308d 	.word	0x0000308d
    2e20:	000032bb 	.word	0x000032bb
    2e24:	00008415 	.word	0x00008415
    2e28:	00004c1d 	.word	0x00004c1d
    2e2c:	000032a1 	.word	0x000032a1
    2e30:	00004c01 	.word	0x00004c01

00002e34 <ip_frag>:
 * @param dest destination ip address to which to send
 *
 * @return ERR_OK if sent successfully, err_t otherwise
 */
err_t ip_frag(struct pbuf *p, struct netif *netif, ip_addr_t *dest)
{
    2e34:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    2e38:	ed2d 8b02 	vpush	{d8}
    2e3c:	b08d      	sub	sp, #52	; 0x34
	struct ip_hdr *original_iphdr;
#endif
	struct ip_hdr *iphdr;
	u16_t          nfb;
	u16_t          left, cop;
	u16_t          mtu = netif->mtu;
    2e3e:	8d0b      	ldrh	r3, [r1, #40]	; 0x28
    2e40:	9305      	str	r3, [sp, #20]

	/* Copy the IP header in it */
	iphdr = (struct ip_hdr *)rambuf->payload;
	SMEMCPY(iphdr, p->payload, IP_HLEN);
#else  /* IP_FRAG_USES_STATIC_BUF */
	original_iphdr = (struct ip_hdr *)p->payload;
    2e42:	6843      	ldr	r3, [r0, #4]
    2e44:	9306      	str	r3, [sp, #24]
{
    2e46:	4604      	mov	r4, r0
	iphdr          = original_iphdr;
#endif /* IP_FRAG_USES_STATIC_BUF */

	/* Save original offset */
	tmp = ntohs(IPH_OFFSET(iphdr));
    2e48:	88d8      	ldrh	r0, [r3, #6]
    2e4a:	4b5e      	ldr	r3, [pc, #376]	; (2fc4 <ip_frag+0x190>)
{
    2e4c:	ee08 2a10 	vmov	s16, r2
    2e50:	468a      	mov	sl, r1
	tmp = ntohs(IPH_OFFSET(iphdr));
    2e52:	4798      	blx	r3
	ofo = tmp & IP_OFFMASK;
	omf = tmp & IP_MF;

	left = p->tot_len - IP_HLEN;
    2e54:	8925      	ldrh	r5, [r4, #8]
	ofo = tmp & IP_OFFMASK;
    2e56:	f3c0 030c 	ubfx	r3, r0, #0, #13
    2e5a:	9304      	str	r3, [sp, #16]
	left = p->tot_len - IP_HLEN;
    2e5c:	3d14      	subs	r5, #20
	omf = tmp & IP_MF;
    2e5e:	f400 5300 	and.w	r3, r0, #8192	; 0x2000
    2e62:	9308      	str	r3, [sp, #32]
	left = p->tot_len - IP_HLEN;
    2e64:	b2ab      	uxth	r3, r5
    2e66:	9302      	str	r3, [sp, #8]

	nfb = (mtu - IP_HLEN) / 8;
    2e68:	9b05      	ldr	r3, [sp, #20]
    2e6a:	3b14      	subs	r3, #20
    2e6c:	bf44      	itt	mi
    2e6e:	9b05      	ldrmi	r3, [sp, #20]
    2e70:	3b0d      	submi	r3, #13
    2e72:	f3c3 03cf 	ubfx	r3, r3, #3, #16
    2e76:	9307      	str	r3, [sp, #28]
		if (!last) {
			tmp = tmp | IP_MF;
		}

		/* Fill this fragment */
		cop = last ? left : nfb * 8;
    2e78:	00db      	lsls	r3, r3, #3
    2e7a:	b29b      	uxth	r3, r3
    2e7c:	9309      	str	r3, [sp, #36]	; 0x24
	u16_t          poff = IP_HLEN;
    2e7e:	2614      	movs	r6, #20
	u16_t newpbuflen = 0;
    2e80:	2300      	movs	r3, #0
	while (left) {
    2e82:	9a02      	ldr	r2, [sp, #8]
    2e84:	b92a      	cbnz	r2, 2e92 <ip_frag+0x5e>
	}
#if IP_FRAG_USES_STATIC_BUF
	pbuf_free(rambuf);
#endif /* IP_FRAG_USES_STATIC_BUF */
	snmp_inc_ipfragoks();
	return ERR_OK;
    2e86:	4610      	mov	r0, r2
}
    2e88:	b00d      	add	sp, #52	; 0x34
    2e8a:	ecbd 8b02 	vpop	{d8}
    2e8e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		tmp = omf | (IP_OFFMASK & (ofo));
    2e92:	9a04      	ldr	r2, [sp, #16]
		if (!last) {
    2e94:	9902      	ldr	r1, [sp, #8]
    2e96:	930a      	str	r3, [sp, #40]	; 0x28
		tmp = omf | (IP_OFFMASK & (ofo));
    2e98:	f3c2 0b0c 	ubfx	fp, r2, #0, #13
    2e9c:	9a08      	ldr	r2, [sp, #32]
		rambuf = pbuf_alloc(PBUF_LINK, IP_HLEN, PBUF_RAM);
    2e9e:	4b4a      	ldr	r3, [pc, #296]	; (2fc8 <ip_frag+0x194>)
		tmp = omf | (IP_OFFMASK & (ofo));
    2ea0:	ea42 0b0b 	orr.w	fp, r2, fp
		last = (left <= mtu - IP_HLEN);
    2ea4:	9a05      	ldr	r2, [sp, #20]
    2ea6:	3a13      	subs	r2, #19
		if (!last) {
    2ea8:	428a      	cmp	r2, r1
		cop = last ? left : nfb * 8;
    2eaa:	bfd4      	ite	le
    2eac:	9a09      	ldrle	r2, [sp, #36]	; 0x24
    2eae:	9a02      	ldrgt	r2, [sp, #8]
    2eb0:	9203      	str	r2, [sp, #12]
		rambuf = pbuf_alloc(PBUF_LINK, IP_HLEN, PBUF_RAM);
    2eb2:	f04f 0114 	mov.w	r1, #20
    2eb6:	f04f 0200 	mov.w	r2, #0
    2eba:	f04f 0002 	mov.w	r0, #2
			tmp = tmp | IP_MF;
    2ebe:	bfd8      	it	le
    2ec0:	f44b 5b00 	orrle.w	fp, fp, #8192	; 0x2000
		rambuf = pbuf_alloc(PBUF_LINK, IP_HLEN, PBUF_RAM);
    2ec4:	4798      	blx	r3
		if (rambuf == NULL) {
    2ec6:	4607      	mov	r7, r0
    2ec8:	b340      	cbz	r0, 2f1c <ip_frag+0xe8>
		SMEMCPY(rambuf->payload, original_iphdr, IP_HLEN);
    2eca:	9a06      	ldr	r2, [sp, #24]
    2ecc:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    2ece:	6841      	ldr	r1, [r0, #4]
    2ed0:	f102 0014 	add.w	r0, r2, #20
    2ed4:	f852 cb04 	ldr.w	ip, [r2], #4
    2ed8:	f841 cb04 	str.w	ip, [r1], #4
    2edc:	4282      	cmp	r2, r0
    2ede:	d1f9      	bne.n	2ed4 <ip_frag+0xa0>
		p->payload = (u8_t *)p->payload + poff;
    2ee0:	6862      	ldr	r2, [r4, #4]
		iphdr = (struct ip_hdr *)rambuf->payload;
    2ee2:	f8d7 9004 	ldr.w	r9, [r7, #4]
		left_to_copy = cop;
    2ee6:	f8dd 800c 	ldr.w	r8, [sp, #12]
		p->payload = (u8_t *)p->payload + poff;
    2eea:	4432      	add	r2, r6
    2eec:	6062      	str	r2, [r4, #4]
		p->len -= poff;
    2eee:	8962      	ldrh	r2, [r4, #10]
    2ef0:	1b96      	subs	r6, r2, r6
    2ef2:	8166      	strh	r6, [r4, #10]
		while (left_to_copy) {
    2ef4:	461e      	mov	r6, r3
    2ef6:	f1b8 0f00 	cmp.w	r8, #0
    2efa:	d036      	beq.n	2f6a <ip_frag+0x136>
			newpbuflen = (left_to_copy < p->len) ? left_to_copy : p->len;
    2efc:	8966      	ldrh	r6, [r4, #10]
    2efe:	4546      	cmp	r6, r8
    2f00:	bf28      	it	cs
    2f02:	4646      	movcs	r6, r8
    2f04:	b2b6      	uxth	r6, r6
			if (!newpbuflen) {
    2f06:	b90e      	cbnz	r6, 2f0c <ip_frag+0xd8>
				p = p->next;
    2f08:	6824      	ldr	r4, [r4, #0]
    2f0a:	e7f4      	b.n	2ef6 <ip_frag+0xc2>
	return (struct pbuf_custom_ref *)memp_malloc(MEMP_FRAG_PBUF);
    2f0c:	4b2f      	ldr	r3, [pc, #188]	; (2fcc <ip_frag+0x198>)
    2f0e:	2005      	movs	r0, #5
    2f10:	4798      	blx	r3
			if (pcr == NULL) {
    2f12:	4603      	mov	r3, r0
    2f14:	b928      	cbnz	r0, 2f22 <ip_frag+0xee>
				pbuf_free(rambuf);
    2f16:	4b2e      	ldr	r3, [pc, #184]	; (2fd0 <ip_frag+0x19c>)
    2f18:	4638      	mov	r0, r7
    2f1a:	4798      	blx	r3
			return ERR_MEM;
    2f1c:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    2f20:	e7b2      	b.n	2e88 <ip_frag+0x54>
			newpbuf = pbuf_alloced_custom(PBUF_RAW, newpbuflen, PBUF_REF, &pcr->pc, p->payload, newpbuflen);
    2f22:	9601      	str	r6, [sp, #4]
    2f24:	6862      	ldr	r2, [r4, #4]
    2f26:	9200      	str	r2, [sp, #0]
    2f28:	900a      	str	r0, [sp, #40]	; 0x28
    2f2a:	4d2a      	ldr	r5, [pc, #168]	; (2fd4 <ip_frag+0x1a0>)
    2f2c:	2202      	movs	r2, #2
    2f2e:	4631      	mov	r1, r6
    2f30:	2003      	movs	r0, #3
    2f32:	47a8      	blx	r5
			if (newpbuf == NULL) {
    2f34:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    2f36:	b920      	cbnz	r0, 2f42 <ip_frag+0x10e>
	memp_free(MEMP_FRAG_PBUF, p);
    2f38:	4619      	mov	r1, r3
    2f3a:	2005      	movs	r0, #5
    2f3c:	4b26      	ldr	r3, [pc, #152]	; (2fd8 <ip_frag+0x1a4>)
    2f3e:	4798      	blx	r3
    2f40:	e7e9      	b.n	2f16 <ip_frag+0xe2>
    2f42:	e9cd 030a 	strd	r0, r3, [sp, #40]	; 0x28
			pbuf_ref(p);
    2f46:	4b25      	ldr	r3, [pc, #148]	; (2fdc <ip_frag+0x1a8>)
    2f48:	4620      	mov	r0, r4
    2f4a:	4798      	blx	r3
			pcr->original                = p;
    2f4c:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
			pcr->pc.custom_free_function = ipfrag_free_pbuf_custom;
    2f4e:	4a24      	ldr	r2, [pc, #144]	; (2fe0 <ip_frag+0x1ac>)
			pcr->original                = p;
    2f50:	615c      	str	r4, [r3, #20]
			left_to_copy -= newpbuflen;
    2f52:	eba8 0806 	sub.w	r8, r8, r6
			pcr->pc.custom_free_function = ipfrag_free_pbuf_custom;
    2f56:	611a      	str	r2, [r3, #16]
			pbuf_cat(rambuf, newpbuf);
    2f58:	990a      	ldr	r1, [sp, #40]	; 0x28
    2f5a:	4b22      	ldr	r3, [pc, #136]	; (2fe4 <ip_frag+0x1b0>)
    2f5c:	4638      	mov	r0, r7
			left_to_copy -= newpbuflen;
    2f5e:	fa1f f888 	uxth.w	r8, r8
			pbuf_cat(rambuf, newpbuf);
    2f62:	4798      	blx	r3
			if (left_to_copy) {
    2f64:	f1b8 0f00 	cmp.w	r8, #0
    2f68:	d1ce      	bne.n	2f08 <ip_frag+0xd4>
		IPH_OFFSET_SET(iphdr, htons(tmp));
    2f6a:	4658      	mov	r0, fp
    2f6c:	f8df b07c 	ldr.w	fp, [pc, #124]	; 2fec <ip_frag+0x1b8>
    2f70:	47d8      	blx	fp
		IPH_LEN_SET(iphdr, htons(cop + IP_HLEN));
    2f72:	9b03      	ldr	r3, [sp, #12]
		IPH_OFFSET_SET(iphdr, htons(tmp));
    2f74:	f8a9 0006 	strh.w	r0, [r9, #6]
		IPH_LEN_SET(iphdr, htons(cop + IP_HLEN));
    2f78:	f103 0014 	add.w	r0, r3, #20
    2f7c:	b280      	uxth	r0, r0
    2f7e:	47d8      	blx	fp
		IPH_CHKSUM_SET(iphdr, inet_chksum(iphdr, IP_HLEN));
    2f80:	4b19      	ldr	r3, [pc, #100]	; (2fe8 <ip_frag+0x1b4>)
		IPH_LEN_SET(iphdr, htons(cop + IP_HLEN));
    2f82:	f8a9 0002 	strh.w	r0, [r9, #2]
		IPH_CHKSUM_SET(iphdr, inet_chksum(iphdr, IP_HLEN));
    2f86:	2114      	movs	r1, #20
		IPH_CHKSUM_SET(iphdr, 0);
    2f88:	f889 800a 	strb.w	r8, [r9, #10]
    2f8c:	f889 800b 	strb.w	r8, [r9, #11]
		IPH_CHKSUM_SET(iphdr, inet_chksum(iphdr, IP_HLEN));
    2f90:	4648      	mov	r0, r9
    2f92:	4798      	blx	r3
        netif->output(netif, rambuf, dest);
    2f94:	ee18 2a10 	vmov	r2, s16
    2f98:	f8da 3014 	ldr.w	r3, [sl, #20]
		IPH_CHKSUM_SET(iphdr, inet_chksum(iphdr, IP_HLEN));
    2f9c:	f8a9 000a 	strh.w	r0, [r9, #10]
        netif->output(netif, rambuf, dest);
    2fa0:	4639      	mov	r1, r7
    2fa2:	4650      	mov	r0, sl
    2fa4:	4798      	blx	r3
        pbuf_free(rambuf);
    2fa6:	4b0a      	ldr	r3, [pc, #40]	; (2fd0 <ip_frag+0x19c>)
    2fa8:	4638      	mov	r0, r7
    2faa:	4798      	blx	r3
		left -= cop;
    2fac:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
    2fb0:	1ad5      	subs	r5, r2, r3
    2fb2:	b2ab      	uxth	r3, r5
		ofo += nfb;
    2fb4:	9a07      	ldr	r2, [sp, #28]
		left -= cop;
    2fb6:	9302      	str	r3, [sp, #8]
		ofo += nfb;
    2fb8:	9b04      	ldr	r3, [sp, #16]
    2fba:	4413      	add	r3, r2
    2fbc:	b29b      	uxth	r3, r3
    2fbe:	9304      	str	r3, [sp, #16]
    2fc0:	4633      	mov	r3, r6
    2fc2:	e75e      	b.n	2e82 <ip_frag+0x4e>
    2fc4:	00000d6b 	.word	0x00000d6b
    2fc8:	0000313d 	.word	0x0000313d
    2fcc:	00004c01 	.word	0x00004c01
    2fd0:	000030e5 	.word	0x000030e5
    2fd4:	00003049 	.word	0x00003049
    2fd8:	00004c1d 	.word	0x00004c1d
    2fdc:	000032b1 	.word	0x000032b1
    2fe0:	00002afd 	.word	0x00002afd
    2fe4:	000032bb 	.word	0x000032bb
    2fe8:	00008415 	.word	0x00008415
    2fec:	00000d65 	.word	0x00000d65

00002ff0 <pbuf_free_ooseq_callback>:
{
	struct tcp_pcb *pcb;
	SYS_ARCH_DECL_PROTECT(old_level);

	SYS_ARCH_PROTECT(old_level);
	pbuf_free_ooseq_pending = 0;
    2ff0:	4b07      	ldr	r3, [pc, #28]	; (3010 <pbuf_free_ooseq_callback+0x20>)
    2ff2:	2200      	movs	r2, #0
#if !NO_SYS
/**
 * Just a callback function for tcpip_timeout() that calls pbuf_free_ooseq().
 */
static void pbuf_free_ooseq_callback(void *arg)
{
    2ff4:	b510      	push	{r4, lr}
	pbuf_free_ooseq_pending = 0;
    2ff6:	701a      	strb	r2, [r3, #0]
	for (pcb = tcp_active_pcbs; NULL != pcb; pcb = pcb->next) {
    2ff8:	4b06      	ldr	r3, [pc, #24]	; (3014 <pbuf_free_ooseq_callback+0x24>)
    2ffa:	681c      	ldr	r4, [r3, #0]
    2ffc:	b12c      	cbz	r4, 300a <pbuf_free_ooseq_callback+0x1a>
		if (NULL != pcb->ooseq) {
    2ffe:	6f60      	ldr	r0, [r4, #116]	; 0x74
    3000:	b120      	cbz	r0, 300c <pbuf_free_ooseq_callback+0x1c>
			tcp_segs_free(pcb->ooseq);
    3002:	4b05      	ldr	r3, [pc, #20]	; (3018 <pbuf_free_ooseq_callback+0x28>)
    3004:	4798      	blx	r3
			pcb->ooseq = NULL;
    3006:	2300      	movs	r3, #0
    3008:	6763      	str	r3, [r4, #116]	; 0x74
	LWIP_UNUSED_ARG(arg);
	pbuf_free_ooseq();
}
    300a:	bd10      	pop	{r4, pc}
	for (pcb = tcp_active_pcbs; NULL != pcb; pcb = pcb->next) {
    300c:	68e4      	ldr	r4, [r4, #12]
    300e:	e7f5      	b.n	2ffc <pbuf_free_ooseq_callback+0xc>
    3010:	2000a4de 	.word	0x2000a4de
    3014:	20014950 	.word	0x20014950
    3018:	00006ae5 	.word	0x00006ae5

0000301c <pbuf_pool_is_empty>:
#endif /* !NO_SYS */

/** Queue a call to pbuf_free_ooseq if not already queued. */
static void pbuf_pool_is_empty(void)
{
    301c:	b538      	push	{r3, r4, r5, lr}
	SYS_ARCH_UNPROTECT(old_level);
#else  /* PBUF_POOL_FREE_OOSEQ_QUEUE_CALL */
	u8_t queued;
	SYS_ARCH_DECL_PROTECT(old_level);
	SYS_ARCH_PROTECT(old_level);
	queued                  = pbuf_free_ooseq_pending;
    301e:	4c07      	ldr	r4, [pc, #28]	; (303c <pbuf_pool_is_empty+0x20>)
    3020:	7823      	ldrb	r3, [r4, #0]
	pbuf_free_ooseq_pending = 1;
    3022:	2201      	movs	r2, #1
    3024:	7022      	strb	r2, [r4, #0]
	SYS_ARCH_UNPROTECT(old_level);

	if (!queued) {
    3026:	f003 05ff 	and.w	r5, r3, #255	; 0xff
    302a:	b933      	cbnz	r3, 303a <pbuf_pool_is_empty+0x1e>
		/* queue a call to pbuf_free_ooseq if not already queued */
		PBUF_POOL_FREE_OOSEQ_QUEUE_CALL();
    302c:	4804      	ldr	r0, [pc, #16]	; (3040 <pbuf_pool_is_empty+0x24>)
    302e:	4b05      	ldr	r3, [pc, #20]	; (3044 <pbuf_pool_is_empty+0x28>)
    3030:	462a      	mov	r2, r5
    3032:	4629      	mov	r1, r5
    3034:	4798      	blx	r3
    3036:	b100      	cbz	r0, 303a <pbuf_pool_is_empty+0x1e>
    3038:	7025      	strb	r5, [r4, #0]
	}
#endif /* PBUF_POOL_FREE_OOSEQ_QUEUE_CALL */
}
    303a:	bd38      	pop	{r3, r4, r5, pc}
    303c:	2000a4de 	.word	0x2000a4de
    3040:	00002ff1 	.word	0x00002ff1
    3044:	0000a1ed 	.word	0x0000a1ed

00003048 <pbuf_alloced_custom>:
 * @param payload_mem_len the size of the 'payload_mem' buffer, must be at least
 *        big enough to hold 'length' plus the header size
 */
struct pbuf *pbuf_alloced_custom(pbuf_layer l, u16_t length, pbuf_type type, struct pbuf_custom *p, void *payload_mem,
                                 u16_t payload_mem_len)
{
    3048:	b570      	push	{r4, r5, r6, lr}
    304a:	2803      	cmp	r0, #3
    304c:	9d04      	ldr	r5, [sp, #16]
    304e:	d818      	bhi.n	3082 <pbuf_alloced_custom+0x3a>
	default:
		LWIP_ASSERT("pbuf_alloced_custom: bad pbuf layer", 0);
		return NULL;
	}

	if (LWIP_MEM_ALIGN_SIZE(offset) + length > payload_mem_len) {
    3050:	4c0d      	ldr	r4, [pc, #52]	; (3088 <pbuf_alloced_custom+0x40>)
    3052:	5c24      	ldrb	r4, [r4, r0]
    3054:	f8bd 0014 	ldrh.w	r0, [sp, #20]
    3058:	3403      	adds	r4, #3
    305a:	f024 0403 	bic.w	r4, r4, #3
    305e:	1866      	adds	r6, r4, r1
    3060:	4286      	cmp	r6, r0
    3062:	f04f 0000 	mov.w	r0, #0
    3066:	dc0b      	bgt.n	3080 <pbuf_alloced_custom+0x38>
		LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_LEVEL_WARNING,
		            ("pbuf_alloced_custom(length=%" U16_F ") buffer too short\n", length));
		return NULL;
	}

	p->pbuf.next = NULL;
    3068:	6018      	str	r0, [r3, #0]
	if (payload_mem != NULL) {
    306a:	b105      	cbz	r5, 306e <pbuf_alloced_custom+0x26>
		p->pbuf.payload = (u8_t *)payload_mem + LWIP_MEM_ALIGN_SIZE(offset);
    306c:	4425      	add	r5, r4
	} else {
		p->pbuf.payload = NULL;
	}
	p->pbuf.flags = PBUF_FLAG_IS_CUSTOM;
    306e:	2002      	movs	r0, #2
	p->pbuf.len = p->pbuf.tot_len = length;
	p->pbuf.type                  = type;
    3070:	731a      	strb	r2, [r3, #12]
	p->pbuf.ref                   = 1;
    3072:	2201      	movs	r2, #1
	p->pbuf.flags = PBUF_FLAG_IS_CUSTOM;
    3074:	7358      	strb	r0, [r3, #13]
    3076:	605d      	str	r5, [r3, #4]
	p->pbuf.len = p->pbuf.tot_len = length;
    3078:	8119      	strh	r1, [r3, #8]
    307a:	8159      	strh	r1, [r3, #10]
	p->pbuf.ref                   = 1;
    307c:	81da      	strh	r2, [r3, #14]
	return &p->pbuf;
    307e:	4618      	mov	r0, r3
}
    3080:	bd70      	pop	{r4, r5, r6, pc}
		return NULL;
    3082:	2000      	movs	r0, #0
    3084:	e7fc      	b.n	3080 <pbuf_alloced_custom+0x38>
    3086:	bf00      	nop
    3088:	0000b627 	.word	0x0000b627

0000308c <pbuf_header>:
 * not move the payload pointer in front of the start of the buffer.
 * @return non-zero on failure, zero on success.
 *
 */
u8_t pbuf_header(struct pbuf *p, s16_t header_size_increment)
{
    308c:	b530      	push	{r4, r5, lr}
	u16_t type;
	void *payload;
	u16_t increment_magnitude;

	LWIP_ASSERT("p != NULL", p != NULL);
	if ((header_size_increment == 0) || (p == NULL)) {
    308e:	b1d9      	cbz	r1, 30c8 <pbuf_header+0x3c>
    3090:	b1d8      	cbz	r0, 30ca <pbuf_header+0x3e>
		return 0;
	}

	if (header_size_increment < 0) {
    3092:	2900      	cmp	r1, #0
		increment_magnitude = -header_size_increment;
    3094:	b28a      	uxth	r2, r1
	if (header_size_increment < 0) {
    3096:	da05      	bge.n	30a4 <pbuf_header+0x18>
		/* Check that we aren't going to move off the end of the pbuf */
		LWIP_ERROR("increment_magnitude <= p->len", (increment_magnitude <= p->len), return 1;);
    3098:	8943      	ldrh	r3, [r0, #10]
		increment_magnitude = -header_size_increment;
    309a:	4254      	negs	r4, r2
    309c:	b2a4      	uxth	r4, r4
		LWIP_ERROR("increment_magnitude <= p->len", (increment_magnitude <= p->len), return 1;);
    309e:	42a3      	cmp	r3, r4
    30a0:	d201      	bcs.n	30a6 <pbuf_header+0x1a>
    30a2:	e7fe      	b.n	30a2 <pbuf_header+0x16>
	} else {
		increment_magnitude = header_size_increment;
    30a4:	4614      	mov	r4, r2
    LWIP_ASSERT("p->payload - increment_magnitude >= p + SIZEOF_STRUCT_PBUF",
                (u8_t *)p->payload - increment_magnitude >= (u8_t *)p + SIZEOF_STRUCT_PBUF);
#endif
	}

	type = p->type;
    30a6:	7b05      	ldrb	r5, [r0, #12]
	/* remember current payload pointer */
	payload = p->payload;
    30a8:	6843      	ldr	r3, [r0, #4]

	/* pbuf types containing payloads? */
	if (type == PBUF_RAM || type == PBUF_POOL) {
    30aa:	b10d      	cbz	r5, 30b0 <pbuf_header+0x24>
    30ac:	2d03      	cmp	r5, #3
    30ae:	d10d      	bne.n	30cc <pbuf_header+0x40>
		/* set new payload pointer */
		p->payload = (u8_t *)p->payload - header_size_increment;
    30b0:	1a59      	subs	r1, r3, r1
		/* boundary check fails? */
		if ((u8_t *)p->payload < (u8_t *)p + SIZEOF_STRUCT_PBUF) {
    30b2:	f100 0310 	add.w	r3, r0, #16
    30b6:	4299      	cmp	r1, r3
    30b8:	d312      	bcc.n	30e0 <pbuf_header+0x54>
		/* Unknown type */
		LWIP_ASSERT("bad pbuf type", 0);
		return 1;
	}
	/* modify pbuf length fields */
	p->len += header_size_increment;
    30ba:	8943      	ldrh	r3, [r0, #10]
			p->payload = (u8_t *)p->payload - header_size_increment;
    30bc:	6041      	str	r1, [r0, #4]
	p->len += header_size_increment;
    30be:	4413      	add	r3, r2
    30c0:	8143      	strh	r3, [r0, #10]
	p->tot_len += header_size_increment;
    30c2:	8903      	ldrh	r3, [r0, #8]
    30c4:	441a      	add	r2, r3
    30c6:	8102      	strh	r2, [r0, #8]

	LWIP_DEBUGF(
	    PBUF_DEBUG | LWIP_DBG_TRACE,
	    ("pbuf_header: old %p new %p (%" S16_F ")\n", (void *)payload, (void *)p->payload, header_size_increment));

	return 0;
    30c8:	2000      	movs	r0, #0
}
    30ca:	bd30      	pop	{r4, r5, pc}
	} else if (type == PBUF_REF || type == PBUF_ROM) {
    30cc:	3d01      	subs	r5, #1
    30ce:	2d01      	cmp	r5, #1
    30d0:	d806      	bhi.n	30e0 <pbuf_header+0x54>
		if ((header_size_increment < 0) && (increment_magnitude <= p->len)) {
    30d2:	2900      	cmp	r1, #0
    30d4:	da04      	bge.n	30e0 <pbuf_header+0x54>
    30d6:	8945      	ldrh	r5, [r0, #10]
    30d8:	42a5      	cmp	r5, r4
    30da:	d301      	bcc.n	30e0 <pbuf_header+0x54>
			p->payload = (u8_t *)p->payload - header_size_increment;
    30dc:	1a59      	subs	r1, r3, r1
    30de:	e7ec      	b.n	30ba <pbuf_header+0x2e>
		return 1;
    30e0:	2001      	movs	r0, #1
    30e2:	e7f2      	b.n	30ca <pbuf_header+0x3e>

000030e4 <pbuf_free>:
 * 2->1->1 becomes 1->1->1
 * 1->1->1 becomes .......
 *
 */
u8_t pbuf_free(struct pbuf *p)
{
    30e4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	u16_t        type;
	struct pbuf *q;
	u8_t         count;

	if (p == NULL) {
    30e6:	b318      	cbz	r0, 3130 <pbuf_free+0x4c>
					/* is this a ROM or RAM referencing pbuf? */
				} else if (type == PBUF_ROM || type == PBUF_REF) {
					memp_free(MEMP_PBUF, p);
					/* type == PBUF_RAM */
				} else {
					mem_free(p);
    30e8:	4e12      	ldr	r6, [pc, #72]	; (3134 <pbuf_free+0x50>)
					memp_free(MEMP_PBUF, p);
    30ea:	4d13      	ldr	r5, [pc, #76]	; (3138 <pbuf_free+0x54>)
	count = 0;
    30ec:	2400      	movs	r4, #0
		ref = --(p->ref);
    30ee:	89c3      	ldrh	r3, [r0, #14]
    30f0:	3b01      	subs	r3, #1
    30f2:	b29b      	uxth	r3, r3
    30f4:	81c3      	strh	r3, [r0, #14]
		if (ref == 0) {
    30f6:	b943      	cbnz	r3, 310a <pbuf_free+0x26>
			if ((p->flags & PBUF_FLAG_IS_CUSTOM) != 0) {
    30f8:	7b43      	ldrb	r3, [r0, #13]
			q = p->next;
    30fa:	6807      	ldr	r7, [r0, #0]
			if ((p->flags & PBUF_FLAG_IS_CUSTOM) != 0) {
    30fc:	079b      	lsls	r3, r3, #30
    30fe:	d508      	bpl.n	3112 <pbuf_free+0x2e>
				pc->custom_free_function(p);
    3100:	6903      	ldr	r3, [r0, #16]
    3102:	4798      	blx	r3
				}
			}
			count++;
    3104:	3401      	adds	r4, #1
    3106:	b2e4      	uxtb	r4, r4
	while (p != NULL) {
    3108:	b90f      	cbnz	r7, 310e <pbuf_free+0x2a>
		}
	}
	PERF_STOP("pbuf_free");
	/* return number of de-allocated pbufs */
	return count;
}
    310a:	4620      	mov	r0, r4
    310c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    310e:	4638      	mov	r0, r7
    3110:	e7ed      	b.n	30ee <pbuf_free+0xa>
			type = p->type;
    3112:	7b03      	ldrb	r3, [r0, #12]
				if (type == PBUF_POOL) {
    3114:	2b03      	cmp	r3, #3
    3116:	d103      	bne.n	3120 <pbuf_free+0x3c>
					memp_free(MEMP_PBUF_POOL, p);
    3118:	4601      	mov	r1, r0
    311a:	200c      	movs	r0, #12
					memp_free(MEMP_PBUF, p);
    311c:	47a8      	blx	r5
    311e:	e7f1      	b.n	3104 <pbuf_free+0x20>
				} else if (type == PBUF_ROM || type == PBUF_REF) {
    3120:	3b01      	subs	r3, #1
    3122:	2b01      	cmp	r3, #1
    3124:	d802      	bhi.n	312c <pbuf_free+0x48>
					memp_free(MEMP_PBUF, p);
    3126:	4601      	mov	r1, r0
    3128:	200b      	movs	r0, #11
    312a:	e7f7      	b.n	311c <pbuf_free+0x38>
					mem_free(p);
    312c:	47b0      	blx	r6
    312e:	e7e9      	b.n	3104 <pbuf_free+0x20>
		return 0;
    3130:	4604      	mov	r4, r0
    3132:	e7ea      	b.n	310a <pbuf_free+0x26>
    3134:	00006679 	.word	0x00006679
    3138:	00004c1d 	.word	0x00004c1d

0000313c <pbuf_alloc>:
	switch (layer) {
    313c:	2803      	cmp	r0, #3
{
    313e:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    3142:	460e      	mov	r6, r1
    3144:	4617      	mov	r7, r2
    3146:	d901      	bls.n	314c <pbuf_alloc+0x10>
	switch (type) {
    3148:	2400      	movs	r4, #0
    314a:	e01b      	b.n	3184 <pbuf_alloc+0x48>
    314c:	4b3a      	ldr	r3, [pc, #232]	; (3238 <pbuf_alloc+0xfc>)
    314e:	2a02      	cmp	r2, #2
    3150:	5c1d      	ldrb	r5, [r3, r0]
    3152:	d80d      	bhi.n	3170 <pbuf_alloc+0x34>
    3154:	2a00      	cmp	r2, #0
    3156:	d056      	beq.n	3206 <pbuf_alloc+0xca>
		p = (struct pbuf *)memp_malloc(MEMP_PBUF);
    3158:	4b38      	ldr	r3, [pc, #224]	; (323c <pbuf_alloc+0x100>)
    315a:	200b      	movs	r0, #11
    315c:	4798      	blx	r3
		if (p == NULL) {
    315e:	4604      	mov	r4, r0
    3160:	2800      	cmp	r0, #0
    3162:	d0f1      	beq.n	3148 <pbuf_alloc+0xc>
		p->payload = NULL;
    3164:	2300      	movs	r3, #0
    3166:	6043      	str	r3, [r0, #4]
		p->len = p->tot_len = length;
    3168:	8106      	strh	r6, [r0, #8]
    316a:	8146      	strh	r6, [r0, #10]
		p->next             = NULL;
    316c:	6003      	str	r3, [r0, #0]
    316e:	e060      	b.n	3232 <pbuf_alloc+0xf6>
	switch (type) {
    3170:	2a03      	cmp	r2, #3
    3172:	d1e9      	bne.n	3148 <pbuf_alloc+0xc>
		p = (struct pbuf *)memp_malloc(MEMP_PBUF_POOL);
    3174:	f8df 80c4 	ldr.w	r8, [pc, #196]	; 323c <pbuf_alloc+0x100>
    3178:	200c      	movs	r0, #12
    317a:	47c0      	blx	r8
		if (p == NULL) {
    317c:	4604      	mov	r4, r0
    317e:	b920      	cbnz	r0, 318a <pbuf_alloc+0x4e>
			PBUF_POOL_IS_EMPTY();
    3180:	4b2f      	ldr	r3, [pc, #188]	; (3240 <pbuf_alloc+0x104>)
    3182:	4798      	blx	r3
}
    3184:	4620      	mov	r0, r4
    3186:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
		p->payload = LWIP_MEM_ALIGN((void *)((u8_t *)p + (SIZEOF_STRUCT_PBUF + offset)));
    318a:	1943      	adds	r3, r0, r5
    318c:	3313      	adds	r3, #19
    318e:	f023 0303 	bic.w	r3, r3, #3
		p->len = LWIP_MIN(length, PBUF_POOL_BUFSIZE_ALIGNED - LWIP_MEM_ALIGN_SIZE(offset));
    3192:	3503      	adds	r5, #3
		p->payload = LWIP_MEM_ALIGN((void *)((u8_t *)p + (SIZEOF_STRUCT_PBUF + offset)));
    3194:	6043      	str	r3, [r0, #4]
		p->len = LWIP_MIN(length, PBUF_POOL_BUFSIZE_ALIGNED - LWIP_MEM_ALIGN_SIZE(offset));
    3196:	f025 0303 	bic.w	r3, r5, #3
    319a:	f5c3 65bd 	rsb	r5, r3, #1512	; 0x5e8
    319e:	3504      	adds	r5, #4
    31a0:	42b5      	cmp	r5, r6
    31a2:	bfa8      	it	ge
    31a4:	4635      	movge	r5, r6
		p->next = NULL;
    31a6:	f04f 0900 	mov.w	r9, #0
		p->ref = 1;
    31aa:	2301      	movs	r3, #1
		p->len = LWIP_MIN(length, PBUF_POOL_BUFSIZE_ALIGNED - LWIP_MEM_ALIGN_SIZE(offset));
    31ac:	8145      	strh	r5, [r0, #10]
		p->type = type;
    31ae:	7307      	strb	r7, [r0, #12]
		p->next = NULL;
    31b0:	f8c0 9000 	str.w	r9, [r0]
		p->tot_len = length;
    31b4:	8106      	strh	r6, [r0, #8]
		p->ref = 1;
    31b6:	81c3      	strh	r3, [r0, #14]
		rem_len = length - p->len;
    31b8:	1b75      	subs	r5, r6, r5
		while (rem_len > 0) {
    31ba:	4682      	mov	sl, r0
    31bc:	2d00      	cmp	r5, #0
    31be:	dc04      	bgt.n	31ca <pbuf_alloc+0x8e>
	p->ref = 1;
    31c0:	2301      	movs	r3, #1
    31c2:	81e3      	strh	r3, [r4, #14]
	p->flags = 0;
    31c4:	2300      	movs	r3, #0
    31c6:	7363      	strb	r3, [r4, #13]
	return p;
    31c8:	e7dc      	b.n	3184 <pbuf_alloc+0x48>
			q = (struct pbuf *)memp_malloc(MEMP_PBUF_POOL);
    31ca:	200c      	movs	r0, #12
    31cc:	47c0      	blx	r8
			if (q == NULL) {
    31ce:	b928      	cbnz	r0, 31dc <pbuf_alloc+0xa0>
				PBUF_POOL_IS_EMPTY();
    31d0:	4b1b      	ldr	r3, [pc, #108]	; (3240 <pbuf_alloc+0x104>)
    31d2:	4798      	blx	r3
				pbuf_free(p);
    31d4:	4b1b      	ldr	r3, [pc, #108]	; (3244 <pbuf_alloc+0x108>)
    31d6:	4620      	mov	r0, r4
    31d8:	4798      	blx	r3
				return NULL;
    31da:	e7b5      	b.n	3148 <pbuf_alloc+0xc>
			q->tot_len = (u16_t)rem_len;
    31dc:	b2ab      	uxth	r3, r5
			q->len     = LWIP_MIN((u16_t)rem_len, PBUF_POOL_BUFSIZE_ALIGNED);
    31de:	f240 52ec 	movw	r2, #1516	; 0x5ec
    31e2:	4293      	cmp	r3, r2
			q->type  = type;
    31e4:	8187      	strh	r7, [r0, #12]
			q->next  = NULL;
    31e6:	f8c0 9000 	str.w	r9, [r0]
			r->next = q;
    31ea:	f8ca 0000 	str.w	r0, [sl]
			q->tot_len = (u16_t)rem_len;
    31ee:	8103      	strh	r3, [r0, #8]
			q->len     = LWIP_MIN((u16_t)rem_len, PBUF_POOL_BUFSIZE_ALIGNED);
    31f0:	bf28      	it	cs
    31f2:	4613      	movcs	r3, r2
			q->payload = (void *)((u8_t *)q + SIZEOF_STRUCT_PBUF);
    31f4:	f100 0210 	add.w	r2, r0, #16
    31f8:	6042      	str	r2, [r0, #4]
			q->ref = 1;
    31fa:	2201      	movs	r2, #1
			q->len     = LWIP_MIN((u16_t)rem_len, PBUF_POOL_BUFSIZE_ALIGNED);
    31fc:	8143      	strh	r3, [r0, #10]
			q->ref = 1;
    31fe:	81c2      	strh	r2, [r0, #14]
			rem_len -= q->len;
    3200:	1aed      	subs	r5, r5, r3
    3202:	4682      	mov	sl, r0
    3204:	e7da      	b.n	31bc <pbuf_alloc+0x80>
		p = (struct pbuf *)mem_malloc(LWIP_MEM_ALIGN_SIZE(SIZEOF_STRUCT_PBUF + offset) + LWIP_MEM_ALIGN_SIZE(length));
    3206:	1ccb      	adds	r3, r1, #3
    3208:	f105 0013 	add.w	r0, r5, #19
    320c:	f023 0303 	bic.w	r3, r3, #3
    3210:	f020 0003 	bic.w	r0, r0, #3
    3214:	4418      	add	r0, r3
    3216:	b280      	uxth	r0, r0
    3218:	4b0b      	ldr	r3, [pc, #44]	; (3248 <pbuf_alloc+0x10c>)
    321a:	4798      	blx	r3
		if (p == NULL) {
    321c:	4604      	mov	r4, r0
    321e:	2800      	cmp	r0, #0
    3220:	d092      	beq.n	3148 <pbuf_alloc+0xc>
		p->payload = LWIP_MEM_ALIGN((void *)((u8_t *)p + SIZEOF_STRUCT_PBUF + offset));
    3222:	1943      	adds	r3, r0, r5
    3224:	3313      	adds	r3, #19
    3226:	f023 0303 	bic.w	r3, r3, #3
    322a:	6043      	str	r3, [r0, #4]
		p->len = p->tot_len = length;
    322c:	8106      	strh	r6, [r0, #8]
    322e:	8146      	strh	r6, [r0, #10]
		p->next             = NULL;
    3230:	6007      	str	r7, [r0, #0]
		p->type             = type;
    3232:	7327      	strb	r7, [r4, #12]
		break;
    3234:	e7c4      	b.n	31c0 <pbuf_alloc+0x84>
    3236:	bf00      	nop
    3238:	0000b627 	.word	0x0000b627
    323c:	00004c01 	.word	0x00004c01
    3240:	0000301d 	.word	0x0000301d
    3244:	000030e5 	.word	0x000030e5
    3248:	00006805 	.word	0x00006805

0000324c <pbuf_realloc>:
{
    324c:	b538      	push	{r3, r4, r5, lr}
	if (new_len >= p->tot_len) {
    324e:	8903      	ldrh	r3, [r0, #8]
    3250:	428b      	cmp	r3, r1
{
    3252:	4604      	mov	r4, r0
	if (new_len >= p->tot_len) {
    3254:	d918      	bls.n	3288 <pbuf_realloc+0x3c>
    3256:	460d      	mov	r5, r1
		q->tot_len += (u16_t)grow;
    3258:	1aca      	subs	r2, r1, r3
	while (rem_len > q->len) {
    325a:	8963      	ldrh	r3, [r4, #10]
    325c:	42ab      	cmp	r3, r5
    325e:	d314      	bcc.n	328a <pbuf_realloc+0x3e>
	if ((q->type == PBUF_RAM) && (rem_len != q->len)) {
    3260:	7b22      	ldrb	r2, [r4, #12]
    3262:	b94a      	cbnz	r2, 3278 <pbuf_realloc+0x2c>
    3264:	42ab      	cmp	r3, r5
    3266:	d007      	beq.n	3278 <pbuf_realloc+0x2c>
		q = (struct pbuf *)mem_trim(q, (u16_t)((u8_t *)q->payload - (u8_t *)q) + rem_len);
    3268:	6861      	ldr	r1, [r4, #4]
    326a:	4b0b      	ldr	r3, [pc, #44]	; (3298 <pbuf_realloc+0x4c>)
    326c:	1b09      	subs	r1, r1, r4
    326e:	4429      	add	r1, r5
    3270:	4620      	mov	r0, r4
    3272:	b289      	uxth	r1, r1
    3274:	4798      	blx	r3
    3276:	4604      	mov	r4, r0
	if (q->next != NULL) {
    3278:	6820      	ldr	r0, [r4, #0]
	q->len     = rem_len;
    327a:	8165      	strh	r5, [r4, #10]
	q->tot_len = q->len;
    327c:	8125      	strh	r5, [r4, #8]
	if (q->next != NULL) {
    327e:	b108      	cbz	r0, 3284 <pbuf_realloc+0x38>
		pbuf_free(q->next);
    3280:	4b06      	ldr	r3, [pc, #24]	; (329c <pbuf_realloc+0x50>)
    3282:	4798      	blx	r3
	q->next = NULL;
    3284:	2300      	movs	r3, #0
    3286:	6023      	str	r3, [r4, #0]
}
    3288:	bd38      	pop	{r3, r4, r5, pc}
		rem_len -= q->len;
    328a:	1aed      	subs	r5, r5, r3
		q->tot_len += (u16_t)grow;
    328c:	8923      	ldrh	r3, [r4, #8]
    328e:	4413      	add	r3, r2
    3290:	8123      	strh	r3, [r4, #8]
		rem_len -= q->len;
    3292:	b2ad      	uxth	r5, r5
		q = q->next;
    3294:	6824      	ldr	r4, [r4, #0]
    3296:	e7e0      	b.n	325a <pbuf_realloc+0xe>
    3298:	00006719 	.word	0x00006719
    329c:	000030e5 	.word	0x000030e5

000032a0 <pbuf_clen>:
 * @param p first pbuf of chain
 * @return the number of pbufs in a chain
 */

u8_t pbuf_clen(struct pbuf *p)
{
    32a0:	4603      	mov	r3, r0
	u8_t len;

	len = 0;
	while (p != NULL) {
    32a2:	2200      	movs	r2, #0
    32a4:	b2d0      	uxtb	r0, r2
    32a6:	3201      	adds	r2, #1
    32a8:	b903      	cbnz	r3, 32ac <pbuf_clen+0xc>
		++len;
		p = p->next;
	}
	return len;
}
    32aa:	4770      	bx	lr
		p = p->next;
    32ac:	681b      	ldr	r3, [r3, #0]
    32ae:	e7f9      	b.n	32a4 <pbuf_clen+0x4>

000032b0 <pbuf_ref>:
 */
void pbuf_ref(struct pbuf *p)
{
	SYS_ARCH_DECL_PROTECT(old_level);
	/* pbuf given? */
	if (p != NULL) {
    32b0:	b110      	cbz	r0, 32b8 <pbuf_ref+0x8>
		SYS_ARCH_PROTECT(old_level);
		++(p->ref);
    32b2:	89c3      	ldrh	r3, [r0, #14]
    32b4:	3301      	adds	r3, #1
    32b6:	81c3      	strh	r3, [r0, #14]
		SYS_ARCH_UNPROTECT(old_level);
	}
}
    32b8:	4770      	bx	lr

000032ba <pbuf_cat>:
 *
 * @see pbuf_chain()
 */

void pbuf_cat(struct pbuf *h, struct pbuf *t)
{
    32ba:	b510      	push	{r4, lr}
	struct pbuf *p;

	LWIP_ERROR("(h != NULL) && (t != NULL) (programmer violates API)", ((h != NULL) && (t != NULL)), return;);
    32bc:	b100      	cbz	r0, 32c0 <pbuf_cat+0x6>
    32be:	b909      	cbnz	r1, 32c4 <pbuf_cat+0xa>
    32c0:	e7fe      	b.n	32c0 <pbuf_cat+0x6>

	/* proceed to last pbuf of chain */
	for (p = h; p->next != NULL; p = p->next) {
		/* add total length of second chain to all totals of first chain */
		p->tot_len += t->tot_len;
    32c2:	4610      	mov	r0, r2
    32c4:	890b      	ldrh	r3, [r1, #8]
    32c6:	8904      	ldrh	r4, [r0, #8]
	for (p = h; p->next != NULL; p = p->next) {
    32c8:	6802      	ldr	r2, [r0, #0]
		p->tot_len += t->tot_len;
    32ca:	4423      	add	r3, r4
    32cc:	b29b      	uxth	r3, r3
    32ce:	8103      	strh	r3, [r0, #8]
	for (p = h; p->next != NULL; p = p->next) {
    32d0:	2a00      	cmp	r2, #0
    32d2:	d1f6      	bne.n	32c2 <pbuf_cat+0x8>
	LWIP_ASSERT("p->tot_len == p->len (of last pbuf in chain)", p->tot_len == p->len);
	LWIP_ASSERT("p->next == NULL", p->next == NULL);
	/* add total length of second chain to last pbuf total of first chain */
	p->tot_len += t->tot_len;
	/* chain last pbuf of head (p) with first of tail (t) */
	p->next = t;
    32d4:	6001      	str	r1, [r0, #0]
	/* p->next now references t, but the caller will drop its reference to t,
	 * so netto there is no change to the reference count of t.
	 */
}
    32d6:	bd10      	pop	{r4, pc}

000032d8 <pbuf_chain>:
 * The ->next field of the last pbuf of the head chain is adjusted.
 * The ->ref field of the first pbuf of the tail chain is adjusted.
 *
 */
void pbuf_chain(struct pbuf *h, struct pbuf *t)
{
    32d8:	b510      	push	{r4, lr}
	pbuf_cat(h, t);
    32da:	4b03      	ldr	r3, [pc, #12]	; (32e8 <pbuf_chain+0x10>)
    32dc:	4798      	blx	r3
	/* t is now referenced by h */
	pbuf_ref(t);
	LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_chain: %p references %p\n", (void *)h, (void *)t));
}
    32de:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	pbuf_ref(t);
    32e2:	4b02      	ldr	r3, [pc, #8]	; (32ec <pbuf_chain+0x14>)
    32e4:	4608      	mov	r0, r1
    32e6:	4718      	bx	r3
    32e8:	000032bb 	.word	0x000032bb
    32ec:	000032b1 	.word	0x000032b1

000032f0 <pbuf_copy>:
 * @return ERR_OK if pbuf was copied
 *         ERR_ARG if one of the pbufs is NULL or p_to is not big
 *                 enough to hold p_from
 */
err_t pbuf_copy(struct pbuf *p_to, struct pbuf *p_from)
{
    32f0:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    32f4:	460c      	mov	r4, r1
	u16_t offset_to = 0, offset_from = 0, len;

	LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_copy(%p, %p)\n", (void *)p_to, (void *)p_from));

	/* is the target big enough to hold the source? */
	LWIP_ERROR("pbuf_copy: target not big enough to hold source",
    32f6:	4605      	mov	r5, r0
    32f8:	b120      	cbz	r0, 3304 <pbuf_copy+0x14>
    32fa:	b119      	cbz	r1, 3304 <pbuf_copy+0x14>
    32fc:	8902      	ldrh	r2, [r0, #8]
    32fe:	890b      	ldrh	r3, [r1, #8]
    3300:	429a      	cmp	r2, r3
    3302:	d200      	bcs.n	3306 <pbuf_copy+0x16>
    3304:	e7fe      	b.n	3304 <pbuf_copy+0x14>
	u16_t offset_to = 0, offset_from = 0, len;
    3306:	f04f 0800 	mov.w	r8, #0
			len = p_from->len - offset_from;
		} else {
			/* current p_from does not fit into current p_to */
			len = p_to->len - offset_to;
		}
		MEMCPY((u8_t *)p_to->payload + offset_to, (u8_t *)p_from->payload + offset_from, len);
    330a:	f8df 9074 	ldr.w	r9, [pc, #116]	; 3380 <pbuf_copy+0x90>
	u16_t offset_to = 0, offset_from = 0, len;
    330e:	4647      	mov	r7, r8
		if ((p_to->len - offset_to) >= (p_from->len - offset_from)) {
    3310:	8962      	ldrh	r2, [r4, #10]
    3312:	896e      	ldrh	r6, [r5, #10]
		MEMCPY((u8_t *)p_to->payload + offset_to, (u8_t *)p_from->payload + offset_from, len);
    3314:	6861      	ldr	r1, [r4, #4]
    3316:	6868      	ldr	r0, [r5, #4]
		if ((p_to->len - offset_to) >= (p_from->len - offset_from)) {
    3318:	1bf6      	subs	r6, r6, r7
    331a:	eba2 0208 	sub.w	r2, r2, r8
    331e:	4296      	cmp	r6, r2
			len = p_from->len - offset_from;
    3320:	bfac      	ite	ge
    3322:	b296      	uxthge	r6, r2
			len = p_to->len - offset_to;
    3324:	b2b6      	uxthlt	r6, r6
		MEMCPY((u8_t *)p_to->payload + offset_to, (u8_t *)p_from->payload + offset_from, len);
    3326:	4632      	mov	r2, r6
    3328:	4441      	add	r1, r8
    332a:	4438      	add	r0, r7
    332c:	47c8      	blx	r9
		offset_to += len;
    332e:	4437      	add	r7, r6
		offset_from += len;
		LWIP_ASSERT("offset_to <= p_to->len", offset_to <= p_to->len);
		LWIP_ASSERT("offset_from <= p_from->len", offset_from <= p_from->len);
		if (offset_from >= p_from->len) {
    3330:	8963      	ldrh	r3, [r4, #10]
		offset_from += len;
    3332:	4446      	add	r6, r8
    3334:	fa1f f886 	uxth.w	r8, r6
		if (offset_from >= p_from->len) {
    3338:	4543      	cmp	r3, r8
			/* on to next p_from (if any) */
			offset_from = 0;
			p_from      = p_from->next;
		}
		if (offset_to == p_to->len) {
    333a:	896b      	ldrh	r3, [r5, #10]
			p_from      = p_from->next;
    333c:	bf98      	it	ls
    333e:	6824      	ldrls	r4, [r4, #0]
		offset_to += len;
    3340:	b2bf      	uxth	r7, r7
			offset_from = 0;
    3342:	bf98      	it	ls
    3344:	f04f 0800 	movls.w	r8, #0
		if (offset_to == p_to->len) {
    3348:	42bb      	cmp	r3, r7
    334a:	d104      	bne.n	3356 <pbuf_copy+0x66>
			/* on to next p_to (if any) */
			offset_to = 0;
			p_to      = p_to->next;
    334c:	682d      	ldr	r5, [r5, #0]
			LWIP_ERROR("p_to != NULL", (p_to != NULL) || (p_from == NULL), return ERR_ARG;);
    334e:	b90d      	cbnz	r5, 3354 <pbuf_copy+0x64>
    3350:	b194      	cbz	r4, 3378 <pbuf_copy+0x88>
    3352:	e7fe      	b.n	3352 <pbuf_copy+0x62>
			offset_to = 0;
    3354:	2700      	movs	r7, #0
		}

		if ((p_from != NULL) && (p_from->len == p_from->tot_len)) {
    3356:	b134      	cbz	r4, 3366 <pbuf_copy+0x76>
    3358:	8962      	ldrh	r2, [r4, #10]
    335a:	8923      	ldrh	r3, [r4, #8]
    335c:	429a      	cmp	r2, r3
    335e:	d102      	bne.n	3366 <pbuf_copy+0x76>
			/* don't copy more than one packet! */
			LWIP_ERROR("pbuf_copy() does not allow packet queues!\n", (p_from->next == NULL), return ERR_VAL;);
    3360:	6823      	ldr	r3, [r4, #0]
    3362:	b103      	cbz	r3, 3366 <pbuf_copy+0x76>
    3364:	e7fe      	b.n	3364 <pbuf_copy+0x74>
		}
		if ((p_to != NULL) && (p_to->len == p_to->tot_len)) {
    3366:	896a      	ldrh	r2, [r5, #10]
    3368:	892b      	ldrh	r3, [r5, #8]
    336a:	429a      	cmp	r2, r3
    336c:	d102      	bne.n	3374 <pbuf_copy+0x84>
			/* don't copy more than one packet! */
			LWIP_ERROR("pbuf_copy() does not allow packet queues!\n", (p_to->next == NULL), return ERR_VAL;);
    336e:	682b      	ldr	r3, [r5, #0]
    3370:	b103      	cbz	r3, 3374 <pbuf_copy+0x84>
    3372:	e7fe      	b.n	3372 <pbuf_copy+0x82>
		}
	} while (p_from);
    3374:	2c00      	cmp	r4, #0
    3376:	d1cb      	bne.n	3310 <pbuf_copy+0x20>
	LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_copy: end of chain reached.\n"));
	return ERR_OK;
}
    3378:	2000      	movs	r0, #0
    337a:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    337e:	bf00      	nop
    3380:	0000a349 	.word	0x0000a349

00003384 <pbuf_copy_partial>:
 * than buf->tot_len will be copied, irrespective of len
 * @param offset offset into the packet buffer from where to begin copying len bytes
 * @return the number of bytes copied, or 0 on failure
 */
u16_t pbuf_copy_partial(struct pbuf *buf, void *dataptr, u16_t len, u16_t offset)
{
    3384:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    3388:	4688      	mov	r8, r1
    338a:	4617      	mov	r7, r2
	struct pbuf *p;
	u16_t        left;
	u16_t        buf_copy_len;
	u16_t        copied_total = 0;

	LWIP_ERROR("pbuf_copy_partial: invalid buf", (buf != NULL), return 0;);
    338c:	4605      	mov	r5, r0
    338e:	b900      	cbnz	r0, 3392 <pbuf_copy_partial+0xe>
    3390:	e7fe      	b.n	3390 <pbuf_copy_partial+0xc>
	LWIP_ERROR("pbuf_copy_partial: invalid dataptr", (dataptr != NULL), return 0;);
    3392:	b9f1      	cbnz	r1, 33d2 <pbuf_copy_partial+0x4e>
    3394:	e7fe      	b.n	3394 <pbuf_copy_partial+0x10>
		return 0;
	}

	/* Note some systems use byte copy if dataptr or one of the pbuf payload pointers are unaligned. */
	for (p = buf; len != 0 && p != NULL; p = p->next) {
		if ((offset != 0) && (offset >= p->len)) {
    3396:	896c      	ldrh	r4, [r5, #10]
    3398:	b153      	cbz	r3, 33b0 <pbuf_copy_partial+0x2c>
    339a:	42a3      	cmp	r3, r4
    339c:	d308      	bcc.n	33b0 <pbuf_copy_partial+0x2c>
			/* don't copy from this buffer -> on to the next */
			offset -= p->len;
    339e:	1b1b      	subs	r3, r3, r4
    33a0:	b29b      	uxth	r3, r3
	for (p = buf; len != 0 && p != NULL; p = p->next) {
    33a2:	682d      	ldr	r5, [r5, #0]
    33a4:	b10f      	cbz	r7, 33aa <pbuf_copy_partial+0x26>
    33a6:	2d00      	cmp	r5, #0
    33a8:	d1f5      	bne.n	3396 <pbuf_copy_partial+0x12>
			len -= buf_copy_len;
			offset = 0;
		}
	}
	return copied_total;
}
    33aa:	4630      	mov	r0, r6
    33ac:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
			buf_copy_len = p->len - offset;
    33b0:	1ae4      	subs	r4, r4, r3
    33b2:	b2a4      	uxth	r4, r4
			if (buf_copy_len > len)
    33b4:	42bc      	cmp	r4, r7
			MEMCPY(&((char *)dataptr)[left], &((char *)p->payload)[offset], buf_copy_len);
    33b6:	6869      	ldr	r1, [r5, #4]
    33b8:	bf28      	it	cs
    33ba:	463c      	movcs	r4, r7
    33bc:	4419      	add	r1, r3
    33be:	eb08 0006 	add.w	r0, r8, r6
    33c2:	4622      	mov	r2, r4
			copied_total += buf_copy_len;
    33c4:	4426      	add	r6, r4
			len -= buf_copy_len;
    33c6:	1b3f      	subs	r7, r7, r4
			MEMCPY(&((char *)dataptr)[left], &((char *)p->payload)[offset], buf_copy_len);
    33c8:	47c8      	blx	r9
			copied_total += buf_copy_len;
    33ca:	b2b6      	uxth	r6, r6
			len -= buf_copy_len;
    33cc:	b2bf      	uxth	r7, r7
			offset = 0;
    33ce:	2300      	movs	r3, #0
    33d0:	e7e7      	b.n	33a2 <pbuf_copy_partial+0x1e>
			MEMCPY(&((char *)dataptr)[left], &((char *)p->payload)[offset], buf_copy_len);
    33d2:	f8df 9008 	ldr.w	r9, [pc, #8]	; 33dc <pbuf_copy_partial+0x58>
	left = 0;
    33d6:	2600      	movs	r6, #0
    33d8:	e7e4      	b.n	33a4 <pbuf_copy_partial+0x20>
    33da:	bf00      	nop
    33dc:	0000a349 	.word	0x0000a349

000033e0 <tcp_parseopt>:
 * Currently, only the MSS option is supported!
 *
 * @param pcb the tcp_pcb for which a segment arrived
 */
static void tcp_parseopt(struct tcp_pcb *pcb)
{
    33e0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	u8_t *opts, opt;
#if LWIP_TCP_TIMESTAMPS
	u32_t tsval;
#endif

	opts = (u8_t *)tcphdr + TCP_HLEN;
    33e2:	4f1f      	ldr	r7, [pc, #124]	; (3460 <tcp_parseopt+0x80>)

	/* Parse the TCP MSS option, if present. */
	if (TCPH_HDRLEN(tcphdr) > 0x5) {
    33e4:	4e1f      	ldr	r6, [pc, #124]	; (3464 <tcp_parseopt+0x84>)
	opts = (u8_t *)tcphdr + TCP_HLEN;
    33e6:	683c      	ldr	r4, [r7, #0]
{
    33e8:	4605      	mov	r5, r0
	if (TCPH_HDRLEN(tcphdr) > 0x5) {
    33ea:	89a0      	ldrh	r0, [r4, #12]
    33ec:	47b0      	blx	r6
    33ee:	f3c0 300f 	ubfx	r0, r0, #12, #16
    33f2:	2805      	cmp	r0, #5
    33f4:	d914      	bls.n	3420 <tcp_parseopt+0x40>
		max_c = (TCPH_HDRLEN(tcphdr) - 5) << 2;
    33f6:	683b      	ldr	r3, [r7, #0]
    33f8:	8998      	ldrh	r0, [r3, #12]
    33fa:	47b0      	blx	r6
    33fc:	0b02      	lsrs	r2, r0, #12
    33fe:	3a05      	subs	r2, #5
    3400:	0092      	lsls	r2, r2, #2
	opts = (u8_t *)tcphdr + TCP_HLEN;
    3402:	3414      	adds	r4, #20
		max_c = (TCPH_HDRLEN(tcphdr) - 5) << 2;
    3404:	b292      	uxth	r2, r2
		for (c = 0; c < max_c;) {
    3406:	2300      	movs	r3, #0
					return;
				}
				/* An MSS option with the right option length. */
				mss = (opts[c + 2] << 8) | opts[c + 3];
				/* Limit the mss to the configured TCP_MSS and prevent division by zero */
				pcb->mss = ((mss > TCP_MSS) || (mss == 0)) ? TCP_MSS : mss;
    3408:	f240 56b3 	movw	r6, #1459	; 0x5b3
    340c:	f240 57b4 	movw	r7, #1460	; 0x5b4
		for (c = 0; c < max_c;) {
    3410:	4293      	cmp	r3, r2
    3412:	d205      	bcs.n	3420 <tcp_parseopt+0x40>
			opt = opts[c];
    3414:	5ce1      	ldrb	r1, [r4, r3]
			switch (opt) {
    3416:	2901      	cmp	r1, #1
    3418:	d003      	beq.n	3422 <tcp_parseopt+0x42>
    341a:	2902      	cmp	r1, #2
    341c:	d004      	beq.n	3428 <tcp_parseopt+0x48>
    341e:	b9c1      	cbnz	r1, 3452 <tcp_parseopt+0x72>
				   can skip past them. */
				c += opts[c + 1];
			}
		}
	}
}
    3420:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
				++c;
    3422:	3301      	adds	r3, #1
				c += opts[c + 1];
    3424:	b29b      	uxth	r3, r3
    3426:	e7f3      	b.n	3410 <tcp_parseopt+0x30>
				if (opts[c + 1] != 0x04 || c + 0x04 > max_c) {
    3428:	18e0      	adds	r0, r4, r3
    342a:	7841      	ldrb	r1, [r0, #1]
    342c:	2904      	cmp	r1, #4
    342e:	d1f7      	bne.n	3420 <tcp_parseopt+0x40>
    3430:	1cd9      	adds	r1, r3, #3
    3432:	b289      	uxth	r1, r1
    3434:	428a      	cmp	r2, r1
    3436:	d9f3      	bls.n	3420 <tcp_parseopt+0x40>
				mss = (opts[c + 2] << 8) | opts[c + 3];
    3438:	f890 c002 	ldrb.w	ip, [r0, #2]
    343c:	78c1      	ldrb	r1, [r0, #3]
    343e:	ea41 210c 	orr.w	r1, r1, ip, lsl #8
				pcb->mss = ((mss > TCP_MSS) || (mss == 0)) ? TCP_MSS : mss;
    3442:	1e48      	subs	r0, r1, #1
    3444:	b280      	uxth	r0, r0
    3446:	42b0      	cmp	r0, r6
    3448:	bf88      	it	hi
    344a:	4639      	movhi	r1, r7
    344c:	86e9      	strh	r1, [r5, #54]	; 0x36
				c += 0x04;
    344e:	3304      	adds	r3, #4
    3450:	e7e8      	b.n	3424 <tcp_parseopt+0x44>
				if (opts[c + 1] == 0) {
    3452:	18e1      	adds	r1, r4, r3
    3454:	7849      	ldrb	r1, [r1, #1]
    3456:	2900      	cmp	r1, #0
    3458:	d0e2      	beq.n	3420 <tcp_parseopt+0x40>
				c += opts[c + 1];
    345a:	440b      	add	r3, r1
    345c:	e7e2      	b.n	3424 <tcp_parseopt+0x44>
    345e:	bf00      	nop
    3460:	2000a4e0 	.word	0x2000a4e0
    3464:	00000d6b 	.word	0x00000d6b

00003468 <tcp_oos_insert_segment>:
{
    3468:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	if (TCPH_FLAGS(cseg->tcphdr) & TCP_FIN) {
    346c:	68c3      	ldr	r3, [r0, #12]
    346e:	4e20      	ldr	r6, [pc, #128]	; (34f0 <tcp_oos_insert_segment+0x88>)
{
    3470:	4605      	mov	r5, r0
	if (TCPH_FLAGS(cseg->tcphdr) & TCP_FIN) {
    3472:	8998      	ldrh	r0, [r3, #12]
{
    3474:	460c      	mov	r4, r1
	if (TCPH_FLAGS(cseg->tcphdr) & TCP_FIN) {
    3476:	47b0      	blx	r6
    3478:	07c2      	lsls	r2, r0, #31
    347a:	d41a      	bmi.n	34b2 <tcp_oos_insert_segment+0x4a>
		while (next && TCP_SEQ_GEQ((seqno + cseg->len), (next->tcphdr->seqno + next->len))) {
    347c:	4f1d      	ldr	r7, [pc, #116]	; (34f4 <tcp_oos_insert_segment+0x8c>)
				TCPH_SET_FLAG(cseg->tcphdr, TCP_FIN);
    347e:	f8df 8080 	ldr.w	r8, [pc, #128]	; 3500 <tcp_oos_insert_segment+0x98>
			tcp_seg_free(old_seg);
    3482:	f8df 9080 	ldr.w	r9, [pc, #128]	; 3504 <tcp_oos_insert_segment+0x9c>
		while (next && TCP_SEQ_GEQ((seqno + cseg->len), (next->tcphdr->seqno + next->len))) {
    3486:	f8d4 c00c 	ldr.w	ip, [r4, #12]
    348a:	6878      	ldr	r0, [r7, #4]
    348c:	892b      	ldrh	r3, [r5, #8]
    348e:	f8dc 1004 	ldr.w	r1, [ip, #4]
    3492:	8922      	ldrh	r2, [r4, #8]
    3494:	4403      	add	r3, r0
    3496:	440a      	add	r2, r1
    3498:	1a9a      	subs	r2, r3, r2
    349a:	2a00      	cmp	r2, #0
    349c:	da10      	bge.n	34c0 <tcp_oos_insert_segment+0x58>
		if (next && TCP_SEQ_GT(seqno + cseg->len, next->tcphdr->seqno)) {
    349e:	1a5b      	subs	r3, r3, r1
    34a0:	2b00      	cmp	r3, #0
    34a2:	dd0a      	ble.n	34ba <tcp_oos_insert_segment+0x52>
			cseg->len = (u16_t)(next->tcphdr->seqno - seqno);
    34a4:	1a09      	subs	r1, r1, r0
    34a6:	b289      	uxth	r1, r1
			pbuf_realloc(cseg->p, cseg->len);
    34a8:	6868      	ldr	r0, [r5, #4]
    34aa:	4b13      	ldr	r3, [pc, #76]	; (34f8 <tcp_oos_insert_segment+0x90>)
			cseg->len = (u16_t)(next->tcphdr->seqno - seqno);
    34ac:	8129      	strh	r1, [r5, #8]
			pbuf_realloc(cseg->p, cseg->len);
    34ae:	4798      	blx	r3
    34b0:	e003      	b.n	34ba <tcp_oos_insert_segment+0x52>
		tcp_segs_free(next);
    34b2:	4620      	mov	r0, r4
    34b4:	4b11      	ldr	r3, [pc, #68]	; (34fc <tcp_oos_insert_segment+0x94>)
    34b6:	4798      	blx	r3
		next = NULL;
    34b8:	2400      	movs	r4, #0
	cseg->next = next;
    34ba:	602c      	str	r4, [r5, #0]
}
    34bc:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
			if (TCPH_FLAGS(next->tcphdr) & TCP_FIN) {
    34c0:	f8bc 000c 	ldrh.w	r0, [ip, #12]
    34c4:	47b0      	blx	r6
    34c6:	07c3      	lsls	r3, r0, #31
    34c8:	d508      	bpl.n	34dc <tcp_oos_insert_segment+0x74>
				TCPH_SET_FLAG(cseg->tcphdr, TCP_FIN);
    34ca:	68eb      	ldr	r3, [r5, #12]
    34cc:	2001      	movs	r0, #1
    34ce:	f8b3 a00c 	ldrh.w	sl, [r3, #12]
    34d2:	47c0      	blx	r8
    34d4:	68eb      	ldr	r3, [r5, #12]
    34d6:	ea4a 0000 	orr.w	r0, sl, r0
    34da:	8198      	strh	r0, [r3, #12]
			next    = next->next;
    34dc:	f8d4 a000 	ldr.w	sl, [r4]
			tcp_seg_free(old_seg);
    34e0:	4620      	mov	r0, r4
    34e2:	47c8      	blx	r9
		while (next && TCP_SEQ_GEQ((seqno + cseg->len), (next->tcphdr->seqno + next->len))) {
    34e4:	4654      	mov	r4, sl
    34e6:	f1ba 0f00 	cmp.w	sl, #0
    34ea:	d1cc      	bne.n	3486 <tcp_oos_insert_segment+0x1e>
    34ec:	e7e5      	b.n	34ba <tcp_oos_insert_segment+0x52>
    34ee:	bf00      	nop
    34f0:	00000d6b 	.word	0x00000d6b
    34f4:	2000a4e0 	.word	0x2000a4e0
    34f8:	0000324d 	.word	0x0000324d
    34fc:	00006ae5 	.word	0x00006ae5
    3500:	00000d65 	.word	0x00000d65
    3504:	00006ac1 	.word	0x00006ac1

00003508 <tcp_receive>:
{
    3508:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
	if (flags & TCP_ACK) {
    350c:	4d75      	ldr	r5, [pc, #468]	; (36e4 <tcp_receive+0x1dc>)
    350e:	7a2b      	ldrb	r3, [r5, #8]
    3510:	06de      	lsls	r6, r3, #27
{
    3512:	4604      	mov	r4, r0
	if (flags & TCP_ACK) {
    3514:	f140 8132 	bpl.w	377c <tcp_receive+0x274>
		right_wnd_edge = pcb->snd_wnd + pcb->snd_wl2;
    3518:	f8b0 1060 	ldrh.w	r1, [r0, #96]	; 0x60
		if (TCP_SEQ_LT(pcb->snd_wl1, seqno) || (pcb->snd_wl1 == seqno && TCP_SEQ_LT(pcb->snd_wl2, ackno))
    351c:	686a      	ldr	r2, [r5, #4]
    351e:	68eb      	ldr	r3, [r5, #12]
    3520:	e9d0 6015 	ldrd	r6, r0, [r0, #84]	; 0x54
    3524:	1ab7      	subs	r7, r6, r2
    3526:	2f00      	cmp	r7, #0
    3528:	db0a      	blt.n	3540 <tcp_receive+0x38>
    352a:	4296      	cmp	r6, r2
    352c:	d102      	bne.n	3534 <tcp_receive+0x2c>
    352e:	1ac6      	subs	r6, r0, r3
    3530:	2e00      	cmp	r6, #0
    3532:	db05      	blt.n	3540 <tcp_receive+0x38>
		    || (pcb->snd_wl2 == ackno && tcphdr->wnd > pcb->snd_wnd)) {
    3534:	4298      	cmp	r0, r3
    3536:	d118      	bne.n	356a <tcp_receive+0x62>
    3538:	682e      	ldr	r6, [r5, #0]
    353a:	89f6      	ldrh	r6, [r6, #14]
    353c:	428e      	cmp	r6, r1
    353e:	d914      	bls.n	356a <tcp_receive+0x62>
			pcb->snd_wnd = tcphdr->wnd;
    3540:	682e      	ldr	r6, [r5, #0]
			if (pcb->snd_wnd_max < tcphdr->wnd) {
    3542:	f8b4 c062 	ldrh.w	ip, [r4, #98]	; 0x62
			pcb->snd_wnd = tcphdr->wnd;
    3546:	89f6      	ldrh	r6, [r6, #14]
    3548:	f8a4 6060 	strh.w	r6, [r4, #96]	; 0x60
    354c:	b2b7      	uxth	r7, r6
			if (pcb->snd_wnd_max < tcphdr->wnd) {
    354e:	45bc      	cmp	ip, r7
			pcb->snd_wl2 = ackno;
    3550:	e9c4 2315 	strd	r2, r3, [r4, #84]	; 0x54
				pcb->snd_wnd_max = tcphdr->wnd;
    3554:	bf38      	it	cc
    3556:	f8a4 6062 	strhcc.w	r6, [r4, #98]	; 0x62
				if (pcb->persist_backoff == 0) {
    355a:	f894 2095 	ldrb.w	r2, [r4, #149]	; 0x95
			if (pcb->snd_wnd == 0) {
    355e:	bb97      	cbnz	r7, 35c6 <tcp_receive+0xbe>
				if (pcb->persist_backoff == 0) {
    3560:	b91a      	cbnz	r2, 356a <tcp_receive+0x62>
					pcb->persist_cnt     = 0;
    3562:	f44f 7280 	mov.w	r2, #256	; 0x100
    3566:	f8a4 2094 	strh.w	r2, [r4, #148]	; 0x94
		if (TCP_SEQ_LEQ(ackno, pcb->lastack)) {
    356a:	6ca6      	ldr	r6, [r4, #72]	; 0x48
    356c:	1b9a      	subs	r2, r3, r6
    356e:	2a00      	cmp	r2, #0
    3570:	dc38      	bgt.n	35e4 <tcp_receive+0xdc>
			pcb->acked = 0;
    3572:	2200      	movs	r2, #0
    3574:	f8a4 2064 	strh.w	r2, [r4, #100]	; 0x64
			if (tcplen == 0) {
    3578:	8a2a      	ldrh	r2, [r5, #16]
    357a:	bb7a      	cbnz	r2, 35dc <tcp_receive+0xd4>
				if (pcb->snd_wl2 + pcb->snd_wnd == right_wnd_edge) {
    357c:	f8b4 2060 	ldrh.w	r2, [r4, #96]	; 0x60
    3580:	6da7      	ldr	r7, [r4, #88]	; 0x58
		right_wnd_edge = pcb->snd_wnd + pcb->snd_wl2;
    3582:	4401      	add	r1, r0
				if (pcb->snd_wl2 + pcb->snd_wnd == right_wnd_edge) {
    3584:	443a      	add	r2, r7
    3586:	428a      	cmp	r2, r1
    3588:	d128      	bne.n	35dc <tcp_receive+0xd4>
					if (pcb->rtime >= 0) {
    358a:	f9b4 2034 	ldrsh.w	r2, [r4, #52]	; 0x34
    358e:	2a00      	cmp	r2, #0
    3590:	db24      	blt.n	35dc <tcp_receive+0xd4>
						if (pcb->lastack == ackno) {
    3592:	429e      	cmp	r6, r3
    3594:	d122      	bne.n	35dc <tcp_receive+0xd4>
							if ((u8_t)(pcb->dupacks + 1) > pcb->dupacks) {
    3596:	f894 3047 	ldrb.w	r3, [r4, #71]	; 0x47
    359a:	2bff      	cmp	r3, #255	; 0xff
								++pcb->dupacks;
    359c:	bf1c      	itt	ne
    359e:	3301      	addne	r3, #1
    35a0:	f884 3047 	strbne.w	r3, [r4, #71]	; 0x47
							if (pcb->dupacks > 3) {
    35a4:	f894 3047 	ldrb.w	r3, [r4, #71]	; 0x47
    35a8:	2b03      	cmp	r3, #3
    35aa:	d912      	bls.n	35d2 <tcp_receive+0xca>
								if ((u16_t)(pcb->cwnd + pcb->mss) > pcb->cwnd) {
    35ac:	f8b4 204c 	ldrh.w	r2, [r4, #76]	; 0x4c
    35b0:	8ee3      	ldrh	r3, [r4, #54]	; 0x36
    35b2:	4413      	add	r3, r2
    35b4:	b29b      	uxth	r3, r3
    35b6:	429a      	cmp	r2, r3
    35b8:	d201      	bcs.n	35be <tcp_receive+0xb6>
									pcb->cwnd += pcb->mss;
    35ba:	f8a4 304c 	strh.w	r3, [r4, #76]	; 0x4c
		       && TCP_SEQ_BETWEEN(ackno, ntohl(pcb->unsent->tcphdr->seqno) + TCP_TCPLEN(pcb->unsent), pcb->snd_nxt)) {
    35be:	f8df 8130 	ldr.w	r8, [pc, #304]	; 36f0 <tcp_receive+0x1e8>
    35c2:	4f49      	ldr	r7, [pc, #292]	; (36e8 <tcp_receive+0x1e0>)
    35c4:	e0d3      	b.n	376e <tcp_receive+0x266>
			} else if (pcb->persist_backoff > 0) {
    35c6:	2a00      	cmp	r2, #0
    35c8:	d0cf      	beq.n	356a <tcp_receive+0x62>
				pcb->persist_backoff = 0;
    35ca:	2200      	movs	r2, #0
    35cc:	f884 2095 	strb.w	r2, [r4, #149]	; 0x95
    35d0:	e7cb      	b.n	356a <tcp_receive+0x62>
							} else if (pcb->dupacks == 3) {
    35d2:	d1f4      	bne.n	35be <tcp_receive+0xb6>
								tcp_rexmit_fast(pcb);
    35d4:	4b45      	ldr	r3, [pc, #276]	; (36ec <tcp_receive+0x1e4>)
    35d6:	4620      	mov	r0, r4
    35d8:	4798      	blx	r3
			if (!found_dupack) {
    35da:	e7f0      	b.n	35be <tcp_receive+0xb6>
				pcb->dupacks = 0;
    35dc:	2300      	movs	r3, #0
    35de:	f884 3047 	strb.w	r3, [r4, #71]	; 0x47
    35e2:	e7ec      	b.n	35be <tcp_receive+0xb6>
		} else if (TCP_SEQ_BETWEEN(ackno, pcb->lastack + 1, pcb->snd_nxt)) {
    35e4:	6d21      	ldr	r1, [r4, #80]	; 0x50
    35e6:	1a59      	subs	r1, r3, r1
    35e8:	2900      	cmp	r1, #0
    35ea:	dc76      	bgt.n	36da <tcp_receive+0x1d2>
			if (pcb->flags & TF_INFR) {
    35ec:	7fa1      	ldrb	r1, [r4, #30]
			pcb->lastack = ackno;
    35ee:	64a3      	str	r3, [r4, #72]	; 0x48
			if (pcb->flags & TF_INFR) {
    35f0:	0748      	lsls	r0, r1, #29
				pcb->flags &= ~TF_INFR;
    35f2:	bf41      	itttt	mi
    35f4:	f021 0104 	bicmi.w	r1, r1, #4
    35f8:	77a1      	strbmi	r1, [r4, #30]
				pcb->cwnd = pcb->ssthresh;
    35fa:	f8b4 104e 	ldrhmi.w	r1, [r4, #78]	; 0x4e
    35fe:	f8a4 104c 	strhmi.w	r1, [r4, #76]	; 0x4c
			pcb->rto = (pcb->sa >> 3) + pcb->sv;
    3602:	f9b4 0040 	ldrsh.w	r0, [r4, #64]	; 0x40
    3606:	f8b4 1042 	ldrh.w	r1, [r4, #66]	; 0x42
			if (pcb->state >= ESTABLISHED) {
    360a:	7e23      	ldrb	r3, [r4, #24]
			pcb->rto = (pcb->sa >> 3) + pcb->sv;
    360c:	eb01 01e0 	add.w	r1, r1, r0, asr #3
    3610:	f8a4 1044 	strh.w	r1, [r4, #68]	; 0x44
			pcb->snd_buf += pcb->acked;
    3614:	f8b4 1066 	ldrh.w	r1, [r4, #102]	; 0x66
			pcb->acked = (u16_t)(ackno - pcb->lastack);
    3618:	b292      	uxth	r2, r2
    361a:	f8a4 2064 	strh.w	r2, [r4, #100]	; 0x64
			pcb->snd_buf += pcb->acked;
    361e:	440a      	add	r2, r1
    3620:	f8a4 2066 	strh.w	r2, [r4, #102]	; 0x66
			if (pcb->state >= ESTABLISHED) {
    3624:	2b03      	cmp	r3, #3
			pcb->nrtx = 0;
    3626:	f04f 0200 	mov.w	r2, #0
    362a:	f8a4 2046 	strh.w	r2, [r4, #70]	; 0x46
			if (pcb->state >= ESTABLISHED) {
    362e:	d90f      	bls.n	3650 <tcp_receive+0x148>
				if (pcb->cwnd < pcb->ssthresh) {
    3630:	f8b4 204c 	ldrh.w	r2, [r4, #76]	; 0x4c
    3634:	f8b4 104e 	ldrh.w	r1, [r4, #78]	; 0x4e
								if ((u16_t)(pcb->cwnd + pcb->mss) > pcb->cwnd) {
    3638:	8ee3      	ldrh	r3, [r4, #54]	; 0x36
				if (pcb->cwnd < pcb->ssthresh) {
    363a:	4291      	cmp	r1, r2
					u16_t new_cwnd = (pcb->cwnd + pcb->mss * pcb->mss / pcb->cwnd);
    363c:	bf9c      	itt	ls
    363e:	435b      	mulls	r3, r3
    3640:	fbb3 f3f2 	udivls	r3, r3, r2
    3644:	4413      	add	r3, r2
    3646:	b29b      	uxth	r3, r3
					if (new_cwnd > pcb->cwnd) {
    3648:	429a      	cmp	r2, r3
    364a:	d201      	bcs.n	3650 <tcp_receive+0x148>
						pcb->cwnd = new_cwnd;
    364c:	f8a4 304c 	strh.w	r3, [r4, #76]	; 0x4c
			       && TCP_SEQ_LEQ(ntohl(pcb->unacked->tcphdr->seqno) + TCP_TCPLEN(pcb->unacked), ackno)) {
    3650:	4f27      	ldr	r7, [pc, #156]	; (36f0 <tcp_receive+0x1e8>)
    3652:	4e25      	ldr	r6, [pc, #148]	; (36e8 <tcp_receive+0x1e0>)
				pcb->snd_queuelen -= pbuf_clen(next->p);
    3654:	f8df 80a0 	ldr.w	r8, [pc, #160]	; 36f8 <tcp_receive+0x1f0>
    3658:	e033      	b.n	36c2 <tcp_receive+0x1ba>
			       && TCP_SEQ_LEQ(ntohl(pcb->unacked->tcphdr->seqno) + TCP_TCPLEN(pcb->unacked), ackno)) {
    365a:	68db      	ldr	r3, [r3, #12]
    365c:	6858      	ldr	r0, [r3, #4]
    365e:	47b8      	blx	r7
    3660:	6f22      	ldr	r2, [r4, #112]	; 0x70
    3662:	68d3      	ldr	r3, [r2, #12]
    3664:	f8b2 a008 	ldrh.w	sl, [r2, #8]
    3668:	4681      	mov	r9, r0
    366a:	8998      	ldrh	r0, [r3, #12]
    366c:	47b0      	blx	r6
    366e:	f010 0303 	ands.w	r3, r0, #3
    3672:	68e8      	ldr	r0, [r5, #12]
    3674:	bf18      	it	ne
    3676:	2301      	movne	r3, #1
    3678:	4453      	add	r3, sl
    367a:	eba9 0900 	sub.w	r9, r9, r0
    367e:	444b      	add	r3, r9
    3680:	2b00      	cmp	r3, #0
    3682:	dc21      	bgt.n	36c8 <tcp_receive+0x1c0>
				next         = pcb->unacked;
    3684:	f8d4 9070 	ldr.w	r9, [r4, #112]	; 0x70
				pcb->unacked = pcb->unacked->next;
    3688:	f8d9 3000 	ldr.w	r3, [r9]
    368c:	6723      	str	r3, [r4, #112]	; 0x70
				if ((pcb->acked != 0) && ((TCPH_FLAGS(next->tcphdr) & TCP_FIN) != 0)) {
    368e:	f8b4 3064 	ldrh.w	r3, [r4, #100]	; 0x64
    3692:	b15b      	cbz	r3, 36ac <tcp_receive+0x1a4>
    3694:	f8d9 300c 	ldr.w	r3, [r9, #12]
    3698:	8998      	ldrh	r0, [r3, #12]
    369a:	47b0      	blx	r6
    369c:	07c1      	lsls	r1, r0, #31
					pcb->acked--;
    369e:	bf42      	ittt	mi
    36a0:	f8b4 3064 	ldrhmi.w	r3, [r4, #100]	; 0x64
    36a4:	f103 33ff 	addmi.w	r3, r3, #4294967295	; 0xffffffff
    36a8:	f8a4 3064 	strhmi.w	r3, [r4, #100]	; 0x64
				pcb->snd_queuelen -= pbuf_clen(next->p);
    36ac:	f8d9 0004 	ldr.w	r0, [r9, #4]
    36b0:	47c0      	blx	r8
    36b2:	f8b4 3068 	ldrh.w	r3, [r4, #104]	; 0x68
    36b6:	1a18      	subs	r0, r3, r0
    36b8:	f8a4 0068 	strh.w	r0, [r4, #104]	; 0x68
				tcp_seg_free(next);
    36bc:	4b0d      	ldr	r3, [pc, #52]	; (36f4 <tcp_receive+0x1ec>)
    36be:	4648      	mov	r0, r9
    36c0:	4798      	blx	r3
			while (pcb->unacked != NULL
    36c2:	6f23      	ldr	r3, [r4, #112]	; 0x70
    36c4:	2b00      	cmp	r3, #0
    36c6:	d1c8      	bne.n	365a <tcp_receive+0x152>
			if (pcb->unacked == NULL)
    36c8:	6f23      	ldr	r3, [r4, #112]	; 0x70
    36ca:	fab3 f383 	clz	r3, r3
    36ce:	095b      	lsrs	r3, r3, #5
    36d0:	425b      	negs	r3, r3
    36d2:	86a3      	strh	r3, [r4, #52]	; 0x34
			pcb->polltmr = 0;
    36d4:	2300      	movs	r3, #0
    36d6:	77e3      	strb	r3, [r4, #31]
    36d8:	e771      	b.n	35be <tcp_receive+0xb6>
			pcb->acked = 0;
    36da:	2300      	movs	r3, #0
    36dc:	f8a4 3064 	strh.w	r3, [r4, #100]	; 0x64
    36e0:	e76d      	b.n	35be <tcp_receive+0xb6>
    36e2:	bf00      	nop
    36e4:	2000a4e0 	.word	0x2000a4e0
    36e8:	00000d6b 	.word	0x00000d6b
    36ec:	00002869 	.word	0x00002869
    36f0:	00000d75 	.word	0x00000d75
    36f4:	00006ac1 	.word	0x00006ac1
    36f8:	000032a1 	.word	0x000032a1
		       && TCP_SEQ_BETWEEN(ackno, ntohl(pcb->unsent->tcphdr->seqno) + TCP_TCPLEN(pcb->unsent), pcb->snd_nxt)) {
    36fc:	68db      	ldr	r3, [r3, #12]
    36fe:	68ee      	ldr	r6, [r5, #12]
    3700:	6858      	ldr	r0, [r3, #4]
    3702:	47c0      	blx	r8
    3704:	6ee3      	ldr	r3, [r4, #108]	; 0x6c
    3706:	f8b3 a008 	ldrh.w	sl, [r3, #8]
    370a:	68db      	ldr	r3, [r3, #12]
    370c:	4681      	mov	r9, r0
    370e:	8998      	ldrh	r0, [r3, #12]
    3710:	47b8      	blx	r7
    3712:	f010 0003 	ands.w	r0, r0, #3
    3716:	bf18      	it	ne
    3718:	2001      	movne	r0, #1
    371a:	eba6 0609 	sub.w	r6, r6, r9
    371e:	4450      	add	r0, sl
    3720:	1a30      	subs	r0, r6, r0
    3722:	2800      	cmp	r0, #0
    3724:	db26      	blt.n	3774 <tcp_receive+0x26c>
    3726:	68eb      	ldr	r3, [r5, #12]
    3728:	6d22      	ldr	r2, [r4, #80]	; 0x50
    372a:	1a9b      	subs	r3, r3, r2
    372c:	2b00      	cmp	r3, #0
    372e:	dc21      	bgt.n	3774 <tcp_receive+0x26c>
			next        = pcb->unsent;
    3730:	6ee6      	ldr	r6, [r4, #108]	; 0x6c
			pcb->unsent = pcb->unsent->next;
    3732:	6833      	ldr	r3, [r6, #0]
    3734:	66e3      	str	r3, [r4, #108]	; 0x6c
			if (pcb->unsent == NULL) {
    3736:	b90b      	cbnz	r3, 373c <tcp_receive+0x234>
				pcb->unsent_oversize = 0;
    3738:	f8a4 306a 	strh.w	r3, [r4, #106]	; 0x6a
			if ((pcb->acked != 0) && ((TCPH_FLAGS(next->tcphdr) & TCP_FIN) != 0)) {
    373c:	f8b4 3064 	ldrh.w	r3, [r4, #100]	; 0x64
    3740:	b153      	cbz	r3, 3758 <tcp_receive+0x250>
    3742:	68f3      	ldr	r3, [r6, #12]
    3744:	8998      	ldrh	r0, [r3, #12]
    3746:	47b8      	blx	r7
    3748:	07c2      	lsls	r2, r0, #31
				pcb->acked--;
    374a:	bf42      	ittt	mi
    374c:	f8b4 3064 	ldrhmi.w	r3, [r4, #100]	; 0x64
    3750:	f103 33ff 	addmi.w	r3, r3, #4294967295	; 0xffffffff
    3754:	f8a4 3064 	strhmi.w	r3, [r4, #100]	; 0x64
			pcb->snd_queuelen -= pbuf_clen(next->p);
    3758:	4b95      	ldr	r3, [pc, #596]	; (39b0 <tcp_receive+0x4a8>)
    375a:	6870      	ldr	r0, [r6, #4]
    375c:	4798      	blx	r3
    375e:	f8b4 3068 	ldrh.w	r3, [r4, #104]	; 0x68
    3762:	1a18      	subs	r0, r3, r0
    3764:	f8a4 0068 	strh.w	r0, [r4, #104]	; 0x68
			tcp_seg_free(next);
    3768:	4b92      	ldr	r3, [pc, #584]	; (39b4 <tcp_receive+0x4ac>)
    376a:	4630      	mov	r0, r6
    376c:	4798      	blx	r3
		while (pcb->unsent != NULL
    376e:	6ee3      	ldr	r3, [r4, #108]	; 0x6c
    3770:	2b00      	cmp	r3, #0
    3772:	d1c3      	bne.n	36fc <tcp_receive+0x1f4>
		if (pcb->rttest && TCP_SEQ_LT(pcb->rtseq, ackno)) {
    3774:	6ba1      	ldr	r1, [r4, #56]	; 0x38
    3776:	2900      	cmp	r1, #0
    3778:	f040 80a9 	bne.w	38ce <tcp_receive+0x3c6>
	if ((tcplen > 0) && (pcb->state < CLOSE_WAIT)) {
    377c:	8a2e      	ldrh	r6, [r5, #16]
		if (TCP_SEQ_BETWEEN(pcb->rcv_nxt, seqno + 1, seqno + tcplen - 1)) {
    377e:	686b      	ldr	r3, [r5, #4]
    3780:	6aa2      	ldr	r2, [r4, #40]	; 0x28
	if ((tcplen > 0) && (pcb->state < CLOSE_WAIT)) {
    3782:	2e00      	cmp	r6, #0
    3784:	f000 824d 	beq.w	3c22 <tcp_receive+0x71a>
    3788:	7e21      	ldrb	r1, [r4, #24]
    378a:	2906      	cmp	r1, #6
    378c:	f200 8249 	bhi.w	3c22 <tcp_receive+0x71a>
		if (TCP_SEQ_BETWEEN(pcb->rcv_nxt, seqno + 1, seqno + tcplen - 1)) {
    3790:	1ad1      	subs	r1, r2, r3
    3792:	2901      	cmp	r1, #1
    3794:	f100 80cd 	bmi.w	3932 <tcp_receive+0x42a>
    3798:	f1c3 0001 	rsb	r0, r3, #1
    379c:	1b80      	subs	r0, r0, r6
    379e:	4410      	add	r0, r2
    37a0:	2800      	cmp	r0, #0
    37a2:	f300 80c6 	bgt.w	3932 <tcp_receive+0x42a>
			p   = inseg.p;
    37a6:	69a8      	ldr	r0, [r5, #24]
			if (inseg.p->len < off) {
    37a8:	8943      	ldrh	r3, [r0, #10]
    37aa:	428b      	cmp	r3, r1
				new_tot_len = (u16_t)(inseg.p->tot_len - off);
    37ac:	b28a      	uxth	r2, r1
			if (inseg.p->len < off) {
    37ae:	f280 80bd 	bge.w	392c <tcp_receive+0x424>
				new_tot_len = (u16_t)(inseg.p->tot_len - off);
    37b2:	8903      	ldrh	r3, [r0, #8]
    37b4:	1a9b      	subs	r3, r3, r2
    37b6:	b29b      	uxth	r3, r3
					p->len     = 0;
    37b8:	2600      	movs	r6, #0
				while (p->len < off) {
    37ba:	8942      	ldrh	r2, [r0, #10]
    37bc:	428a      	cmp	r2, r1
    37be:	f2c0 80b0 	blt.w	3922 <tcp_receive+0x41a>
				if (pbuf_header(p, (s16_t)-off)) {
    37c2:	4249      	negs	r1, r1
    37c4:	b209      	sxth	r1, r1
				if (pbuf_header(inseg.p, (s16_t)-off)) {
    37c6:	4b7c      	ldr	r3, [pc, #496]	; (39b8 <tcp_receive+0x4b0>)
    37c8:	4798      	blx	r3
			inseg.len -= (u16_t)(pcb->rcv_nxt - seqno);
    37ca:	8ba9      	ldrh	r1, [r5, #28]
    37cc:	686b      	ldr	r3, [r5, #4]
    37ce:	6aa2      	ldr	r2, [r4, #40]	; 0x28
			inseg.tcphdr->seqno = seqno = pcb->rcv_nxt;
    37d0:	606a      	str	r2, [r5, #4]
			inseg.len -= (u16_t)(pcb->rcv_nxt - seqno);
    37d2:	440b      	add	r3, r1
    37d4:	1a9b      	subs	r3, r3, r2
    37d6:	83ab      	strh	r3, [r5, #28]
			inseg.tcphdr->seqno = seqno = pcb->rcv_nxt;
    37d8:	6a2b      	ldr	r3, [r5, #32]
    37da:	605a      	str	r2, [r3, #4]
		if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, pcb->rcv_nxt + pcb->rcv_wnd - 1)) {
    37dc:	6869      	ldr	r1, [r5, #4]
    37de:	6aa2      	ldr	r2, [r4, #40]	; 0x28
    37e0:	1a8b      	subs	r3, r1, r2
    37e2:	2b00      	cmp	r3, #0
    37e4:	f2c0 8217 	blt.w	3c16 <tcp_receive+0x70e>
    37e8:	8da0      	ldrh	r0, [r4, #44]	; 0x2c
    37ea:	1c4b      	adds	r3, r1, #1
    37ec:	1a9b      	subs	r3, r3, r2
    37ee:	1a1b      	subs	r3, r3, r0
    37f0:	2b00      	cmp	r3, #0
    37f2:	f300 8210 	bgt.w	3c16 <tcp_receive+0x70e>
			if (pcb->rcv_nxt == seqno) {
    37f6:	4291      	cmp	r1, r2
    37f8:	f040 815f 	bne.w	3aba <tcp_receive+0x5b2>
				tcplen = TCP_TCPLEN(&inseg);
    37fc:	6a2b      	ldr	r3, [r5, #32]
    37fe:	4e6f      	ldr	r6, [pc, #444]	; (39bc <tcp_receive+0x4b4>)
    3800:	8998      	ldrh	r0, [r3, #12]
    3802:	8baf      	ldrh	r7, [r5, #28]
    3804:	47b0      	blx	r6
    3806:	f010 0003 	ands.w	r0, r0, #3
    380a:	bf18      	it	ne
    380c:	2001      	movne	r0, #1
				if (tcplen > pcb->rcv_wnd) {
    380e:	8da3      	ldrh	r3, [r4, #44]	; 0x2c
				tcplen = TCP_TCPLEN(&inseg);
    3810:	4438      	add	r0, r7
    3812:	b280      	uxth	r0, r0
				if (tcplen > pcb->rcv_wnd) {
    3814:	4283      	cmp	r3, r0
				tcplen = TCP_TCPLEN(&inseg);
    3816:	8228      	strh	r0, [r5, #16]
				if (tcplen > pcb->rcv_wnd) {
    3818:	d22b      	bcs.n	3872 <tcp_receive+0x36a>
					if (TCPH_FLAGS(inseg.tcphdr) & TCP_FIN) {
    381a:	6a2b      	ldr	r3, [r5, #32]
    381c:	8998      	ldrh	r0, [r3, #12]
    381e:	47b0      	blx	r6
    3820:	07c3      	lsls	r3, r0, #31
    3822:	d50c      	bpl.n	383e <tcp_receive+0x336>
						TCPH_FLAGS_SET(inseg.tcphdr, TCPH_FLAGS(inseg.tcphdr) & ~TCP_FIN);
    3824:	6a2b      	ldr	r3, [r5, #32]
    3826:	899f      	ldrh	r7, [r3, #12]
    3828:	4638      	mov	r0, r7
    382a:	47b0      	blx	r6
    382c:	4b64      	ldr	r3, [pc, #400]	; (39c0 <tcp_receive+0x4b8>)
    382e:	f000 003e 	and.w	r0, r0, #62	; 0x3e
    3832:	4798      	blx	r3
    3834:	f427 577c 	bic.w	r7, r7, #16128	; 0x3f00
    3838:	6a2b      	ldr	r3, [r5, #32]
    383a:	4307      	orrs	r7, r0
    383c:	819f      	strh	r7, [r3, #12]
					inseg.len = pcb->rcv_wnd;
    383e:	8da3      	ldrh	r3, [r4, #44]	; 0x2c
    3840:	83ab      	strh	r3, [r5, #28]
					if (TCPH_FLAGS(inseg.tcphdr) & TCP_SYN) {
    3842:	6a2b      	ldr	r3, [r5, #32]
    3844:	8998      	ldrh	r0, [r3, #12]
    3846:	47b0      	blx	r6
    3848:	0787      	lsls	r7, r0, #30
						inseg.len -= 1;
    384a:	bf48      	it	mi
    384c:	8bab      	ldrhmi	r3, [r5, #28]
					pbuf_realloc(inseg.p, inseg.len);
    384e:	69a8      	ldr	r0, [r5, #24]
						inseg.len -= 1;
    3850:	bf44      	itt	mi
    3852:	f103 33ff 	addmi.w	r3, r3, #4294967295	; 0xffffffff
    3856:	83ab      	strhmi	r3, [r5, #28]
					pbuf_realloc(inseg.p, inseg.len);
    3858:	8ba9      	ldrh	r1, [r5, #28]
    385a:	4b5a      	ldr	r3, [pc, #360]	; (39c4 <tcp_receive+0x4bc>)
    385c:	4798      	blx	r3
					tcplen = TCP_TCPLEN(&inseg);
    385e:	6a2b      	ldr	r3, [r5, #32]
    3860:	8baf      	ldrh	r7, [r5, #28]
    3862:	8998      	ldrh	r0, [r3, #12]
    3864:	47b0      	blx	r6
    3866:	f010 0003 	ands.w	r0, r0, #3
    386a:	bf18      	it	ne
    386c:	2001      	movne	r0, #1
    386e:	4438      	add	r0, r7
    3870:	8228      	strh	r0, [r5, #16]
				if (pcb->ooseq != NULL) {
    3872:	6f63      	ldr	r3, [r4, #116]	; 0x74
    3874:	b143      	cbz	r3, 3888 <tcp_receive+0x380>
					if (TCPH_FLAGS(inseg.tcphdr) & TCP_FIN) {
    3876:	6a2b      	ldr	r3, [r5, #32]
    3878:	8998      	ldrh	r0, [r3, #12]
    387a:	47b0      	blx	r6
    387c:	07c0      	lsls	r0, r0, #31
    387e:	d564      	bpl.n	394a <tcp_receive+0x442>
							tcp_seg_free(old_ooseq);
    3880:	4f4c      	ldr	r7, [pc, #304]	; (39b4 <tcp_receive+0x4ac>)
						while (pcb->ooseq != NULL) {
    3882:	6f60      	ldr	r0, [r4, #116]	; 0x74
    3884:	2800      	cmp	r0, #0
    3886:	d15c      	bne.n	3942 <tcp_receive+0x43a>
				pcb->rcv_nxt = seqno + tcplen;
    3888:	8a29      	ldrh	r1, [r5, #16]
				pcb->rcv_wnd -= tcplen;
    388a:	8da3      	ldrh	r3, [r4, #44]	; 0x2c
				pcb->rcv_nxt = seqno + tcplen;
    388c:	686a      	ldr	r2, [r5, #4]
				tcp_update_rcv_ann_wnd(pcb);
    388e:	4f4e      	ldr	r7, [pc, #312]	; (39c8 <tcp_receive+0x4c0>)
				pcb->rcv_nxt = seqno + tcplen;
    3890:	440a      	add	r2, r1
				pcb->rcv_wnd -= tcplen;
    3892:	1a5b      	subs	r3, r3, r1
				pcb->rcv_nxt = seqno + tcplen;
    3894:	62a2      	str	r2, [r4, #40]	; 0x28
				pcb->rcv_wnd -= tcplen;
    3896:	85a3      	strh	r3, [r4, #44]	; 0x2c
				tcp_update_rcv_ann_wnd(pcb);
    3898:	4620      	mov	r0, r4
    389a:	47b8      	blx	r7
				if (inseg.p->tot_len > 0) {
    389c:	69ab      	ldr	r3, [r5, #24]
    389e:	9701      	str	r7, [sp, #4]
    38a0:	891a      	ldrh	r2, [r3, #8]
    38a2:	b112      	cbz	r2, 38aa <tcp_receive+0x3a2>
					recv_data = inseg.p;
    38a4:	626b      	str	r3, [r5, #36]	; 0x24
					inseg.p = NULL;
    38a6:	2300      	movs	r3, #0
    38a8:	61ab      	str	r3, [r5, #24]
				if (TCPH_FLAGS(inseg.tcphdr) & TCP_FIN) {
    38aa:	6a2b      	ldr	r3, [r5, #32]
    38ac:	8998      	ldrh	r0, [r3, #12]
    38ae:	47b0      	blx	r6
    38b0:	07c7      	lsls	r7, r0, #31
    38b2:	d505      	bpl.n	38c0 <tcp_receive+0x3b8>
					recv_flags |= TF_GOT_FIN;
    38b4:	f895 3028 	ldrb.w	r3, [r5, #40]	; 0x28
    38b8:	f043 0320 	orr.w	r3, r3, #32
    38bc:	f885 3028 	strb.w	r3, [r5, #40]	; 0x28
							pbuf_cat(recv_data, cseg->p);
    38c0:	f8df a10c 	ldr.w	sl, [pc, #268]	; 39d0 <tcp_receive+0x4c8>
					tcp_seg_free(cseg);
    38c4:	f8df b0ec 	ldr.w	fp, [pc, #236]	; 39b4 <tcp_receive+0x4ac>
						cseg->p = NULL;
    38c8:	f04f 0900 	mov.w	r9, #0
    38cc:	e0de      	b.n	3a8c <tcp_receive+0x584>
		if (pcb->rttest && TCP_SEQ_LT(pcb->rtseq, ackno)) {
    38ce:	6be3      	ldr	r3, [r4, #60]	; 0x3c
    38d0:	68ea      	ldr	r2, [r5, #12]
    38d2:	1a9b      	subs	r3, r3, r2
    38d4:	2b00      	cmp	r3, #0
    38d6:	f6bf af51 	bge.w	377c <tcp_receive+0x274>
			m = (s16_t)(tcp_ticks - pcb->rttest);
    38da:	4b3c      	ldr	r3, [pc, #240]	; (39cc <tcp_receive+0x4c4>)
    38dc:	881f      	ldrh	r7, [r3, #0]
			m = m - (pcb->sa >> 3);
    38de:	f9b4 3040 	ldrsh.w	r3, [r4, #64]	; 0x40
			m = (s16_t)(tcp_ticks - pcb->rttest);
    38e2:	b289      	uxth	r1, r1
			m = m - (pcb->sa >> 3);
    38e4:	f3c3 00cf 	ubfx	r0, r3, #3, #16
			m = (s16_t)(tcp_ticks - pcb->rttest);
    38e8:	1a7a      	subs	r2, r7, r1
			m = m - (pcb->sa >> 3);
    38ea:	1a12      	subs	r2, r2, r0
    38ec:	b216      	sxth	r6, r2
			if (m < 0) {
    38ee:	2e00      	cmp	r6, #0
			pcb->sa += m;
    38f0:	fa13 f282 	uxtah	r2, r3, r2
				m = -m;
    38f4:	bfb8      	it	lt
    38f6:	1bc9      	sublt	r1, r1, r7
			m = m - (pcb->sv >> 2);
    38f8:	f9b4 3042 	ldrsh.w	r3, [r4, #66]	; 0x42
				m = -m;
    38fc:	bfbc      	itt	lt
    38fe:	1809      	addlt	r1, r1, r0
    3900:	b20e      	sxthlt	r6, r1
			pcb->sv += m;
    3902:	eba3 03a3 	sub.w	r3, r3, r3, asr #2
    3906:	4433      	add	r3, r6
			pcb->sa += m;
    3908:	b212      	sxth	r2, r2
			pcb->sv += m;
    390a:	b29b      	uxth	r3, r3
    390c:	f8a4 3042 	strh.w	r3, [r4, #66]	; 0x42
			pcb->rto = (pcb->sa >> 3) + pcb->sv;
    3910:	eb03 03e2 	add.w	r3, r3, r2, asr #3
    3914:	f8a4 3044 	strh.w	r3, [r4, #68]	; 0x44
			pcb->rttest = 0;
    3918:	2300      	movs	r3, #0
			pcb->sa += m;
    391a:	f8a4 2040 	strh.w	r2, [r4, #64]	; 0x40
			pcb->rttest = 0;
    391e:	63a3      	str	r3, [r4, #56]	; 0x38
    3920:	e72c      	b.n	377c <tcp_receive+0x274>
					p->tot_len = new_tot_len;
    3922:	8103      	strh	r3, [r0, #8]
					p->len     = 0;
    3924:	8146      	strh	r6, [r0, #10]
					off -= p->len;
    3926:	1a89      	subs	r1, r1, r2
					p          = p->next;
    3928:	6800      	ldr	r0, [r0, #0]
    392a:	e746      	b.n	37ba <tcp_receive+0x2b2>
				if (pbuf_header(inseg.p, (s16_t)-off)) {
    392c:	4252      	negs	r2, r2
    392e:	b211      	sxth	r1, r2
    3930:	e749      	b.n	37c6 <tcp_receive+0x2be>
			if (TCP_SEQ_LT(seqno, pcb->rcv_nxt)) {
    3932:	1a9b      	subs	r3, r3, r2
    3934:	2b00      	cmp	r3, #0
				tcp_ack_now(pcb);
    3936:	bfbe      	ittt	lt
    3938:	7fa3      	ldrblt	r3, [r4, #30]
    393a:	f043 0302 	orrlt.w	r3, r3, #2
    393e:	77a3      	strblt	r3, [r4, #30]
    3940:	e74c      	b.n	37dc <tcp_receive+0x2d4>
							pcb->ooseq                = pcb->ooseq->next;
    3942:	6803      	ldr	r3, [r0, #0]
    3944:	6763      	str	r3, [r4, #116]	; 0x74
							tcp_seg_free(old_ooseq);
    3946:	47b8      	blx	r7
    3948:	e79b      	b.n	3882 <tcp_receive+0x37a>
						next = pcb->ooseq;
    394a:	6f67      	ldr	r7, [r4, #116]	; 0x74
								TCPH_SET_FLAG(inseg.tcphdr, TCP_FIN);
    394c:	f8df 8070 	ldr.w	r8, [pc, #112]	; 39c0 <tcp_receive+0x4b8>
							tcp_seg_free(prev);
    3950:	f8df 9060 	ldr.w	r9, [pc, #96]	; 39b4 <tcp_receive+0x4ac>
						while (next && TCP_SEQ_GEQ(seqno + tcplen, next->tcphdr->seqno + next->len)) {
    3954:	6868      	ldr	r0, [r5, #4]
    3956:	8a2b      	ldrh	r3, [r5, #16]
    3958:	4403      	add	r3, r0
    395a:	b337      	cbz	r7, 39aa <tcp_receive+0x4a2>
    395c:	f8d7 c00c 	ldr.w	ip, [r7, #12]
    3960:	8939      	ldrh	r1, [r7, #8]
    3962:	f8dc 2004 	ldr.w	r2, [ip, #4]
    3966:	4411      	add	r1, r2
    3968:	1a59      	subs	r1, r3, r1
    396a:	2900      	cmp	r1, #0
    396c:	da32      	bge.n	39d4 <tcp_receive+0x4cc>
						if (next && TCP_SEQ_GT(seqno + tcplen, next->tcphdr->seqno)) {
    396e:	1a9b      	subs	r3, r3, r2
    3970:	2b00      	cmp	r3, #0
    3972:	dd1a      	ble.n	39aa <tcp_receive+0x4a2>
							if (TCPH_FLAGS(inseg.tcphdr) & TCP_SYN) {
    3974:	6a2b      	ldr	r3, [r5, #32]
							inseg.len = (u16_t)(next->tcphdr->seqno - seqno);
    3976:	1a12      	subs	r2, r2, r0
    3978:	83aa      	strh	r2, [r5, #28]
							if (TCPH_FLAGS(inseg.tcphdr) & TCP_SYN) {
    397a:	8998      	ldrh	r0, [r3, #12]
    397c:	47b0      	blx	r6
    397e:	0783      	lsls	r3, r0, #30
								inseg.len -= 1;
    3980:	bf48      	it	mi
    3982:	8bab      	ldrhmi	r3, [r5, #28]
							pbuf_realloc(inseg.p, inseg.len);
    3984:	69a8      	ldr	r0, [r5, #24]
								inseg.len -= 1;
    3986:	bf44      	itt	mi
    3988:	f103 33ff 	addmi.w	r3, r3, #4294967295	; 0xffffffff
    398c:	83ab      	strhmi	r3, [r5, #28]
							pbuf_realloc(inseg.p, inseg.len);
    398e:	8ba9      	ldrh	r1, [r5, #28]
    3990:	4b0c      	ldr	r3, [pc, #48]	; (39c4 <tcp_receive+0x4bc>)
    3992:	4798      	blx	r3
							tcplen = TCP_TCPLEN(&inseg);
    3994:	6a2b      	ldr	r3, [r5, #32]
    3996:	f8b5 801c 	ldrh.w	r8, [r5, #28]
    399a:	8998      	ldrh	r0, [r3, #12]
    399c:	47b0      	blx	r6
    399e:	f010 0003 	ands.w	r0, r0, #3
    39a2:	bf18      	it	ne
    39a4:	2001      	movne	r0, #1
    39a6:	4440      	add	r0, r8
    39a8:	8228      	strh	r0, [r5, #16]
						pcb->ooseq = next;
    39aa:	6767      	str	r7, [r4, #116]	; 0x74
    39ac:	e76c      	b.n	3888 <tcp_receive+0x380>
    39ae:	bf00      	nop
    39b0:	000032a1 	.word	0x000032a1
    39b4:	00006ac1 	.word	0x00006ac1
    39b8:	0000308d 	.word	0x0000308d
    39bc:	00000d6b 	.word	0x00000d6b
    39c0:	00000d65 	.word	0x00000d65
    39c4:	0000324d 	.word	0x0000324d
    39c8:	00006a49 	.word	0x00006a49
    39cc:	20014948 	.word	0x20014948
    39d0:	000032bb 	.word	0x000032bb
							if (TCPH_FLAGS(next->tcphdr) & TCP_FIN && (TCPH_FLAGS(inseg.tcphdr) & TCP_SYN) == 0) {
    39d4:	f8bc 000c 	ldrh.w	r0, [ip, #12]
    39d8:	47b0      	blx	r6
    39da:	07c1      	lsls	r1, r0, #31
    39dc:	d517      	bpl.n	3a0e <tcp_receive+0x506>
    39de:	6a2b      	ldr	r3, [r5, #32]
    39e0:	8998      	ldrh	r0, [r3, #12]
    39e2:	47b0      	blx	r6
    39e4:	0782      	lsls	r2, r0, #30
    39e6:	d412      	bmi.n	3a0e <tcp_receive+0x506>
								TCPH_SET_FLAG(inseg.tcphdr, TCP_FIN);
    39e8:	6a2b      	ldr	r3, [r5, #32]
    39ea:	2001      	movs	r0, #1
    39ec:	f8b3 a00c 	ldrh.w	sl, [r3, #12]
    39f0:	47c0      	blx	r8
    39f2:	6a2b      	ldr	r3, [r5, #32]
    39f4:	ea4a 0000 	orr.w	r0, sl, r0
    39f8:	8198      	strh	r0, [r3, #12]
								tcplen = TCP_TCPLEN(&inseg);
    39fa:	b280      	uxth	r0, r0
    39fc:	f8b5 a01c 	ldrh.w	sl, [r5, #28]
    3a00:	47b0      	blx	r6
    3a02:	f010 0003 	ands.w	r0, r0, #3
    3a06:	bf18      	it	ne
    3a08:	2001      	movne	r0, #1
    3a0a:	4450      	add	r0, sl
    3a0c:	8228      	strh	r0, [r5, #16]
							next = next->next;
    3a0e:	f8d7 a000 	ldr.w	sl, [r7]
							tcp_seg_free(prev);
    3a12:	4638      	mov	r0, r7
    3a14:	47c8      	blx	r9
							next = next->next;
    3a16:	4657      	mov	r7, sl
    3a18:	e79c      	b.n	3954 <tcp_receive+0x44c>
					seqno = pcb->ooseq->tcphdr->seqno;
    3a1a:	606b      	str	r3, [r5, #4]
					pcb->rcv_nxt += TCP_TCPLEN(cseg);
    3a1c:	8988      	ldrh	r0, [r1, #12]
    3a1e:	f8b7 8008 	ldrh.w	r8, [r7, #8]
    3a22:	47b0      	blx	r6
    3a24:	f010 0003 	ands.w	r0, r0, #3
    3a28:	6aa3      	ldr	r3, [r4, #40]	; 0x28
					pcb->rcv_wnd -= TCP_TCPLEN(cseg);
    3a2a:	68fa      	ldr	r2, [r7, #12]
					pcb->rcv_nxt += TCP_TCPLEN(cseg);
    3a2c:	bf18      	it	ne
    3a2e:	2001      	movne	r0, #1
    3a30:	4440      	add	r0, r8
    3a32:	4418      	add	r0, r3
    3a34:	62a0      	str	r0, [r4, #40]	; 0x28
					pcb->rcv_wnd -= TCP_TCPLEN(cseg);
    3a36:	8990      	ldrh	r0, [r2, #12]
    3a38:	f8b7 8008 	ldrh.w	r8, [r7, #8]
    3a3c:	47b0      	blx	r6
    3a3e:	f010 0003 	ands.w	r0, r0, #3
    3a42:	8da3      	ldrh	r3, [r4, #44]	; 0x2c
    3a44:	bf18      	it	ne
    3a46:	2001      	movne	r0, #1
    3a48:	4440      	add	r0, r8
    3a4a:	1a18      	subs	r0, r3, r0
    3a4c:	85a0      	strh	r0, [r4, #44]	; 0x2c
					tcp_update_rcv_ann_wnd(pcb);
    3a4e:	9b01      	ldr	r3, [sp, #4]
    3a50:	4620      	mov	r0, r4
    3a52:	4798      	blx	r3
					if (cseg->p->tot_len > 0) {
    3a54:	6879      	ldr	r1, [r7, #4]
    3a56:	890b      	ldrh	r3, [r1, #8]
    3a58:	b123      	cbz	r3, 3a64 <tcp_receive+0x55c>
						if (recv_data) {
    3a5a:	6a68      	ldr	r0, [r5, #36]	; 0x24
    3a5c:	b328      	cbz	r0, 3aaa <tcp_receive+0x5a2>
							pbuf_cat(recv_data, cseg->p);
    3a5e:	47d0      	blx	sl
						cseg->p = NULL;
    3a60:	f8c7 9004 	str.w	r9, [r7, #4]
					if (TCPH_FLAGS(cseg->tcphdr) & TCP_FIN) {
    3a64:	68fb      	ldr	r3, [r7, #12]
    3a66:	8998      	ldrh	r0, [r3, #12]
    3a68:	47b0      	blx	r6
    3a6a:	07c0      	lsls	r0, r0, #31
    3a6c:	d50a      	bpl.n	3a84 <tcp_receive+0x57c>
						recv_flags |= TF_GOT_FIN;
    3a6e:	f895 3028 	ldrb.w	r3, [r5, #40]	; 0x28
    3a72:	f043 0320 	orr.w	r3, r3, #32
    3a76:	f885 3028 	strb.w	r3, [r5, #40]	; 0x28
						if (pcb->state == ESTABLISHED) { /* force passive close or we can move to active close */
    3a7a:	7e23      	ldrb	r3, [r4, #24]
    3a7c:	2b04      	cmp	r3, #4
							pcb->state = CLOSE_WAIT;
    3a7e:	bf04      	itt	eq
    3a80:	2307      	moveq	r3, #7
    3a82:	7623      	strbeq	r3, [r4, #24]
					pcb->ooseq = cseg->next;
    3a84:	683b      	ldr	r3, [r7, #0]
    3a86:	6763      	str	r3, [r4, #116]	; 0x74
					tcp_seg_free(cseg);
    3a88:	4638      	mov	r0, r7
    3a8a:	47d8      	blx	fp
				while (pcb->ooseq != NULL && pcb->ooseq->tcphdr->seqno == pcb->rcv_nxt) {
    3a8c:	6f67      	ldr	r7, [r4, #116]	; 0x74
    3a8e:	b127      	cbz	r7, 3a9a <tcp_receive+0x592>
    3a90:	68f9      	ldr	r1, [r7, #12]
    3a92:	6aa2      	ldr	r2, [r4, #40]	; 0x28
    3a94:	684b      	ldr	r3, [r1, #4]
    3a96:	4293      	cmp	r3, r2
    3a98:	d0bf      	beq.n	3a1a <tcp_receive+0x512>
				tcp_ack(pcb);
    3a9a:	7fa3      	ldrb	r3, [r4, #30]
    3a9c:	07d9      	lsls	r1, r3, #31
    3a9e:	d506      	bpl.n	3aae <tcp_receive+0x5a6>
    3aa0:	f023 0301 	bic.w	r3, r3, #1
			tcp_ack_now(pcb);
    3aa4:	f043 0302 	orr.w	r3, r3, #2
    3aa8:	e003      	b.n	3ab2 <tcp_receive+0x5aa>
							recv_data = cseg->p;
    3aaa:	6269      	str	r1, [r5, #36]	; 0x24
    3aac:	e7d8      	b.n	3a60 <tcp_receive+0x558>
				tcp_ack(pcb);
    3aae:	f043 0301 	orr.w	r3, r3, #1
    3ab2:	77a3      	strb	r3, [r4, #30]
}
    3ab4:	b003      	add	sp, #12
    3ab6:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
				tcp_send_empty_ack(pcb);
    3aba:	4b60      	ldr	r3, [pc, #384]	; (3c3c <tcp_receive+0x734>)
    3abc:	4620      	mov	r0, r4
    3abe:	4798      	blx	r3
				if (pcb->ooseq == NULL) {
    3ac0:	6f66      	ldr	r6, [r4, #116]	; 0x74
    3ac2:	b926      	cbnz	r6, 3ace <tcp_receive+0x5c6>
					pcb->ooseq = tcp_seg_copy(&inseg);
    3ac4:	485e      	ldr	r0, [pc, #376]	; (3c40 <tcp_receive+0x738>)
    3ac6:	4b5f      	ldr	r3, [pc, #380]	; (3c44 <tcp_receive+0x73c>)
    3ac8:	4798      	blx	r3
    3aca:	6760      	str	r0, [r4, #116]	; 0x74
    3acc:	e7f2      	b.n	3ab4 <tcp_receive+0x5ac>
						if (seqno == next->tcphdr->seqno) {
    3ace:	686b      	ldr	r3, [r5, #4]
					prev = NULL;
    3ad0:	2700      	movs	r7, #0
    3ad2:	f103 3cff 	add.w	ip, r3, #4294967295	; 0xffffffff
    3ad6:	f103 0e01 	add.w	lr, r3, #1
						if (seqno == next->tcphdr->seqno) {
    3ada:	68f0      	ldr	r0, [r6, #12]
    3adc:	6841      	ldr	r1, [r0, #4]
    3ade:	4299      	cmp	r1, r3
    3ae0:	d114      	bne.n	3b0c <tcp_receive+0x604>
							if (inseg.len > next->len) {
    3ae2:	8baa      	ldrh	r2, [r5, #28]
    3ae4:	8933      	ldrh	r3, [r6, #8]
    3ae6:	429a      	cmp	r2, r3
    3ae8:	d9e4      	bls.n	3ab4 <tcp_receive+0x5ac>
								cseg = tcp_seg_copy(&inseg);
    3aea:	4855      	ldr	r0, [pc, #340]	; (3c40 <tcp_receive+0x738>)
    3aec:	4b55      	ldr	r3, [pc, #340]	; (3c44 <tcp_receive+0x73c>)
    3aee:	4798      	blx	r3
								if (cseg != NULL) {
    3af0:	2800      	cmp	r0, #0
    3af2:	d0df      	beq.n	3ab4 <tcp_receive+0x5ac>
									if (prev != NULL) {
    3af4:	b147      	cbz	r7, 3b08 <tcp_receive+0x600>
										prev->next = cseg;
    3af6:	6038      	str	r0, [r7, #0]
										tcp_oos_insert_segment(cseg, next);
    3af8:	4631      	mov	r1, r6
    3afa:	4b53      	ldr	r3, [pc, #332]	; (3c48 <tcp_receive+0x740>)
}
    3afc:	b003      	add	sp, #12
    3afe:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
										tcp_oos_insert_segment(cseg, next);
    3b02:	4718      	bx	r3
    3b04:	4616      	mov	r6, r2
    3b06:	e7e8      	b.n	3ada <tcp_receive+0x5d2>
										pcb->ooseq = cseg;
    3b08:	6760      	str	r0, [r4, #116]	; 0x74
									tcp_oos_insert_segment(cseg, next);
    3b0a:	e7f5      	b.n	3af8 <tcp_receive+0x5f0>
							if (prev == NULL) {
    3b0c:	b94f      	cbnz	r7, 3b22 <tcp_receive+0x61a>
								if (TCP_SEQ_LT(seqno, next->tcphdr->seqno)) {
    3b0e:	1a5a      	subs	r2, r3, r1
    3b10:	2a00      	cmp	r2, #0
    3b12:	da28      	bge.n	3b66 <tcp_receive+0x65e>
									cseg = tcp_seg_copy(&inseg);
    3b14:	484a      	ldr	r0, [pc, #296]	; (3c40 <tcp_receive+0x738>)
    3b16:	4b4b      	ldr	r3, [pc, #300]	; (3c44 <tcp_receive+0x73c>)
    3b18:	4798      	blx	r3
									if (cseg != NULL) {
    3b1a:	2800      	cmp	r0, #0
    3b1c:	d0ca      	beq.n	3ab4 <tcp_receive+0x5ac>
										pcb->ooseq = cseg;
    3b1e:	6760      	str	r0, [r4, #116]	; 0x74
    3b20:	e7ea      	b.n	3af8 <tcp_receive+0x5f0>
								if (TCP_SEQ_BETWEEN(seqno, prev->tcphdr->seqno + 1, next->tcphdr->seqno - 1)) {
    3b22:	68fa      	ldr	r2, [r7, #12]
    3b24:	6852      	ldr	r2, [r2, #4]
    3b26:	ebac 0202 	sub.w	r2, ip, r2
    3b2a:	2a00      	cmp	r2, #0
    3b2c:	db1b      	blt.n	3b66 <tcp_receive+0x65e>
    3b2e:	ebae 0201 	sub.w	r2, lr, r1
    3b32:	2a00      	cmp	r2, #0
    3b34:	dc17      	bgt.n	3b66 <tcp_receive+0x65e>
									cseg = tcp_seg_copy(&inseg);
    3b36:	4842      	ldr	r0, [pc, #264]	; (3c40 <tcp_receive+0x738>)
    3b38:	4b42      	ldr	r3, [pc, #264]	; (3c44 <tcp_receive+0x73c>)
    3b3a:	4798      	blx	r3
									if (cseg != NULL) {
    3b3c:	4604      	mov	r4, r0
    3b3e:	2800      	cmp	r0, #0
    3b40:	d0b8      	beq.n	3ab4 <tcp_receive+0x5ac>
										if (TCP_SEQ_GT(prev->tcphdr->seqno + prev->len, seqno)) {
    3b42:	68fb      	ldr	r3, [r7, #12]
    3b44:	6869      	ldr	r1, [r5, #4]
    3b46:	685a      	ldr	r2, [r3, #4]
    3b48:	893b      	ldrh	r3, [r7, #8]
    3b4a:	4413      	add	r3, r2
    3b4c:	1a5b      	subs	r3, r3, r1
    3b4e:	2b00      	cmp	r3, #0
    3b50:	dd05      	ble.n	3b5e <tcp_receive+0x656>
											prev->len = (u16_t)(seqno - prev->tcphdr->seqno);
    3b52:	1a89      	subs	r1, r1, r2
    3b54:	b289      	uxth	r1, r1
											pbuf_realloc(prev->p, prev->len);
    3b56:	6878      	ldr	r0, [r7, #4]
    3b58:	4b3c      	ldr	r3, [pc, #240]	; (3c4c <tcp_receive+0x744>)
											prev->len = (u16_t)(seqno - prev->tcphdr->seqno);
    3b5a:	8139      	strh	r1, [r7, #8]
											pbuf_realloc(prev->p, prev->len);
    3b5c:	4798      	blx	r3
										prev->next = cseg;
    3b5e:	603c      	str	r4, [r7, #0]
										tcp_oos_insert_segment(cseg, next);
    3b60:	4631      	mov	r1, r6
    3b62:	4620      	mov	r0, r4
    3b64:	e7c9      	b.n	3afa <tcp_receive+0x5f2>
							if (next->next == NULL && TCP_SEQ_GT(seqno, next->tcphdr->seqno)) {
    3b66:	6832      	ldr	r2, [r6, #0]
    3b68:	4637      	mov	r7, r6
    3b6a:	2a00      	cmp	r2, #0
    3b6c:	d1ca      	bne.n	3b04 <tcp_receive+0x5fc>
    3b6e:	1a5b      	subs	r3, r3, r1
    3b70:	2b00      	cmp	r3, #0
    3b72:	dd9f      	ble.n	3ab4 <tcp_receive+0x5ac>
								if (TCPH_FLAGS(next->tcphdr) & TCP_FIN) {
    3b74:	8980      	ldrh	r0, [r0, #12]
    3b76:	4f36      	ldr	r7, [pc, #216]	; (3c50 <tcp_receive+0x748>)
    3b78:	47b8      	blx	r7
    3b7a:	07c2      	lsls	r2, r0, #31
    3b7c:	d49a      	bmi.n	3ab4 <tcp_receive+0x5ac>
								next->next = tcp_seg_copy(&inseg);
    3b7e:	4830      	ldr	r0, [pc, #192]	; (3c40 <tcp_receive+0x738>)
    3b80:	4b30      	ldr	r3, [pc, #192]	; (3c44 <tcp_receive+0x73c>)
    3b82:	4798      	blx	r3
    3b84:	6030      	str	r0, [r6, #0]
								if (next->next != NULL) {
    3b86:	2800      	cmp	r0, #0
    3b88:	d094      	beq.n	3ab4 <tcp_receive+0x5ac>
									if (TCP_SEQ_GT(next->tcphdr->seqno + next->len, seqno)) {
    3b8a:	68f3      	ldr	r3, [r6, #12]
    3b8c:	6869      	ldr	r1, [r5, #4]
    3b8e:	685a      	ldr	r2, [r3, #4]
    3b90:	8933      	ldrh	r3, [r6, #8]
    3b92:	4413      	add	r3, r2
    3b94:	1a5b      	subs	r3, r3, r1
    3b96:	2b00      	cmp	r3, #0
    3b98:	dd05      	ble.n	3ba6 <tcp_receive+0x69e>
										next->len = (u16_t)(seqno - next->tcphdr->seqno);
    3b9a:	1a89      	subs	r1, r1, r2
    3b9c:	b289      	uxth	r1, r1
										pbuf_realloc(next->p, next->len);
    3b9e:	6870      	ldr	r0, [r6, #4]
    3ba0:	4b2a      	ldr	r3, [pc, #168]	; (3c4c <tcp_receive+0x744>)
										next->len = (u16_t)(seqno - next->tcphdr->seqno);
    3ba2:	8131      	strh	r1, [r6, #8]
										pbuf_realloc(next->p, next->len);
    3ba4:	4798      	blx	r3
									if ((u32_t)tcplen + seqno > pcb->rcv_nxt + (u32_t)pcb->rcv_wnd) {
    3ba6:	686b      	ldr	r3, [r5, #4]
    3ba8:	8a2a      	ldrh	r2, [r5, #16]
    3baa:	6aa1      	ldr	r1, [r4, #40]	; 0x28
    3bac:	441a      	add	r2, r3
    3bae:	8da3      	ldrh	r3, [r4, #44]	; 0x2c
    3bb0:	440b      	add	r3, r1
    3bb2:	429a      	cmp	r2, r3
    3bb4:	f67f af7e 	bls.w	3ab4 <tcp_receive+0x5ac>
										if (TCPH_FLAGS(next->next->tcphdr) & TCP_FIN) {
    3bb8:	6833      	ldr	r3, [r6, #0]
    3bba:	68db      	ldr	r3, [r3, #12]
    3bbc:	8998      	ldrh	r0, [r3, #12]
    3bbe:	47b8      	blx	r7
    3bc0:	07c3      	lsls	r3, r0, #31
    3bc2:	d511      	bpl.n	3be8 <tcp_receive+0x6e0>
											TCPH_FLAGS_SET(next->next->tcphdr,
    3bc4:	6833      	ldr	r3, [r6, #0]
    3bc6:	68db      	ldr	r3, [r3, #12]
    3bc8:	f8b3 800c 	ldrh.w	r8, [r3, #12]
    3bcc:	4640      	mov	r0, r8
    3bce:	47b8      	blx	r7
    3bd0:	4b20      	ldr	r3, [pc, #128]	; (3c54 <tcp_receive+0x74c>)
    3bd2:	f000 003e 	and.w	r0, r0, #62	; 0x3e
    3bd6:	4798      	blx	r3
    3bd8:	6833      	ldr	r3, [r6, #0]
    3bda:	f428 587c 	bic.w	r8, r8, #16128	; 0x3f00
    3bde:	68db      	ldr	r3, [r3, #12]
    3be0:	ea48 0800 	orr.w	r8, r8, r0
    3be4:	f8a3 800c 	strh.w	r8, [r3, #12]
										next->next->len = pcb->rcv_nxt + pcb->rcv_wnd - seqno;
    3be8:	8da1      	ldrh	r1, [r4, #44]	; 0x2c
    3bea:	686a      	ldr	r2, [r5, #4]
    3bec:	6833      	ldr	r3, [r6, #0]
    3bee:	1a89      	subs	r1, r1, r2
    3bf0:	6aa2      	ldr	r2, [r4, #40]	; 0x28
										pbuf_realloc(next->next->p, next->next->len);
    3bf2:	6858      	ldr	r0, [r3, #4]
										next->next->len = pcb->rcv_nxt + pcb->rcv_wnd - seqno;
    3bf4:	4411      	add	r1, r2
    3bf6:	b289      	uxth	r1, r1
    3bf8:	8119      	strh	r1, [r3, #8]
										pbuf_realloc(next->next->p, next->next->len);
    3bfa:	4b14      	ldr	r3, [pc, #80]	; (3c4c <tcp_receive+0x744>)
    3bfc:	4798      	blx	r3
										tcplen = TCP_TCPLEN(next->next);
    3bfe:	6833      	ldr	r3, [r6, #0]
    3c00:	891c      	ldrh	r4, [r3, #8]
    3c02:	68db      	ldr	r3, [r3, #12]
    3c04:	8998      	ldrh	r0, [r3, #12]
    3c06:	47b8      	blx	r7
    3c08:	f010 0003 	ands.w	r0, r0, #3
    3c0c:	bf18      	it	ne
    3c0e:	2001      	movne	r0, #1
    3c10:	4420      	add	r0, r4
    3c12:	8228      	strh	r0, [r5, #16]
    3c14:	e74e      	b.n	3ab4 <tcp_receive+0x5ac>
			tcp_send_empty_ack(pcb);
    3c16:	4b09      	ldr	r3, [pc, #36]	; (3c3c <tcp_receive+0x734>)
    3c18:	4620      	mov	r0, r4
}
    3c1a:	b003      	add	sp, #12
    3c1c:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
			tcp_send_empty_ack(pcb);
    3c20:	4718      	bx	r3
		if (!TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, pcb->rcv_nxt + pcb->rcv_wnd - 1)) {
    3c22:	1a99      	subs	r1, r3, r2
    3c24:	2900      	cmp	r1, #0
    3c26:	db06      	blt.n	3c36 <tcp_receive+0x72e>
    3c28:	3301      	adds	r3, #1
    3c2a:	1a9b      	subs	r3, r3, r2
    3c2c:	8da2      	ldrh	r2, [r4, #44]	; 0x2c
    3c2e:	1a9b      	subs	r3, r3, r2
    3c30:	2b00      	cmp	r3, #0
    3c32:	f77f af3f 	ble.w	3ab4 <tcp_receive+0x5ac>
			tcp_ack_now(pcb);
    3c36:	7fa3      	ldrb	r3, [r4, #30]
    3c38:	e734      	b.n	3aa4 <tcp_receive+0x59c>
    3c3a:	bf00      	nop
    3c3c:	00002435 	.word	0x00002435
    3c40:	2000a4f4 	.word	0x2000a4f4
    3c44:	00006af9 	.word	0x00006af9
    3c48:	00003469 	.word	0x00003469
    3c4c:	0000324d 	.word	0x0000324d
    3c50:	00000d6b 	.word	0x00000d6b
    3c54:	00000d65 	.word	0x00000d65

00003c58 <tcp_input>:
{
    3c58:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	iphdr  = (struct ip_hdr *)p->payload;
    3c5c:	6843      	ldr	r3, [r0, #4]
	tcphdr = (struct tcp_hdr *)((u8_t *)p->payload + IPH_HL(iphdr) * 4);
    3c5e:	4d97      	ldr	r5, [pc, #604]	; (3ebc <tcp_input+0x264>)
    3c60:	781a      	ldrb	r2, [r3, #0]
	if (pbuf_header(p, -((s16_t)(IPH_HL(iphdr) * 4))) || (p->tot_len < sizeof(struct tcp_hdr))) {
    3c62:	f8df 928c 	ldr.w	r9, [pc, #652]	; 3ef0 <tcp_input+0x298>
{
    3c66:	460c      	mov	r4, r1
    3c68:	f002 010f 	and.w	r1, r2, #15
	tcphdr = (struct tcp_hdr *)((u8_t *)p->payload + IPH_HL(iphdr) * 4);
    3c6c:	eb03 0381 	add.w	r3, r3, r1, lsl #2
	if (pbuf_header(p, -((s16_t)(IPH_HL(iphdr) * 4))) || (p->tot_len < sizeof(struct tcp_hdr))) {
    3c70:	0089      	lsls	r1, r1, #2
{
    3c72:	b085      	sub	sp, #20
	if (pbuf_header(p, -((s16_t)(IPH_HL(iphdr) * 4))) || (p->tot_len < sizeof(struct tcp_hdr))) {
    3c74:	4249      	negs	r1, r1
{
    3c76:	4606      	mov	r6, r0
	tcphdr = (struct tcp_hdr *)((u8_t *)p->payload + IPH_HL(iphdr) * 4);
    3c78:	602b      	str	r3, [r5, #0]
	if (pbuf_header(p, -((s16_t)(IPH_HL(iphdr) * 4))) || (p->tot_len < sizeof(struct tcp_hdr))) {
    3c7a:	47c8      	blx	r9
    3c7c:	2800      	cmp	r0, #0
    3c7e:	f040 80ec 	bne.w	3e5a <tcp_input+0x202>
    3c82:	8933      	ldrh	r3, [r6, #8]
    3c84:	2b13      	cmp	r3, #19
    3c86:	f240 80e8 	bls.w	3e5a <tcp_input+0x202>
	if (ip_addr_isbroadcast(&current_iphdr_dest, inp) || ip_addr_ismulticast(&current_iphdr_dest)) {
    3c8a:	4f8d      	ldr	r7, [pc, #564]	; (3ec0 <tcp_input+0x268>)
    3c8c:	4b8d      	ldr	r3, [pc, #564]	; (3ec4 <tcp_input+0x26c>)
    3c8e:	6838      	ldr	r0, [r7, #0]
    3c90:	4621      	mov	r1, r4
    3c92:	4798      	blx	r3
    3c94:	2800      	cmp	r0, #0
    3c96:	f040 80e0 	bne.w	3e5a <tcp_input+0x202>
    3c9a:	683b      	ldr	r3, [r7, #0]
    3c9c:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
    3ca0:	2be0      	cmp	r3, #224	; 0xe0
    3ca2:	f000 80da 	beq.w	3e5a <tcp_input+0x202>
	if (inet_chksum_pseudo(p, ip_current_src_addr(), ip_current_dest_addr(), IP_PROTO_TCP, p->tot_len) != 0) {
    3ca6:	f8df 8230 	ldr.w	r8, [pc, #560]	; 3ed8 <tcp_input+0x280>
    3caa:	8933      	ldrh	r3, [r6, #8]
    3cac:	9300      	str	r3, [sp, #0]
    3cae:	4c86      	ldr	r4, [pc, #536]	; (3ec8 <tcp_input+0x270>)
    3cb0:	2306      	movs	r3, #6
    3cb2:	463a      	mov	r2, r7
    3cb4:	4641      	mov	r1, r8
    3cb6:	4630      	mov	r0, r6
    3cb8:	47a0      	blx	r4
    3cba:	2800      	cmp	r0, #0
    3cbc:	f040 80cd 	bne.w	3e5a <tcp_input+0x202>
	hdrlen = TCPH_HDRLEN(tcphdr);
    3cc0:	682b      	ldr	r3, [r5, #0]
    3cc2:	4c82      	ldr	r4, [pc, #520]	; (3ecc <tcp_input+0x274>)
    3cc4:	8998      	ldrh	r0, [r3, #12]
    3cc6:	47a0      	blx	r4
    3cc8:	0b00      	lsrs	r0, r0, #12
	if (pbuf_header(p, -(hdrlen * 4))) {
    3cca:	ebc0 3080 	rsb	r0, r0, r0, lsl #14
    3cce:	0081      	lsls	r1, r0, #2
    3cd0:	b209      	sxth	r1, r1
    3cd2:	4630      	mov	r0, r6
    3cd4:	47c8      	blx	r9
    3cd6:	4682      	mov	sl, r0
    3cd8:	2800      	cmp	r0, #0
    3cda:	f040 80be 	bne.w	3e5a <tcp_input+0x202>
	tcphdr->src  = ntohs(tcphdr->src);
    3cde:	f8d5 9000 	ldr.w	r9, [r5]
	seqno = tcphdr->seqno = ntohl(tcphdr->seqno);
    3ce2:	f8df b210 	ldr.w	fp, [pc, #528]	; 3ef4 <tcp_input+0x29c>
	tcphdr->src  = ntohs(tcphdr->src);
    3ce6:	f8b9 0000 	ldrh.w	r0, [r9]
    3cea:	47a0      	blx	r4
    3cec:	f8a9 0000 	strh.w	r0, [r9]
	tcphdr->dest = ntohs(tcphdr->dest);
    3cf0:	f8d5 9000 	ldr.w	r9, [r5]
    3cf4:	f8b9 0002 	ldrh.w	r0, [r9, #2]
    3cf8:	47a0      	blx	r4
    3cfa:	f8a9 0002 	strh.w	r0, [r9, #2]
	seqno = tcphdr->seqno = ntohl(tcphdr->seqno);
    3cfe:	f8d5 9000 	ldr.w	r9, [r5]
    3d02:	f8d9 0004 	ldr.w	r0, [r9, #4]
    3d06:	47d8      	blx	fp
    3d08:	f8c9 0004 	str.w	r0, [r9, #4]
	ackno = tcphdr->ackno = ntohl(tcphdr->ackno);
    3d0c:	f8d5 9000 	ldr.w	r9, [r5]
	seqno = tcphdr->seqno = ntohl(tcphdr->seqno);
    3d10:	6068      	str	r0, [r5, #4]
	ackno = tcphdr->ackno = ntohl(tcphdr->ackno);
    3d12:	f8d9 0008 	ldr.w	r0, [r9, #8]
    3d16:	47d8      	blx	fp
    3d18:	f8c9 0008 	str.w	r0, [r9, #8]
	tcphdr->wnd           = ntohs(tcphdr->wnd);
    3d1c:	f8d5 9000 	ldr.w	r9, [r5]
	ackno = tcphdr->ackno = ntohl(tcphdr->ackno);
    3d20:	60e8      	str	r0, [r5, #12]
	tcphdr->wnd           = ntohs(tcphdr->wnd);
    3d22:	f8b9 000e 	ldrh.w	r0, [r9, #14]
    3d26:	47a0      	blx	r4
	flags  = TCPH_FLAGS(tcphdr);
    3d28:	682b      	ldr	r3, [r5, #0]
	tcphdr->wnd           = ntohs(tcphdr->wnd);
    3d2a:	f8a9 000e 	strh.w	r0, [r9, #14]
	flags  = TCPH_FLAGS(tcphdr);
    3d2e:	8998      	ldrh	r0, [r3, #12]
	for (pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
    3d30:	f8df 91a0 	ldr.w	r9, [pc, #416]	; 3ed4 <tcp_input+0x27c>
	flags  = TCPH_FLAGS(tcphdr);
    3d34:	47a0      	blx	r4
    3d36:	f000 023f 	and.w	r2, r0, #63	; 0x3f
    3d3a:	b2c3      	uxtb	r3, r0
    3d3c:	722a      	strb	r2, [r5, #8]
	tcplen = p->tot_len + ((flags & (TCP_FIN | TCP_SYN)) ? 1 : 0);
    3d3e:	f010 0003 	ands.w	r0, r0, #3
    3d42:	8932      	ldrh	r2, [r6, #8]
    3d44:	9203      	str	r2, [sp, #12]
    3d46:	bf18      	it	ne
    3d48:	2001      	movne	r0, #1
    3d4a:	4410      	add	r0, r2
    3d4c:	b282      	uxth	r2, r0
    3d4e:	9202      	str	r2, [sp, #8]
	for (pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
    3d50:	f8d9 0000 	ldr.w	r0, [r9]
	tcplen = p->tot_len + ((flags & (TCP_FIN | TCP_SYN)) ? 1 : 0);
    3d54:	822a      	strh	r2, [r5, #16]
		    && ip_addr_cmp(&(pcb->remote_ip), &current_iphdr_src)
    3d56:	f8d8 2000 	ldr.w	r2, [r8]
		if (pcb->remote_port == tcphdr->src && pcb->local_port == tcphdr->dest
    3d5a:	f8d5 c000 	ldr.w	ip, [r5]
		    && ip_addr_cmp(&(pcb->local_ip), &current_iphdr_dest)) {
    3d5e:	f8d7 e000 	ldr.w	lr, [r7]
		    && ip_addr_cmp(&(pcb->remote_ip), &current_iphdr_src)
    3d62:	4611      	mov	r1, r2
	for (pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
    3d64:	4604      	mov	r4, r0
    3d66:	b914      	cbnz	r4, 3d6e <tcp_input+0x116>
		for (pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
    3d68:	4a59      	ldr	r2, [pc, #356]	; (3ed0 <tcp_input+0x278>)
    3d6a:	6810      	ldr	r0, [r2, #0]
    3d6c:	e07c      	b.n	3e68 <tcp_input+0x210>
		if (pcb->remote_port == tcphdr->src && pcb->local_port == tcphdr->dest
    3d6e:	f8b4 b01c 	ldrh.w	fp, [r4, #28]
    3d72:	f8bc 2000 	ldrh.w	r2, [ip]
    3d76:	4593      	cmp	fp, r2
    3d78:	d138      	bne.n	3dec <tcp_input+0x194>
    3d7a:	f8b4 b01a 	ldrh.w	fp, [r4, #26]
    3d7e:	f8bc 2002 	ldrh.w	r2, [ip, #2]
    3d82:	4593      	cmp	fp, r2
    3d84:	d132      	bne.n	3dec <tcp_input+0x194>
		    && ip_addr_cmp(&(pcb->remote_ip), &current_iphdr_src)
    3d86:	6862      	ldr	r2, [r4, #4]
    3d88:	428a      	cmp	r2, r1
    3d8a:	d12f      	bne.n	3dec <tcp_input+0x194>
		    && ip_addr_cmp(&(pcb->local_ip), &current_iphdr_dest)) {
    3d8c:	6822      	ldr	r2, [r4, #0]
    3d8e:	4572      	cmp	r2, lr
    3d90:	d12c      	bne.n	3dec <tcp_input+0x194>
			if (prev != NULL) {
    3d92:	f1ba 0f00 	cmp.w	sl, #0
    3d96:	d005      	beq.n	3da4 <tcp_input+0x14c>
				prev->next      = pcb->next;
    3d98:	68e2      	ldr	r2, [r4, #12]
    3d9a:	f8ca 200c 	str.w	r2, [sl, #12]
				tcp_active_pcbs = pcb;
    3d9e:	4a4d      	ldr	r2, [pc, #308]	; (3ed4 <tcp_input+0x27c>)
				pcb->next       = tcp_active_pcbs;
    3da0:	60e0      	str	r0, [r4, #12]
				tcp_active_pcbs = pcb;
    3da2:	6014      	str	r4, [r2, #0]
		inseg.next   = NULL;
    3da4:	2200      	movs	r2, #0
		inseg.len    = p->tot_len;
    3da6:	9903      	ldr	r1, [sp, #12]
		inseg.next   = NULL;
    3da8:	616a      	str	r2, [r5, #20]
		if (flags & TCP_PSH) {
    3daa:	071b      	lsls	r3, r3, #28
		recv_data  = NULL;
    3dac:	e9c5 c208 	strd	ip, r2, [r5, #32]
		inseg.len    = p->tot_len;
    3db0:	83a9      	strh	r1, [r5, #28]
		inseg.p      = p;
    3db2:	61ae      	str	r6, [r5, #24]
		recv_flags = 0;
    3db4:	f885 2028 	strb.w	r2, [r5, #40]	; 0x28
		if (flags & TCP_PSH) {
    3db8:	d503      	bpl.n	3dc2 <tcp_input+0x16a>
			p->flags |= PBUF_FLAG_PUSH;
    3dba:	7b73      	ldrb	r3, [r6, #13]
    3dbc:	f043 0301 	orr.w	r3, r3, #1
    3dc0:	7373      	strb	r3, [r6, #13]
		if (pcb->refused_data != NULL) {
    3dc2:	6fa3      	ldr	r3, [r4, #120]	; 0x78
    3dc4:	2b00      	cmp	r3, #0
    3dc6:	f040 80e9 	bne.w	3f9c <tcp_input+0x344>
	if (flags & TCP_RST) {
    3dca:	7a2a      	ldrb	r2, [r5, #8]
		tcp_input_pcb = pcb;
    3dcc:	62ec      	str	r4, [r5, #44]	; 0x2c
	if (flags & TCP_RST) {
    3dce:	0757      	lsls	r7, r2, #29
    3dd0:	f100 80fc 	bmi.w	3fcc <tcp_input+0x374>
	if ((flags & TCP_SYN) && (pcb->state != SYN_SENT && pcb->state != SYN_RCVD)) {
    3dd4:	0796      	lsls	r6, r2, #30
			pcb->flags &= ~TF_ACK_DELAY;
    3dd6:	7fa3      	ldrb	r3, [r4, #30]
	if ((flags & TCP_SYN) && (pcb->state != SYN_SENT && pcb->state != SYN_RCVD)) {
    3dd8:	f140 8127 	bpl.w	402a <tcp_input+0x3d2>
    3ddc:	7e22      	ldrb	r2, [r4, #24]
    3dde:	3a02      	subs	r2, #2
    3de0:	2a01      	cmp	r2, #1
    3de2:	f240 8122 	bls.w	402a <tcp_input+0x3d2>
			tcp_ack_now(pcb);
    3de6:	f043 0302 	orr.w	r3, r3, #2
    3dea:	e0ff      	b.n	3fec <tcp_input+0x394>
	for (pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
    3dec:	46a2      	mov	sl, r4
    3dee:	68e4      	ldr	r4, [r4, #12]
    3df0:	e7b9      	b.n	3d66 <tcp_input+0x10e>
			if (pcb->remote_port == tcphdr->src && pcb->local_port == tcphdr->dest
    3df2:	f8bc 2000 	ldrh.w	r2, [ip]
    3df6:	f8b0 a01c 	ldrh.w	sl, [r0, #28]
    3dfa:	4592      	cmp	sl, r2
    3dfc:	d133      	bne.n	3e66 <tcp_input+0x20e>
    3dfe:	f8bc 2002 	ldrh.w	r2, [ip, #2]
    3e02:	8b44      	ldrh	r4, [r0, #26]
    3e04:	4294      	cmp	r4, r2
    3e06:	d12e      	bne.n	3e66 <tcp_input+0x20e>
			    && ip_addr_cmp(&(pcb->remote_ip), &current_iphdr_src)
    3e08:	6842      	ldr	r2, [r0, #4]
    3e0a:	4291      	cmp	r1, r2
    3e0c:	d12b      	bne.n	3e66 <tcp_input+0x20e>
			    && ip_addr_cmp(&(pcb->local_ip), &current_iphdr_dest)) {
    3e0e:	6802      	ldr	r2, [r0, #0]
    3e10:	4596      	cmp	lr, r2
    3e12:	d128      	bne.n	3e66 <tcp_input+0x20e>
	if (flags & TCP_RST) {
    3e14:	075a      	lsls	r2, r3, #29
    3e16:	d420      	bmi.n	3e5a <tcp_input+0x202>
	if (flags & TCP_SYN) {
    3e18:	079f      	lsls	r7, r3, #30
    3e1a:	d511      	bpl.n	3e40 <tcp_input+0x1e8>
		if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, pcb->rcv_nxt + pcb->rcv_wnd)) {
    3e1c:	686f      	ldr	r7, [r5, #4]
    3e1e:	6a83      	ldr	r3, [r0, #40]	; 0x28
    3e20:	1afb      	subs	r3, r7, r3
    3e22:	d412      	bmi.n	3e4a <tcp_input+0x1f2>
    3e24:	8d82      	ldrh	r2, [r0, #44]	; 0x2c
    3e26:	1a9b      	subs	r3, r3, r2
    3e28:	2b00      	cmp	r3, #0
    3e2a:	dc0e      	bgt.n	3e4a <tcp_input+0x1f2>
			tcp_rst(ackno, seqno + tcplen, ip_current_dest_addr(), ip_current_src_addr(), tcphdr->dest, tcphdr->src);
    3e2c:	9902      	ldr	r1, [sp, #8]
    3e2e:	4b2a      	ldr	r3, [pc, #168]	; (3ed8 <tcp_input+0x280>)
    3e30:	4a23      	ldr	r2, [pc, #140]	; (3ec0 <tcp_input+0x268>)
    3e32:	e9cd 4a00 	strd	r4, sl, [sp]
    3e36:	4439      	add	r1, r7
			tcp_rst(ackno, seqno + tcplen, ip_current_dest_addr(), ip_current_src_addr(), tcphdr->dest, tcphdr->src);
    3e38:	68e8      	ldr	r0, [r5, #12]
    3e3a:	4c28      	ldr	r4, [pc, #160]	; (3edc <tcp_input+0x284>)
    3e3c:	47a0      	blx	r4
    3e3e:	e00c      	b.n	3e5a <tcp_input+0x202>
	} else if (flags & TCP_FIN) {
    3e40:	07d9      	lsls	r1, r3, #31
		pcb->tmr = tcp_ticks;
    3e42:	bf42      	ittt	mi
    3e44:	4b26      	ldrmi	r3, [pc, #152]	; (3ee0 <tcp_input+0x288>)
    3e46:	681b      	ldrmi	r3, [r3, #0]
    3e48:	6243      	strmi	r3, [r0, #36]	; 0x24
	if ((tcplen > 0)) {
    3e4a:	9b02      	ldr	r3, [sp, #8]
    3e4c:	b12b      	cbz	r3, 3e5a <tcp_input+0x202>
		pcb->flags |= TF_ACK_NOW;
    3e4e:	7f83      	ldrb	r3, [r0, #30]
    3e50:	f043 0302 	orr.w	r3, r3, #2
    3e54:	7783      	strb	r3, [r0, #30]
		return tcp_output(pcb);
    3e56:	4b23      	ldr	r3, [pc, #140]	; (3ee4 <tcp_input+0x28c>)
    3e58:	4798      	blx	r3
	pbuf_free(p);
    3e5a:	4b23      	ldr	r3, [pc, #140]	; (3ee8 <tcp_input+0x290>)
    3e5c:	4630      	mov	r0, r6
}
    3e5e:	b005      	add	sp, #20
    3e60:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	pbuf_free(p);
    3e64:	4718      	bx	r3
		for (pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
    3e66:	68c0      	ldr	r0, [r0, #12]
    3e68:	2800      	cmp	r0, #0
    3e6a:	d1c2      	bne.n	3df2 <tcp_input+0x19a>
		for (lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
    3e6c:	4a1f      	ldr	r2, [pc, #124]	; (3eec <tcp_input+0x294>)
    3e6e:	6814      	ldr	r4, [r2, #0]
    3e70:	46a2      	mov	sl, r4
    3e72:	f1ba 0f00 	cmp.w	sl, #0
    3e76:	d10f      	bne.n	3e98 <tcp_input+0x240>
		if (!(TCPH_FLAGS(tcphdr) & TCP_RST)) {
    3e78:	f8bc 000c 	ldrh.w	r0, [ip, #12]
    3e7c:	4b13      	ldr	r3, [pc, #76]	; (3ecc <tcp_input+0x274>)
    3e7e:	4798      	blx	r3
    3e80:	0742      	lsls	r2, r0, #29
    3e82:	d4ea      	bmi.n	3e5a <tcp_input+0x202>
			tcp_rst(ackno, seqno + tcplen, ip_current_dest_addr(), ip_current_src_addr(), tcphdr->dest, tcphdr->src);
    3e84:	682b      	ldr	r3, [r5, #0]
    3e86:	8a28      	ldrh	r0, [r5, #16]
    3e88:	881a      	ldrh	r2, [r3, #0]
    3e8a:	9201      	str	r2, [sp, #4]
    3e8c:	885b      	ldrh	r3, [r3, #2]
    3e8e:	9300      	str	r3, [sp, #0]
    3e90:	6869      	ldr	r1, [r5, #4]
    3e92:	4b11      	ldr	r3, [pc, #68]	; (3ed8 <tcp_input+0x280>)
    3e94:	4a0a      	ldr	r2, [pc, #40]	; (3ec0 <tcp_input+0x268>)
    3e96:	e2e9      	b.n	446c <tcp_input+0x814>
			if (lpcb->local_port == tcphdr->dest) {
    3e98:	f8bc b002 	ldrh.w	fp, [ip, #2]
    3e9c:	f8ba 201a 	ldrh.w	r2, [sl, #26]
    3ea0:	455a      	cmp	r2, fp
    3ea2:	d107      	bne.n	3eb4 <tcp_input+0x25c>
				if (ip_addr_cmp(&(lpcb->local_ip), &current_iphdr_dest) || ip_addr_isany(&(lpcb->local_ip))) {
    3ea4:	f8da 2000 	ldr.w	r2, [sl]
    3ea8:	4596      	cmp	lr, r2
    3eaa:	f000 82c7 	beq.w	443c <tcp_input+0x7e4>
    3eae:	2a00      	cmp	r2, #0
    3eb0:	f000 82c4 	beq.w	443c <tcp_input+0x7e4>
		for (lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
    3eb4:	4650      	mov	r0, sl
    3eb6:	f8da a00c 	ldr.w	sl, [sl, #12]
    3eba:	e7da      	b.n	3e72 <tcp_input+0x21a>
    3ebc:	2000a4e0 	.word	0x2000a4e0
    3ec0:	20011104 	.word	0x20011104
    3ec4:	00008a1b 	.word	0x00008a1b
    3ec8:	00008385 	.word	0x00008385
    3ecc:	00000d6b 	.word	0x00000d6b
    3ed0:	20014958 	.word	0x20014958
    3ed4:	20014950 	.word	0x20014950
    3ed8:	20011108 	.word	0x20011108
    3edc:	00002729 	.word	0x00002729
    3ee0:	20014948 	.word	0x20014948
    3ee4:	000024a5 	.word	0x000024a5
    3ee8:	000030e5 	.word	0x000030e5
    3eec:	20014944 	.word	0x20014944
    3ef0:	0000308d 	.word	0x0000308d
    3ef4:	00000d75 	.word	0x00000d75
	} else if (flags & TCP_SYN) {
    3ef8:	079b      	lsls	r3, r3, #30
    3efa:	d5ae      	bpl.n	3e5a <tcp_input+0x202>
		npcb = tcp_alloc(pcb->prio);
    3efc:	f89a 0019 	ldrb.w	r0, [sl, #25]
    3f00:	4b98      	ldr	r3, [pc, #608]	; (4164 <tcp_input+0x50c>)
    3f02:	4798      	blx	r3
		if (npcb == NULL) {
    3f04:	4683      	mov	fp, r0
    3f06:	2800      	cmp	r0, #0
    3f08:	d0a7      	beq.n	3e5a <tcp_input+0x202>
		ip_addr_copy(npcb->local_ip, current_iphdr_dest);
    3f0a:	683b      	ldr	r3, [r7, #0]
    3f0c:	6003      	str	r3, [r0, #0]
		npcb->remote_port        = tcphdr->src;
    3f0e:	682a      	ldr	r2, [r5, #0]
		npcb->local_port = pcb->local_port;
    3f10:	f8ba 301a 	ldrh.w	r3, [sl, #26]
    3f14:	8343      	strh	r3, [r0, #26]
		ip_addr_copy(npcb->remote_ip, current_iphdr_src);
    3f16:	f8d8 3000 	ldr.w	r3, [r8]
		npcb->remote_port        = tcphdr->src;
    3f1a:	7851      	ldrb	r1, [r2, #1]
		ip_addr_copy(npcb->remote_ip, current_iphdr_src);
    3f1c:	6043      	str	r3, [r0, #4]
		npcb->remote_port        = tcphdr->src;
    3f1e:	7813      	ldrb	r3, [r2, #0]
    3f20:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
    3f24:	8383      	strh	r3, [r0, #28]
		npcb->state              = SYN_RCVD;
    3f26:	2303      	movs	r3, #3
    3f28:	7603      	strb	r3, [r0, #24]
		npcb->rcv_nxt            = seqno + 1;
    3f2a:	686b      	ldr	r3, [r5, #4]
    3f2c:	1c59      	adds	r1, r3, #1
    3f2e:	6281      	str	r1, [r0, #40]	; 0x28
		npcb->rcv_ann_right_edge = npcb->rcv_nxt;
    3f30:	6301      	str	r1, [r0, #48]	; 0x30
		npcb->snd_wl1            = seqno - 1; /* initialise to seqno-1 to force window update */
    3f32:	3b01      	subs	r3, #1
		npcb->snd_wnd            = tcphdr->wnd;
    3f34:	89d2      	ldrh	r2, [r2, #14]
		npcb->snd_wl1            = seqno - 1; /* initialise to seqno-1 to force window update */
    3f36:	6543      	str	r3, [r0, #84]	; 0x54
		npcb->callback_arg       = pcb->callback_arg;
    3f38:	f8da 3010 	ldr.w	r3, [sl, #16]
    3f3c:	6103      	str	r3, [r0, #16]
		npcb->accept = pcb->accept;
    3f3e:	f8da 3014 	ldr.w	r3, [sl, #20]
		npcb->snd_wnd            = tcphdr->wnd;
    3f42:	f8a0 2060 	strh.w	r2, [r0, #96]	; 0x60
		npcb->snd_wnd_max        = tcphdr->wnd;
    3f46:	f8a0 2062 	strh.w	r2, [r0, #98]	; 0x62
		npcb->ssthresh           = npcb->snd_wnd;
    3f4a:	f8a0 204e 	strh.w	r2, [r0, #78]	; 0x4e
		npcb->accept = pcb->accept;
    3f4e:	6143      	str	r3, [r0, #20]
		npcb->so_options = pcb->so_options & SOF_INHERITED;
    3f50:	f89a 3008 	ldrb.w	r3, [sl, #8]
    3f54:	f023 0373 	bic.w	r3, r3, #115	; 0x73
    3f58:	7203      	strb	r3, [r0, #8]
		TCP_REG_ACTIVE(npcb);
    3f5a:	f8d9 3000 	ldr.w	r3, [r9]
    3f5e:	60c3      	str	r3, [r0, #12]
    3f60:	4b81      	ldr	r3, [pc, #516]	; (4168 <tcp_input+0x510>)
    3f62:	f8c9 0000 	str.w	r0, [r9]
    3f66:	4798      	blx	r3
    3f68:	4b80      	ldr	r3, [pc, #512]	; (416c <tcp_input+0x514>)
    3f6a:	2201      	movs	r2, #1
    3f6c:	701a      	strb	r2, [r3, #0]
		tcp_parseopt(npcb);
    3f6e:	4658      	mov	r0, fp
    3f70:	4b7f      	ldr	r3, [pc, #508]	; (4170 <tcp_input+0x518>)
    3f72:	4798      	blx	r3
		npcb->mss = tcp_eff_send_mss(npcb->mss, &(npcb->remote_ip));
    3f74:	4b7f      	ldr	r3, [pc, #508]	; (4174 <tcp_input+0x51c>)
    3f76:	f8bb 0036 	ldrh.w	r0, [fp, #54]	; 0x36
    3f7a:	f10b 0104 	add.w	r1, fp, #4
    3f7e:	4798      	blx	r3
		rc = tcp_enqueue_flags(npcb, TCP_SYN | TCP_ACK);
    3f80:	4b7d      	ldr	r3, [pc, #500]	; (4178 <tcp_input+0x520>)
		npcb->mss = tcp_eff_send_mss(npcb->mss, &(npcb->remote_ip));
    3f82:	f8ab 0036 	strh.w	r0, [fp, #54]	; 0x36
		rc = tcp_enqueue_flags(npcb, TCP_SYN | TCP_ACK);
    3f86:	2112      	movs	r1, #18
    3f88:	4658      	mov	r0, fp
    3f8a:	4798      	blx	r3
		if (rc != ERR_OK) {
    3f8c:	b120      	cbz	r0, 3f98 <tcp_input+0x340>
			tcp_abandon(npcb, 0);
    3f8e:	4b7b      	ldr	r3, [pc, #492]	; (417c <tcp_input+0x524>)
    3f90:	4621      	mov	r1, r4
    3f92:	4658      	mov	r0, fp
    3f94:	4798      	blx	r3
			return rc;
    3f96:	e760      	b.n	3e5a <tcp_input+0x202>
		return tcp_output(npcb);
    3f98:	4658      	mov	r0, fp
    3f9a:	e75c      	b.n	3e56 <tcp_input+0x1fe>
			if ((tcp_process_refused_data(pcb) == ERR_ABRT) || ((pcb->refused_data != NULL) && (tcplen > 0))) {
    3f9c:	4b78      	ldr	r3, [pc, #480]	; (4180 <tcp_input+0x528>)
    3f9e:	4620      	mov	r0, r4
    3fa0:	4798      	blx	r3
    3fa2:	300a      	adds	r0, #10
    3fa4:	d007      	beq.n	3fb6 <tcp_input+0x35e>
    3fa6:	6fa3      	ldr	r3, [r4, #120]	; 0x78
    3fa8:	2b00      	cmp	r3, #0
    3faa:	f43f af0e 	beq.w	3dca <tcp_input+0x172>
    3fae:	8a2b      	ldrh	r3, [r5, #16]
    3fb0:	2b00      	cmp	r3, #0
    3fb2:	f43f af0a 	beq.w	3dca <tcp_input+0x172>
		if (inseg.p != NULL) {
    3fb6:	69a8      	ldr	r0, [r5, #24]
		tcp_input_pcb = NULL;
    3fb8:	2400      	movs	r4, #0
    3fba:	62ec      	str	r4, [r5, #44]	; 0x2c
		recv_data     = NULL;
    3fbc:	626c      	str	r4, [r5, #36]	; 0x24
		if (inseg.p != NULL) {
    3fbe:	b110      	cbz	r0, 3fc6 <tcp_input+0x36e>
			pbuf_free(inseg.p);
    3fc0:	4b70      	ldr	r3, [pc, #448]	; (4184 <tcp_input+0x52c>)
    3fc2:	4798      	blx	r3
			inseg.p = NULL;
    3fc4:	61ac      	str	r4, [r5, #24]
}
    3fc6:	b005      	add	sp, #20
    3fc8:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		if (pcb->state == SYN_SENT) {
    3fcc:	7e23      	ldrb	r3, [r4, #24]
    3fce:	2b02      	cmp	r3, #2
    3fd0:	d10e      	bne.n	3ff0 <tcp_input+0x398>
			if (ackno == pcb->snd_nxt) {
    3fd2:	6d22      	ldr	r2, [r4, #80]	; 0x50
    3fd4:	68eb      	ldr	r3, [r5, #12]
    3fd6:	429a      	cmp	r2, r3
    3fd8:	d112      	bne.n	4000 <tcp_input+0x3a8>
			recv_flags |= TF_RESET;
    3fda:	f895 3028 	ldrb.w	r3, [r5, #40]	; 0x28
    3fde:	f043 0308 	orr.w	r3, r3, #8
    3fe2:	f885 3028 	strb.w	r3, [r5, #40]	; 0x28
			pcb->flags &= ~TF_ACK_DELAY;
    3fe6:	7fa3      	ldrb	r3, [r4, #30]
    3fe8:	f023 0301 	bic.w	r3, r3, #1
			tcp_ack_now(pcb);
    3fec:	77a3      	strb	r3, [r4, #30]
		if (err != ERR_ABRT) {
    3fee:	e007      	b.n	4000 <tcp_input+0x3a8>
			if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, pcb->rcv_nxt + pcb->rcv_wnd)) {
    3ff0:	686b      	ldr	r3, [r5, #4]
    3ff2:	6aa2      	ldr	r2, [r4, #40]	; 0x28
    3ff4:	1a9b      	subs	r3, r3, r2
    3ff6:	d403      	bmi.n	4000 <tcp_input+0x3a8>
    3ff8:	8da2      	ldrh	r2, [r4, #44]	; 0x2c
    3ffa:	1a9b      	subs	r3, r3, r2
    3ffc:	2b00      	cmp	r3, #0
    3ffe:	ddec      	ble.n	3fda <tcp_input+0x382>
			if (recv_flags & TF_RESET) {
    4000:	f895 3028 	ldrb.w	r3, [r5, #40]	; 0x28
    4004:	071f      	lsls	r7, r3, #28
    4006:	f140 81a3 	bpl.w	4350 <tcp_input+0x6f8>
				TCP_EVENT_ERR(pcb->errf, pcb->callback_arg, ERR_RST);
    400a:	f8d4 308c 	ldr.w	r3, [r4, #140]	; 0x8c
    400e:	b11b      	cbz	r3, 4018 <tcp_input+0x3c0>
    4010:	f06f 010a 	mvn.w	r1, #10
					TCP_EVENT_ERR(pcb->errf, pcb->callback_arg, ERR_CLSD);
    4014:	6920      	ldr	r0, [r4, #16]
    4016:	4798      	blx	r3
				tcp_pcb_remove(&tcp_active_pcbs, pcb);
    4018:	4621      	mov	r1, r4
    401a:	485b      	ldr	r0, [pc, #364]	; (4188 <tcp_input+0x530>)
    401c:	4b5b      	ldr	r3, [pc, #364]	; (418c <tcp_input+0x534>)
    401e:	4798      	blx	r3
				memp_free(MEMP_TCP_PCB, pcb);
    4020:	4b5b      	ldr	r3, [pc, #364]	; (4190 <tcp_input+0x538>)
    4022:	4621      	mov	r1, r4
    4024:	2001      	movs	r0, #1
    4026:	4798      	blx	r3
    4028:	e7c5      	b.n	3fb6 <tcp_input+0x35e>
	if ((pcb->flags & TF_RXCLOSED) == 0) {
    402a:	06d8      	lsls	r0, r3, #27
		pcb->tmr = tcp_ticks;
    402c:	bf5e      	ittt	pl
    402e:	4b59      	ldrpl	r3, [pc, #356]	; (4194 <tcp_input+0x53c>)
    4030:	681b      	ldrpl	r3, [r3, #0]
    4032:	6263      	strpl	r3, [r4, #36]	; 0x24
	pcb->keep_cnt_sent = 0;
    4034:	2300      	movs	r3, #0
    4036:	f884 3096 	strb.w	r3, [r4, #150]	; 0x96
	tcp_parseopt(pcb);
    403a:	4620      	mov	r0, r4
    403c:	4b4c      	ldr	r3, [pc, #304]	; (4170 <tcp_input+0x518>)
    403e:	4798      	blx	r3
	switch (pcb->state) {
    4040:	7e23      	ldrb	r3, [r4, #24]
    4042:	3b02      	subs	r3, #2
    4044:	2b07      	cmp	r3, #7
    4046:	d8db      	bhi.n	4000 <tcp_input+0x3a8>
    4048:	e8df f013 	tbh	[pc, r3, lsl #1]
    404c:	006f0008 	.word	0x006f0008
    4050:	00ec00e8 	.word	0x00ec00e8
    4054:	00e80134 	.word	0x00e80134
    4058:	01700152 	.word	0x01700152
		if ((flags & TCP_ACK) && (flags & TCP_SYN) && ackno == ntohl(pcb->unacked->tcphdr->seqno) + 1) {
    405c:	7a2b      	ldrb	r3, [r5, #8]
    405e:	f003 0312 	and.w	r3, r3, #18
    4062:	2b12      	cmp	r3, #18
    4064:	d14f      	bne.n	4106 <tcp_input+0x4ae>
    4066:	6f23      	ldr	r3, [r4, #112]	; 0x70
    4068:	68db      	ldr	r3, [r3, #12]
    406a:	6858      	ldr	r0, [r3, #4]
    406c:	4b4a      	ldr	r3, [pc, #296]	; (4198 <tcp_input+0x540>)
    406e:	4798      	blx	r3
    4070:	68eb      	ldr	r3, [r5, #12]
    4072:	3001      	adds	r0, #1
    4074:	4298      	cmp	r0, r3
    4076:	d146      	bne.n	4106 <tcp_input+0x4ae>
			pcb->snd_buf++;
    4078:	f8b4 3066 	ldrh.w	r3, [r4, #102]	; 0x66
			pcb->lastack            = ackno;
    407c:	64a0      	str	r0, [r4, #72]	; 0x48
			pcb->snd_buf++;
    407e:	3301      	adds	r3, #1
    4080:	f8a4 3066 	strh.w	r3, [r4, #102]	; 0x66
			pcb->rcv_nxt            = seqno + 1;
    4084:	686b      	ldr	r3, [r5, #4]
			pcb->mss = tcp_eff_send_mss(pcb->mss, &(pcb->remote_ip));
    4086:	8ee0      	ldrh	r0, [r4, #54]	; 0x36
			pcb->rcv_nxt            = seqno + 1;
    4088:	1c5a      	adds	r2, r3, #1
    408a:	62a2      	str	r2, [r4, #40]	; 0x28
			pcb->rcv_ann_right_edge = pcb->rcv_nxt;
    408c:	6322      	str	r2, [r4, #48]	; 0x30
			pcb->snd_wnd            = tcphdr->wnd;
    408e:	682a      	ldr	r2, [r5, #0]
			pcb->snd_wl1            = seqno - 1; /* initialise to seqno - 1 to force window update */
    4090:	3b01      	subs	r3, #1
			pcb->snd_wnd            = tcphdr->wnd;
    4092:	89d2      	ldrh	r2, [r2, #14]
			pcb->snd_wl1            = seqno - 1; /* initialise to seqno - 1 to force window update */
    4094:	6563      	str	r3, [r4, #84]	; 0x54
			pcb->state              = ESTABLISHED;
    4096:	2304      	movs	r3, #4
			pcb->mss = tcp_eff_send_mss(pcb->mss, &(pcb->remote_ip));
    4098:	18e1      	adds	r1, r4, r3
			pcb->snd_wnd            = tcphdr->wnd;
    409a:	f8a4 2060 	strh.w	r2, [r4, #96]	; 0x60
			pcb->snd_wnd_max        = tcphdr->wnd;
    409e:	f8a4 2062 	strh.w	r2, [r4, #98]	; 0x62
			pcb->state              = ESTABLISHED;
    40a2:	7623      	strb	r3, [r4, #24]
			pcb->mss = tcp_eff_send_mss(pcb->mss, &(pcb->remote_ip));
    40a4:	4b33      	ldr	r3, [pc, #204]	; (4174 <tcp_input+0x51c>)
    40a6:	4798      	blx	r3
			pcb->ssthresh = pcb->mss * 10;
    40a8:	eb00 0380 	add.w	r3, r0, r0, lsl #2
    40ac:	005b      	lsls	r3, r3, #1
    40ae:	f8a4 304e 	strh.w	r3, [r4, #78]	; 0x4e
			pcb->cwnd = ((pcb->cwnd == 1) ? (pcb->mss * 2) : pcb->mss);
    40b2:	f8b4 304c 	ldrh.w	r3, [r4, #76]	; 0x4c
			pcb->mss = tcp_eff_send_mss(pcb->mss, &(pcb->remote_ip));
    40b6:	86e0      	strh	r0, [r4, #54]	; 0x36
			pcb->cwnd = ((pcb->cwnd == 1) ? (pcb->mss * 2) : pcb->mss);
    40b8:	2b01      	cmp	r3, #1
    40ba:	bf08      	it	eq
    40bc:	0040      	lsleq	r0, r0, #1
			--pcb->snd_queuelen;
    40be:	f8b4 3068 	ldrh.w	r3, [r4, #104]	; 0x68
			pcb->cwnd = ((pcb->cwnd == 1) ? (pcb->mss * 2) : pcb->mss);
    40c2:	bf08      	it	eq
    40c4:	b280      	uxtheq	r0, r0
    40c6:	f8a4 004c 	strh.w	r0, [r4, #76]	; 0x4c
			rseg         = pcb->unacked;
    40ca:	6f20      	ldr	r0, [r4, #112]	; 0x70
			--pcb->snd_queuelen;
    40cc:	3b01      	subs	r3, #1
    40ce:	f8a4 3068 	strh.w	r3, [r4, #104]	; 0x68
			pcb->unacked = rseg->next;
    40d2:	6803      	ldr	r3, [r0, #0]
    40d4:	6723      	str	r3, [r4, #112]	; 0x70
			tcp_seg_free(rseg);
    40d6:	4b31      	ldr	r3, [pc, #196]	; (419c <tcp_input+0x544>)
    40d8:	4798      	blx	r3
			if (pcb->unacked == NULL)
    40da:	6f23      	ldr	r3, [r4, #112]	; 0x70
    40dc:	b93b      	cbnz	r3, 40ee <tcp_input+0x496>
				pcb->rtime = -1;
    40de:	f64f 73ff 	movw	r3, #65535	; 0xffff
    40e2:	86a3      	strh	r3, [r4, #52]	; 0x34
			TCP_EVENT_CONNECTED(pcb, ERR_OK, err);
    40e4:	f8d4 3084 	ldr.w	r3, [r4, #132]	; 0x84
    40e8:	b933      	cbnz	r3, 40f8 <tcp_input+0x4a0>
			tcp_ack_now(pcb);
    40ea:	7fa3      	ldrb	r3, [r4, #30]
    40ec:	e67b      	b.n	3de6 <tcp_input+0x18e>
				pcb->rtime = 0;
    40ee:	2300      	movs	r3, #0
    40f0:	86a3      	strh	r3, [r4, #52]	; 0x34
				pcb->nrtx  = 0;
    40f2:	f884 3046 	strb.w	r3, [r4, #70]	; 0x46
    40f6:	e7f5      	b.n	40e4 <tcp_input+0x48c>
			TCP_EVENT_CONNECTED(pcb, ERR_OK, err);
    40f8:	6920      	ldr	r0, [r4, #16]
    40fa:	2200      	movs	r2, #0
    40fc:	4621      	mov	r1, r4
    40fe:	4798      	blx	r3
			if (err == ERR_ABRT) {
    4100:	300a      	adds	r0, #10
    4102:	d1f2      	bne.n	40ea <tcp_input+0x492>
    4104:	e757      	b.n	3fb6 <tcp_input+0x35e>
		else if (flags & TCP_ACK) {
    4106:	7a2b      	ldrb	r3, [r5, #8]
    4108:	06d9      	lsls	r1, r3, #27
    410a:	f57f af79 	bpl.w	4000 <tcp_input+0x3a8>
			tcp_rst(ackno, seqno + tcplen, ip_current_dest_addr(), ip_current_src_addr(), tcphdr->dest, tcphdr->src);
    410e:	682b      	ldr	r3, [r5, #0]
    4110:	8a28      	ldrh	r0, [r5, #16]
    4112:	881a      	ldrh	r2, [r3, #0]
    4114:	9201      	str	r2, [sp, #4]
    4116:	6869      	ldr	r1, [r5, #4]
    4118:	885b      	ldrh	r3, [r3, #2]
    411a:	9300      	str	r3, [sp, #0]
    411c:	4401      	add	r1, r0
    411e:	4b20      	ldr	r3, [pc, #128]	; (41a0 <tcp_input+0x548>)
    4120:	4a20      	ldr	r2, [pc, #128]	; (41a4 <tcp_input+0x54c>)
    4122:	68e8      	ldr	r0, [r5, #12]
				tcp_rst(
    4124:	4e20      	ldr	r6, [pc, #128]	; (41a8 <tcp_input+0x550>)
    4126:	47b0      	blx	r6
		if (err != ERR_ABRT) {
    4128:	e76a      	b.n	4000 <tcp_input+0x3a8>
		if (flags & TCP_ACK) {
    412a:	7a2b      	ldrb	r3, [r5, #8]
    412c:	06da      	lsls	r2, r3, #27
    412e:	d568      	bpl.n	4202 <tcp_input+0x5aa>
			if (TCP_SEQ_BETWEEN(ackno, pcb->lastack + 1, pcb->snd_nxt)) {
    4130:	6ca3      	ldr	r3, [r4, #72]	; 0x48
    4132:	68e8      	ldr	r0, [r5, #12]
    4134:	43db      	mvns	r3, r3
    4136:	42c3      	cmn	r3, r0
    4138:	d458      	bmi.n	41ec <tcp_input+0x594>
    413a:	6d23      	ldr	r3, [r4, #80]	; 0x50
    413c:	1ac3      	subs	r3, r0, r3
    413e:	2b00      	cmp	r3, #0
    4140:	dc54      	bgt.n	41ec <tcp_input+0x594>
				pcb->state = ESTABLISHED;
    4142:	2304      	movs	r3, #4
    4144:	7623      	strb	r3, [r4, #24]
				TCP_EVENT_ACCEPT(pcb, ERR_OK, err);
    4146:	6963      	ldr	r3, [r4, #20]
    4148:	b91b      	cbnz	r3, 4152 <tcp_input+0x4fa>
						tcp_abort(pcb);
    414a:	4b18      	ldr	r3, [pc, #96]	; (41ac <tcp_input+0x554>)
    414c:	4620      	mov	r0, r4
    414e:	4798      	blx	r3
						goto aborted;
    4150:	e731      	b.n	3fb6 <tcp_input+0x35e>
				TCP_EVENT_ACCEPT(pcb, ERR_OK, err);
    4152:	6920      	ldr	r0, [r4, #16]
    4154:	2200      	movs	r2, #0
    4156:	4621      	mov	r1, r4
    4158:	4798      	blx	r3
				if (err != ERR_OK) {
    415a:	b348      	cbz	r0, 41b0 <tcp_input+0x558>
					if (err != ERR_ABRT) {
    415c:	300a      	adds	r0, #10
    415e:	f43f af2a 	beq.w	3fb6 <tcp_input+0x35e>
    4162:	e7f2      	b.n	414a <tcp_input+0x4f2>
    4164:	00007299 	.word	0x00007299
    4168:	000010a5 	.word	0x000010a5
    416c:	20014954 	.word	0x20014954
    4170:	000033e1 	.word	0x000033e1
    4174:	0000739d 	.word	0x0000739d
    4178:	0000233d 	.word	0x0000233d
    417c:	000071c9 	.word	0x000071c9
    4180:	00007071 	.word	0x00007071
    4184:	000030e5 	.word	0x000030e5
    4188:	20014950 	.word	0x20014950
    418c:	00006e59 	.word	0x00006e59
    4190:	00004c1d 	.word	0x00004c1d
    4194:	20014948 	.word	0x20014948
    4198:	00000d75 	.word	0x00000d75
    419c:	00006ac1 	.word	0x00006ac1
    41a0:	20011108 	.word	0x20011108
    41a4:	20011104 	.word	0x20011104
    41a8:	00002729 	.word	0x00002729
    41ac:	00007275 	.word	0x00007275
				tcp_receive(pcb);
    41b0:	4b95      	ldr	r3, [pc, #596]	; (4408 <tcp_input+0x7b0>)
				old_cwnd = pcb->cwnd;
    41b2:	f8b4 604c 	ldrh.w	r6, [r4, #76]	; 0x4c
				tcp_receive(pcb);
    41b6:	4620      	mov	r0, r4
    41b8:	4798      	blx	r3
				if (pcb->acked != 0) {
    41ba:	f8b4 3064 	ldrh.w	r3, [r4, #100]	; 0x64
    41be:	b113      	cbz	r3, 41c6 <tcp_input+0x56e>
					pcb->acked--;
    41c0:	3b01      	subs	r3, #1
    41c2:	f8a4 3064 	strh.w	r3, [r4, #100]	; 0x64
				pcb->cwnd = ((old_cwnd == 1) ? (pcb->mss * 2) : pcb->mss);
    41c6:	8ee3      	ldrh	r3, [r4, #54]	; 0x36
    41c8:	2e01      	cmp	r6, #1
    41ca:	bf04      	itt	eq
    41cc:	005b      	lsleq	r3, r3, #1
    41ce:	b29b      	uxtheq	r3, r3
    41d0:	f8a4 304c 	strh.w	r3, [r4, #76]	; 0x4c
		if (recv_flags & TF_GOT_FIN) { /* passive close */
    41d4:	f895 3028 	ldrb.w	r3, [r5, #40]	; 0x28
    41d8:	069e      	lsls	r6, r3, #26
    41da:	f57f af11 	bpl.w	4000 <tcp_input+0x3a8>
			tcp_ack_now(pcb);
    41de:	7fa3      	ldrb	r3, [r4, #30]
    41e0:	f043 0302 	orr.w	r3, r3, #2
    41e4:	77a3      	strb	r3, [r4, #30]
			pcb->state = CLOSE_WAIT;
    41e6:	2307      	movs	r3, #7
			pcb->state = FIN_WAIT_2;
    41e8:	7623      	strb	r3, [r4, #24]
		if (err != ERR_ABRT) {
    41ea:	e709      	b.n	4000 <tcp_input+0x3a8>
				    ackno, seqno + tcplen, ip_current_dest_addr(), ip_current_src_addr(), tcphdr->dest, tcphdr->src);
    41ec:	682b      	ldr	r3, [r5, #0]
				tcp_rst(
    41ee:	8a2e      	ldrh	r6, [r5, #16]
    41f0:	881a      	ldrh	r2, [r3, #0]
    41f2:	9201      	str	r2, [sp, #4]
    41f4:	6869      	ldr	r1, [r5, #4]
    41f6:	885b      	ldrh	r3, [r3, #2]
    41f8:	9300      	str	r3, [sp, #0]
    41fa:	4a84      	ldr	r2, [pc, #528]	; (440c <tcp_input+0x7b4>)
    41fc:	4b84      	ldr	r3, [pc, #528]	; (4410 <tcp_input+0x7b8>)
    41fe:	4431      	add	r1, r6
    4200:	e790      	b.n	4124 <tcp_input+0x4cc>
		} else if ((flags & TCP_SYN) && (seqno == pcb->rcv_nxt - 1)) {
    4202:	079f      	lsls	r7, r3, #30
    4204:	f57f aefc 	bpl.w	4000 <tcp_input+0x3a8>
    4208:	6aa3      	ldr	r3, [r4, #40]	; 0x28
    420a:	686a      	ldr	r2, [r5, #4]
    420c:	3b01      	subs	r3, #1
    420e:	4293      	cmp	r3, r2
    4210:	f47f aef6 	bne.w	4000 <tcp_input+0x3a8>
			tcp_rexmit(pcb);
    4214:	4b7f      	ldr	r3, [pc, #508]	; (4414 <tcp_input+0x7bc>)
    4216:	4620      	mov	r0, r4
    4218:	4798      	blx	r3
		if (err != ERR_ABRT) {
    421a:	e6f1      	b.n	4000 <tcp_input+0x3a8>
		tcp_receive(pcb);
    421c:	4b7a      	ldr	r3, [pc, #488]	; (4408 <tcp_input+0x7b0>)
    421e:	4620      	mov	r0, r4
    4220:	4798      	blx	r3
    4222:	e7d7      	b.n	41d4 <tcp_input+0x57c>
		tcp_receive(pcb);
    4224:	4b78      	ldr	r3, [pc, #480]	; (4408 <tcp_input+0x7b0>)
    4226:	4620      	mov	r0, r4
    4228:	4798      	blx	r3
		if (recv_flags & TF_GOT_FIN) {
    422a:	f895 3028 	ldrb.w	r3, [r5, #40]	; 0x28
    422e:	f013 0f20 	tst.w	r3, #32
    4232:	7a2b      	ldrb	r3, [r5, #8]
    4234:	d034      	beq.n	42a0 <tcp_input+0x648>
			if ((flags & TCP_ACK) && (ackno == pcb->snd_nxt)) {
    4236:	f013 0f10 	tst.w	r3, #16
    423a:	7fa3      	ldrb	r3, [r4, #30]
				tcp_ack_now(pcb);
    423c:	f043 0302 	orr.w	r3, r3, #2
			if ((flags & TCP_ACK) && (ackno == pcb->snd_nxt)) {
    4240:	d02b      	beq.n	429a <tcp_input+0x642>
    4242:	6d21      	ldr	r1, [r4, #80]	; 0x50
    4244:	68ea      	ldr	r2, [r5, #12]
    4246:	4291      	cmp	r1, r2
    4248:	d127      	bne.n	429a <tcp_input+0x642>
				tcp_ack_now(pcb);
    424a:	77a3      	strb	r3, [r4, #30]
				tcp_pcb_purge(pcb);
    424c:	4620      	mov	r0, r4
    424e:	4b72      	ldr	r3, [pc, #456]	; (4418 <tcp_input+0x7c0>)
    4250:	4798      	blx	r3
				TCP_RMV_ACTIVE(pcb);
    4252:	4a72      	ldr	r2, [pc, #456]	; (441c <tcp_input+0x7c4>)
    4254:	6813      	ldr	r3, [r2, #0]
    4256:	429c      	cmp	r4, r3
    4258:	d102      	bne.n	4260 <tcp_input+0x608>
			TCP_RMV_ACTIVE(pcb);
    425a:	68e3      	ldr	r3, [r4, #12]
    425c:	6013      	str	r3, [r2, #0]
    425e:	e00d      	b.n	427c <tcp_input+0x624>
				TCP_RMV_ACTIVE(pcb);
    4260:	4a6f      	ldr	r2, [pc, #444]	; (4420 <tcp_input+0x7c8>)
    4262:	2100      	movs	r1, #0
    4264:	6013      	str	r3, [r2, #0]
    4266:	b913      	cbnz	r3, 426e <tcp_input+0x616>
    4268:	2900      	cmp	r1, #0
    426a:	d1f7      	bne.n	425c <tcp_input+0x604>
    426c:	e006      	b.n	427c <tcp_input+0x624>
    426e:	68d8      	ldr	r0, [r3, #12]
    4270:	4284      	cmp	r4, r0
    4272:	d10f      	bne.n	4294 <tcp_input+0x63c>
    4274:	b101      	cbz	r1, 4278 <tcp_input+0x620>
    4276:	6013      	str	r3, [r2, #0]
			TCP_RMV_ACTIVE(pcb);
    4278:	68e2      	ldr	r2, [r4, #12]
    427a:	60da      	str	r2, [r3, #12]
    427c:	4b69      	ldr	r3, [pc, #420]	; (4424 <tcp_input+0x7cc>)
    427e:	2201      	movs	r2, #1
    4280:	701a      	strb	r2, [r3, #0]
			pcb->state = TIME_WAIT;
    4282:	230a      	movs	r3, #10
    4284:	7623      	strb	r3, [r4, #24]
			TCP_REG(&tcp_tw_pcbs, pcb);
    4286:	4b68      	ldr	r3, [pc, #416]	; (4428 <tcp_input+0x7d0>)
    4288:	681a      	ldr	r2, [r3, #0]
    428a:	60e2      	str	r2, [r4, #12]
    428c:	601c      	str	r4, [r3, #0]
    428e:	4b67      	ldr	r3, [pc, #412]	; (442c <tcp_input+0x7d4>)
    4290:	4798      	blx	r3
		if (err != ERR_ABRT) {
    4292:	e6b5      	b.n	4000 <tcp_input+0x3a8>
    4294:	2101      	movs	r1, #1
    4296:	4603      	mov	r3, r0
    4298:	e7e5      	b.n	4266 <tcp_input+0x60e>
				tcp_ack_now(pcb);
    429a:	77a3      	strb	r3, [r4, #30]
				pcb->state = CLOSING;
    429c:	2308      	movs	r3, #8
    429e:	e7a3      	b.n	41e8 <tcp_input+0x590>
		} else if ((flags & TCP_ACK) && (ackno == pcb->snd_nxt)) {
    42a0:	06d8      	lsls	r0, r3, #27
    42a2:	f57f aead 	bpl.w	4000 <tcp_input+0x3a8>
    42a6:	6d22      	ldr	r2, [r4, #80]	; 0x50
    42a8:	68eb      	ldr	r3, [r5, #12]
    42aa:	429a      	cmp	r2, r3
    42ac:	f47f aea8 	bne.w	4000 <tcp_input+0x3a8>
			pcb->state = FIN_WAIT_2;
    42b0:	2306      	movs	r3, #6
    42b2:	e799      	b.n	41e8 <tcp_input+0x590>
		tcp_receive(pcb);
    42b4:	4b54      	ldr	r3, [pc, #336]	; (4408 <tcp_input+0x7b0>)
    42b6:	4620      	mov	r0, r4
    42b8:	4798      	blx	r3
		if (recv_flags & TF_GOT_FIN) {
    42ba:	f895 3028 	ldrb.w	r3, [r5, #40]	; 0x28
    42be:	0699      	lsls	r1, r3, #26
    42c0:	f57f ae9e 	bpl.w	4000 <tcp_input+0x3a8>
			tcp_ack_now(pcb);
    42c4:	7fa3      	ldrb	r3, [r4, #30]
    42c6:	f043 0302 	orr.w	r3, r3, #2
    42ca:	77a3      	strb	r3, [r4, #30]
			tcp_pcb_purge(pcb);
    42cc:	4620      	mov	r0, r4
    42ce:	4b52      	ldr	r3, [pc, #328]	; (4418 <tcp_input+0x7c0>)
    42d0:	4798      	blx	r3
			TCP_RMV_ACTIVE(pcb);
    42d2:	4a52      	ldr	r2, [pc, #328]	; (441c <tcp_input+0x7c4>)
    42d4:	6813      	ldr	r3, [r2, #0]
    42d6:	429c      	cmp	r4, r3
    42d8:	d0bf      	beq.n	425a <tcp_input+0x602>
    42da:	4a51      	ldr	r2, [pc, #324]	; (4420 <tcp_input+0x7c8>)
    42dc:	2100      	movs	r1, #0
    42de:	6013      	str	r3, [r2, #0]
    42e0:	2b00      	cmp	r3, #0
    42e2:	d0c1      	beq.n	4268 <tcp_input+0x610>
    42e4:	68d8      	ldr	r0, [r3, #12]
    42e6:	4284      	cmp	r4, r0
    42e8:	d0c4      	beq.n	4274 <tcp_input+0x61c>
    42ea:	2101      	movs	r1, #1
    42ec:	4603      	mov	r3, r0
    42ee:	e7f7      	b.n	42e0 <tcp_input+0x688>
		tcp_receive(pcb);
    42f0:	4b45      	ldr	r3, [pc, #276]	; (4408 <tcp_input+0x7b0>)
    42f2:	4620      	mov	r0, r4
    42f4:	4798      	blx	r3
		if (flags & TCP_ACK && ackno == pcb->snd_nxt) {
    42f6:	7a2b      	ldrb	r3, [r5, #8]
    42f8:	06da      	lsls	r2, r3, #27
    42fa:	f57f ae81 	bpl.w	4000 <tcp_input+0x3a8>
    42fe:	6d22      	ldr	r2, [r4, #80]	; 0x50
    4300:	68eb      	ldr	r3, [r5, #12]
    4302:	429a      	cmp	r2, r3
    4304:	f47f ae7c 	bne.w	4000 <tcp_input+0x3a8>
			tcp_pcb_purge(pcb);
    4308:	4b43      	ldr	r3, [pc, #268]	; (4418 <tcp_input+0x7c0>)
    430a:	4620      	mov	r0, r4
    430c:	4798      	blx	r3
			TCP_RMV_ACTIVE(pcb);
    430e:	4a43      	ldr	r2, [pc, #268]	; (441c <tcp_input+0x7c4>)
    4310:	6813      	ldr	r3, [r2, #0]
    4312:	429c      	cmp	r4, r3
    4314:	d0a1      	beq.n	425a <tcp_input+0x602>
    4316:	4a42      	ldr	r2, [pc, #264]	; (4420 <tcp_input+0x7c8>)
    4318:	2100      	movs	r1, #0
    431a:	6013      	str	r3, [r2, #0]
    431c:	2b00      	cmp	r3, #0
    431e:	d0a3      	beq.n	4268 <tcp_input+0x610>
    4320:	68d8      	ldr	r0, [r3, #12]
    4322:	4284      	cmp	r4, r0
    4324:	d0a6      	beq.n	4274 <tcp_input+0x61c>
    4326:	2101      	movs	r1, #1
    4328:	4603      	mov	r3, r0
    432a:	e7f7      	b.n	431c <tcp_input+0x6c4>
		tcp_receive(pcb);
    432c:	4b36      	ldr	r3, [pc, #216]	; (4408 <tcp_input+0x7b0>)
    432e:	4620      	mov	r0, r4
    4330:	4798      	blx	r3
		if (flags & TCP_ACK && ackno == pcb->snd_nxt) {
    4332:	7a2b      	ldrb	r3, [r5, #8]
    4334:	06db      	lsls	r3, r3, #27
    4336:	f57f ae63 	bpl.w	4000 <tcp_input+0x3a8>
    433a:	68eb      	ldr	r3, [r5, #12]
    433c:	6d22      	ldr	r2, [r4, #80]	; 0x50
    433e:	429a      	cmp	r2, r3
			recv_flags |= TF_CLOSED;
    4340:	bf02      	ittt	eq
    4342:	f895 3028 	ldrbeq.w	r3, [r5, #40]	; 0x28
    4346:	f043 0310 	orreq.w	r3, r3, #16
    434a:	f885 3028 	strbeq.w	r3, [r5, #40]	; 0x28
		if (err != ERR_ABRT) {
    434e:	e657      	b.n	4000 <tcp_input+0x3a8>
			} else if (recv_flags & TF_CLOSED) {
    4350:	06de      	lsls	r6, r3, #27
    4352:	d50b      	bpl.n	436c <tcp_input+0x714>
				if (!(pcb->flags & TF_RXCLOSED)) {
    4354:	7fa3      	ldrb	r3, [r4, #30]
    4356:	06d8      	lsls	r0, r3, #27
    4358:	f53f ae5e 	bmi.w	4018 <tcp_input+0x3c0>
					TCP_EVENT_ERR(pcb->errf, pcb->callback_arg, ERR_CLSD);
    435c:	f8d4 308c 	ldr.w	r3, [r4, #140]	; 0x8c
    4360:	2b00      	cmp	r3, #0
    4362:	f43f ae59 	beq.w	4018 <tcp_input+0x3c0>
    4366:	f06f 010b 	mvn.w	r1, #11
    436a:	e653      	b.n	4014 <tcp_input+0x3bc>
				if (pcb->acked > 0) {
    436c:	f8b4 2064 	ldrh.w	r2, [r4, #100]	; 0x64
    4370:	b992      	cbnz	r2, 4398 <tcp_input+0x740>
				if (recv_data != NULL) {
    4372:	6a6a      	ldr	r2, [r5, #36]	; 0x24
    4374:	b9ca      	cbnz	r2, 43aa <tcp_input+0x752>
				if (recv_flags & TF_GOT_FIN) {
    4376:	f895 3028 	ldrb.w	r3, [r5, #40]	; 0x28
    437a:	0699      	lsls	r1, r3, #26
    437c:	d506      	bpl.n	438c <tcp_input+0x734>
					if (pcb->refused_data != NULL) {
    437e:	6fa3      	ldr	r3, [r4, #120]	; 0x78
    4380:	2b00      	cmp	r3, #0
    4382:	d02e      	beq.n	43e2 <tcp_input+0x78a>
						pcb->refused_data->flags |= PBUF_FLAG_TCP_FIN;
    4384:	7b5a      	ldrb	r2, [r3, #13]
    4386:	f042 0220 	orr.w	r2, r2, #32
    438a:	735a      	strb	r2, [r3, #13]
				tcp_input_pcb = NULL;
    438c:	2300      	movs	r3, #0
    438e:	62eb      	str	r3, [r5, #44]	; 0x2c
				tcp_output(pcb);
    4390:	4620      	mov	r0, r4
    4392:	4b27      	ldr	r3, [pc, #156]	; (4430 <tcp_input+0x7d8>)
    4394:	4798      	blx	r3
    4396:	e60e      	b.n	3fb6 <tcp_input+0x35e>
					TCP_EVENT_SENT(pcb, pcb->acked, err);
    4398:	6fe3      	ldr	r3, [r4, #124]	; 0x7c
    439a:	2b00      	cmp	r3, #0
    439c:	d0e9      	beq.n	4372 <tcp_input+0x71a>
    439e:	6920      	ldr	r0, [r4, #16]
    43a0:	4621      	mov	r1, r4
    43a2:	4798      	blx	r3
					if (err == ERR_ABRT) {
    43a4:	300a      	adds	r0, #10
    43a6:	d1e4      	bne.n	4372 <tcp_input+0x71a>
    43a8:	e605      	b.n	3fb6 <tcp_input+0x35e>
					if (pcb->flags & TF_RXCLOSED) {
    43aa:	7fa3      	ldrb	r3, [r4, #30]
    43ac:	f013 0310 	ands.w	r3, r3, #16
    43b0:	d003      	beq.n	43ba <tcp_input+0x762>
						pbuf_free(recv_data);
    43b2:	4b20      	ldr	r3, [pc, #128]	; (4434 <tcp_input+0x7dc>)
    43b4:	4610      	mov	r0, r2
    43b6:	4798      	blx	r3
    43b8:	e6c7      	b.n	414a <tcp_input+0x4f2>
					TCP_EVENT_RECV(pcb, recv_data, ERR_OK, err);
    43ba:	f8d4 6080 	ldr.w	r6, [r4, #128]	; 0x80
    43be:	b15e      	cbz	r6, 43d8 <tcp_input+0x780>
    43c0:	6920      	ldr	r0, [r4, #16]
    43c2:	4621      	mov	r1, r4
    43c4:	47b0      	blx	r6
					if (err == ERR_ABRT) {
    43c6:	f110 0f0a 	cmn.w	r0, #10
    43ca:	f43f adf4 	beq.w	3fb6 <tcp_input+0x35e>
					if (err != ERR_OK) {
    43ce:	2800      	cmp	r0, #0
    43d0:	d0d1      	beq.n	4376 <tcp_input+0x71e>
						pcb->refused_data = recv_data;
    43d2:	6a6b      	ldr	r3, [r5, #36]	; 0x24
    43d4:	67a3      	str	r3, [r4, #120]	; 0x78
    43d6:	e7ce      	b.n	4376 <tcp_input+0x71e>
					TCP_EVENT_RECV(pcb, recv_data, ERR_OK, err);
    43d8:	4633      	mov	r3, r6
    43da:	4630      	mov	r0, r6
    43dc:	4621      	mov	r1, r4
    43de:	4e16      	ldr	r6, [pc, #88]	; (4438 <tcp_input+0x7e0>)
    43e0:	e7f0      	b.n	43c4 <tcp_input+0x76c>
						if (pcb->rcv_wnd != TCP_WND) {
    43e2:	8da3      	ldrh	r3, [r4, #44]	; 0x2c
						TCP_EVENT_CLOSED(pcb, err);
    43e4:	f8d4 6080 	ldr.w	r6, [r4, #128]	; 0x80
						if (pcb->rcv_wnd != TCP_WND) {
    43e8:	f241 62d0 	movw	r2, #5840	; 0x16d0
    43ec:	4293      	cmp	r3, r2
							pcb->rcv_wnd++;
    43ee:	bf1c      	itt	ne
    43f0:	3301      	addne	r3, #1
    43f2:	85a3      	strhne	r3, [r4, #44]	; 0x2c
						TCP_EVENT_CLOSED(pcb, err);
    43f4:	2e00      	cmp	r6, #0
    43f6:	d0c9      	beq.n	438c <tcp_input+0x734>
    43f8:	2300      	movs	r3, #0
    43fa:	6920      	ldr	r0, [r4, #16]
    43fc:	461a      	mov	r2, r3
    43fe:	4621      	mov	r1, r4
    4400:	47b0      	blx	r6
						if (err == ERR_ABRT) {
    4402:	300a      	adds	r0, #10
    4404:	d1c2      	bne.n	438c <tcp_input+0x734>
    4406:	e5d6      	b.n	3fb6 <tcp_input+0x35e>
    4408:	00003509 	.word	0x00003509
    440c:	20011104 	.word	0x20011104
    4410:	20011108 	.word	0x20011108
    4414:	00002811 	.word	0x00002811
    4418:	00006b51 	.word	0x00006b51
    441c:	20014950 	.word	0x20014950
    4420:	20014940 	.word	0x20014940
    4424:	20014954 	.word	0x20014954
    4428:	20014958 	.word	0x20014958
    442c:	000010a5 	.word	0x000010a5
    4430:	000024a5 	.word	0x000024a5
    4434:	000030e5 	.word	0x000030e5
    4438:	00007041 	.word	0x00007041
			if (prev != NULL) {
    443c:	b138      	cbz	r0, 444e <tcp_input+0x7f6>
				((struct tcp_pcb_listen *)prev)->next = lpcb->next;
    443e:	f8da 200c 	ldr.w	r2, [sl, #12]
    4442:	60c2      	str	r2, [r0, #12]
				tcp_listen_pcbs.listen_pcbs = lpcb;
    4444:	4a0a      	ldr	r2, [pc, #40]	; (4470 <tcp_input+0x818>)
				lpcb->next = tcp_listen_pcbs.listen_pcbs;
    4446:	f8ca 400c 	str.w	r4, [sl, #12]
				tcp_listen_pcbs.listen_pcbs = lpcb;
    444a:	f8c2 a000 	str.w	sl, [r2]
	if (flags & TCP_RST) {
    444e:	075a      	lsls	r2, r3, #29
    4450:	f53f ad03 	bmi.w	3e5a <tcp_input+0x202>
	if (flags & TCP_ACK) {
    4454:	f013 0410 	ands.w	r4, r3, #16
    4458:	f43f ad4e 	beq.w	3ef8 <tcp_input+0x2a0>
		tcp_rst(ackno, seqno + tcplen, ip_current_dest_addr(), ip_current_src_addr(), tcphdr->dest, tcphdr->src);
    445c:	f8bc 3000 	ldrh.w	r3, [ip]
    4460:	6868      	ldr	r0, [r5, #4]
    4462:	4a04      	ldr	r2, [pc, #16]	; (4474 <tcp_input+0x81c>)
    4464:	9902      	ldr	r1, [sp, #8]
    4466:	e9cd b300 	strd	fp, r3, [sp]
    446a:	4b03      	ldr	r3, [pc, #12]	; (4478 <tcp_input+0x820>)
			tcp_rst(ackno, seqno + tcplen, ip_current_dest_addr(), ip_current_src_addr(), tcphdr->dest, tcphdr->src);
    446c:	4401      	add	r1, r0
    446e:	e4e3      	b.n	3e38 <tcp_input+0x1e0>
    4470:	20014944 	.word	0x20014944
    4474:	20011104 	.word	0x20011104
    4478:	20011108 	.word	0x20011108

0000447c <udp_init>:
void udp_init(void)
{
#if LWIP_RANDOMIZE_INITIAL_LOCAL_PORTS && defined(LWIP_RAND)
	udp_port = UDP_ENSURE_LOCAL_PORT_RANGE(LWIP_RAND());
#endif /* LWIP_RANDOMIZE_INITIAL_LOCAL_PORTS && defined(LWIP_RAND) */
}
    447c:	4770      	bx	lr
	...

00004480 <udp_input>:
 * @param p pbuf to be demultiplexed to a UDP PCB.
 * @param inp network interface on which the datagram was received.
 *
 */
void udp_input(struct pbuf *p, struct netif *inp)
{
    4480:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}

	PERF_START;

	UDP_STATS_INC(udp.recv);

	iphdr = (struct ip_hdr *)p->payload;
    4484:	f8d0 a004 	ldr.w	sl, [r0, #4]

	/* Check minimum length (IP header + UDP header)
	 * and move payload pointer to UDP header */
	if (p->tot_len < (IPH_HL(iphdr) * 4 + UDP_HLEN) || pbuf_header(p, -(s16_t)(IPH_HL(iphdr) * 4))) {
    4488:	8903      	ldrh	r3, [r0, #8]
{
    448a:	468b      	mov	fp, r1
    448c:	f89a 1000 	ldrb.w	r1, [sl]
    4490:	f001 010f 	and.w	r1, r1, #15
	if (p->tot_len < (IPH_HL(iphdr) * 4 + UDP_HLEN) || pbuf_header(p, -(s16_t)(IPH_HL(iphdr) * 4))) {
    4494:	1c8a      	adds	r2, r1, #2
    4496:	ebb3 0f82 	cmp.w	r3, r2, lsl #2
{
    449a:	b085      	sub	sp, #20
    449c:	4605      	mov	r5, r0
	if (p->tot_len < (IPH_HL(iphdr) * 4 + UDP_HLEN) || pbuf_header(p, -(s16_t)(IPH_HL(iphdr) * 4))) {
    449e:	db05      	blt.n	44ac <udp_input+0x2c>
    44a0:	0089      	lsls	r1, r1, #2
    44a2:	4b53      	ldr	r3, [pc, #332]	; (45f0 <udp_input+0x170>)
    44a4:	4249      	negs	r1, r1
    44a6:	4798      	blx	r3
    44a8:	4606      	mov	r6, r0
    44aa:	b128      	cbz	r0, 44b8 <udp_input+0x38>
		/* drop short packets */
		LWIP_DEBUGF(UDP_DEBUG, ("udp_input: short UDP datagram (%" U16_F " bytes) discarded\n", p->tot_len));
		UDP_STATS_INC(udp.lenerr);
		UDP_STATS_INC(udp.drop);
		snmp_inc_udpinerrors();
		pbuf_free(p);
    44ac:	4b51      	ldr	r3, [pc, #324]	; (45f4 <udp_input+0x174>)
    44ae:	4628      	mov	r0, r5
	} else {
		pbuf_free(p);
	}
end:
	PERF_STOP("udp_input");
}
    44b0:	b005      	add	sp, #20
    44b2:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
		pbuf_free(p);
    44b6:	4718      	bx	r3
	broadcast = ip_addr_isbroadcast(&current_iphdr_dest, inp);
    44b8:	4c4f      	ldr	r4, [pc, #316]	; (45f8 <udp_input+0x178>)
    44ba:	4b50      	ldr	r3, [pc, #320]	; (45fc <udp_input+0x17c>)
    44bc:	6820      	ldr	r0, [r4, #0]
	udphdr = (struct udp_hdr *)p->payload;
    44be:	f8d5 9004 	ldr.w	r9, [r5, #4]
	broadcast = ip_addr_isbroadcast(&current_iphdr_dest, inp);
    44c2:	4659      	mov	r1, fp
    44c4:	4798      	blx	r3
	src  = ntohs(udphdr->src);
    44c6:	4b4e      	ldr	r3, [pc, #312]	; (4600 <udp_input+0x180>)
	broadcast = ip_addr_isbroadcast(&current_iphdr_dest, inp);
    44c8:	4680      	mov	r8, r0
	src  = ntohs(udphdr->src);
    44ca:	f8b9 0000 	ldrh.w	r0, [r9]
    44ce:	4798      	blx	r3
	dest = ntohs(udphdr->dest);
    44d0:	4b4b      	ldr	r3, [pc, #300]	; (4600 <udp_input+0x180>)
	src  = ntohs(udphdr->src);
    44d2:	4607      	mov	r7, r0
	dest = ntohs(udphdr->dest);
    44d4:	f8b9 0002 	ldrh.w	r0, [r9, #2]
    44d8:	4798      	blx	r3
	if (dest == DHCP_CLIENT_PORT) {
    44da:	2844      	cmp	r0, #68	; 0x44
	dest = ntohs(udphdr->dest);
    44dc:	9003      	str	r0, [sp, #12]
	if (dest == DHCP_CLIENT_PORT) {
    44de:	d130      	bne.n	4542 <udp_input+0xc2>
		if (src == DHCP_SERVER_PORT) {
    44e0:	2f43      	cmp	r7, #67	; 0x43
    44e2:	d149      	bne.n	4578 <udp_input+0xf8>
			if ((inp->dhcp != NULL) && (inp->dhcp->pcb != NULL)) {
    44e4:	f8db 3024 	ldr.w	r3, [fp, #36]	; 0x24
    44e8:	2b00      	cmp	r3, #0
    44ea:	d045      	beq.n	4578 <udp_input+0xf8>
    44ec:	685c      	ldr	r4, [r3, #4]
    44ee:	2c00      	cmp	r4, #0
    44f0:	d042      	beq.n	4578 <udp_input+0xf8>
				if ((ip_addr_isany(&inp->dhcp->pcb->remote_ip)
    44f2:	6863      	ldr	r3, [r4, #4]
    44f4:	b11b      	cbz	r3, 44fe <udp_input+0x7e>
				     || ip_addr_cmp(&(inp->dhcp->pcb->remote_ip), &current_iphdr_src))) {
    44f6:	4a43      	ldr	r2, [pc, #268]	; (4604 <udp_input+0x184>)
    44f8:	6812      	ldr	r2, [r2, #0]
    44fa:	4293      	cmp	r3, r2
    44fc:	d13c      	bne.n	4578 <udp_input+0xf8>
			if (udphdr->chksum != 0) {
    44fe:	f8b9 3006 	ldrh.w	r3, [r9, #6]
    4502:	b14b      	cbz	r3, 4518 <udp_input+0x98>
				if (inet_chksum_pseudo(p, ip_current_src_addr(), ip_current_dest_addr(), IP_PROTO_UDP, p->tot_len)
    4504:	892b      	ldrh	r3, [r5, #8]
    4506:	9300      	str	r3, [sp, #0]
    4508:	4a3b      	ldr	r2, [pc, #236]	; (45f8 <udp_input+0x178>)
    450a:	493e      	ldr	r1, [pc, #248]	; (4604 <udp_input+0x184>)
    450c:	4e3e      	ldr	r6, [pc, #248]	; (4608 <udp_input+0x188>)
    450e:	2311      	movs	r3, #17
    4510:	4628      	mov	r0, r5
    4512:	47b0      	blx	r6
    4514:	2800      	cmp	r0, #0
    4516:	d1c9      	bne.n	44ac <udp_input+0x2c>
		if (pbuf_header(p, -UDP_HLEN)) {
    4518:	4e35      	ldr	r6, [pc, #212]	; (45f0 <udp_input+0x170>)
    451a:	f06f 0107 	mvn.w	r1, #7
    451e:	4628      	mov	r0, r5
    4520:	47b0      	blx	r6
    4522:	2800      	cmp	r0, #0
    4524:	d1c2      	bne.n	44ac <udp_input+0x2c>
		if (pcb != NULL) {
    4526:	2c00      	cmp	r4, #0
    4528:	d02e      	beq.n	4588 <udp_input+0x108>
			if (pcb->recv != NULL) {
    452a:	69a6      	ldr	r6, [r4, #24]
    452c:	2e00      	cmp	r6, #0
    452e:	d0bd      	beq.n	44ac <udp_input+0x2c>
				pcb->recv(pcb->recv_arg, pcb, p, ip_current_src_addr(), src);
    4530:	9700      	str	r7, [sp, #0]
    4532:	4b34      	ldr	r3, [pc, #208]	; (4604 <udp_input+0x184>)
    4534:	69e0      	ldr	r0, [r4, #28]
    4536:	462a      	mov	r2, r5
    4538:	4621      	mov	r1, r4
    453a:	47b0      	blx	r6
}
    453c:	b005      	add	sp, #20
    453e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		for (pcb = udp_pcbs; pcb != NULL; pcb = pcb->next) {
    4542:	4b32      	ldr	r3, [pc, #200]	; (460c <udp_input+0x18c>)
				if ((!broadcast && ip_addr_isany(&pcb->local_ip)) || ip_addr_cmp(&(pcb->local_ip), &current_iphdr_dest)
    4544:	6821      	ldr	r1, [r4, #0]
		for (pcb = udp_pcbs; pcb != NULL; pcb = pcb->next) {
    4546:	f8d3 e000 	ldr.w	lr, [r3]
			    && (ip_addr_isany(&pcb->remote_ip) || ip_addr_cmp(&(pcb->remote_ip), &current_iphdr_src))) {
    454a:	4b2e      	ldr	r3, [pc, #184]	; (4604 <udp_input+0x184>)
		for (pcb = udp_pcbs; pcb != NULL; pcb = pcb->next) {
    454c:	4674      	mov	r4, lr
			    && (ip_addr_isany(&pcb->remote_ip) || ip_addr_cmp(&(pcb->remote_ip), &current_iphdr_src))) {
    454e:	f8d3 c000 	ldr.w	ip, [r3]
		uncon_pcb   = NULL;
    4552:	4633      	mov	r3, r6
		for (pcb = udp_pcbs; pcb != NULL; pcb = pcb->next) {
    4554:	b914      	cbnz	r4, 455c <udp_input+0xdc>
	if (pcb != NULL || ip_addr_cmp(&inp->ip_addr, &current_iphdr_dest)) {
    4556:	b17b      	cbz	r3, 4578 <udp_input+0xf8>
    4558:	461c      	mov	r4, r3
    455a:	e7d0      	b.n	44fe <udp_input+0x7e>
			if (pcb->local_port == dest) {
    455c:	8a62      	ldrh	r2, [r4, #18]
    455e:	9803      	ldr	r0, [sp, #12]
    4560:	4282      	cmp	r2, r0
    4562:	d106      	bne.n	4572 <udp_input+0xf2>
				if ((!broadcast && ip_addr_isany(&pcb->local_ip)) || ip_addr_cmp(&(pcb->local_ip), &current_iphdr_dest)
    4564:	6822      	ldr	r2, [r4, #0]
    4566:	f1b8 0f00 	cmp.w	r8, #0
    456a:	d123      	bne.n	45b4 <udp_input+0x134>
    456c:	b352      	cbz	r2, 45c4 <udp_input+0x144>
    456e:	4291      	cmp	r1, r2
    4570:	d028      	beq.n	45c4 <udp_input+0x144>
		for (pcb = udp_pcbs; pcb != NULL; pcb = pcb->next) {
    4572:	4626      	mov	r6, r4
    4574:	68e4      	ldr	r4, [r4, #12]
    4576:	e7ed      	b.n	4554 <udp_input+0xd4>
	if (pcb != NULL || ip_addr_cmp(&inp->ip_addr, &current_iphdr_dest)) {
    4578:	4b1f      	ldr	r3, [pc, #124]	; (45f8 <udp_input+0x178>)
    457a:	f8db 2004 	ldr.w	r2, [fp, #4]
    457e:	681b      	ldr	r3, [r3, #0]
    4580:	429a      	cmp	r2, r3
    4582:	d193      	bne.n	44ac <udp_input+0x2c>
    4584:	2400      	movs	r4, #0
    4586:	e7ba      	b.n	44fe <udp_input+0x7e>
			if (!broadcast && !ip_addr_ismulticast(&current_iphdr_dest)) {
    4588:	f1b8 0f00 	cmp.w	r8, #0
    458c:	d18e      	bne.n	44ac <udp_input+0x2c>
    458e:	4b1a      	ldr	r3, [pc, #104]	; (45f8 <udp_input+0x178>)
    4590:	681b      	ldr	r3, [r3, #0]
    4592:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
    4596:	2be0      	cmp	r3, #224	; 0xe0
    4598:	d088      	beq.n	44ac <udp_input+0x2c>
				pbuf_header(p, (IPH_HL(iphdr) * 4) + UDP_HLEN);
    459a:	f89a 1000 	ldrb.w	r1, [sl]
    459e:	f001 010f 	and.w	r1, r1, #15
    45a2:	3102      	adds	r1, #2
    45a4:	0089      	lsls	r1, r1, #2
    45a6:	4628      	mov	r0, r5
    45a8:	47b0      	blx	r6
				icmp_dest_unreach(p, ICMP_DUR_PORT);
    45aa:	4b19      	ldr	r3, [pc, #100]	; (4610 <udp_input+0x190>)
    45ac:	2103      	movs	r1, #3
    45ae:	4628      	mov	r0, r5
    45b0:	4798      	blx	r3
    45b2:	e77b      	b.n	44ac <udp_input+0x2c>
				if ((!broadcast && ip_addr_isany(&pcb->local_ip)) || ip_addr_cmp(&(pcb->local_ip), &current_iphdr_dest)
    45b4:	4291      	cmp	r1, r2
    45b6:	d005      	beq.n	45c4 <udp_input+0x144>
				     && (ip_addr_isany(&pcb->local_ip)
    45b8:	b122      	cbz	r2, 45c4 <udp_input+0x144>
				         || ip_addr_netcmp(&pcb->local_ip, ip_current_dest_addr(), &inp->netmask)))) {
    45ba:	f8db 0008 	ldr.w	r0, [fp, #8]
    45be:	404a      	eors	r2, r1
    45c0:	4202      	tst	r2, r0
    45c2:	d1d6      	bne.n	4572 <udp_input+0xf2>
					if ((uncon_pcb == NULL) && ((pcb->flags & UDP_FLAGS_CONNECTED) == 0)) {
    45c4:	b923      	cbnz	r3, 45d0 <udp_input+0x150>
    45c6:	7c22      	ldrb	r2, [r4, #16]
    45c8:	f012 0f04 	tst.w	r2, #4
    45cc:	bf08      	it	eq
    45ce:	4623      	moveq	r3, r4
			if ((local_match != 0) && (pcb->remote_port == src)
    45d0:	8aa2      	ldrh	r2, [r4, #20]
    45d2:	42ba      	cmp	r2, r7
    45d4:	d1cd      	bne.n	4572 <udp_input+0xf2>
			    && (ip_addr_isany(&pcb->remote_ip) || ip_addr_cmp(&(pcb->remote_ip), &current_iphdr_src))) {
    45d6:	6862      	ldr	r2, [r4, #4]
    45d8:	b10a      	cbz	r2, 45de <udp_input+0x15e>
    45da:	4562      	cmp	r2, ip
    45dc:	d1c9      	bne.n	4572 <udp_input+0xf2>
				if (prev != NULL) {
    45de:	2e00      	cmp	r6, #0
    45e0:	d08d      	beq.n	44fe <udp_input+0x7e>
					prev->next = pcb->next;
    45e2:	68e3      	ldr	r3, [r4, #12]
    45e4:	60f3      	str	r3, [r6, #12]
					udp_pcbs   = pcb;
    45e6:	4b09      	ldr	r3, [pc, #36]	; (460c <udp_input+0x18c>)
					pcb->next  = udp_pcbs;
    45e8:	f8c4 e00c 	str.w	lr, [r4, #12]
					udp_pcbs   = pcb;
    45ec:	601c      	str	r4, [r3, #0]
    45ee:	e786      	b.n	44fe <udp_input+0x7e>
    45f0:	0000308d 	.word	0x0000308d
    45f4:	000030e5 	.word	0x000030e5
    45f8:	20011104 	.word	0x20011104
    45fc:	00008a1b 	.word	0x00008a1b
    4600:	00000d6b 	.word	0x00000d6b
    4604:	20011108 	.word	0x20011108
    4608:	00008385 	.word	0x00008385
    460c:	2000a510 	.word	0x2000a510
    4610:	00000d4d 	.word	0x00000d4d

00004614 <udp_bind>:
 * another UDP PCB.
 *
 * @see udp_disconnect()
 */
err_t udp_bind(struct udp_pcb *pcb, ip_addr_t *ipaddr, u16_t port)
{
    4614:	b5f0      	push	{r4, r5, r6, r7, lr}
	ip_addr_debug_print(UDP_DEBUG, ipaddr);
	LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE, (", port = %" U16_F ")\n", port));

	rebind = 0;
	/* Check for double bind and rebind of the same pcb */
	for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
    4616:	4f1f      	ldr	r7, [pc, #124]	; (4694 <udp_bind+0x80>)
    4618:	683d      	ldr	r5, [r7, #0]
	rebind = 0;
    461a:	2300      	movs	r3, #0
	for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
    461c:	462c      	mov	r4, r5
    461e:	b9c4      	cbnz	r4, 4652 <udp_bind+0x3e>
				return ERR_USE;
			}
		}
	}

	ip_addr_set(&pcb->local_ip, ipaddr);
    4620:	b101      	cbz	r1, 4624 <udp_bind+0x10>
    4622:	6809      	ldr	r1, [r1, #0]
    4624:	6001      	str	r1, [r0, #0]

	/* no port specified? */
	if (port == 0) {
    4626:	b972      	cbnz	r2, 4646 <udp_bind+0x32>
    4628:	4e1b      	ldr	r6, [pc, #108]	; (4698 <udp_bind+0x84>)
    462a:	8832      	ldrh	r2, [r6, #0]
    462c:	f44f 4180 	mov.w	r1, #16384	; 0x4000
	if (udp_port++ == UDP_LOCAL_PORT_RANGE_END) {
    4630:	f64f 7cff 	movw	ip, #65535	; 0xffff
    4634:	4562      	cmp	r2, ip
    4636:	bf1a      	itte	ne
    4638:	3201      	addne	r2, #1
    463a:	b292      	uxthne	r2, r2
		udp_port = UDP_LOCAL_PORT_RANGE_START;
    463c:	f44f 4240 	moveq.w	r2, #49152	; 0xc000
	for (pcb = udp_pcbs; pcb != NULL; pcb = pcb->next) {
    4640:	462c      	mov	r4, r5
    4642:	b9dc      	cbnz	r4, 467c <udp_bind+0x68>
    4644:	8032      	strh	r2, [r6, #0]
			/* no more ports available in local range */
			LWIP_DEBUGF(UDP_DEBUG, ("udp_bind: out of free UDP ports\n"));
			return ERR_USE;
		}
	}
	pcb->local_port = port;
    4646:	8242      	strh	r2, [r0, #18]
	snmp_insert_udpidx_tree(pcb);
	/* pcb not active yet? */
	if (rebind == 0) {
    4648:	b90b      	cbnz	r3, 464e <udp_bind+0x3a>
		/* place the PCB on the active list if not already there */
		pcb->next = udp_pcbs;
    464a:	60c5      	str	r5, [r0, #12]
		udp_pcbs  = pcb;
    464c:	6038      	str	r0, [r7, #0]
	             ip4_addr1_16(&pcb->local_ip),
	             ip4_addr2_16(&pcb->local_ip),
	             ip4_addr3_16(&pcb->local_ip),
	             ip4_addr4_16(&pcb->local_ip),
	             pcb->local_port));
	return ERR_OK;
    464e:	2000      	movs	r0, #0
    4650:	e010      	b.n	4674 <udp_bind+0x60>
		if (pcb == ipcb) {
    4652:	4284      	cmp	r4, r0
    4654:	d00f      	beq.n	4676 <udp_bind+0x62>
			if ((ipcb->local_port == port) &&
    4656:	8a66      	ldrh	r6, [r4, #18]
    4658:	4296      	cmp	r6, r2
    465a:	d10d      	bne.n	4678 <udp_bind+0x64>
			    (ip_addr_isany(&(ipcb->local_ip)) || ip_addr_isany(ipaddr) || ip_addr_cmp(&(ipcb->local_ip), ipaddr))) {
    465c:	f8d4 c000 	ldr.w	ip, [r4]
    4660:	f1bc 0f00 	cmp.w	ip, #0
    4664:	d004      	beq.n	4670 <udp_bind+0x5c>
    4666:	b119      	cbz	r1, 4670 <udp_bind+0x5c>
    4668:	680e      	ldr	r6, [r1, #0]
    466a:	b10e      	cbz	r6, 4670 <udp_bind+0x5c>
    466c:	45b4      	cmp	ip, r6
    466e:	d103      	bne.n	4678 <udp_bind+0x64>
				return ERR_USE;
    4670:	f06f 0007 	mvn.w	r0, #7
}
    4674:	bdf0      	pop	{r4, r5, r6, r7, pc}
			rebind = 1;
    4676:	2301      	movs	r3, #1
	for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
    4678:	68e4      	ldr	r4, [r4, #12]
    467a:	e7d0      	b.n	461e <udp_bind+0xa>
		if (pcb->local_port == udp_port) {
    467c:	f8b4 e012 	ldrh.w	lr, [r4, #18]
    4680:	4596      	cmp	lr, r2
    4682:	d105      	bne.n	4690 <udp_bind+0x7c>
			if (++n > (UDP_LOCAL_PORT_RANGE_END - UDP_LOCAL_PORT_RANGE_START)) {
    4684:	3901      	subs	r1, #1
    4686:	b289      	uxth	r1, r1
    4688:	2900      	cmp	r1, #0
    468a:	d1d3      	bne.n	4634 <udp_bind+0x20>
    468c:	8032      	strh	r2, [r6, #0]
    468e:	e7ef      	b.n	4670 <udp_bind+0x5c>
	for (pcb = udp_pcbs; pcb != NULL; pcb = pcb->next) {
    4690:	68e4      	ldr	r4, [r4, #12]
    4692:	e7d6      	b.n	4642 <udp_bind+0x2e>
    4694:	2000a510 	.word	0x2000a510
    4698:	20000004 	.word	0x20000004

0000469c <udp_sendto_if>:
{
    469c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    46a0:	4690      	mov	r8, r2
    46a2:	b087      	sub	sp, #28
	if (pcb->local_port == 0) {
    46a4:	8a42      	ldrh	r2, [r0, #18]
{
    46a6:	f8dd 9040 	ldr.w	r9, [sp, #64]	; 0x40
    46aa:	4606      	mov	r6, r0
    46ac:	460f      	mov	r7, r1
    46ae:	469a      	mov	sl, r3
	if (pcb->local_port == 0) {
    46b0:	2a00      	cmp	r2, #0
    46b2:	d042      	beq.n	473a <udp_sendto_if+0x9e>
	if (pbuf_header(p, UDP_HLEN)) {
    46b4:	4b35      	ldr	r3, [pc, #212]	; (478c <udp_sendto_if+0xf0>)
    46b6:	2108      	movs	r1, #8
    46b8:	4638      	mov	r0, r7
    46ba:	4798      	blx	r3
    46bc:	2800      	cmp	r0, #0
    46be:	d146      	bne.n	474e <udp_sendto_if+0xb2>
    46c0:	463c      	mov	r4, r7
	udphdr->src  = htons(pcb->local_port);
    46c2:	f8df b0e0 	ldr.w	fp, [pc, #224]	; 47a4 <udp_sendto_if+0x108>
    46c6:	8a70      	ldrh	r0, [r6, #18]
	udphdr       = (struct udp_hdr *)q->payload;
    46c8:	6865      	ldr	r5, [r4, #4]
	udphdr->src  = htons(pcb->local_port);
    46ca:	47d8      	blx	fp
    46cc:	8028      	strh	r0, [r5, #0]
	udphdr->dest = htons(dst_port);
    46ce:	4650      	mov	r0, sl
    46d0:	47d8      	blx	fp
	if (ip_addr_isany(&pcb->local_ip)) {
    46d2:	6832      	ldr	r2, [r6, #0]
	udphdr->dest = htons(dst_port);
    46d4:	8068      	strh	r0, [r5, #2]
	udphdr->chksum = 0x0000;
    46d6:	2300      	movs	r3, #0
    46d8:	71ab      	strb	r3, [r5, #6]
    46da:	71eb      	strb	r3, [r5, #7]
	if (ip_addr_isany(&pcb->local_ip)) {
    46dc:	465b      	mov	r3, fp
    46de:	2a00      	cmp	r2, #0
    46e0:	d143      	bne.n	476a <udp_sendto_if+0xce>
		src_ip = &(netif->ip_addr);
    46e2:	f109 0104 	add.w	r1, r9, #4
		udphdr->len = htons(q->tot_len);
    46e6:	8920      	ldrh	r0, [r4, #8]
    46e8:	9105      	str	r1, [sp, #20]
    46ea:	4798      	blx	r3
    46ec:	80a8      	strh	r0, [r5, #4]
		if ((pcb->flags & UDP_FLAGS_NOCHKSUM) == 0) {
    46ee:	7c33      	ldrb	r3, [r6, #16]
    46f0:	9905      	ldr	r1, [sp, #20]
    46f2:	f013 0f01 	tst.w	r3, #1
    46f6:	d10e      	bne.n	4716 <udp_sendto_if+0x7a>
				udpchksum = inet_chksum_pseudo(q, src_ip, dst_ip, IP_PROTO_UDP, q->tot_len);
    46f8:	8923      	ldrh	r3, [r4, #8]
    46fa:	9300      	str	r3, [sp, #0]
    46fc:	f8df a0a8 	ldr.w	sl, [pc, #168]	; 47a8 <udp_sendto_if+0x10c>
    4700:	2311      	movs	r3, #17
    4702:	4642      	mov	r2, r8
    4704:	4620      	mov	r0, r4
    4706:	47d0      	blx	sl
				udpchksum = 0xffff;
    4708:	f64f 73ff 	movw	r3, #65535	; 0xffff
    470c:	2800      	cmp	r0, #0
    470e:	bf18      	it	ne
    4710:	4603      	movne	r3, r0
			udphdr->chksum = udpchksum;
    4712:	9905      	ldr	r1, [sp, #20]
    4714:	80eb      	strh	r3, [r5, #6]
		err = ip_output_if(q, src_ip, dst_ip, pcb->ttl, pcb->tos, IP_PROTO_UDP, netif);
    4716:	2311      	movs	r3, #17
    4718:	9301      	str	r3, [sp, #4]
    471a:	7a73      	ldrb	r3, [r6, #9]
    471c:	4d1c      	ldr	r5, [pc, #112]	; (4790 <udp_sendto_if+0xf4>)
    471e:	9300      	str	r3, [sp, #0]
    4720:	f8cd 9008 	str.w	r9, [sp, #8]
    4724:	7ab3      	ldrb	r3, [r6, #10]
    4726:	4642      	mov	r2, r8
    4728:	4620      	mov	r0, r4
    472a:	47a8      	blx	r5
	if (q != p) {
    472c:	42bc      	cmp	r4, r7
		err = ip_output_if(q, src_ip, dst_ip, pcb->ttl, pcb->tos, IP_PROTO_UDP, netif);
    472e:	4605      	mov	r5, r0
	if (q != p) {
    4730:	d009      	beq.n	4746 <udp_sendto_if+0xaa>
		pbuf_free(q);
    4732:	4b18      	ldr	r3, [pc, #96]	; (4794 <udp_sendto_if+0xf8>)
    4734:	4620      	mov	r0, r4
    4736:	4798      	blx	r3
		q = NULL;
    4738:	e005      	b.n	4746 <udp_sendto_if+0xaa>
		err = udp_bind(pcb, &pcb->local_ip, pcb->local_port);
    473a:	4b17      	ldr	r3, [pc, #92]	; (4798 <udp_sendto_if+0xfc>)
    473c:	4601      	mov	r1, r0
    473e:	4798      	blx	r3
		if (err != ERR_OK) {
    4740:	4605      	mov	r5, r0
    4742:	2800      	cmp	r0, #0
    4744:	d0b6      	beq.n	46b4 <udp_sendto_if+0x18>
}
    4746:	4628      	mov	r0, r5
    4748:	b007      	add	sp, #28
    474a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		q = pbuf_alloc(PBUF_IP, UDP_HLEN, PBUF_RAM);
    474e:	4b13      	ldr	r3, [pc, #76]	; (479c <udp_sendto_if+0x100>)
    4750:	2200      	movs	r2, #0
    4752:	2108      	movs	r1, #8
    4754:	2001      	movs	r0, #1
    4756:	4798      	blx	r3
		if (q == NULL) {
    4758:	4604      	mov	r4, r0
    475a:	b1a0      	cbz	r0, 4786 <udp_sendto_if+0xea>
		if (p->tot_len != 0) {
    475c:	893b      	ldrh	r3, [r7, #8]
    475e:	2b00      	cmp	r3, #0
    4760:	d0af      	beq.n	46c2 <udp_sendto_if+0x26>
			pbuf_chain(q, p);
    4762:	4b0f      	ldr	r3, [pc, #60]	; (47a0 <udp_sendto_if+0x104>)
    4764:	4639      	mov	r1, r7
    4766:	4798      	blx	r3
    4768:	e7ab      	b.n	46c2 <udp_sendto_if+0x26>
		if (!ip_addr_cmp(&(pcb->local_ip), &(netif->ip_addr))) {
    476a:	f8d9 1004 	ldr.w	r1, [r9, #4]
    476e:	428a      	cmp	r2, r1
    4770:	d007      	beq.n	4782 <udp_sendto_if+0xe6>
			if (q != p) {
    4772:	42bc      	cmp	r4, r7
    4774:	d002      	beq.n	477c <udp_sendto_if+0xe0>
				pbuf_free(q);
    4776:	4b07      	ldr	r3, [pc, #28]	; (4794 <udp_sendto_if+0xf8>)
    4778:	4620      	mov	r0, r4
    477a:	4798      	blx	r3
			return ERR_VAL;
    477c:	f06f 0505 	mvn.w	r5, #5
    4780:	e7e1      	b.n	4746 <udp_sendto_if+0xaa>
	if (ip_addr_isany(&pcb->local_ip)) {
    4782:	4631      	mov	r1, r6
    4784:	e7af      	b.n	46e6 <udp_sendto_if+0x4a>
			return ERR_MEM;
    4786:	f04f 35ff 	mov.w	r5, #4294967295	; 0xffffffff
    478a:	e7dc      	b.n	4746 <udp_sendto_if+0xaa>
    478c:	0000308d 	.word	0x0000308d
    4790:	0000650d 	.word	0x0000650d
    4794:	000030e5 	.word	0x000030e5
    4798:	00004615 	.word	0x00004615
    479c:	0000313d 	.word	0x0000313d
    47a0:	000032d9 	.word	0x000032d9
    47a4:	00000d65 	.word	0x00000d65
    47a8:	00008385 	.word	0x00008385

000047ac <udp_sendto>:
{
    47ac:	b530      	push	{r4, r5, lr}
    47ae:	b087      	sub	sp, #28
    47b0:	4605      	mov	r5, r0
	netif = ip_route(dst_ip);
    47b2:	4c09      	ldr	r4, [pc, #36]	; (47d8 <udp_sendto+0x2c>)
    47b4:	9203      	str	r2, [sp, #12]
    47b6:	4610      	mov	r0, r2
{
    47b8:	e9cd 3104 	strd	r3, r1, [sp, #16]
	netif = ip_route(dst_ip);
    47bc:	47a0      	blx	r4
	if (netif == NULL) {
    47be:	b140      	cbz	r0, 47d2 <udp_sendto+0x26>
	return udp_sendto_if(pcb, p, dst_ip, dst_port, netif);
    47c0:	9000      	str	r0, [sp, #0]
    47c2:	e9dd 2303 	ldrd	r2, r3, [sp, #12]
    47c6:	9905      	ldr	r1, [sp, #20]
    47c8:	4c04      	ldr	r4, [pc, #16]	; (47dc <udp_sendto+0x30>)
    47ca:	4628      	mov	r0, r5
    47cc:	47a0      	blx	r4
}
    47ce:	b007      	add	sp, #28
    47d0:	bd30      	pop	{r4, r5, pc}
		return ERR_RTE;
    47d2:	f06f 0003 	mvn.w	r0, #3
    47d6:	e7fa      	b.n	47ce <udp_sendto+0x22>
    47d8:	00006359 	.word	0x00006359
    47dc:	0000469d 	.word	0x0000469d

000047e0 <udp_send>:
{
    47e0:	b410      	push	{r4}
	return udp_sendto(pcb, p, &pcb->remote_ip, pcb->remote_port);
    47e2:	4c04      	ldr	r4, [pc, #16]	; (47f4 <udp_send+0x14>)
    47e4:	8a83      	ldrh	r3, [r0, #20]
{
    47e6:	4602      	mov	r2, r0
	return udp_sendto(pcb, p, &pcb->remote_ip, pcb->remote_port);
    47e8:	46a4      	mov	ip, r4
    47ea:	3204      	adds	r2, #4
}
    47ec:	f85d 4b04 	ldr.w	r4, [sp], #4
	return udp_sendto(pcb, p, &pcb->remote_ip, pcb->remote_port);
    47f0:	4760      	bx	ip
    47f2:	bf00      	nop
    47f4:	000047ad 	.word	0x000047ad

000047f8 <udp_connect>:
 * The udp pcb is bound to a random local port if not already bound.
 *
 * @see udp_disconnect()
 */
err_t udp_connect(struct udp_pcb *pcb, ip_addr_t *ipaddr, u16_t port)
{
    47f8:	b570      	push	{r4, r5, r6, lr}
    47fa:	4616      	mov	r6, r2
	struct udp_pcb *ipcb;

	if (pcb->local_port == 0) {
    47fc:	8a42      	ldrh	r2, [r0, #18]
{
    47fe:	4604      	mov	r4, r0
    4800:	460d      	mov	r5, r1
	if (pcb->local_port == 0) {
    4802:	b16a      	cbz	r2, 4820 <udp_connect+0x28>
		if (err != ERR_OK) {
			return err;
		}
	}

	ip_addr_set(&pcb->remote_ip, ipaddr);
    4804:	b995      	cbnz	r5, 482c <udp_connect+0x34>
	             ip4_addr3_16(&pcb->local_ip),
	             ip4_addr4_16(&pcb->local_ip),
	             pcb->local_port));

	/* Insert UDP PCB into the list of active UDP PCBs. */
	for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
    4806:	4a0d      	ldr	r2, [pc, #52]	; (483c <udp_connect+0x44>)
	pcb->flags |= UDP_FLAGS_CONNECTED;
    4808:	7c23      	ldrb	r3, [r4, #16]
	for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
    480a:	6811      	ldr	r1, [r2, #0]
	ip_addr_set(&pcb->remote_ip, ipaddr);
    480c:	6065      	str	r5, [r4, #4]
	pcb->flags |= UDP_FLAGS_CONNECTED;
    480e:	f043 0304 	orr.w	r3, r3, #4
	pcb->remote_port = port;
    4812:	82a6      	strh	r6, [r4, #20]
	pcb->flags |= UDP_FLAGS_CONNECTED;
    4814:	7423      	strb	r3, [r4, #16]
	for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
    4816:	4608      	mov	r0, r1
    4818:	b950      	cbnz	r0, 4830 <udp_connect+0x38>
			/* already on the list, just return */
			return ERR_OK;
		}
	}
	/* PCB not yet on the list, add PCB now */
	pcb->next = udp_pcbs;
    481a:	60e1      	str	r1, [r4, #12]
	udp_pcbs  = pcb;
    481c:	6014      	str	r4, [r2, #0]
	return ERR_OK;
    481e:	e004      	b.n	482a <udp_connect+0x32>
		err_t err = udp_bind(pcb, &pcb->local_ip, pcb->local_port);
    4820:	4b07      	ldr	r3, [pc, #28]	; (4840 <udp_connect+0x48>)
    4822:	4601      	mov	r1, r0
    4824:	4798      	blx	r3
		if (err != ERR_OK) {
    4826:	2800      	cmp	r0, #0
    4828:	d0ec      	beq.n	4804 <udp_connect+0xc>
}
    482a:	bd70      	pop	{r4, r5, r6, pc}
	ip_addr_set(&pcb->remote_ip, ipaddr);
    482c:	682d      	ldr	r5, [r5, #0]
    482e:	e7ea      	b.n	4806 <udp_connect+0xe>
		if (pcb == ipcb) {
    4830:	42a0      	cmp	r0, r4
    4832:	d001      	beq.n	4838 <udp_connect+0x40>
	for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
    4834:	68c0      	ldr	r0, [r0, #12]
    4836:	e7ef      	b.n	4818 <udp_connect+0x20>
			return ERR_OK;
    4838:	2000      	movs	r0, #0
    483a:	e7f6      	b.n	482a <udp_connect+0x32>
    483c:	2000a510 	.word	0x2000a510
    4840:	00004615 	.word	0x00004615

00004844 <udp_recv>:
 */
void udp_recv(struct udp_pcb *pcb, udp_recv_fn recv, void *recv_arg)
{
	/* remember recv() callback and user data */
	pcb->recv     = recv;
	pcb->recv_arg = recv_arg;
    4844:	e9c0 1206 	strd	r1, r2, [r0, #24]
}
    4848:	4770      	bx	lr
	...

0000484c <udp_remove>:
{
	struct udp_pcb *pcb2;

	snmp_delete_udpidx_tree(pcb);
	/* pcb to be removed is first in list? */
	if (udp_pcbs == pcb) {
    484c:	4a09      	ldr	r2, [pc, #36]	; (4874 <udp_remove+0x28>)
    484e:	6813      	ldr	r3, [r2, #0]
    4850:	4283      	cmp	r3, r0
{
    4852:	4601      	mov	r1, r0
	if (udp_pcbs == pcb) {
    4854:	d10b      	bne.n	486e <udp_remove+0x22>
		/* make list start at 2nd pcb */
		udp_pcbs = udp_pcbs->next;
    4856:	68c3      	ldr	r3, [r0, #12]
    4858:	6013      	str	r3, [r2, #0]
				/* remove pcb from list */
				pcb2->next = pcb->next;
			}
		}
	}
	memp_free(MEMP_UDP_PCB, pcb);
    485a:	4b07      	ldr	r3, [pc, #28]	; (4878 <udp_remove+0x2c>)
    485c:	2000      	movs	r0, #0
    485e:	4718      	bx	r3
			if (pcb2->next != NULL && pcb2->next == pcb) {
    4860:	68da      	ldr	r2, [r3, #12]
    4862:	b11a      	cbz	r2, 486c <udp_remove+0x20>
    4864:	428a      	cmp	r2, r1
				pcb2->next = pcb->next;
    4866:	bf04      	itt	eq
    4868:	68ca      	ldreq	r2, [r1, #12]
    486a:	60da      	streq	r2, [r3, #12]
		for (pcb2 = udp_pcbs; pcb2 != NULL; pcb2 = pcb2->next) {
    486c:	68db      	ldr	r3, [r3, #12]
    486e:	2b00      	cmp	r3, #0
    4870:	d1f6      	bne.n	4860 <udp_remove+0x14>
    4872:	e7f2      	b.n	485a <udp_remove+0xe>
    4874:	2000a510 	.word	0x2000a510
    4878:	00004c1d 	.word	0x00004c1d

0000487c <udp_new>:
 * could not be allocated.
 *
 * @see udp_remove()
 */
struct udp_pcb *udp_new(void)
{
    487c:	b510      	push	{r4, lr}
	struct udp_pcb *pcb;
	pcb = (struct udp_pcb *)memp_malloc(MEMP_UDP_PCB);
    487e:	4b06      	ldr	r3, [pc, #24]	; (4898 <udp_new+0x1c>)
    4880:	2000      	movs	r0, #0
    4882:	4798      	blx	r3
	/* could allocate UDP PCB? */
	if (pcb != NULL) {
    4884:	4604      	mov	r4, r0
    4886:	b128      	cbz	r0, 4894 <udp_new+0x18>
		/* UDP Lite: by initializing to all zeroes, chksum_len is set to 0
		 * which means checksum is generated over the whole datagram per default
		 * (recommended as default by RFC 3828). */
		/* initialize PCB to all zeroes */
		memset(pcb, 0, sizeof(struct udp_pcb));
    4888:	4b04      	ldr	r3, [pc, #16]	; (489c <udp_new+0x20>)
    488a:	2220      	movs	r2, #32
    488c:	2100      	movs	r1, #0
    488e:	4798      	blx	r3
		pcb->ttl = UDP_TTL;
    4890:	23ff      	movs	r3, #255	; 0xff
    4892:	72a3      	strb	r3, [r4, #10]
	}
	return pcb;
}
    4894:	4620      	mov	r0, r4
    4896:	bd10      	pop	{r4, pc}
    4898:	00004c01 	.word	0x00004c01
    489c:	0000a365 	.word	0x0000a365

000048a0 <_osc32kctrl_init_sources>:
}

static inline hri_osc32kctrl_osculp32k_reg_t hri_osc32kctrl_read_OSCULP32K_CALIB_bf(const void *const hw)
{
	uint32_t tmp;
	tmp = ((Osc32kctrl *)hw)->OSCULP32K.reg;
    48a0:	4b03      	ldr	r3, [pc, #12]	; (48b0 <_osc32kctrl_init_sources+0x10>)
    48a2:	69da      	ldr	r2, [r3, #28]
	calib = hri_osc32kctrl_read_OSCULP32K_CALIB_bf(hw);
	hri_osc32kctrl_write_OSCULP32K_reg(hw,
#if CONF_OSCULP32K_CALIB_ENABLE == 1
	                                   OSC32KCTRL_OSCULP32K_CALIB(CONF_OSCULP32K_CALIB)
#else
	                                   OSC32KCTRL_OSCULP32K_CALIB(calib)
    48a4:	f402 527c 	and.w	r2, r2, #16128	; 0x3f00
}

static inline void hri_osc32kctrl_write_OSCULP32K_reg(const void *const hw, hri_osc32kctrl_osculp32k_reg_t data)
{
	OSC32KCTRL_CRITICAL_SECTION_ENTER();
	((Osc32kctrl *)hw)->OSCULP32K.reg = data;
    48a8:	61da      	str	r2, [r3, #28]
	((Osc32kctrl *)hw)->RTCCTRL.reg = data;
    48aa:	2201      	movs	r2, #1
    48ac:	741a      	strb	r2, [r3, #16]
#endif
#endif

	hri_osc32kctrl_write_RTCCTRL_reg(hw, OSC32KCTRL_RTCCTRL_RTCSEL(CONF_RTCCTRL));
	(void)calib;
}
    48ae:	4770      	bx	lr
    48b0:	40001400 	.word	0x40001400

000048b4 <Dummy_Handler>:
/**
 * \brief Default interrupt handler for unused IRQs.
 */
void Dummy_Handler(void)
{
	while (1) {
    48b4:	e7fe      	b.n	48b4 <Dummy_Handler>
	...

000048b8 <Reset_Handler>:
	if (pSrc != pDest) {
    48b8:	4918      	ldr	r1, [pc, #96]	; (491c <Reset_Handler+0x64>)
    48ba:	4819      	ldr	r0, [pc, #100]	; (4920 <Reset_Handler+0x68>)
    48bc:	4281      	cmp	r1, r0
{
    48be:	b510      	push	{r4, lr}
	if (pSrc != pDest) {
    48c0:	d00a      	beq.n	48d8 <Reset_Handler+0x20>
			*pDest++ = *pSrc++;
    48c2:	4b18      	ldr	r3, [pc, #96]	; (4924 <Reset_Handler+0x6c>)
    48c4:	1cda      	adds	r2, r3, #3
    48c6:	1a12      	subs	r2, r2, r0
    48c8:	f022 0203 	bic.w	r2, r2, #3
    48cc:	1ec4      	subs	r4, r0, #3
    48ce:	42a3      	cmp	r3, r4
    48d0:	bf38      	it	cc
    48d2:	2200      	movcc	r2, #0
    48d4:	4b14      	ldr	r3, [pc, #80]	; (4928 <Reset_Handler+0x70>)
    48d6:	4798      	blx	r3
		*pDest++ = 0;
    48d8:	4b14      	ldr	r3, [pc, #80]	; (492c <Reset_Handler+0x74>)
    48da:	4815      	ldr	r0, [pc, #84]	; (4930 <Reset_Handler+0x78>)
    48dc:	1cda      	adds	r2, r3, #3
    48de:	1a12      	subs	r2, r2, r0
    48e0:	1ec1      	subs	r1, r0, #3
    48e2:	f022 0203 	bic.w	r2, r2, #3
    48e6:	4299      	cmp	r1, r3
    48e8:	bf88      	it	hi
    48ea:	2200      	movhi	r2, #0
    48ec:	4b11      	ldr	r3, [pc, #68]	; (4934 <Reset_Handler+0x7c>)
    48ee:	2100      	movs	r1, #0
    48f0:	4798      	blx	r3
	SCB->VTOR = ((uint32_t)pSrc & SCB_VTOR_TBLOFF_Msk);
    48f2:	4a11      	ldr	r2, [pc, #68]	; (4938 <Reset_Handler+0x80>)
    48f4:	4b11      	ldr	r3, [pc, #68]	; (493c <Reset_Handler+0x84>)
    48f6:	f022 027f 	bic.w	r2, r2, #127	; 0x7f
    48fa:	609a      	str	r2, [r3, #8]
	SCB->CPACR |= (0xFu << 20);
    48fc:	f8d3 2088 	ldr.w	r2, [r3, #136]	; 0x88
    4900:	f442 0270 	orr.w	r2, r2, #15728640	; 0xf00000
    4904:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88
  \details Acts as a special kind of Data Memory Barrier.
           It completes when all explicit memory accesses before this instruction complete.
 */
__STATIC_FORCEINLINE void __DSB(void)
{
  __ASM volatile ("dsb 0xF":::"memory");
    4908:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
    490c:	f3bf 8f6f 	isb	sy
	__libc_init_array();
    4910:	4b0b      	ldr	r3, [pc, #44]	; (4940 <Reset_Handler+0x88>)
    4912:	4798      	blx	r3
	main();
    4914:	4b0b      	ldr	r3, [pc, #44]	; (4944 <Reset_Handler+0x8c>)
    4916:	4798      	blx	r3
	while (1)
    4918:	e7fe      	b.n	4918 <Reset_Handler+0x60>
    491a:	bf00      	nop
    491c:	0000ba3c 	.word	0x0000ba3c
    4920:	20000000 	.word	0x20000000
    4924:	20000080 	.word	0x20000080
    4928:	0000a349 	.word	0x0000a349
    492c:	2001640c 	.word	0x2001640c
    4930:	20000080 	.word	0x20000080
    4934:	0000a365 	.word	0x0000a365
    4938:	00000000 	.word	0x00000000
    493c:	e000ed00 	.word	0xe000ed00
    4940:	0000a2e1 	.word	0x0000a2e1
    4944:	00004b8d 	.word	0x00004b8d

00004948 <_gpio_set_pin_function>:

/**
 * \brief Set gpio pin function
 */
static inline void _gpio_set_pin_function(const uint32_t gpio, const uint32_t function)
{
    4948:	b530      	push	{r4, r5, lr}
	uint8_t port = GPIO_PORT(gpio);
	uint8_t pin  = GPIO_PIN(gpio);

	if (function == GPIO_PIN_FUNCTION_OFF) {
    494a:	1c4b      	adds	r3, r1, #1
	uint8_t pin  = GPIO_PIN(gpio);
    494c:	b2c5      	uxtb	r5, r0
    494e:	4b18      	ldr	r3, [pc, #96]	; (49b0 <_gpio_set_pin_function+0x68>)
    4950:	f000 041f 	and.w	r4, r0, #31
	uint8_t port = GPIO_PORT(gpio);
    4954:	ea4f 1050 	mov.w	r0, r0, lsr #5
    4958:	ea4f 10c0 	mov.w	r0, r0, lsl #7
static inline void hri_port_write_PINCFG_PMUXEN_bit(const void *const hw, uint8_t submodule_index, uint8_t index,
                                                    bool value)
{
	uint8_t tmp;
	PORT_CRITICAL_SECTION_ENTER();
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
    495c:	4403      	add	r3, r0
	if (function == GPIO_PIN_FUNCTION_OFF) {
    495e:	d107      	bne.n	4970 <_gpio_set_pin_function+0x28>
    4960:	4423      	add	r3, r4
    4962:	f893 2040 	ldrb.w	r2, [r3, #64]	; 0x40
	tmp &= ~PORT_PINCFG_PMUXEN;
    4966:	f002 02fe 	and.w	r2, r2, #254	; 0xfe
	tmp |= value << PORT_PINCFG_PMUXEN_Pos;
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
    496a:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
		} else {
			// Even numbered pin
			hri_port_write_PMUX_PMUXE_bf(PORT, port, pin >> 1, function & 0xffff);
		}
	}
}
    496e:	bd30      	pop	{r4, r5, pc}
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
    4970:	1918      	adds	r0, r3, r4
    4972:	eb03 0354 	add.w	r3, r3, r4, lsr #1
    4976:	f890 2040 	ldrb.w	r2, [r0, #64]	; 0x40
	tmp &= ~PORT_PINCFG_PMUXEN;
    497a:	f002 02fe 	and.w	r2, r2, #254	; 0xfe
	tmp |= value << PORT_PINCFG_PMUXEN_Pos;
    497e:	f042 0201 	orr.w	r2, r2, #1
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
    4982:	f880 2040 	strb.w	r2, [r0, #64]	; 0x40
	tmp = ((Port *)hw)->Group[submodule_index].PMUX[index].reg;
    4986:	f893 2030 	ldrb.w	r2, [r3, #48]	; 0x30
		if (pin & 1) {
    498a:	f015 0f01 	tst.w	r5, #1
			hri_port_write_PMUX_PMUXO_bf(PORT, port, pin >> 1, function & 0xffff);
    498e:	b2c9      	uxtb	r1, r1
	tmp &= ~PORT_PMUX_PMUXO_Msk;
    4990:	bf19      	ittee	ne
    4992:	f002 020f 	andne.w	r2, r2, #15
	tmp |= PORT_PMUX_PMUXO(data);
    4996:	ea42 1101 	orrne.w	r1, r2, r1, lsl #4
	tmp |= PORT_PMUX_PMUXE(data);
    499a:	f001 010f 	andeq.w	r1, r1, #15
	tmp &= ~PORT_PMUX_PMUXE_Msk;
    499e:	f002 02f0 	andeq.w	r2, r2, #240	; 0xf0
	tmp |= PORT_PMUX_PMUXO(data);
    49a2:	bf14      	ite	ne
    49a4:	b2c9      	uxtbne	r1, r1
	tmp |= PORT_PMUX_PMUXE(data);
    49a6:	4311      	orreq	r1, r2
	((Port *)hw)->Group[submodule_index].PMUX[index].reg = tmp;
    49a8:	f883 1030 	strb.w	r1, [r3, #48]	; 0x30
}
    49ac:	e7df      	b.n	496e <_gpio_set_pin_function+0x26>
    49ae:	bf00      	nop
    49b0:	41008000 	.word	0x41008000

000049b4 <TARGET_IO_PORT_init>:
struct usart_sync_descriptor TARGET_IO;

struct mac_async_descriptor COMMUNICATION_IO;

void TARGET_IO_PORT_init(void)
{
    49b4:	b510      	push	{r4, lr}
 *                      found in the header files for the device
 *
 */
static inline void gpio_set_pin_function(const uint32_t pin, uint32_t function)
{
	_gpio_set_pin_function(pin, function);
    49b6:	4c05      	ldr	r4, [pc, #20]	; (49cc <TARGET_IO_PORT_init+0x18>)
    49b8:	4905      	ldr	r1, [pc, #20]	; (49d0 <TARGET_IO_PORT_init+0x1c>)
    49ba:	2039      	movs	r0, #57	; 0x39
    49bc:	47a0      	blx	r4
    49be:	4623      	mov	r3, r4
    49c0:	4904      	ldr	r1, [pc, #16]	; (49d4 <TARGET_IO_PORT_init+0x20>)

	gpio_set_pin_function(PB25, PINMUX_PB25D_SERCOM2_PAD0);

	gpio_set_pin_function(PB24, PINMUX_PB24D_SERCOM2_PAD1);
}
    49c2:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    49c6:	2038      	movs	r0, #56	; 0x38
    49c8:	4718      	bx	r3
    49ca:	bf00      	nop
    49cc:	00004949 	.word	0x00004949
    49d0:	00390003 	.word	0x00390003
    49d4:	00380003 	.word	0x00380003

000049d8 <TARGET_IO_CLOCK_init>:
}

static inline void hri_gclk_write_PCHCTRL_reg(const void *const hw, uint8_t index, hri_gclk_pchctrl_reg_t data)
{
	GCLK_CRITICAL_SECTION_ENTER();
	((Gclk *)hw)->PCHCTRL[index].reg = data;
    49d8:	4b06      	ldr	r3, [pc, #24]	; (49f4 <TARGET_IO_CLOCK_init+0x1c>)
    49da:	2240      	movs	r2, #64	; 0x40
    49dc:	f8c3 20dc 	str.w	r2, [r3, #220]	; 0xdc
    49e0:	2243      	movs	r2, #67	; 0x43
    49e2:	f8c3 208c 	str.w	r2, [r3, #140]	; 0x8c
}

static inline void hri_mclk_set_APBBMASK_SERCOM2_bit(const void *const hw)
{
	MCLK_CRITICAL_SECTION_ENTER();
	((Mclk *)hw)->APBBMASK.reg |= MCLK_APBBMASK_SERCOM2;
    49e6:	4a04      	ldr	r2, [pc, #16]	; (49f8 <TARGET_IO_CLOCK_init+0x20>)
    49e8:	6993      	ldr	r3, [r2, #24]
    49ea:	f443 7300 	orr.w	r3, r3, #512	; 0x200
    49ee:	6193      	str	r3, [r2, #24]
{
	hri_gclk_write_PCHCTRL_reg(GCLK, SERCOM2_GCLK_ID_CORE, CONF_GCLK_SERCOM2_CORE_SRC | (1 << GCLK_PCHCTRL_CHEN_Pos));
	hri_gclk_write_PCHCTRL_reg(GCLK, SERCOM2_GCLK_ID_SLOW, CONF_GCLK_SERCOM2_SLOW_SRC | (1 << GCLK_PCHCTRL_CHEN_Pos));

	hri_mclk_set_APBBMASK_SERCOM2_bit(MCLK);
}
    49f0:	4770      	bx	lr
    49f2:	bf00      	nop
    49f4:	40001c00 	.word	0x40001c00
    49f8:	40000800 	.word	0x40000800

000049fc <TARGET_IO_init>:

void TARGET_IO_init(void)
{
    49fc:	b510      	push	{r4, lr}
	TARGET_IO_CLOCK_init();
    49fe:	4b05      	ldr	r3, [pc, #20]	; (4a14 <TARGET_IO_init+0x18>)
	usart_sync_init(&TARGET_IO, SERCOM2, (void *)NULL);
    4a00:	4905      	ldr	r1, [pc, #20]	; (4a18 <TARGET_IO_init+0x1c>)
    4a02:	4806      	ldr	r0, [pc, #24]	; (4a1c <TARGET_IO_init+0x20>)
	TARGET_IO_CLOCK_init();
    4a04:	4798      	blx	r3
	usart_sync_init(&TARGET_IO, SERCOM2, (void *)NULL);
    4a06:	4b06      	ldr	r3, [pc, #24]	; (4a20 <TARGET_IO_init+0x24>)
    4a08:	2200      	movs	r2, #0
    4a0a:	4798      	blx	r3
	TARGET_IO_PORT_init();
}
    4a0c:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	TARGET_IO_PORT_init();
    4a10:	4b04      	ldr	r3, [pc, #16]	; (4a24 <TARGET_IO_init+0x28>)
    4a12:	4718      	bx	r3
    4a14:	000049d9 	.word	0x000049d9
    4a18:	41012000 	.word	0x41012000
    4a1c:	2000a514 	.word	0x2000a514
    4a20:	00000f09 	.word	0x00000f09
    4a24:	000049b5 	.word	0x000049b5

00004a28 <COMMUNICATION_IO_PORT_init>:

void COMMUNICATION_IO_PORT_init(void)
{
    4a28:	b510      	push	{r4, lr}
    4a2a:	4911      	ldr	r1, [pc, #68]	; (4a70 <COMMUNICATION_IO_PORT_init+0x48>)
    4a2c:	4c11      	ldr	r4, [pc, #68]	; (4a74 <COMMUNICATION_IO_PORT_init+0x4c>)
    4a2e:	204b      	movs	r0, #75	; 0x4b
    4a30:	47a0      	blx	r4
    4a32:	4911      	ldr	r1, [pc, #68]	; (4a78 <COMMUNICATION_IO_PORT_init+0x50>)
    4a34:	204c      	movs	r0, #76	; 0x4c
    4a36:	47a0      	blx	r4
    4a38:	4910      	ldr	r1, [pc, #64]	; (4a7c <COMMUNICATION_IO_PORT_init+0x54>)
    4a3a:	200d      	movs	r0, #13
    4a3c:	47a0      	blx	r4
    4a3e:	4910      	ldr	r1, [pc, #64]	; (4a80 <COMMUNICATION_IO_PORT_init+0x58>)
    4a40:	200c      	movs	r0, #12
    4a42:	47a0      	blx	r4
    4a44:	490f      	ldr	r1, [pc, #60]	; (4a84 <COMMUNICATION_IO_PORT_init+0x5c>)
    4a46:	2054      	movs	r0, #84	; 0x54
    4a48:	47a0      	blx	r4
    4a4a:	490f      	ldr	r1, [pc, #60]	; (4a88 <COMMUNICATION_IO_PORT_init+0x60>)
    4a4c:	200f      	movs	r0, #15
    4a4e:	47a0      	blx	r4
    4a50:	490e      	ldr	r1, [pc, #56]	; (4a8c <COMMUNICATION_IO_PORT_init+0x64>)
    4a52:	2012      	movs	r0, #18
    4a54:	47a0      	blx	r4
    4a56:	490e      	ldr	r1, [pc, #56]	; (4a90 <COMMUNICATION_IO_PORT_init+0x68>)
    4a58:	2013      	movs	r0, #19
    4a5a:	47a0      	blx	r4
    4a5c:	490d      	ldr	r1, [pc, #52]	; (4a94 <COMMUNICATION_IO_PORT_init+0x6c>)
    4a5e:	200e      	movs	r0, #14
    4a60:	47a0      	blx	r4
    4a62:	4623      	mov	r3, r4
    4a64:	490c      	ldr	r1, [pc, #48]	; (4a98 <COMMUNICATION_IO_PORT_init+0x70>)
	gpio_set_pin_function(PA19, PINMUX_PA19L_GMAC_GTX1);

	gpio_set_pin_function(PA14, PINMUX_PA14L_GMAC_GTXCK);

	gpio_set_pin_function(PA17, PINMUX_PA17L_GMAC_GTXEN);
}
    4a66:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    4a6a:	2011      	movs	r0, #17
    4a6c:	4718      	bx	r3
    4a6e:	bf00      	nop
    4a70:	004b000b 	.word	0x004b000b
    4a74:	00004949 	.word	0x00004949
    4a78:	004c000b 	.word	0x004c000b
    4a7c:	000d000b 	.word	0x000d000b
    4a80:	000c000b 	.word	0x000c000b
    4a84:	0054000b 	.word	0x0054000b
    4a88:	000f000b 	.word	0x000f000b
    4a8c:	0012000b 	.word	0x0012000b
    4a90:	0013000b 	.word	0x0013000b
    4a94:	000e000b 	.word	0x000e000b
    4a98:	0011000b 	.word	0x0011000b

00004a9c <COMMUNICATION_IO_CLOCK_init>:
	((Mclk *)hw)->AHBMASK.reg |= MCLK_AHBMASK_GMAC;
    4a9c:	4b04      	ldr	r3, [pc, #16]	; (4ab0 <COMMUNICATION_IO_CLOCK_init+0x14>)
    4a9e:	691a      	ldr	r2, [r3, #16]
    4aa0:	f442 4280 	orr.w	r2, r2, #16384	; 0x4000
    4aa4:	611a      	str	r2, [r3, #16]
}

static inline void hri_mclk_set_APBCMASK_GMAC_bit(const void *const hw)
{
	MCLK_CRITICAL_SECTION_ENTER();
	((Mclk *)hw)->APBCMASK.reg |= MCLK_APBCMASK_GMAC;
    4aa6:	69da      	ldr	r2, [r3, #28]
    4aa8:	f042 0204 	orr.w	r2, r2, #4
    4aac:	61da      	str	r2, [r3, #28]

void COMMUNICATION_IO_CLOCK_init(void)
{
	hri_mclk_set_AHBMASK_GMAC_bit(MCLK);
	hri_mclk_set_APBCMASK_GMAC_bit(MCLK);
}
    4aae:	4770      	bx	lr
    4ab0:	40000800 	.word	0x40000800

00004ab4 <COMMUNICATION_IO_init>:

void COMMUNICATION_IO_init(void)
{
    4ab4:	b510      	push	{r4, lr}
	COMMUNICATION_IO_CLOCK_init();
    4ab6:	4b05      	ldr	r3, [pc, #20]	; (4acc <COMMUNICATION_IO_init+0x18>)
	mac_async_init(&COMMUNICATION_IO, GMAC);
    4ab8:	4905      	ldr	r1, [pc, #20]	; (4ad0 <COMMUNICATION_IO_init+0x1c>)
    4aba:	4806      	ldr	r0, [pc, #24]	; (4ad4 <COMMUNICATION_IO_init+0x20>)
	COMMUNICATION_IO_CLOCK_init();
    4abc:	4798      	blx	r3
	mac_async_init(&COMMUNICATION_IO, GMAC);
    4abe:	4b06      	ldr	r3, [pc, #24]	; (4ad8 <COMMUNICATION_IO_init+0x24>)
    4ac0:	4798      	blx	r3
	COMMUNICATION_IO_PORT_init();
}
    4ac2:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	COMMUNICATION_IO_PORT_init();
    4ac6:	4b05      	ldr	r3, [pc, #20]	; (4adc <COMMUNICATION_IO_init+0x28>)
    4ac8:	4718      	bx	r3
    4aca:	bf00      	nop
    4acc:	00004a9d 	.word	0x00004a9d
    4ad0:	42000800 	.word	0x42000800
    4ad4:	2000a520 	.word	0x2000a520
    4ad8:	00004c41 	.word	0x00004c41
    4adc:	00004a29 	.word	0x00004a29

00004ae0 <system_init>:
	mac_async_enable(&COMMUNICATION_IO);
	mac_async_write(&COMMUNICATION_IO, (uint8_t *)"Hello World!", 12);
}

void system_init(void)
{
    4ae0:	b510      	push	{r4, lr}
 * Currently the following initialization functions are supported:
 *  - System clock initialization
 */
static inline void init_mcu(void)
{
	_init_chip();
    4ae2:	4b0d      	ldr	r3, [pc, #52]	; (4b18 <system_init+0x38>)
    4ae4:	4798      	blx	r3
	((Port *)hw)->Group[submodule_index].OUTSET.reg = mask;
    4ae6:	4b0d      	ldr	r3, [pc, #52]	; (4b1c <system_init+0x3c>)
    4ae8:	f44f 2280 	mov.w	r2, #262144	; 0x40000
    4aec:	f8c3 2118 	str.w	r2, [r3, #280]	; 0x118
	((Port *)hw)->Group[submodule_index].DIRSET.reg = mask;
    4af0:	f8c3 2108 	str.w	r2, [r3, #264]	; 0x108

static inline void hri_port_write_WRCONFIG_reg(const void *const hw, uint8_t submodule_index,
                                               hri_port_wrconfig_reg_t data)
{
	PORT_CRITICAL_SECTION_ENTER();
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
    4af4:	f04f 4280 	mov.w	r2, #1073741824	; 0x40000000
    4af8:	f8c3 2128 	str.w	r2, [r3, #296]	; 0x128
    4afc:	4a08      	ldr	r2, [pc, #32]	; (4b20 <system_init+0x40>)
    4afe:	f8c3 2128 	str.w	r2, [r3, #296]	; 0x128
    4b02:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
    4b06:	4b07      	ldr	r3, [pc, #28]	; (4b24 <system_init+0x44>)
    4b08:	2052      	movs	r0, #82	; 0x52
    4b0a:	4798      	blx	r3
	// Set pin direction to output
	gpio_set_pin_direction(LED_0, GPIO_DIRECTION_OUT);

	gpio_set_pin_function(LED_0, GPIO_PIN_FUNCTION_OFF);

	TARGET_IO_init();
    4b0c:	4b06      	ldr	r3, [pc, #24]	; (4b28 <system_init+0x48>)
    4b0e:	4798      	blx	r3

	COMMUNICATION_IO_init();
}
    4b10:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	COMMUNICATION_IO_init();
    4b14:	4b05      	ldr	r3, [pc, #20]	; (4b2c <system_init+0x4c>)
    4b16:	4718      	bx	r3
    4b18:	00007941 	.word	0x00007941
    4b1c:	41008000 	.word	0x41008000
    4b20:	c0000004 	.word	0xc0000004
    4b24:	00004949 	.word	0x00004949
    4b28:	000049fd 	.word	0x000049fd
    4b2c:	00004ab5 	.word	0x00004ab5

00004b30 <print_ipaddress>:

/* define to avoid compilation warning */
// #define LWIP_TIMEVAL_PRIVATE 0

void print_ipaddress(void)
{
    4b30:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	static char tmp_buff[16];
	printf("IP_ADDR    : %s\r\n",
    4b34:	4f0e      	ldr	r7, [pc, #56]	; (4b70 <print_ipaddress+0x40>)
    4b36:	4e0f      	ldr	r6, [pc, #60]	; (4b74 <print_ipaddress+0x44>)
    4b38:	4d0f      	ldr	r5, [pc, #60]	; (4b78 <print_ipaddress+0x48>)
    4b3a:	4c10      	ldr	r4, [pc, #64]	; (4b7c <print_ipaddress+0x4c>)
    4b3c:	2210      	movs	r2, #16
    4b3e:	4639      	mov	r1, r7
    4b40:	4630      	mov	r0, r6
    4b42:	47a8      	blx	r5
    4b44:	4601      	mov	r1, r0
    4b46:	480e      	ldr	r0, [pc, #56]	; (4b80 <print_ipaddress+0x50>)
    4b48:	47a0      	blx	r4
	       ipaddr_ntoa_r((const ip_addr_t *)&(TCPIP_STACK_INTERFACE_0_desc.ip_addr), tmp_buff, 16));
	printf("NET_MASK   : %s\r\n",
    4b4a:	2210      	movs	r2, #16
    4b4c:	4639      	mov	r1, r7
    4b4e:	1d30      	adds	r0, r6, #4
    4b50:	47a8      	blx	r5
    4b52:	4601      	mov	r1, r0
    4b54:	480b      	ldr	r0, [pc, #44]	; (4b84 <print_ipaddress+0x54>)
    4b56:	47a0      	blx	r4
	       ipaddr_ntoa_r((const ip_addr_t *)&(TCPIP_STACK_INTERFACE_0_desc.netmask), tmp_buff, 16));
	printf("GATEWAY_IP : %s\r\n", ipaddr_ntoa_r((const ip_addr_t *)&(TCPIP_STACK_INTERFACE_0_desc.gw), tmp_buff, 16));
    4b58:	4639      	mov	r1, r7
    4b5a:	f106 0008 	add.w	r0, r6, #8
    4b5e:	2210      	movs	r2, #16
    4b60:	47a8      	blx	r5
    4b62:	4623      	mov	r3, r4
    4b64:	4601      	mov	r1, r0
}
    4b66:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
	printf("GATEWAY_IP : %s\r\n", ipaddr_ntoa_r((const ip_addr_t *)&(TCPIP_STACK_INTERFACE_0_desc.gw), tmp_buff, 16));
    4b6a:	4807      	ldr	r0, [pc, #28]	; (4b88 <print_ipaddress+0x58>)
    4b6c:	4718      	bx	r3
    4b6e:	bf00      	nop
    4b70:	2000a53c 	.word	0x2000a53c
    4b74:	20014964 	.word	0x20014964
    4b78:	00008a51 	.word	0x00008a51
    4b7c:	0000a375 	.word	0x0000a375
    4b80:	0000b62b 	.word	0x0000b62b
    4b84:	0000b63d 	.word	0x0000b63d
    4b88:	0000b64f 	.word	0x0000b64f

00004b8c <main>:
 * #define LWIP_TIMEVAL_PRIVATE		0
 *
 */

int main(void)
{
    4b8c:	b508      	push	{r3, lr}
	/* Initializes MCU, drivers and middleware */
	atmel_start_init();
    4b8e:	4b04      	ldr	r3, [pc, #16]	; (4ba0 <main+0x14>)
    4b90:	4798      	blx	r3

	/*Handles Socket API */
	printf("\r\nSocket API implementation\r\n");
    4b92:	4b04      	ldr	r3, [pc, #16]	; (4ba4 <main+0x18>)
    4b94:	4804      	ldr	r0, [pc, #16]	; (4ba8 <main+0x1c>)
    4b96:	4798      	blx	r3
	basic_socket();
    4b98:	4b04      	ldr	r3, [pc, #16]	; (4bac <main+0x20>)
    4b9a:	4798      	blx	r3

	while (1)
    4b9c:	e7fe      	b.n	4b9c <main+0x10>
    4b9e:	bf00      	nop
    4ba0:	00004df1 	.word	0x00004df1
    4ba4:	0000a481 	.word	0x0000a481
    4ba8:	0000b661 	.word	0x0000b661
    4bac:	00008589 	.word	0x00008589

00004bb0 <memp_init>:
 * Initialize this module.
 *
 * Carves out memp_memory into linked lists for each pool-type.
 */
void memp_init(void)
{
    4bb0:	b5f0      	push	{r4, r5, r6, r7, lr}
		MEMP_STATS_AVAIL(err, i, 0);
		MEMP_STATS_AVAIL(avail, i, memp_num[i]);
	}

#if !MEMP_SEPARATE_POOLS
	memp = (struct memp *)LWIP_MEM_ALIGN(memp_memory);
    4bb2:	4b10      	ldr	r3, [pc, #64]	; (4bf4 <memp_init+0x44>)
    4bb4:	4c10      	ldr	r4, [pc, #64]	; (4bf8 <memp_init+0x48>)
    4bb6:	4911      	ldr	r1, [pc, #68]	; (4bfc <memp_init+0x4c>)
    4bb8:	f023 0303 	bic.w	r3, r3, #3
#endif /* !MEMP_SEPARATE_POOLS */
	/* for every pool: */
	for (i = 0; i < MEMP_MAX; ++i) {
    4bbc:	f104 001a 	add.w	r0, r4, #26
	memp = (struct memp *)LWIP_MEM_ALIGN(memp_memory);
    4bc0:	220d      	movs	r2, #13
		memp_tab[i] = NULL;
    4bc2:	2600      	movs	r6, #0
    4bc4:	f841 6b04 	str.w	r6, [r1], #4
#if MEMP_SEPARATE_POOLS
		memp = (struct memp *)memp_bases[i];
#endif /* MEMP_SEPARATE_POOLS */
		/* create a linked list of memp elements */
		for (j = 0; j < memp_num[i]; ++j) {
    4bc8:	f834 cb02 	ldrh.w	ip, [r4], #2
    4bcc:	2500      	movs	r5, #0
    4bce:	b2af      	uxth	r7, r5
    4bd0:	45bc      	cmp	ip, r7
    4bd2:	d805      	bhi.n	4be0 <memp_init+0x30>
	for (i = 0; i < MEMP_MAX; ++i) {
    4bd4:	3a01      	subs	r2, #1
    4bd6:	b292      	uxth	r2, r2
    4bd8:	3002      	adds	r0, #2
    4bda:	2a00      	cmp	r2, #0
    4bdc:	d1f2      	bne.n	4bc4 <memp_init+0x14>
#if MEMP_OVERFLOW_CHECK
	memp_overflow_init();
	/* check everything a first time to see if it worked */
	memp_overflow_check_all();
#endif /* MEMP_OVERFLOW_CHECK */
}
    4bde:	bdf0      	pop	{r4, r5, r6, r7, pc}
			memp->next  = memp_tab[i];
    4be0:	f851 7c04 	ldr.w	r7, [r1, #-4]
    4be4:	601f      	str	r7, [r3, #0]
			memp        = (struct memp *)(void *)((u8_t *)memp + MEMP_SIZE + memp_sizes[i]
    4be6:	8807      	ldrh	r7, [r0, #0]
			memp_tab[i] = memp;
    4be8:	f841 3c04 	str.w	r3, [r1, #-4]
			memp        = (struct memp *)(void *)((u8_t *)memp + MEMP_SIZE + memp_sizes[i]
    4bec:	3501      	adds	r5, #1
    4bee:	443b      	add	r3, r7
		for (j = 0; j < memp_num[i]; ++j) {
    4bf0:	e7ed      	b.n	4bce <memp_init+0x1e>
    4bf2:	bf00      	nop
    4bf4:	2000a583 	.word	0x2000a583
    4bf8:	0000b67e 	.word	0x0000b67e
    4bfc:	2000a54c 	.word	0x2000a54c

00004c00 <memp_malloc>:
#endif
{
	struct memp *memp;
	SYS_ARCH_DECL_PROTECT(old_level);

	LWIP_ERROR("memp_malloc: type < MEMP_MAX", (type < MEMP_MAX), return NULL;);
    4c00:	280c      	cmp	r0, #12
    4c02:	d900      	bls.n	4c06 <memp_malloc+0x6>
    4c04:	e7fe      	b.n	4c04 <memp_malloc+0x4>
	SYS_ARCH_PROTECT(old_level);
#if MEMP_OVERFLOW_CHECK >= 2
	memp_overflow_check_all();
#endif /* MEMP_OVERFLOW_CHECK >= 2 */

	memp = memp_tab[type];
    4c06:	4a04      	ldr	r2, [pc, #16]	; (4c18 <memp_malloc+0x18>)
    4c08:	f852 3020 	ldr.w	r3, [r2, r0, lsl #2]

	if (memp != NULL) {
    4c0c:	b113      	cbz	r3, 4c14 <memp_malloc+0x14>
		memp_tab[type] = memp->next;
    4c0e:	6819      	ldr	r1, [r3, #0]
    4c10:	f842 1020 	str.w	r1, [r2, r0, lsl #2]
	}

	SYS_ARCH_UNPROTECT(old_level);

	return memp;
}
    4c14:	4618      	mov	r0, r3
    4c16:	4770      	bx	lr
    4c18:	2000a54c 	.word	0x2000a54c

00004c1c <memp_free>:
void memp_free(memp_t type, void *mem)
{
	struct memp *memp;
	SYS_ARCH_DECL_PROTECT(old_level);

	if (mem == NULL) {
    4c1c:	b129      	cbz	r1, 4c2a <memp_free+0xe>
#endif /* MEMP_OVERFLOW_CHECK >= 2 */
#endif /* MEMP_OVERFLOW_CHECK */

	MEMP_STATS_DEC(used, type);

	memp->next     = memp_tab[type];
    4c1e:	4b03      	ldr	r3, [pc, #12]	; (4c2c <memp_free+0x10>)
    4c20:	f853 2020 	ldr.w	r2, [r3, r0, lsl #2]
    4c24:	600a      	str	r2, [r1, #0]
	memp_tab[type] = memp;
    4c26:	f843 1020 	str.w	r1, [r3, r0, lsl #2]
#if MEMP_SANITY_CHECK
	LWIP_ASSERT("memp sanity", memp_sanity());
#endif /* MEMP_SANITY_CHECK */

	SYS_ARCH_UNPROTECT(old_level);
}
    4c2a:	4770      	bx	lr
    4c2c:	2000a54c 	.word	0x2000a54c

00004c30 <mac_read_cb>:
 */
static void mac_read_cb(struct _mac_async_device *dev)
{
	struct mac_async_descriptor *const descr = CONTAINER_OF(dev, struct mac_async_descriptor, dev);

	if (descr->cb.receive) {
    4c30:	6943      	ldr	r3, [r0, #20]
    4c32:	b103      	cbz	r3, 4c36 <mac_read_cb+0x6>
		descr->cb.receive(descr);
    4c34:	4718      	bx	r3
	}
}
    4c36:	4770      	bx	lr

00004c38 <mac_write_cb>:
 */
static void mac_write_cb(struct _mac_async_device *dev)
{
	struct mac_async_descriptor *const descr = CONTAINER_OF(dev, struct mac_async_descriptor, dev);

	if (descr->cb.transmit) {
    4c38:	6983      	ldr	r3, [r0, #24]
    4c3a:	b103      	cbz	r3, 4c3e <mac_write_cb+0x6>
		descr->cb.transmit(descr);
    4c3c:	4718      	bx	r3
	}
}
    4c3e:	4770      	bx	lr

00004c40 <mac_async_init>:
{
    4c40:	b570      	push	{r4, r5, r6, lr}
    4c42:	460d      	mov	r5, r1
	ASSERT(descr && hw);
    4c44:	4604      	mov	r4, r0
    4c46:	b110      	cbz	r0, 4c4e <mac_async_init+0xe>
    4c48:	1e08      	subs	r0, r1, #0
    4c4a:	bf18      	it	ne
    4c4c:	2001      	movne	r0, #1
    4c4e:	4905      	ldr	r1, [pc, #20]	; (4c64 <mac_async_init+0x24>)
    4c50:	4b05      	ldr	r3, [pc, #20]	; (4c68 <mac_async_init+0x28>)
    4c52:	2231      	movs	r2, #49	; 0x31
    4c54:	4798      	blx	r3
	return _mac_async_init(&descr->dev, hw);
    4c56:	4629      	mov	r1, r5
    4c58:	4620      	mov	r0, r4
    4c5a:	4b04      	ldr	r3, [pc, #16]	; (4c6c <mac_async_init+0x2c>)
}
    4c5c:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	return _mac_async_init(&descr->dev, hw);
    4c60:	4718      	bx	r3
    4c62:	bf00      	nop
    4c64:	0000b6b2 	.word	0x0000b6b2
    4c68:	00008a15 	.word	0x00008a15
    4c6c:	0000861d 	.word	0x0000861d

00004c70 <mac_async_enable>:
{
    4c70:	b510      	push	{r4, lr}
	ASSERT(descr);
    4c72:	4604      	mov	r4, r0
    4c74:	3800      	subs	r0, #0
    4c76:	4b05      	ldr	r3, [pc, #20]	; (4c8c <mac_async_enable+0x1c>)
    4c78:	4905      	ldr	r1, [pc, #20]	; (4c90 <mac_async_enable+0x20>)
    4c7a:	bf18      	it	ne
    4c7c:	2001      	movne	r0, #1
    4c7e:	2245      	movs	r2, #69	; 0x45
    4c80:	4798      	blx	r3
	return _mac_async_enable(&descr->dev);
    4c82:	4620      	mov	r0, r4
    4c84:	4b03      	ldr	r3, [pc, #12]	; (4c94 <mac_async_enable+0x24>)
}
    4c86:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	return _mac_async_enable(&descr->dev);
    4c8a:	4718      	bx	r3
    4c8c:	00008a15 	.word	0x00008a15
    4c90:	0000b6b2 	.word	0x0000b6b2
    4c94:	000086cd 	.word	0x000086cd

00004c98 <mac_async_write>:
{
    4c98:	b570      	push	{r4, r5, r6, lr}
    4c9a:	460d      	mov	r5, r1
    4c9c:	4616      	mov	r6, r2
	ASSERT(descr && buf && len);
    4c9e:	4604      	mov	r4, r0
    4ca0:	b118      	cbz	r0, 4caa <mac_async_write+0x12>
    4ca2:	b169      	cbz	r1, 4cc0 <mac_async_write+0x28>
    4ca4:	1e10      	subs	r0, r2, #0
    4ca6:	bf18      	it	ne
    4ca8:	2001      	movne	r0, #1
    4caa:	4906      	ldr	r1, [pc, #24]	; (4cc4 <mac_async_write+0x2c>)
    4cac:	4b06      	ldr	r3, [pc, #24]	; (4cc8 <mac_async_write+0x30>)
    4cae:	2257      	movs	r2, #87	; 0x57
    4cb0:	4798      	blx	r3
	return _mac_async_write(&descr->dev, buf, len);
    4cb2:	4632      	mov	r2, r6
    4cb4:	4629      	mov	r1, r5
    4cb6:	4620      	mov	r0, r4
    4cb8:	4b04      	ldr	r3, [pc, #16]	; (4ccc <mac_async_write+0x34>)
}
    4cba:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	return _mac_async_write(&descr->dev, buf, len);
    4cbe:	4718      	bx	r3
	ASSERT(descr && buf && len);
    4cc0:	4608      	mov	r0, r1
    4cc2:	e7f2      	b.n	4caa <mac_async_write+0x12>
    4cc4:	0000b6b2 	.word	0x0000b6b2
    4cc8:	00008a15 	.word	0x00008a15
    4ccc:	000086dd 	.word	0x000086dd

00004cd0 <mac_async_read>:
{
    4cd0:	b570      	push	{r4, r5, r6, lr}
	ASSERT(descr);
    4cd2:	4604      	mov	r4, r0
    4cd4:	3800      	subs	r0, #0
{
    4cd6:	460d      	mov	r5, r1
    4cd8:	4616      	mov	r6, r2
	ASSERT(descr);
    4cda:	4907      	ldr	r1, [pc, #28]	; (4cf8 <mac_async_read+0x28>)
    4cdc:	4b07      	ldr	r3, [pc, #28]	; (4cfc <mac_async_read+0x2c>)
    4cde:	f04f 0261 	mov.w	r2, #97	; 0x61
    4ce2:	bf18      	it	ne
    4ce4:	2001      	movne	r0, #1
    4ce6:	4798      	blx	r3
	return _mac_async_read(&descr->dev, buf, len);
    4ce8:	4632      	mov	r2, r6
    4cea:	4629      	mov	r1, r5
    4cec:	4620      	mov	r0, r4
    4cee:	4b04      	ldr	r3, [pc, #16]	; (4d00 <mac_async_read+0x30>)
}
    4cf0:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	return _mac_async_read(&descr->dev, buf, len);
    4cf4:	4718      	bx	r3
    4cf6:	bf00      	nop
    4cf8:	0000b6b2 	.word	0x0000b6b2
    4cfc:	00008a15 	.word	0x00008a15
    4d00:	000087d9 	.word	0x000087d9

00004d04 <mac_async_read_len>:
{
    4d04:	b510      	push	{r4, lr}
	ASSERT(descr);
    4d06:	4604      	mov	r4, r0
    4d08:	3800      	subs	r0, #0
    4d0a:	4b05      	ldr	r3, [pc, #20]	; (4d20 <mac_async_read_len+0x1c>)
    4d0c:	4905      	ldr	r1, [pc, #20]	; (4d24 <mac_async_read_len+0x20>)
    4d0e:	bf18      	it	ne
    4d10:	2001      	movne	r0, #1
    4d12:	226b      	movs	r2, #107	; 0x6b
    4d14:	4798      	blx	r3
	return _mac_async_read_len(&descr->dev);
    4d16:	4620      	mov	r0, r4
    4d18:	4b03      	ldr	r3, [pc, #12]	; (4d28 <mac_async_read_len+0x24>)
}
    4d1a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	return _mac_async_read_len(&descr->dev);
    4d1e:	4718      	bx	r3
    4d20:	00008a15 	.word	0x00008a15
    4d24:	0000b6b2 	.word	0x0000b6b2
    4d28:	000088c1 	.word	0x000088c1

00004d2c <mac_async_register_callback>:
{
    4d2c:	b570      	push	{r4, r5, r6, lr}
	ASSERT(descr);
    4d2e:	4605      	mov	r5, r0
    4d30:	3800      	subs	r0, #0
{
    4d32:	460e      	mov	r6, r1
    4d34:	4614      	mov	r4, r2
	ASSERT(descr);
    4d36:	bf18      	it	ne
    4d38:	2001      	movne	r0, #1
    4d3a:	490c      	ldr	r1, [pc, #48]	; (4d6c <mac_async_register_callback+0x40>)
    4d3c:	4b0c      	ldr	r3, [pc, #48]	; (4d70 <mac_async_register_callback+0x44>)
    4d3e:	2289      	movs	r2, #137	; 0x89
    4d40:	4798      	blx	r3
	switch (type) {
    4d42:	b126      	cbz	r6, 4d4e <mac_async_register_callback+0x22>
    4d44:	2e01      	cmp	r6, #1
    4d46:	d00d      	beq.n	4d64 <mac_async_register_callback+0x38>
}
    4d48:	f06f 000c 	mvn.w	r0, #12
    4d4c:	bd70      	pop	{r4, r5, r6, pc}
		return _mac_async_register_callback(&descr->dev, type, (func == NULL) ? NULL : (FUNC_PTR)mac_read_cb);
    4d4e:	4a09      	ldr	r2, [pc, #36]	; (4d74 <mac_async_register_callback+0x48>)
		descr->cb.receive = (mac_async_cb_t)func;
    4d50:	616c      	str	r4, [r5, #20]
		return _mac_async_register_callback(&descr->dev, type, (func == NULL) ? NULL : (FUNC_PTR)mac_read_cb);
    4d52:	2c00      	cmp	r4, #0
		return _mac_async_register_callback(&descr->dev, type, (func == NULL) ? NULL : (FUNC_PTR)mac_write_cb);
    4d54:	bf08      	it	eq
    4d56:	4622      	moveq	r2, r4
    4d58:	4631      	mov	r1, r6
    4d5a:	4628      	mov	r0, r5
    4d5c:	4b06      	ldr	r3, [pc, #24]	; (4d78 <mac_async_register_callback+0x4c>)
}
    4d5e:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		return _mac_async_register_callback(&descr->dev, type, (func == NULL) ? NULL : (FUNC_PTR)mac_write_cb);
    4d62:	4718      	bx	r3
    4d64:	4a05      	ldr	r2, [pc, #20]	; (4d7c <mac_async_register_callback+0x50>)
		descr->cb.transmit = (mac_async_cb_t)func;
    4d66:	61ac      	str	r4, [r5, #24]
		return _mac_async_register_callback(&descr->dev, type, (func == NULL) ? NULL : (FUNC_PTR)mac_write_cb);
    4d68:	2c00      	cmp	r4, #0
    4d6a:	e7f3      	b.n	4d54 <mac_async_register_callback+0x28>
    4d6c:	0000b6b2 	.word	0x0000b6b2
    4d70:	00008a15 	.word	0x00008a15
    4d74:	00004c31 	.word	0x00004c31
    4d78:	00008915 	.word	0x00008915
    4d7c:	00004c39 	.word	0x00004c39

00004d80 <mac_async_set_filter>:
{
    4d80:	b570      	push	{r4, r5, r6, lr}
    4d82:	460e      	mov	r6, r1
    4d84:	4615      	mov	r5, r2
	ASSERT(descr && filter);
    4d86:	4604      	mov	r4, r0
    4d88:	b110      	cbz	r0, 4d90 <mac_async_set_filter+0x10>
    4d8a:	1e10      	subs	r0, r2, #0
    4d8c:	bf18      	it	ne
    4d8e:	2001      	movne	r0, #1
    4d90:	4905      	ldr	r1, [pc, #20]	; (4da8 <mac_async_set_filter+0x28>)
    4d92:	4b06      	ldr	r3, [pc, #24]	; (4dac <mac_async_set_filter+0x2c>)
    4d94:	229b      	movs	r2, #155	; 0x9b
    4d96:	4798      	blx	r3
	return _mac_async_set_filter(&descr->dev, index, filter);
    4d98:	462a      	mov	r2, r5
    4d9a:	4631      	mov	r1, r6
    4d9c:	4620      	mov	r0, r4
    4d9e:	4b04      	ldr	r3, [pc, #16]	; (4db0 <mac_async_set_filter+0x30>)
}
    4da0:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	return _mac_async_set_filter(&descr->dev, index, filter);
    4da4:	4718      	bx	r3
    4da6:	bf00      	nop
    4da8:	0000b6b2 	.word	0x0000b6b2
    4dac:	00008a15 	.word	0x00008a15
    4db0:	0000893d 	.word	0x0000893d

00004db4 <mac_async_read_phy_reg>:
{
    4db4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    4db8:	460e      	mov	r6, r1
    4dba:	4617      	mov	r7, r2
    4dbc:	461d      	mov	r5, r3
	ASSERT(descr && val);
    4dbe:	4604      	mov	r4, r0
    4dc0:	b110      	cbz	r0, 4dc8 <mac_async_read_phy_reg+0x14>
    4dc2:	1e18      	subs	r0, r3, #0
    4dc4:	bf18      	it	ne
    4dc6:	2001      	movne	r0, #1
    4dc8:	4906      	ldr	r1, [pc, #24]	; (4de4 <mac_async_read_phy_reg+0x30>)
    4dca:	4b07      	ldr	r3, [pc, #28]	; (4de8 <mac_async_read_phy_reg+0x34>)
    4dcc:	22b8      	movs	r2, #184	; 0xb8
    4dce:	4798      	blx	r3
	return _mac_async_read_phy_reg(&descr->dev, addr, reg, val);
    4dd0:	4620      	mov	r0, r4
    4dd2:	4c06      	ldr	r4, [pc, #24]	; (4dec <mac_async_read_phy_reg+0x38>)
    4dd4:	462b      	mov	r3, r5
    4dd6:	463a      	mov	r2, r7
    4dd8:	4631      	mov	r1, r6
    4dda:	46a4      	mov	ip, r4
}
    4ddc:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
	return _mac_async_read_phy_reg(&descr->dev, addr, reg, val);
    4de0:	4760      	bx	ip
    4de2:	bf00      	nop
    4de4:	0000b6b2 	.word	0x0000b6b2
    4de8:	00008a15 	.word	0x00008a15
    4dec:	0000897d 	.word	0x0000897d

00004df0 <atmel_start_init>:

/**
 * Initializes MCU, drivers and middleware in the project
 **/
void atmel_start_init(void)
{
    4df0:	b510      	push	{r4, lr}
	system_init();
    4df2:	4b04      	ldr	r3, [pc, #16]	; (4e04 <atmel_start_init+0x14>)
    4df4:	4798      	blx	r3
	ethernet_phys_init();
    4df6:	4b04      	ldr	r3, [pc, #16]	; (4e08 <atmel_start_init+0x18>)
    4df8:	4798      	blx	r3
	stdio_redirect_init();
}
    4dfa:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	stdio_redirect_init();
    4dfe:	4b03      	ldr	r3, [pc, #12]	; (4e0c <atmel_start_init+0x1c>)
    4e00:	4718      	bx	r3
    4e02:	bf00      	nop
    4e04:	00004ae1 	.word	0x00004ae1
    4e08:	00000e2d 	.word	0x00000e2d
    4e0c:	00000fb5 	.word	0x00000fb5

00004e10 <etharp_free_entry>:

#endif /* ARP_QUEUEING */

/** Clean up ARP table entries */
static void etharp_free_entry(int i)
{
    4e10:	b570      	push	{r4, r5, r6, lr}
	/* remove from SNMP ARP index tree */
	snmp_delete_arpidx_tree(arp_table[i].netif, &arp_table[i].ipaddr);
	/* and empty packet queue */
	if (arp_table[i].q != NULL) {
    4e12:	2614      	movs	r6, #20
    4e14:	4c07      	ldr	r4, [pc, #28]	; (4e34 <etharp_free_entry+0x24>)
    4e16:	4346      	muls	r6, r0
{
    4e18:	4605      	mov	r5, r0
	if (arp_table[i].q != NULL) {
    4e1a:	59a0      	ldr	r0, [r4, r6]
    4e1c:	b118      	cbz	r0, 4e26 <etharp_free_entry+0x16>
		/* remove all queued packets */
		LWIP_DEBUGF(
		    ETHARP_DEBUG,
		    ("etharp_free_entry: freeing entry %" U16_F ", packet queue %p.\n", (u16_t)i, (void *)(arp_table[i].q)));
		free_etharp_q(arp_table[i].q);
    4e1e:	4b06      	ldr	r3, [pc, #24]	; (4e38 <etharp_free_entry+0x28>)
    4e20:	4798      	blx	r3
		arp_table[i].q = NULL;
    4e22:	2300      	movs	r3, #0
    4e24:	51a3      	str	r3, [r4, r6]
	}
	/* recycle entry for re-use */
	arp_table[i].state = ETHARP_STATE_EMPTY;
    4e26:	2014      	movs	r0, #20
    4e28:	fb00 4405 	mla	r4, r0, r5, r4
    4e2c:	2300      	movs	r3, #0
    4e2e:	74a3      	strb	r3, [r4, #18]
	arp_table[i].ctime = 0;
	arp_table[i].netif = NULL;
	ip_addr_set_zero(&arp_table[i].ipaddr);
	arp_table[i].ethaddr = ethzero;
#endif /* LWIP_DEBUG */
}
    4e30:	bd70      	pop	{r4, r5, r6, pc}
    4e32:	bf00      	nop
    4e34:	20011004 	.word	0x20011004
    4e38:	000030e5 	.word	0x000030e5

00004e3c <etharp_find_entry>:
 *
 * @return The ARP entry index that matched or is created, ERR_MEM if no
 * entry is found or could be recycled.
 */
static s8_t etharp_find_entry(ip_addr_t *ipaddr, u8_t flags)
{
    4e3c:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    4e40:	2200      	movs	r2, #0
	s8_t old_pending = ARP_TABLE_SIZE, old_stable = ARP_TABLE_SIZE;
	s8_t empty = ARP_TABLE_SIZE;
	u8_t i = 0, age_pending = 0, age_stable = 0;
	/* oldest entry with packets on queue */
	s8_t old_queue = ARP_TABLE_SIZE;
    4e42:	230a      	movs	r3, #10
{
    4e44:	460e      	mov	r6, r1
    4e46:	4930      	ldr	r1, [pc, #192]	; (4f08 <etharp_find_entry+0xcc>)
    4e48:	4604      	mov	r4, r0
	/* its age */
	u8_t age_queue = 0;
    4e4a:	4692      	mov	sl, r2
	u8_t i = 0, age_pending = 0, age_stable = 0;
    4e4c:	4691      	mov	r9, r2
    4e4e:	4690      	mov	r8, r2
	s8_t empty = ARP_TABLE_SIZE;
    4e50:	4618      	mov	r0, r3
	s8_t old_pending = ARP_TABLE_SIZE, old_stable = ARP_TABLE_SIZE;
    4e52:	469e      	mov	lr, r3
    4e54:	469c      	mov	ip, r3
	 */

	for (i = 0; i < ARP_TABLE_SIZE; ++i) {
		u8_t state = arp_table[i].state;
		/* no empty entry found yet and now we do find one? */
		if ((empty == ARP_TABLE_SIZE) && (state == ETHARP_STATE_EMPTY)) {
    4e56:	280a      	cmp	r0, #10
		u8_t state = arp_table[i].state;
    4e58:	f891 b012 	ldrb.w	fp, [r1, #18]
		if ((empty == ARP_TABLE_SIZE) && (state == ETHARP_STATE_EMPTY)) {
    4e5c:	d11c      	bne.n	4e98 <etharp_find_entry+0x5c>
    4e5e:	f1bb 0f00 	cmp.w	fp, #0
    4e62:	d11c      	bne.n	4e9e <etharp_find_entry+0x62>
			LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_find_entry: found empty entry %" U16_F "\n", (u16_t)i));
			/* remember first empty entry */
			empty = i;
    4e64:	b250      	sxtb	r0, r2
	for (i = 0; i < ARP_TABLE_SIZE; ++i) {
    4e66:	3201      	adds	r2, #1
    4e68:	2a0a      	cmp	r2, #10
    4e6a:	f101 0114 	add.w	r1, r1, #20
    4e6e:	d1f2      	bne.n	4e56 <etharp_find_entry+0x1a>
		}
	}
	/* { we have no match } => try to create a new entry */

	/* don't create new entry, only search? */
	if (((flags & ETHARP_FLAG_FIND_ONLY) != 0) ||
    4e70:	2e01      	cmp	r6, #1
    4e72:	d146      	bne.n	4f02 <etharp_find_entry+0xc6>
    4e74:	280a      	cmp	r0, #10
    4e76:	d031      	beq.n	4edc <etharp_find_entry+0xa0>
	 * { ETHARP_FLAG_TRY_HARD is set at this point }
	 */

	/* 1) empty entry available? */
	if (empty < ARP_TABLE_SIZE) {
		i = empty;
    4e78:	b2c6      	uxtb	r6, r0

	LWIP_ASSERT("i < ARP_TABLE_SIZE", i < ARP_TABLE_SIZE);
	LWIP_ASSERT("arp_table[i].state == ETHARP_STATE_EMPTY", arp_table[i].state == ETHARP_STATE_EMPTY);

	/* IP address given? */
	if (ipaddr != NULL) {
    4e7a:	b12c      	cbz	r4, 4e88 <etharp_find_entry+0x4c>
		/* set IP address */
		ip_addr_copy(arp_table[i].ipaddr, *ipaddr);
    4e7c:	4922      	ldr	r1, [pc, #136]	; (4f08 <etharp_find_entry+0xcc>)
    4e7e:	6822      	ldr	r2, [r4, #0]
    4e80:	2314      	movs	r3, #20
    4e82:	fb03 1306 	mla	r3, r3, r6, r1
    4e86:	605a      	str	r2, [r3, #4]
	}
	arp_table[i].ctime = 0;
    4e88:	4a1f      	ldr	r2, [pc, #124]	; (4f08 <etharp_find_entry+0xcc>)
    4e8a:	2314      	movs	r3, #20
    4e8c:	fb03 2506 	mla	r5, r3, r6, r2
    4e90:	2300      	movs	r3, #0
    4e92:	74eb      	strb	r3, [r5, #19]
	return (err_t)i;
    4e94:	b270      	sxtb	r0, r6
    4e96:	e008      	b.n	4eaa <etharp_find_entry+0x6e>
		} else if (state != ETHARP_STATE_EMPTY) {
    4e98:	f1bb 0f00 	cmp.w	fp, #0
    4e9c:	d0e3      	beq.n	4e66 <etharp_find_entry+0x2a>
			if (ipaddr && ip_addr_cmp(ipaddr, &arp_table[i].ipaddr)) {
    4e9e:	b134      	cbz	r4, 4eae <etharp_find_entry+0x72>
    4ea0:	6827      	ldr	r7, [r4, #0]
    4ea2:	684d      	ldr	r5, [r1, #4]
    4ea4:	42af      	cmp	r7, r5
    4ea6:	d102      	bne.n	4eae <etharp_find_entry+0x72>
				return i;
    4ea8:	b250      	sxtb	r0, r2
}
    4eaa:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
			if (state == ETHARP_STATE_PENDING) {
    4eae:	f1bb 0f01 	cmp.w	fp, #1
					if (arp_table[i].ctime >= age_queue) {
    4eb2:	7ccf      	ldrb	r7, [r1, #19]
			if (state == ETHARP_STATE_PENDING) {
    4eb4:	d10c      	bne.n	4ed0 <etharp_find_entry+0x94>
				if (arp_table[i].q != NULL) {
    4eb6:	680d      	ldr	r5, [r1, #0]
    4eb8:	b125      	cbz	r5, 4ec4 <etharp_find_entry+0x88>
					if (arp_table[i].ctime >= age_queue) {
    4eba:	4557      	cmp	r7, sl
    4ebc:	d3d3      	bcc.n	4e66 <etharp_find_entry+0x2a>
						old_queue = i;
    4ebe:	b253      	sxtb	r3, r2
    4ec0:	46ba      	mov	sl, r7
    4ec2:	e7d0      	b.n	4e66 <etharp_find_entry+0x2a>
					if (arp_table[i].ctime >= age_pending) {
    4ec4:	4547      	cmp	r7, r8
    4ec6:	d3ce      	bcc.n	4e66 <etharp_find_entry+0x2a>
						old_pending = i;
    4ec8:	fa4f fc82 	sxtb.w	ip, r2
    4ecc:	46b8      	mov	r8, r7
    4ece:	e7ca      	b.n	4e66 <etharp_find_entry+0x2a>
					if (arp_table[i].ctime >= age_stable) {
    4ed0:	454f      	cmp	r7, r9
						old_stable = i;
    4ed2:	bf24      	itt	cs
    4ed4:	fa4f fe82 	sxtbcs.w	lr, r2
    4ed8:	46b9      	movcs	r9, r7
    4eda:	e7c4      	b.n	4e66 <etharp_find_entry+0x2a>
		if (old_stable < ARP_TABLE_SIZE) {
    4edc:	f1be 0f0a 	cmp.w	lr, #10
    4ee0:	d005      	beq.n	4eee <etharp_find_entry+0xb2>
			i = old_stable;
    4ee2:	fa5f f68e 	uxtb.w	r6, lr
		etharp_free_entry(i);
    4ee6:	4b09      	ldr	r3, [pc, #36]	; (4f0c <etharp_find_entry+0xd0>)
    4ee8:	4630      	mov	r0, r6
    4eea:	4798      	blx	r3
    4eec:	e7c5      	b.n	4e7a <etharp_find_entry+0x3e>
		} else if (old_pending < ARP_TABLE_SIZE) {
    4eee:	f1bc 0f0a 	cmp.w	ip, #10
    4ef2:	d002      	beq.n	4efa <etharp_find_entry+0xbe>
			i = old_pending;
    4ef4:	fa5f f68c 	uxtb.w	r6, ip
			            ("etharp_find_entry: selecting oldest pending entry %" U16_F " (without queue)\n", (u16_t)i));
    4ef8:	e7f5      	b.n	4ee6 <etharp_find_entry+0xaa>
		} else if (old_queue < ARP_TABLE_SIZE) {
    4efa:	2b0a      	cmp	r3, #10
    4efc:	d001      	beq.n	4f02 <etharp_find_entry+0xc6>
			i = old_queue;
    4efe:	b2de      	uxtb	r6, r3
			             (void *)(arp_table[i].q)));
    4f00:	e7f1      	b.n	4ee6 <etharp_find_entry+0xaa>
		return (s8_t)ERR_MEM;
    4f02:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    4f06:	e7d0      	b.n	4eaa <etharp_find_entry+0x6e>
    4f08:	20011004 	.word	0x20011004
    4f0c:	00004e11 	.word	0x00004e11

00004f10 <etharp_send_ip>:
 * @params src the source MAC address to be copied into the ethernet header
 * @params dst the destination MAC address to be copied into the ethernet header
 * @return ERR_OK if the packet was sent, any other err_t on failure
 */
static err_t etharp_send_ip(struct netif *netif, struct pbuf *p, struct eth_addr *src, struct eth_addr *dst)
{
    4f10:	b430      	push	{r4, r5}
	struct eth_hdr *ethhdr = (struct eth_hdr *)p->payload;
    4f12:	684c      	ldr	r4, [r1, #4]

	LWIP_ASSERT("netif->hwaddr_len must be the same as ETHARP_HWADDR_LEN for etharp!",
	            (netif->hwaddr_len == ETHARP_HWADDR_LEN));
	ETHADDR32_COPY(&ethhdr->dest, dst);
    4f14:	681d      	ldr	r5, [r3, #0]
    4f16:	f8c4 5002 	str.w	r5, [r4, #2]
    4f1a:	889b      	ldrh	r3, [r3, #4]
    4f1c:	80e3      	strh	r3, [r4, #6]
	ETHADDR16_COPY(&ethhdr->src, src);
    4f1e:	6813      	ldr	r3, [r2, #0]
    4f20:	60a3      	str	r3, [r4, #8]
    4f22:	8893      	ldrh	r3, [r2, #4]
    4f24:	81a3      	strh	r3, [r4, #12]
	ethhdr->type = PP_HTONS(ETHTYPE_IP);
    4f26:	2308      	movs	r3, #8
    4f28:	73a3      	strb	r3, [r4, #14]
    4f2a:	2300      	movs	r3, #0
    4f2c:	73e3      	strb	r3, [r4, #15]
	LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_send_ip: sending packet %p\n", (void *)p));
	/* send the packet */
	return netif->linkoutput(netif, p);
}
    4f2e:	bc30      	pop	{r4, r5}
	return netif->linkoutput(netif, p);
    4f30:	6983      	ldr	r3, [r0, #24]
    4f32:	4718      	bx	r3

00004f34 <etharp_tmr>:
{
    4f34:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    4f36:	4c0e      	ldr	r4, [pc, #56]	; (4f70 <etharp_tmr+0x3c>)
				etharp_free_entry(i);
    4f38:	4e0e      	ldr	r6, [pc, #56]	; (4f74 <etharp_tmr+0x40>)
{
    4f3a:	2500      	movs	r5, #0
				arp_table[i].state = ETHARP_STATE_STABLE;
    4f3c:	2702      	movs	r7, #2
		u8_t state = arp_table[i].state;
    4f3e:	7ca2      	ldrb	r2, [r4, #18]
		if (state != ETHARP_STATE_EMPTY
    4f40:	b15a      	cbz	r2, 4f5a <etharp_tmr+0x26>
			arp_table[i].ctime++;
    4f42:	7ce3      	ldrb	r3, [r4, #19]
    4f44:	3301      	adds	r3, #1
    4f46:	b2db      	uxtb	r3, r3
			if ((arp_table[i].ctime >= ARP_MAXAGE)
    4f48:	2bef      	cmp	r3, #239	; 0xef
			arp_table[i].ctime++;
    4f4a:	74e3      	strb	r3, [r4, #19]
			if ((arp_table[i].ctime >= ARP_MAXAGE)
    4f4c:	d803      	bhi.n	4f56 <etharp_tmr+0x22>
			    || ((arp_table[i].state == ETHARP_STATE_PENDING) && (arp_table[i].ctime >= ARP_MAXPENDING))) {
    4f4e:	2a01      	cmp	r2, #1
    4f50:	d109      	bne.n	4f66 <etharp_tmr+0x32>
    4f52:	2b01      	cmp	r3, #1
    4f54:	d901      	bls.n	4f5a <etharp_tmr+0x26>
				etharp_free_entry(i);
    4f56:	4628      	mov	r0, r5
    4f58:	47b0      	blx	r6
	for (i = 0; i < ARP_TABLE_SIZE; ++i) {
    4f5a:	3501      	adds	r5, #1
    4f5c:	2d0a      	cmp	r5, #10
    4f5e:	f104 0414 	add.w	r4, r4, #20
    4f62:	d1ec      	bne.n	4f3e <etharp_tmr+0xa>
}
    4f64:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
			} else if (arp_table[i].state == ETHARP_STATE_STABLE_REREQUESTING) {
    4f66:	2a03      	cmp	r2, #3
				arp_table[i].state = ETHARP_STATE_STABLE;
    4f68:	bf08      	it	eq
    4f6a:	74a7      	strbeq	r7, [r4, #18]
    4f6c:	e7f5      	b.n	4f5a <etharp_tmr+0x26>
    4f6e:	bf00      	nop
    4f70:	20011004 	.word	0x20011004
    4f74:	00004e11 	.word	0x00004e11

00004f78 <etharp_cleanup_netif>:
 * Remove all ARP table entries of the specified netif.
 *
 * @param netif points to a network interface
 */
void etharp_cleanup_netif(struct netif *netif)
{
    4f78:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    4f7a:	4d08      	ldr	r5, [pc, #32]	; (4f9c <etharp_cleanup_netif+0x24>)
	u8_t i;

	for (i = 0; i < ARP_TABLE_SIZE; ++i) {
		u8_t state = arp_table[i].state;
		if ((state != ETHARP_STATE_EMPTY) && (arp_table[i].netif == netif)) {
			etharp_free_entry(i);
    4f7c:	4f08      	ldr	r7, [pc, #32]	; (4fa0 <etharp_cleanup_netif+0x28>)
{
    4f7e:	4606      	mov	r6, r0
    4f80:	2400      	movs	r4, #0
		if ((state != ETHARP_STATE_EMPTY) && (arp_table[i].netif == netif)) {
    4f82:	7cab      	ldrb	r3, [r5, #18]
    4f84:	b123      	cbz	r3, 4f90 <etharp_cleanup_netif+0x18>
    4f86:	68ab      	ldr	r3, [r5, #8]
    4f88:	42b3      	cmp	r3, r6
    4f8a:	d101      	bne.n	4f90 <etharp_cleanup_netif+0x18>
			etharp_free_entry(i);
    4f8c:	4620      	mov	r0, r4
    4f8e:	47b8      	blx	r7
	for (i = 0; i < ARP_TABLE_SIZE; ++i) {
    4f90:	3401      	adds	r4, #1
    4f92:	2c0a      	cmp	r4, #10
    4f94:	f105 0514 	add.w	r5, r5, #20
    4f98:	d1f3      	bne.n	4f82 <etharp_cleanup_netif+0xa>
		}
	}
}
    4f9a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    4f9c:	20011004 	.word	0x20011004
    4fa0:	00004e11 	.word	0x00004e11

00004fa4 <etharp_request>:
 * @return ERR_OK if the request has been sent
 *         ERR_MEM if the ARP packet couldn't be allocated
 *         any other err_t on failure
 */
err_t etharp_request(struct netif *netif, ip_addr_t *ipaddr)
{
    4fa4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	p = pbuf_alloc(PBUF_RAW, SIZEOF_ETHARP_PACKET, PBUF_RAM);
    4fa8:	4b23      	ldr	r3, [pc, #140]	; (5038 <etharp_request+0x94>)
{
    4faa:	4605      	mov	r5, r0
    4fac:	460f      	mov	r7, r1
	p = pbuf_alloc(PBUF_RAW, SIZEOF_ETHARP_PACKET, PBUF_RAM);
    4fae:	2200      	movs	r2, #0
    4fb0:	212c      	movs	r1, #44	; 0x2c
    4fb2:	2003      	movs	r0, #3
    4fb4:	4798      	blx	r3
	if (p == NULL) {
    4fb6:	4606      	mov	r6, r0
    4fb8:	2800      	cmp	r0, #0
    4fba:	d039      	beq.n	5030 <etharp_request+0x8c>
	ethhdr = (struct eth_hdr *)p->payload;
    4fbc:	6844      	ldr	r4, [r0, #4]
	hdr->opcode = htons(opcode);
    4fbe:	4b1f      	ldr	r3, [pc, #124]	; (503c <etharp_request+0x98>)
    4fc0:	2001      	movs	r0, #1
    4fc2:	4798      	blx	r3
    4fc4:	82e0      	strh	r0, [r4, #22]
	ETHADDR16_COPY(&hdr->shwaddr, hwsrc_addr);
    4fc6:	f8d5 302b 	ldr.w	r3, [r5, #43]	; 0x2b
    4fca:	61a3      	str	r3, [r4, #24]
    4fcc:	f8b5 302f 	ldrh.w	r3, [r5, #47]	; 0x2f
    4fd0:	83a3      	strh	r3, [r4, #28]
	ETHADDR16_COPY(&hdr->dhwaddr, hwdst_addr);
    4fd2:	4b1b      	ldr	r3, [pc, #108]	; (5040 <etharp_request+0x9c>)
    4fd4:	681a      	ldr	r2, [r3, #0]
    4fd6:	889b      	ldrh	r3, [r3, #4]
    4fd8:	84e3      	strh	r3, [r4, #38]	; 0x26
	ETHADDR16_COPY(&ethhdr->dest, ethdst_addr);
    4fda:	4b1a      	ldr	r3, [pc, #104]	; (5044 <etharp_request+0xa0>)
	ETHADDR16_COPY(&hdr->dhwaddr, hwdst_addr);
    4fdc:	f8c4 2022 	str.w	r2, [r4, #34]	; 0x22
	ETHADDR16_COPY(&ethhdr->dest, ethdst_addr);
    4fe0:	681a      	ldr	r2, [r3, #0]
    4fe2:	889b      	ldrh	r3, [r3, #4]
    4fe4:	f8c4 2002 	str.w	r2, [r4, #2]
    4fe8:	80e3      	strh	r3, [r4, #6]
	ETHADDR16_COPY(&ethhdr->src, ethsrc_addr);
    4fea:	f8d5 302b 	ldr.w	r3, [r5, #43]	; 0x2b
    4fee:	60a3      	str	r3, [r4, #8]
    4ff0:	f8b5 302f 	ldrh.w	r3, [r5, #47]	; 0x2f
    4ff4:	81a3      	strh	r3, [r4, #12]
	IPADDR2_COPY(&hdr->sipaddr, ipsrc_addr);
    4ff6:	686b      	ldr	r3, [r5, #4]
    4ff8:	f8c4 301e 	str.w	r3, [r4, #30]
	IPADDR2_COPY(&hdr->dipaddr, ipdst_addr);
    4ffc:	683b      	ldr	r3, [r7, #0]
    4ffe:	62a3      	str	r3, [r4, #40]	; 0x28
	hdr->hwtype = PP_HTONS(HWTYPE_ETHERNET);
    5000:	2300      	movs	r3, #0
    5002:	7423      	strb	r3, [r4, #16]
	hdr->proto  = PP_HTONS(ETHTYPE_IP);
    5004:	74e3      	strb	r3, [r4, #19]
	hdr->hwtype = PP_HTONS(HWTYPE_ETHERNET);
    5006:	2201      	movs	r2, #1
	hdr->hwlen    = ETHARP_HWADDR_LEN;
    5008:	2306      	movs	r3, #6
	hdr->protolen = sizeof(ip_addr_t);
    500a:	2104      	movs	r1, #4
    500c:	7561      	strb	r1, [r4, #21]
	hdr->hwtype = PP_HTONS(HWTYPE_ETHERNET);
    500e:	7462      	strb	r2, [r4, #17]
	hdr->hwlen    = ETHARP_HWADDR_LEN;
    5010:	7523      	strb	r3, [r4, #20]
	hdr->proto  = PP_HTONS(ETHTYPE_IP);
    5012:	2208      	movs	r2, #8
	ethhdr->type = PP_HTONS(ETHTYPE_ARP);
    5014:	73e3      	strb	r3, [r4, #15]
	hdr->proto  = PP_HTONS(ETHTYPE_IP);
    5016:	74a2      	strb	r2, [r4, #18]
	result = netif->linkoutput(netif, p);
    5018:	69ab      	ldr	r3, [r5, #24]
	ethhdr->type = PP_HTONS(ETHTYPE_ARP);
    501a:	73a2      	strb	r2, [r4, #14]
	result = netif->linkoutput(netif, p);
    501c:	4631      	mov	r1, r6
    501e:	4628      	mov	r0, r5
    5020:	4798      	blx	r3
	pbuf_free(p);
    5022:	4b09      	ldr	r3, [pc, #36]	; (5048 <etharp_request+0xa4>)
	result = netif->linkoutput(netif, p);
    5024:	4604      	mov	r4, r0
	pbuf_free(p);
    5026:	4630      	mov	r0, r6
    5028:	4798      	blx	r3
	                  (struct eth_addr *)netif->hwaddr,
	                  &netif->ip_addr,
	                  &ethzero,
	                  ipaddr,
	                  ARP_REQUEST);
}
    502a:	4620      	mov	r0, r4
    502c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		return ERR_MEM;
    5030:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
    5034:	e7f9      	b.n	502a <etharp_request+0x86>
    5036:	bf00      	nop
    5038:	0000313d 	.word	0x0000313d
    503c:	00000d65 	.word	0x00000d65
    5040:	0000b6d4 	.word	0x0000b6d4
    5044:	0000b6cd 	.word	0x0000b6cd
    5048:	000030e5 	.word	0x000030e5

0000504c <etharp_output_to_arp_index>:
{
    504c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	if ((arp_table[arp_idx].state == ETHARP_STATE_STABLE) && (arp_table[arp_idx].ctime >= ARP_AGE_REREQUEST_USED)) {
    5050:	f8df 804c 	ldr.w	r8, [pc, #76]	; 50a0 <etharp_output_to_arp_index+0x54>
    5054:	2414      	movs	r4, #20
    5056:	fb04 8402 	mla	r4, r4, r2, r8
    505a:	eb02 0582 	add.w	r5, r2, r2, lsl #2
    505e:	7ca3      	ldrb	r3, [r4, #18]
    5060:	2b02      	cmp	r3, #2
{
    5062:	4606      	mov	r6, r0
    5064:	460f      	mov	r7, r1
    5066:	ea4f 0585 	mov.w	r5, r5, lsl #2
	if ((arp_table[arp_idx].state == ETHARP_STATE_STABLE) && (arp_table[arp_idx].ctime >= ARP_AGE_REREQUEST_USED)) {
    506a:	d109      	bne.n	5080 <etharp_output_to_arp_index+0x34>
    506c:	7ce3      	ldrb	r3, [r4, #19]
    506e:	2be3      	cmp	r3, #227	; 0xe3
    5070:	d906      	bls.n	5080 <etharp_output_to_arp_index+0x34>
		if (etharp_request(netif, &arp_table[arp_idx].ipaddr) == ERR_OK) {
    5072:	1d29      	adds	r1, r5, #4
    5074:	4b08      	ldr	r3, [pc, #32]	; (5098 <etharp_output_to_arp_index+0x4c>)
    5076:	4441      	add	r1, r8
    5078:	4798      	blx	r3
    507a:	b908      	cbnz	r0, 5080 <etharp_output_to_arp_index+0x34>
			arp_table[arp_idx].state = ETHARP_STATE_STABLE_REREQUESTING;
    507c:	2303      	movs	r3, #3
    507e:	74a3      	strb	r3, [r4, #18]
	return etharp_send_ip(netif, q, (struct eth_addr *)(netif->hwaddr), &arp_table[arp_idx].ethaddr);
    5080:	4c06      	ldr	r4, [pc, #24]	; (509c <etharp_output_to_arp_index+0x50>)
    5082:	350c      	adds	r5, #12
    5084:	eb08 0305 	add.w	r3, r8, r5
    5088:	f106 022b 	add.w	r2, r6, #43	; 0x2b
    508c:	4639      	mov	r1, r7
    508e:	4630      	mov	r0, r6
    5090:	46a4      	mov	ip, r4
}
    5092:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
	return etharp_send_ip(netif, q, (struct eth_addr *)(netif->hwaddr), &arp_table[arp_idx].ethaddr);
    5096:	4760      	bx	ip
    5098:	00004fa5 	.word	0x00004fa5
    509c:	00004f11 	.word	0x00004f11
    50a0:	20011004 	.word	0x20011004

000050a4 <etharp_query>:
{
    50a4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    50a8:	4688      	mov	r8, r1
    50aa:	4606      	mov	r6, r0
	if (ip_addr_isbroadcast(ipaddr, netif) || ip_addr_ismulticast(ipaddr) || ip_addr_isany(ipaddr)) {
    50ac:	4601      	mov	r1, r0
    50ae:	4b36      	ldr	r3, [pc, #216]	; (5188 <etharp_query+0xe4>)
    50b0:	f8d8 0000 	ldr.w	r0, [r8]
{
    50b4:	4615      	mov	r5, r2
	if (ip_addr_isbroadcast(ipaddr, netif) || ip_addr_ismulticast(ipaddr) || ip_addr_isany(ipaddr)) {
    50b6:	4798      	blx	r3
    50b8:	2800      	cmp	r0, #0
    50ba:	d14e      	bne.n	515a <etharp_query+0xb6>
    50bc:	f8d8 3000 	ldr.w	r3, [r8]
    50c0:	f003 02f0 	and.w	r2, r3, #240	; 0xf0
    50c4:	2ae0      	cmp	r2, #224	; 0xe0
    50c6:	d048      	beq.n	515a <etharp_query+0xb6>
    50c8:	2b00      	cmp	r3, #0
    50ca:	d046      	beq.n	515a <etharp_query+0xb6>
	i = etharp_find_entry(ipaddr, ETHARP_FLAG_TRY_HARD);
    50cc:	4b2f      	ldr	r3, [pc, #188]	; (518c <etharp_query+0xe8>)
    50ce:	2101      	movs	r1, #1
    50d0:	4640      	mov	r0, r8
    50d2:	4798      	blx	r3
	if (i < 0) {
    50d4:	1e04      	subs	r4, r0, #0
    50d6:	db43      	blt.n	5160 <etharp_query+0xbc>
	if (arp_table[i].state == ETHARP_STATE_EMPTY) {
    50d8:	4f2d      	ldr	r7, [pc, #180]	; (5190 <etharp_query+0xec>)
    50da:	2314      	movs	r3, #20
    50dc:	fb03 7304 	mla	r3, r3, r4, r7
    50e0:	7c9a      	ldrb	r2, [r3, #18]
    50e2:	b942      	cbnz	r2, 50f6 <etharp_query+0x52>
		arp_table[i].state = ETHARP_STATE_PENDING;
    50e4:	2201      	movs	r2, #1
    50e6:	749a      	strb	r2, [r3, #18]
		result = etharp_request(netif, ipaddr);
    50e8:	4b2a      	ldr	r3, [pc, #168]	; (5194 <etharp_query+0xf0>)
    50ea:	4641      	mov	r1, r8
    50ec:	4630      	mov	r0, r6
    50ee:	4798      	blx	r3
		if (q == NULL) {
    50f0:	b93d      	cbnz	r5, 5102 <etharp_query+0x5e>
}
    50f2:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	if ((arp_table[i].state == ETHARP_STATE_PENDING) || (q == NULL)) {
    50f6:	2a01      	cmp	r2, #1
    50f8:	d0f6      	beq.n	50e8 <etharp_query+0x44>
    50fa:	2d00      	cmp	r5, #0
    50fc:	d0f4      	beq.n	50e8 <etharp_query+0x44>
	err_t            result  = ERR_MEM;
    50fe:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
	if (arp_table[i].state >= ETHARP_STATE_STABLE) {
    5102:	2314      	movs	r3, #20
    5104:	fb03 7204 	mla	r2, r3, r4, r7
    5108:	7c92      	ldrb	r2, [r2, #18]
    510a:	2a01      	cmp	r2, #1
    510c:	d90e      	bls.n	512c <etharp_query+0x88>
		result = etharp_send_ip(netif, q, srcaddr, &(arp_table[i].ethaddr));
    510e:	200c      	movs	r0, #12
    5110:	fb13 0304 	smlabb	r3, r3, r4, r0
		ETHARP_SET_HINT(netif, i);
    5114:	f887 40c8 	strb.w	r4, [r7, #200]	; 0xc8
		result = etharp_send_ip(netif, q, srcaddr, &(arp_table[i].ethaddr));
    5118:	4c1f      	ldr	r4, [pc, #124]	; (5198 <etharp_query+0xf4>)
    511a:	443b      	add	r3, r7
    511c:	f106 022b 	add.w	r2, r6, #43	; 0x2b
    5120:	4629      	mov	r1, r5
    5122:	4630      	mov	r0, r6
    5124:	46a4      	mov	ip, r4
}
    5126:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
		result = etharp_send_ip(netif, q, srcaddr, &(arp_table[i].ethaddr));
    512a:	4760      	bx	ip
	} else if (arp_table[i].state == ETHARP_STATE_PENDING) {
    512c:	d1e1      	bne.n	50f2 <etharp_query+0x4e>
    512e:	462b      	mov	r3, r5
			if (p->type != PBUF_ROM) {
    5130:	7b1a      	ldrb	r2, [r3, #12]
    5132:	2a01      	cmp	r2, #1
    5134:	d116      	bne.n	5164 <etharp_query+0xc0>
			p = p->next;
    5136:	681b      	ldr	r3, [r3, #0]
		while (p) {
    5138:	2b00      	cmp	r3, #0
    513a:	d1f9      	bne.n	5130 <etharp_query+0x8c>
			pbuf_ref(p);
    513c:	4b17      	ldr	r3, [pc, #92]	; (519c <etharp_query+0xf8>)
    513e:	4628      	mov	r0, r5
    5140:	4798      	blx	r3
    5142:	462e      	mov	r6, r5
			if (arp_table[i].q != NULL) {
    5144:	2314      	movs	r3, #20
    5146:	4363      	muls	r3, r4
    5148:	58f8      	ldr	r0, [r7, r3]
    514a:	b108      	cbz	r0, 5150 <etharp_query+0xac>
				pbuf_free(arp_table[i].q);
    514c:	4b14      	ldr	r3, [pc, #80]	; (51a0 <etharp_query+0xfc>)
    514e:	4798      	blx	r3
			arp_table[i].q = p;
    5150:	2314      	movs	r3, #20
    5152:	435c      	muls	r4, r3
			result = ERR_OK;
    5154:	2000      	movs	r0, #0
			arp_table[i].q = p;
    5156:	513e      	str	r6, [r7, r4]
			            ("etharp_query: queued packet %p on ARP entry %" S16_F "\n", (void *)q, (s16_t)i));
    5158:	e7cb      	b.n	50f2 <etharp_query+0x4e>
		return ERR_ARG;
    515a:	f06f 000d 	mvn.w	r0, #13
    515e:	e7c8      	b.n	50f2 <etharp_query+0x4e>
    5160:	4620      	mov	r0, r4
    5162:	e7c6      	b.n	50f2 <etharp_query+0x4e>
			p = pbuf_alloc(PBUF_RAW, p->tot_len, PBUF_RAM);
    5164:	8919      	ldrh	r1, [r3, #8]
    5166:	4b0f      	ldr	r3, [pc, #60]	; (51a4 <etharp_query+0x100>)
    5168:	2200      	movs	r2, #0
    516a:	2003      	movs	r0, #3
    516c:	4798      	blx	r3
			if (p != NULL) {
    516e:	4606      	mov	r6, r0
    5170:	b138      	cbz	r0, 5182 <etharp_query+0xde>
				if (pbuf_copy(p, q) != ERR_OK) {
    5172:	4b0d      	ldr	r3, [pc, #52]	; (51a8 <etharp_query+0x104>)
    5174:	4629      	mov	r1, r5
    5176:	4798      	blx	r3
    5178:	2800      	cmp	r0, #0
    517a:	d0e3      	beq.n	5144 <etharp_query+0xa0>
					pbuf_free(p);
    517c:	4b08      	ldr	r3, [pc, #32]	; (51a0 <etharp_query+0xfc>)
    517e:	4630      	mov	r0, r6
    5180:	4798      	blx	r3
			result = ERR_MEM;
    5182:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    5186:	e7b4      	b.n	50f2 <etharp_query+0x4e>
    5188:	00008a1b 	.word	0x00008a1b
    518c:	00004e3d 	.word	0x00004e3d
    5190:	20011004 	.word	0x20011004
    5194:	00004fa5 	.word	0x00004fa5
    5198:	00004f11 	.word	0x00004f11
    519c:	000032b1 	.word	0x000032b1
    51a0:	000030e5 	.word	0x000030e5
    51a4:	0000313d 	.word	0x0000313d
    51a8:	000032f1 	.word	0x000032f1

000051ac <etharp_output>:
{
    51ac:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
    51ae:	460e      	mov	r6, r1
    51b0:	4604      	mov	r4, r0
	if (pbuf_header(q, sizeof(struct eth_hdr)) != 0) {
    51b2:	4b3a      	ldr	r3, [pc, #232]	; (529c <etharp_output+0xf0>)
    51b4:	2110      	movs	r1, #16
    51b6:	4630      	mov	r0, r6
{
    51b8:	4615      	mov	r5, r2
	if (pbuf_header(q, sizeof(struct eth_hdr)) != 0) {
    51ba:	4798      	blx	r3
    51bc:	2800      	cmp	r0, #0
    51be:	d167      	bne.n	5290 <etharp_output+0xe4>
	if (ip_addr_isbroadcast(ipaddr, netif)) {
    51c0:	6828      	ldr	r0, [r5, #0]
    51c2:	4b37      	ldr	r3, [pc, #220]	; (52a0 <etharp_output+0xf4>)
    51c4:	4621      	mov	r1, r4
    51c6:	4798      	blx	r3
    51c8:	2800      	cmp	r0, #0
    51ca:	d15f      	bne.n	528c <etharp_output+0xe0>
	} else if (ip_addr_ismulticast(ipaddr)) {
    51cc:	682b      	ldr	r3, [r5, #0]
    51ce:	f003 02f0 	and.w	r2, r3, #240	; 0xf0
    51d2:	2ae0      	cmp	r2, #224	; 0xe0
    51d4:	d11b      	bne.n	520e <etharp_output+0x62>
		mcastaddr.addr[0] = LL_MULTICAST_ADDR_0;
    51d6:	2301      	movs	r3, #1
    51d8:	f88d 3000 	strb.w	r3, [sp]
		mcastaddr.addr[2] = LL_MULTICAST_ADDR_2;
    51dc:	235e      	movs	r3, #94	; 0x5e
    51de:	f88d 3002 	strb.w	r3, [sp, #2]
		mcastaddr.addr[3] = ip4_addr2(ipaddr) & 0x7f;
    51e2:	786b      	ldrb	r3, [r5, #1]
		mcastaddr.addr[1] = LL_MULTICAST_ADDR_1;
    51e4:	f88d 0001 	strb.w	r0, [sp, #1]
		mcastaddr.addr[3] = ip4_addr2(ipaddr) & 0x7f;
    51e8:	f003 037f 	and.w	r3, r3, #127	; 0x7f
    51ec:	f88d 3003 	strb.w	r3, [sp, #3]
		mcastaddr.addr[4] = ip4_addr3(ipaddr);
    51f0:	78ab      	ldrb	r3, [r5, #2]
    51f2:	f88d 3004 	strb.w	r3, [sp, #4]
		mcastaddr.addr[5] = ip4_addr4(ipaddr);
    51f6:	78eb      	ldrb	r3, [r5, #3]
    51f8:	f88d 3005 	strb.w	r3, [sp, #5]
		dest = &mcastaddr;
    51fc:	466b      	mov	r3, sp
	return etharp_send_ip(netif, q, (struct eth_addr *)(netif->hwaddr), dest);
    51fe:	f104 022b 	add.w	r2, r4, #43	; 0x2b
    5202:	4620      	mov	r0, r4
    5204:	4631      	mov	r1, r6
    5206:	4c27      	ldr	r4, [pc, #156]	; (52a4 <etharp_output+0xf8>)
    5208:	47a0      	blx	r4
}
    520a:	b003      	add	sp, #12
    520c:	bdf0      	pop	{r4, r5, r6, r7, pc}
		if (!ip_addr_netcmp(ipaddr, &(netif->ip_addr), &(netif->netmask)) && !ip_addr_islinklocal(ipaddr)) {
    520e:	6862      	ldr	r2, [r4, #4]
    5210:	68a1      	ldr	r1, [r4, #8]
    5212:	405a      	eors	r2, r3
    5214:	420a      	tst	r2, r1
    5216:	d009      	beq.n	522c <etharp_output+0x80>
    5218:	b29b      	uxth	r3, r3
    521a:	f64f 62a9 	movw	r2, #65193	; 0xfea9
    521e:	4293      	cmp	r3, r2
    5220:	d004      	beq.n	522c <etharp_output+0x80>
				if (!ip_addr_isany(&netif->gw)) {
    5222:	68e3      	ldr	r3, [r4, #12]
    5224:	f104 050c 	add.w	r5, r4, #12
    5228:	2b00      	cmp	r3, #0
    522a:	d034      	beq.n	5296 <etharp_output+0xea>
				if ((arp_table[etharp_cached_entry].state >= ETHARP_STATE_STABLE)
    522c:	481e      	ldr	r0, [pc, #120]	; (52a8 <etharp_output+0xfc>)
    522e:	f890 20c8 	ldrb.w	r2, [r0, #200]	; 0xc8
    5232:	2314      	movs	r3, #20
    5234:	fb03 0302 	mla	r3, r3, r2, r0
    5238:	7c99      	ldrb	r1, [r3, #18]
    523a:	2901      	cmp	r1, #1
    523c:	d90a      	bls.n	5254 <etharp_output+0xa8>
				    && (ip_addr_cmp(dst_addr, &arp_table[etharp_cached_entry].ipaddr))) {
    523e:	6829      	ldr	r1, [r5, #0]
    5240:	685b      	ldr	r3, [r3, #4]
    5242:	4299      	cmp	r1, r3
    5244:	d106      	bne.n	5254 <etharp_output+0xa8>
				return etharp_output_to_arp_index(netif, q, i);
    5246:	4b19      	ldr	r3, [pc, #100]	; (52ac <etharp_output+0x100>)
    5248:	4631      	mov	r1, r6
    524a:	4620      	mov	r0, r4
}
    524c:	b003      	add	sp, #12
    524e:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
				return etharp_output_to_arp_index(netif, q, i);
    5252:	4718      	bx	r3
    5254:	4914      	ldr	r1, [pc, #80]	; (52a8 <etharp_output+0xfc>)
{
    5256:	2300      	movs	r3, #0
			if ((arp_table[i].state >= ETHARP_STATE_STABLE) && (ip_addr_cmp(dst_addr, &arp_table[i].ipaddr))) {
    5258:	7c8f      	ldrb	r7, [r1, #18]
    525a:	2f01      	cmp	r7, #1
    525c:	fa5f fc83 	uxtb.w	ip, r3
    5260:	d907      	bls.n	5272 <etharp_output+0xc6>
    5262:	684f      	ldr	r7, [r1, #4]
    5264:	682a      	ldr	r2, [r5, #0]
    5266:	42ba      	cmp	r2, r7
    5268:	d103      	bne.n	5272 <etharp_output+0xc6>
				ETHARP_SET_HINT(netif, i);
    526a:	f880 c0c8 	strb.w	ip, [r0, #200]	; 0xc8
				return etharp_output_to_arp_index(netif, q, i);
    526e:	4662      	mov	r2, ip
    5270:	e7e9      	b.n	5246 <etharp_output+0x9a>
		for (i = 0; i < ARP_TABLE_SIZE; i++) {
    5272:	3301      	adds	r3, #1
    5274:	2b0a      	cmp	r3, #10
    5276:	f101 0114 	add.w	r1, r1, #20
    527a:	d1ed      	bne.n	5258 <etharp_output+0xac>
		return etharp_query(netif, dst_addr, q);
    527c:	4b0c      	ldr	r3, [pc, #48]	; (52b0 <etharp_output+0x104>)
    527e:	4632      	mov	r2, r6
    5280:	4629      	mov	r1, r5
    5282:	4620      	mov	r0, r4
}
    5284:	b003      	add	sp, #12
    5286:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
		return etharp_query(netif, dst_addr, q);
    528a:	4718      	bx	r3
		dest = (struct eth_addr *)&ethbroadcast;
    528c:	4b09      	ldr	r3, [pc, #36]	; (52b4 <etharp_output+0x108>)
    528e:	e7b6      	b.n	51fe <etharp_output+0x52>
		return ERR_BUF;
    5290:	f06f 0001 	mvn.w	r0, #1
    5294:	e7b9      	b.n	520a <etharp_output+0x5e>
					return ERR_RTE;
    5296:	f06f 0003 	mvn.w	r0, #3
    529a:	e7b6      	b.n	520a <etharp_output+0x5e>
    529c:	0000308d 	.word	0x0000308d
    52a0:	00008a1b 	.word	0x00008a1b
    52a4:	00004f11 	.word	0x00004f11
    52a8:	20011004 	.word	0x20011004
    52ac:	0000504d 	.word	0x0000504d
    52b0:	000050a5 	.word	0x000050a5
    52b4:	0000b6da 	.word	0x0000b6da

000052b8 <ethernet_input>:
 *
 * @param p the recevied packet, p->payload pointing to the ethernet header
 * @param netif the network interface on which the packet was received
 */
err_t ethernet_input(struct pbuf *p, struct netif *netif)
{
    52b8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	u16_t           type;
#if LWIP_ARP || ETHARP_SUPPORT_VLAN
	s16_t ip_hdr_offset = SIZEOF_ETH_HDR;
#endif /* LWIP_ARP || ETHARP_SUPPORT_VLAN */

	if (p->len <= SIZEOF_ETH_HDR) {
    52bc:	8947      	ldrh	r7, [r0, #10]
    52be:	2f10      	cmp	r7, #16
{
    52c0:	b085      	sub	sp, #20
    52c2:	4606      	mov	r6, r0
    52c4:	460d      	mov	r5, r1
	if (p->len <= SIZEOF_ETH_HDR) {
    52c6:	d916      	bls.n	52f6 <ethernet_input+0x3e>
		ETHARP_STATS_INC(etharp.drop);
		goto free_and_return;
	}

	/* points to packet payload, which starts with an Ethernet header */
	ethhdr = (struct eth_hdr *)p->payload;
    52c8:	6844      	ldr	r4, [r0, #4]

#if LWIP_ARP_FILTER_NETIF
	netif = LWIP_ARP_FILTER_NETIF_FN(p, netif, htons(type));
#endif /* LWIP_ARP_FILTER_NETIF*/

	if (ethhdr->dest.addr[0] & 1) {
    52ca:	78a3      	ldrb	r3, [r4, #2]
	type = ethhdr->type;
    52cc:	f8b4 800e 	ldrh.w	r8, [r4, #14]
	if (ethhdr->dest.addr[0] & 1) {
    52d0:	07d8      	lsls	r0, r3, #31
    52d2:	d50a      	bpl.n	52ea <ethernet_input+0x32>
		/* this might be a multicast or broadcast packet */
		if (ethhdr->dest.addr[0] == LL_MULTICAST_ADDR_0) {
    52d4:	2b01      	cmp	r3, #1
    52d6:	d112      	bne.n	52fe <ethernet_input+0x46>
			if ((ethhdr->dest.addr[1] == LL_MULTICAST_ADDR_1) && (ethhdr->dest.addr[2] == LL_MULTICAST_ADDR_2)) {
    52d8:	78e3      	ldrb	r3, [r4, #3]
    52da:	b933      	cbnz	r3, 52ea <ethernet_input+0x32>
    52dc:	7923      	ldrb	r3, [r4, #4]
    52de:	2b5e      	cmp	r3, #94	; 0x5e
    52e0:	d103      	bne.n	52ea <ethernet_input+0x32>
				/* mark the pbuf as link-layer multicast */
				p->flags |= PBUF_FLAG_LLMCAST;
    52e2:	7b73      	ldrb	r3, [r6, #13]
    52e4:	f043 0310 	orr.w	r3, r3, #16
			}
		} else if (eth_addr_cmp(&ethhdr->dest, &ethbroadcast)) {
			/* mark the pbuf as link-layer broadcast */
			p->flags |= PBUF_FLAG_LLBCAST;
    52e8:	7373      	strb	r3, [r6, #13]
		}
	}

	switch (type) {
    52ea:	f1b8 0f08 	cmp.w	r8, #8
    52ee:	d011      	beq.n	5314 <ethernet_input+0x5c>
    52f0:	f5b8 6fc1 	cmp.w	r8, #1544	; 0x608
    52f4:	d021      	beq.n	533a <ethernet_input+0x82>
	/* This means the pbuf is freed or consumed,
	   so the caller doesn't have to free it again */
	return ERR_OK;

free_and_return:
	pbuf_free(p);
    52f6:	4b5f      	ldr	r3, [pc, #380]	; (5474 <ethernet_input+0x1bc>)
    52f8:	4630      	mov	r0, r6
    52fa:	4798      	blx	r3
	return ERR_OK;
    52fc:	e019      	b.n	5332 <ethernet_input+0x7a>
		} else if (eth_addr_cmp(&ethhdr->dest, &ethbroadcast)) {
    52fe:	495e      	ldr	r1, [pc, #376]	; (5478 <ethernet_input+0x1c0>)
    5300:	4b5e      	ldr	r3, [pc, #376]	; (547c <ethernet_input+0x1c4>)
    5302:	2206      	movs	r2, #6
    5304:	1ca0      	adds	r0, r4, #2
    5306:	4798      	blx	r3
    5308:	2800      	cmp	r0, #0
    530a:	d1ee      	bne.n	52ea <ethernet_input+0x32>
			p->flags |= PBUF_FLAG_LLBCAST;
    530c:	7b73      	ldrb	r3, [r6, #13]
    530e:	f043 0308 	orr.w	r3, r3, #8
    5312:	e7e9      	b.n	52e8 <ethernet_input+0x30>
		if (!(netif->flags & NETIF_FLAG_ETHARP)) {
    5314:	f895 3031 	ldrb.w	r3, [r5, #49]	; 0x31
    5318:	0699      	lsls	r1, r3, #26
    531a:	d5ec      	bpl.n	52f6 <ethernet_input+0x3e>
		if (pbuf_header(p, -ip_hdr_offset)) {
    531c:	4b58      	ldr	r3, [pc, #352]	; (5480 <ethernet_input+0x1c8>)
    531e:	f06f 010f 	mvn.w	r1, #15
    5322:	4630      	mov	r0, r6
    5324:	4798      	blx	r3
    5326:	2800      	cmp	r0, #0
    5328:	d1e5      	bne.n	52f6 <ethernet_input+0x3e>
			ip_input(p, netif);
    532a:	4b56      	ldr	r3, [pc, #344]	; (5484 <ethernet_input+0x1cc>)
    532c:	4629      	mov	r1, r5
    532e:	4630      	mov	r0, r6
    5330:	4798      	blx	r3
}
    5332:	2000      	movs	r0, #0
    5334:	b005      	add	sp, #20
    5336:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		if (!(netif->flags & NETIF_FLAG_ETHARP)) {
    533a:	f895 3031 	ldrb.w	r3, [r5, #49]	; 0x31
    533e:	069a      	lsls	r2, r3, #26
    5340:	d5d9      	bpl.n	52f6 <ethernet_input+0x3e>
	if (p->len < SIZEOF_ETHARP_PACKET) {
    5342:	2f2b      	cmp	r7, #43	; 0x2b
    5344:	f8df 912c 	ldr.w	r9, [pc, #300]	; 5474 <ethernet_input+0x1bc>
    5348:	d802      	bhi.n	5350 <ethernet_input+0x98>
	pbuf_free(p);
    534a:	4630      	mov	r0, r6
    534c:	47c8      	blx	r9
    534e:	e7f0      	b.n	5332 <ethernet_input+0x7a>
	if ((hdr->hwtype != PP_HTONS(HWTYPE_ETHERNET)) || (hdr->hwlen != ETHARP_HWADDR_LEN)
    5350:	8a23      	ldrh	r3, [r4, #16]
    5352:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
    5356:	d1f8      	bne.n	534a <ethernet_input+0x92>
    5358:	7d23      	ldrb	r3, [r4, #20]
    535a:	2b06      	cmp	r3, #6
    535c:	d1f5      	bne.n	534a <ethernet_input+0x92>
	    || (hdr->protolen != sizeof(ip_addr_t)) || (hdr->proto != PP_HTONS(ETHTYPE_IP))) {
    535e:	7d63      	ldrb	r3, [r4, #21]
    5360:	2b04      	cmp	r3, #4
    5362:	d1f2      	bne.n	534a <ethernet_input+0x92>
    5364:	8a63      	ldrh	r3, [r4, #18]
    5366:	2b08      	cmp	r3, #8
    5368:	d1ef      	bne.n	534a <ethernet_input+0x92>
	if (ip_addr_isany(&netif->ip_addr)) {
    536a:	686f      	ldr	r7, [r5, #4]
    536c:	f8d4 001e 	ldr.w	r0, [r4, #30]
    5370:	6aa3      	ldr	r3, [r4, #40]	; 0x28
	IPADDR2_COPY(&sipaddr, &hdr->sipaddr);
    5372:	9003      	str	r0, [sp, #12]
	etharp_update_arp_entry(netif, &sipaddr, &(hdr->shwaddr), for_us ? ETHARP_FLAG_TRY_HARD : ETHARP_FLAG_FIND_ONLY);
    5374:	f104 0818 	add.w	r8, r4, #24
	if (ip_addr_isany(&netif->ip_addr)) {
    5378:	2f00      	cmp	r7, #0
    537a:	d04f      	beq.n	541c <ethernet_input+0x164>
		for_us = (u8_t)ip_addr_cmp(&dipaddr, &(netif->ip_addr));
    537c:	1bdb      	subs	r3, r3, r7
    537e:	425f      	negs	r7, r3
    5380:	415f      	adcs	r7, r3
	etharp_update_arp_entry(netif, &sipaddr, &(hdr->shwaddr), for_us ? ETHARP_FLAG_TRY_HARD : ETHARP_FLAG_FIND_ONLY);
    5382:	f1c7 0302 	rsb	r3, r7, #2
    5386:	b2db      	uxtb	r3, r3
    5388:	9301      	str	r3, [sp, #4]
		etharp_arp_input(netif, (struct eth_addr *)(netif->hwaddr), p);
    538a:	f105 0a2b 	add.w	sl, r5, #43	; 0x2b
	if (ip_addr_isany(ipaddr) || ip_addr_isbroadcast(ipaddr, netif) || ip_addr_ismulticast(ipaddr)) {
    538e:	2800      	cmp	r0, #0
    5390:	d038      	beq.n	5404 <ethernet_input+0x14c>
    5392:	4a3d      	ldr	r2, [pc, #244]	; (5488 <ethernet_input+0x1d0>)
    5394:	4629      	mov	r1, r5
    5396:	4790      	blx	r2
    5398:	4683      	mov	fp, r0
    539a:	bb98      	cbnz	r0, 5404 <ethernet_input+0x14c>
    539c:	9a03      	ldr	r2, [sp, #12]
    539e:	f002 02f0 	and.w	r2, r2, #240	; 0xf0
    53a2:	2ae0      	cmp	r2, #224	; 0xe0
    53a4:	d02e      	beq.n	5404 <ethernet_input+0x14c>
	i = etharp_find_entry(ipaddr, flags);
    53a6:	9b01      	ldr	r3, [sp, #4]
    53a8:	a803      	add	r0, sp, #12
    53aa:	4619      	mov	r1, r3
    53ac:	4b37      	ldr	r3, [pc, #220]	; (548c <ethernet_input+0x1d4>)
    53ae:	4798      	blx	r3
	if (i < 0) {
    53b0:	2800      	cmp	r0, #0
    53b2:	db27      	blt.n	5404 <ethernet_input+0x14c>
		arp_table[i].state = ETHARP_STATE_STABLE;
    53b4:	4b36      	ldr	r3, [pc, #216]	; (5490 <ethernet_input+0x1d8>)
    53b6:	2214      	movs	r2, #20
    53b8:	fb02 fc00 	mul.w	ip, r2, r0
    53bc:	eb03 010c 	add.w	r1, r3, ip
    53c0:	f04f 0e02 	mov.w	lr, #2
    53c4:	f881 e012 	strb.w	lr, [r1, #18]
	ETHADDR32_COPY(&arp_table[i].ethaddr, ethaddr);
    53c8:	f04f 0e0c 	mov.w	lr, #12
	arp_table[i].netif = netif;
    53cc:	608d      	str	r5, [r1, #8]
	ETHADDR32_COPY(&arp_table[i].ethaddr, ethaddr);
    53ce:	fb12 e200 	smlabb	r2, r2, r0, lr
    53d2:	69a0      	ldr	r0, [r4, #24]
    53d4:	5098      	str	r0, [r3, r2]
    53d6:	eb03 0e02 	add.w	lr, r3, r2
    53da:	f8b8 2004 	ldrh.w	r2, [r8, #4]
    53de:	f8ae 2004 	strh.w	r2, [lr, #4]
	arp_table[i].ctime = 0;
    53e2:	f881 b013 	strb.w	fp, [r1, #19]
	if (arp_table[i].q != NULL) {
    53e6:	f853 100c 	ldr.w	r1, [r3, ip]
    53ea:	b159      	cbz	r1, 5404 <ethernet_input+0x14c>
		arp_table[i].q = NULL;
    53ec:	f843 b00c 	str.w	fp, [r3, ip]
		etharp_send_ip(netif, p, (struct eth_addr *)(netif->hwaddr), ethaddr);
    53f0:	4652      	mov	r2, sl
    53f2:	f8df b0a8 	ldr.w	fp, [pc, #168]	; 549c <ethernet_input+0x1e4>
    53f6:	9101      	str	r1, [sp, #4]
    53f8:	4643      	mov	r3, r8
    53fa:	4628      	mov	r0, r5
    53fc:	47d8      	blx	fp
		pbuf_free(p);
    53fe:	9901      	ldr	r1, [sp, #4]
    5400:	4608      	mov	r0, r1
    5402:	47c8      	blx	r9
	switch (hdr->opcode) {
    5404:	8ae3      	ldrh	r3, [r4, #22]
    5406:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
    540a:	d009      	beq.n	5420 <ethernet_input+0x168>
    540c:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
    5410:	d19b      	bne.n	534a <ethernet_input+0x92>
		dhcp_arp_reply(netif, &sipaddr);
    5412:	4b20      	ldr	r3, [pc, #128]	; (5494 <ethernet_input+0x1dc>)
    5414:	a903      	add	r1, sp, #12
    5416:	4628      	mov	r0, r5
    5418:	4798      	blx	r3
		break;
    541a:	e796      	b.n	534a <ethernet_input+0x92>
	etharp_update_arp_entry(netif, &sipaddr, &(hdr->shwaddr), for_us ? ETHARP_FLAG_TRY_HARD : ETHARP_FLAG_FIND_ONLY);
    541c:	2302      	movs	r3, #2
    541e:	e7b3      	b.n	5388 <ethernet_input+0xd0>
		if (for_us) {
    5420:	2f00      	cmp	r7, #0
    5422:	d092      	beq.n	534a <ethernet_input+0x92>
			hdr->opcode = htons(ARP_REPLY);
    5424:	4b1c      	ldr	r3, [pc, #112]	; (5498 <ethernet_input+0x1e0>)
    5426:	2002      	movs	r0, #2
    5428:	4798      	blx	r3
			IPADDR2_COPY(&hdr->dipaddr, &hdr->sipaddr);
    542a:	f8d4 301e 	ldr.w	r3, [r4, #30]
			hdr->opcode = htons(ARP_REPLY);
    542e:	82e0      	strh	r0, [r4, #22]
			IPADDR2_COPY(&hdr->dipaddr, &hdr->sipaddr);
    5430:	62a3      	str	r3, [r4, #40]	; 0x28
			IPADDR2_COPY(&hdr->sipaddr, &netif->ip_addr);
    5432:	686b      	ldr	r3, [r5, #4]
    5434:	f8c4 301e 	str.w	r3, [r4, #30]
			ETHADDR16_COPY(&hdr->dhwaddr, &hdr->shwaddr);
    5438:	69a3      	ldr	r3, [r4, #24]
    543a:	f8c4 3022 	str.w	r3, [r4, #34]	; 0x22
    543e:	f8b8 3004 	ldrh.w	r3, [r8, #4]
    5442:	84e3      	strh	r3, [r4, #38]	; 0x26
			ETHADDR16_COPY(&ethhdr->dest, &hdr->shwaddr);
    5444:	69a3      	ldr	r3, [r4, #24]
    5446:	f8c4 3002 	str.w	r3, [r4, #2]
    544a:	f8b8 3004 	ldrh.w	r3, [r8, #4]
    544e:	80e3      	strh	r3, [r4, #6]
			ETHADDR16_COPY(&hdr->shwaddr, ethaddr);
    5450:	f8d5 302b 	ldr.w	r3, [r5, #43]	; 0x2b
    5454:	61a3      	str	r3, [r4, #24]
    5456:	f8ba 3004 	ldrh.w	r3, [sl, #4]
    545a:	f8a8 3004 	strh.w	r3, [r8, #4]
			ETHADDR16_COPY(&ethhdr->src, ethaddr);
    545e:	f8d5 302b 	ldr.w	r3, [r5, #43]	; 0x2b
    5462:	60a3      	str	r3, [r4, #8]
    5464:	f8ba 3004 	ldrh.w	r3, [sl, #4]
    5468:	81a3      	strh	r3, [r4, #12]
			netif->linkoutput(netif, p);
    546a:	69ab      	ldr	r3, [r5, #24]
    546c:	4631      	mov	r1, r6
    546e:	4628      	mov	r0, r5
    5470:	4798      	blx	r3
    5472:	e76a      	b.n	534a <ethernet_input+0x92>
    5474:	000030e5 	.word	0x000030e5
    5478:	0000b6da 	.word	0x0000b6da
    547c:	0000a329 	.word	0x0000a329
    5480:	0000308d 	.word	0x0000308d
    5484:	00006395 	.word	0x00006395
    5488:	00008a1b 	.word	0x00008a1b
    548c:	00004e3d 	.word	0x00004e3d
    5490:	20011004 	.word	0x20011004
    5494:	00005ec9 	.word	0x00005ec9
    5498:	00000d65 	.word	0x00000d65
    549c:	00004f11 	.word	0x00004f11

000054a0 <dhcp_set_state>:
 *
 * If the state changed, reset the number of tries.
 */
static void dhcp_set_state(struct dhcp *dhcp, u8_t new_state)
{
	if (new_state != dhcp->state) {
    54a0:	7b03      	ldrb	r3, [r0, #12]
    54a2:	428b      	cmp	r3, r1
		dhcp->state           = new_state;
		dhcp->tries           = 0;
    54a4:	bf1f      	itttt	ne
    54a6:	2300      	movne	r3, #0
		dhcp->state           = new_state;
    54a8:	7301      	strbne	r1, [r0, #12]
		dhcp->tries           = 0;
    54aa:	7343      	strbne	r3, [r0, #13]
		dhcp->request_timeout = 0;
    54ac:	8343      	strhne	r3, [r0, #26]
	}
}
    54ae:	4770      	bx	lr

000054b0 <dhcp_option>:
 */
static void dhcp_option(struct dhcp *dhcp, u8_t option_type, u8_t option_len)
{
	LWIP_ASSERT("dhcp_option: dhcp->options_out_len + 2 + option_len <= DHCP_OPTIONS_LEN",
	            dhcp->options_out_len + 2U + option_len <= DHCP_OPTIONS_LEN);
	dhcp->msg_out->options[dhcp->options_out_len++] = option_type;
    54b0:	8b03      	ldrh	r3, [r0, #24]
{
    54b2:	b530      	push	{r4, r5, lr}
	dhcp->msg_out->options[dhcp->options_out_len++] = option_type;
    54b4:	6944      	ldr	r4, [r0, #20]
    54b6:	18e5      	adds	r5, r4, r3
    54b8:	f885 10f0 	strb.w	r1, [r5, #240]	; 0xf0
	dhcp->msg_out->options[dhcp->options_out_len++] = option_len;
    54bc:	1c99      	adds	r1, r3, #2
	dhcp->msg_out->options[dhcp->options_out_len++] = option_type;
    54be:	3301      	adds	r3, #1
	dhcp->msg_out->options[dhcp->options_out_len++] = option_len;
    54c0:	fa14 f383 	uxtah	r3, r4, r3
    54c4:	8301      	strh	r1, [r0, #24]
    54c6:	f883 20f0 	strb.w	r2, [r3, #240]	; 0xf0
}
    54ca:	bd30      	pop	{r4, r5, pc}

000054cc <dhcp_option_byte>:
 *
 */
static void dhcp_option_byte(struct dhcp *dhcp, u8_t value)
{
	LWIP_ASSERT("dhcp_option_byte: dhcp->options_out_len < DHCP_OPTIONS_LEN", dhcp->options_out_len < DHCP_OPTIONS_LEN);
	dhcp->msg_out->options[dhcp->options_out_len++] = value;
    54cc:	8b02      	ldrh	r2, [r0, #24]
    54ce:	6943      	ldr	r3, [r0, #20]
{
    54d0:	b510      	push	{r4, lr}
	dhcp->msg_out->options[dhcp->options_out_len++] = value;
    54d2:	4413      	add	r3, r2
    54d4:	1c54      	adds	r4, r2, #1
    54d6:	8304      	strh	r4, [r0, #24]
    54d8:	f883 10f0 	strb.w	r1, [r3, #240]	; 0xf0
}
    54dc:	bd10      	pop	{r4, pc}

000054de <dhcp_option_short>:

static void dhcp_option_short(struct dhcp *dhcp, u16_t value)
{
	LWIP_ASSERT("dhcp_option_short: dhcp->options_out_len + 2 <= DHCP_OPTIONS_LEN",
	            dhcp->options_out_len + 2U <= DHCP_OPTIONS_LEN);
	dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t)((value & 0xff00U) >> 8);
    54de:	8b03      	ldrh	r3, [r0, #24]
    54e0:	6942      	ldr	r2, [r0, #20]
{
    54e2:	b530      	push	{r4, r5, lr}
	dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t)((value & 0xff00U) >> 8);
    54e4:	18d4      	adds	r4, r2, r3
    54e6:	0a0d      	lsrs	r5, r1, #8
    54e8:	f884 50f0 	strb.w	r5, [r4, #240]	; 0xf0
	dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t)(value & 0x00ffU);
    54ec:	1c9c      	adds	r4, r3, #2
	dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t)((value & 0xff00U) >> 8);
    54ee:	3301      	adds	r3, #1
	dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t)(value & 0x00ffU);
    54f0:	fa12 f383 	uxtah	r3, r2, r3
    54f4:	8304      	strh	r4, [r0, #24]
    54f6:	f883 10f0 	strb.w	r1, [r3, #240]	; 0xf0
}
    54fa:	bd30      	pop	{r4, r5, pc}

000054fc <dhcp_option_long>:

static void dhcp_option_long(struct dhcp *dhcp, u32_t value)
{
	LWIP_ASSERT("dhcp_option_long: dhcp->options_out_len + 4 <= DHCP_OPTIONS_LEN",
	            dhcp->options_out_len + 4U <= DHCP_OPTIONS_LEN);
	dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t)((value & 0xff000000UL) >> 24);
    54fc:	8b03      	ldrh	r3, [r0, #24]
    54fe:	6942      	ldr	r2, [r0, #20]
{
    5500:	b530      	push	{r4, r5, lr}
	dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t)((value & 0xff000000UL) >> 24);
    5502:	18d4      	adds	r4, r2, r3
    5504:	0e0d      	lsrs	r5, r1, #24
    5506:	f884 50f0 	strb.w	r5, [r4, #240]	; 0xf0
    550a:	1c5c      	adds	r4, r3, #1
	dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t)((value & 0x00ff0000UL) >> 16);
    550c:	fa12 f484 	uxtah	r4, r2, r4
    5510:	0c0d      	lsrs	r5, r1, #16
    5512:	f884 50f0 	strb.w	r5, [r4, #240]	; 0xf0
    5516:	1c9c      	adds	r4, r3, #2
	dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t)((value & 0x0000ff00UL) >> 8);
    5518:	fa12 f484 	uxtah	r4, r2, r4
    551c:	0a0d      	lsrs	r5, r1, #8
    551e:	f884 50f0 	strb.w	r5, [r4, #240]	; 0xf0
	dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t)((value & 0x000000ffUL));
    5522:	1d1c      	adds	r4, r3, #4
	dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t)((value & 0x0000ff00UL) >> 8);
    5524:	3303      	adds	r3, #3
	dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t)((value & 0x000000ffUL));
    5526:	fa12 f383 	uxtah	r3, r2, r3
    552a:	8304      	strh	r4, [r0, #24]
    552c:	f883 10f0 	strb.w	r1, [r3, #240]	; 0xf0
}
    5530:	bd30      	pop	{r4, r5, pc}

00005532 <dhcp_option_trailer>:
 * necessary, up to three padding bytes.
 *
 * @param dhcp DHCP state structure
 */
static void dhcp_option_trailer(struct dhcp *dhcp)
{
    5532:	b510      	push	{r4, lr}
	LWIP_ERROR("dhcp_option_trailer: dhcp != NULL", (dhcp != NULL), return;);
    5534:	b900      	cbnz	r0, 5538 <dhcp_option_trailer+0x6>
    5536:	e7fe      	b.n	5536 <dhcp_option_trailer+0x4>
	LWIP_ASSERT("dhcp_option_trailer: dhcp->msg_out != NULL\n", dhcp->msg_out != NULL);
	LWIP_ASSERT("dhcp_option_trailer: dhcp->options_out_len < DHCP_OPTIONS_LEN\n",
	            dhcp->options_out_len < DHCP_OPTIONS_LEN);
	dhcp->msg_out->options[dhcp->options_out_len++] = DHCP_OPTION_END;
    5538:	8b03      	ldrh	r3, [r0, #24]
    553a:	6942      	ldr	r2, [r0, #20]
    553c:	1c59      	adds	r1, r3, #1
    553e:	4413      	add	r3, r2
    5540:	8301      	strh	r1, [r0, #24]
    5542:	21ff      	movs	r1, #255	; 0xff
    5544:	f883 10f0 	strb.w	r1, [r3, #240]	; 0xf0
	/* packet is too small, or not 4 byte aligned? */
	while (((dhcp->options_out_len < DHCP_MIN_OPTIONS_LEN) || (dhcp->options_out_len & 3))
	       && (dhcp->options_out_len < DHCP_OPTIONS_LEN)) {
		/* add a fill/padding byte */
		dhcp->msg_out->options[dhcp->options_out_len++] = 0;
    5548:	2100      	movs	r1, #0
	while (((dhcp->options_out_len < DHCP_MIN_OPTIONS_LEN) || (dhcp->options_out_len & 3))
    554a:	8b03      	ldrh	r3, [r0, #24]
    554c:	2b43      	cmp	r3, #67	; 0x43
    554e:	d900      	bls.n	5552 <dhcp_option_trailer+0x20>
	}
}
    5550:	bd10      	pop	{r4, pc}
		dhcp->msg_out->options[dhcp->options_out_len++] = 0;
    5552:	1c5c      	adds	r4, r3, #1
    5554:	4413      	add	r3, r2
    5556:	8304      	strh	r4, [r0, #24]
    5558:	f883 10f0 	strb.w	r1, [r3, #240]	; 0xf0
    555c:	e7f5      	b.n	554a <dhcp_option_trailer+0x18>
	...

00005560 <dhcp_delete_msg>:
{
    5560:	b510      	push	{r4, lr}
	LWIP_ERROR("dhcp_delete_msg: dhcp != NULL", (dhcp != NULL), return;);
    5562:	4604      	mov	r4, r0
    5564:	b900      	cbnz	r0, 5568 <dhcp_delete_msg+0x8>
    5566:	e7fe      	b.n	5566 <dhcp_delete_msg+0x6>
	if (dhcp->p_out != NULL) {
    5568:	6900      	ldr	r0, [r0, #16]
    556a:	b108      	cbz	r0, 5570 <dhcp_delete_msg+0x10>
		pbuf_free(dhcp->p_out);
    556c:	4b02      	ldr	r3, [pc, #8]	; (5578 <dhcp_delete_msg+0x18>)
    556e:	4798      	blx	r3
	dhcp->p_out   = NULL;
    5570:	2300      	movs	r3, #0
	dhcp->msg_out = NULL;
    5572:	e9c4 3304 	strd	r3, r3, [r4, #16]
}
    5576:	bd10      	pop	{r4, pc}
    5578:	000030e5 	.word	0x000030e5

0000557c <dhcp_check>:
{
    557c:	b538      	push	{r3, r4, r5, lr}
	struct dhcp *dhcp = netif->dhcp;
    557e:	6a44      	ldr	r4, [r0, #36]	; 0x24
	dhcp_set_state(dhcp, DHCP_CHECKING);
    5580:	4b08      	ldr	r3, [pc, #32]	; (55a4 <dhcp_check+0x28>)
{
    5582:	4605      	mov	r5, r0
	dhcp_set_state(dhcp, DHCP_CHECKING);
    5584:	2108      	movs	r1, #8
    5586:	4620      	mov	r0, r4
    5588:	4798      	blx	r3
	result = etharp_query(netif, &dhcp->offered_ip_addr, NULL);
    558a:	2200      	movs	r2, #0
    558c:	4b06      	ldr	r3, [pc, #24]	; (55a8 <dhcp_check+0x2c>)
    558e:	f104 0124 	add.w	r1, r4, #36	; 0x24
    5592:	4628      	mov	r0, r5
    5594:	4798      	blx	r3
	dhcp->tries++;
    5596:	7b63      	ldrb	r3, [r4, #13]
    5598:	3301      	adds	r3, #1
    559a:	7363      	strb	r3, [r4, #13]
	dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
    559c:	2301      	movs	r3, #1
    559e:	8363      	strh	r3, [r4, #26]
}
    55a0:	bd38      	pop	{r3, r4, r5, pc}
    55a2:	bf00      	nop
    55a4:	000054a1 	.word	0x000054a1
    55a8:	000050a5 	.word	0x000050a5

000055ac <dhcp_bind>:
{
    55ac:	b51f      	push	{r0, r1, r2, r3, r4, lr}
	LWIP_ERROR("dhcp_bind: netif != NULL", (netif != NULL), return;);
    55ae:	b900      	cbnz	r0, 55b2 <dhcp_bind+0x6>
    55b0:	e7fe      	b.n	55b0 <dhcp_bind+0x4>
	dhcp = netif->dhcp;
    55b2:	6a44      	ldr	r4, [r0, #36]	; 0x24
	LWIP_ERROR("dhcp_bind: dhcp != NULL", (dhcp != NULL), return;);
    55b4:	b904      	cbnz	r4, 55b8 <dhcp_bind+0xc>
    55b6:	e7fe      	b.n	55b6 <dhcp_bind+0xa>
	if (dhcp->offered_t1_renew != 0xffffffffUL) {
    55b8:	6b63      	ldr	r3, [r4, #52]	; 0x34
    55ba:	1c59      	adds	r1, r3, #1
    55bc:	d00c      	beq.n	55d8 <dhcp_bind+0x2c>
		timeout = (dhcp->offered_t1_renew + DHCP_COARSE_TIMER_SECS / 2) / DHCP_COARSE_TIMER_SECS;
    55be:	331e      	adds	r3, #30
		if (timeout > 0xffff) {
    55c0:	f5b3 1f70 	cmp.w	r3, #3932160	; 0x3c0000
			timeout = 0xffff;
    55c4:	bf2e      	itee	cs
    55c6:	f64f 73ff 	movwcs	r3, #65535	; 0xffff
		timeout = (dhcp->offered_t1_renew + DHCP_COARSE_TIMER_SECS / 2) / DHCP_COARSE_TIMER_SECS;
    55ca:	223c      	movcc	r2, #60	; 0x3c
    55cc:	fbb3 f3f2 	udivcc	r3, r3, r2
		dhcp->t1_timeout = (u16_t)timeout;
    55d0:	b29a      	uxth	r2, r3
		if (dhcp->t1_timeout == 0) {
    55d2:	2b00      	cmp	r3, #0
    55d4:	d03b      	beq.n	564e <dhcp_bind+0xa2>
		dhcp->t1_timeout = (u16_t)timeout;
    55d6:	83a2      	strh	r2, [r4, #28]
	if (dhcp->offered_t2_rebind != 0xffffffffUL) {
    55d8:	6ba3      	ldr	r3, [r4, #56]	; 0x38
    55da:	1c5a      	adds	r2, r3, #1
    55dc:	d00c      	beq.n	55f8 <dhcp_bind+0x4c>
		timeout = (dhcp->offered_t2_rebind + DHCP_COARSE_TIMER_SECS / 2) / DHCP_COARSE_TIMER_SECS;
    55de:	331e      	adds	r3, #30
		if (timeout > 0xffff) {
    55e0:	f5b3 1f70 	cmp.w	r3, #3932160	; 0x3c0000
			timeout = 0xffff;
    55e4:	bf2e      	itee	cs
    55e6:	f64f 73ff 	movwcs	r3, #65535	; 0xffff
		timeout = (dhcp->offered_t2_rebind + DHCP_COARSE_TIMER_SECS / 2) / DHCP_COARSE_TIMER_SECS;
    55ea:	223c      	movcc	r2, #60	; 0x3c
    55ec:	fbb3 f3f2 	udivcc	r3, r3, r2
		dhcp->t2_timeout = (u16_t)timeout;
    55f0:	b29a      	uxth	r2, r3
		if (dhcp->t2_timeout == 0) {
    55f2:	2b00      	cmp	r3, #0
    55f4:	d02e      	beq.n	5654 <dhcp_bind+0xa8>
		dhcp->t2_timeout = (u16_t)timeout;
    55f6:	83e2      	strh	r2, [r4, #30]
	if ((dhcp->t1_timeout >= dhcp->t2_timeout) && (dhcp->t2_timeout > 0)) {
    55f8:	8be3      	ldrh	r3, [r4, #30]
    55fa:	8ba2      	ldrh	r2, [r4, #28]
    55fc:	429a      	cmp	r2, r3
    55fe:	d302      	bcc.n	5606 <dhcp_bind+0x5a>
    5600:	b10b      	cbz	r3, 5606 <dhcp_bind+0x5a>
		dhcp->t1_timeout = 0;
    5602:	2300      	movs	r3, #0
    5604:	83a3      	strh	r3, [r4, #28]
	if (dhcp->subnet_mask_given) {
    5606:	7ba3      	ldrb	r3, [r4, #14]
    5608:	2b00      	cmp	r3, #0
    560a:	d026      	beq.n	565a <dhcp_bind+0xae>
		ip_addr_copy(sn_mask, dhcp->offered_sn_mask);
    560c:	6aa3      	ldr	r3, [r4, #40]	; 0x28
			ip4_addr_set_u32(&sn_mask, PP_HTONL(0xffff0000UL));
    560e:	9302      	str	r3, [sp, #8]
	ip_addr_copy(gw_addr, dhcp->offered_gw_addr);
    5610:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
    5612:	9303      	str	r3, [sp, #12]
	if (ip_addr_isany(&gw_addr)) {
    5614:	b92b      	cbnz	r3, 5622 <dhcp_bind+0x76>
		ip_addr_get_network(&gw_addr, &dhcp->offered_ip_addr, &sn_mask);
    5616:	6a63      	ldr	r3, [r4, #36]	; 0x24
    5618:	9a02      	ldr	r2, [sp, #8]
    561a:	4013      	ands	r3, r2
		ip4_addr_set_u32(&gw_addr, ip4_addr_get_u32(&gw_addr) | PP_HTONL(0x00000001UL));
    561c:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
    5620:	9303      	str	r3, [sp, #12]
	netif_set_ipaddr(netif, &dhcp->offered_ip_addr);
    5622:	f104 0124 	add.w	r1, r4, #36	; 0x24
    5626:	4b14      	ldr	r3, [pc, #80]	; (5678 <dhcp_bind+0xcc>)
    5628:	9001      	str	r0, [sp, #4]
    562a:	4798      	blx	r3
	netif_set_netmask(netif, &sn_mask);
    562c:	9801      	ldr	r0, [sp, #4]
    562e:	4b13      	ldr	r3, [pc, #76]	; (567c <dhcp_bind+0xd0>)
    5630:	a902      	add	r1, sp, #8
    5632:	4798      	blx	r3
	netif_set_gw(netif, &gw_addr);
    5634:	a903      	add	r1, sp, #12
    5636:	9801      	ldr	r0, [sp, #4]
    5638:	4b11      	ldr	r3, [pc, #68]	; (5680 <dhcp_bind+0xd4>)
    563a:	4798      	blx	r3
	netif_set_up(netif);
    563c:	9801      	ldr	r0, [sp, #4]
    563e:	4b11      	ldr	r3, [pc, #68]	; (5684 <dhcp_bind+0xd8>)
    5640:	4798      	blx	r3
	dhcp_set_state(dhcp, DHCP_BOUND);
    5642:	4b11      	ldr	r3, [pc, #68]	; (5688 <dhcp_bind+0xdc>)
    5644:	210a      	movs	r1, #10
    5646:	4620      	mov	r0, r4
    5648:	4798      	blx	r3
}
    564a:	b004      	add	sp, #16
    564c:	bd10      	pop	{r4, pc}
			dhcp->t1_timeout = 1;
    564e:	2301      	movs	r3, #1
    5650:	83a3      	strh	r3, [r4, #28]
    5652:	e7c1      	b.n	55d8 <dhcp_bind+0x2c>
			dhcp->t2_timeout = 1;
    5654:	2301      	movs	r3, #1
    5656:	83e3      	strh	r3, [r4, #30]
    5658:	e7ce      	b.n	55f8 <dhcp_bind+0x4c>
		if (first_octet <= 127) {
    565a:	f994 2024 	ldrsb.w	r2, [r4, #36]	; 0x24
		u8_t first_octet = ip4_addr1(&dhcp->offered_ip_addr);
    565e:	f894 3024 	ldrb.w	r3, [r4, #36]	; 0x24
		if (first_octet <= 127) {
    5662:	2a00      	cmp	r2, #0
    5664:	db01      	blt.n	566a <dhcp_bind+0xbe>
			ip4_addr_set_u32(&sn_mask, PP_HTONL(0xff000000UL));
    5666:	23ff      	movs	r3, #255	; 0xff
    5668:	e7d1      	b.n	560e <dhcp_bind+0x62>
		} else if (first_octet >= 192) {
    566a:	2bbf      	cmp	r3, #191	; 0xbf
			ip4_addr_set_u32(&sn_mask, PP_HTONL(0xffffff00UL));
    566c:	bf8c      	ite	hi
    566e:	f06f 437f 	mvnhi.w	r3, #4278190080	; 0xff000000
			ip4_addr_set_u32(&sn_mask, PP_HTONL(0xffff0000UL));
    5672:	f64f 73ff 	movwls	r3, #65535	; 0xffff
    5676:	e7ca      	b.n	560e <dhcp_bind+0x62>
    5678:	00009fb5 	.word	0x00009fb5
    567c:	0000a081 	.word	0x0000a081
    5680:	0000a079 	.word	0x0000a079
    5684:	0000a095 	.word	0x0000a095
    5688:	000054a1 	.word	0x000054a1

0000568c <dhcp_create_msg>:
{
    568c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    5690:	460d      	mov	r5, r1
    5692:	4690      	mov	r8, r2
	LWIP_ERROR("dhcp_create_msg: netif != NULL", (netif != NULL), return ERR_ARG;);
    5694:	4606      	mov	r6, r0
    5696:	b900      	cbnz	r0, 569a <dhcp_create_msg+0xe>
    5698:	e7fe      	b.n	5698 <dhcp_create_msg+0xc>
	LWIP_ERROR("dhcp_create_msg: dhcp != NULL", (dhcp != NULL), return ERR_VAL;);
    569a:	b901      	cbnz	r1, 569e <dhcp_create_msg+0x12>
    569c:	e7fe      	b.n	569c <dhcp_create_msg+0x10>
	dhcp->p_out = pbuf_alloc(PBUF_TRANSPORT, sizeof(struct dhcp_msg), PBUF_RAM);
    569e:	2200      	movs	r2, #0
    56a0:	4b40      	ldr	r3, [pc, #256]	; (57a4 <dhcp_create_msg+0x118>)
    56a2:	f44f 719a 	mov.w	r1, #308	; 0x134
    56a6:	4610      	mov	r0, r2
    56a8:	4798      	blx	r3
    56aa:	6128      	str	r0, [r5, #16]
	if (dhcp->p_out == NULL) {
    56ac:	2800      	cmp	r0, #0
    56ae:	d075      	beq.n	579c <dhcp_create_msg+0x110>
	if (dhcp->tries == 0) {
    56b0:	7b6a      	ldrb	r2, [r5, #13]
    56b2:	4b3d      	ldr	r3, [pc, #244]	; (57a8 <dhcp_create_msg+0x11c>)
    56b4:	b912      	cbnz	r2, 56bc <dhcp_create_msg+0x30>
		xid++;
    56b6:	681a      	ldr	r2, [r3, #0]
    56b8:	3201      	adds	r2, #1
    56ba:	601a      	str	r2, [r3, #0]
	dhcp->msg_out = (struct dhcp_msg *)dhcp->p_out->payload;
    56bc:	6844      	ldr	r4, [r0, #4]
	dhcp->xid = xid;
    56be:	681b      	ldr	r3, [r3, #0]
    56c0:	602b      	str	r3, [r5, #0]
	dhcp->msg_out->op = DHCP_BOOTREQUEST;
    56c2:	2201      	movs	r2, #1
	dhcp->msg_out = (struct dhcp_msg *)dhcp->p_out->payload;
    56c4:	616c      	str	r4, [r5, #20]
	dhcp->msg_out->op = DHCP_BOOTREQUEST;
    56c6:	7022      	strb	r2, [r4, #0]
	dhcp->msg_out->htype = DHCP_HTYPE_ETH;
    56c8:	7062      	strb	r2, [r4, #1]
	dhcp->msg_out->hops  = 0;
    56ca:	2700      	movs	r7, #0
	dhcp->msg_out->hlen  = netif->hwaddr_len;
    56cc:	f896 202a 	ldrb.w	r2, [r6, #42]	; 0x2a
    56d0:	70a2      	strb	r2, [r4, #2]
	dhcp->msg_out->hops  = 0;
    56d2:	70e7      	strb	r7, [r4, #3]
	dhcp->msg_out->xid   = htonl(dhcp->xid);
    56d4:	4618      	mov	r0, r3
    56d6:	4b35      	ldr	r3, [pc, #212]	; (57ac <dhcp_create_msg+0x120>)
    56d8:	4798      	blx	r3
    56da:	6060      	str	r0, [r4, #4]
	dhcp->msg_out->secs  = 0;
    56dc:	696c      	ldr	r4, [r5, #20]
	if ((message_type == DHCP_INFORM) || (message_type == DHCP_DECLINE)
    56de:	f1b8 0f08 	cmp.w	r8, #8
	dhcp->msg_out->secs  = 0;
    56e2:	7227      	strb	r7, [r4, #8]
    56e4:	7267      	strb	r7, [r4, #9]
	dhcp->msg_out->flags = 0;
    56e6:	72a7      	strb	r7, [r4, #10]
    56e8:	72e7      	strb	r7, [r4, #11]
	ip_addr_set_zero(&dhcp->msg_out->ciaddr);
    56ea:	7327      	strb	r7, [r4, #12]
    56ec:	7367      	strb	r7, [r4, #13]
    56ee:	73a7      	strb	r7, [r4, #14]
    56f0:	73e7      	strb	r7, [r4, #15]
	if ((message_type == DHCP_INFORM) || (message_type == DHCP_DECLINE)
    56f2:	d009      	beq.n	5708 <dhcp_create_msg+0x7c>
    56f4:	f1b8 0f04 	cmp.w	r8, #4
    56f8:	d006      	beq.n	5708 <dhcp_create_msg+0x7c>
	    || ((message_type == DHCP_REQUEST) && /* DHCP_BOUND not used for sending! */
    56fa:	f1b8 0f03 	cmp.w	r8, #3
    56fe:	d105      	bne.n	570c <dhcp_create_msg+0x80>
	        ((dhcp->state == DHCP_RENEWING) || dhcp->state == DHCP_REBINDING))) {
    5700:	7b2b      	ldrb	r3, [r5, #12]
	    || ((message_type == DHCP_REQUEST) && /* DHCP_BOUND not used for sending! */
    5702:	3b04      	subs	r3, #4
    5704:	2b01      	cmp	r3, #1
    5706:	d801      	bhi.n	570c <dhcp_create_msg+0x80>
		ip_addr_copy(dhcp->msg_out->ciaddr, netif->ip_addr);
    5708:	6873      	ldr	r3, [r6, #4]
    570a:	60e3      	str	r3, [r4, #12]
	ip_addr_set_zero(&dhcp->msg_out->yiaddr);
    570c:	2300      	movs	r3, #0
    570e:	7423      	strb	r3, [r4, #16]
    5710:	7463      	strb	r3, [r4, #17]
    5712:	74a3      	strb	r3, [r4, #18]
    5714:	74e3      	strb	r3, [r4, #19]
	ip_addr_set_zero(&dhcp->msg_out->siaddr);
    5716:	7523      	strb	r3, [r4, #20]
    5718:	7563      	strb	r3, [r4, #21]
    571a:	75a3      	strb	r3, [r4, #22]
    571c:	75e3      	strb	r3, [r4, #23]
	ip_addr_set_zero(&dhcp->msg_out->giaddr);
    571e:	7623      	strb	r3, [r4, #24]
    5720:	7663      	strb	r3, [r4, #25]
    5722:	76a3      	strb	r3, [r4, #26]
    5724:	76e3      	strb	r3, [r4, #27]
		dhcp->msg_out->chaddr[i] = (i < netif->hwaddr_len) ? netif->hwaddr[i] : 0 /* pad byte*/;
    5726:	f896 002a 	ldrb.w	r0, [r6, #42]	; 0x2a
    572a:	f104 021c 	add.w	r2, r4, #28
    572e:	362b      	adds	r6, #43	; 0x2b
    5730:	b299      	uxth	r1, r3
    5732:	4288      	cmp	r0, r1
    5734:	bf88      	it	hi
    5736:	5cf1      	ldrbhi	r1, [r6, r3]
	for (i = 0; i < DHCP_CHADDR_LEN; i++) {
    5738:	f103 0301 	add.w	r3, r3, #1
		dhcp->msg_out->chaddr[i] = (i < netif->hwaddr_len) ? netif->hwaddr[i] : 0 /* pad byte*/;
    573c:	bf98      	it	ls
    573e:	2100      	movls	r1, #0
	for (i = 0; i < DHCP_CHADDR_LEN; i++) {
    5740:	2b10      	cmp	r3, #16
		dhcp->msg_out->chaddr[i] = (i < netif->hwaddr_len) ? netif->hwaddr[i] : 0 /* pad byte*/;
    5742:	f802 1b01 	strb.w	r1, [r2], #1
	for (i = 0; i < DHCP_CHADDR_LEN; i++) {
    5746:	d1f3      	bne.n	5730 <dhcp_create_msg+0xa4>
		dhcp->msg_out->sname[i] = 0;
    5748:	4e19      	ldr	r6, [pc, #100]	; (57b0 <dhcp_create_msg+0x124>)
    574a:	2240      	movs	r2, #64	; 0x40
    574c:	2100      	movs	r1, #0
    574e:	f104 002c 	add.w	r0, r4, #44	; 0x2c
    5752:	47b0      	blx	r6
		dhcp->msg_out->file[i] = 0;
    5754:	2280      	movs	r2, #128	; 0x80
    5756:	2100      	movs	r1, #0
    5758:	f104 006c 	add.w	r0, r4, #108	; 0x6c
    575c:	47b0      	blx	r6
	dhcp->msg_out->cookie = PP_HTONL(DHCP_MAGIC_COOKIE);
    575e:	f06f 017d 	mvn.w	r1, #125	; 0x7d
    5762:	f884 10ed 	strb.w	r1, [r4, #237]	; 0xed
    5766:	2263      	movs	r2, #99	; 0x63
    5768:	2300      	movs	r3, #0
    576a:	2153      	movs	r1, #83	; 0x53
    576c:	f884 20ec 	strb.w	r2, [r4, #236]	; 0xec
    5770:	f884 10ee 	strb.w	r1, [r4, #238]	; 0xee
    5774:	f884 20ef 	strb.w	r2, [r4, #239]	; 0xef
	dhcp->options_out_len = 0;
    5778:	832b      	strh	r3, [r5, #24]
	for (i = 0; i < DHCP_OPTIONS_LEN; i++) {
    577a:	34f0      	adds	r4, #240	; 0xf0
		dhcp->msg_out->options[i] = (u8_t)i; /* for debugging only, no matter if truncated */
    577c:	f804 3b01 	strb.w	r3, [r4], #1
	for (i = 0; i < DHCP_OPTIONS_LEN; i++) {
    5780:	3301      	adds	r3, #1
    5782:	2b44      	cmp	r3, #68	; 0x44
    5784:	d1fa      	bne.n	577c <dhcp_create_msg+0xf0>
	dhcp_option(dhcp, DHCP_OPTION_MESSAGE_TYPE, DHCP_OPTION_MESSAGE_TYPE_LEN);
    5786:	4628      	mov	r0, r5
    5788:	4b0a      	ldr	r3, [pc, #40]	; (57b4 <dhcp_create_msg+0x128>)
    578a:	2201      	movs	r2, #1
    578c:	2135      	movs	r1, #53	; 0x35
    578e:	4798      	blx	r3
	dhcp_option_byte(dhcp, message_type);
    5790:	4b09      	ldr	r3, [pc, #36]	; (57b8 <dhcp_create_msg+0x12c>)
    5792:	4641      	mov	r1, r8
    5794:	4798      	blx	r3
	return ERR_OK;
    5796:	2000      	movs	r0, #0
}
    5798:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		return ERR_MEM;
    579c:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    57a0:	e7fa      	b.n	5798 <dhcp_create_msg+0x10c>
    57a2:	bf00      	nop
    57a4:	0000313d 	.word	0x0000313d
    57a8:	20000008 	.word	0x20000008
    57ac:	00000d71 	.word	0x00000d71
    57b0:	0000a365 	.word	0x0000a365
    57b4:	000054b1 	.word	0x000054b1
    57b8:	000054cd 	.word	0x000054cd

000057bc <dhcp_discover>:
{
    57bc:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
	struct dhcp *dhcp   = netif->dhcp;
    57be:	6a44      	ldr	r4, [r0, #36]	; 0x24
	ip_addr_set_any(&dhcp->offered_ip_addr);
    57c0:	2300      	movs	r3, #0
{
    57c2:	4606      	mov	r6, r0
	ip_addr_set_any(&dhcp->offered_ip_addr);
    57c4:	6263      	str	r3, [r4, #36]	; 0x24
	dhcp_set_state(dhcp, DHCP_SELECTING);
    57c6:	2106      	movs	r1, #6
    57c8:	4b23      	ldr	r3, [pc, #140]	; (5858 <dhcp_discover+0x9c>)
    57ca:	4620      	mov	r0, r4
    57cc:	4798      	blx	r3
	result = dhcp_create_msg(netif, dhcp, DHCP_DISCOVER);
    57ce:	2201      	movs	r2, #1
    57d0:	4b22      	ldr	r3, [pc, #136]	; (585c <dhcp_discover+0xa0>)
    57d2:	4621      	mov	r1, r4
    57d4:	4630      	mov	r0, r6
    57d6:	4798      	blx	r3
	if (result == ERR_OK) {
    57d8:	4605      	mov	r5, r0
    57da:	bb28      	cbnz	r0, 5828 <dhcp_discover+0x6c>
		dhcp_option(dhcp, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
    57dc:	4620      	mov	r0, r4
    57de:	4f20      	ldr	r7, [pc, #128]	; (5860 <dhcp_discover+0xa4>)
    57e0:	2202      	movs	r2, #2
    57e2:	2139      	movs	r1, #57	; 0x39
    57e4:	47b8      	blx	r7
		dhcp_option_short(dhcp, DHCP_MAX_MSG_LEN(netif));
    57e6:	4b1f      	ldr	r3, [pc, #124]	; (5864 <dhcp_discover+0xa8>)
    57e8:	8d31      	ldrh	r1, [r6, #40]	; 0x28
    57ea:	4798      	blx	r3
		dhcp_option(dhcp, DHCP_OPTION_PARAMETER_REQUEST_LIST, 4 /*num options*/);
    57ec:	2204      	movs	r2, #4
    57ee:	2137      	movs	r1, #55	; 0x37
    57f0:	47b8      	blx	r7
		dhcp_option_byte(dhcp, DHCP_OPTION_SUBNET_MASK);
    57f2:	4f1d      	ldr	r7, [pc, #116]	; (5868 <dhcp_discover+0xac>)
    57f4:	2101      	movs	r1, #1
    57f6:	47b8      	blx	r7
		dhcp_option_byte(dhcp, DHCP_OPTION_ROUTER);
    57f8:	2103      	movs	r1, #3
    57fa:	47b8      	blx	r7
		dhcp_option_byte(dhcp, DHCP_OPTION_BROADCAST);
    57fc:	211c      	movs	r1, #28
    57fe:	47b8      	blx	r7
		dhcp_option_byte(dhcp, DHCP_OPTION_DNS_SERVER);
    5800:	2106      	movs	r1, #6
    5802:	47b8      	blx	r7
		dhcp_option_trailer(dhcp);
    5804:	4b19      	ldr	r3, [pc, #100]	; (586c <dhcp_discover+0xb0>)
    5806:	4798      	blx	r3
		pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
    5808:	8b21      	ldrh	r1, [r4, #24]
    580a:	6920      	ldr	r0, [r4, #16]
    580c:	4b18      	ldr	r3, [pc, #96]	; (5870 <dhcp_discover+0xb4>)
    580e:	31f0      	adds	r1, #240	; 0xf0
    5810:	b289      	uxth	r1, r1
    5812:	4798      	blx	r3
		udp_sendto_if(dhcp->pcb, dhcp->p_out, IP_ADDR_BROADCAST, DHCP_SERVER_PORT, netif);
    5814:	9600      	str	r6, [sp, #0]
    5816:	2343      	movs	r3, #67	; 0x43
    5818:	4a16      	ldr	r2, [pc, #88]	; (5874 <dhcp_discover+0xb8>)
    581a:	6921      	ldr	r1, [r4, #16]
    581c:	6860      	ldr	r0, [r4, #4]
    581e:	4e16      	ldr	r6, [pc, #88]	; (5878 <dhcp_discover+0xbc>)
    5820:	47b0      	blx	r6
		dhcp_delete_msg(dhcp);
    5822:	4b16      	ldr	r3, [pc, #88]	; (587c <dhcp_discover+0xc0>)
    5824:	4620      	mov	r0, r4
    5826:	4798      	blx	r3
	dhcp->tries++;
    5828:	7b63      	ldrb	r3, [r4, #13]
    582a:	3301      	adds	r3, #1
    582c:	b2da      	uxtb	r2, r3
	msecs                 = (dhcp->tries < 6 ? 1 << dhcp->tries : 60) * 1000;
    582e:	2a05      	cmp	r2, #5
    5830:	bf9d      	ittte	ls
    5832:	f44f 737a 	movls.w	r3, #1000	; 0x3e8
    5836:	4093      	lslls	r3, r2
    5838:	b29b      	uxthls	r3, r3
    583a:	f64e 2360 	movwhi	r3, #60000	; 0xea60
	dhcp->tries++;
    583e:	7362      	strb	r2, [r4, #13]
}
    5840:	4628      	mov	r0, r5
	dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
    5842:	f44f 72fa 	mov.w	r2, #500	; 0x1f4
    5846:	f203 13f3 	addw	r3, r3, #499	; 0x1f3
    584a:	b29b      	uxth	r3, r3
    584c:	fbb3 f3f2 	udiv	r3, r3, r2
    5850:	8363      	strh	r3, [r4, #26]
}
    5852:	b003      	add	sp, #12
    5854:	bdf0      	pop	{r4, r5, r6, r7, pc}
    5856:	bf00      	nop
    5858:	000054a1 	.word	0x000054a1
    585c:	0000568d 	.word	0x0000568d
    5860:	000054b1 	.word	0x000054b1
    5864:	000054df 	.word	0x000054df
    5868:	000054cd 	.word	0x000054cd
    586c:	00005533 	.word	0x00005533
    5870:	0000324d 	.word	0x0000324d
    5874:	0000b918 	.word	0x0000b918
    5878:	0000469d 	.word	0x0000469d
    587c:	00005561 	.word	0x00005561

00005880 <dhcp_reboot.isra.0>:
static err_t dhcp_reboot(struct netif *netif)
    5880:	b573      	push	{r0, r1, r4, r5, r6, lr}
	struct dhcp *dhcp = netif->dhcp;
    5882:	6a44      	ldr	r4, [r0, #36]	; 0x24
	dhcp_set_state(dhcp, DHCP_REBOOTING);
    5884:	4b24      	ldr	r3, [pc, #144]	; (5918 <dhcp_reboot.isra.0+0x98>)
    5886:	2103      	movs	r1, #3
static err_t dhcp_reboot(struct netif *netif)
    5888:	4605      	mov	r5, r0
	dhcp_set_state(dhcp, DHCP_REBOOTING);
    588a:	4620      	mov	r0, r4
    588c:	4798      	blx	r3
	result = dhcp_create_msg(netif, dhcp, DHCP_REQUEST);
    588e:	460a      	mov	r2, r1
    5890:	4b22      	ldr	r3, [pc, #136]	; (591c <dhcp_reboot.isra.0+0x9c>)
    5892:	4621      	mov	r1, r4
    5894:	4628      	mov	r0, r5
    5896:	4798      	blx	r3
	if (result == ERR_OK) {
    5898:	bb20      	cbnz	r0, 58e4 <dhcp_reboot.isra.0+0x64>
		dhcp_option(dhcp, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
    589a:	4620      	mov	r0, r4
    589c:	2202      	movs	r2, #2
    589e:	4e20      	ldr	r6, [pc, #128]	; (5920 <dhcp_reboot.isra.0+0xa0>)
    58a0:	2139      	movs	r1, #57	; 0x39
    58a2:	47b0      	blx	r6
		dhcp_option_short(dhcp, 576);
    58a4:	4b1f      	ldr	r3, [pc, #124]	; (5924 <dhcp_reboot.isra.0+0xa4>)
    58a6:	f44f 7110 	mov.w	r1, #576	; 0x240
    58aa:	4798      	blx	r3
		dhcp_option(dhcp, DHCP_OPTION_REQUESTED_IP, 4);
    58ac:	2204      	movs	r2, #4
    58ae:	2132      	movs	r1, #50	; 0x32
    58b0:	47b0      	blx	r6
		dhcp_option_long(dhcp, ntohl(ip4_addr_get_u32(&dhcp->offered_ip_addr)));
    58b2:	4b1d      	ldr	r3, [pc, #116]	; (5928 <dhcp_reboot.isra.0+0xa8>)
    58b4:	6a60      	ldr	r0, [r4, #36]	; 0x24
    58b6:	4798      	blx	r3
    58b8:	4b1c      	ldr	r3, [pc, #112]	; (592c <dhcp_reboot.isra.0+0xac>)
    58ba:	4601      	mov	r1, r0
    58bc:	4620      	mov	r0, r4
    58be:	4798      	blx	r3
		dhcp_option_trailer(dhcp);
    58c0:	4b1b      	ldr	r3, [pc, #108]	; (5930 <dhcp_reboot.isra.0+0xb0>)
    58c2:	4798      	blx	r3
		pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
    58c4:	8b21      	ldrh	r1, [r4, #24]
    58c6:	6920      	ldr	r0, [r4, #16]
    58c8:	4b1a      	ldr	r3, [pc, #104]	; (5934 <dhcp_reboot.isra.0+0xb4>)
    58ca:	31f0      	adds	r1, #240	; 0xf0
    58cc:	b289      	uxth	r1, r1
    58ce:	4798      	blx	r3
		udp_sendto_if(dhcp->pcb, dhcp->p_out, IP_ADDR_BROADCAST, DHCP_SERVER_PORT, netif);
    58d0:	9500      	str	r5, [sp, #0]
    58d2:	2343      	movs	r3, #67	; 0x43
    58d4:	4a18      	ldr	r2, [pc, #96]	; (5938 <dhcp_reboot.isra.0+0xb8>)
    58d6:	6921      	ldr	r1, [r4, #16]
    58d8:	6860      	ldr	r0, [r4, #4]
    58da:	4d18      	ldr	r5, [pc, #96]	; (593c <dhcp_reboot.isra.0+0xbc>)
    58dc:	47a8      	blx	r5
		dhcp_delete_msg(dhcp);
    58de:	4b18      	ldr	r3, [pc, #96]	; (5940 <dhcp_reboot.isra.0+0xc0>)
    58e0:	4620      	mov	r0, r4
    58e2:	4798      	blx	r3
	dhcp->tries++;
    58e4:	7b63      	ldrb	r3, [r4, #13]
    58e6:	3301      	adds	r3, #1
    58e8:	b2db      	uxtb	r3, r3
	msecs                 = dhcp->tries < 10 ? dhcp->tries * 1000 : 10 * 1000;
    58ea:	2b09      	cmp	r3, #9
    58ec:	bf98      	it	ls
    58ee:	ebc3 1243 	rsbls	r2, r3, r3, lsl #5
	dhcp->tries++;
    58f2:	7363      	strb	r3, [r4, #13]
	msecs                 = dhcp->tries < 10 ? dhcp->tries * 1000 : 10 * 1000;
    58f4:	bf9d      	ittte	ls
    58f6:	eb03 0382 	addls.w	r3, r3, r2, lsl #2
    58fa:	00db      	lslls	r3, r3, #3
    58fc:	b29b      	uxthls	r3, r3
    58fe:	f242 7310 	movwhi	r3, #10000	; 0x2710
	dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
    5902:	f44f 72fa 	mov.w	r2, #500	; 0x1f4
    5906:	f203 13f3 	addw	r3, r3, #499	; 0x1f3
    590a:	b29b      	uxth	r3, r3
    590c:	fbb3 f3f2 	udiv	r3, r3, r2
    5910:	8363      	strh	r3, [r4, #26]
}
    5912:	b002      	add	sp, #8
    5914:	bd70      	pop	{r4, r5, r6, pc}
    5916:	bf00      	nop
    5918:	000054a1 	.word	0x000054a1
    591c:	0000568d 	.word	0x0000568d
    5920:	000054b1 	.word	0x000054b1
    5924:	000054df 	.word	0x000054df
    5928:	00000d75 	.word	0x00000d75
    592c:	000054fd 	.word	0x000054fd
    5930:	00005533 	.word	0x00005533
    5934:	0000324d 	.word	0x0000324d
    5938:	0000b918 	.word	0x0000b918
    593c:	0000469d 	.word	0x0000469d
    5940:	00005561 	.word	0x00005561

00005944 <dhcp_rebind.isra.0>:
static err_t dhcp_rebind(struct netif *netif)
    5944:	b537      	push	{r0, r1, r2, r4, r5, lr}
	struct dhcp *dhcp = netif->dhcp;
    5946:	6a44      	ldr	r4, [r0, #36]	; 0x24
	dhcp_set_state(dhcp, DHCP_REBINDING);
    5948:	4b1e      	ldr	r3, [pc, #120]	; (59c4 <dhcp_rebind.isra.0+0x80>)
static err_t dhcp_rebind(struct netif *netif)
    594a:	4605      	mov	r5, r0
	dhcp_set_state(dhcp, DHCP_REBINDING);
    594c:	2104      	movs	r1, #4
    594e:	4620      	mov	r0, r4
    5950:	4798      	blx	r3
	result = dhcp_create_msg(netif, dhcp, DHCP_REQUEST);
    5952:	2203      	movs	r2, #3
    5954:	4b1c      	ldr	r3, [pc, #112]	; (59c8 <dhcp_rebind.isra.0+0x84>)
    5956:	4621      	mov	r1, r4
    5958:	4628      	mov	r0, r5
    595a:	4798      	blx	r3
	if (result == ERR_OK) {
    595c:	b9c8      	cbnz	r0, 5992 <dhcp_rebind.isra.0+0x4e>
		dhcp_option(dhcp, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
    595e:	2202      	movs	r2, #2
    5960:	4620      	mov	r0, r4
    5962:	4b1a      	ldr	r3, [pc, #104]	; (59cc <dhcp_rebind.isra.0+0x88>)
    5964:	2139      	movs	r1, #57	; 0x39
    5966:	4798      	blx	r3
		dhcp_option_short(dhcp, DHCP_MAX_MSG_LEN(netif));
    5968:	8d29      	ldrh	r1, [r5, #40]	; 0x28
    596a:	4b19      	ldr	r3, [pc, #100]	; (59d0 <dhcp_rebind.isra.0+0x8c>)
    596c:	4798      	blx	r3
		dhcp_option_trailer(dhcp);
    596e:	4b19      	ldr	r3, [pc, #100]	; (59d4 <dhcp_rebind.isra.0+0x90>)
    5970:	4798      	blx	r3
		pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
    5972:	8b21      	ldrh	r1, [r4, #24]
    5974:	6920      	ldr	r0, [r4, #16]
    5976:	4b18      	ldr	r3, [pc, #96]	; (59d8 <dhcp_rebind.isra.0+0x94>)
    5978:	31f0      	adds	r1, #240	; 0xf0
    597a:	b289      	uxth	r1, r1
    597c:	4798      	blx	r3
		udp_sendto_if(dhcp->pcb, dhcp->p_out, IP_ADDR_BROADCAST, DHCP_SERVER_PORT, netif);
    597e:	9500      	str	r5, [sp, #0]
    5980:	2343      	movs	r3, #67	; 0x43
    5982:	4a16      	ldr	r2, [pc, #88]	; (59dc <dhcp_rebind.isra.0+0x98>)
    5984:	6921      	ldr	r1, [r4, #16]
    5986:	6860      	ldr	r0, [r4, #4]
    5988:	4d15      	ldr	r5, [pc, #84]	; (59e0 <dhcp_rebind.isra.0+0x9c>)
    598a:	47a8      	blx	r5
		dhcp_delete_msg(dhcp);
    598c:	4b15      	ldr	r3, [pc, #84]	; (59e4 <dhcp_rebind.isra.0+0xa0>)
    598e:	4620      	mov	r0, r4
    5990:	4798      	blx	r3
	dhcp->tries++;
    5992:	7b63      	ldrb	r3, [r4, #13]
    5994:	3301      	adds	r3, #1
    5996:	b2db      	uxtb	r3, r3
	msecs                 = dhcp->tries < 10 ? dhcp->tries * 1000 : 10 * 1000;
    5998:	2b09      	cmp	r3, #9
    599a:	bf98      	it	ls
    599c:	ebc3 1243 	rsbls	r2, r3, r3, lsl #5
	dhcp->tries++;
    59a0:	7363      	strb	r3, [r4, #13]
	msecs                 = dhcp->tries < 10 ? dhcp->tries * 1000 : 10 * 1000;
    59a2:	bf9d      	ittte	ls
    59a4:	eb03 0382 	addls.w	r3, r3, r2, lsl #2
    59a8:	00db      	lslls	r3, r3, #3
    59aa:	b29b      	uxthls	r3, r3
    59ac:	f242 7310 	movwhi	r3, #10000	; 0x2710
	dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
    59b0:	f44f 72fa 	mov.w	r2, #500	; 0x1f4
    59b4:	f203 13f3 	addw	r3, r3, #499	; 0x1f3
    59b8:	b29b      	uxth	r3, r3
    59ba:	fbb3 f3f2 	udiv	r3, r3, r2
    59be:	8363      	strh	r3, [r4, #26]
}
    59c0:	b003      	add	sp, #12
    59c2:	bd30      	pop	{r4, r5, pc}
    59c4:	000054a1 	.word	0x000054a1
    59c8:	0000568d 	.word	0x0000568d
    59cc:	000054b1 	.word	0x000054b1
    59d0:	000054df 	.word	0x000054df
    59d4:	00005533 	.word	0x00005533
    59d8:	0000324d 	.word	0x0000324d
    59dc:	0000b918 	.word	0x0000b918
    59e0:	0000469d 	.word	0x0000469d
    59e4:	00005561 	.word	0x00005561

000059e8 <dhcp_select.isra.0>:
static err_t dhcp_select(struct netif *netif)
    59e8:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
	struct dhcp *dhcp = netif->dhcp;
    59ec:	6a44      	ldr	r4, [r0, #36]	; 0x24
	dhcp_set_state(dhcp, DHCP_REQUESTING);
    59ee:	4b2e      	ldr	r3, [pc, #184]	; (5aa8 <dhcp_select.isra.0+0xc0>)
static err_t dhcp_select(struct netif *netif)
    59f0:	4605      	mov	r5, r0
	dhcp_set_state(dhcp, DHCP_REQUESTING);
    59f2:	2101      	movs	r1, #1
    59f4:	4620      	mov	r0, r4
    59f6:	4798      	blx	r3
	result = dhcp_create_msg(netif, dhcp, DHCP_REQUEST);
    59f8:	2203      	movs	r2, #3
    59fa:	4b2c      	ldr	r3, [pc, #176]	; (5aac <dhcp_select.isra.0+0xc4>)
    59fc:	4621      	mov	r1, r4
    59fe:	4628      	mov	r0, r5
    5a00:	4798      	blx	r3
	if (result == ERR_OK) {
    5a02:	2800      	cmp	r0, #0
    5a04:	d138      	bne.n	5a78 <dhcp_select.isra.0+0x90>
		dhcp_option(dhcp, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
    5a06:	4e2a      	ldr	r6, [pc, #168]	; (5ab0 <dhcp_select.isra.0+0xc8>)
		dhcp_option_long(dhcp, ntohl(ip4_addr_get_u32(&dhcp->offered_ip_addr)));
    5a08:	f8df 80c8 	ldr.w	r8, [pc, #200]	; 5ad4 <dhcp_select.isra.0+0xec>
    5a0c:	4f29      	ldr	r7, [pc, #164]	; (5ab4 <dhcp_select.isra.0+0xcc>)
		dhcp_option(dhcp, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
    5a0e:	4620      	mov	r0, r4
    5a10:	2202      	movs	r2, #2
    5a12:	2139      	movs	r1, #57	; 0x39
    5a14:	47b0      	blx	r6
		dhcp_option_short(dhcp, DHCP_MAX_MSG_LEN(netif));
    5a16:	4b28      	ldr	r3, [pc, #160]	; (5ab8 <dhcp_select.isra.0+0xd0>)
    5a18:	8d29      	ldrh	r1, [r5, #40]	; 0x28
    5a1a:	4798      	blx	r3
		dhcp_option(dhcp, DHCP_OPTION_REQUESTED_IP, 4);
    5a1c:	2204      	movs	r2, #4
    5a1e:	2132      	movs	r1, #50	; 0x32
    5a20:	47b0      	blx	r6
		dhcp_option_long(dhcp, ntohl(ip4_addr_get_u32(&dhcp->offered_ip_addr)));
    5a22:	6a60      	ldr	r0, [r4, #36]	; 0x24
    5a24:	47c0      	blx	r8
    5a26:	4601      	mov	r1, r0
    5a28:	4620      	mov	r0, r4
    5a2a:	47b8      	blx	r7
		dhcp_option(dhcp, DHCP_OPTION_SERVER_ID, 4);
    5a2c:	2204      	movs	r2, #4
    5a2e:	2136      	movs	r1, #54	; 0x36
    5a30:	47b0      	blx	r6
		dhcp_option_long(dhcp, ntohl(ip4_addr_get_u32(&dhcp->server_ip_addr)));
    5a32:	6a20      	ldr	r0, [r4, #32]
    5a34:	47c0      	blx	r8
    5a36:	4601      	mov	r1, r0
    5a38:	4620      	mov	r0, r4
    5a3a:	47b8      	blx	r7
		dhcp_option(dhcp, DHCP_OPTION_PARAMETER_REQUEST_LIST, 4 /*num options*/);
    5a3c:	2204      	movs	r2, #4
    5a3e:	2137      	movs	r1, #55	; 0x37
    5a40:	47b0      	blx	r6
		dhcp_option_byte(dhcp, DHCP_OPTION_SUBNET_MASK);
    5a42:	4e1e      	ldr	r6, [pc, #120]	; (5abc <dhcp_select.isra.0+0xd4>)
    5a44:	2101      	movs	r1, #1
    5a46:	47b0      	blx	r6
		dhcp_option_byte(dhcp, DHCP_OPTION_ROUTER);
    5a48:	2103      	movs	r1, #3
    5a4a:	47b0      	blx	r6
		dhcp_option_byte(dhcp, DHCP_OPTION_BROADCAST);
    5a4c:	211c      	movs	r1, #28
    5a4e:	47b0      	blx	r6
		dhcp_option_byte(dhcp, DHCP_OPTION_DNS_SERVER);
    5a50:	2106      	movs	r1, #6
    5a52:	47b0      	blx	r6
		dhcp_option_trailer(dhcp);
    5a54:	4b1a      	ldr	r3, [pc, #104]	; (5ac0 <dhcp_select.isra.0+0xd8>)
    5a56:	4798      	blx	r3
		pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
    5a58:	8b21      	ldrh	r1, [r4, #24]
    5a5a:	6920      	ldr	r0, [r4, #16]
    5a5c:	4b19      	ldr	r3, [pc, #100]	; (5ac4 <dhcp_select.isra.0+0xdc>)
    5a5e:	31f0      	adds	r1, #240	; 0xf0
    5a60:	b289      	uxth	r1, r1
    5a62:	4798      	blx	r3
		udp_sendto_if(dhcp->pcb, dhcp->p_out, IP_ADDR_BROADCAST, DHCP_SERVER_PORT, netif);
    5a64:	9500      	str	r5, [sp, #0]
    5a66:	2343      	movs	r3, #67	; 0x43
    5a68:	4a17      	ldr	r2, [pc, #92]	; (5ac8 <dhcp_select.isra.0+0xe0>)
    5a6a:	6921      	ldr	r1, [r4, #16]
    5a6c:	6860      	ldr	r0, [r4, #4]
    5a6e:	4d17      	ldr	r5, [pc, #92]	; (5acc <dhcp_select.isra.0+0xe4>)
    5a70:	47a8      	blx	r5
		dhcp_delete_msg(dhcp);
    5a72:	4b17      	ldr	r3, [pc, #92]	; (5ad0 <dhcp_select.isra.0+0xe8>)
    5a74:	4620      	mov	r0, r4
    5a76:	4798      	blx	r3
	dhcp->tries++;
    5a78:	7b63      	ldrb	r3, [r4, #13]
    5a7a:	3301      	adds	r3, #1
    5a7c:	b2da      	uxtb	r2, r3
	msecs                 = (dhcp->tries < 6 ? 1 << dhcp->tries : 60) * 1000;
    5a7e:	2a05      	cmp	r2, #5
    5a80:	bf9d      	ittte	ls
    5a82:	f44f 737a 	movls.w	r3, #1000	; 0x3e8
    5a86:	4093      	lslls	r3, r2
    5a88:	b29b      	uxthls	r3, r3
    5a8a:	f64e 2360 	movwhi	r3, #60000	; 0xea60
	dhcp->tries++;
    5a8e:	7362      	strb	r2, [r4, #13]
	dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
    5a90:	f203 13f3 	addw	r3, r3, #499	; 0x1f3
    5a94:	f44f 72fa 	mov.w	r2, #500	; 0x1f4
    5a98:	b29b      	uxth	r3, r3
    5a9a:	fbb3 f3f2 	udiv	r3, r3, r2
    5a9e:	8363      	strh	r3, [r4, #26]
}
    5aa0:	b002      	add	sp, #8
    5aa2:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    5aa6:	bf00      	nop
    5aa8:	000054a1 	.word	0x000054a1
    5aac:	0000568d 	.word	0x0000568d
    5ab0:	000054b1 	.word	0x000054b1
    5ab4:	000054fd 	.word	0x000054fd
    5ab8:	000054df 	.word	0x000054df
    5abc:	000054cd 	.word	0x000054cd
    5ac0:	00005533 	.word	0x00005533
    5ac4:	0000324d 	.word	0x0000324d
    5ac8:	0000b918 	.word	0x0000b918
    5acc:	0000469d 	.word	0x0000469d
    5ad0:	00005561 	.word	0x00005561
    5ad4:	00000d75 	.word	0x00000d75

00005ad8 <dhcp_recv>:
{
    5ad8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	if (p->len < DHCP_MIN_REPLY_LEN) {
    5adc:	8953      	ldrh	r3, [r2, #10]
	struct dhcp *    dhcp      = netif->dhcp;
    5ade:	f8d0 b024 	ldr.w	fp, [r0, #36]	; 0x24
	if (p->len < DHCP_MIN_REPLY_LEN) {
    5ae2:	2b2b      	cmp	r3, #43	; 0x2b
{
    5ae4:	b089      	sub	sp, #36	; 0x24
    5ae6:	4606      	mov	r6, r0
    5ae8:	4692      	mov	sl, r2
	if (p->len < DHCP_MIN_REPLY_LEN) {
    5aea:	d939      	bls.n	5b60 <dhcp_recv+0x88>
	struct dhcp_msg *reply_msg = (struct dhcp_msg *)p->payload;
    5aec:	6853      	ldr	r3, [r2, #4]
	if (reply_msg->op != DHCP_BOOTREPLY) {
    5aee:	781a      	ldrb	r2, [r3, #0]
    5af0:	2a02      	cmp	r2, #2
    5af2:	d135      	bne.n	5b60 <dhcp_recv+0x88>
	for (i = 0; i < netif->hwaddr_len; i++) {
    5af4:	f890 502a 	ldrb.w	r5, [r0, #42]	; 0x2a
    5af8:	f103 011c 	add.w	r1, r3, #28
    5afc:	302b      	adds	r0, #43	; 0x2b
    5afe:	2200      	movs	r2, #0
    5b00:	b2d4      	uxtb	r4, r2
    5b02:	42a5      	cmp	r5, r4
    5b04:	d824      	bhi.n	5b50 <dhcp_recv+0x78>
	if (ntohl(reply_msg->xid) != dhcp->xid) {
    5b06:	6858      	ldr	r0, [r3, #4]
    5b08:	4b97      	ldr	r3, [pc, #604]	; (5d68 <dhcp_recv+0x290>)
    5b0a:	4798      	blx	r3
    5b0c:	f8db 3000 	ldr.w	r3, [fp]
    5b10:	4298      	cmp	r0, r3
    5b12:	d125      	bne.n	5b60 <dhcp_recv+0x88>
	dhcp_clear_all_options(dhcp);
    5b14:	4b95      	ldr	r3, [pc, #596]	; (5d6c <dhcp_recv+0x294>)
    5b16:	f04f 0800 	mov.w	r8, #0
    5b1a:	f8c3 8004 	str.w	r8, [r3, #4]
    5b1e:	f8a3 8008 	strh.w	r8, [r3, #8]
    5b22:	f8c3 8000 	str.w	r8, [r3]
	if (p->len < DHCP_SNAME_OFS) {
    5b26:	f8ba 300a 	ldrh.w	r3, [sl, #10]
    5b2a:	2b2b      	cmp	r3, #43	; 0x2b
    5b2c:	d918      	bls.n	5b60 <dhcp_recv+0x88>
	dhcp->msg_in = (struct dhcp_msg *)p->payload;
    5b2e:	f8da 3004 	ldr.w	r3, [sl, #4]
	options_idx_max = p->tot_len;
    5b32:	f8ba 9008 	ldrh.w	r9, [sl, #8]
	dhcp->msg_in = (struct dhcp_msg *)p->payload;
    5b36:	f8cb 3008 	str.w	r3, [fp, #8]
	options_idx = DHCP_OPTIONS_OFS;
    5b3a:	23f0      	movs	r3, #240	; 0xf0
    5b3c:	f8cd a004 	str.w	sl, [sp, #4]
	while ((q != NULL) && (options_idx >= q->len)) {
    5b40:	9a01      	ldr	r2, [sp, #4]
    5b42:	8952      	ldrh	r2, [r2, #10]
    5b44:	429a      	cmp	r2, r3
    5b46:	d914      	bls.n	5b72 <dhcp_recv+0x9a>
	options    = (u8_t *)q->payload;
    5b48:	9a01      	ldr	r2, [sp, #4]
    5b4a:	6852      	ldr	r2, [r2, #4]
    5b4c:	9203      	str	r2, [sp, #12]
	while ((q != NULL) && (options[offset] != DHCP_OPTION_END) && (offset < offset_max)) {
    5b4e:	e123      	b.n	5d98 <dhcp_recv+0x2c0>
		if (netif->hwaddr[i] != reply_msg->chaddr[i]) {
    5b50:	f810 7b01 	ldrb.w	r7, [r0], #1
    5b54:	f811 4b01 	ldrb.w	r4, [r1], #1
    5b58:	42a7      	cmp	r7, r4
    5b5a:	f102 0201 	add.w	r2, r2, #1
    5b5e:	d0cf      	beq.n	5b00 <dhcp_recv+0x28>
	dhcp->msg_in = NULL;
    5b60:	2300      	movs	r3, #0
    5b62:	f8cb 3008 	str.w	r3, [fp, #8]
	pbuf_free(p);
    5b66:	4b82      	ldr	r3, [pc, #520]	; (5d70 <dhcp_recv+0x298>)
    5b68:	4650      	mov	r0, sl
}
    5b6a:	b009      	add	sp, #36	; 0x24
    5b6c:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	pbuf_free(p);
    5b70:	4718      	bx	r3
		options_idx -= q->len;
    5b72:	1a9b      	subs	r3, r3, r2
		options_idx_max -= q->len;
    5b74:	eba9 0902 	sub.w	r9, r9, r2
		q = q->next;
    5b78:	9a01      	ldr	r2, [sp, #4]
    5b7a:	6812      	ldr	r2, [r2, #0]
    5b7c:	9201      	str	r2, [sp, #4]
		options_idx -= q->len;
    5b7e:	b29b      	uxth	r3, r3
		options_idx_max -= q->len;
    5b80:	fa1f f989 	uxth.w	r9, r9
	while ((q != NULL) && (options_idx >= q->len)) {
    5b84:	2a00      	cmp	r2, #0
    5b86:	d1db      	bne.n	5b40 <dhcp_recv+0x68>
    5b88:	e7ea      	b.n	5b60 <dhcp_recv+0x88>
			len = (q->next != NULL ? ((u8_t *)q->next->payload)[0] : 0);
    5b8a:	9a01      	ldr	r2, [sp, #4]
    5b8c:	6812      	ldr	r2, [r2, #0]
    5b8e:	2a00      	cmp	r2, #0
    5b90:	f000 8111 	beq.w	5db6 <dhcp_recv+0x2de>
    5b94:	6852      	ldr	r2, [r2, #4]
    5b96:	7812      	ldrb	r2, [r2, #0]
    5b98:	e10d      	b.n	5db6 <dhcp_recv+0x2de>
		switch (op) {
    5b9a:	2c08      	cmp	r4, #8
    5b9c:	d80a      	bhi.n	5bb4 <dhcp_recv+0xdc>
    5b9e:	e8df f004 	tbb	[pc, r4]
    5ba2:	4b48      	.short	0x4b48
    5ba4:	0909514e 	.word	0x0909514e
    5ba8:	5409      	.short	0x5409
    5baa:	57          	.byte	0x57
    5bab:	00          	.byte	0x00
    5bac:	3c33      	subs	r4, #51	; 0x33
    5bae:	b2e1      	uxtb	r1, r4
    5bb0:	2908      	cmp	r1, #8
    5bb2:	d9f2      	bls.n	5b9a <dhcp_recv+0xc2>
    5bb4:	4619      	mov	r1, r3
    5bb6:	f04f 35ff 	mov.w	r5, #4294967295	; 0xffffffff
    5bba:	2400      	movs	r4, #0
    5bbc:	e004      	b.n	5bc8 <dhcp_recv+0xf0>
			offset--;
    5bbe:	1e59      	subs	r1, r3, #1
    5bc0:	b289      	uxth	r1, r1
			decode_len = len = 0;
    5bc2:	4622      	mov	r2, r4
		int   decode_idx = -1;
    5bc4:	f04f 35ff 	mov.w	r5, #4294967295	; 0xffffffff
		offset += len + 2;
    5bc8:	3102      	adds	r1, #2
    5bca:	fa12 f281 	uxtah	r2, r2, r1
    5bce:	b292      	uxth	r2, r2
    5bd0:	9202      	str	r2, [sp, #8]
		if (decode_len > 0) {
    5bd2:	2c00      	cmp	r4, #0
    5bd4:	d07c      	beq.n	5cd0 <dhcp_recv+0x1f8>
			u32_t value = 0;
    5bd6:	2200      	movs	r2, #0
    5bd8:	9207      	str	r2, [sp, #28]
    5bda:	4a64      	ldr	r2, [pc, #400]	; (5d6c <dhcp_recv+0x294>)
		u16_t val_offset = offset + 2;
    5bdc:	3302      	adds	r3, #2
    5bde:	442a      	add	r2, r5
    5be0:	b29b      	uxth	r3, r3
			u32_t value = 0;
    5be2:	9204      	str	r2, [sp, #16]
			if (!dhcp_option_given(dhcp, decode_idx)) {
    5be4:	9904      	ldr	r1, [sp, #16]
    5be6:	f811 2b01 	ldrb.w	r2, [r1], #1
    5bea:	9104      	str	r1, [sp, #16]
    5bec:	2a00      	cmp	r2, #0
    5bee:	d16f      	bne.n	5cd0 <dhcp_recv+0x1f8>
				pbuf_copy_partial(q, &value, copy_len, val_offset);
    5bf0:	2c04      	cmp	r4, #4
    5bf2:	4622      	mov	r2, r4
    5bf4:	9801      	ldr	r0, [sp, #4]
    5bf6:	4f5f      	ldr	r7, [pc, #380]	; (5d74 <dhcp_recv+0x29c>)
    5bf8:	9305      	str	r3, [sp, #20]
    5bfa:	bf28      	it	cs
    5bfc:	2204      	movcs	r2, #4
    5bfe:	a907      	add	r1, sp, #28
    5c00:	47b8      	blx	r7
				if (decode_len > 4) {
    5c02:	2c04      	cmp	r4, #4
    5c04:	d958      	bls.n	5cb8 <dhcp_recv+0x1e0>
					LWIP_ERROR("decode_len % 4 == 0", decode_len % 4 == 0, return ERR_VAL;);
    5c06:	f014 0f03 	tst.w	r4, #3
    5c0a:	9b05      	ldr	r3, [sp, #20]
    5c0c:	d042      	beq.n	5c94 <dhcp_recv+0x1bc>
    5c0e:	e7fe      	b.n	5c0e <dhcp_recv+0x136>
			LWIP_ERROR("len == 4", len == 4, return ERR_VAL;);
    5c10:	2a04      	cmp	r2, #4
    5c12:	d020      	beq.n	5c56 <dhcp_recv+0x17e>
    5c14:	e7fe      	b.n	5c14 <dhcp_recv+0x13c>
			LWIP_ERROR("len >= decode_len", len >= decode_len, return ERR_VAL;);
    5c16:	2a03      	cmp	r2, #3
    5c18:	d821      	bhi.n	5c5e <dhcp_recv+0x186>
    5c1a:	e7fe      	b.n	5c1a <dhcp_recv+0x142>
			LWIP_ERROR("len % 4 == 0", len % 4 == 0, return ERR_VAL;);
    5c1c:	0791      	lsls	r1, r2, #30
    5c1e:	d000      	beq.n	5c22 <dhcp_recv+0x14a>
    5c20:	e7fe      	b.n	5c20 <dhcp_recv+0x148>
			decode_len = LWIP_MIN(len, 4 * DNS_MAX_SERVERS);
    5c22:	2a08      	cmp	r2, #8
    5c24:	4614      	mov	r4, r2
    5c26:	bf28      	it	cs
    5c28:	2408      	movcs	r4, #8
    5c2a:	b2e4      	uxtb	r4, r4
			LWIP_ERROR("len >= decode_len", len >= decode_len, return ERR_VAL;);
    5c2c:	42a2      	cmp	r2, r4
    5c2e:	d21a      	bcs.n	5c66 <dhcp_recv+0x18e>
    5c30:	e7fe      	b.n	5c30 <dhcp_recv+0x158>
			LWIP_ERROR("len == 4", len == 4, return ERR_VAL;);
    5c32:	2a04      	cmp	r2, #4
    5c34:	d01a      	beq.n	5c6c <dhcp_recv+0x194>
    5c36:	e7fe      	b.n	5c36 <dhcp_recv+0x15e>
			LWIP_ERROR("len == 1", len == 1, return ERR_VAL;);
    5c38:	2a01      	cmp	r2, #1
    5c3a:	d01b      	beq.n	5c74 <dhcp_recv+0x19c>
    5c3c:	e7fe      	b.n	5c3c <dhcp_recv+0x164>
			LWIP_ERROR("len == 1", len == 1, return ERR_VAL;);
    5c3e:	2a01      	cmp	r2, #1
    5c40:	d020      	beq.n	5c84 <dhcp_recv+0x1ac>
    5c42:	e7fe      	b.n	5c42 <dhcp_recv+0x16a>
			LWIP_ERROR("len == 4", len == 4, return ERR_VAL;);
    5c44:	2a04      	cmp	r2, #4
    5c46:	d019      	beq.n	5c7c <dhcp_recv+0x1a4>
    5c48:	e7fe      	b.n	5c48 <dhcp_recv+0x170>
			LWIP_ERROR("len == 4", len == 4, return ERR_VAL;);
    5c4a:	2a04      	cmp	r2, #4
    5c4c:	d01a      	beq.n	5c84 <dhcp_recv+0x1ac>
    5c4e:	e7fe      	b.n	5c4e <dhcp_recv+0x176>
			LWIP_ERROR("len == 4", len == 4, return ERR_VAL;);
    5c50:	2a04      	cmp	r2, #4
    5c52:	d01b      	beq.n	5c8c <dhcp_recv+0x1b4>
    5c54:	e7fe      	b.n	5c54 <dhcp_recv+0x17c>
    5c56:	4614      	mov	r4, r2
    5c58:	4619      	mov	r1, r3
			decode_idx = DHCP_OPTION_IDX_SUBNET_MASK;
    5c5a:	2506      	movs	r5, #6
    5c5c:	e7b4      	b.n	5bc8 <dhcp_recv+0xf0>
    5c5e:	4619      	mov	r1, r3
			decode_idx = DHCP_OPTION_IDX_ROUTER;
    5c60:	2507      	movs	r5, #7
			decode_len = 4; /* only copy the first given router */
    5c62:	2404      	movs	r4, #4
    5c64:	e7b0      	b.n	5bc8 <dhcp_recv+0xf0>
    5c66:	4619      	mov	r1, r3
			decode_idx = DHCP_OPTION_IDX_DNS_SERVER;
    5c68:	2508      	movs	r5, #8
    5c6a:	e7ad      	b.n	5bc8 <dhcp_recv+0xf0>
    5c6c:	4614      	mov	r4, r2
    5c6e:	4619      	mov	r1, r3
			decode_idx = DHCP_OPTION_IDX_LEASE_TIME;
    5c70:	2503      	movs	r5, #3
    5c72:	e7a9      	b.n	5bc8 <dhcp_recv+0xf0>
    5c74:	4614      	mov	r4, r2
    5c76:	4619      	mov	r1, r3
			decode_idx = DHCP_OPTION_IDX_OVERLOAD;
    5c78:	2500      	movs	r5, #0
    5c7a:	e7a5      	b.n	5bc8 <dhcp_recv+0xf0>
    5c7c:	4614      	mov	r4, r2
    5c7e:	4619      	mov	r1, r3
			decode_idx = DHCP_OPTION_IDX_SERVER_ID;
    5c80:	2502      	movs	r5, #2
    5c82:	e7a1      	b.n	5bc8 <dhcp_recv+0xf0>
    5c84:	4614      	mov	r4, r2
    5c86:	4619      	mov	r1, r3
			decode_idx = DHCP_OPTION_IDX_T1;
    5c88:	4615      	mov	r5, r2
    5c8a:	e79d      	b.n	5bc8 <dhcp_recv+0xf0>
    5c8c:	4614      	mov	r4, r2
    5c8e:	4619      	mov	r1, r3
			decode_idx = DHCP_OPTION_IDX_T2;
    5c90:	2505      	movs	r5, #5
    5c92:	e799      	b.n	5bc8 <dhcp_recv+0xf0>
    5c94:	9305      	str	r3, [sp, #20]
					dhcp_got_option(dhcp, decode_idx);
    5c96:	9b04      	ldr	r3, [sp, #16]
					dhcp_set_option_value(dhcp, decode_idx, htonl(value));
    5c98:	9807      	ldr	r0, [sp, #28]
					dhcp_got_option(dhcp, decode_idx);
    5c9a:	2201      	movs	r2, #1
    5c9c:	f803 2c01 	strb.w	r2, [r3, #-1]
					dhcp_set_option_value(dhcp, decode_idx, htonl(value));
    5ca0:	4b35      	ldr	r3, [pc, #212]	; (5d78 <dhcp_recv+0x2a0>)
    5ca2:	4798      	blx	r3
    5ca4:	4b35      	ldr	r3, [pc, #212]	; (5d7c <dhcp_recv+0x2a4>)
    5ca6:	f843 0025 	str.w	r0, [r3, r5, lsl #2]
					val_offset += 4;
    5caa:	9b05      	ldr	r3, [sp, #20]
					decode_len -= 4;
    5cac:	3c04      	subs	r4, #4
					val_offset += 4;
    5cae:	3304      	adds	r3, #4
					decode_len -= 4;
    5cb0:	b2e4      	uxtb	r4, r4
					val_offset += 4;
    5cb2:	b29b      	uxth	r3, r3
					decode_idx++;
    5cb4:	3501      	adds	r5, #1
					goto decode_next;
    5cb6:	e795      	b.n	5be4 <dhcp_recv+0x10c>
				} else if (decode_len == 4) {
    5cb8:	d152      	bne.n	5d60 <dhcp_recv+0x288>
					value = ntohl(value);
    5cba:	9807      	ldr	r0, [sp, #28]
    5cbc:	4b2a      	ldr	r3, [pc, #168]	; (5d68 <dhcp_recv+0x290>)
    5cbe:	4798      	blx	r3
    5cc0:	9007      	str	r0, [sp, #28]
				dhcp_got_option(dhcp, decode_idx);
    5cc2:	4a2a      	ldr	r2, [pc, #168]	; (5d6c <dhcp_recv+0x294>)
    5cc4:	2301      	movs	r3, #1
    5cc6:	5553      	strb	r3, [r2, r5]
				dhcp_set_option_value(dhcp, decode_idx, value);
    5cc8:	eb02 0585 	add.w	r5, r2, r5, lsl #2
    5ccc:	9b07      	ldr	r3, [sp, #28]
    5cce:	60eb      	str	r3, [r5, #12]
		if (offset >= q->len) {
    5cd0:	9b01      	ldr	r3, [sp, #4]
    5cd2:	9a02      	ldr	r2, [sp, #8]
    5cd4:	895b      	ldrh	r3, [r3, #10]
    5cd6:	429a      	cmp	r2, r3
    5cd8:	d35d      	bcc.n	5d96 <dhcp_recv+0x2be>
			offset -= q->len;
    5cda:	1ad2      	subs	r2, r2, r3
			offset_max -= q->len;
    5cdc:	eba9 0903 	sub.w	r9, r9, r3
			offset -= q->len;
    5ce0:	b292      	uxth	r2, r2
			offset_max -= q->len;
    5ce2:	fa1f f989 	uxth.w	r9, r9
			if ((offset < offset_max) && offset_max) {
    5ce6:	454a      	cmp	r2, r9
			offset -= q->len;
    5ce8:	9202      	str	r2, [sp, #8]
			if ((offset < offset_max) && offset_max) {
    5cea:	d34f      	bcc.n	5d8c <dhcp_recv+0x2b4>
	if (dhcp_option_given(dhcp, DHCP_OPTION_IDX_OVERLOAD)) {
    5cec:	4c1f      	ldr	r4, [pc, #124]	; (5d6c <dhcp_recv+0x294>)
    5cee:	7823      	ldrb	r3, [r4, #0]
    5cf0:	2b00      	cmp	r3, #0
    5cf2:	d177      	bne.n	5de4 <dhcp_recv+0x30c>
	} else if (parse_sname_as_options) {
    5cf4:	f1b8 0f00 	cmp.w	r8, #0
    5cf8:	d17b      	bne.n	5df2 <dhcp_recv+0x31a>
	if (!dhcp_option_given(dhcp, DHCP_OPTION_IDX_MSG_TYPE)) {
    5cfa:	7863      	ldrb	r3, [r4, #1]
    5cfc:	2b00      	cmp	r3, #0
    5cfe:	f43f af2f 	beq.w	5b60 <dhcp_recv+0x88>
	msg_type = (u8_t)dhcp_get_option_value(dhcp, DHCP_OPTION_IDX_MSG_TYPE);
    5d02:	7c23      	ldrb	r3, [r4, #16]
	if (msg_type == DHCP_ACK) {
    5d04:	2b05      	cmp	r3, #5
    5d06:	f040 808f 	bne.w	5e28 <dhcp_recv+0x350>
		if (dhcp->state == DHCP_REQUESTING) {
    5d0a:	f89b 300c 	ldrb.w	r3, [fp, #12]
    5d0e:	2b01      	cmp	r3, #1
    5d10:	f040 8083 	bne.w	5e1a <dhcp_recv+0x342>
			dhcp_handle_ack(netif);
    5d14:	6a75      	ldr	r5, [r6, #36]	; 0x24
	if (dhcp_option_given(dhcp, DHCP_OPTION_IDX_LEASE_TIME)) {
    5d16:	78e3      	ldrb	r3, [r4, #3]
	ip_addr_set_zero(&dhcp->offered_gw_addr);
    5d18:	e9c5 880a 	strd	r8, r8, [r5, #40]	; 0x28
	if (dhcp_option_given(dhcp, DHCP_OPTION_IDX_LEASE_TIME)) {
    5d1c:	b10b      	cbz	r3, 5d22 <dhcp_recv+0x24a>
		dhcp->offered_t0_lease = dhcp_get_option_value(dhcp, DHCP_OPTION_IDX_LEASE_TIME);
    5d1e:	69a3      	ldr	r3, [r4, #24]
    5d20:	632b      	str	r3, [r5, #48]	; 0x30
	if (dhcp_option_given(dhcp, DHCP_OPTION_IDX_T1)) {
    5d22:	7923      	ldrb	r3, [r4, #4]
    5d24:	2b00      	cmp	r3, #0
    5d26:	d073      	beq.n	5e10 <dhcp_recv+0x338>
		dhcp->offered_t1_renew = dhcp_get_option_value(dhcp, DHCP_OPTION_IDX_T1);
    5d28:	69e3      	ldr	r3, [r4, #28]
    5d2a:	636b      	str	r3, [r5, #52]	; 0x34
	if (dhcp_option_given(dhcp, DHCP_OPTION_IDX_T2)) {
    5d2c:	7963      	ldrb	r3, [r4, #5]
    5d2e:	2b00      	cmp	r3, #0
    5d30:	d071      	beq.n	5e16 <dhcp_recv+0x33e>
		dhcp->offered_t2_rebind = dhcp_get_option_value(dhcp, DHCP_OPTION_IDX_T2);
    5d32:	6a23      	ldr	r3, [r4, #32]
    5d34:	63ab      	str	r3, [r5, #56]	; 0x38
	ip_addr_copy(dhcp->offered_ip_addr, dhcp->msg_in->yiaddr);
    5d36:	68ab      	ldr	r3, [r5, #8]
    5d38:	691b      	ldr	r3, [r3, #16]
    5d3a:	626b      	str	r3, [r5, #36]	; 0x24
	if (dhcp_option_given(dhcp, DHCP_OPTION_IDX_SUBNET_MASK)) {
    5d3c:	79a3      	ldrb	r3, [r4, #6]
    5d3e:	b123      	cbz	r3, 5d4a <dhcp_recv+0x272>
		ip4_addr_set_u32(&dhcp->offered_sn_mask, htonl(dhcp_get_option_value(dhcp, DHCP_OPTION_IDX_SUBNET_MASK)));
    5d40:	4b0d      	ldr	r3, [pc, #52]	; (5d78 <dhcp_recv+0x2a0>)
    5d42:	6a60      	ldr	r0, [r4, #36]	; 0x24
    5d44:	4798      	blx	r3
		dhcp->subnet_mask_given = 1;
    5d46:	2301      	movs	r3, #1
		ip4_addr_set_u32(&dhcp->offered_sn_mask, htonl(dhcp_get_option_value(dhcp, DHCP_OPTION_IDX_SUBNET_MASK)));
    5d48:	62a8      	str	r0, [r5, #40]	; 0x28
		dhcp->subnet_mask_given = 0;
    5d4a:	73ab      	strb	r3, [r5, #14]
	if (dhcp_option_given(dhcp, DHCP_OPTION_IDX_ROUTER)) {
    5d4c:	79e3      	ldrb	r3, [r4, #7]
    5d4e:	b11b      	cbz	r3, 5d58 <dhcp_recv+0x280>
		ip4_addr_set_u32(&dhcp->offered_gw_addr, htonl(dhcp_get_option_value(dhcp, DHCP_OPTION_IDX_ROUTER)));
    5d50:	6aa0      	ldr	r0, [r4, #40]	; 0x28
    5d52:	4b09      	ldr	r3, [pc, #36]	; (5d78 <dhcp_recv+0x2a0>)
    5d54:	4798      	blx	r3
    5d56:	62e8      	str	r0, [r5, #44]	; 0x2c
			dhcp_check(netif);
    5d58:	4b09      	ldr	r3, [pc, #36]	; (5d80 <dhcp_recv+0x2a8>)
    5d5a:	4630      	mov	r0, r6
		dhcp_select(netif);
    5d5c:	4798      	blx	r3
    5d5e:	e6ff      	b.n	5b60 <dhcp_recv+0x88>
					LWIP_ERROR("invalid decode_len", decode_len == 1, return ERR_VAL;);
    5d60:	2c01      	cmp	r4, #1
    5d62:	d00f      	beq.n	5d84 <dhcp_recv+0x2ac>
    5d64:	e7fe      	b.n	5d64 <dhcp_recv+0x28c>
    5d66:	bf00      	nop
    5d68:	00000d75 	.word	0x00000d75
    5d6c:	200110d0 	.word	0x200110d0
    5d70:	000030e5 	.word	0x000030e5
    5d74:	00003385 	.word	0x00003385
    5d78:	00000d71 	.word	0x00000d71
    5d7c:	200110dc 	.word	0x200110dc
    5d80:	0000557d 	.word	0x0000557d
					value = ((u8_t *)&value)[0];
    5d84:	f89d 301c 	ldrb.w	r3, [sp, #28]
    5d88:	9307      	str	r3, [sp, #28]
    5d8a:	e79a      	b.n	5cc2 <dhcp_recv+0x1ea>
				q = q->next;
    5d8c:	9b01      	ldr	r3, [sp, #4]
    5d8e:	681b      	ldr	r3, [r3, #0]
    5d90:	9301      	str	r3, [sp, #4]
				options = (u8_t *)q->payload;
    5d92:	685b      	ldr	r3, [r3, #4]
    5d94:	9303      	str	r3, [sp, #12]
			decode_idx = DHCP_OPTION_IDX_T2;
    5d96:	9b02      	ldr	r3, [sp, #8]
	while ((q != NULL) && (options[offset] != DHCP_OPTION_END) && (offset < offset_max)) {
    5d98:	9a03      	ldr	r2, [sp, #12]
    5d9a:	5cd4      	ldrb	r4, [r2, r3]
    5d9c:	2cff      	cmp	r4, #255	; 0xff
    5d9e:	d0a5      	beq.n	5cec <dhcp_recv+0x214>
    5da0:	454b      	cmp	r3, r9
    5da2:	d2a3      	bcs.n	5cec <dhcp_recv+0x214>
		if (offset + 1 < q->len) {
    5da4:	9901      	ldr	r1, [sp, #4]
    5da6:	8949      	ldrh	r1, [r1, #10]
    5da8:	1c5a      	adds	r2, r3, #1
    5daa:	428a      	cmp	r2, r1
    5dac:	f6bf aeed 	bge.w	5b8a <dhcp_recv+0xb2>
			len = options[offset + 1];
    5db0:	9a03      	ldr	r2, [sp, #12]
    5db2:	441a      	add	r2, r3
    5db4:	7852      	ldrb	r2, [r2, #1]
		switch (op) {
    5db6:	2c06      	cmp	r4, #6
    5db8:	f63f aef8 	bhi.w	5bac <dhcp_recv+0xd4>
    5dbc:	2c06      	cmp	r4, #6
    5dbe:	f63f aef9 	bhi.w	5bb4 <dhcp_recv+0xdc>
    5dc2:	a101      	add	r1, pc, #4	; (adr r1, 5dc8 <dhcp_recv+0x2f0>)
    5dc4:	f851 f024 	ldr.w	pc, [r1, r4, lsl #2]
    5dc8:	00005bbf 	.word	0x00005bbf
    5dcc:	00005c11 	.word	0x00005c11
    5dd0:	00005bb5 	.word	0x00005bb5
    5dd4:	00005c17 	.word	0x00005c17
    5dd8:	00005bb5 	.word	0x00005bb5
    5ddc:	00005bb5 	.word	0x00005bb5
    5de0:	00005c1d 	.word	0x00005c1d
		u32_t overload = dhcp_get_option_value(dhcp, DHCP_OPTION_IDX_OVERLOAD);
    5de4:	68e3      	ldr	r3, [r4, #12]
		dhcp_clear_option(dhcp, DHCP_OPTION_IDX_OVERLOAD);
    5de6:	2200      	movs	r2, #0
		if (overload == DHCP_OVERLOAD_FILE) {
    5de8:	2b01      	cmp	r3, #1
		dhcp_clear_option(dhcp, DHCP_OPTION_IDX_OVERLOAD);
    5dea:	7022      	strb	r2, [r4, #0]
		if (overload == DHCP_OVERLOAD_FILE) {
    5dec:	d00c      	beq.n	5e08 <dhcp_recv+0x330>
		} else if (overload == DHCP_OVERLOAD_SNAME) {
    5dee:	2b02      	cmp	r3, #2
    5df0:	d105      	bne.n	5dfe <dhcp_recv+0x326>
		parse_sname_as_options = 0;
    5df2:	f04f 0800 	mov.w	r8, #0
		options_idx_max        = DHCP_SNAME_OFS + DHCP_SNAME_LEN;
    5df6:	f04f 096c 	mov.w	r9, #108	; 0x6c
		options_idx            = DHCP_SNAME_OFS;
    5dfa:	232c      	movs	r3, #44	; 0x2c
    5dfc:	e69e      	b.n	5b3c <dhcp_recv+0x64>
		} else if (overload == DHCP_OVERLOAD_SNAME_FILE) {
    5dfe:	2b03      	cmp	r3, #3
    5e00:	f47f af78 	bne.w	5cf4 <dhcp_recv+0x21c>
			parse_sname_as_options = 1;
    5e04:	f04f 0801 	mov.w	r8, #1
		options_idx_max       = DHCP_FILE_OFS + DHCP_FILE_LEN;
    5e08:	f04f 09ec 	mov.w	r9, #236	; 0xec
		options_idx           = DHCP_FILE_OFS;
    5e0c:	236c      	movs	r3, #108	; 0x6c
    5e0e:	e695      	b.n	5b3c <dhcp_recv+0x64>
		dhcp->offered_t1_renew = dhcp->offered_t0_lease / 2;
    5e10:	6b2b      	ldr	r3, [r5, #48]	; 0x30
    5e12:	085b      	lsrs	r3, r3, #1
    5e14:	e789      	b.n	5d2a <dhcp_recv+0x252>
		dhcp->offered_t2_rebind = dhcp->offered_t0_lease;
    5e16:	6b2b      	ldr	r3, [r5, #48]	; 0x30
    5e18:	e78c      	b.n	5d34 <dhcp_recv+0x25c>
		else if ((dhcp->state == DHCP_REBOOTING) || (dhcp->state == DHCP_REBINDING) || (dhcp->state == DHCP_RENEWING)) {
    5e1a:	3b03      	subs	r3, #3
    5e1c:	2b02      	cmp	r3, #2
    5e1e:	f63f ae9f 	bhi.w	5b60 <dhcp_recv+0x88>
			dhcp_bind(netif);
    5e22:	4b1f      	ldr	r3, [pc, #124]	; (5ea0 <dhcp_recv+0x3c8>)
    5e24:	4630      	mov	r0, r6
    5e26:	e799      	b.n	5d5c <dhcp_recv+0x284>
	else if ((msg_type == DHCP_NAK)
    5e28:	2b06      	cmp	r3, #6
    5e2a:	d11f      	bne.n	5e6c <dhcp_recv+0x394>
	         && ((dhcp->state == DHCP_REBOOTING) || (dhcp->state == DHCP_REQUESTING) || (dhcp->state == DHCP_REBINDING)
    5e2c:	f89b 300c 	ldrb.w	r3, [fp, #12]
    5e30:	1eda      	subs	r2, r3, #3
    5e32:	2a02      	cmp	r2, #2
    5e34:	d902      	bls.n	5e3c <dhcp_recv+0x364>
    5e36:	2b01      	cmp	r3, #1
    5e38:	f47f ae92 	bne.w	5b60 <dhcp_recv+0x88>
	netif_set_down(netif);
    5e3c:	4630      	mov	r0, r6
    5e3e:	4b19      	ldr	r3, [pc, #100]	; (5ea4 <dhcp_recv+0x3cc>)
	struct dhcp *dhcp = netif->dhcp;
    5e40:	6a74      	ldr	r4, [r6, #36]	; 0x24
	netif_set_down(netif);
    5e42:	4798      	blx	r3
	netif_set_ipaddr(netif, IP_ADDR_ANY);
    5e44:	4630      	mov	r0, r6
    5e46:	4918      	ldr	r1, [pc, #96]	; (5ea8 <dhcp_recv+0x3d0>)
    5e48:	4b18      	ldr	r3, [pc, #96]	; (5eac <dhcp_recv+0x3d4>)
    5e4a:	4798      	blx	r3
	netif_set_gw(netif, IP_ADDR_ANY);
    5e4c:	4630      	mov	r0, r6
    5e4e:	4916      	ldr	r1, [pc, #88]	; (5ea8 <dhcp_recv+0x3d0>)
    5e50:	4b17      	ldr	r3, [pc, #92]	; (5eb0 <dhcp_recv+0x3d8>)
    5e52:	4798      	blx	r3
	netif_set_netmask(netif, IP_ADDR_ANY);
    5e54:	4630      	mov	r0, r6
    5e56:	4914      	ldr	r1, [pc, #80]	; (5ea8 <dhcp_recv+0x3d0>)
    5e58:	4b16      	ldr	r3, [pc, #88]	; (5eb4 <dhcp_recv+0x3dc>)
    5e5a:	4798      	blx	r3
	dhcp_set_state(dhcp, DHCP_BACKING_OFF);
    5e5c:	4620      	mov	r0, r4
    5e5e:	4b16      	ldr	r3, [pc, #88]	; (5eb8 <dhcp_recv+0x3e0>)
    5e60:	210c      	movs	r1, #12
    5e62:	4798      	blx	r3
	dhcp_discover(netif);
    5e64:	4b15      	ldr	r3, [pc, #84]	; (5ebc <dhcp_recv+0x3e4>)
    5e66:	4630      	mov	r0, r6
    5e68:	4798      	blx	r3
}
    5e6a:	e679      	b.n	5b60 <dhcp_recv+0x88>
	else if ((msg_type == DHCP_OFFER) && (dhcp->state == DHCP_SELECTING)) {
    5e6c:	2b02      	cmp	r3, #2
    5e6e:	f47f ae77 	bne.w	5b60 <dhcp_recv+0x88>
    5e72:	f89b 300c 	ldrb.w	r3, [fp, #12]
    5e76:	2b06      	cmp	r3, #6
    5e78:	f47f ae72 	bne.w	5b60 <dhcp_recv+0x88>
	if (dhcp_option_given(dhcp, DHCP_OPTION_IDX_SERVER_ID)) {
    5e7c:	78a3      	ldrb	r3, [r4, #2]
		dhcp->request_timeout = 0;
    5e7e:	f8ab 801a 	strh.w	r8, [fp, #26]
	if (dhcp_option_given(dhcp, DHCP_OPTION_IDX_SERVER_ID)) {
    5e82:	2b00      	cmp	r3, #0
    5e84:	f43f ae6c 	beq.w	5b60 <dhcp_recv+0x88>
		ip4_addr_set_u32(&dhcp->server_ip_addr, htonl(dhcp_get_option_value(dhcp, DHCP_OPTION_IDX_SERVER_ID)));
    5e88:	4b0d      	ldr	r3, [pc, #52]	; (5ec0 <dhcp_recv+0x3e8>)
    5e8a:	6960      	ldr	r0, [r4, #20]
	struct dhcp *dhcp = netif->dhcp;
    5e8c:	6a75      	ldr	r5, [r6, #36]	; 0x24
		ip4_addr_set_u32(&dhcp->server_ip_addr, htonl(dhcp_get_option_value(dhcp, DHCP_OPTION_IDX_SERVER_ID)));
    5e8e:	4798      	blx	r3
		ip_addr_copy(dhcp->offered_ip_addr, dhcp->msg_in->yiaddr);
    5e90:	68ab      	ldr	r3, [r5, #8]
		ip4_addr_set_u32(&dhcp->server_ip_addr, htonl(dhcp_get_option_value(dhcp, DHCP_OPTION_IDX_SERVER_ID)));
    5e92:	6228      	str	r0, [r5, #32]
		ip_addr_copy(dhcp->offered_ip_addr, dhcp->msg_in->yiaddr);
    5e94:	691b      	ldr	r3, [r3, #16]
    5e96:	626b      	str	r3, [r5, #36]	; 0x24
		dhcp_select(netif);
    5e98:	4630      	mov	r0, r6
    5e9a:	4b0a      	ldr	r3, [pc, #40]	; (5ec4 <dhcp_recv+0x3ec>)
    5e9c:	e75e      	b.n	5d5c <dhcp_recv+0x284>
    5e9e:	bf00      	nop
    5ea0:	000055ad 	.word	0x000055ad
    5ea4:	0000a0cd 	.word	0x0000a0cd
    5ea8:	0000b91c 	.word	0x0000b91c
    5eac:	00009fb5 	.word	0x00009fb5
    5eb0:	0000a079 	.word	0x0000a079
    5eb4:	0000a081 	.word	0x0000a081
    5eb8:	000054a1 	.word	0x000054a1
    5ebc:	000057bd 	.word	0x000057bd
    5ec0:	00000d71 	.word	0x00000d71
    5ec4:	000059e9 	.word	0x000059e9

00005ec8 <dhcp_arp_reply>:
{
    5ec8:	b537      	push	{r0, r1, r2, r4, r5, lr}
	LWIP_ERROR("netif != NULL", (netif != NULL), return;);
    5eca:	4605      	mov	r5, r0
    5ecc:	b900      	cbnz	r0, 5ed0 <dhcp_arp_reply+0x8>
    5ece:	e7fe      	b.n	5ece <dhcp_arp_reply+0x6>
	if ((netif->dhcp != NULL) && (netif->dhcp->state == DHCP_CHECKING)) {
    5ed0:	6a44      	ldr	r4, [r0, #36]	; 0x24
    5ed2:	2c00      	cmp	r4, #0
    5ed4:	d033      	beq.n	5f3e <dhcp_arp_reply+0x76>
    5ed6:	7b23      	ldrb	r3, [r4, #12]
    5ed8:	2b08      	cmp	r3, #8
    5eda:	d130      	bne.n	5f3e <dhcp_arp_reply+0x76>
		if (ip_addr_cmp(addr, &netif->dhcp->offered_ip_addr)) {
    5edc:	680a      	ldr	r2, [r1, #0]
    5ede:	6a63      	ldr	r3, [r4, #36]	; 0x24
    5ee0:	429a      	cmp	r2, r3
    5ee2:	d12c      	bne.n	5f3e <dhcp_arp_reply+0x76>
	dhcp_set_state(dhcp, DHCP_BACKING_OFF);
    5ee4:	4b17      	ldr	r3, [pc, #92]	; (5f44 <dhcp_arp_reply+0x7c>)
    5ee6:	210c      	movs	r1, #12
    5ee8:	4620      	mov	r0, r4
    5eea:	4798      	blx	r3
	result = dhcp_create_msg(netif, dhcp, DHCP_DECLINE);
    5eec:	2204      	movs	r2, #4
    5eee:	4b16      	ldr	r3, [pc, #88]	; (5f48 <dhcp_arp_reply+0x80>)
    5ef0:	4621      	mov	r1, r4
    5ef2:	4628      	mov	r0, r5
    5ef4:	4798      	blx	r3
	if (result == ERR_OK) {
    5ef6:	b9e8      	cbnz	r0, 5f34 <dhcp_arp_reply+0x6c>
		dhcp_option(dhcp, DHCP_OPTION_REQUESTED_IP, 4);
    5ef8:	2204      	movs	r2, #4
    5efa:	2132      	movs	r1, #50	; 0x32
    5efc:	4b13      	ldr	r3, [pc, #76]	; (5f4c <dhcp_arp_reply+0x84>)
    5efe:	4620      	mov	r0, r4
    5f00:	4798      	blx	r3
		dhcp_option_long(dhcp, ntohl(ip4_addr_get_u32(&dhcp->offered_ip_addr)));
    5f02:	4b13      	ldr	r3, [pc, #76]	; (5f50 <dhcp_arp_reply+0x88>)
    5f04:	6a60      	ldr	r0, [r4, #36]	; 0x24
    5f06:	4798      	blx	r3
    5f08:	4b12      	ldr	r3, [pc, #72]	; (5f54 <dhcp_arp_reply+0x8c>)
    5f0a:	4601      	mov	r1, r0
    5f0c:	4620      	mov	r0, r4
    5f0e:	4798      	blx	r3
		dhcp_option_trailer(dhcp);
    5f10:	4b11      	ldr	r3, [pc, #68]	; (5f58 <dhcp_arp_reply+0x90>)
    5f12:	4798      	blx	r3
		pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
    5f14:	8b21      	ldrh	r1, [r4, #24]
    5f16:	6920      	ldr	r0, [r4, #16]
    5f18:	4b10      	ldr	r3, [pc, #64]	; (5f5c <dhcp_arp_reply+0x94>)
    5f1a:	31f0      	adds	r1, #240	; 0xf0
    5f1c:	b289      	uxth	r1, r1
    5f1e:	4798      	blx	r3
		udp_sendto_if(dhcp->pcb, dhcp->p_out, IP_ADDR_BROADCAST, DHCP_SERVER_PORT, netif);
    5f20:	9500      	str	r5, [sp, #0]
    5f22:	2343      	movs	r3, #67	; 0x43
    5f24:	4a0e      	ldr	r2, [pc, #56]	; (5f60 <dhcp_arp_reply+0x98>)
    5f26:	6921      	ldr	r1, [r4, #16]
    5f28:	6860      	ldr	r0, [r4, #4]
    5f2a:	4d0e      	ldr	r5, [pc, #56]	; (5f64 <dhcp_arp_reply+0x9c>)
    5f2c:	47a8      	blx	r5
		dhcp_delete_msg(dhcp);
    5f2e:	4b0e      	ldr	r3, [pc, #56]	; (5f68 <dhcp_arp_reply+0xa0>)
    5f30:	4620      	mov	r0, r4
    5f32:	4798      	blx	r3
	dhcp->tries++;
    5f34:	7b63      	ldrb	r3, [r4, #13]
    5f36:	3301      	adds	r3, #1
    5f38:	7363      	strb	r3, [r4, #13]
	dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
    5f3a:	2314      	movs	r3, #20
    5f3c:	8363      	strh	r3, [r4, #26]
}
    5f3e:	b003      	add	sp, #12
    5f40:	bd30      	pop	{r4, r5, pc}
    5f42:	bf00      	nop
    5f44:	000054a1 	.word	0x000054a1
    5f48:	0000568d 	.word	0x0000568d
    5f4c:	000054b1 	.word	0x000054b1
    5f50:	00000d75 	.word	0x00000d75
    5f54:	000054fd 	.word	0x000054fd
    5f58:	00005533 	.word	0x00005533
    5f5c:	0000324d 	.word	0x0000324d
    5f60:	0000b918 	.word	0x0000b918
    5f64:	0000469d 	.word	0x0000469d
    5f68:	00005561 	.word	0x00005561

00005f6c <dhcp_renew>:
{
    5f6c:	b573      	push	{r0, r1, r4, r5, r6, lr}
	struct dhcp *dhcp = netif->dhcp;
    5f6e:	6a44      	ldr	r4, [r0, #36]	; 0x24
	dhcp_set_state(dhcp, DHCP_RENEWING);
    5f70:	4b20      	ldr	r3, [pc, #128]	; (5ff4 <dhcp_renew+0x88>)
{
    5f72:	4606      	mov	r6, r0
	dhcp_set_state(dhcp, DHCP_RENEWING);
    5f74:	2105      	movs	r1, #5
    5f76:	4620      	mov	r0, r4
    5f78:	4798      	blx	r3
	result = dhcp_create_msg(netif, dhcp, DHCP_REQUEST);
    5f7a:	2203      	movs	r2, #3
    5f7c:	4b1e      	ldr	r3, [pc, #120]	; (5ff8 <dhcp_renew+0x8c>)
    5f7e:	4621      	mov	r1, r4
    5f80:	4630      	mov	r0, r6
    5f82:	4798      	blx	r3
	if (result == ERR_OK) {
    5f84:	4605      	mov	r5, r0
    5f86:	b9d0      	cbnz	r0, 5fbe <dhcp_renew+0x52>
		dhcp_option(dhcp, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
    5f88:	2202      	movs	r2, #2
    5f8a:	4620      	mov	r0, r4
    5f8c:	4b1b      	ldr	r3, [pc, #108]	; (5ffc <dhcp_renew+0x90>)
    5f8e:	2139      	movs	r1, #57	; 0x39
    5f90:	4798      	blx	r3
		dhcp_option_short(dhcp, DHCP_MAX_MSG_LEN(netif));
    5f92:	8d31      	ldrh	r1, [r6, #40]	; 0x28
    5f94:	4b1a      	ldr	r3, [pc, #104]	; (6000 <dhcp_renew+0x94>)
    5f96:	4798      	blx	r3
		dhcp_option_trailer(dhcp);
    5f98:	4b1a      	ldr	r3, [pc, #104]	; (6004 <dhcp_renew+0x98>)
    5f9a:	4798      	blx	r3
		pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
    5f9c:	8b21      	ldrh	r1, [r4, #24]
    5f9e:	6920      	ldr	r0, [r4, #16]
    5fa0:	4b19      	ldr	r3, [pc, #100]	; (6008 <dhcp_renew+0x9c>)
    5fa2:	31f0      	adds	r1, #240	; 0xf0
    5fa4:	b289      	uxth	r1, r1
    5fa6:	4798      	blx	r3
		udp_sendto_if(dhcp->pcb, dhcp->p_out, &dhcp->server_ip_addr, DHCP_SERVER_PORT, netif);
    5fa8:	9600      	str	r6, [sp, #0]
    5faa:	2343      	movs	r3, #67	; 0x43
    5fac:	6921      	ldr	r1, [r4, #16]
    5fae:	6860      	ldr	r0, [r4, #4]
    5fb0:	4e16      	ldr	r6, [pc, #88]	; (600c <dhcp_renew+0xa0>)
    5fb2:	f104 0220 	add.w	r2, r4, #32
    5fb6:	47b0      	blx	r6
		dhcp_delete_msg(dhcp);
    5fb8:	4b15      	ldr	r3, [pc, #84]	; (6010 <dhcp_renew+0xa4>)
    5fba:	4620      	mov	r0, r4
    5fbc:	4798      	blx	r3
	dhcp->tries++;
    5fbe:	7b63      	ldrb	r3, [r4, #13]
    5fc0:	3301      	adds	r3, #1
    5fc2:	b2db      	uxtb	r3, r3
	msecs                 = dhcp->tries < 10 ? dhcp->tries * 2000 : 20 * 1000;
    5fc4:	2b09      	cmp	r3, #9
    5fc6:	bf98      	it	ls
    5fc8:	ebc3 1243 	rsbls	r2, r3, r3, lsl #5
	dhcp->tries++;
    5fcc:	7363      	strb	r3, [r4, #13]
	msecs                 = dhcp->tries < 10 ? dhcp->tries * 2000 : 20 * 1000;
    5fce:	bf9d      	ittte	ls
    5fd0:	eb03 0382 	addls.w	r3, r3, r2, lsl #2
    5fd4:	011b      	lslls	r3, r3, #4
    5fd6:	b29b      	uxthls	r3, r3
    5fd8:	f644 6320 	movwhi	r3, #20000	; 0x4e20
	dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
    5fdc:	f44f 72fa 	mov.w	r2, #500	; 0x1f4
}
    5fe0:	4628      	mov	r0, r5
	dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
    5fe2:	f203 13f3 	addw	r3, r3, #499	; 0x1f3
    5fe6:	b29b      	uxth	r3, r3
    5fe8:	fbb3 f3f2 	udiv	r3, r3, r2
    5fec:	8363      	strh	r3, [r4, #26]
}
    5fee:	b002      	add	sp, #8
    5ff0:	bd70      	pop	{r4, r5, r6, pc}
    5ff2:	bf00      	nop
    5ff4:	000054a1 	.word	0x000054a1
    5ff8:	0000568d 	.word	0x0000568d
    5ffc:	000054b1 	.word	0x000054b1
    6000:	000054df 	.word	0x000054df
    6004:	00005533 	.word	0x00005533
    6008:	0000324d 	.word	0x0000324d
    600c:	0000469d 	.word	0x0000469d
    6010:	00005561 	.word	0x00005561

00006014 <dhcp_coarse_tmr>:
	struct netif *netif = netif_list;
    6014:	4b13      	ldr	r3, [pc, #76]	; (6064 <dhcp_coarse_tmr+0x50>)
{
    6016:	b570      	push	{r4, r5, r6, lr}
	struct netif *netif = netif_list;
    6018:	681c      	ldr	r4, [r3, #0]
		dhcp_renew(netif);
    601a:	4d13      	ldr	r5, [pc, #76]	; (6068 <dhcp_coarse_tmr+0x54>)
		dhcp_rebind(netif);
    601c:	4e13      	ldr	r6, [pc, #76]	; (606c <dhcp_coarse_tmr+0x58>)
	while (netif != NULL) {
    601e:	b904      	cbnz	r4, 6022 <dhcp_coarse_tmr+0xe>
}
    6020:	bd70      	pop	{r4, r5, r6, pc}
		if (netif->dhcp != NULL) {
    6022:	6a63      	ldr	r3, [r4, #36]	; 0x24
    6024:	b16b      	cbz	r3, 6042 <dhcp_coarse_tmr+0x2e>
			if (netif->dhcp->t2_timeout-- == 1) {
    6026:	8bda      	ldrh	r2, [r3, #30]
    6028:	1e51      	subs	r1, r2, #1
    602a:	2a01      	cmp	r2, #1
    602c:	83d9      	strh	r1, [r3, #30]
    602e:	d10a      	bne.n	6046 <dhcp_coarse_tmr+0x32>
	if ((dhcp->state == DHCP_REQUESTING) || (dhcp->state == DHCP_BOUND) || (dhcp->state == DHCP_RENEWING)) {
    6030:	7b1b      	ldrb	r3, [r3, #12]
    6032:	f003 02fb 	and.w	r2, r3, #251	; 0xfb
    6036:	2a01      	cmp	r2, #1
    6038:	d001      	beq.n	603e <dhcp_coarse_tmr+0x2a>
    603a:	2b0a      	cmp	r3, #10
    603c:	d101      	bne.n	6042 <dhcp_coarse_tmr+0x2e>
		dhcp_rebind(netif);
    603e:	4620      	mov	r0, r4
    6040:	47b0      	blx	r6
		netif = netif->next;
    6042:	6824      	ldr	r4, [r4, #0]
    6044:	e7eb      	b.n	601e <dhcp_coarse_tmr+0xa>
			} else if (netif->dhcp->t1_timeout-- == 1) {
    6046:	8b9a      	ldrh	r2, [r3, #28]
    6048:	1e51      	subs	r1, r2, #1
    604a:	2a01      	cmp	r2, #1
    604c:	8399      	strh	r1, [r3, #28]
    604e:	d1f8      	bne.n	6042 <dhcp_coarse_tmr+0x2e>
	if ((dhcp->state == DHCP_REQUESTING) || (dhcp->state == DHCP_BOUND) || (dhcp->state == DHCP_RENEWING)) {
    6050:	7b1b      	ldrb	r3, [r3, #12]
    6052:	f003 02fb 	and.w	r2, r3, #251	; 0xfb
    6056:	2a01      	cmp	r2, #1
    6058:	d001      	beq.n	605e <dhcp_coarse_tmr+0x4a>
    605a:	2b0a      	cmp	r3, #10
    605c:	d1f1      	bne.n	6042 <dhcp_coarse_tmr+0x2e>
		dhcp_renew(netif);
    605e:	4620      	mov	r0, r4
    6060:	47a8      	blx	r5
    6062:	e7ee      	b.n	6042 <dhcp_coarse_tmr+0x2e>
    6064:	200163e4 	.word	0x200163e4
    6068:	00005f6d 	.word	0x00005f6d
    606c:	00005945 	.word	0x00005945

00006070 <dhcp_release>:
{
    6070:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
	struct dhcp *dhcp = netif->dhcp;
    6072:	6a44      	ldr	r4, [r0, #36]	; 0x24
	dhcp_set_state(dhcp, DHCP_OFF);
    6074:	4b27      	ldr	r3, [pc, #156]	; (6114 <dhcp_release+0xa4>)
    6076:	2100      	movs	r1, #0
{
    6078:	4605      	mov	r5, r0
	dhcp_set_state(dhcp, DHCP_OFF);
    607a:	4620      	mov	r0, r4
    607c:	4798      	blx	r3
	result = dhcp_create_msg(netif, dhcp, DHCP_RELEASE);
    607e:	2207      	movs	r2, #7
	ip_addr_set_zero(&dhcp->offered_ip_addr);
    6080:	e9c4 1108 	strd	r1, r1, [r4, #32]
	ip_addr_set_zero(&dhcp->offered_gw_addr);
    6084:	e9c4 110a 	strd	r1, r1, [r4, #40]	; 0x28
	dhcp->offered_t0_lease = dhcp->offered_t1_renew = dhcp->offered_t2_rebind = 0;
    6088:	e9c4 110d 	strd	r1, r1, [r4, #52]	; 0x34
    608c:	6321      	str	r1, [r4, #48]	; 0x30
	result = dhcp_create_msg(netif, dhcp, DHCP_RELEASE);
    608e:	4b22      	ldr	r3, [pc, #136]	; (6118 <dhcp_release+0xa8>)
    6090:	4621      	mov	r1, r4
    6092:	4628      	mov	r0, r5
    6094:	4798      	blx	r3
	if (result == ERR_OK) {
    6096:	4606      	mov	r6, r0
    6098:	b998      	cbnz	r0, 60c2 <dhcp_release+0x52>
		dhcp_option_trailer(dhcp);
    609a:	4b20      	ldr	r3, [pc, #128]	; (611c <dhcp_release+0xac>)
		udp_sendto_if(dhcp->pcb, dhcp->p_out, &dhcp->server_ip_addr, DHCP_SERVER_PORT, netif);
    609c:	4f20      	ldr	r7, [pc, #128]	; (6120 <dhcp_release+0xb0>)
		dhcp_option_trailer(dhcp);
    609e:	4620      	mov	r0, r4
    60a0:	4798      	blx	r3
		pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
    60a2:	8b21      	ldrh	r1, [r4, #24]
    60a4:	6920      	ldr	r0, [r4, #16]
    60a6:	4b1f      	ldr	r3, [pc, #124]	; (6124 <dhcp_release+0xb4>)
    60a8:	31f0      	adds	r1, #240	; 0xf0
    60aa:	b289      	uxth	r1, r1
    60ac:	4798      	blx	r3
		udp_sendto_if(dhcp->pcb, dhcp->p_out, &dhcp->server_ip_addr, DHCP_SERVER_PORT, netif);
    60ae:	9500      	str	r5, [sp, #0]
    60b0:	2343      	movs	r3, #67	; 0x43
    60b2:	6921      	ldr	r1, [r4, #16]
    60b4:	6860      	ldr	r0, [r4, #4]
    60b6:	f104 0220 	add.w	r2, r4, #32
    60ba:	47b8      	blx	r7
		dhcp_delete_msg(dhcp);
    60bc:	4b1a      	ldr	r3, [pc, #104]	; (6128 <dhcp_release+0xb8>)
    60be:	4620      	mov	r0, r4
    60c0:	4798      	blx	r3
	dhcp->tries++;
    60c2:	7b63      	ldrb	r3, [r4, #13]
    60c4:	3301      	adds	r3, #1
    60c6:	b2db      	uxtb	r3, r3
	msecs                 = dhcp->tries < 10 ? dhcp->tries * 1000 : 10 * 1000;
    60c8:	2b09      	cmp	r3, #9
    60ca:	bf98      	it	ls
    60cc:	ebc3 1243 	rsbls	r2, r3, r3, lsl #5
	dhcp->tries++;
    60d0:	7363      	strb	r3, [r4, #13]
	msecs                 = dhcp->tries < 10 ? dhcp->tries * 1000 : 10 * 1000;
    60d2:	bf9d      	ittte	ls
    60d4:	eb03 0382 	addls.w	r3, r3, r2, lsl #2
    60d8:	00db      	lslls	r3, r3, #3
    60da:	b29b      	uxthls	r3, r3
    60dc:	f242 7310 	movwhi	r3, #10000	; 0x2710
	dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
    60e0:	f203 13f3 	addw	r3, r3, #499	; 0x1f3
    60e4:	f44f 72fa 	mov.w	r2, #500	; 0x1f4
	netif_set_down(netif);
    60e8:	4628      	mov	r0, r5
	dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
    60ea:	b29b      	uxth	r3, r3
    60ec:	fbb3 f3f2 	udiv	r3, r3, r2
    60f0:	8363      	strh	r3, [r4, #26]
	netif_set_down(netif);
    60f2:	4b0e      	ldr	r3, [pc, #56]	; (612c <dhcp_release+0xbc>)
    60f4:	4798      	blx	r3
	netif_set_ipaddr(netif, IP_ADDR_ANY);
    60f6:	4628      	mov	r0, r5
    60f8:	490d      	ldr	r1, [pc, #52]	; (6130 <dhcp_release+0xc0>)
    60fa:	4b0e      	ldr	r3, [pc, #56]	; (6134 <dhcp_release+0xc4>)
    60fc:	4798      	blx	r3
	netif_set_gw(netif, IP_ADDR_ANY);
    60fe:	4628      	mov	r0, r5
    6100:	490b      	ldr	r1, [pc, #44]	; (6130 <dhcp_release+0xc0>)
    6102:	4b0d      	ldr	r3, [pc, #52]	; (6138 <dhcp_release+0xc8>)
    6104:	4798      	blx	r3
	netif_set_netmask(netif, IP_ADDR_ANY);
    6106:	4628      	mov	r0, r5
    6108:	4909      	ldr	r1, [pc, #36]	; (6130 <dhcp_release+0xc0>)
    610a:	4b0c      	ldr	r3, [pc, #48]	; (613c <dhcp_release+0xcc>)
    610c:	4798      	blx	r3
}
    610e:	4630      	mov	r0, r6
    6110:	b003      	add	sp, #12
    6112:	bdf0      	pop	{r4, r5, r6, r7, pc}
    6114:	000054a1 	.word	0x000054a1
    6118:	0000568d 	.word	0x0000568d
    611c:	00005533 	.word	0x00005533
    6120:	0000469d 	.word	0x0000469d
    6124:	0000324d 	.word	0x0000324d
    6128:	00005561 	.word	0x00005561
    612c:	0000a0cd 	.word	0x0000a0cd
    6130:	0000b91c 	.word	0x0000b91c
    6134:	00009fb5 	.word	0x00009fb5
    6138:	0000a079 	.word	0x0000a079
    613c:	0000a081 	.word	0x0000a081

00006140 <dhcp_fine_tmr>:
{
    6140:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	struct netif *netif = netif_list;
    6142:	4b22      	ldr	r3, [pc, #136]	; (61cc <dhcp_fine_tmr+0x8c>)
		dhcp_discover(netif);
    6144:	4d22      	ldr	r5, [pc, #136]	; (61d0 <dhcp_fine_tmr+0x90>)
	struct netif *netif = netif_list;
    6146:	681c      	ldr	r4, [r3, #0]
			dhcp_reboot(netif);
    6148:	4f22      	ldr	r7, [pc, #136]	; (61d4 <dhcp_fine_tmr+0x94>)
			dhcp_release(netif);
    614a:	4e23      	ldr	r6, [pc, #140]	; (61d8 <dhcp_fine_tmr+0x98>)
	while (netif != NULL) {
    614c:	b904      	cbnz	r4, 6150 <dhcp_fine_tmr+0x10>
}
    614e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		if (netif->dhcp != NULL) {
    6150:	6a63      	ldr	r3, [r4, #36]	; 0x24
    6152:	b123      	cbz	r3, 615e <dhcp_fine_tmr+0x1e>
			if (netif->dhcp->request_timeout > 1) {
    6154:	8b5a      	ldrh	r2, [r3, #26]
    6156:	2a01      	cmp	r2, #1
    6158:	d903      	bls.n	6162 <dhcp_fine_tmr+0x22>
				netif->dhcp->request_timeout--;
    615a:	3a01      	subs	r2, #1
    615c:	835a      	strh	r2, [r3, #26]
		netif = netif->next;
    615e:	6824      	ldr	r4, [r4, #0]
    6160:	e7f4      	b.n	614c <dhcp_fine_tmr+0xc>
			} else if (netif->dhcp->request_timeout == 1) {
    6162:	d1fc      	bne.n	615e <dhcp_fine_tmr+0x1e>
				netif->dhcp->request_timeout--;
    6164:	2200      	movs	r2, #0
    6166:	835a      	strh	r2, [r3, #26]
	if ((dhcp->state == DHCP_BACKING_OFF) || (dhcp->state == DHCP_SELECTING)) {
    6168:	7b1a      	ldrb	r2, [r3, #12]
    616a:	2a0c      	cmp	r2, #12
    616c:	d001      	beq.n	6172 <dhcp_fine_tmr+0x32>
    616e:	2a06      	cmp	r2, #6
    6170:	d102      	bne.n	6178 <dhcp_fine_tmr+0x38>
			dhcp_discover(netif);
    6172:	4620      	mov	r0, r4
			dhcp_discover(netif);
    6174:	47a8      	blx	r5
    6176:	e7f2      	b.n	615e <dhcp_fine_tmr+0x1e>
	} else if (dhcp->state == DHCP_REQUESTING) {
    6178:	2a01      	cmp	r2, #1
    617a:	d106      	bne.n	618a <dhcp_fine_tmr+0x4a>
		if (dhcp->tries <= 5) {
    617c:	7b5b      	ldrb	r3, [r3, #13]
    617e:	2b05      	cmp	r3, #5
			dhcp_select(netif);
    6180:	4620      	mov	r0, r4
		if (dhcp->tries <= 5) {
    6182:	d819      	bhi.n	61b8 <dhcp_fine_tmr+0x78>
			dhcp_select(netif);
    6184:	4b15      	ldr	r3, [pc, #84]	; (61dc <dhcp_fine_tmr+0x9c>)
			dhcp_rebind(netif);
    6186:	4798      	blx	r3
    6188:	e7e9      	b.n	615e <dhcp_fine_tmr+0x1e>
	} else if (dhcp->state == DHCP_CHECKING) {
    618a:	2a08      	cmp	r2, #8
    618c:	d106      	bne.n	619c <dhcp_fine_tmr+0x5c>
		if (dhcp->tries <= 1) {
    618e:	7b5b      	ldrb	r3, [r3, #13]
    6190:	2b01      	cmp	r3, #1
			dhcp_check(netif);
    6192:	bf94      	ite	ls
    6194:	4b12      	ldrls	r3, [pc, #72]	; (61e0 <dhcp_fine_tmr+0xa0>)
			dhcp_bind(netif);
    6196:	4b13      	ldrhi	r3, [pc, #76]	; (61e4 <dhcp_fine_tmr+0xa4>)
			dhcp_check(netif);
    6198:	4620      	mov	r0, r4
    619a:	e7f4      	b.n	6186 <dhcp_fine_tmr+0x46>
	else if (dhcp->state == DHCP_RENEWING) {
    619c:	2a05      	cmp	r2, #5
    619e:	d103      	bne.n	61a8 <dhcp_fine_tmr+0x68>
		dhcp_renew(netif);
    61a0:	4b11      	ldr	r3, [pc, #68]	; (61e8 <dhcp_fine_tmr+0xa8>)
    61a2:	4620      	mov	r0, r4
    61a4:	4798      	blx	r3
    61a6:	e7da      	b.n	615e <dhcp_fine_tmr+0x1e>
	} else if (dhcp->state == DHCP_REBINDING) {
    61a8:	2a04      	cmp	r2, #4
    61aa:	d107      	bne.n	61bc <dhcp_fine_tmr+0x7c>
		if (dhcp->tries <= 8) {
    61ac:	7b5b      	ldrb	r3, [r3, #13]
    61ae:	2b08      	cmp	r3, #8
			dhcp_rebind(netif);
    61b0:	4620      	mov	r0, r4
		if (dhcp->tries <= 8) {
    61b2:	d801      	bhi.n	61b8 <dhcp_fine_tmr+0x78>
			dhcp_rebind(netif);
    61b4:	4b0d      	ldr	r3, [pc, #52]	; (61ec <dhcp_fine_tmr+0xac>)
    61b6:	e7e6      	b.n	6186 <dhcp_fine_tmr+0x46>
			dhcp_release(netif);
    61b8:	47b0      	blx	r6
    61ba:	e7da      	b.n	6172 <dhcp_fine_tmr+0x32>
	} else if (dhcp->state == DHCP_REBOOTING) {
    61bc:	2a03      	cmp	r2, #3
    61be:	d1ce      	bne.n	615e <dhcp_fine_tmr+0x1e>
		if (dhcp->tries < REBOOT_TRIES) {
    61c0:	7b5b      	ldrb	r3, [r3, #13]
    61c2:	2b01      	cmp	r3, #1
			dhcp_reboot(netif);
    61c4:	4620      	mov	r0, r4
		if (dhcp->tries < REBOOT_TRIES) {
    61c6:	d8d5      	bhi.n	6174 <dhcp_fine_tmr+0x34>
			dhcp_reboot(netif);
    61c8:	47b8      	blx	r7
    61ca:	e7c8      	b.n	615e <dhcp_fine_tmr+0x1e>
    61cc:	200163e4 	.word	0x200163e4
    61d0:	000057bd 	.word	0x000057bd
    61d4:	00005881 	.word	0x00005881
    61d8:	00006071 	.word	0x00006071
    61dc:	000059e9 	.word	0x000059e9
    61e0:	0000557d 	.word	0x0000557d
    61e4:	000055ad 	.word	0x000055ad
    61e8:	00005f6d 	.word	0x00005f6d
    61ec:	00005945 	.word	0x00005945

000061f0 <dhcp_stop>:
{
    61f0:	b510      	push	{r4, lr}
	LWIP_ERROR("dhcp_stop: netif != NULL", (netif != NULL), return;);
    61f2:	b900      	cbnz	r0, 61f6 <dhcp_stop+0x6>
    61f4:	e7fe      	b.n	61f4 <dhcp_stop+0x4>
	netif->flags &= ~NETIF_FLAG_DHCP;
    61f6:	f890 3031 	ldrb.w	r3, [r0, #49]	; 0x31
	dhcp = netif->dhcp;
    61fa:	6a44      	ldr	r4, [r0, #36]	; 0x24
	netif->flags &= ~NETIF_FLAG_DHCP;
    61fc:	f023 0308 	bic.w	r3, r3, #8
    6200:	f880 3031 	strb.w	r3, [r0, #49]	; 0x31
	if (dhcp != NULL) {
    6204:	b15c      	cbz	r4, 621e <dhcp_stop+0x2e>
		if (dhcp->pcb != NULL) {
    6206:	6860      	ldr	r0, [r4, #4]
    6208:	b118      	cbz	r0, 6212 <dhcp_stop+0x22>
			udp_remove(dhcp->pcb);
    620a:	4b05      	ldr	r3, [pc, #20]	; (6220 <dhcp_stop+0x30>)
    620c:	4798      	blx	r3
			dhcp->pcb = NULL;
    620e:	2300      	movs	r3, #0
    6210:	6063      	str	r3, [r4, #4]
		dhcp_set_state(dhcp, DHCP_OFF);
    6212:	4620      	mov	r0, r4
    6214:	4b03      	ldr	r3, [pc, #12]	; (6224 <dhcp_stop+0x34>)
}
    6216:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		dhcp_set_state(dhcp, DHCP_OFF);
    621a:	2100      	movs	r1, #0
    621c:	4718      	bx	r3
}
    621e:	bd10      	pop	{r4, pc}
    6220:	0000484d 	.word	0x0000484d
    6224:	000054a1 	.word	0x000054a1

00006228 <dhcp_start>:
{
    6228:	b538      	push	{r3, r4, r5, lr}
	LWIP_ERROR("netif != NULL", (netif != NULL), return ERR_ARG;);
    622a:	4604      	mov	r4, r0
    622c:	b900      	cbnz	r0, 6230 <dhcp_start+0x8>
    622e:	e7fe      	b.n	622e <dhcp_start+0x6>
	netif->flags &= ~NETIF_FLAG_DHCP;
    6230:	f890 3031 	ldrb.w	r3, [r0, #49]	; 0x31
	dhcp = netif->dhcp;
    6234:	6a45      	ldr	r5, [r0, #36]	; 0x24
	netif->flags &= ~NETIF_FLAG_DHCP;
    6236:	f023 0208 	bic.w	r2, r3, #8
	if ((netif->flags & NETIF_FLAG_ETHARP) == 0) {
    623a:	069b      	lsls	r3, r3, #26
	netif->flags &= ~NETIF_FLAG_DHCP;
    623c:	f880 2031 	strb.w	r2, [r0, #49]	; 0x31
	if ((netif->flags & NETIF_FLAG_ETHARP) == 0) {
    6240:	d540      	bpl.n	62c4 <dhcp_start+0x9c>
	if (netif->mtu < DHCP_MAX_MSG_LEN_MIN_REQUIRED) {
    6242:	8d03      	ldrh	r3, [r0, #40]	; 0x28
    6244:	f5b3 7f10 	cmp.w	r3, #576	; 0x240
    6248:	d202      	bcs.n	6250 <dhcp_start+0x28>
		return ERR_MEM;
    624a:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
}
    624e:	bd38      	pop	{r3, r4, r5, pc}
	if (dhcp == NULL) {
    6250:	2d00      	cmp	r5, #0
    6252:	d12a      	bne.n	62aa <dhcp_start+0x82>
		dhcp = (struct dhcp *)mem_malloc(sizeof(struct dhcp));
    6254:	4b1d      	ldr	r3, [pc, #116]	; (62cc <dhcp_start+0xa4>)
    6256:	203c      	movs	r0, #60	; 0x3c
    6258:	4798      	blx	r3
		if (dhcp == NULL) {
    625a:	4605      	mov	r5, r0
    625c:	2800      	cmp	r0, #0
    625e:	d0f4      	beq.n	624a <dhcp_start+0x22>
		netif->dhcp = dhcp;
    6260:	6260      	str	r0, [r4, #36]	; 0x24
	memset(dhcp, 0, sizeof(struct dhcp));
    6262:	4b1b      	ldr	r3, [pc, #108]	; (62d0 <dhcp_start+0xa8>)
    6264:	223c      	movs	r2, #60	; 0x3c
    6266:	2100      	movs	r1, #0
    6268:	4628      	mov	r0, r5
    626a:	4798      	blx	r3
	dhcp->pcb = udp_new();
    626c:	4b19      	ldr	r3, [pc, #100]	; (62d4 <dhcp_start+0xac>)
    626e:	4798      	blx	r3
    6270:	6068      	str	r0, [r5, #4]
	if (dhcp->pcb == NULL) {
    6272:	2800      	cmp	r0, #0
    6274:	d0e9      	beq.n	624a <dhcp_start+0x22>
	ip_set_option(dhcp->pcb, SOF_BROADCAST);
    6276:	7a02      	ldrb	r2, [r0, #8]
	udp_bind(dhcp->pcb, IP_ADDR_ANY, DHCP_CLIENT_PORT);
    6278:	4917      	ldr	r1, [pc, #92]	; (62d8 <dhcp_start+0xb0>)
    627a:	4b18      	ldr	r3, [pc, #96]	; (62dc <dhcp_start+0xb4>)
	ip_set_option(dhcp->pcb, SOF_BROADCAST);
    627c:	f042 0220 	orr.w	r2, r2, #32
    6280:	7202      	strb	r2, [r0, #8]
	udp_bind(dhcp->pcb, IP_ADDR_ANY, DHCP_CLIENT_PORT);
    6282:	2244      	movs	r2, #68	; 0x44
    6284:	4798      	blx	r3
	udp_connect(dhcp->pcb, IP_ADDR_ANY, DHCP_SERVER_PORT);
    6286:	4914      	ldr	r1, [pc, #80]	; (62d8 <dhcp_start+0xb0>)
    6288:	4b15      	ldr	r3, [pc, #84]	; (62e0 <dhcp_start+0xb8>)
    628a:	6868      	ldr	r0, [r5, #4]
    628c:	2243      	movs	r2, #67	; 0x43
    628e:	4798      	blx	r3
	udp_recv(dhcp->pcb, dhcp_recv, netif);
    6290:	6868      	ldr	r0, [r5, #4]
    6292:	4b14      	ldr	r3, [pc, #80]	; (62e4 <dhcp_start+0xbc>)
    6294:	4914      	ldr	r1, [pc, #80]	; (62e8 <dhcp_start+0xc0>)
    6296:	4622      	mov	r2, r4
    6298:	4798      	blx	r3
	result = dhcp_discover(netif);
    629a:	4b14      	ldr	r3, [pc, #80]	; (62ec <dhcp_start+0xc4>)
    629c:	4620      	mov	r0, r4
    629e:	4798      	blx	r3
	if (result != ERR_OK) {
    62a0:	b148      	cbz	r0, 62b6 <dhcp_start+0x8e>
		dhcp_stop(netif);
    62a2:	4b13      	ldr	r3, [pc, #76]	; (62f0 <dhcp_start+0xc8>)
    62a4:	4620      	mov	r0, r4
    62a6:	4798      	blx	r3
    62a8:	e7cf      	b.n	624a <dhcp_start+0x22>
		if (dhcp->pcb != NULL) {
    62aa:	6868      	ldr	r0, [r5, #4]
    62ac:	2800      	cmp	r0, #0
    62ae:	d0d8      	beq.n	6262 <dhcp_start+0x3a>
			udp_remove(dhcp->pcb);
    62b0:	4b10      	ldr	r3, [pc, #64]	; (62f4 <dhcp_start+0xcc>)
    62b2:	4798      	blx	r3
    62b4:	e7d5      	b.n	6262 <dhcp_start+0x3a>
	netif->flags |= NETIF_FLAG_DHCP;
    62b6:	f894 3031 	ldrb.w	r3, [r4, #49]	; 0x31
    62ba:	f043 0308 	orr.w	r3, r3, #8
    62be:	f884 3031 	strb.w	r3, [r4, #49]	; 0x31
	return result;
    62c2:	e7c4      	b.n	624e <dhcp_start+0x26>
		return ERR_ARG;
    62c4:	f06f 000d 	mvn.w	r0, #13
    62c8:	e7c1      	b.n	624e <dhcp_start+0x26>
    62ca:	bf00      	nop
    62cc:	00006805 	.word	0x00006805
    62d0:	0000a365 	.word	0x0000a365
    62d4:	0000487d 	.word	0x0000487d
    62d8:	0000b91c 	.word	0x0000b91c
    62dc:	00004615 	.word	0x00004615
    62e0:	000047f9 	.word	0x000047f9
    62e4:	00004845 	.word	0x00004845
    62e8:	00005ad9 	.word	0x00005ad9
    62ec:	000057bd 	.word	0x000057bd
    62f0:	000061f1 	.word	0x000061f1
    62f4:	0000484d 	.word	0x0000484d

000062f8 <io_write>:

/**
 * \brief I/O write interface
 */
int32_t io_write(struct io_descriptor *const io_descr, const uint8_t *const buf, const uint16_t length)
{
    62f8:	b570      	push	{r4, r5, r6, lr}
    62fa:	460d      	mov	r5, r1
    62fc:	4616      	mov	r6, r2
	ASSERT(io_descr && buf);
    62fe:	4604      	mov	r4, r0
    6300:	b110      	cbz	r0, 6308 <io_write+0x10>
    6302:	1e08      	subs	r0, r1, #0
    6304:	bf18      	it	ne
    6306:	2001      	movne	r0, #1
    6308:	4905      	ldr	r1, [pc, #20]	; (6320 <io_write+0x28>)
    630a:	4b06      	ldr	r3, [pc, #24]	; (6324 <io_write+0x2c>)
    630c:	2234      	movs	r2, #52	; 0x34
    630e:	4798      	blx	r3
	return io_descr->write(io_descr, buf, length);
    6310:	6823      	ldr	r3, [r4, #0]
    6312:	4632      	mov	r2, r6
    6314:	4629      	mov	r1, r5
    6316:	4620      	mov	r0, r4
}
    6318:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	return io_descr->write(io_descr, buf, length);
    631c:	4718      	bx	r3
    631e:	bf00      	nop
    6320:	0000b6e6 	.word	0x0000b6e6
    6324:	00008a15 	.word	0x00008a15

00006328 <io_read>:

/**
 * \brief I/O read interface
 */
int32_t io_read(struct io_descriptor *const io_descr, uint8_t *const buf, const uint16_t length)
{
    6328:	b570      	push	{r4, r5, r6, lr}
    632a:	460d      	mov	r5, r1
    632c:	4616      	mov	r6, r2
	ASSERT(io_descr && buf);
    632e:	4604      	mov	r4, r0
    6330:	b110      	cbz	r0, 6338 <io_read+0x10>
    6332:	1e08      	subs	r0, r1, #0
    6334:	bf18      	it	ne
    6336:	2001      	movne	r0, #1
    6338:	4905      	ldr	r1, [pc, #20]	; (6350 <io_read+0x28>)
    633a:	4b06      	ldr	r3, [pc, #24]	; (6354 <io_read+0x2c>)
    633c:	223d      	movs	r2, #61	; 0x3d
    633e:	4798      	blx	r3
	return io_descr->read(io_descr, buf, length);
    6340:	6863      	ldr	r3, [r4, #4]
    6342:	4632      	mov	r2, r6
    6344:	4629      	mov	r1, r5
    6346:	4620      	mov	r0, r4
}
    6348:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	return io_descr->read(io_descr, buf, length);
    634c:	4718      	bx	r3
    634e:	bf00      	nop
    6350:	0000b6e6 	.word	0x0000b6e6
    6354:	00008a15 	.word	0x00008a15

00006358 <ip_route>:
		return netif;
	}
#endif

	/* iterate through netifs */
	for (netif = netif_list; netif != NULL; netif = netif->next) {
    6358:	4a0c      	ldr	r2, [pc, #48]	; (638c <ip_route+0x34>)
{
    635a:	4603      	mov	r3, r0
	for (netif = netif_list; netif != NULL; netif = netif->next) {
    635c:	6810      	ldr	r0, [r2, #0]
    635e:	b948      	cbnz	r0, 6374 <ip_route+0x1c>
				/* return netif on which to forward IP packet */
				return netif;
			}
		}
	}
	if ((netif_default == NULL) || (!netif_is_up(netif_default))) {
    6360:	4b0b      	ldr	r3, [pc, #44]	; (6390 <ip_route+0x38>)
    6362:	681b      	ldr	r3, [r3, #0]
    6364:	b12b      	cbz	r3, 6372 <ip_route+0x1a>
    6366:	f893 2031 	ldrb.w	r2, [r3, #49]	; 0x31
    636a:	f012 0f01 	tst.w	r2, #1
    636e:	bf18      	it	ne
    6370:	4618      	movne	r0, r3
		snmp_inc_ipoutnoroutes();
		return NULL;
	}
	/* no matching netif found, use default netif */
	return netif_default;
}
    6372:	4770      	bx	lr
		if (netif_is_up(netif)) {
    6374:	f890 2031 	ldrb.w	r2, [r0, #49]	; 0x31
    6378:	07d2      	lsls	r2, r2, #31
    637a:	d505      	bpl.n	6388 <ip_route+0x30>
			if (ip_addr_netcmp(dest, &(netif->ip_addr), &(netif->netmask))) {
    637c:	6841      	ldr	r1, [r0, #4]
    637e:	681a      	ldr	r2, [r3, #0]
    6380:	404a      	eors	r2, r1
    6382:	6881      	ldr	r1, [r0, #8]
    6384:	420a      	tst	r2, r1
    6386:	d0f4      	beq.n	6372 <ip_route+0x1a>
	for (netif = netif_list; netif != NULL; netif = netif->next) {
    6388:	6800      	ldr	r0, [r0, #0]
    638a:	e7e8      	b.n	635e <ip_route+0x6>
    638c:	200163e4 	.word	0x200163e4
    6390:	200163ec 	.word	0x200163ec

00006394 <ip_input>:
 * @param inp the netif on which this packet was received
 * @return ERR_OK if the packet was processed (could return ERR_* if it wasn't
 *         processed, but currently always returns ERR_OK)
 */
err_t ip_input(struct pbuf *p, struct netif *inp)
{
    6394:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}

	IP_STATS_INC(ip.recv);
	snmp_inc_ipinreceives();

	/* identify the IP header */
	iphdr = (struct ip_hdr *)p->payload;
    6398:	6846      	ldr	r6, [r0, #4]
	if (IPH_V(iphdr) != 4) {
    639a:	f896 9000 	ldrb.w	r9, [r6]
    639e:	ea4f 1319 	mov.w	r3, r9, lsr #4
    63a2:	2b04      	cmp	r3, #4
{
    63a4:	4604      	mov	r4, r0
    63a6:	4688      	mov	r8, r1
	if (IPH_V(iphdr) != 4) {
    63a8:	d005      	beq.n	63b6 <ip_input+0x22>
		LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_LEVEL_WARNING,
		            ("IP packet dropped due to bad version number %" U16_F "\n", IPH_V(iphdr)));
		ip_debug_print(p);
		pbuf_free(p);
    63aa:	4b4c      	ldr	r3, [pc, #304]	; (64dc <ip_input+0x148>)
    63ac:	4620      	mov	r0, r4
    63ae:	4798      	blx	r3
	current_header = NULL;
	ip_addr_set_any(&current_iphdr_src);
	ip_addr_set_any(&current_iphdr_dest);

	return ERR_OK;
}
    63b0:	2000      	movs	r0, #0
    63b2:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
	iphdr_len = ntohs(IPH_LEN(iphdr));
    63b6:	4b4a      	ldr	r3, [pc, #296]	; (64e0 <ip_input+0x14c>)
    63b8:	8870      	ldrh	r0, [r6, #2]
    63ba:	4798      	blx	r3
	iphdr_hlen = IPH_HL(iphdr);
    63bc:	f009 090f 	and.w	r9, r9, #15
	if ((iphdr_hlen > p->len) || (iphdr_len > p->tot_len)) {
    63c0:	8963      	ldrh	r3, [r4, #10]
	iphdr_hlen *= 4;
    63c2:	ea4f 0989 	mov.w	r9, r9, lsl #2
	if ((iphdr_hlen > p->len) || (iphdr_len > p->tot_len)) {
    63c6:	454b      	cmp	r3, r9
	iphdr_len = ntohs(IPH_LEN(iphdr));
    63c8:	4605      	mov	r5, r0
	if ((iphdr_hlen > p->len) || (iphdr_len > p->tot_len)) {
    63ca:	d3ee      	bcc.n	63aa <ip_input+0x16>
    63cc:	8923      	ldrh	r3, [r4, #8]
    63ce:	4283      	cmp	r3, r0
    63d0:	d3eb      	bcc.n	63aa <ip_input+0x16>
	if (inet_chksum(iphdr, iphdr_hlen) != 0) {
    63d2:	4b44      	ldr	r3, [pc, #272]	; (64e4 <ip_input+0x150>)
    63d4:	4649      	mov	r1, r9
    63d6:	4630      	mov	r0, r6
    63d8:	4798      	blx	r3
    63da:	2800      	cmp	r0, #0
    63dc:	d1e5      	bne.n	63aa <ip_input+0x16>
	pbuf_realloc(p, iphdr_len);
    63de:	4b42      	ldr	r3, [pc, #264]	; (64e8 <ip_input+0x154>)
				netif = netif_list;
    63e0:	f8df b124 	ldr.w	fp, [pc, #292]	; 6508 <ip_input+0x174>
	pbuf_realloc(p, iphdr_len);
    63e4:	4629      	mov	r1, r5
    63e6:	4620      	mov	r0, r4
	ip_addr_copy(current_iphdr_dest, iphdr->dest);
    63e8:	4d40      	ldr	r5, [pc, #256]	; (64ec <ip_input+0x158>)
	pbuf_realloc(p, iphdr_len);
    63ea:	4798      	blx	r3
	ip_addr_copy(current_iphdr_dest, iphdr->dest);
    63ec:	6933      	ldr	r3, [r6, #16]
    63ee:	602b      	str	r3, [r5, #0]
	ip_addr_copy(current_iphdr_src, iphdr->src);
    63f0:	68f3      	ldr	r3, [r6, #12]
    63f2:	606b      	str	r3, [r5, #4]
				    ip_addr_isbroadcast(&current_iphdr_dest, netif)) {
    63f4:	4b3e      	ldr	r3, [pc, #248]	; (64f0 <ip_input+0x15c>)
	ip_addr_copy(current_iphdr_src, iphdr->src);
    63f6:	4647      	mov	r7, r8
		int first = 1;
    63f8:	f04f 0a01 	mov.w	sl, #1
			if ((netif_is_up(netif)) && (!ip_addr_isany(&(netif->ip_addr)))) {
    63fc:	f897 2031 	ldrb.w	r2, [r7, #49]	; 0x31
    6400:	07d2      	lsls	r2, r2, #31
    6402:	d404      	bmi.n	640e <ip_input+0x7a>
			if (first) {
    6404:	f1ba 0f00 	cmp.w	sl, #0
    6408:	d132      	bne.n	6470 <ip_input+0xdc>
				netif = netif->next;
    640a:	683f      	ldr	r7, [r7, #0]
    640c:	e032      	b.n	6474 <ip_input+0xe0>
			if ((netif_is_up(netif)) && (!ip_addr_isany(&(netif->ip_addr)))) {
    640e:	687a      	ldr	r2, [r7, #4]
    6410:	2a00      	cmp	r2, #0
    6412:	d0f7      	beq.n	6404 <ip_input+0x70>
				if (ip_addr_cmp(&current_iphdr_dest, &(netif->ip_addr)) ||
    6414:	6828      	ldr	r0, [r5, #0]
    6416:	4282      	cmp	r2, r0
    6418:	d004      	beq.n	6424 <ip_input+0x90>
				    ip_addr_isbroadcast(&current_iphdr_dest, netif)) {
    641a:	4639      	mov	r1, r7
    641c:	4798      	blx	r3
				if (ip_addr_cmp(&current_iphdr_dest, &(netif->ip_addr)) ||
    641e:	4b34      	ldr	r3, [pc, #208]	; (64f0 <ip_input+0x15c>)
    6420:	2800      	cmp	r0, #0
    6422:	d0ef      	beq.n	6404 <ip_input+0x70>
	if (check_ip_src && !ip_addr_isany(&current_iphdr_src))
    6424:	6868      	ldr	r0, [r5, #4]
    6426:	b148      	cbz	r0, 643c <ip_input+0xa8>
		if ((ip_addr_isbroadcast(&current_iphdr_src, inp)) || (ip_addr_ismulticast(&current_iphdr_src))) {
    6428:	4b31      	ldr	r3, [pc, #196]	; (64f0 <ip_input+0x15c>)
    642a:	4641      	mov	r1, r8
    642c:	4798      	blx	r3
    642e:	2800      	cmp	r0, #0
    6430:	d1bb      	bne.n	63aa <ip_input+0x16>
    6432:	686b      	ldr	r3, [r5, #4]
    6434:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
    6438:	2be0      	cmp	r3, #224	; 0xe0
    643a:	d0b6      	beq.n	63aa <ip_input+0x16>
	if (netif == NULL) {
    643c:	2f00      	cmp	r7, #0
    643e:	d0b4      	beq.n	63aa <ip_input+0x16>
	if ((IPH_OFFSET(iphdr) & PP_HTONS(IP_OFFMASK | IP_MF)) != 0) {
    6440:	88f3      	ldrh	r3, [r6, #6]
    6442:	f023 03c0 	bic.w	r3, r3, #192	; 0xc0
    6446:	b133      	cbz	r3, 6456 <ip_input+0xc2>
		p = ip_reass(p);
    6448:	4620      	mov	r0, r4
    644a:	4b2a      	ldr	r3, [pc, #168]	; (64f4 <ip_input+0x160>)
    644c:	4798      	blx	r3
		if (p == NULL) {
    644e:	4604      	mov	r4, r0
    6450:	2800      	cmp	r0, #0
    6452:	d0ad      	beq.n	63b0 <ip_input+0x1c>
		iphdr = (struct ip_hdr *)p->payload;
    6454:	6846      	ldr	r6, [r0, #4]
		switch (IPH_PROTO(iphdr)) {
    6456:	7a73      	ldrb	r3, [r6, #9]
    6458:	2b06      	cmp	r3, #6
	current_header = iphdr;
    645a:	e9c5 8602 	strd	r8, r6, [r5, #8]
		switch (IPH_PROTO(iphdr)) {
    645e:	d025      	beq.n	64ac <ip_input+0x118>
    6460:	2b11      	cmp	r3, #17
    6462:	d019      	beq.n	6498 <ip_input+0x104>
    6464:	2b01      	cmp	r3, #1
    6466:	d125      	bne.n	64b4 <ip_input+0x120>
			icmp_input(p, inp);
    6468:	4b23      	ldr	r3, [pc, #140]	; (64f8 <ip_input+0x164>)
    646a:	4641      	mov	r1, r8
    646c:	4620      	mov	r0, r4
    646e:	e016      	b.n	649e <ip_input+0x10a>
				netif = netif_list;
    6470:	f8db 7000 	ldr.w	r7, [fp]
			if (netif == inp) {
    6474:	4547      	cmp	r7, r8
				netif = netif->next;
    6476:	bf08      	it	eq
    6478:	683f      	ldreq	r7, [r7, #0]
		} while (netif != NULL);
    647a:	f04f 0a00 	mov.w	sl, #0
    647e:	2f00      	cmp	r7, #0
    6480:	d1bc      	bne.n	63fc <ip_input+0x68>
		if (IPH_PROTO(iphdr) == IP_PROTO_UDP) {
    6482:	7a73      	ldrb	r3, [r6, #9]
    6484:	2b11      	cmp	r3, #17
    6486:	d1cd      	bne.n	6424 <ip_input+0x90>
			if (IP_ACCEPT_LINK_LAYER_ADDRESSED_PORT(udphdr->dest)) {
    6488:	44b1      	add	r9, r6
    648a:	f8b9 3002 	ldrh.w	r3, [r9, #2]
    648e:	f5b3 4f88 	cmp.w	r3, #17408	; 0x4400
    6492:	d1c7      	bne.n	6424 <ip_input+0x90>
    6494:	4647      	mov	r7, r8
    6496:	e7d1      	b.n	643c <ip_input+0xa8>
			udp_input(p, inp);
    6498:	4b18      	ldr	r3, [pc, #96]	; (64fc <ip_input+0x168>)
    649a:	4641      	mov	r1, r8
    649c:	4620      	mov	r0, r4
			tcp_input(p, inp);
    649e:	4798      	blx	r3
	current_netif  = NULL;
    64a0:	2300      	movs	r3, #0
	current_header = NULL;
    64a2:	e9c5 3302 	strd	r3, r3, [r5, #8]
	ip_addr_set_any(&current_iphdr_dest);
    64a6:	e9c5 3300 	strd	r3, r3, [r5]
	return ERR_OK;
    64aa:	e781      	b.n	63b0 <ip_input+0x1c>
			tcp_input(p, inp);
    64ac:	4b14      	ldr	r3, [pc, #80]	; (6500 <ip_input+0x16c>)
    64ae:	4641      	mov	r1, r8
    64b0:	4620      	mov	r0, r4
    64b2:	e7f4      	b.n	649e <ip_input+0x10a>
			if (!ip_addr_isbroadcast(&current_iphdr_dest, inp) && !ip_addr_ismulticast(&current_iphdr_dest)) {
    64b4:	6828      	ldr	r0, [r5, #0]
    64b6:	4b0e      	ldr	r3, [pc, #56]	; (64f0 <ip_input+0x15c>)
    64b8:	4641      	mov	r1, r8
    64ba:	4798      	blx	r3
    64bc:	b948      	cbnz	r0, 64d2 <ip_input+0x13e>
    64be:	682b      	ldr	r3, [r5, #0]
    64c0:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
    64c4:	2be0      	cmp	r3, #224	; 0xe0
    64c6:	d004      	beq.n	64d2 <ip_input+0x13e>
				icmp_dest_unreach(p, ICMP_DUR_PROTO);
    64c8:	4b0e      	ldr	r3, [pc, #56]	; (6504 <ip_input+0x170>)
				p->payload = iphdr;
    64ca:	6066      	str	r6, [r4, #4]
				icmp_dest_unreach(p, ICMP_DUR_PROTO);
    64cc:	2102      	movs	r1, #2
    64ce:	4620      	mov	r0, r4
    64d0:	4798      	blx	r3
			pbuf_free(p);
    64d2:	4b02      	ldr	r3, [pc, #8]	; (64dc <ip_input+0x148>)
    64d4:	4620      	mov	r0, r4
    64d6:	4798      	blx	r3
    64d8:	e7e2      	b.n	64a0 <ip_input+0x10c>
    64da:	bf00      	nop
    64dc:	000030e5 	.word	0x000030e5
    64e0:	00000d6b 	.word	0x00000d6b
    64e4:	00008415 	.word	0x00008415
    64e8:	0000324d 	.word	0x0000324d
    64ec:	20011104 	.word	0x20011104
    64f0:	00008a1b 	.word	0x00008a1b
    64f4:	00002b4d 	.word	0x00002b4d
    64f8:	00000c09 	.word	0x00000c09
    64fc:	00004481 	.word	0x00004481
    6500:	00003c59 	.word	0x00003c59
    6504:	00000d4d 	.word	0x00000d4d
    6508:	200163e4 	.word	0x200163e4

0000650c <ip_output_if>:
 *
 * @note ip_id: RFC791 "some host may be able to simply use
 *  unique identifiers independent of destination"
 */
err_t ip_output_if(struct pbuf *p, ip_addr_t *src, ip_addr_t *dest, u8_t ttl, u8_t tos, u8_t proto, struct netif *netif)
{
    650c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    6510:	b085      	sub	sp, #20
    6512:	4606      	mov	r6, r0
    6514:	f89d b038 	ldrb.w	fp, [sp, #56]	; 0x38
    6518:	f89d 903c 	ldrb.w	r9, [sp, #60]	; 0x3c
    651c:	f8dd 8040 	ldr.w	r8, [sp, #64]	; 0x40
    6520:	9101      	str	r1, [sp, #4]
    6522:	461c      	mov	r4, r3
	LWIP_ASSERT("p->ref == 1", p->ref == 1);

	snmp_inc_ipoutrequests();

	/* Should the IP header be generated or is it already included in p? */
	if (dest != IP_HDRINCL) {
    6524:	4617      	mov	r7, r2
    6526:	2a00      	cmp	r2, #0
    6528:	d050      	beq.n	65cc <ip_output_if+0xc0>
			}
#endif /* CHECKSUM_GEN_IP_INLINE */
		}
#endif /* IP_OPTIONS_SEND */
		/* generate IP header */
		if (pbuf_header(p, IP_HLEN)) {
    652a:	4b2f      	ldr	r3, [pc, #188]	; (65e8 <ip_output_if+0xdc>)
    652c:	2114      	movs	r1, #20
    652e:	4798      	blx	r3
    6530:	4682      	mov	sl, r0
    6532:	2800      	cmp	r0, #0
    6534:	d155      	bne.n	65e2 <ip_output_if+0xd6>
			IP_STATS_INC(ip.err);
			snmp_inc_ipoutdiscards();
			return ERR_BUF;
		}

		iphdr = (struct ip_hdr *)p->payload;
    6536:	6875      	ldr	r5, [r6, #4]
		LWIP_ASSERT("check that first pbuf can hold struct ip_hdr", (p->len >= sizeof(struct ip_hdr)));

		IPH_TTL_SET(iphdr, ttl);
    6538:	722c      	strb	r4, [r5, #8]
		IPH_PROTO_SET(iphdr, proto);
    653a:	f885 9009 	strb.w	r9, [r5, #9]
#if CHECKSUM_GEN_IP_INLINE
		chk_sum += LWIP_MAKE_U16(proto, ttl);
#endif /* CHECKSUM_GEN_IP_INLINE */

		/* dest cannot be NULL here */
		ip_addr_copy(iphdr->dest, *dest);
    653e:	683b      	ldr	r3, [r7, #0]
		chk_sum += ip4_addr_get_u32(&iphdr->dest) & 0xFFFF;
		chk_sum += ip4_addr_get_u32(&iphdr->dest) >> 16;
#endif /* CHECKSUM_GEN_IP_INLINE */

		IPH_VHL_SET(iphdr, 4, ip_hlen / 4);
		IPH_TOS_SET(iphdr, tos);
    6540:	f885 b001 	strb.w	fp, [r5, #1]
		IPH_VHL_SET(iphdr, 4, ip_hlen / 4);
    6544:	2245      	movs	r2, #69	; 0x45
#if CHECKSUM_GEN_IP_INLINE
		chk_sum += LWIP_MAKE_U16(tos, iphdr->_v_hl);
    6546:	ea4f 2b0b 	mov.w	fp, fp, lsl #8
    654a:	ea4b 0b02 	orr.w	fp, fp, r2
		chk_sum += LWIP_MAKE_U16(proto, ttl);
    654e:	ea44 2409 	orr.w	r4, r4, r9, lsl #8
		IPH_VHL_SET(iphdr, 4, ip_hlen / 4);
    6552:	702a      	strb	r2, [r5, #0]
		chk_sum += LWIP_MAKE_U16(tos, iphdr->_v_hl);
    6554:	445c      	add	r4, fp
    6556:	fa14 f483 	uxtah	r4, r4, r3
		ip_addr_copy(iphdr->dest, *dest);
    655a:	612b      	str	r3, [r5, #16]
#endif /* CHECKSUM_GEN_IP_INLINE */
		IPH_LEN_SET(iphdr, htons(p->tot_len));
    655c:	f8df b090 	ldr.w	fp, [pc, #144]	; 65f0 <ip_output_if+0xe4>
    6560:	8930      	ldrh	r0, [r6, #8]
		chk_sum += LWIP_MAKE_U16(tos, iphdr->_v_hl);
    6562:	eb04 4413 	add.w	r4, r4, r3, lsr #16
		IPH_LEN_SET(iphdr, htons(p->tot_len));
    6566:	47d8      	blx	fp
#if CHECKSUM_GEN_IP_INLINE
		chk_sum += iphdr->_len;
#endif /* CHECKSUM_GEN_IP_INLINE */
		IPH_OFFSET_SET(iphdr, 0);
    6568:	f885 a006 	strb.w	sl, [r5, #6]
    656c:	f885 a007 	strb.w	sl, [r5, #7]
		IPH_ID_SET(iphdr, htons(ip_id));
    6570:	f8df a080 	ldr.w	sl, [pc, #128]	; 65f4 <ip_output_if+0xe8>
		IPH_LEN_SET(iphdr, htons(p->tot_len));
    6574:	8068      	strh	r0, [r5, #2]
		chk_sum += iphdr->_len;
    6576:	4404      	add	r4, r0
		IPH_ID_SET(iphdr, htons(ip_id));
    6578:	f8ba 0010 	ldrh.w	r0, [sl, #16]
    657c:	47d8      	blx	fp
#if CHECKSUM_GEN_IP_INLINE
		chk_sum += iphdr->_id;
#endif /* CHECKSUM_GEN_IP_INLINE */
		++ip_id;
    657e:	f8ba 2010 	ldrh.w	r2, [sl, #16]
		IPH_ID_SET(iphdr, htons(ip_id));
    6582:	80a8      	strh	r0, [r5, #4]
		++ip_id;
    6584:	3201      	adds	r2, #1
    6586:	f8aa 2010 	strh.w	r2, [sl, #16]

		if (ip_addr_isany(src)) {
    658a:	9a01      	ldr	r2, [sp, #4]
		chk_sum += iphdr->_id;
    658c:	1903      	adds	r3, r0, r4
		if (ip_addr_isany(src)) {
    658e:	b10a      	cbz	r2, 6594 <ip_output_if+0x88>
    6590:	6812      	ldr	r2, [r2, #0]
    6592:	b90a      	cbnz	r2, 6598 <ip_output_if+0x8c>
			ip_addr_copy(iphdr->src, netif->ip_addr);
    6594:	f8d8 2004 	ldr.w	r2, [r8, #4]
    6598:	60ea      	str	r2, [r5, #12]
			/* src cannot be NULL here */
			ip_addr_copy(iphdr->src, *src);
		}

#if CHECKSUM_GEN_IP_INLINE
		chk_sum += ip4_addr_get_u32(&iphdr->src) & 0xFFFF;
    659a:	fa13 f382 	uxtah	r3, r3, r2
		chk_sum += ip4_addr_get_u32(&iphdr->src) >> 16;
    659e:	eb03 4312 	add.w	r3, r3, r2, lsr #16
		chk_sum        = (chk_sum >> 16) + (chk_sum & 0xFFFF);
    65a2:	b29a      	uxth	r2, r3
    65a4:	eb02 4313 	add.w	r3, r2, r3, lsr #16
		chk_sum        = (chk_sum >> 16) + chk_sum;
    65a8:	eb03 4313 	add.w	r3, r3, r3, lsr #16
		chk_sum        = ~chk_sum;
    65ac:	43db      	mvns	r3, r3
		iphdr->_chksum = chk_sum; /* network order */
    65ae:	816b      	strh	r3, [r5, #10]
	}
#endif /* LWIP_IGMP */
#endif /* ENABLE_LOOPBACK */
#if IP_FRAG
	/* don't fragment if interface has mtu set to 0 [loopif] */
	if (netif->mtu && (p->tot_len > netif->mtu)) {
    65b0:	f8b8 3028 	ldrh.w	r3, [r8, #40]	; 0x28
    65b4:	b17b      	cbz	r3, 65d6 <ip_output_if+0xca>
    65b6:	8932      	ldrh	r2, [r6, #8]
    65b8:	429a      	cmp	r2, r3
    65ba:	d90c      	bls.n	65d6 <ip_output_if+0xca>
		return ip_frag(p, netif, dest);
    65bc:	4b0b      	ldr	r3, [pc, #44]	; (65ec <ip_output_if+0xe0>)
    65be:	463a      	mov	r2, r7
    65c0:	4641      	mov	r1, r8
    65c2:	4630      	mov	r0, r6
	}
#endif /* IP_FRAG */

	LWIP_DEBUGF(IP_DEBUG, ("netif->output()"));
	return netif->output(netif, p, dest);
    65c4:	4798      	blx	r3
}
    65c6:	b005      	add	sp, #20
    65c8:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		ip_addr_copy(dest_addr, iphdr->dest);
    65cc:	6843      	ldr	r3, [r0, #4]
    65ce:	691b      	ldr	r3, [r3, #16]
    65d0:	9303      	str	r3, [sp, #12]
		dest = &dest_addr;
    65d2:	af03      	add	r7, sp, #12
    65d4:	e7ec      	b.n	65b0 <ip_output_if+0xa4>
	return netif->output(netif, p, dest);
    65d6:	f8d8 3014 	ldr.w	r3, [r8, #20]
    65da:	463a      	mov	r2, r7
    65dc:	4631      	mov	r1, r6
    65de:	4640      	mov	r0, r8
    65e0:	e7f0      	b.n	65c4 <ip_output_if+0xb8>
			return ERR_BUF;
    65e2:	f06f 0001 	mvn.w	r0, #1
    65e6:	e7ee      	b.n	65c6 <ip_output_if+0xba>
    65e8:	0000308d 	.word	0x0000308d
    65ec:	00002e35 	.word	0x00002e35
    65f0:	00000d65 	.word	0x00000d65
    65f4:	20011104 	.word	0x20011104

000065f8 <ip_output>:
 *
 * @return ERR_RTE if no route is found
 *         see ip_output_if() for more return values
 */
err_t ip_output(struct pbuf *p, ip_addr_t *src, ip_addr_t *dest, u8_t ttl, u8_t tos, u8_t proto)
{
    65f8:	b530      	push	{r4, r5, lr}
    65fa:	b089      	sub	sp, #36	; 0x24
    65fc:	4605      	mov	r5, r0

	/* pbufs passed to IP must have a ref-count of 1 as their payload pointer
	   gets altered as the packet is passed down the stack */
	LWIP_ASSERT("p->ref == 1", p->ref == 1);

	if ((netif = ip_route(dest)) == NULL) {
    65fe:	4c0c      	ldr	r4, [pc, #48]	; (6630 <ip_output+0x38>)
    6600:	9205      	str	r2, [sp, #20]
    6602:	4610      	mov	r0, r2
{
    6604:	e9cd 3106 	strd	r3, r1, [sp, #24]
	if ((netif = ip_route(dest)) == NULL) {
    6608:	47a0      	blx	r4
    660a:	b170      	cbz	r0, 662a <ip_output+0x32>
		             ip4_addr4_16(dest)));
		IP_STATS_INC(ip.rterr);
		return ERR_RTE;
	}

	return ip_output_if(p, src, dest, ttl, tos, proto, netif);
    660c:	9002      	str	r0, [sp, #8]
    660e:	f89d 0034 	ldrb.w	r0, [sp, #52]	; 0x34
    6612:	9001      	str	r0, [sp, #4]
    6614:	f89d 0030 	ldrb.w	r0, [sp, #48]	; 0x30
    6618:	9000      	str	r0, [sp, #0]
    661a:	e9dd 2305 	ldrd	r2, r3, [sp, #20]
    661e:	9907      	ldr	r1, [sp, #28]
    6620:	4c04      	ldr	r4, [pc, #16]	; (6634 <ip_output+0x3c>)
    6622:	4628      	mov	r0, r5
    6624:	47a0      	blx	r4
}
    6626:	b009      	add	sp, #36	; 0x24
    6628:	bd30      	pop	{r4, r5, pc}
		return ERR_RTE;
    662a:	f06f 0003 	mvn.w	r0, #3
    662e:	e7fa      	b.n	6626 <ip_output+0x2e>
    6630:	00006359 	.word	0x00006359
    6634:	0000650d 	.word	0x0000650d

00006638 <mem_init>:
	struct mem *mem;

	LWIP_ASSERT("Sanity check alignment", (SIZEOF_STRUCT_MEM & (MEM_ALIGNMENT - 1)) == 0);

	/* align the heap */
	ram = (u8_t *)LWIP_MEM_ALIGN(LWIP_RAM_HEAP_POINTER);
    6638:	4b0c      	ldr	r3, [pc, #48]	; (666c <mem_init+0x34>)
    663a:	480d      	ldr	r0, [pc, #52]	; (6670 <mem_init+0x38>)
    663c:	f023 0303 	bic.w	r3, r3, #3
	/* initialize the start of the heap */
	mem       = (struct mem *)(void *)ram;
	mem->next = MEM_SIZE_ALIGNED;
    6640:	f44f 5260 	mov.w	r2, #14336	; 0x3800
    6644:	601a      	str	r2, [r3, #0]
	mem->prev = 0;
	mem->used = 0;
    6646:	2200      	movs	r2, #0
    6648:	711a      	strb	r2, [r3, #4]
	/* initialize the end of the heap */
	ram_end       = (struct mem *)(void *)&ram[MEM_SIZE_ALIGNED];
    664a:	f503 5260 	add.w	r2, r3, #14336	; 0x3800
    664e:	6042      	str	r2, [r0, #4]
	ram_end->used = 1;
	ram_end->next = MEM_SIZE_ALIGNED;
    6650:	f503 5240 	add.w	r2, r3, #12288	; 0x3000
    6654:	f04f 2138 	mov.w	r1, #939538432	; 0x38003800
    6658:	f8c2 1800 	str.w	r1, [r2, #2048]	; 0x800
	ram_end->used = 1;
    665c:	2101      	movs	r1, #1
	ram = (u8_t *)LWIP_MEM_ALIGN(LWIP_RAM_HEAP_POINTER);
    665e:	6003      	str	r3, [r0, #0]
	ram_end->prev = MEM_SIZE_ALIGNED;

	/* initialize the lowest-free pointer to the start of the heap */
	lfree = (struct mem *)(void *)ram;
    6660:	6083      	str	r3, [r0, #8]
	ram_end->used = 1;
    6662:	f882 1804 	strb.w	r1, [r2, #2052]	; 0x804

	MEM_STATS_AVAIL(avail, MEM_SIZE_ALIGNED);

	if (sys_mutex_new(&mem_mutex) != ERR_OK) {
    6666:	4b03      	ldr	r3, [pc, #12]	; (6674 <mem_init+0x3c>)
    6668:	300c      	adds	r0, #12
    666a:	4718      	bx	r3
    666c:	2001112b 	.word	0x2001112b
    6670:	20011118 	.word	0x20011118
    6674:	000079a9 	.word	0x000079a9

00006678 <mem_free>:
 *
 * @param rmem is the data portion of a struct mem as returned by a previous
 *             call to mem_malloc()
 */
void mem_free(void *rmem)
{
    6678:	b570      	push	{r4, r5, r6, lr}
	struct mem *mem;
	LWIP_MEM_FREE_DECL_PROTECT();

	if (rmem == NULL) {
    667a:	4604      	mov	r4, r0
    667c:	2800      	cmp	r0, #0
    667e:	d041      	beq.n	6704 <mem_free+0x8c>
	}
	LWIP_ASSERT("mem_free: sanity check alignment", (((mem_ptr_t)rmem) & (MEM_ALIGNMENT - 1)) == 0);

	LWIP_ASSERT("mem_free: legal memory", (u8_t *)rmem >= (u8_t *)ram && (u8_t *)rmem < (u8_t *)ram_end);

	if ((u8_t *)rmem < (u8_t *)ram || (u8_t *)rmem >= (u8_t *)ram_end) {
    6680:	4d21      	ldr	r5, [pc, #132]	; (6708 <mem_free+0x90>)
    6682:	682b      	ldr	r3, [r5, #0]
    6684:	4283      	cmp	r3, r0
    6686:	d83d      	bhi.n	6704 <mem_free+0x8c>
    6688:	686b      	ldr	r3, [r5, #4]
    668a:	4283      	cmp	r3, r0
    668c:	d93a      	bls.n	6704 <mem_free+0x8c>
		MEM_STATS_INC(illegal);
		SYS_ARCH_UNPROTECT(lev);
		return;
	}
	/* protect the heap from concurrent access */
	LWIP_MEM_FREE_PROTECT();
    668e:	4b1f      	ldr	r3, [pc, #124]	; (670c <mem_free+0x94>)
    6690:	2100      	movs	r1, #0
    6692:	f105 000c 	add.w	r0, r5, #12
    6696:	4798      	blx	r3
	/* Get the corresponding struct mem ... */
	mem = (struct mem *)(void *)((u8_t *)rmem - SIZEOF_STRUCT_MEM);
	/* ... which has to be in a used state ... */
	LWIP_ASSERT("mem_free: mem->used", mem->used);
	/* ... and is now unused. */
	mem->used = 0;
    6698:	2300      	movs	r3, #0
    669a:	f804 3c04 	strb.w	r3, [r4, #-4]

	if (mem < lfree) {
    669e:	68ab      	ldr	r3, [r5, #8]
	nmem = (struct mem *)(void *)&ram[mem->next];
    66a0:	f834 0c08 	ldrh.w	r0, [r4, #-8]
	mem = (struct mem *)(void *)((u8_t *)rmem - SIZEOF_STRUCT_MEM);
    66a4:	f1a4 0208 	sub.w	r2, r4, #8
	if (mem < lfree) {
    66a8:	4293      	cmp	r3, r2
	nmem = (struct mem *)(void *)&ram[mem->next];
    66aa:	682b      	ldr	r3, [r5, #0]
		/* the newly freed struct is now the lowest */
		lfree = mem;
    66ac:	bf88      	it	hi
    66ae:	60aa      	strhi	r2, [r5, #8]
	nmem = (struct mem *)(void *)&ram[mem->next];
    66b0:	1819      	adds	r1, r3, r0
	if (mem != nmem && nmem->used == 0 && (u8_t *)nmem != (u8_t *)ram_end) {
    66b2:	428a      	cmp	r2, r1
    66b4:	d00f      	beq.n	66d6 <mem_free+0x5e>
    66b6:	790e      	ldrb	r6, [r1, #4]
    66b8:	b96e      	cbnz	r6, 66d6 <mem_free+0x5e>
    66ba:	686e      	ldr	r6, [r5, #4]
    66bc:	42b1      	cmp	r1, r6
    66be:	d00a      	beq.n	66d6 <mem_free+0x5e>
		if (lfree == nmem) {
    66c0:	68ae      	ldr	r6, [r5, #8]
    66c2:	42b1      	cmp	r1, r6
		mem->next                                      = nmem->next;
    66c4:	5a19      	ldrh	r1, [r3, r0]
    66c6:	f824 1c08 	strh.w	r1, [r4, #-8]
		((struct mem *)(void *)&ram[nmem->next])->prev = (mem_size_t)((u8_t *)mem - ram);
    66ca:	5a19      	ldrh	r1, [r3, r0]
			lfree = mem;
    66cc:	bf08      	it	eq
    66ce:	60aa      	streq	r2, [r5, #8]
		((struct mem *)(void *)&ram[nmem->next])->prev = (mem_size_t)((u8_t *)mem - ram);
    66d0:	4419      	add	r1, r3
    66d2:	1ad0      	subs	r0, r2, r3
    66d4:	8048      	strh	r0, [r1, #2]
	pmem = (struct mem *)(void *)&ram[mem->prev];
    66d6:	f834 1c06 	ldrh.w	r1, [r4, #-6]
    66da:	1858      	adds	r0, r3, r1
	if (pmem != mem && pmem->used == 0) {
    66dc:	4282      	cmp	r2, r0
    66de:	d00c      	beq.n	66fa <mem_free+0x82>
    66e0:	7906      	ldrb	r6, [r0, #4]
    66e2:	b956      	cbnz	r6, 66fa <mem_free+0x82>
		if (lfree == mem) {
    66e4:	68ae      	ldr	r6, [r5, #8]
    66e6:	42b2      	cmp	r2, r6
		pmem->next                                    = mem->next;
    66e8:	f834 2c08 	ldrh.w	r2, [r4, #-8]
    66ec:	525a      	strh	r2, [r3, r1]
		((struct mem *)(void *)&ram[mem->next])->prev = (mem_size_t)((u8_t *)pmem - ram);
    66ee:	f834 2c08 	ldrh.w	r2, [r4, #-8]
			lfree = pmem;
    66f2:	bf08      	it	eq
    66f4:	60a8      	streq	r0, [r5, #8]
		((struct mem *)(void *)&ram[mem->next])->prev = (mem_size_t)((u8_t *)pmem - ram);
    66f6:	4413      	add	r3, r2
    66f8:	8059      	strh	r1, [r3, #2]
	plug_holes(mem);
#if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
	mem_free_count = 1;
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
	LWIP_MEM_FREE_UNPROTECT();
}
    66fa:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	LWIP_MEM_FREE_UNPROTECT();
    66fe:	4804      	ldr	r0, [pc, #16]	; (6710 <mem_free+0x98>)
    6700:	4b04      	ldr	r3, [pc, #16]	; (6714 <mem_free+0x9c>)
    6702:	4718      	bx	r3
}
    6704:	bd70      	pop	{r4, r5, r6, pc}
    6706:	bf00      	nop
    6708:	20011118 	.word	0x20011118
    670c:	00007a39 	.word	0x00007a39
    6710:	20011124 	.word	0x20011124
    6714:	00007a19 	.word	0x00007a19

00006718 <mem_trim>:
 * @return for compatibility reasons: is always == rmem, at the moment
 *         or NULL if newsize is > old size, in which case rmem is NOT touched
 *         or freed!
 */
void *mem_trim(void *rmem, mem_size_t newsize)
{
    6718:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	/* use the FREE_PROTECT here: it protects with sem OR SYS_ARCH_PROTECT */
	LWIP_MEM_FREE_DECL_PROTECT();

	/* Expand the size of the allocated memory region so that we can
	   adjust for alignment. */
	newsize = LWIP_MEM_ALIGN_SIZE(newsize);
    671c:	3103      	adds	r1, #3
    671e:	f64f 74fc 	movw	r4, #65532	; 0xfffc
    6722:	400c      	ands	r4, r1

	if (newsize < MIN_SIZE_ALIGNED) {
    6724:	2c0b      	cmp	r4, #11
{
    6726:	4605      	mov	r5, r0
	if (newsize < MIN_SIZE_ALIGNED) {
    6728:	d904      	bls.n	6734 <mem_trim+0x1c>
		/* every data block must be at least MIN_SIZE_ALIGNED long */
		newsize = MIN_SIZE_ALIGNED;
	}

	if (newsize > MEM_SIZE_ALIGNED) {
    672a:	f5b4 5f60 	cmp.w	r4, #14336	; 0x3800
    672e:	d902      	bls.n	6736 <mem_trim+0x1e>
		return NULL;
    6730:	2500      	movs	r5, #0
    6732:	e03e      	b.n	67b2 <mem_trim+0x9a>
		newsize = MIN_SIZE_ALIGNED;
    6734:	240c      	movs	r4, #12
	}

	LWIP_ASSERT("mem_trim: legal memory", (u8_t *)rmem >= (u8_t *)ram && (u8_t *)rmem < (u8_t *)ram_end);

	if ((u8_t *)rmem < (u8_t *)ram || (u8_t *)rmem >= (u8_t *)ram_end) {
    6736:	4f2f      	ldr	r7, [pc, #188]	; (67f4 <mem_trim+0xdc>)
    6738:	683b      	ldr	r3, [r7, #0]
    673a:	42ab      	cmp	r3, r5
    673c:	d839      	bhi.n	67b2 <mem_trim+0x9a>
    673e:	687a      	ldr	r2, [r7, #4]
    6740:	42aa      	cmp	r2, r5
    6742:	d936      	bls.n	67b2 <mem_trim+0x9a>
	/* Get the corresponding struct mem ... */
	mem = (struct mem *)(void *)((u8_t *)rmem - SIZEOF_STRUCT_MEM);
	/* ... and its offset pointer */
	ptr = (mem_size_t)((u8_t *)mem - ram);

	size = mem->next - ptr - SIZEOF_STRUCT_MEM;
    6744:	f835 8c08 	ldrh.w	r8, [r5, #-8]
	mem = (struct mem *)(void *)((u8_t *)rmem - SIZEOF_STRUCT_MEM);
    6748:	f1a5 0608 	sub.w	r6, r5, #8
	ptr = (mem_size_t)((u8_t *)mem - ram);
    674c:	1af6      	subs	r6, r6, r3
    674e:	b2b6      	uxth	r6, r6
	size = mem->next - ptr - SIZEOF_STRUCT_MEM;
    6750:	f1a8 0808 	sub.w	r8, r8, #8
    6754:	eba8 0806 	sub.w	r8, r8, r6
    6758:	fa1f f888 	uxth.w	r8, r8
	LWIP_ASSERT("mem_trim can only shrink memory", newsize <= size);
	if (newsize > size) {
    675c:	45a0      	cmp	r8, r4
    675e:	d3e7      	bcc.n	6730 <mem_trim+0x18>
		/* not supported */
		return NULL;
	}
	if (newsize == size) {
    6760:	d027      	beq.n	67b2 <mem_trim+0x9a>
		/* No change in size, simply return */
		return rmem;
	}

	/* protect the heap from concurrent access */
	LWIP_MEM_FREE_PROTECT();
    6762:	4b25      	ldr	r3, [pc, #148]	; (67f8 <mem_trim+0xe0>)
    6764:	2100      	movs	r1, #0
    6766:	f107 000c 	add.w	r0, r7, #12
    676a:	4798      	blx	r3

	mem2 = (struct mem *)(void *)&ram[mem->next];
    676c:	683b      	ldr	r3, [r7, #0]
    676e:	f835 1c08 	ldrh.w	r1, [r5, #-8]
    6772:	1858      	adds	r0, r3, r1
	if (mem2->used == 0) {
    6774:	7902      	ldrb	r2, [r0, #4]
    6776:	b9fa      	cbnz	r2, 67b8 <mem_trim+0xa0>
		/* The next struct is unused, we can simply move it at little */
		mem_size_t next;
		/* remember the old next pointer */
		next = mem2->next;
		/* create new struct mem which is moved directly after the shrinked mem */
		ptr2 = ptr + SIZEOF_STRUCT_MEM + newsize;
    6778:	f106 0208 	add.w	r2, r6, #8
    677c:	4414      	add	r4, r2
		if (lfree == mem2) {
    677e:	68ba      	ldr	r2, [r7, #8]
		next = mem2->next;
    6780:	f833 c001 	ldrh.w	ip, [r3, r1]
		ptr2 = ptr + SIZEOF_STRUCT_MEM + newsize;
    6784:	b2a1      	uxth	r1, r4
			lfree = (struct mem *)(void *)&ram[ptr2];
    6786:	fa13 f484 	uxtah	r4, r3, r4
		if (lfree == mem2) {
    678a:	4282      	cmp	r2, r0
		}
		mem2       = (struct mem *)(void *)&ram[ptr2];
		mem2->used = 0;
    678c:	f04f 0200 	mov.w	r2, #0
    6790:	7122      	strb	r2, [r4, #4]
		/* restore the next pointer */
		mem2->next = next;
    6792:	f823 c001 	strh.w	ip, [r3, r1]
		/* link it back to mem */
		mem2->prev = ptr;
    6796:	8066      	strh	r6, [r4, #2]
		/* link mem to it */
		mem->next = ptr2;
    6798:	f825 1c08 	strh.w	r1, [r5, #-8]
		/* last thing to restore linked list: as we have moved mem2,
		 * let 'mem2->next->prev' point to mem2 again. but only if mem2->next is not
		 * the end of the heap */
		if (mem2->next != MEM_SIZE_ALIGNED) {
    679c:	5a5a      	ldrh	r2, [r3, r1]
			lfree = (struct mem *)(void *)&ram[ptr2];
    679e:	bf08      	it	eq
    67a0:	60bc      	streq	r4, [r7, #8]
		if (mem2->next != MEM_SIZE_ALIGNED) {
    67a2:	f5b2 5f60 	cmp.w	r2, #14336	; 0x3800
    67a6:	d001      	beq.n	67ac <mem_trim+0x94>
			((struct mem *)(void *)&ram[mem2->next])->prev = ptr2;
    67a8:	4413      	add	r3, r2
    67aa:	8059      	strh	r1, [r3, #2]
		  -> the remaining space stays unused since it is too small
		} */
#if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
	mem_free_count = 1;
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
	LWIP_MEM_FREE_UNPROTECT();
    67ac:	4813      	ldr	r0, [pc, #76]	; (67fc <mem_trim+0xe4>)
    67ae:	4b14      	ldr	r3, [pc, #80]	; (6800 <mem_trim+0xe8>)
    67b0:	4798      	blx	r3
	return rmem;
}
    67b2:	4628      	mov	r0, r5
    67b4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	} else if (newsize + SIZEOF_STRUCT_MEM + MIN_SIZE_ALIGNED <= size) {
    67b8:	f104 0214 	add.w	r2, r4, #20
    67bc:	b292      	uxth	r2, r2
    67be:	4590      	cmp	r8, r2
    67c0:	d3f4      	bcc.n	67ac <mem_trim+0x94>
		ptr2 = ptr + SIZEOF_STRUCT_MEM + newsize;
    67c2:	f106 0208 	add.w	r2, r6, #8
		if (mem2 < lfree) {
    67c6:	68b8      	ldr	r0, [r7, #8]
		ptr2 = ptr + SIZEOF_STRUCT_MEM + newsize;
    67c8:	4414      	add	r4, r2
    67ca:	b2a2      	uxth	r2, r4
		mem2 = (struct mem *)(void *)&ram[ptr2];
    67cc:	fa13 f484 	uxtah	r4, r3, r4
		if (mem2 < lfree) {
    67d0:	42a0      	cmp	r0, r4
		mem2->used = 0;
    67d2:	f04f 0000 	mov.w	r0, #0
    67d6:	7120      	strb	r0, [r4, #4]
		mem2->next = mem->next;
    67d8:	5299      	strh	r1, [r3, r2]
		mem2->prev = ptr;
    67da:	8066      	strh	r6, [r4, #2]
		mem->next  = ptr2;
    67dc:	f825 2c08 	strh.w	r2, [r5, #-8]
		if (mem2->next != MEM_SIZE_ALIGNED) {
    67e0:	5a99      	ldrh	r1, [r3, r2]
			lfree = mem2;
    67e2:	bf88      	it	hi
    67e4:	60bc      	strhi	r4, [r7, #8]
		if (mem2->next != MEM_SIZE_ALIGNED) {
    67e6:	f5b1 5f60 	cmp.w	r1, #14336	; 0x3800
			((struct mem *)(void *)&ram[mem2->next])->prev = ptr2;
    67ea:	bf1c      	itt	ne
    67ec:	185b      	addne	r3, r3, r1
    67ee:	805a      	strhne	r2, [r3, #2]
    67f0:	e7dc      	b.n	67ac <mem_trim+0x94>
    67f2:	bf00      	nop
    67f4:	20011118 	.word	0x20011118
    67f8:	00007a39 	.word	0x00007a39
    67fc:	20011124 	.word	0x20011124
    6800:	00007a19 	.word	0x00007a19

00006804 <mem_malloc>:
 * @return pointer to allocated memory or NULL if no free memory was found.
 *
 * Note that the returned value will always be aligned (as defined by MEM_ALIGNMENT).
 */
void *mem_malloc(mem_size_t size)
{
    6804:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
#if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
	u8_t        local_mem_free_count = 0;
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
	LWIP_MEM_ALLOC_DECL_PROTECT();

	if (size == 0) {
    6808:	2800      	cmp	r0, #0
    680a:	d050      	beq.n	68ae <mem_malloc+0xaa>
		return NULL;
	}

	/* Expand the size of the allocated memory region so that we can
	   adjust for alignment. */
	size = LWIP_MEM_ALIGN_SIZE(size);
    680c:	3003      	adds	r0, #3
    680e:	f64f 75fc 	movw	r5, #65532	; 0xfffc
    6812:	4005      	ands	r5, r0

	if (size < MIN_SIZE_ALIGNED) {
    6814:	2d0b      	cmp	r5, #11
    6816:	d904      	bls.n	6822 <mem_malloc+0x1e>
		/* every data block must be at least MIN_SIZE_ALIGNED long */
		size = MIN_SIZE_ALIGNED;
	}

	if (size > MEM_SIZE_ALIGNED) {
    6818:	f5b5 5f60 	cmp.w	r5, #14336	; 0x3800
    681c:	d902      	bls.n	6824 <mem_malloc+0x20>
		return NULL;
    681e:	2000      	movs	r0, #0
    6820:	e045      	b.n	68ae <mem_malloc+0xaa>
		size = MIN_SIZE_ALIGNED;
    6822:	250c      	movs	r5, #12
		return NULL;
	}

	/* protect the heap from concurrent access */
	sys_mutex_lock(&mem_mutex);
    6824:	4e27      	ldr	r6, [pc, #156]	; (68c4 <mem_malloc+0xc0>)
    6826:	4b28      	ldr	r3, [pc, #160]	; (68c8 <mem_malloc+0xc4>)
    6828:	2100      	movs	r1, #0
    682a:	f106 000c 	add.w	r0, r6, #12
    682e:	4798      	blx	r3
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */

		/* Scan through the heap searching for a free block that is big enough,
		 * beginning with the lowest free block.
		 */
		for (ptr = (mem_size_t)((u8_t *)lfree - ram); ptr < MEM_SIZE_ALIGNED - size;
    6830:	68b2      	ldr	r2, [r6, #8]
    6832:	6831      	ldr	r1, [r6, #0]
    6834:	1a53      	subs	r3, r2, r1
    6836:	b29b      	uxth	r3, r3
    6838:	f5c5 5e60 	rsb	lr, r5, #14336	; 0x3800
				local_mem_free_count = 1;
				break;
			}
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */

			if ((!mem->used) && (mem->next - (ptr + SIZEOF_STRUCT_MEM)) >= size) {
    683c:	f06f 0807 	mvn.w	r8, #7
		for (ptr = (mem_size_t)((u8_t *)lfree - ram); ptr < MEM_SIZE_ALIGNED - size;
    6840:	4573      	cmp	r3, lr
    6842:	db03      	blt.n	684c <mem_malloc+0x48>
	} while (local_mem_free_count != 0);
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
	LWIP_DEBUGF(MEM_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("mem_malloc: could not allocate %" S16_F " bytes\n", (s16_t)size));
	MEM_STATS_INC(err);
	LWIP_MEM_ALLOC_UNPROTECT();
	sys_mutex_unlock(&mem_mutex);
    6844:	4821      	ldr	r0, [pc, #132]	; (68cc <mem_malloc+0xc8>)
    6846:	4b22      	ldr	r3, [pc, #136]	; (68d0 <mem_malloc+0xcc>)
    6848:	4798      	blx	r3
	return NULL;
    684a:	e7e8      	b.n	681e <mem_malloc+0x1a>
			mem            = (struct mem *)(void *)&ram[ptr];
    684c:	18cc      	adds	r4, r1, r3
			if ((!mem->used) && (mem->next - (ptr + SIZEOF_STRUCT_MEM)) >= size) {
    684e:	5ac8      	ldrh	r0, [r1, r3]
    6850:	f894 c004 	ldrb.w	ip, [r4, #4]
    6854:	f1bc 0f00 	cmp.w	ip, #0
    6858:	d131      	bne.n	68be <mem_malloc+0xba>
    685a:	eba8 0703 	sub.w	r7, r8, r3
    685e:	4407      	add	r7, r0
    6860:	42af      	cmp	r7, r5
    6862:	d32c      	bcc.n	68be <mem_malloc+0xba>
				if (mem->next - (ptr + SIZEOF_STRUCT_MEM) >= (size + SIZEOF_STRUCT_MEM + MIN_SIZE_ALIGNED)) {
    6864:	f105 0e14 	add.w	lr, r5, #20
    6868:	fa1f fe8e 	uxth.w	lr, lr
    686c:	4577      	cmp	r7, lr
    686e:	d320      	bcc.n	68b2 <mem_malloc+0xae>
					ptr2 = ptr + SIZEOF_STRUCT_MEM + size;
    6870:	3508      	adds	r5, #8
    6872:	441d      	add	r5, r3
    6874:	b2af      	uxth	r7, r5
					mem2       = (struct mem *)(void *)&ram[ptr2];
    6876:	fa11 f585 	uxtah	r5, r1, r5
					mem2->used = 0;
    687a:	f885 c004 	strb.w	ip, [r5, #4]
					mem2->next = mem->next;
    687e:	53c8      	strh	r0, [r1, r7]
					mem2->prev = ptr;
    6880:	806b      	strh	r3, [r5, #2]
					mem->used = 1;
    6882:	2301      	movs	r3, #1
					mem->next = ptr2;
    6884:	8027      	strh	r7, [r4, #0]
					mem->used = 1;
    6886:	7123      	strb	r3, [r4, #4]
					if (mem2->next != MEM_SIZE_ALIGNED) {
    6888:	5bcb      	ldrh	r3, [r1, r7]
    688a:	f5b3 5f60 	cmp.w	r3, #14336	; 0x3800
    688e:	d001      	beq.n	6894 <mem_malloc+0x90>
						((struct mem *)(void *)&ram[mem2->next])->prev = ptr2;
    6890:	440b      	add	r3, r1
    6892:	805f      	strh	r7, [r3, #2]
				if (mem == lfree) {
    6894:	42a2      	cmp	r2, r4
    6896:	d105      	bne.n	68a4 <mem_malloc+0xa0>
					while (cur->used && cur != ram_end) {
    6898:	6873      	ldr	r3, [r6, #4]
    689a:	7910      	ldrb	r0, [r2, #4]
    689c:	b108      	cbz	r0, 68a2 <mem_malloc+0x9e>
    689e:	4293      	cmp	r3, r2
    68a0:	d10a      	bne.n	68b8 <mem_malloc+0xb4>
					lfree = cur;
    68a2:	60b2      	str	r2, [r6, #8]
				sys_mutex_unlock(&mem_mutex);
    68a4:	4809      	ldr	r0, [pc, #36]	; (68cc <mem_malloc+0xc8>)
    68a6:	4b0a      	ldr	r3, [pc, #40]	; (68d0 <mem_malloc+0xcc>)
    68a8:	4798      	blx	r3
				return (u8_t *)mem + SIZEOF_STRUCT_MEM;
    68aa:	f104 0008 	add.w	r0, r4, #8
}
    68ae:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
					mem->used = 1;
    68b2:	2301      	movs	r3, #1
    68b4:	7123      	strb	r3, [r4, #4]
    68b6:	e7ed      	b.n	6894 <mem_malloc+0x90>
						cur = (struct mem *)(void *)&ram[cur->next];
    68b8:	8812      	ldrh	r2, [r2, #0]
    68ba:	440a      	add	r2, r1
    68bc:	e7ed      	b.n	689a <mem_malloc+0x96>
    68be:	4603      	mov	r3, r0
    68c0:	e7be      	b.n	6840 <mem_malloc+0x3c>
    68c2:	bf00      	nop
    68c4:	20011118 	.word	0x20011118
    68c8:	00007a39 	.word	0x00007a39
    68cc:	20011124 	.word	0x20011124
    68d0:	00007a19 	.word	0x00007a19

000068d4 <tcp_accept_null>:
	LWIP_UNUSED_ARG(arg);
	LWIP_UNUSED_ARG(pcb);
	LWIP_UNUSED_ARG(err);

	return ERR_ABRT;
}
    68d4:	f06f 0009 	mvn.w	r0, #9
    68d8:	4770      	bx	lr
	...

000068dc <tcp_new_port>:
 * Allocate a new local TCP port.
 *
 * @return a new (free) local TCP port number
 */
static u16_t tcp_new_port(void)
{
    68dc:	b5f0      	push	{r4, r5, r6, r7, lr}
    68de:	4c12      	ldr	r4, [pc, #72]	; (6928 <tcp_new_port+0x4c>)
    68e0:	8823      	ldrh	r3, [r4, #0]
    68e2:	f44f 4080 	mov.w	r0, #16384	; 0x4000
	u8_t            i;
	u16_t           n = 0;
	struct tcp_pcb *pcb;

again:
	if (tcp_port++ == TCP_LOCAL_PORT_RANGE_END) {
    68e6:	f64f 76ff 	movw	r6, #65535	; 0xffff
    68ea:	42b3      	cmp	r3, r6
    68ec:	bf18      	it	ne
    68ee:	3301      	addne	r3, #1
    68f0:	4d0e      	ldr	r5, [pc, #56]	; (692c <tcp_new_port+0x50>)
    68f2:	bf14      	ite	ne
    68f4:	b29b      	uxthne	r3, r3
		tcp_port = TCP_LOCAL_PORT_RANGE_START;
    68f6:	f44f 4340 	moveq.w	r3, #49152	; 0xc000
    68fa:	2204      	movs	r2, #4
	}
	/* Check all PCB lists. */
	for (i = 0; i < NUM_TCP_PCB_LISTS; i++) {
		for (pcb = *tcp_pcb_lists[i]; pcb != NULL; pcb = pcb->next) {
    68fc:	f855 1b04 	ldr.w	r1, [r5], #4
    6900:	6809      	ldr	r1, [r1, #0]
    6902:	b931      	cbnz	r1, 6912 <tcp_new_port+0x36>
	for (i = 0; i < NUM_TCP_PCB_LISTS; i++) {
    6904:	3a01      	subs	r2, #1
    6906:	f012 02ff 	ands.w	r2, r2, #255	; 0xff
    690a:	d1f7      	bne.n	68fc <tcp_new_port+0x20>
    690c:	8023      	strh	r3, [r4, #0]
				}
				goto again;
			}
		}
	}
	return tcp_port;
    690e:	4618      	mov	r0, r3
    6910:	e007      	b.n	6922 <tcp_new_port+0x46>
			if (pcb->local_port == tcp_port) {
    6912:	8b4f      	ldrh	r7, [r1, #26]
    6914:	429f      	cmp	r7, r3
    6916:	d105      	bne.n	6924 <tcp_new_port+0x48>
				if (++n > (TCP_LOCAL_PORT_RANGE_END - TCP_LOCAL_PORT_RANGE_START)) {
    6918:	3801      	subs	r0, #1
    691a:	b280      	uxth	r0, r0
    691c:	2800      	cmp	r0, #0
    691e:	d1e4      	bne.n	68ea <tcp_new_port+0xe>
    6920:	8023      	strh	r3, [r4, #0]
}
    6922:	bdf0      	pop	{r4, r5, r6, r7, pc}
		for (pcb = *tcp_pcb_lists[i]; pcb != NULL; pcb = pcb->next) {
    6924:	68c9      	ldr	r1, [r1, #12]
    6926:	e7ec      	b.n	6902 <tcp_new_port+0x26>
    6928:	2000000c 	.word	0x2000000c
    692c:	0000b764 	.word	0x0000b764

00006930 <tcp_init>:
}
    6930:	4770      	bx	lr
	...

00006934 <tcp_bind>:
{
    6934:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	LWIP_ERROR("tcp_bind: can only bind in state CLOSED", pcb->state == CLOSED, return ERR_VAL);
    6936:	7e03      	ldrb	r3, [r0, #24]
{
    6938:	4604      	mov	r4, r0
    693a:	460d      	mov	r5, r1
	LWIP_ERROR("tcp_bind: can only bind in state CLOSED", pcb->state == CLOSED, return ERR_VAL);
    693c:	b103      	cbz	r3, 6940 <tcp_bind+0xc>
    693e:	e7fe      	b.n	693e <tcp_bind+0xa>
	if (port == 0) {
    6940:	b91a      	cbnz	r2, 694a <tcp_bind+0x16>
		port = tcp_new_port();
    6942:	4b16      	ldr	r3, [pc, #88]	; (699c <tcp_bind+0x68>)
    6944:	4798      	blx	r3
		if (port == 0) {
    6946:	4602      	mov	r2, r0
    6948:	b308      	cbz	r0, 698e <tcp_bind+0x5a>
	for (i = 0; i < max_pcb_list; i++) {
    694a:	4815      	ldr	r0, [pc, #84]	; (69a0 <tcp_bind+0x6c>)
    694c:	2100      	movs	r1, #0
		for (cpcb = *tcp_pcb_lists[i]; cpcb != NULL; cpcb = cpcb->next) {
    694e:	f850 3b04 	ldr.w	r3, [r0], #4
    6952:	681b      	ldr	r3, [r3, #0]
    6954:	b97b      	cbnz	r3, 6976 <tcp_bind+0x42>
	for (i = 0; i < max_pcb_list; i++) {
    6956:	3101      	adds	r1, #1
    6958:	2904      	cmp	r1, #4
    695a:	d1f8      	bne.n	694e <tcp_bind+0x1a>
	if (!ip_addr_isany(ipaddr)) {
    695c:	b115      	cbz	r5, 6964 <tcp_bind+0x30>
    695e:	682b      	ldr	r3, [r5, #0]
    6960:	b103      	cbz	r3, 6964 <tcp_bind+0x30>
		pcb->local_ip = *ipaddr;
    6962:	6023      	str	r3, [r4, #0]
	TCP_REG(&tcp_bound_pcbs, pcb);
    6964:	4b0f      	ldr	r3, [pc, #60]	; (69a4 <tcp_bind+0x70>)
	pcb->local_port = port;
    6966:	8362      	strh	r2, [r4, #26]
	TCP_REG(&tcp_bound_pcbs, pcb);
    6968:	681a      	ldr	r2, [r3, #0]
    696a:	60e2      	str	r2, [r4, #12]
    696c:	601c      	str	r4, [r3, #0]
    696e:	4b0e      	ldr	r3, [pc, #56]	; (69a8 <tcp_bind+0x74>)
    6970:	4798      	blx	r3
	return ERR_OK;
    6972:	2000      	movs	r0, #0
}
    6974:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
			if (cpcb->local_port == port) {
    6976:	8b5e      	ldrh	r6, [r3, #26]
    6978:	4296      	cmp	r6, r2
    697a:	d106      	bne.n	698a <tcp_bind+0x56>
					if (ip_addr_isany(&(cpcb->local_ip)) || ip_addr_isany(ipaddr)
    697c:	681f      	ldr	r7, [r3, #0]
    697e:	b14f      	cbz	r7, 6994 <tcp_bind+0x60>
    6980:	b145      	cbz	r5, 6994 <tcp_bind+0x60>
    6982:	682e      	ldr	r6, [r5, #0]
    6984:	b136      	cbz	r6, 6994 <tcp_bind+0x60>
					    || ip_addr_cmp(&(cpcb->local_ip), ipaddr)) {
    6986:	42b7      	cmp	r7, r6
    6988:	d004      	beq.n	6994 <tcp_bind+0x60>
		for (cpcb = *tcp_pcb_lists[i]; cpcb != NULL; cpcb = cpcb->next) {
    698a:	68db      	ldr	r3, [r3, #12]
    698c:	e7e2      	b.n	6954 <tcp_bind+0x20>
			return ERR_BUF;
    698e:	f06f 0001 	mvn.w	r0, #1
    6992:	e7ef      	b.n	6974 <tcp_bind+0x40>
						return ERR_USE;
    6994:	f06f 0007 	mvn.w	r0, #7
    6998:	e7ec      	b.n	6974 <tcp_bind+0x40>
    699a:	bf00      	nop
    699c:	000068dd 	.word	0x000068dd
    69a0:	0000b764 	.word	0x0000b764
    69a4:	2001493c 	.word	0x2001493c
    69a8:	000010a5 	.word	0x000010a5

000069ac <tcp_listen_with_backlog>:
{
    69ac:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	LWIP_ERROR("tcp_listen: pcb already connected", pcb->state == CLOSED, return NULL);
    69ae:	7e07      	ldrb	r7, [r0, #24]
{
    69b0:	4604      	mov	r4, r0
	LWIP_ERROR("tcp_listen: pcb already connected", pcb->state == CLOSED, return NULL);
    69b2:	b107      	cbz	r7, 69b6 <tcp_listen_with_backlog+0xa>
    69b4:	e7fe      	b.n	69b4 <tcp_listen_with_backlog+0x8>
	lpcb = (struct tcp_pcb_listen *)memp_malloc(MEMP_TCP_PCB_LISTEN);
    69b6:	4b1f      	ldr	r3, [pc, #124]	; (6a34 <tcp_listen_with_backlog+0x88>)
    69b8:	2002      	movs	r0, #2
    69ba:	4798      	blx	r3
	if (lpcb == NULL) {
    69bc:	4605      	mov	r5, r0
    69be:	b328      	cbz	r0, 6a0c <tcp_listen_with_backlog+0x60>
	lpcb->callback_arg = pcb->callback_arg;
    69c0:	6923      	ldr	r3, [r4, #16]
	lpcb->local_port   = pcb->local_port;
    69c2:	8b62      	ldrh	r2, [r4, #26]
	lpcb->callback_arg = pcb->callback_arg;
    69c4:	6103      	str	r3, [r0, #16]
	lpcb->state        = LISTEN;
    69c6:	2301      	movs	r3, #1
    69c8:	7603      	strb	r3, [r0, #24]
	lpcb->local_port   = pcb->local_port;
    69ca:	8342      	strh	r2, [r0, #26]
	lpcb->prio         = pcb->prio;
    69cc:	7e63      	ldrb	r3, [r4, #25]
    69ce:	7643      	strb	r3, [r0, #25]
	ip_set_option(lpcb, SOF_ACCEPTCONN);
    69d0:	7a23      	ldrb	r3, [r4, #8]
    69d2:	4e19      	ldr	r6, [pc, #100]	; (6a38 <tcp_listen_with_backlog+0x8c>)
    69d4:	f043 0302 	orr.w	r3, r3, #2
    69d8:	7203      	strb	r3, [r0, #8]
	lpcb->ttl = pcb->ttl;
    69da:	7aa3      	ldrb	r3, [r4, #10]
    69dc:	7283      	strb	r3, [r0, #10]
	lpcb->tos = pcb->tos;
    69de:	7a63      	ldrb	r3, [r4, #9]
    69e0:	7243      	strb	r3, [r0, #9]
	ip_addr_copy(lpcb->local_ip, pcb->local_ip);
    69e2:	6823      	ldr	r3, [r4, #0]
    69e4:	6003      	str	r3, [r0, #0]
	if (pcb->local_port != 0) {
    69e6:	b132      	cbz	r2, 69f6 <tcp_listen_with_backlog+0x4a>
		TCP_RMV(&tcp_bound_pcbs, pcb);
    69e8:	6833      	ldr	r3, [r6, #0]
    69ea:	42a3      	cmp	r3, r4
    69ec:	d110      	bne.n	6a10 <tcp_listen_with_backlog+0x64>
    69ee:	68e3      	ldr	r3, [r4, #12]
    69f0:	6033      	str	r3, [r6, #0]
    69f2:	2300      	movs	r3, #0
    69f4:	60e3      	str	r3, [r4, #12]
	memp_free(MEMP_TCP_PCB, pcb);
    69f6:	4b11      	ldr	r3, [pc, #68]	; (6a3c <tcp_listen_with_backlog+0x90>)
    69f8:	4621      	mov	r1, r4
    69fa:	2001      	movs	r0, #1
    69fc:	4798      	blx	r3
	lpcb->accept = tcp_accept_null;
    69fe:	4b10      	ldr	r3, [pc, #64]	; (6a40 <tcp_listen_with_backlog+0x94>)
    6a00:	616b      	str	r3, [r5, #20]
	TCP_REG(&tcp_listen_pcbs.pcbs, (struct tcp_pcb *)lpcb);
    6a02:	68b3      	ldr	r3, [r6, #8]
    6a04:	60eb      	str	r3, [r5, #12]
    6a06:	4b0f      	ldr	r3, [pc, #60]	; (6a44 <tcp_listen_with_backlog+0x98>)
    6a08:	60b5      	str	r5, [r6, #8]
    6a0a:	4798      	blx	r3
}
    6a0c:	4628      	mov	r0, r5
    6a0e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		TCP_RMV(&tcp_bound_pcbs, pcb);
    6a10:	6073      	str	r3, [r6, #4]
    6a12:	b91b      	cbnz	r3, 6a1c <tcp_listen_with_backlog+0x70>
    6a14:	2f00      	cmp	r7, #0
    6a16:	d0ec      	beq.n	69f2 <tcp_listen_with_backlog+0x46>
    6a18:	6073      	str	r3, [r6, #4]
    6a1a:	e7ea      	b.n	69f2 <tcp_listen_with_backlog+0x46>
    6a1c:	68d9      	ldr	r1, [r3, #12]
    6a1e:	42a1      	cmp	r1, r4
    6a20:	d104      	bne.n	6a2c <tcp_listen_with_backlog+0x80>
    6a22:	b107      	cbz	r7, 6a26 <tcp_listen_with_backlog+0x7a>
    6a24:	6073      	str	r3, [r6, #4]
    6a26:	68e2      	ldr	r2, [r4, #12]
    6a28:	60da      	str	r2, [r3, #12]
    6a2a:	e7e2      	b.n	69f2 <tcp_listen_with_backlog+0x46>
    6a2c:	2701      	movs	r7, #1
    6a2e:	460b      	mov	r3, r1
    6a30:	e7ef      	b.n	6a12 <tcp_listen_with_backlog+0x66>
    6a32:	bf00      	nop
    6a34:	00004c01 	.word	0x00004c01
    6a38:	2001493c 	.word	0x2001493c
    6a3c:	00004c1d 	.word	0x00004c1d
    6a40:	000068d5 	.word	0x000068d5
    6a44:	000010a5 	.word	0x000010a5

00006a48 <tcp_update_rcv_ann_wnd>:
{
    6a48:	4602      	mov	r2, r0
    6a4a:	b5f0      	push	{r4, r5, r6, r7, lr}
	if (TCP_SEQ_GEQ(new_right_edge, pcb->rcv_ann_right_edge + LWIP_MIN((TCP_WND / 2), pcb->mss))) {
    6a4c:	6b01      	ldr	r1, [r0, #48]	; 0x30
	u32_t new_right_edge = pcb->rcv_nxt + pcb->rcv_wnd;
    6a4e:	8d85      	ldrh	r5, [r0, #44]	; 0x2c
	if (TCP_SEQ_GEQ(new_right_edge, pcb->rcv_ann_right_edge + LWIP_MIN((TCP_WND / 2), pcb->mss))) {
    6a50:	8ed7      	ldrh	r7, [r2, #54]	; 0x36
	u32_t new_right_edge = pcb->rcv_nxt + pcb->rcv_wnd;
    6a52:	6a84      	ldr	r4, [r0, #40]	; 0x28
	if (TCP_SEQ_GEQ(new_right_edge, pcb->rcv_ann_right_edge + LWIP_MIN((TCP_WND / 2), pcb->mss))) {
    6a54:	1a6b      	subs	r3, r5, r1
    6a56:	f640 3668 	movw	r6, #2920	; 0xb68
    6a5a:	42b7      	cmp	r7, r6
    6a5c:	eb03 0004 	add.w	r0, r3, r4
    6a60:	bf94      	ite	ls
    6a62:	1bc3      	subls	r3, r0, r7
    6a64:	1b83      	subhi	r3, r0, r6
    6a66:	2b00      	cmp	r3, #0
    6a68:	db01      	blt.n	6a6e <tcp_update_rcv_ann_wnd+0x26>
		pcb->rcv_ann_wnd = pcb->rcv_wnd;
    6a6a:	85d5      	strh	r5, [r2, #46]	; 0x2e
}
    6a6c:	bdf0      	pop	{r4, r5, r6, r7, pc}
		if (TCP_SEQ_GT(pcb->rcv_nxt, pcb->rcv_ann_right_edge)) {
    6a6e:	1a63      	subs	r3, r4, r1
    6a70:	2b00      	cmp	r3, #0
    6a72:	f04f 0000 	mov.w	r0, #0
			u32_t new_rcv_ann_wnd = pcb->rcv_ann_right_edge - pcb->rcv_nxt;
    6a76:	bfd6      	itet	le
    6a78:	1b09      	suble	r1, r1, r4
			pcb->rcv_ann_wnd = 0;
    6a7a:	85d0      	strhgt	r0, [r2, #46]	; 0x2e
			pcb->rcv_ann_wnd = (u16_t)new_rcv_ann_wnd;
    6a7c:	85d1      	strhle	r1, [r2, #46]	; 0x2e
    6a7e:	e7f5      	b.n	6a6c <tcp_update_rcv_ann_wnd+0x24>

00006a80 <tcp_recved>:
	pcb->rcv_wnd += len;
    6a80:	8d83      	ldrh	r3, [r0, #44]	; 0x2c
    6a82:	4419      	add	r1, r3
    6a84:	b289      	uxth	r1, r1
	if (pcb->rcv_wnd > TCP_WND) {
    6a86:	f241 63d0 	movw	r3, #5840	; 0x16d0
    6a8a:	4299      	cmp	r1, r3
{
    6a8c:	b510      	push	{r4, lr}
		pcb->rcv_wnd = TCP_WND;
    6a8e:	bf8c      	ite	hi
    6a90:	8583      	strhhi	r3, [r0, #44]	; 0x2c
	pcb->rcv_wnd += len;
    6a92:	8581      	strhls	r1, [r0, #44]	; 0x2c
	wnd_inflation = tcp_update_rcv_ann_wnd(pcb);
    6a94:	4b08      	ldr	r3, [pc, #32]	; (6ab8 <tcp_recved+0x38>)
{
    6a96:	4604      	mov	r4, r0
	wnd_inflation = tcp_update_rcv_ann_wnd(pcb);
    6a98:	4798      	blx	r3
	if (wnd_inflation >= TCP_WND_UPDATE_THRESHOLD) {
    6a9a:	f240 53b3 	movw	r3, #1459	; 0x5b3
    6a9e:	4298      	cmp	r0, r3
    6aa0:	dd08      	ble.n	6ab4 <tcp_recved+0x34>
		tcp_ack_now(pcb);
    6aa2:	7fa3      	ldrb	r3, [r4, #30]
    6aa4:	f043 0302 	orr.w	r3, r3, #2
    6aa8:	77a3      	strb	r3, [r4, #30]
		tcp_output(pcb);
    6aaa:	4620      	mov	r0, r4
    6aac:	4b03      	ldr	r3, [pc, #12]	; (6abc <tcp_recved+0x3c>)
}
    6aae:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		tcp_output(pcb);
    6ab2:	4718      	bx	r3
}
    6ab4:	bd10      	pop	{r4, pc}
    6ab6:	bf00      	nop
    6ab8:	00006a49 	.word	0x00006a49
    6abc:	000024a5 	.word	0x000024a5

00006ac0 <tcp_seg_free>:
 * Frees a TCP segment (tcp_seg structure).
 *
 * @param seg single tcp_seg to free
 */
void tcp_seg_free(struct tcp_seg *seg)
{
    6ac0:	b510      	push	{r4, lr}
	if (seg != NULL) {
    6ac2:	4604      	mov	r4, r0
    6ac4:	b148      	cbz	r0, 6ada <tcp_seg_free+0x1a>
		if (seg->p != NULL) {
    6ac6:	6840      	ldr	r0, [r0, #4]
    6ac8:	b108      	cbz	r0, 6ace <tcp_seg_free+0xe>
			pbuf_free(seg->p);
    6aca:	4b04      	ldr	r3, [pc, #16]	; (6adc <tcp_seg_free+0x1c>)
    6acc:	4798      	blx	r3
#if TCP_DEBUG
			seg->p = NULL;
#endif /* TCP_DEBUG */
		}
		memp_free(MEMP_TCP_SEG, seg);
    6ace:	4621      	mov	r1, r4
    6ad0:	4b03      	ldr	r3, [pc, #12]	; (6ae0 <tcp_seg_free+0x20>)
	}
}
    6ad2:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		memp_free(MEMP_TCP_SEG, seg);
    6ad6:	2003      	movs	r0, #3
    6ad8:	4718      	bx	r3
}
    6ada:	bd10      	pop	{r4, pc}
    6adc:	000030e5 	.word	0x000030e5
    6ae0:	00004c1d 	.word	0x00004c1d

00006ae4 <tcp_segs_free>:
{
    6ae4:	b538      	push	{r3, r4, r5, lr}
		tcp_seg_free(seg);
    6ae6:	4c03      	ldr	r4, [pc, #12]	; (6af4 <tcp_segs_free+0x10>)
	while (seg != NULL) {
    6ae8:	b900      	cbnz	r0, 6aec <tcp_segs_free+0x8>
}
    6aea:	bd38      	pop	{r3, r4, r5, pc}
		struct tcp_seg *next = seg->next;
    6aec:	6805      	ldr	r5, [r0, #0]
		tcp_seg_free(seg);
    6aee:	47a0      	blx	r4
		seg = next;
    6af0:	4628      	mov	r0, r5
    6af2:	e7f9      	b.n	6ae8 <tcp_segs_free+0x4>
    6af4:	00006ac1 	.word	0x00006ac1

00006af8 <tcp_seg_copy>:
 *
 * @param seg the old tcp_seg
 * @return a copy of seg
 */
struct tcp_seg *tcp_seg_copy(struct tcp_seg *seg)
{
    6af8:	b538      	push	{r3, r4, r5, lr}
	struct tcp_seg *cseg;

	cseg = (struct tcp_seg *)memp_malloc(MEMP_TCP_SEG);
    6afa:	4b0a      	ldr	r3, [pc, #40]	; (6b24 <tcp_seg_copy+0x2c>)
{
    6afc:	4604      	mov	r4, r0
	cseg = (struct tcp_seg *)memp_malloc(MEMP_TCP_SEG);
    6afe:	2003      	movs	r0, #3
    6b00:	4798      	blx	r3
	if (cseg == NULL) {
    6b02:	4605      	mov	r5, r0
    6b04:	b160      	cbz	r0, 6b20 <tcp_seg_copy+0x28>
		return NULL;
	}
	SMEMCPY((u8_t *)cseg, (const u8_t *)seg, sizeof(struct tcp_seg));
    6b06:	4623      	mov	r3, r4
    6b08:	4602      	mov	r2, r0
    6b0a:	f104 0110 	add.w	r1, r4, #16
    6b0e:	f853 0b04 	ldr.w	r0, [r3], #4
    6b12:	f842 0b04 	str.w	r0, [r2], #4
    6b16:	428b      	cmp	r3, r1
    6b18:	d1f9      	bne.n	6b0e <tcp_seg_copy+0x16>
	pbuf_ref(cseg->p);
    6b1a:	6868      	ldr	r0, [r5, #4]
    6b1c:	4b02      	ldr	r3, [pc, #8]	; (6b28 <tcp_seg_copy+0x30>)
    6b1e:	4798      	blx	r3
	return cseg;
}
    6b20:	4628      	mov	r0, r5
    6b22:	bd38      	pop	{r3, r4, r5, pc}
    6b24:	00004c01 	.word	0x00004c01
    6b28:	000032b1 	.word	0x000032b1

00006b2c <tcp_arg>:
 */
void tcp_arg(struct tcp_pcb *pcb, void *arg)
{
	/* This function is allowed to be called for both listen pcbs and
	   connection pcbs. */
	pcb->callback_arg = arg;
    6b2c:	6101      	str	r1, [r0, #16]
}
    6b2e:	4770      	bx	lr

00006b30 <tcp_recv>:
 * @param recv callback function to call for this pcb when data is received
 */
void tcp_recv(struct tcp_pcb *pcb, tcp_recv_fn recv)
{
	LWIP_ASSERT("invalid socket state for recv callback", pcb->state != LISTEN);
	pcb->recv = recv;
    6b30:	f8c0 1080 	str.w	r1, [r0, #128]	; 0x80
}
    6b34:	4770      	bx	lr

00006b36 <tcp_sent>:
 * @param sent callback function to call for this pcb when data is successfully sent
 */
void tcp_sent(struct tcp_pcb *pcb, tcp_sent_fn sent)
{
	LWIP_ASSERT("invalid socket state for sent callback", pcb->state != LISTEN);
	pcb->sent = sent;
    6b36:	67c1      	str	r1, [r0, #124]	; 0x7c
}
    6b38:	4770      	bx	lr

00006b3a <tcp_err>:
 *        has occured on the connection
 */
void tcp_err(struct tcp_pcb *pcb, tcp_err_fn err)
{
	LWIP_ASSERT("invalid socket state for err callback", pcb->state != LISTEN);
	pcb->errf = err;
    6b3a:	f8c0 108c 	str.w	r1, [r0, #140]	; 0x8c
}
    6b3e:	4770      	bx	lr

00006b40 <tcp_accept>:
 */
void tcp_accept(struct tcp_pcb *pcb, tcp_accept_fn accept)
{
	/* This function is allowed to be called for both listen pcbs and
	   connection pcbs. */
	pcb->accept = accept;
    6b40:	6141      	str	r1, [r0, #20]
}
    6b42:	4770      	bx	lr

00006b44 <tcp_poll>:
 */
void tcp_poll(struct tcp_pcb *pcb, tcp_poll_fn poll, u8_t interval)
{
	LWIP_ASSERT("invalid socket state for poll", pcb->state != LISTEN);
#if LWIP_CALLBACK_API
	pcb->poll = poll;
    6b44:	f8c0 1088 	str.w	r1, [r0, #136]	; 0x88
#else  /* LWIP_CALLBACK_API */
	LWIP_UNUSED_ARG(poll);
#endif /* LWIP_CALLBACK_API */
	pcb->pollinterval = interval;
    6b48:	f880 2020 	strb.w	r2, [r0, #32]
}
    6b4c:	4770      	bx	lr
	...

00006b50 <tcp_pcb_purge>:
 * (pcb->ooseq, pcb->unsent and pcb->unacked are freed).
 *
 * @param pcb tcp_pcb to purge. The pcb itself is not deallocated!
 */
void tcp_pcb_purge(struct tcp_pcb *pcb)
{
    6b50:	b570      	push	{r4, r5, r6, lr}
	if (pcb->state != CLOSED && pcb->state != TIME_WAIT && pcb->state != LISTEN) {
    6b52:	7e03      	ldrb	r3, [r0, #24]
    6b54:	2b01      	cmp	r3, #1
{
    6b56:	4604      	mov	r4, r0
	if (pcb->state != CLOSED && pcb->state != TIME_WAIT && pcb->state != LISTEN) {
    6b58:	d917      	bls.n	6b8a <tcp_pcb_purge+0x3a>
    6b5a:	2b0a      	cmp	r3, #10
    6b5c:	d015      	beq.n	6b8a <tcp_pcb_purge+0x3a>
				}
			}
		}
#endif /* TCP_LISTEN_BACKLOG */

		if (pcb->refused_data != NULL) {
    6b5e:	6f80      	ldr	r0, [r0, #120]	; 0x78
    6b60:	b118      	cbz	r0, 6b6a <tcp_pcb_purge+0x1a>
			LWIP_DEBUGF(TCP_DEBUG, ("tcp_pcb_purge: data left on ->refused_data\n"));
			pbuf_free(pcb->refused_data);
    6b62:	4b0a      	ldr	r3, [pc, #40]	; (6b8c <tcp_pcb_purge+0x3c>)
    6b64:	4798      	blx	r3
			pcb->refused_data = NULL;
    6b66:	2300      	movs	r3, #0
    6b68:	67a3      	str	r3, [r4, #120]	; 0x78
		}
#if TCP_QUEUE_OOSEQ
		if (pcb->ooseq != NULL) {
			LWIP_DEBUGF(TCP_DEBUG, ("tcp_pcb_purge: data left on ->ooseq\n"));
		}
		tcp_segs_free(pcb->ooseq);
    6b6a:	4e09      	ldr	r6, [pc, #36]	; (6b90 <tcp_pcb_purge+0x40>)
    6b6c:	6f60      	ldr	r0, [r4, #116]	; 0x74
    6b6e:	47b0      	blx	r6
		pcb->ooseq = NULL;
    6b70:	2500      	movs	r5, #0
#endif /* TCP_QUEUE_OOSEQ */

		/* Stop the retransmission timer as it will expect data on unacked
		   queue if it fires */
		pcb->rtime = -1;
    6b72:	f64f 73ff 	movw	r3, #65535	; 0xffff

		tcp_segs_free(pcb->unsent);
    6b76:	6ee0      	ldr	r0, [r4, #108]	; 0x6c
		pcb->rtime = -1;
    6b78:	86a3      	strh	r3, [r4, #52]	; 0x34
		pcb->ooseq = NULL;
    6b7a:	6765      	str	r5, [r4, #116]	; 0x74
		tcp_segs_free(pcb->unsent);
    6b7c:	47b0      	blx	r6
		tcp_segs_free(pcb->unacked);
    6b7e:	6f20      	ldr	r0, [r4, #112]	; 0x70
    6b80:	47b0      	blx	r6
		pcb->unacked = pcb->unsent = NULL;
    6b82:	e9c4 551b 	strd	r5, r5, [r4, #108]	; 0x6c
#if TCP_OVERSIZE
		pcb->unsent_oversize = 0;
    6b86:	f8a4 506a 	strh.w	r5, [r4, #106]	; 0x6a
#endif /* TCP_OVERSIZE */
	}
}
    6b8a:	bd70      	pop	{r4, r5, r6, pc}
    6b8c:	000030e5 	.word	0x000030e5
    6b90:	00006ae5 	.word	0x00006ae5

00006b94 <tcp_slowtmr>:
{
    6b94:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	++tcp_ticks;
    6b98:	4ea4      	ldr	r6, [pc, #656]	; (6e2c <tcp_slowtmr+0x298>)
			tcp_pcb_purge(pcb);
    6b9a:	f8df b294 	ldr.w	fp, [pc, #660]	; 6e30 <tcp_slowtmr+0x29c>
	++tcp_ticks;
    6b9e:	68f3      	ldr	r3, [r6, #12]
			memp_free(MEMP_TCP_PCB, pcb2);
    6ba0:	f8df a2ac 	ldr.w	sl, [pc, #684]	; 6e50 <tcp_slowtmr+0x2bc>
	++tcp_ticks;
    6ba4:	3301      	adds	r3, #1
    6ba6:	60f3      	str	r3, [r6, #12]
	++tcp_timer_ctr;
    6ba8:	7c33      	ldrb	r3, [r6, #16]
    6baa:	3301      	adds	r3, #1
{
    6bac:	b085      	sub	sp, #20
	++tcp_timer_ctr;
    6bae:	7433      	strb	r3, [r6, #16]
	pcb  = tcp_active_pcbs;
    6bb0:	6974      	ldr	r4, [r6, #20]
				tcp_rst(pcb->snd_nxt, pcb->rcv_nxt, &pcb->local_ip, &pcb->remote_ip, pcb->local_port, pcb->remote_port);
    6bb2:	f8df 92a0 	ldr.w	r9, [pc, #672]	; 6e54 <tcp_slowtmr+0x2c0>
	prev = NULL;
    6bb6:	f04f 0800 	mov.w	r8, #0
	while (pcb != NULL) {
    6bba:	b94c      	cbnz	r4, 6bd0 <tcp_slowtmr+0x3c>
	pcb  = tcp_tw_pcbs;
    6bbc:	69f5      	ldr	r5, [r6, #28]
			tcp_pcb_purge(pcb);
    6bbe:	4f9c      	ldr	r7, [pc, #624]	; (6e30 <tcp_slowtmr+0x29c>)
			memp_free(MEMP_TCP_PCB, pcb2);
    6bc0:	f8df 828c 	ldr.w	r8, [pc, #652]	; 6e50 <tcp_slowtmr+0x2bc>
	while (pcb != NULL) {
    6bc4:	2d00      	cmp	r5, #0
    6bc6:	f040 811b 	bne.w	6e00 <tcp_slowtmr+0x26c>
}
    6bca:	b005      	add	sp, #20
    6bcc:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		if (pcb->last_timer == tcp_timer_ctr) {
    6bd0:	7c33      	ldrb	r3, [r6, #16]
    6bd2:	f894 2021 	ldrb.w	r2, [r4, #33]	; 0x21
    6bd6:	429a      	cmp	r2, r3
    6bd8:	d102      	bne.n	6be0 <tcp_slowtmr+0x4c>
			pcb = pcb->next;
    6bda:	68e7      	ldr	r7, [r4, #12]
			continue;
    6bdc:	463c      	mov	r4, r7
    6bde:	e7ec      	b.n	6bba <tcp_slowtmr+0x26>
		if (pcb->state == SYN_SENT && pcb->nrtx == TCP_SYNMAXRTX) {
    6be0:	7e22      	ldrb	r2, [r4, #24]
    6be2:	f894 1046 	ldrb.w	r1, [r4, #70]	; 0x46
		pcb->last_timer = tcp_timer_ctr;
    6be6:	f884 3021 	strb.w	r3, [r4, #33]	; 0x21
		if (pcb->state == SYN_SENT && pcb->nrtx == TCP_SYNMAXRTX) {
    6bea:	2a02      	cmp	r2, #2
    6bec:	d102      	bne.n	6bf4 <tcp_slowtmr+0x60>
    6bee:	2906      	cmp	r1, #6
    6bf0:	f000 80ca 	beq.w	6d88 <tcp_slowtmr+0x1f4>
		} else if (pcb->nrtx == TCP_MAXRTX) {
    6bf4:	290c      	cmp	r1, #12
    6bf6:	f000 80c7 	beq.w	6d88 <tcp_slowtmr+0x1f4>
			if (pcb->persist_backoff > 0) {
    6bfa:	f894 5095 	ldrb.w	r5, [r4, #149]	; 0x95
    6bfe:	2d00      	cmp	r5, #0
    6c00:	f000 8089 	beq.w	6d16 <tcp_slowtmr+0x182>
				if (pcb->persist_cnt >= tcp_persist_backoff[pcb->persist_backoff - 1]) {
    6c04:	4a8b      	ldr	r2, [pc, #556]	; (6e34 <tcp_slowtmr+0x2a0>)
				pcb->persist_cnt++;
    6c06:	f894 3094 	ldrb.w	r3, [r4, #148]	; 0x94
				if (pcb->persist_cnt >= tcp_persist_backoff[pcb->persist_backoff - 1]) {
    6c0a:	442a      	add	r2, r5
				pcb->persist_cnt++;
    6c0c:	3301      	adds	r3, #1
				if (pcb->persist_cnt >= tcp_persist_backoff[pcb->persist_backoff - 1]) {
    6c0e:	7bd2      	ldrb	r2, [r2, #15]
				pcb->persist_cnt++;
    6c10:	b2db      	uxtb	r3, r3
				if (pcb->persist_cnt >= tcp_persist_backoff[pcb->persist_backoff - 1]) {
    6c12:	429a      	cmp	r2, r3
				pcb->persist_cnt++;
    6c14:	f884 3094 	strb.w	r3, [r4, #148]	; 0x94
				if (pcb->persist_cnt >= tcp_persist_backoff[pcb->persist_backoff - 1]) {
    6c18:	d96f      	bls.n	6cfa <tcp_slowtmr+0x166>
		pcb_remove = 0;
    6c1a:	2500      	movs	r5, #0
		if (pcb->state == FIN_WAIT_2) {
    6c1c:	7e21      	ldrb	r1, [r4, #24]
    6c1e:	2906      	cmp	r1, #6
    6c20:	d109      	bne.n	6c36 <tcp_slowtmr+0xa2>
			if (pcb->flags & TF_RXCLOSED) {
    6c22:	7fa3      	ldrb	r3, [r4, #30]
    6c24:	06db      	lsls	r3, r3, #27
    6c26:	d506      	bpl.n	6c36 <tcp_slowtmr+0xa2>
				if ((u32_t)(tcp_ticks - pcb->tmr) > TCP_FIN_WAIT_TIMEOUT / TCP_SLOW_INTERVAL) {
    6c28:	68f3      	ldr	r3, [r6, #12]
    6c2a:	6a62      	ldr	r2, [r4, #36]	; 0x24
    6c2c:	1a9b      	subs	r3, r3, r2
    6c2e:	2b28      	cmp	r3, #40	; 0x28
					++pcb_remove;
    6c30:	bf84      	itt	hi
    6c32:	3501      	addhi	r5, #1
    6c34:	b2ed      	uxtbhi	r5, r5
		if (ip_get_option(pcb, SOF_KEEPALIVE) && ((pcb->state == ESTABLISHED) || (pcb->state == CLOSE_WAIT))) {
    6c36:	7a27      	ldrb	r7, [r4, #8]
    6c38:	f017 0708 	ands.w	r7, r7, #8
    6c3c:	d017      	beq.n	6c6e <tcp_slowtmr+0xda>
    6c3e:	2904      	cmp	r1, #4
    6c40:	d002      	beq.n	6c48 <tcp_slowtmr+0xb4>
    6c42:	2907      	cmp	r1, #7
    6c44:	f040 80b3 	bne.w	6dae <tcp_slowtmr+0x21a>
			if ((u32_t)(tcp_ticks - pcb->tmr) > (pcb->keep_idle + TCP_KEEP_DUR(pcb)) / TCP_SLOW_INTERVAL) {
    6c48:	6a63      	ldr	r3, [r4, #36]	; 0x24
    6c4a:	68f1      	ldr	r1, [r6, #12]
    6c4c:	1ac9      	subs	r1, r1, r3
    6c4e:	f8d4 3090 	ldr.w	r3, [r4, #144]	; 0x90
    6c52:	f503 2224 	add.w	r2, r3, #671744	; 0xa4000
    6c56:	f602 42b8 	addw	r2, r2, #3256	; 0xcb8
    6c5a:	f44f 70fa 	mov.w	r0, #500	; 0x1f4
    6c5e:	fbb2 f2f0 	udiv	r2, r2, r0
    6c62:	4291      	cmp	r1, r2
    6c64:	f240 8092 	bls.w	6d8c <tcp_slowtmr+0x1f8>
				++pcb_remove;
    6c68:	3501      	adds	r5, #1
    6c6a:	b2ed      	uxtb	r5, r5
				++pcb_reset;
    6c6c:	2701      	movs	r7, #1
		if (pcb->ooseq != NULL && (u32_t)tcp_ticks - pcb->tmr >= pcb->rto * TCP_OOSEQ_TIMEOUT) {
    6c6e:	6f60      	ldr	r0, [r4, #116]	; 0x74
    6c70:	b168      	cbz	r0, 6c8e <tcp_slowtmr+0xfa>
    6c72:	68f3      	ldr	r3, [r6, #12]
    6c74:	6a62      	ldr	r2, [r4, #36]	; 0x24
    6c76:	f9b4 1044 	ldrsh.w	r1, [r4, #68]	; 0x44
    6c7a:	1a9b      	subs	r3, r3, r2
    6c7c:	eb01 0141 	add.w	r1, r1, r1, lsl #1
    6c80:	ebb3 0f41 	cmp.w	r3, r1, lsl #1
    6c84:	d303      	bcc.n	6c8e <tcp_slowtmr+0xfa>
			tcp_segs_free(pcb->ooseq);
    6c86:	4b6c      	ldr	r3, [pc, #432]	; (6e38 <tcp_slowtmr+0x2a4>)
    6c88:	4798      	blx	r3
			pcb->ooseq = NULL;
    6c8a:	2300      	movs	r3, #0
    6c8c:	6763      	str	r3, [r4, #116]	; 0x74
		if (pcb->state == SYN_RCVD) {
    6c8e:	7e23      	ldrb	r3, [r4, #24]
    6c90:	2b03      	cmp	r3, #3
    6c92:	f040 808e 	bne.w	6db2 <tcp_slowtmr+0x21e>
			if ((u32_t)(tcp_ticks - pcb->tmr) > TCP_SYN_RCVD_TIMEOUT / TCP_SLOW_INTERVAL) {
    6c96:	68f3      	ldr	r3, [r6, #12]
    6c98:	6a62      	ldr	r2, [r4, #36]	; 0x24
    6c9a:	1a9b      	subs	r3, r3, r2
    6c9c:	2b28      	cmp	r3, #40	; 0x28
			if ((u32_t)(tcp_ticks - pcb->tmr) > 2 * TCP_MSL / TCP_SLOW_INTERVAL) {
    6c9e:	d802      	bhi.n	6ca6 <tcp_slowtmr+0x112>
		if (pcb_remove) {
    6ca0:	2d00      	cmp	r5, #0
    6ca2:	f000 8090 	beq.w	6dc6 <tcp_slowtmr+0x232>
			tcp_pcb_purge(pcb);
    6ca6:	4620      	mov	r0, r4
    6ca8:	47d8      	blx	fp
			if (prev != NULL) {
    6caa:	68e3      	ldr	r3, [r4, #12]
    6cac:	f1b8 0f00 	cmp.w	r8, #0
    6cb0:	f000 8087 	beq.w	6dc2 <tcp_slowtmr+0x22e>
				prev->next = pcb->next;
    6cb4:	f8c8 300c 	str.w	r3, [r8, #12]
			if (pcb_reset) {
    6cb8:	b147      	cbz	r7, 6ccc <tcp_slowtmr+0x138>
				tcp_rst(pcb->snd_nxt, pcb->rcv_nxt, &pcb->local_ip, &pcb->remote_ip, pcb->local_port, pcb->remote_port);
    6cba:	8ba3      	ldrh	r3, [r4, #28]
    6cbc:	9301      	str	r3, [sp, #4]
    6cbe:	8b63      	ldrh	r3, [r4, #26]
    6cc0:	9300      	str	r3, [sp, #0]
    6cc2:	6aa1      	ldr	r1, [r4, #40]	; 0x28
    6cc4:	6d20      	ldr	r0, [r4, #80]	; 0x50
    6cc6:	1d23      	adds	r3, r4, #4
    6cc8:	4622      	mov	r2, r4
    6cca:	47c8      	blx	r9
			err_arg = pcb->callback_arg;
    6ccc:	6923      	ldr	r3, [r4, #16]
			err_fn  = pcb->errf;
    6cce:	f8d4 508c 	ldr.w	r5, [r4, #140]	; 0x8c
			pcb     = pcb->next;
    6cd2:	68e7      	ldr	r7, [r4, #12]
			err_arg = pcb->callback_arg;
    6cd4:	9303      	str	r3, [sp, #12]
			memp_free(MEMP_TCP_PCB, pcb2);
    6cd6:	4621      	mov	r1, r4
    6cd8:	2001      	movs	r0, #1
    6cda:	47d0      	blx	sl
			tcp_active_pcbs_changed = 0;
    6cdc:	2200      	movs	r2, #0
    6cde:	7632      	strb	r2, [r6, #24]
			TCP_EVENT_ERR(err_fn, err_arg, ERR_ABRT);
    6ce0:	2d00      	cmp	r5, #0
    6ce2:	f43f af7b 	beq.w	6bdc <tcp_slowtmr+0x48>
    6ce6:	9b03      	ldr	r3, [sp, #12]
    6ce8:	f06f 0109 	mvn.w	r1, #9
    6cec:	4618      	mov	r0, r3
    6cee:	47a8      	blx	r5
			if (tcp_active_pcbs_changed) {
    6cf0:	7e33      	ldrb	r3, [r6, #24]
    6cf2:	2b00      	cmp	r3, #0
    6cf4:	f43f af72 	beq.w	6bdc <tcp_slowtmr+0x48>
    6cf8:	e75a      	b.n	6bb0 <tcp_slowtmr+0x1c>
					if (pcb->persist_backoff < sizeof(tcp_persist_backoff)) {
    6cfa:	2d06      	cmp	r5, #6
					pcb->persist_cnt = 0;
    6cfc:	f04f 0300 	mov.w	r3, #0
						pcb->persist_backoff++;
    6d00:	bf98      	it	ls
    6d02:	3501      	addls	r5, #1
					pcb->persist_cnt = 0;
    6d04:	f884 3094 	strb.w	r3, [r4, #148]	; 0x94
						pcb->persist_backoff++;
    6d08:	bf98      	it	ls
    6d0a:	f884 5095 	strbls.w	r5, [r4, #149]	; 0x95
					tcp_zero_window_probe(pcb);
    6d0e:	4b4b      	ldr	r3, [pc, #300]	; (6e3c <tcp_slowtmr+0x2a8>)
    6d10:	4620      	mov	r0, r4
    6d12:	4798      	blx	r3
    6d14:	e781      	b.n	6c1a <tcp_slowtmr+0x86>
				if (pcb->rtime >= 0) {
    6d16:	f9b4 3034 	ldrsh.w	r3, [r4, #52]	; 0x34
    6d1a:	2b00      	cmp	r3, #0
					++pcb->rtime;
    6d1c:	bfa4      	itt	ge
    6d1e:	3301      	addge	r3, #1
    6d20:	86a3      	strhge	r3, [r4, #52]	; 0x34
				if (pcb->unacked != NULL && pcb->rtime >= pcb->rto) {
    6d22:	6f23      	ldr	r3, [r4, #112]	; 0x70
    6d24:	2b00      	cmp	r3, #0
    6d26:	f43f af78 	beq.w	6c1a <tcp_slowtmr+0x86>
    6d2a:	f9b4 0034 	ldrsh.w	r0, [r4, #52]	; 0x34
    6d2e:	f9b4 3044 	ldrsh.w	r3, [r4, #68]	; 0x44
    6d32:	4298      	cmp	r0, r3
    6d34:	f6ff af71 	blt.w	6c1a <tcp_slowtmr+0x86>
					if (pcb->state != SYN_SENT) {
    6d38:	2a02      	cmp	r2, #2
    6d3a:	d00b      	beq.n	6d54 <tcp_slowtmr+0x1c0>
						pcb->rto = ((pcb->sa >> 3) + pcb->sv) << tcp_backoff[pcb->nrtx];
    6d3c:	f9b4 2040 	ldrsh.w	r2, [r4, #64]	; 0x40
    6d40:	f9b4 3042 	ldrsh.w	r3, [r4, #66]	; 0x42
    6d44:	eb03 03e2 	add.w	r3, r3, r2, asr #3
    6d48:	4a3a      	ldr	r2, [pc, #232]	; (6e34 <tcp_slowtmr+0x2a0>)
    6d4a:	440a      	add	r2, r1
    6d4c:	7dd2      	ldrb	r2, [r2, #23]
    6d4e:	4093      	lsls	r3, r2
    6d50:	f8a4 3044 	strh.w	r3, [r4, #68]	; 0x44
					pcb->rtime = 0;
    6d54:	2300      	movs	r3, #0
					eff_wnd       = LWIP_MIN(pcb->cwnd, pcb->snd_wnd);
    6d56:	f8b4 204c 	ldrh.w	r2, [r4, #76]	; 0x4c
					pcb->rtime = 0;
    6d5a:	86a3      	strh	r3, [r4, #52]	; 0x34
					eff_wnd       = LWIP_MIN(pcb->cwnd, pcb->snd_wnd);
    6d5c:	f8b4 3060 	ldrh.w	r3, [r4, #96]	; 0x60
					pcb->ssthresh = eff_wnd >> 1;
    6d60:	4293      	cmp	r3, r2
    6d62:	bf28      	it	cs
    6d64:	4613      	movcs	r3, r2
					if (pcb->ssthresh < (pcb->mss << 1)) {
    6d66:	8ee2      	ldrh	r2, [r4, #54]	; 0x36
					pcb->cwnd = pcb->mss;
    6d68:	f8a4 204c 	strh.w	r2, [r4, #76]	; 0x4c
					pcb->ssthresh = eff_wnd >> 1;
    6d6c:	085b      	lsrs	r3, r3, #1
					if (pcb->ssthresh < (pcb->mss << 1)) {
    6d6e:	ebb3 0f42 	cmp.w	r3, r2, lsl #1
    6d72:	ea4f 0142 	mov.w	r1, r2, lsl #1
					pcb->ssthresh = eff_wnd >> 1;
    6d76:	f8a4 304e 	strh.w	r3, [r4, #78]	; 0x4e
					tcp_rexmit_rto(pcb);
    6d7a:	4620      	mov	r0, r4
    6d7c:	4b30      	ldr	r3, [pc, #192]	; (6e40 <tcp_slowtmr+0x2ac>)
						pcb->ssthresh = (pcb->mss << 1);
    6d7e:	bfb8      	it	lt
    6d80:	f8a4 104e 	strhlt.w	r1, [r4, #78]	; 0x4e
					tcp_rexmit_rto(pcb);
    6d84:	4798      	blx	r3
    6d86:	e749      	b.n	6c1c <tcp_slowtmr+0x88>
			++pcb_remove;
    6d88:	2501      	movs	r5, #1
    6d8a:	e747      	b.n	6c1c <tcp_slowtmr+0x88>
			           > (pcb->keep_idle + pcb->keep_cnt_sent * TCP_KEEP_INTVL(pcb)) / TCP_SLOW_INTERVAL) {
    6d8c:	f894 2096 	ldrb.w	r2, [r4, #150]	; 0x96
    6d90:	4f2c      	ldr	r7, [pc, #176]	; (6e44 <tcp_slowtmr+0x2b0>)
    6d92:	fb07 3302 	mla	r3, r7, r2, r3
    6d96:	fbb3 f3f0 	udiv	r3, r3, r0
			} else if ((u32_t)(tcp_ticks - pcb->tmr)
    6d9a:	4299      	cmp	r1, r3
    6d9c:	d907      	bls.n	6dae <tcp_slowtmr+0x21a>
				tcp_keepalive(pcb);
    6d9e:	4b2a      	ldr	r3, [pc, #168]	; (6e48 <tcp_slowtmr+0x2b4>)
    6da0:	4620      	mov	r0, r4
    6da2:	4798      	blx	r3
				pcb->keep_cnt_sent++;
    6da4:	f894 3096 	ldrb.w	r3, [r4, #150]	; 0x96
    6da8:	3301      	adds	r3, #1
    6daa:	f884 3096 	strb.w	r3, [r4, #150]	; 0x96
		pcb_reset  = 0;
    6dae:	2700      	movs	r7, #0
    6db0:	e75d      	b.n	6c6e <tcp_slowtmr+0xda>
		if (pcb->state == LAST_ACK) {
    6db2:	2b09      	cmp	r3, #9
    6db4:	f47f af74 	bne.w	6ca0 <tcp_slowtmr+0x10c>
			if ((u32_t)(tcp_ticks - pcb->tmr) > 2 * TCP_MSL / TCP_SLOW_INTERVAL) {
    6db8:	68f3      	ldr	r3, [r6, #12]
    6dba:	6a62      	ldr	r2, [r4, #36]	; 0x24
    6dbc:	1a9b      	subs	r3, r3, r2
    6dbe:	2bf0      	cmp	r3, #240	; 0xf0
    6dc0:	e76d      	b.n	6c9e <tcp_slowtmr+0x10a>
				tcp_active_pcbs = pcb->next;
    6dc2:	6173      	str	r3, [r6, #20]
    6dc4:	e778      	b.n	6cb8 <tcp_slowtmr+0x124>
			++prev->polltmr;
    6dc6:	7fe3      	ldrb	r3, [r4, #31]
			if (prev->polltmr >= prev->pollinterval) {
    6dc8:	f894 2020 	ldrb.w	r2, [r4, #32]
			pcb  = pcb->next;
    6dcc:	68e7      	ldr	r7, [r4, #12]
			++prev->polltmr;
    6dce:	3301      	adds	r3, #1
    6dd0:	b2db      	uxtb	r3, r3
			if (prev->polltmr >= prev->pollinterval) {
    6dd2:	429a      	cmp	r2, r3
			++prev->polltmr;
    6dd4:	77e3      	strb	r3, [r4, #31]
			if (prev->polltmr >= prev->pollinterval) {
    6dd6:	d807      	bhi.n	6de8 <tcp_slowtmr+0x254>
				TCP_EVENT_POLL(prev, err);
    6dd8:	f8d4 3088 	ldr.w	r3, [r4, #136]	; 0x88
				prev->polltmr = 0;
    6ddc:	77e5      	strb	r5, [r4, #31]
				tcp_active_pcbs_changed = 0;
    6dde:	7635      	strb	r5, [r6, #24]
				TCP_EVENT_POLL(prev, err);
    6de0:	b923      	cbnz	r3, 6dec <tcp_slowtmr+0x258>
					tcp_output(prev);
    6de2:	4b1a      	ldr	r3, [pc, #104]	; (6e4c <tcp_slowtmr+0x2b8>)
    6de4:	4620      	mov	r0, r4
    6de6:	4798      	blx	r3
    6de8:	46a0      	mov	r8, r4
    6dea:	e6f7      	b.n	6bdc <tcp_slowtmr+0x48>
				TCP_EVENT_POLL(prev, err);
    6dec:	6920      	ldr	r0, [r4, #16]
    6dee:	4621      	mov	r1, r4
    6df0:	4798      	blx	r3
				if (tcp_active_pcbs_changed) {
    6df2:	7e33      	ldrb	r3, [r6, #24]
    6df4:	2b00      	cmp	r3, #0
    6df6:	f47f aedb 	bne.w	6bb0 <tcp_slowtmr+0x1c>
				if (err == ERR_OK) {
    6dfa:	2800      	cmp	r0, #0
    6dfc:	d1f4      	bne.n	6de8 <tcp_slowtmr+0x254>
    6dfe:	e7f0      	b.n	6de2 <tcp_slowtmr+0x24e>
		if ((u32_t)(tcp_ticks - pcb->tmr) > 2 * TCP_MSL / TCP_SLOW_INTERVAL) {
    6e00:	68f3      	ldr	r3, [r6, #12]
    6e02:	6a6a      	ldr	r2, [r5, #36]	; 0x24
    6e04:	1a9b      	subs	r3, r3, r2
    6e06:	2bf0      	cmp	r3, #240	; 0xf0
    6e08:	d802      	bhi.n	6e10 <tcp_slowtmr+0x27c>
			pcb  = pcb->next;
    6e0a:	462c      	mov	r4, r5
    6e0c:	68ed      	ldr	r5, [r5, #12]
    6e0e:	e6d9      	b.n	6bc4 <tcp_slowtmr+0x30>
			tcp_pcb_purge(pcb);
    6e10:	4628      	mov	r0, r5
    6e12:	47b8      	blx	r7
			if (prev != NULL) {
    6e14:	68eb      	ldr	r3, [r5, #12]
    6e16:	b13c      	cbz	r4, 6e28 <tcp_slowtmr+0x294>
				prev->next = pcb->next;
    6e18:	60e3      	str	r3, [r4, #12]
			pcb  = pcb->next;
    6e1a:	f8d5 900c 	ldr.w	r9, [r5, #12]
			memp_free(MEMP_TCP_PCB, pcb2);
    6e1e:	4629      	mov	r1, r5
    6e20:	2001      	movs	r0, #1
    6e22:	47c0      	blx	r8
			pcb  = pcb->next;
    6e24:	464d      	mov	r5, r9
    6e26:	e6cd      	b.n	6bc4 <tcp_slowtmr+0x30>
				tcp_tw_pcbs = pcb->next;
    6e28:	61f3      	str	r3, [r6, #28]
    6e2a:	e7f6      	b.n	6e1a <tcp_slowtmr+0x286>
    6e2c:	2001493c 	.word	0x2001493c
    6e30:	00006b51 	.word	0x00006b51
    6e34:	0000b764 	.word	0x0000b764
    6e38:	00006ae5 	.word	0x00006ae5
    6e3c:	00002925 	.word	0x00002925
    6e40:	000027d9 	.word	0x000027d9
    6e44:	000124f8 	.word	0x000124f8
    6e48:	000028bd 	.word	0x000028bd
    6e4c:	000024a5 	.word	0x000024a5
    6e50:	00004c1d 	.word	0x00004c1d
    6e54:	00002729 	.word	0x00002729

00006e58 <tcp_pcb_remove>:
 * @param pcblist PCB list to purge.
 * @param pcb tcp_pcb to purge. The pcb itself is NOT deallocated!
 */
void tcp_pcb_remove(struct tcp_pcb **pcblist, struct tcp_pcb *pcb)
{
	TCP_RMV(pcblist, pcb);
    6e58:	6803      	ldr	r3, [r0, #0]
    6e5a:	428b      	cmp	r3, r1
{
    6e5c:	b510      	push	{r4, lr}
    6e5e:	460c      	mov	r4, r1
	TCP_RMV(pcblist, pcb);
    6e60:	d117      	bne.n	6e92 <tcp_pcb_remove+0x3a>
    6e62:	68cb      	ldr	r3, [r1, #12]
    6e64:	6003      	str	r3, [r0, #0]
    6e66:	2300      	movs	r3, #0
    6e68:	60e3      	str	r3, [r4, #12]

	tcp_pcb_purge(pcb);
    6e6a:	4620      	mov	r0, r4
    6e6c:	4b12      	ldr	r3, [pc, #72]	; (6eb8 <tcp_pcb_remove+0x60>)
    6e6e:	4798      	blx	r3

	/* if there is an outstanding delayed ACKs, send it */
	if (pcb->state != TIME_WAIT && pcb->state != LISTEN && pcb->flags & TF_ACK_DELAY) {
    6e70:	7e23      	ldrb	r3, [r4, #24]
    6e72:	2b0a      	cmp	r3, #10
    6e74:	d00a      	beq.n	6e8c <tcp_pcb_remove+0x34>
    6e76:	2b01      	cmp	r3, #1
    6e78:	d008      	beq.n	6e8c <tcp_pcb_remove+0x34>
    6e7a:	7fa3      	ldrb	r3, [r4, #30]
    6e7c:	07da      	lsls	r2, r3, #31
    6e7e:	d505      	bpl.n	6e8c <tcp_pcb_remove+0x34>
		pcb->flags |= TF_ACK_NOW;
    6e80:	f043 0302 	orr.w	r3, r3, #2
    6e84:	77a3      	strb	r3, [r4, #30]
		tcp_output(pcb);
    6e86:	4620      	mov	r0, r4
    6e88:	4b0c      	ldr	r3, [pc, #48]	; (6ebc <tcp_pcb_remove+0x64>)
    6e8a:	4798      	blx	r3
#if TCP_QUEUE_OOSEQ
		LWIP_ASSERT("ooseq segments leaking", pcb->ooseq == NULL);
#endif /* TCP_QUEUE_OOSEQ */
	}

	pcb->state = CLOSED;
    6e8c:	2300      	movs	r3, #0
    6e8e:	7623      	strb	r3, [r4, #24]

	LWIP_ASSERT("tcp_pcb_remove: tcp_pcbs_sane()", tcp_pcbs_sane());
}
    6e90:	bd10      	pop	{r4, pc}
	TCP_RMV(pcblist, pcb);
    6e92:	4a0b      	ldr	r2, [pc, #44]	; (6ec0 <tcp_pcb_remove+0x68>)
    6e94:	2100      	movs	r1, #0
    6e96:	6053      	str	r3, [r2, #4]
    6e98:	b91b      	cbnz	r3, 6ea2 <tcp_pcb_remove+0x4a>
    6e9a:	2900      	cmp	r1, #0
    6e9c:	d0e3      	beq.n	6e66 <tcp_pcb_remove+0xe>
    6e9e:	6053      	str	r3, [r2, #4]
    6ea0:	e7e1      	b.n	6e66 <tcp_pcb_remove+0xe>
    6ea2:	68d8      	ldr	r0, [r3, #12]
    6ea4:	42a0      	cmp	r0, r4
    6ea6:	d104      	bne.n	6eb2 <tcp_pcb_remove+0x5a>
    6ea8:	b101      	cbz	r1, 6eac <tcp_pcb_remove+0x54>
    6eaa:	6053      	str	r3, [r2, #4]
    6eac:	68e2      	ldr	r2, [r4, #12]
    6eae:	60da      	str	r2, [r3, #12]
    6eb0:	e7d9      	b.n	6e66 <tcp_pcb_remove+0xe>
    6eb2:	2101      	movs	r1, #1
    6eb4:	4603      	mov	r3, r0
    6eb6:	e7ef      	b.n	6e98 <tcp_pcb_remove+0x40>
    6eb8:	00006b51 	.word	0x00006b51
    6ebc:	000024a5 	.word	0x000024a5
    6ec0:	2001493c 	.word	0x2001493c

00006ec4 <tcp_close_shutdown>:
{
    6ec4:	b537      	push	{r0, r1, r2, r4, r5, lr}
    6ec6:	4604      	mov	r4, r0
	if (rst_on_unacked_data && ((pcb->state == ESTABLISHED) || (pcb->state == CLOSE_WAIT))) {
    6ec8:	7e03      	ldrb	r3, [r0, #24]
    6eca:	2900      	cmp	r1, #0
    6ecc:	d040      	beq.n	6f50 <tcp_close_shutdown+0x8c>
    6ece:	2b04      	cmp	r3, #4
    6ed0:	d001      	beq.n	6ed6 <tcp_close_shutdown+0x12>
    6ed2:	2b07      	cmp	r3, #7
    6ed4:	d13c      	bne.n	6f50 <tcp_close_shutdown+0x8c>
		if ((pcb->refused_data != NULL) || (pcb->rcv_wnd != TCP_WND)) {
    6ed6:	6fa2      	ldr	r2, [r4, #120]	; 0x78
    6ed8:	b922      	cbnz	r2, 6ee4 <tcp_close_shutdown+0x20>
    6eda:	8da1      	ldrh	r1, [r4, #44]	; 0x2c
    6edc:	f241 62d0 	movw	r2, #5840	; 0x16d0
    6ee0:	4291      	cmp	r1, r2
    6ee2:	d035      	beq.n	6f50 <tcp_close_shutdown+0x8c>
			tcp_rst(pcb->snd_nxt, pcb->rcv_nxt, &pcb->local_ip, &pcb->remote_ip, pcb->local_port, pcb->remote_port);
    6ee4:	8ba3      	ldrh	r3, [r4, #28]
    6ee6:	9301      	str	r3, [sp, #4]
    6ee8:	8b63      	ldrh	r3, [r4, #26]
    6eea:	6aa1      	ldr	r1, [r4, #40]	; 0x28
    6eec:	6d20      	ldr	r0, [r4, #80]	; 0x50
    6eee:	9300      	str	r3, [sp, #0]
    6ef0:	4622      	mov	r2, r4
    6ef2:	1d23      	adds	r3, r4, #4
    6ef4:	4d43      	ldr	r5, [pc, #268]	; (7004 <tcp_close_shutdown+0x140>)
    6ef6:	47a8      	blx	r5
			tcp_pcb_purge(pcb);
    6ef8:	4b43      	ldr	r3, [pc, #268]	; (7008 <tcp_close_shutdown+0x144>)
    6efa:	4620      	mov	r0, r4
    6efc:	4798      	blx	r3
			TCP_RMV_ACTIVE(pcb);
    6efe:	4b43      	ldr	r3, [pc, #268]	; (700c <tcp_close_shutdown+0x148>)
    6f00:	695a      	ldr	r2, [r3, #20]
    6f02:	42a2      	cmp	r2, r4
    6f04:	d112      	bne.n	6f2c <tcp_close_shutdown+0x68>
    6f06:	68e2      	ldr	r2, [r4, #12]
    6f08:	615a      	str	r2, [r3, #20]
    6f0a:	2201      	movs	r2, #1
    6f0c:	761a      	strb	r2, [r3, #24]
			if (pcb->state == ESTABLISHED) {
    6f0e:	7e22      	ldrb	r2, [r4, #24]
			TCP_RMV_ACTIVE(pcb);
    6f10:	2500      	movs	r5, #0
			if (pcb->state == ESTABLISHED) {
    6f12:	2a04      	cmp	r2, #4
			TCP_RMV_ACTIVE(pcb);
    6f14:	60e5      	str	r5, [r4, #12]
			if (pcb->state == ESTABLISHED) {
    6f16:	d13b      	bne.n	6f90 <tcp_close_shutdown+0xcc>
				pcb->state = TIME_WAIT;
    6f18:	220a      	movs	r2, #10
    6f1a:	7622      	strb	r2, [r4, #24]
				TCP_REG(&tcp_tw_pcbs, pcb);
    6f1c:	69da      	ldr	r2, [r3, #28]
    6f1e:	60e2      	str	r2, [r4, #12]
    6f20:	61dc      	str	r4, [r3, #28]
    6f22:	4b3b      	ldr	r3, [pc, #236]	; (7010 <tcp_close_shutdown+0x14c>)
    6f24:	4798      	blx	r3
	switch (pcb->state) {
    6f26:	2000      	movs	r0, #0
}
    6f28:	b003      	add	sp, #12
    6f2a:	bd30      	pop	{r4, r5, pc}
			TCP_RMV_ACTIVE(pcb);
    6f2c:	605a      	str	r2, [r3, #4]
    6f2e:	2100      	movs	r1, #0
    6f30:	b91a      	cbnz	r2, 6f3a <tcp_close_shutdown+0x76>
    6f32:	2900      	cmp	r1, #0
    6f34:	d0e9      	beq.n	6f0a <tcp_close_shutdown+0x46>
    6f36:	605a      	str	r2, [r3, #4]
    6f38:	e7e7      	b.n	6f0a <tcp_close_shutdown+0x46>
    6f3a:	68d0      	ldr	r0, [r2, #12]
    6f3c:	42a0      	cmp	r0, r4
    6f3e:	d104      	bne.n	6f4a <tcp_close_shutdown+0x86>
    6f40:	b101      	cbz	r1, 6f44 <tcp_close_shutdown+0x80>
    6f42:	605a      	str	r2, [r3, #4]
    6f44:	68e1      	ldr	r1, [r4, #12]
    6f46:	60d1      	str	r1, [r2, #12]
    6f48:	e7df      	b.n	6f0a <tcp_close_shutdown+0x46>
    6f4a:	2101      	movs	r1, #1
    6f4c:	4602      	mov	r2, r0
    6f4e:	e7ef      	b.n	6f30 <tcp_close_shutdown+0x6c>
	switch (pcb->state) {
    6f50:	2b07      	cmp	r3, #7
    6f52:	d8e8      	bhi.n	6f26 <tcp_close_shutdown+0x62>
    6f54:	a201      	add	r2, pc, #4	; (adr r2, 6f5c <tcp_close_shutdown+0x98>)
    6f56:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
    6f5a:	bf00      	nop
    6f5c:	00006f7d 	.word	0x00006f7d
    6f60:	00006fbf 	.word	0x00006fbf
    6f64:	00006fcd 	.word	0x00006fcd
    6f68:	00006fe1 	.word	0x00006fe1
    6f6c:	00006fe1 	.word	0x00006fe1
    6f70:	00006f27 	.word	0x00006f27
    6f74:	00006f27 	.word	0x00006f27
    6f78:	00006ff7 	.word	0x00006ff7
		if (pcb->local_port != 0) {
    6f7c:	8b63      	ldrh	r3, [r4, #26]
    6f7e:	b13b      	cbz	r3, 6f90 <tcp_close_shutdown+0xcc>
			TCP_RMV(&tcp_bound_pcbs, pcb);
    6f80:	4a22      	ldr	r2, [pc, #136]	; (700c <tcp_close_shutdown+0x148>)
    6f82:	6813      	ldr	r3, [r2, #0]
    6f84:	42a3      	cmp	r3, r4
    6f86:	d108      	bne.n	6f9a <tcp_close_shutdown+0xd6>
    6f88:	68e3      	ldr	r3, [r4, #12]
    6f8a:	6013      	str	r3, [r2, #0]
    6f8c:	2300      	movs	r3, #0
    6f8e:	60e3      	str	r3, [r4, #12]
				memp_free(MEMP_TCP_PCB, pcb);
    6f90:	4621      	mov	r1, r4
    6f92:	2001      	movs	r0, #1
		memp_free(MEMP_TCP_PCB, pcb);
    6f94:	4b1f      	ldr	r3, [pc, #124]	; (7014 <tcp_close_shutdown+0x150>)
    6f96:	4798      	blx	r3
	if (pcb != NULL && err == ERR_OK) {
    6f98:	e7c5      	b.n	6f26 <tcp_close_shutdown+0x62>
			TCP_RMV(&tcp_bound_pcbs, pcb);
    6f9a:	6053      	str	r3, [r2, #4]
    6f9c:	2100      	movs	r1, #0
    6f9e:	b91b      	cbnz	r3, 6fa8 <tcp_close_shutdown+0xe4>
    6fa0:	2900      	cmp	r1, #0
    6fa2:	d0f3      	beq.n	6f8c <tcp_close_shutdown+0xc8>
    6fa4:	6053      	str	r3, [r2, #4]
    6fa6:	e7f1      	b.n	6f8c <tcp_close_shutdown+0xc8>
    6fa8:	68d8      	ldr	r0, [r3, #12]
    6faa:	42a0      	cmp	r0, r4
    6fac:	d104      	bne.n	6fb8 <tcp_close_shutdown+0xf4>
    6fae:	b101      	cbz	r1, 6fb2 <tcp_close_shutdown+0xee>
    6fb0:	6053      	str	r3, [r2, #4]
    6fb2:	68e2      	ldr	r2, [r4, #12]
    6fb4:	60da      	str	r2, [r3, #12]
    6fb6:	e7e9      	b.n	6f8c <tcp_close_shutdown+0xc8>
    6fb8:	2101      	movs	r1, #1
    6fba:	4603      	mov	r3, r0
    6fbc:	e7ef      	b.n	6f9e <tcp_close_shutdown+0xda>
		tcp_pcb_remove(&tcp_listen_pcbs.pcbs, pcb);
    6fbe:	4816      	ldr	r0, [pc, #88]	; (7018 <tcp_close_shutdown+0x154>)
    6fc0:	4b16      	ldr	r3, [pc, #88]	; (701c <tcp_close_shutdown+0x158>)
    6fc2:	4621      	mov	r1, r4
    6fc4:	4798      	blx	r3
		memp_free(MEMP_TCP_PCB_LISTEN, pcb);
    6fc6:	4621      	mov	r1, r4
    6fc8:	2002      	movs	r0, #2
    6fca:	e7e3      	b.n	6f94 <tcp_close_shutdown+0xd0>
		TCP_PCB_REMOVE_ACTIVE(pcb);
    6fcc:	4d0f      	ldr	r5, [pc, #60]	; (700c <tcp_close_shutdown+0x148>)
    6fce:	4b13      	ldr	r3, [pc, #76]	; (701c <tcp_close_shutdown+0x158>)
    6fd0:	4621      	mov	r1, r4
    6fd2:	f105 0014 	add.w	r0, r5, #20
    6fd6:	4798      	blx	r3
    6fd8:	2001      	movs	r0, #1
    6fda:	7628      	strb	r0, [r5, #24]
		memp_free(MEMP_TCP_PCB, pcb);
    6fdc:	4621      	mov	r1, r4
    6fde:	e7d9      	b.n	6f94 <tcp_close_shutdown+0xd0>
		err = tcp_send_fin(pcb);
    6fe0:	4b0f      	ldr	r3, [pc, #60]	; (7020 <tcp_close_shutdown+0x15c>)
    6fe2:	4620      	mov	r0, r4
    6fe4:	4798      	blx	r3
		if (err == ERR_OK) {
    6fe6:	2800      	cmp	r0, #0
    6fe8:	d19e      	bne.n	6f28 <tcp_close_shutdown+0x64>
			pcb->state = FIN_WAIT_1;
    6fea:	2305      	movs	r3, #5
			pcb->state = LAST_ACK;
    6fec:	7623      	strb	r3, [r4, #24]
		tcp_output(pcb);
    6fee:	4620      	mov	r0, r4
    6ff0:	4b0c      	ldr	r3, [pc, #48]	; (7024 <tcp_close_shutdown+0x160>)
    6ff2:	4798      	blx	r3
    6ff4:	e797      	b.n	6f26 <tcp_close_shutdown+0x62>
		err = tcp_send_fin(pcb);
    6ff6:	4b0a      	ldr	r3, [pc, #40]	; (7020 <tcp_close_shutdown+0x15c>)
    6ff8:	4620      	mov	r0, r4
    6ffa:	4798      	blx	r3
		if (err == ERR_OK) {
    6ffc:	2800      	cmp	r0, #0
    6ffe:	d193      	bne.n	6f28 <tcp_close_shutdown+0x64>
			pcb->state = LAST_ACK;
    7000:	2309      	movs	r3, #9
    7002:	e7f3      	b.n	6fec <tcp_close_shutdown+0x128>
    7004:	00002729 	.word	0x00002729
    7008:	00006b51 	.word	0x00006b51
    700c:	2001493c 	.word	0x2001493c
    7010:	000010a5 	.word	0x000010a5
    7014:	00004c1d 	.word	0x00004c1d
    7018:	20014944 	.word	0x20014944
    701c:	00006e59 	.word	0x00006e59
    7020:	000023e1 	.word	0x000023e1
    7024:	000024a5 	.word	0x000024a5

00007028 <tcp_close>:
	if (pcb->state != LISTEN) {
    7028:	7e03      	ldrb	r3, [r0, #24]
    702a:	2b01      	cmp	r3, #1
		pcb->flags |= TF_RXCLOSED;
    702c:	bf1e      	ittt	ne
    702e:	7f83      	ldrbne	r3, [r0, #30]
    7030:	f043 0310 	orrne.w	r3, r3, #16
    7034:	7783      	strbne	r3, [r0, #30]
	return tcp_close_shutdown(pcb, 1);
    7036:	2101      	movs	r1, #1
    7038:	4b00      	ldr	r3, [pc, #0]	; (703c <tcp_close+0x14>)
    703a:	4718      	bx	r3
    703c:	00006ec5 	.word	0x00006ec5

00007040 <tcp_recv_null>:
{
    7040:	b510      	push	{r4, lr}
    7042:	4608      	mov	r0, r1
	if (p != NULL) {
    7044:	4614      	mov	r4, r2
    7046:	b13a      	cbz	r2, 7058 <tcp_recv_null+0x18>
		tcp_recved(pcb, p->tot_len);
    7048:	4b06      	ldr	r3, [pc, #24]	; (7064 <tcp_recv_null+0x24>)
    704a:	8911      	ldrh	r1, [r2, #8]
    704c:	4798      	blx	r3
		pbuf_free(p);
    704e:	4b06      	ldr	r3, [pc, #24]	; (7068 <tcp_recv_null+0x28>)
    7050:	4620      	mov	r0, r4
    7052:	4798      	blx	r3
}
    7054:	2000      	movs	r0, #0
    7056:	bd10      	pop	{r4, pc}
	} else if (err == ERR_OK) {
    7058:	2b00      	cmp	r3, #0
    705a:	d1fb      	bne.n	7054 <tcp_recv_null+0x14>
}
    705c:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		return tcp_close(pcb);
    7060:	4b02      	ldr	r3, [pc, #8]	; (706c <tcp_recv_null+0x2c>)
    7062:	4718      	bx	r3
    7064:	00006a81 	.word	0x00006a81
    7068:	000030e5 	.word	0x000030e5
    706c:	00007029 	.word	0x00007029

00007070 <tcp_process_refused_data>:
{
    7070:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	u8_t  refused_flags = pcb->refused_data->flags;
    7072:	6f86      	ldr	r6, [r0, #120]	; 0x78
	TCP_EVENT_RECV(pcb, refused_data, ERR_OK, err);
    7074:	f8d0 5080 	ldr.w	r5, [r0, #128]	; 0x80
	u8_t  refused_flags = pcb->refused_data->flags;
    7078:	7b77      	ldrb	r7, [r6, #13]
	pcb->refused_data         = NULL;
    707a:	2300      	movs	r3, #0
{
    707c:	4604      	mov	r4, r0
	pcb->refused_data         = NULL;
    707e:	6783      	str	r3, [r0, #120]	; 0x78
	TCP_EVENT_RECV(pcb, refused_data, ERR_OK, err);
    7080:	b1e5      	cbz	r5, 70bc <tcp_process_refused_data+0x4c>
    7082:	4601      	mov	r1, r0
    7084:	4632      	mov	r2, r6
    7086:	6900      	ldr	r0, [r0, #16]
    7088:	47a8      	blx	r5
    708a:	4605      	mov	r5, r0
	if (err == ERR_OK) {
    708c:	b9e8      	cbnz	r0, 70ca <tcp_process_refused_data+0x5a>
		if (refused_flags & PBUF_FLAG_TCP_FIN) {
    708e:	06bb      	lsls	r3, r7, #26
    7090:	d512      	bpl.n	70b8 <tcp_process_refused_data+0x48>
			if (pcb->rcv_wnd != TCP_WND) {
    7092:	8da3      	ldrh	r3, [r4, #44]	; 0x2c
			TCP_EVENT_CLOSED(pcb, err);
    7094:	f8d4 6080 	ldr.w	r6, [r4, #128]	; 0x80
			if (pcb->rcv_wnd != TCP_WND) {
    7098:	f241 62d0 	movw	r2, #5840	; 0x16d0
    709c:	4293      	cmp	r3, r2
				pcb->rcv_wnd++;
    709e:	bf1c      	itt	ne
    70a0:	3301      	addne	r3, #1
    70a2:	85a3      	strhne	r3, [r4, #44]	; 0x2c
			TCP_EVENT_CLOSED(pcb, err);
    70a4:	b146      	cbz	r6, 70b8 <tcp_process_refused_data+0x48>
    70a6:	2300      	movs	r3, #0
    70a8:	6920      	ldr	r0, [r4, #16]
    70aa:	461a      	mov	r2, r3
    70ac:	4621      	mov	r1, r4
    70ae:	47b0      	blx	r6
			if (err == ERR_ABRT) {
    70b0:	300a      	adds	r0, #10
    70b2:	d101      	bne.n	70b8 <tcp_process_refused_data+0x48>
				return ERR_ABRT;
    70b4:	f06f 0509 	mvn.w	r5, #9
}
    70b8:	4628      	mov	r0, r5
    70ba:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	TCP_EVENT_RECV(pcb, refused_data, ERR_OK, err);
    70bc:	462b      	mov	r3, r5
    70be:	4601      	mov	r1, r0
    70c0:	4632      	mov	r2, r6
    70c2:	4628      	mov	r0, r5
    70c4:	4d03      	ldr	r5, [pc, #12]	; (70d4 <tcp_process_refused_data+0x64>)
    70c6:	47a8      	blx	r5
    70c8:	e7df      	b.n	708a <tcp_process_refused_data+0x1a>
	} else if (err == ERR_ABRT) {
    70ca:	350a      	adds	r5, #10
    70cc:	d0f2      	beq.n	70b4 <tcp_process_refused_data+0x44>
		pcb->refused_data = refused_data;
    70ce:	67a6      	str	r6, [r4, #120]	; 0x78
	return ERR_OK;
    70d0:	2500      	movs	r5, #0
    70d2:	e7f1      	b.n	70b8 <tcp_process_refused_data+0x48>
    70d4:	00007041 	.word	0x00007041

000070d8 <tcp_fasttmr>:
{
    70d8:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	++tcp_timer_ctr;
    70dc:	4d15      	ldr	r5, [pc, #84]	; (7134 <tcp_fasttmr+0x5c>)
				tcp_output(pcb);
    70de:	4e16      	ldr	r6, [pc, #88]	; (7138 <tcp_fasttmr+0x60>)
	++tcp_timer_ctr;
    70e0:	7c2b      	ldrb	r3, [r5, #16]
				tcp_process_refused_data(pcb);
    70e2:	f8df 8058 	ldr.w	r8, [pc, #88]	; 713c <tcp_fasttmr+0x64>
	++tcp_timer_ctr;
    70e6:	3301      	adds	r3, #1
    70e8:	742b      	strb	r3, [r5, #16]
	pcb = tcp_active_pcbs;
    70ea:	696c      	ldr	r4, [r5, #20]
				tcp_active_pcbs_changed = 0;
    70ec:	2700      	movs	r7, #0
		if (pcb->last_timer != tcp_timer_ctr) {
    70ee:	7c2b      	ldrb	r3, [r5, #16]
	while (pcb != NULL) {
    70f0:	b90c      	cbnz	r4, 70f6 <tcp_fasttmr+0x1e>
}
    70f2:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
		if (pcb->last_timer != tcp_timer_ctr) {
    70f6:	f894 2021 	ldrb.w	r2, [r4, #33]	; 0x21
    70fa:	429a      	cmp	r2, r3
    70fc:	d0f8      	beq.n	70f0 <tcp_fasttmr+0x18>
			pcb->last_timer = tcp_timer_ctr;
    70fe:	f884 3021 	strb.w	r3, [r4, #33]	; 0x21
			if (pcb->flags & TF_ACK_DELAY) {
    7102:	7fa3      	ldrb	r3, [r4, #30]
    7104:	07da      	lsls	r2, r3, #31
    7106:	d508      	bpl.n	711a <tcp_fasttmr+0x42>
				tcp_ack_now(pcb);
    7108:	f043 0302 	orr.w	r3, r3, #2
    710c:	77a3      	strb	r3, [r4, #30]
				tcp_output(pcb);
    710e:	4620      	mov	r0, r4
    7110:	47b0      	blx	r6
				pcb->flags &= ~(TF_ACK_DELAY | TF_ACK_NOW);
    7112:	7fa3      	ldrb	r3, [r4, #30]
    7114:	f023 0303 	bic.w	r3, r3, #3
    7118:	77a3      	strb	r3, [r4, #30]
			if (pcb->refused_data != NULL) {
    711a:	6fa3      	ldr	r3, [r4, #120]	; 0x78
			next = pcb->next;
    711c:	f8d4 900c 	ldr.w	r9, [r4, #12]
			if (pcb->refused_data != NULL) {
    7120:	b12b      	cbz	r3, 712e <tcp_fasttmr+0x56>
				tcp_process_refused_data(pcb);
    7122:	4620      	mov	r0, r4
				tcp_active_pcbs_changed = 0;
    7124:	762f      	strb	r7, [r5, #24]
				tcp_process_refused_data(pcb);
    7126:	47c0      	blx	r8
				if (tcp_active_pcbs_changed) {
    7128:	7e2b      	ldrb	r3, [r5, #24]
    712a:	2b00      	cmp	r3, #0
    712c:	d1dd      	bne.n	70ea <tcp_fasttmr+0x12>
{
    712e:	464c      	mov	r4, r9
    7130:	e7dd      	b.n	70ee <tcp_fasttmr+0x16>
    7132:	bf00      	nop
    7134:	2001493c 	.word	0x2001493c
    7138:	000024a5 	.word	0x000024a5
    713c:	00007071 	.word	0x00007071

00007140 <tcp_tmr>:
	tcp_fasttmr();
    7140:	4b08      	ldr	r3, [pc, #32]	; (7164 <tcp_tmr+0x24>)
{
    7142:	b510      	push	{r4, lr}
	tcp_fasttmr();
    7144:	4798      	blx	r3
	if (++tcp_timer & 1) {
    7146:	4a08      	ldr	r2, [pc, #32]	; (7168 <tcp_tmr+0x28>)
    7148:	f892 3020 	ldrb.w	r3, [r2, #32]
    714c:	3301      	adds	r3, #1
    714e:	b2db      	uxtb	r3, r3
    7150:	f882 3020 	strb.w	r3, [r2, #32]
    7154:	07db      	lsls	r3, r3, #31
    7156:	d503      	bpl.n	7160 <tcp_tmr+0x20>
}
    7158:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		tcp_slowtmr();
    715c:	4b03      	ldr	r3, [pc, #12]	; (716c <tcp_tmr+0x2c>)
    715e:	4718      	bx	r3
}
    7160:	bd10      	pop	{r4, pc}
    7162:	bf00      	nop
    7164:	000070d9 	.word	0x000070d9
    7168:	2001493c 	.word	0x2001493c
    716c:	00006b95 	.word	0x00006b95

00007170 <tcp_shutdown>:
{
    7170:	b570      	push	{r4, r5, r6, lr}
	if (pcb->state == LISTEN) {
    7172:	7e03      	ldrb	r3, [r0, #24]
    7174:	2b01      	cmp	r3, #1
{
    7176:	4605      	mov	r5, r0
    7178:	4614      	mov	r4, r2
	if (pcb->state == LISTEN) {
    717a:	d018      	beq.n	71ae <tcp_shutdown+0x3e>
	if (shut_rx) {
    717c:	b189      	cbz	r1, 71a2 <tcp_shutdown+0x32>
		pcb->flags |= TF_RXCLOSED;
    717e:	7f83      	ldrb	r3, [r0, #30]
    7180:	f043 0310 	orr.w	r3, r3, #16
    7184:	7783      	strb	r3, [r0, #30]
		if (shut_tx) {
    7186:	b122      	cbz	r2, 7192 <tcp_shutdown+0x22>
			return tcp_close_shutdown(pcb, 1);
    7188:	2101      	movs	r1, #1
}
    718a:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
			return tcp_close_shutdown(pcb, shut_rx);
    718e:	4b0c      	ldr	r3, [pc, #48]	; (71c0 <tcp_shutdown+0x50>)
    7190:	4718      	bx	r3
		if (pcb->refused_data != NULL) {
    7192:	6f80      	ldr	r0, [r0, #120]	; 0x78
    7194:	b908      	cbnz	r0, 719a <tcp_shutdown+0x2a>
	return ERR_OK;
    7196:	2000      	movs	r0, #0
}
    7198:	bd70      	pop	{r4, r5, r6, pc}
			pbuf_free(pcb->refused_data);
    719a:	4b0a      	ldr	r3, [pc, #40]	; (71c4 <tcp_shutdown+0x54>)
    719c:	4798      	blx	r3
			pcb->refused_data = NULL;
    719e:	67ac      	str	r4, [r5, #120]	; 0x78
    71a0:	e7f9      	b.n	7196 <tcp_shutdown+0x26>
	if (shut_tx) {
    71a2:	2a00      	cmp	r2, #0
    71a4:	d0f7      	beq.n	7196 <tcp_shutdown+0x26>
		switch (pcb->state) {
    71a6:	2b04      	cmp	r3, #4
    71a8:	d804      	bhi.n	71b4 <tcp_shutdown+0x44>
    71aa:	2b02      	cmp	r3, #2
    71ac:	d804      	bhi.n	71b8 <tcp_shutdown+0x48>
    71ae:	f06f 000c 	mvn.w	r0, #12
    71b2:	e7f1      	b.n	7198 <tcp_shutdown+0x28>
    71b4:	2b07      	cmp	r3, #7
    71b6:	d1fa      	bne.n	71ae <tcp_shutdown+0x3e>
			return tcp_close_shutdown(pcb, shut_rx);
    71b8:	2100      	movs	r1, #0
    71ba:	4628      	mov	r0, r5
    71bc:	e7e5      	b.n	718a <tcp_shutdown+0x1a>
    71be:	bf00      	nop
    71c0:	00006ec5 	.word	0x00006ec5
    71c4:	000030e5 	.word	0x000030e5

000071c8 <tcp_abandon>:
{
    71c8:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
	if (pcb->state == TIME_WAIT) {
    71cc:	7e03      	ldrb	r3, [r0, #24]
    71ce:	4f23      	ldr	r7, [pc, #140]	; (725c <tcp_abandon+0x94>)
    71d0:	2b0a      	cmp	r3, #10
{
    71d2:	4604      	mov	r4, r0
    71d4:	4b22      	ldr	r3, [pc, #136]	; (7260 <tcp_abandon+0x98>)
    71d6:	460d      	mov	r5, r1
	if (pcb->state == TIME_WAIT) {
    71d8:	d109      	bne.n	71ee <tcp_abandon+0x26>
		tcp_pcb_remove(&tcp_tw_pcbs, pcb);
    71da:	4601      	mov	r1, r0
    71dc:	4821      	ldr	r0, [pc, #132]	; (7264 <tcp_abandon+0x9c>)
    71de:	4798      	blx	r3
		memp_free(MEMP_TCP_PCB, pcb);
    71e0:	4621      	mov	r1, r4
    71e2:	2001      	movs	r0, #1
    71e4:	463b      	mov	r3, r7
}
    71e6:	b003      	add	sp, #12
    71e8:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
		memp_free(MEMP_TCP_PCB, pcb);
    71ec:	4718      	bx	r3
		TCP_PCB_REMOVE_ACTIVE(pcb);
    71ee:	f8df b080 	ldr.w	fp, [pc, #128]	; 7270 <tcp_abandon+0xa8>
		seqno = pcb->snd_nxt;
    71f2:	f8d0 9050 	ldr.w	r9, [r0, #80]	; 0x50
		ackno = pcb->rcv_nxt;
    71f6:	f8d0 a028 	ldr.w	sl, [r0, #40]	; 0x28
		errf = pcb->errf;
    71fa:	f8d0 608c 	ldr.w	r6, [r0, #140]	; 0x8c
		errf_arg = pcb->callback_arg;
    71fe:	f8d0 8010 	ldr.w	r8, [r0, #16]
		TCP_PCB_REMOVE_ACTIVE(pcb);
    7202:	4601      	mov	r1, r0
    7204:	f10b 0014 	add.w	r0, fp, #20
    7208:	4798      	blx	r3
		if (pcb->unacked != NULL) {
    720a:	6f20      	ldr	r0, [r4, #112]	; 0x70
		TCP_PCB_REMOVE_ACTIVE(pcb);
    720c:	2301      	movs	r3, #1
    720e:	f88b 3018 	strb.w	r3, [fp, #24]
		if (pcb->unacked != NULL) {
    7212:	b108      	cbz	r0, 7218 <tcp_abandon+0x50>
			tcp_segs_free(pcb->unacked);
    7214:	4b14      	ldr	r3, [pc, #80]	; (7268 <tcp_abandon+0xa0>)
    7216:	4798      	blx	r3
		if (pcb->unsent != NULL) {
    7218:	6ee0      	ldr	r0, [r4, #108]	; 0x6c
    721a:	b108      	cbz	r0, 7220 <tcp_abandon+0x58>
			tcp_segs_free(pcb->unsent);
    721c:	4b12      	ldr	r3, [pc, #72]	; (7268 <tcp_abandon+0xa0>)
    721e:	4798      	blx	r3
		if (pcb->ooseq != NULL) {
    7220:	6f60      	ldr	r0, [r4, #116]	; 0x74
    7222:	b108      	cbz	r0, 7228 <tcp_abandon+0x60>
			tcp_segs_free(pcb->ooseq);
    7224:	4b10      	ldr	r3, [pc, #64]	; (7268 <tcp_abandon+0xa0>)
    7226:	4798      	blx	r3
		if (reset) {
    7228:	b14d      	cbz	r5, 723e <tcp_abandon+0x76>
			tcp_rst(seqno, ackno, &pcb->local_ip, &pcb->remote_ip, pcb->local_port, pcb->remote_port);
    722a:	8ba3      	ldrh	r3, [r4, #28]
    722c:	9301      	str	r3, [sp, #4]
    722e:	8b63      	ldrh	r3, [r4, #26]
    7230:	9300      	str	r3, [sp, #0]
    7232:	4d0e      	ldr	r5, [pc, #56]	; (726c <tcp_abandon+0xa4>)
    7234:	1d23      	adds	r3, r4, #4
    7236:	4622      	mov	r2, r4
    7238:	4651      	mov	r1, sl
    723a:	4648      	mov	r0, r9
    723c:	47a8      	blx	r5
		memp_free(MEMP_TCP_PCB, pcb);
    723e:	4621      	mov	r1, r4
    7240:	2001      	movs	r0, #1
    7242:	47b8      	blx	r7
		TCP_EVENT_ERR(errf, errf_arg, ERR_ABRT);
    7244:	b13e      	cbz	r6, 7256 <tcp_abandon+0x8e>
    7246:	f06f 0109 	mvn.w	r1, #9
    724a:	4640      	mov	r0, r8
    724c:	4633      	mov	r3, r6
}
    724e:	b003      	add	sp, #12
    7250:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
		TCP_EVENT_ERR(errf, errf_arg, ERR_ABRT);
    7254:	4718      	bx	r3
}
    7256:	b003      	add	sp, #12
    7258:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    725c:	00004c1d 	.word	0x00004c1d
    7260:	00006e59 	.word	0x00006e59
    7264:	20014958 	.word	0x20014958
    7268:	00006ae5 	.word	0x00006ae5
    726c:	00002729 	.word	0x00002729
    7270:	2001493c 	.word	0x2001493c

00007274 <tcp_abort>:
	tcp_abandon(pcb, 1);
    7274:	4b01      	ldr	r3, [pc, #4]	; (727c <tcp_abort+0x8>)
    7276:	2101      	movs	r1, #1
    7278:	4718      	bx	r3
    727a:	bf00      	nop
    727c:	000071c9 	.word	0x000071c9

00007280 <tcp_next_iss>:
 */
u32_t tcp_next_iss(void)
{
	static u32_t iss = 6510;

	iss += tcp_ticks; /* XXX */
    7280:	4b03      	ldr	r3, [pc, #12]	; (7290 <tcp_next_iss+0x10>)
    7282:	4a04      	ldr	r2, [pc, #16]	; (7294 <tcp_next_iss+0x14>)
    7284:	6858      	ldr	r0, [r3, #4]
    7286:	68d2      	ldr	r2, [r2, #12]
    7288:	4410      	add	r0, r2
    728a:	6058      	str	r0, [r3, #4]
	return iss;
}
    728c:	4770      	bx	lr
    728e:	bf00      	nop
    7290:	2000000c 	.word	0x2000000c
    7294:	2001493c 	.word	0x2001493c

00007298 <tcp_alloc>:
{
    7298:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	pcb = (struct tcp_pcb *)memp_malloc(MEMP_TCP_PCB);
    729a:	4e34      	ldr	r6, [pc, #208]	; (736c <tcp_alloc+0xd4>)
    729c:	4d34      	ldr	r5, [pc, #208]	; (7370 <tcp_alloc+0xd8>)
{
    729e:	4607      	mov	r7, r0
	pcb = (struct tcp_pcb *)memp_malloc(MEMP_TCP_PCB);
    72a0:	2001      	movs	r0, #1
    72a2:	47b0      	blx	r6
	if (pcb == NULL) {
    72a4:	4604      	mov	r4, r0
    72a6:	b9d8      	cbnz	r0, 72e0 <tcp_alloc+0x48>
	for (pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
    72a8:	69eb      	ldr	r3, [r5, #28]
		if ((u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {
    72aa:	68e8      	ldr	r0, [r5, #12]
	inactivity = 0;
    72ac:	4621      	mov	r1, r4
	for (pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
    72ae:	2b00      	cmp	r3, #0
    72b0:	d145      	bne.n	733e <tcp_alloc+0xa6>
	if (inactive != NULL) {
    72b2:	b114      	cbz	r4, 72ba <tcp_alloc+0x22>
		tcp_abort(inactive);
    72b4:	4b2f      	ldr	r3, [pc, #188]	; (7374 <tcp_alloc+0xdc>)
    72b6:	4620      	mov	r0, r4
    72b8:	4798      	blx	r3
		pcb = (struct tcp_pcb *)memp_malloc(MEMP_TCP_PCB);
    72ba:	2001      	movs	r0, #1
    72bc:	47b0      	blx	r6
		if (pcb == NULL) {
    72be:	4604      	mov	r4, r0
    72c0:	b970      	cbnz	r0, 72e0 <tcp_alloc+0x48>
	for (pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
    72c2:	696b      	ldr	r3, [r5, #20]
		if (pcb->prio <= prio && pcb->prio <= mprio && (u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {
    72c4:	f8d5 e00c 	ldr.w	lr, [r5, #12]
	mprio = TCP_PRIO_MAX;
    72c8:	207f      	movs	r0, #127	; 0x7f
	inactivity = 0;
    72ca:	46a4      	mov	ip, r4
	for (pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
    72cc:	2b00      	cmp	r3, #0
    72ce:	d13e      	bne.n	734e <tcp_alloc+0xb6>
	if (inactive != NULL) {
    72d0:	b114      	cbz	r4, 72d8 <tcp_alloc+0x40>
		tcp_abort(inactive);
    72d2:	4b28      	ldr	r3, [pc, #160]	; (7374 <tcp_alloc+0xdc>)
    72d4:	4620      	mov	r0, r4
    72d6:	4798      	blx	r3
			pcb = (struct tcp_pcb *)memp_malloc(MEMP_TCP_PCB);
    72d8:	2001      	movs	r0, #1
    72da:	47b0      	blx	r6
	if (pcb != NULL) {
    72dc:	4604      	mov	r4, r0
    72de:	b360      	cbz	r0, 733a <tcp_alloc+0xa2>
		memset(pcb, 0, sizeof(struct tcp_pcb));
    72e0:	2298      	movs	r2, #152	; 0x98
    72e2:	4b25      	ldr	r3, [pc, #148]	; (7378 <tcp_alloc+0xe0>)
    72e4:	2100      	movs	r1, #0
    72e6:	4620      	mov	r0, r4
    72e8:	4798      	blx	r3
		pcb->snd_buf      = TCP_SND_BUF;
    72ea:	f640 3368 	movw	r3, #2920	; 0xb68
    72ee:	f8a4 3066 	strh.w	r3, [r4, #102]	; 0x66
		pcb->rcv_wnd      = TCP_WND;
    72f2:	4b22      	ldr	r3, [pc, #136]	; (737c <tcp_alloc+0xe4>)
    72f4:	62e3      	str	r3, [r4, #44]	; 0x2c
		pcb->ttl          = TCP_TTL;
    72f6:	23ff      	movs	r3, #255	; 0xff
    72f8:	72a3      	strb	r3, [r4, #10]
		pcb->rto        = 3000 / TCP_SLOW_INTERVAL;
    72fa:	2306      	movs	r3, #6
    72fc:	f8a4 3044 	strh.w	r3, [r4, #68]	; 0x44
		pcb->sv         = 3000 / TCP_SLOW_INTERVAL;
    7300:	f8a4 3042 	strh.w	r3, [r4, #66]	; 0x42
		pcb->rtime      = -1;
    7304:	4b1e      	ldr	r3, [pc, #120]	; (7380 <tcp_alloc+0xe8>)
    7306:	6363      	str	r3, [r4, #52]	; 0x34
		pcb->cwnd       = 1;
    7308:	2301      	movs	r3, #1
    730a:	f8a4 304c 	strh.w	r3, [r4, #76]	; 0x4c
		pcb->prio         = prio;
    730e:	7667      	strb	r7, [r4, #25]
		iss             = tcp_next_iss();
    7310:	4b1c      	ldr	r3, [pc, #112]	; (7384 <tcp_alloc+0xec>)
    7312:	4798      	blx	r3
		pcb->tmr        = tcp_ticks;
    7314:	68eb      	ldr	r3, [r5, #12]
		pcb->recv = tcp_recv_null;
    7316:	4a1c      	ldr	r2, [pc, #112]	; (7388 <tcp_alloc+0xf0>)
		pcb->tmr        = tcp_ticks;
    7318:	6263      	str	r3, [r4, #36]	; 0x24
		pcb->last_timer = tcp_timer_ctr;
    731a:	7c2b      	ldrb	r3, [r5, #16]
    731c:	f884 3021 	strb.w	r3, [r4, #33]	; 0x21
		pcb->recv = tcp_recv_null;
    7320:	f8c4 2080 	str.w	r2, [r4, #128]	; 0x80
		pcb->polltmr = 0;
    7324:	2300      	movs	r3, #0
		pcb->keep_idle = TCP_KEEPIDLE_DEFAULT;
    7326:	4a19      	ldr	r2, [pc, #100]	; (738c <tcp_alloc+0xf4>)
		pcb->snd_wl2    = iss;
    7328:	65a0      	str	r0, [r4, #88]	; 0x58
		pcb->snd_nxt    = iss;
    732a:	6520      	str	r0, [r4, #80]	; 0x50
		pcb->lastack    = iss;
    732c:	64a0      	str	r0, [r4, #72]	; 0x48
		pcb->snd_lbb    = iss;
    732e:	65e0      	str	r0, [r4, #92]	; 0x5c
		pcb->polltmr = 0;
    7330:	77e3      	strb	r3, [r4, #31]
		pcb->keep_idle = TCP_KEEPIDLE_DEFAULT;
    7332:	f8c4 2090 	str.w	r2, [r4, #144]	; 0x90
		pcb->keep_cnt_sent = 0;
    7336:	f884 3096 	strb.w	r3, [r4, #150]	; 0x96
}
    733a:	4620      	mov	r0, r4
    733c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		if ((u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {
    733e:	6a5a      	ldr	r2, [r3, #36]	; 0x24
    7340:	1a82      	subs	r2, r0, r2
    7342:	428a      	cmp	r2, r1
    7344:	bf24      	itt	cs
    7346:	461c      	movcs	r4, r3
    7348:	4611      	movcs	r1, r2
	for (pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
    734a:	68db      	ldr	r3, [r3, #12]
    734c:	e7af      	b.n	72ae <tcp_alloc+0x16>
		if (pcb->prio <= prio && pcb->prio <= mprio && (u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {
    734e:	7e59      	ldrb	r1, [r3, #25]
    7350:	428f      	cmp	r7, r1
    7352:	d309      	bcc.n	7368 <tcp_alloc+0xd0>
    7354:	4281      	cmp	r1, r0
    7356:	d807      	bhi.n	7368 <tcp_alloc+0xd0>
    7358:	6a5a      	ldr	r2, [r3, #36]	; 0x24
    735a:	ebae 0202 	sub.w	r2, lr, r2
    735e:	4562      	cmp	r2, ip
    7360:	bf22      	ittt	cs
    7362:	4608      	movcs	r0, r1
    7364:	4694      	movcs	ip, r2
    7366:	461c      	movcs	r4, r3
	for (pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
    7368:	68db      	ldr	r3, [r3, #12]
    736a:	e7af      	b.n	72cc <tcp_alloc+0x34>
    736c:	00004c01 	.word	0x00004c01
    7370:	2001493c 	.word	0x2001493c
    7374:	00007275 	.word	0x00007275
    7378:	0000a365 	.word	0x0000a365
    737c:	16d016d0 	.word	0x16d016d0
    7380:	0218ffff 	.word	0x0218ffff
    7384:	00007281 	.word	0x00007281
    7388:	00007041 	.word	0x00007041
    738c:	006ddd00 	.word	0x006ddd00

00007390 <tcp_new>:
	return tcp_alloc(TCP_PRIO_NORMAL);
    7390:	4b01      	ldr	r3, [pc, #4]	; (7398 <tcp_new+0x8>)
    7392:	2040      	movs	r0, #64	; 0x40
    7394:	4718      	bx	r3
    7396:	bf00      	nop
    7398:	00007299 	.word	0x00007299

0000739c <tcp_eff_send_mss>:
 * Calcluates the effective send mss that can be used for a specific IP address
 * by using ip_route to determin the netif used to send to the address and
 * calculating the minimum of TCP_MSS and that netif's mtu (if set).
 */
u16_t tcp_eff_send_mss(u16_t sendmss, ip_addr_t *addr)
{
    739c:	b510      	push	{r4, lr}
	u16_t         mss_s;
	struct netif *outif;

	outif = ip_route(addr);
    739e:	4b07      	ldr	r3, [pc, #28]	; (73bc <tcp_eff_send_mss+0x20>)
{
    73a0:	4604      	mov	r4, r0
	outif = ip_route(addr);
    73a2:	4608      	mov	r0, r1
    73a4:	4798      	blx	r3
	if ((outif != NULL) && (outif->mtu != 0)) {
    73a6:	b130      	cbz	r0, 73b6 <tcp_eff_send_mss+0x1a>
    73a8:	8d03      	ldrh	r3, [r0, #40]	; 0x28
    73aa:	b123      	cbz	r3, 73b6 <tcp_eff_send_mss+0x1a>
		mss_s = outif->mtu - IP_HLEN - TCP_HLEN;
    73ac:	3b28      	subs	r3, #40	; 0x28
		/* RFC 1122, chap 4.2.2.6:
		 * Eff.snd.MSS = min(SendMSS+20, MMS_S) - TCPhdrsize - IPoptionsize
		 * We correct for TCP options in tcp_write(), and don't support IP options.
		 */
		sendmss = LWIP_MIN(sendmss, mss_s);
    73ae:	b29b      	uxth	r3, r3
    73b0:	429c      	cmp	r4, r3
    73b2:	bf28      	it	cs
    73b4:	461c      	movcs	r4, r3
	}
	return sendmss;
}
    73b6:	4620      	mov	r0, r4
    73b8:	bd10      	pop	{r4, pc}
    73ba:	bf00      	nop
    73bc:	00006359 	.word	0x00006359

000073c0 <mac_low_level_init>:

/**
 * \brief Initialize the MAC hardware
 */
void mac_low_level_init(struct netif *netif)
{
    73c0:	b51f      	push	{r0, r1, r2, r3, r4, lr}
    73c2:	4603      	mov	r3, r0
	struct mac_async_filter      filter;

	mac = (struct mac_async_descriptor *)(netif->state);

	/* set MAC hardware address */
	memcpy(filter.mac, netif->hwaddr, NETIF_MAX_HWADDR_LEN);
    73c4:	f8d0 002b 	ldr.w	r0, [r0, #43]	; 0x2b
    73c8:	f8b3 202f 	ldrh.w	r2, [r3, #47]	; 0x2f
    73cc:	9001      	str	r0, [sp, #4]
    73ce:	f8ad 2008 	strh.w	r2, [sp, #8]
	filter.tid_enable = false;
    73d2:	2100      	movs	r1, #0
	mac_async_set_filter(mac, 0, &filter);
    73d4:	6a18      	ldr	r0, [r3, #32]
    73d6:	4b04      	ldr	r3, [pc, #16]	; (73e8 <mac_low_level_init+0x28>)
	filter.tid_enable = false;
    73d8:	f88d 100c 	strb.w	r1, [sp, #12]
	mac_async_set_filter(mac, 0, &filter);
    73dc:	aa01      	add	r2, sp, #4
    73de:	4798      	blx	r3
}
    73e0:	b005      	add	sp, #20
    73e2:	f85d fb04 	ldr.w	pc, [sp], #4
    73e6:	bf00      	nop
    73e8:	00004d81 	.word	0x00004d81

000073ec <mac_low_level_output>:

/**
 * \berif Transmission packet though the MAC hardware.
 */
err_t mac_low_level_output(struct netif *netif, struct pbuf *p)
{
    73ec:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    73f0:	460c      	mov	r4, r1
	struct mac_async_descriptor *mac;
	struct pbuf *                q;
	void *                       tbuf;
	uint8_t *                    pos;

	mac = (struct mac_async_descriptor *)(netif->state);
    73f2:	6a07      	ldr	r7, [r0, #32]

#if ETH_PAD_SIZE
	pbuf_header(p, -ETH_PAD_SIZE); /* drop the padding word */
    73f4:	4e1c      	ldr	r6, [pc, #112]	; (7468 <mac_low_level_output+0x7c>)
    73f6:	f06f 0101 	mvn.w	r1, #1
    73fa:	4620      	mov	r0, r4
    73fc:	47b0      	blx	r6
#endif

	if (p->tot_len == p->len) {
    73fe:	8920      	ldrh	r0, [r4, #8]
    7400:	8962      	ldrh	r2, [r4, #10]
    7402:	4282      	cmp	r2, r0
    7404:	d109      	bne.n	741a <mac_low_level_output+0x2e>
		mac_async_write(mac, p->payload, p->tot_len);
    7406:	6861      	ldr	r1, [r4, #4]
    7408:	4b18      	ldr	r3, [pc, #96]	; (746c <mac_low_level_output+0x80>)
    740a:	4638      	mov	r0, r7
    740c:	4798      	blx	r3
		mac_async_write(mac, tbuf, p->tot_len);
		mem_free(tbuf);
	}

#if ETH_PAD_SIZE
	pbuf_header(p, ETH_PAD_SIZE); /* reclaim the padding word */
    740e:	2102      	movs	r1, #2
    7410:	4620      	mov	r0, r4
    7412:	47b0      	blx	r6
#endif

	LINK_STATS_INC(link.xmit);

	return ERR_OK;
    7414:	2000      	movs	r0, #0
}
    7416:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
		tbuf = mem_malloc(LWIP_MEM_ALIGN_SIZE(p->tot_len));
    741a:	3003      	adds	r0, #3
    741c:	f020 0003 	bic.w	r0, r0, #3
    7420:	4b13      	ldr	r3, [pc, #76]	; (7470 <mac_low_level_output+0x84>)
    7422:	b280      	uxth	r0, r0
    7424:	4798      	blx	r3
		if (tbuf == NULL) {
    7426:	4605      	mov	r5, r0
    7428:	b1d8      	cbz	r0, 7462 <mac_low_level_output+0x76>
			memcpy(pos, q->payload, q->len);
    742a:	f8df 904c 	ldr.w	r9, [pc, #76]	; 7478 <mac_low_level_output+0x8c>
    742e:	4603      	mov	r3, r0
    7430:	46a0      	mov	r8, r4
    7432:	f8b8 200a 	ldrh.w	r2, [r8, #10]
    7436:	f8d8 1004 	ldr.w	r1, [r8, #4]
    743a:	4618      	mov	r0, r3
    743c:	47c8      	blx	r9
			pos += q->len;
    743e:	f8b8 200a 	ldrh.w	r2, [r8, #10]
		for (q = p; q != NULL; q = q->next) {
    7442:	f8d8 8000 	ldr.w	r8, [r8]
			memcpy(pos, q->payload, q->len);
    7446:	4603      	mov	r3, r0
			pos += q->len;
    7448:	4413      	add	r3, r2
		for (q = p; q != NULL; q = q->next) {
    744a:	f1b8 0f00 	cmp.w	r8, #0
    744e:	d1f0      	bne.n	7432 <mac_low_level_output+0x46>
		mac_async_write(mac, tbuf, p->tot_len);
    7450:	8922      	ldrh	r2, [r4, #8]
    7452:	4b06      	ldr	r3, [pc, #24]	; (746c <mac_low_level_output+0x80>)
    7454:	4629      	mov	r1, r5
    7456:	4638      	mov	r0, r7
    7458:	4798      	blx	r3
		mem_free(tbuf);
    745a:	4b06      	ldr	r3, [pc, #24]	; (7474 <mac_low_level_output+0x88>)
    745c:	4628      	mov	r0, r5
    745e:	4798      	blx	r3
    7460:	e7d5      	b.n	740e <mac_low_level_output+0x22>
			return ERR_MEM;
    7462:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    7466:	e7d6      	b.n	7416 <mac_low_level_output+0x2a>
    7468:	0000308d 	.word	0x0000308d
    746c:	00004c99 	.word	0x00004c99
    7470:	00006805 	.word	0x00006805
    7474:	00006679 	.word	0x00006679
    7478:	0000a349 	.word	0x0000a349

0000747c <ethernetif_mac_input>:

/**
 * \brief Process incoming ethernet packet.
 */
void ethernetif_mac_input(struct netif *netif)
{
    747c:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	len = mac_async_read_len(mac); /* Obtain the size of the packet */
    7480:	4f1e      	ldr	r7, [pc, #120]	; (74fc <ethernetif_mac_input+0x80>)
	p = pbuf_alloc(PBUF_RAW, len, PBUF_RAM);
    7482:	f8df 8088 	ldr.w	r8, [pc, #136]	; 750c <ethernetif_mac_input+0x90>
    7486:	4e1e      	ldr	r6, [pc, #120]	; (7500 <ethernetif_mac_input+0x84>)
{
    7488:	4605      	mov	r5, r0
	struct eth_hdr *ethhdr;
	struct pbuf *   p;

	/* move received packet into a new pbuf */
	do {
		p = low_level_input(netif);
    748a:	f8d5 9020 	ldr.w	r9, [r5, #32]
	len = mac_async_read_len(mac); /* Obtain the size of the packet */
    748e:	4648      	mov	r0, r9
    7490:	47b8      	blx	r7
    7492:	b281      	uxth	r1, r0
	if (len == 0) {
    7494:	2900      	cmp	r1, #0
    7496:	d02f      	beq.n	74f8 <ethernetif_mac_input+0x7c>
	len += ETH_PAD_SIZE; /* allow room for Ethernet padding */
    7498:	3102      	adds	r1, #2
	p = pbuf_alloc(PBUF_RAW, len, PBUF_RAM);
    749a:	2200      	movs	r2, #0
    749c:	b289      	uxth	r1, r1
    749e:	2003      	movs	r0, #3
    74a0:	47c0      	blx	r8
	if (p != NULL) {
    74a2:	4604      	mov	r4, r0
    74a4:	b1d0      	cbz	r0, 74dc <ethernetif_mac_input+0x60>
		pbuf_header(p, -ETH_PAD_SIZE); /* drop the padding word */
    74a6:	f8df a068 	ldr.w	sl, [pc, #104]	; 7510 <ethernetif_mac_input+0x94>
    74aa:	f06f 0101 	mvn.w	r1, #1
    74ae:	47d0      	blx	sl
		mac_async_read(mac, p->payload, p->len);
    74b0:	8962      	ldrh	r2, [r4, #10]
    74b2:	6861      	ldr	r1, [r4, #4]
    74b4:	4648      	mov	r0, r9
    74b6:	47b0      	blx	r6
		pbuf_header(p, ETH_PAD_SIZE); /* reclaim the padding word */
    74b8:	2102      	movs	r1, #2
    74ba:	4620      	mov	r0, r4
    74bc:	47d0      	blx	sl
			return;
		}
		/* points to packet payload, which starts with an Ethernet header */
		ethhdr = p->payload;

		switch (htons(ethhdr->type)) {
    74be:	6863      	ldr	r3, [r4, #4]
    74c0:	89d8      	ldrh	r0, [r3, #14]
    74c2:	4b10      	ldr	r3, [pc, #64]	; (7504 <ethernetif_mac_input+0x88>)
    74c4:	4798      	blx	r3
    74c6:	f5b0 6f00 	cmp.w	r0, #2048	; 0x800
    74ca:	d00e      	beq.n	74ea <ethernetif_mac_input+0x6e>
    74cc:	f640 0306 	movw	r3, #2054	; 0x806
    74d0:	4298      	cmp	r0, r3
    74d2:	d00a      	beq.n	74ea <ethernetif_mac_input+0x6e>
				p = NULL;
			}
			break;

		default:
			pbuf_free(p);
    74d4:	4b0c      	ldr	r3, [pc, #48]	; (7508 <ethernetif_mac_input+0x8c>)
    74d6:	4620      	mov	r0, r4
    74d8:	4798      	blx	r3
			p = NULL;
			break;
    74da:	e7d6      	b.n	748a <ethernetif_mac_input+0xe>
		mac_async_read(mac, NULL, 0);
    74dc:	4602      	mov	r2, r0
    74de:	4601      	mov	r1, r0
    74e0:	4633      	mov	r3, r6
    74e2:	4648      	mov	r0, r9
		}
	} while (true);
}
    74e4:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
		mac_async_read(mac, NULL, 0);
    74e8:	4718      	bx	r3
			if (netif->input(p, netif) != ERR_OK) {
    74ea:	692b      	ldr	r3, [r5, #16]
    74ec:	4629      	mov	r1, r5
    74ee:	4620      	mov	r0, r4
    74f0:	4798      	blx	r3
    74f2:	2800      	cmp	r0, #0
    74f4:	d0c9      	beq.n	748a <ethernetif_mac_input+0xe>
    74f6:	e7ed      	b.n	74d4 <ethernetif_mac_input+0x58>
}
    74f8:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    74fc:	00004d05 	.word	0x00004d05
    7500:	00004cd1 	.word	0x00004cd1
    7504:	00000d65 	.word	0x00000d65
    7508:	000030e5 	.word	0x000030e5
    750c:	0000313d 	.word	0x0000313d
    7510:	0000308d 	.word	0x0000308d

00007514 <netconn_recv_data>:
 * @param new_buf pointer where a new pbuf/netbuf is stored when received data
 * @return ERR_OK if data has been received, an error code otherwise (timeout,
 *                memory error or another error)
 */
static err_t netconn_recv_data(struct netconn *conn, void **new_buf)
{
    7514:	b5f0      	push	{r4, r5, r6, r7, lr}
    7516:	b089      	sub	sp, #36	; 0x24
	void *buf = NULL;
    7518:	2600      	movs	r6, #0
{
    751a:	4604      	mov	r4, r0
	void *buf = NULL;
    751c:	9601      	str	r6, [sp, #4]
	err_t err;
#if LWIP_TCP
	struct api_msg msg;
#endif /* LWIP_TCP */

	LWIP_ERROR("netconn_recv: invalid pointer", (new_buf != NULL), return ERR_ARG;);
    751e:	460d      	mov	r5, r1
    7520:	b901      	cbnz	r1, 7524 <netconn_recv_data+0x10>
    7522:	e7fe      	b.n	7522 <netconn_recv_data+0xe>
	*new_buf = NULL;
    7524:	600e      	str	r6, [r1, #0]
	LWIP_ERROR("netconn_recv: invalid conn", (conn != NULL), return ERR_ARG;);
    7526:	b900      	cbnz	r0, 752a <netconn_recv_data+0x16>
    7528:	e7fe      	b.n	7528 <netconn_recv_data+0x14>
	LWIP_ERROR("netconn_accept: invalid recvmbox", sys_mbox_valid(&conn->recvmbox), return ERR_CONN;);
    752a:	f100 0710 	add.w	r7, r0, #16
    752e:	4b20      	ldr	r3, [pc, #128]	; (75b0 <netconn_recv_data+0x9c>)
    7530:	4638      	mov	r0, r7
    7532:	4798      	blx	r3
    7534:	b900      	cbnz	r0, 7538 <netconn_recv_data+0x24>
    7536:	e7fe      	b.n	7536 <netconn_recv_data+0x22>

	err = conn->last_err;
    7538:	f994 0008 	ldrsb.w	r0, [r4, #8]
	if (ERR_IS_FATAL(err)) {
    753c:	f110 0f09 	cmn.w	r0, #9
    7540:	db30      	blt.n	75a4 <netconn_recv_data+0x90>
	if (sys_arch_mbox_fetch(&conn->recvmbox, &buf, conn->recv_timeout) == SYS_ARCH_TIMEOUT) {
		NETCONN_SET_SAFE_ERR(conn, ERR_TIMEOUT);
		return ERR_TIMEOUT;
	}
#else
	sys_arch_mbox_fetch(&conn->recvmbox, &buf, 0);
    7542:	4b1c      	ldr	r3, [pc, #112]	; (75b4 <netconn_recv_data+0xa0>)
    7544:	4632      	mov	r2, r6
    7546:	a901      	add	r1, sp, #4
    7548:	4638      	mov	r0, r7
    754a:	4798      	blx	r3
#endif /* LWIP_SO_RCVTIMEO*/

#if LWIP_TCP
#if (LWIP_UDP || LWIP_RAW)
	if (conn->type == NETCONN_TCP)
    754c:	7823      	ldrb	r3, [r4, #0]
    754e:	2b10      	cmp	r3, #16
    7550:	9b01      	ldr	r3, [sp, #4]
    7552:	d129      	bne.n	75a8 <netconn_recv_data+0x94>
#endif /* (LWIP_UDP || LWIP_RAW) */
	{
		if (!netconn_get_noautorecved(conn) || (buf == NULL)) {
    7554:	7f22      	ldrb	r2, [r4, #28]
    7556:	0712      	lsls	r2, r2, #28
    7558:	d500      	bpl.n	755c <netconn_recv_data+0x48>
    755a:	b943      	cbnz	r3, 756e <netconn_recv_data+0x5a>
			/* Let the stack know that we have taken the data. */
			/* TODO: Speedup: Don't block and wait for the answer here
			   (to prevent multiple thread-switches). */
			msg.function = do_recv;
    755c:	4a16      	ldr	r2, [pc, #88]	; (75b8 <netconn_recv_data+0xa4>)
			msg.msg.conn = conn;
    755e:	e9cd 2402 	strd	r2, r4, [sp, #8]
			if (buf != NULL) {
    7562:	b1a3      	cbz	r3, 758e <netconn_recv_data+0x7a>
				msg.msg.msg.r.len = ((struct pbuf *)buf)->tot_len;
    7564:	891b      	ldrh	r3, [r3, #8]
    7566:	9305      	str	r3, [sp, #20]
			} else {
				msg.msg.msg.r.len = 1;
			}
			/* don't care for the return value of do_recv */
			TCPIP_APIMSG(&msg);
    7568:	a802      	add	r0, sp, #8
    756a:	4b14      	ldr	r3, [pc, #80]	; (75bc <netconn_recv_data+0xa8>)
    756c:	4798      	blx	r3
		}

		/* If we are closed, we indicate that we no longer wish to use the socket */
		if (buf == NULL) {
    756e:	9a01      	ldr	r2, [sp, #4]
    7570:	b97a      	cbnz	r2, 7592 <netconn_recv_data+0x7e>
			API_EVENT(conn, NETCONN_EVT_RCVMINUS, 0);
    7572:	6aa3      	ldr	r3, [r4, #40]	; 0x28
    7574:	b113      	cbz	r3, 757c <netconn_recv_data+0x68>
    7576:	2101      	movs	r1, #1
    7578:	4620      	mov	r0, r4
    757a:	4798      	blx	r3
			/* Avoid to lose any previous error code */
			NETCONN_SET_SAFE_ERR(conn, ERR_CLSD);
    757c:	f994 3008 	ldrsb.w	r3, [r4, #8]
    7580:	3309      	adds	r3, #9
    7582:	db01      	blt.n	7588 <netconn_recv_data+0x74>
    7584:	23f4      	movs	r3, #244	; 0xf4
    7586:	7223      	strb	r3, [r4, #8]
			return ERR_CLSD;
    7588:	f06f 000b 	mvn.w	r0, #11
    758c:	e00a      	b.n	75a4 <netconn_recv_data+0x90>
				msg.msg.msg.r.len = 1;
    758e:	2301      	movs	r3, #1
    7590:	e7e9      	b.n	7566 <netconn_recv_data+0x52>
		}
		len = ((struct pbuf *)buf)->tot_len;
    7592:	8912      	ldrh	r2, [r2, #8]

#if LWIP_SO_RCVBUF
	SYS_ARCH_DEC(conn->recv_avail, len);
#endif /* LWIP_SO_RCVBUF */
	/* Register event with callback */
	API_EVENT(conn, NETCONN_EVT_RCVMINUS, len);
    7594:	6aa3      	ldr	r3, [r4, #40]	; 0x28
    7596:	b113      	cbz	r3, 759e <netconn_recv_data+0x8a>
    7598:	2101      	movs	r1, #1
    759a:	4620      	mov	r0, r4
    759c:	4798      	blx	r3

	LWIP_DEBUGF(API_LIB_DEBUG, ("netconn_recv_data: received %p, len=%" U16_F "\n", buf, len));

	*new_buf = buf;
    759e:	9b01      	ldr	r3, [sp, #4]
    75a0:	602b      	str	r3, [r5, #0]
	/* don't set conn->last_err: it's only ERR_OK, anyway */
	return ERR_OK;
    75a2:	2000      	movs	r0, #0
}
    75a4:	b009      	add	sp, #36	; 0x24
    75a6:	bdf0      	pop	{r4, r5, r6, r7, pc}
		len = netbuf_len((struct netbuf *)buf);
    75a8:	681b      	ldr	r3, [r3, #0]
    75aa:	891a      	ldrh	r2, [r3, #8]
    75ac:	e7f2      	b.n	7594 <netconn_recv_data+0x80>
    75ae:	bf00      	nop
    75b0:	00007bdd 	.word	0x00007bdd
    75b4:	00007b51 	.word	0x00007b51
    75b8:	00001c19 	.word	0x00001c19
    75bc:	0000a251 	.word	0x0000a251

000075c0 <netconn_new_with_proto_and_callback>:
{
    75c0:	b530      	push	{r4, r5, lr}
	conn = netconn_alloc(t, callback);
    75c2:	4b10      	ldr	r3, [pc, #64]	; (7604 <netconn_new_with_proto_and_callback+0x44>)
{
    75c4:	b087      	sub	sp, #28
    75c6:	460d      	mov	r5, r1
	conn = netconn_alloc(t, callback);
    75c8:	4611      	mov	r1, r2
    75ca:	4798      	blx	r3
	if (conn != NULL) {
    75cc:	4604      	mov	r4, r0
    75ce:	b1a8      	cbz	r0, 75fc <netconn_new_with_proto_and_callback+0x3c>
		msg.function        = do_newconn;
    75d0:	4b0d      	ldr	r3, [pc, #52]	; (7608 <netconn_new_with_proto_and_callback+0x48>)
    75d2:	9300      	str	r3, [sp, #0]
		msg.msg.conn        = conn;
    75d4:	9001      	str	r0, [sp, #4]
		if (TCPIP_APIMSG(&msg) != ERR_OK) {
    75d6:	4b0d      	ldr	r3, [pc, #52]	; (760c <netconn_new_with_proto_and_callback+0x4c>)
		msg.msg.msg.n.proto = proto;
    75d8:	f88d 500c 	strb.w	r5, [sp, #12]
		if (TCPIP_APIMSG(&msg) != ERR_OK) {
    75dc:	4668      	mov	r0, sp
    75de:	4798      	blx	r3
    75e0:	b160      	cbz	r0, 75fc <netconn_new_with_proto_and_callback+0x3c>
			sys_sem_free(&conn->op_completed);
    75e2:	f104 000c 	add.w	r0, r4, #12
    75e6:	4b0a      	ldr	r3, [pc, #40]	; (7610 <netconn_new_with_proto_and_callback+0x50>)
    75e8:	4798      	blx	r3
			sys_mbox_free(&conn->recvmbox);
    75ea:	f104 0010 	add.w	r0, r4, #16
    75ee:	4b09      	ldr	r3, [pc, #36]	; (7614 <netconn_new_with_proto_and_callback+0x54>)
    75f0:	4798      	blx	r3
			memp_free(MEMP_NETCONN, conn);
    75f2:	4621      	mov	r1, r4
    75f4:	4b08      	ldr	r3, [pc, #32]	; (7618 <netconn_new_with_proto_and_callback+0x58>)
    75f6:	2007      	movs	r0, #7
    75f8:	4798      	blx	r3
			return NULL;
    75fa:	2400      	movs	r4, #0
}
    75fc:	4620      	mov	r0, r4
    75fe:	b007      	add	sp, #28
    7600:	bd30      	pop	{r4, r5, pc}
    7602:	bf00      	nop
    7604:	000017cd 	.word	0x000017cd
    7608:	00001751 	.word	0x00001751
    760c:	0000a251 	.word	0x0000a251
    7610:	00007a09 	.word	0x00007a09
    7614:	00007abd 	.word	0x00007abd
    7618:	00004c1d 	.word	0x00004c1d

0000761c <netconn_delete>:
{
    761c:	b510      	push	{r4, lr}
	if (conn == NULL) {
    761e:	4604      	mov	r4, r0
{
    7620:	b086      	sub	sp, #24
	if (conn == NULL) {
    7622:	b140      	cbz	r0, 7636 <netconn_delete+0x1a>
	msg.function = do_delconn;
    7624:	4b05      	ldr	r3, [pc, #20]	; (763c <netconn_delete+0x20>)
	msg.msg.conn = conn;
    7626:	e9cd 3000 	strd	r3, r0, [sp]
	tcpip_apimsg(&msg);
    762a:	4b05      	ldr	r3, [pc, #20]	; (7640 <netconn_delete+0x24>)
    762c:	4668      	mov	r0, sp
    762e:	4798      	blx	r3
	netconn_free(conn);
    7630:	4b04      	ldr	r3, [pc, #16]	; (7644 <netconn_delete+0x28>)
    7632:	4620      	mov	r0, r4
    7634:	4798      	blx	r3
}
    7636:	2000      	movs	r0, #0
    7638:	b006      	add	sp, #24
    763a:	bd10      	pop	{r4, pc}
    763c:	00001a01 	.word	0x00001a01
    7640:	0000a251 	.word	0x0000a251
    7644:	00001845 	.word	0x00001845

00007648 <netconn_getaddr>:
{
    7648:	b510      	push	{r4, lr}
	LWIP_ERROR("netconn_getaddr: invalid conn", (conn != NULL), return ERR_ARG;);
    764a:	4604      	mov	r4, r0
{
    764c:	b086      	sub	sp, #24
	LWIP_ERROR("netconn_getaddr: invalid conn", (conn != NULL), return ERR_ARG;);
    764e:	b900      	cbnz	r0, 7652 <netconn_getaddr+0xa>
    7650:	e7fe      	b.n	7650 <netconn_getaddr+0x8>
	LWIP_ERROR("netconn_getaddr: invalid addr", (addr != NULL), return ERR_ARG;);
    7652:	b901      	cbnz	r1, 7656 <netconn_getaddr+0xe>
    7654:	e7fe      	b.n	7654 <netconn_getaddr+0xc>
	LWIP_ERROR("netconn_getaddr: invalid port", (port != NULL), return ERR_ARG;);
    7656:	b902      	cbnz	r2, 765a <netconn_getaddr+0x12>
    7658:	e7fe      	b.n	7658 <netconn_getaddr+0x10>
	msg.function          = do_getaddr;
    765a:	4808      	ldr	r0, [pc, #32]	; (767c <netconn_getaddr+0x34>)
	msg.msg.msg.ad.local  = local;
    765c:	f88d 3014 	strb.w	r3, [sp, #20]
	msg.msg.conn          = conn;
    7660:	e9cd 0400 	strd	r0, r4, [sp]
	err                   = TCPIP_APIMSG(&msg);
    7664:	4b06      	ldr	r3, [pc, #24]	; (7680 <netconn_getaddr+0x38>)
    7666:	4668      	mov	r0, sp
	msg.msg.msg.ad.port   = port;
    7668:	e9cd 1203 	strd	r1, r2, [sp, #12]
	err                   = TCPIP_APIMSG(&msg);
    766c:	4798      	blx	r3
	NETCONN_SET_SAFE_ERR(conn, err);
    766e:	f994 3008 	ldrsb.w	r3, [r4, #8]
    7672:	3309      	adds	r3, #9
    7674:	bfa8      	it	ge
    7676:	7220      	strbge	r0, [r4, #8]
}
    7678:	b006      	add	sp, #24
    767a:	bd10      	pop	{r4, pc}
    767c:	00001ca5 	.word	0x00001ca5
    7680:	0000a251 	.word	0x0000a251

00007684 <netconn_bind>:
{
    7684:	b510      	push	{r4, lr}
	LWIP_ERROR("netconn_bind: invalid conn", (conn != NULL), return ERR_ARG;);
    7686:	4604      	mov	r4, r0
{
    7688:	b086      	sub	sp, #24
	LWIP_ERROR("netconn_bind: invalid conn", (conn != NULL), return ERR_ARG;);
    768a:	b900      	cbnz	r0, 768e <netconn_bind+0xa>
    768c:	e7fe      	b.n	768c <netconn_bind+0x8>
	msg.function          = do_bind;
    768e:	4b08      	ldr	r3, [pc, #32]	; (76b0 <netconn_bind+0x2c>)
	msg.msg.msg.bc.ipaddr = addr;
    7690:	9103      	str	r1, [sp, #12]
	msg.msg.conn          = conn;
    7692:	e9cd 3000 	strd	r3, r0, [sp]
	err                   = TCPIP_APIMSG(&msg);
    7696:	4b07      	ldr	r3, [pc, #28]	; (76b4 <netconn_bind+0x30>)
	msg.msg.msg.bc.port   = port;
    7698:	f8ad 2010 	strh.w	r2, [sp, #16]
	err                   = TCPIP_APIMSG(&msg);
    769c:	4668      	mov	r0, sp
    769e:	4798      	blx	r3
	NETCONN_SET_SAFE_ERR(conn, err);
    76a0:	f994 3008 	ldrsb.w	r3, [r4, #8]
    76a4:	3309      	adds	r3, #9
    76a6:	bfa8      	it	ge
    76a8:	7220      	strbge	r0, [r4, #8]
}
    76aa:	b006      	add	sp, #24
    76ac:	bd10      	pop	{r4, pc}
    76ae:	bf00      	nop
    76b0:	00001a99 	.word	0x00001a99
    76b4:	0000a251 	.word	0x0000a251

000076b8 <netconn_listen_with_backlog>:
{
    76b8:	b510      	push	{r4, lr}
	LWIP_ERROR("netconn_listen: invalid conn", (conn != NULL), return ERR_ARG;);
    76ba:	4604      	mov	r4, r0
{
    76bc:	b086      	sub	sp, #24
	LWIP_ERROR("netconn_listen: invalid conn", (conn != NULL), return ERR_ARG;);
    76be:	b900      	cbnz	r0, 76c2 <netconn_listen_with_backlog+0xa>
    76c0:	e7fe      	b.n	76c0 <netconn_listen_with_backlog+0x8>
	msg.function = do_listen;
    76c2:	4b06      	ldr	r3, [pc, #24]	; (76dc <netconn_listen_with_backlog+0x24>)
	msg.msg.conn = conn;
    76c4:	e9cd 3000 	strd	r3, r0, [sp]
	err = TCPIP_APIMSG(&msg);
    76c8:	4b05      	ldr	r3, [pc, #20]	; (76e0 <netconn_listen_with_backlog+0x28>)
    76ca:	4668      	mov	r0, sp
    76cc:	4798      	blx	r3
	NETCONN_SET_SAFE_ERR(conn, err);
    76ce:	f994 3008 	ldrsb.w	r3, [r4, #8]
    76d2:	3309      	adds	r3, #9
    76d4:	bfa8      	it	ge
    76d6:	7220      	strbge	r0, [r4, #8]
}
    76d8:	b006      	add	sp, #24
    76da:	bd10      	pop	{r4, pc}
    76dc:	00001af1 	.word	0x00001af1
    76e0:	0000a251 	.word	0x0000a251

000076e4 <netconn_accept>:
{
    76e4:	b573      	push	{r0, r1, r4, r5, r6, lr}
    76e6:	4604      	mov	r4, r0
	LWIP_ERROR("netconn_accept: invalid pointer", (new_conn != NULL), return ERR_ARG;);
    76e8:	460d      	mov	r5, r1
    76ea:	b901      	cbnz	r1, 76ee <netconn_accept+0xa>
    76ec:	e7fe      	b.n	76ec <netconn_accept+0x8>
	*new_conn = NULL;
    76ee:	2200      	movs	r2, #0
    76f0:	600a      	str	r2, [r1, #0]
	LWIP_ERROR("netconn_accept: invalid conn", (conn != NULL), return ERR_ARG;);
    76f2:	b900      	cbnz	r0, 76f6 <netconn_accept+0x12>
    76f4:	e7fe      	b.n	76f4 <netconn_accept+0x10>
	LWIP_ERROR("netconn_accept: invalid acceptmbox", sys_mbox_valid(&conn->acceptmbox), return ERR_ARG;);
    76f6:	f100 0614 	add.w	r6, r0, #20
    76fa:	4b12      	ldr	r3, [pc, #72]	; (7744 <netconn_accept+0x60>)
    76fc:	4630      	mov	r0, r6
    76fe:	4798      	blx	r3
    7700:	2200      	movs	r2, #0
    7702:	b900      	cbnz	r0, 7706 <netconn_accept+0x22>
    7704:	e7fe      	b.n	7704 <netconn_accept+0x20>
	err = conn->last_err;
    7706:	f994 0008 	ldrsb.w	r0, [r4, #8]
	if (ERR_IS_FATAL(err)) {
    770a:	f110 0f09 	cmn.w	r0, #9
    770e:	db16      	blt.n	773e <netconn_accept+0x5a>
	sys_arch_mbox_fetch(&conn->acceptmbox, (void **)&newconn, 0);
    7710:	4b0d      	ldr	r3, [pc, #52]	; (7748 <netconn_accept+0x64>)
    7712:	a901      	add	r1, sp, #4
    7714:	4630      	mov	r0, r6
    7716:	4798      	blx	r3
	API_EVENT(conn, NETCONN_EVT_RCVMINUS, 0);
    7718:	6aa3      	ldr	r3, [r4, #40]	; 0x28
    771a:	b11b      	cbz	r3, 7724 <netconn_accept+0x40>
    771c:	2200      	movs	r2, #0
    771e:	2101      	movs	r1, #1
    7720:	4620      	mov	r0, r4
    7722:	4798      	blx	r3
	if (newconn == NULL) {
    7724:	9b01      	ldr	r3, [sp, #4]
    7726:	b943      	cbnz	r3, 773a <netconn_accept+0x56>
		NETCONN_SET_SAFE_ERR(conn, ERR_ABRT);
    7728:	f994 3008 	ldrsb.w	r3, [r4, #8]
    772c:	3309      	adds	r3, #9
    772e:	db01      	blt.n	7734 <netconn_accept+0x50>
    7730:	23f6      	movs	r3, #246	; 0xf6
    7732:	7223      	strb	r3, [r4, #8]
		return ERR_ABRT;
    7734:	f06f 0009 	mvn.w	r0, #9
    7738:	e001      	b.n	773e <netconn_accept+0x5a>
	*new_conn = newconn;
    773a:	602b      	str	r3, [r5, #0]
	return ERR_OK;
    773c:	2000      	movs	r0, #0
}
    773e:	b002      	add	sp, #8
    7740:	bd70      	pop	{r4, r5, r6, pc}
    7742:	bf00      	nop
    7744:	00007bdd 	.word	0x00007bdd
    7748:	00007b51 	.word	0x00007b51

0000774c <netconn_recv_tcp_pbuf>:
 *                memory error or another error)
 *         ERR_ARG if conn is not a TCP netconn
 */
err_t netconn_recv_tcp_pbuf(struct netconn *conn, struct pbuf **new_buf)
{
	LWIP_ERROR("netconn_recv: invalid conn", (conn != NULL) && netconn_type(conn) == NETCONN_TCP, return ERR_ARG;);
    774c:	b110      	cbz	r0, 7754 <netconn_recv_tcp_pbuf+0x8>
    774e:	7803      	ldrb	r3, [r0, #0]
    7750:	2b10      	cmp	r3, #16
    7752:	d000      	beq.n	7756 <netconn_recv_tcp_pbuf+0xa>
    7754:	e7fe      	b.n	7754 <netconn_recv_tcp_pbuf+0x8>

	return netconn_recv_data(conn, (void **)new_buf);
    7756:	4b01      	ldr	r3, [pc, #4]	; (775c <netconn_recv_tcp_pbuf+0x10>)
    7758:	4718      	bx	r3
    775a:	bf00      	nop
    775c:	00007515 	.word	0x00007515

00007760 <netconn_recv>:
 * @param new_buf pointer where a new netbuf is stored when received data
 * @return ERR_OK if data has been received, an error code otherwise (timeout,
 *                memory error or another error)
 */
err_t netconn_recv(struct netconn *conn, struct netbuf **new_buf)
{
    7760:	b573      	push	{r0, r1, r4, r5, r6, lr}
    7762:	4604      	mov	r4, r0
#if LWIP_TCP
	struct netbuf *buf = NULL;
	err_t          err;
#endif /* LWIP_TCP */

	LWIP_ERROR("netconn_recv: invalid pointer", (new_buf != NULL), return ERR_ARG;);
    7764:	460e      	mov	r6, r1
    7766:	b901      	cbnz	r1, 776a <netconn_recv+0xa>
    7768:	e7fe      	b.n	7768 <netconn_recv+0x8>
	*new_buf = NULL;
    776a:	2500      	movs	r5, #0
    776c:	600d      	str	r5, [r1, #0]
	LWIP_ERROR("netconn_recv: invalid conn", (conn != NULL), return ERR_ARG;);
    776e:	b900      	cbnz	r0, 7772 <netconn_recv+0x12>
    7770:	e7fe      	b.n	7770 <netconn_recv+0x10>
	LWIP_ERROR("netconn_accept: invalid recvmbox", sys_mbox_valid(&conn->recvmbox), return ERR_CONN;);
    7772:	4b19      	ldr	r3, [pc, #100]	; (77d8 <netconn_recv+0x78>)
    7774:	3010      	adds	r0, #16
    7776:	4798      	blx	r3
    7778:	b900      	cbnz	r0, 777c <netconn_recv+0x1c>
    777a:	e7fe      	b.n	777a <netconn_recv+0x1a>

#if LWIP_TCP
#if (LWIP_UDP || LWIP_RAW)
	if (conn->type == NETCONN_TCP)
    777c:	7823      	ldrb	r3, [r4, #0]
    777e:	2b10      	cmp	r3, #16
    7780:	d122      	bne.n	77c8 <netconn_recv+0x68>
#endif /* (LWIP_UDP || LWIP_RAW) */
	{
		struct pbuf *p = NULL;
		/* This is not a listening netconn, since recvmbox is set */

		buf = (struct netbuf *)memp_malloc(MEMP_NETBUF);
    7782:	4b16      	ldr	r3, [pc, #88]	; (77dc <netconn_recv+0x7c>)
		struct pbuf *p = NULL;
    7784:	9501      	str	r5, [sp, #4]
		buf = (struct netbuf *)memp_malloc(MEMP_NETBUF);
    7786:	2006      	movs	r0, #6
    7788:	4798      	blx	r3
		if (buf == NULL) {
    778a:	4605      	mov	r5, r0
    778c:	b940      	cbnz	r0, 77a0 <netconn_recv+0x40>
			NETCONN_SET_SAFE_ERR(conn, ERR_MEM);
    778e:	f994 3008 	ldrsb.w	r3, [r4, #8]
    7792:	3309      	adds	r3, #9
    7794:	db01      	blt.n	779a <netconn_recv+0x3a>
    7796:	23ff      	movs	r3, #255	; 0xff
    7798:	7223      	strb	r3, [r4, #8]
			return ERR_MEM;
    779a:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
    779e:	e009      	b.n	77b4 <netconn_recv+0x54>
		}

		err = netconn_recv_data(conn, (void **)&p);
    77a0:	4620      	mov	r0, r4
    77a2:	4b0f      	ldr	r3, [pc, #60]	; (77e0 <netconn_recv+0x80>)
    77a4:	a901      	add	r1, sp, #4
    77a6:	4798      	blx	r3
		if (err != ERR_OK) {
    77a8:	4604      	mov	r4, r0
    77aa:	b130      	cbz	r0, 77ba <netconn_recv+0x5a>
			memp_free(MEMP_NETBUF, buf);
    77ac:	4b0d      	ldr	r3, [pc, #52]	; (77e4 <netconn_recv+0x84>)
    77ae:	4629      	mov	r1, r5
    77b0:	2006      	movs	r0, #6
    77b2:	4798      	blx	r3
	{
#if (LWIP_UDP || LWIP_RAW)
		return netconn_recv_data(conn, (void **)new_buf);
#endif /* (LWIP_UDP || LWIP_RAW) */
	}
}
    77b4:	4620      	mov	r0, r4
    77b6:	b002      	add	sp, #8
    77b8:	bd70      	pop	{r4, r5, r6, pc}
		buf->p    = p;
    77ba:	9b01      	ldr	r3, [sp, #4]
		buf->port = 0;
    77bc:	81a8      	strh	r0, [r5, #12]
		buf->ptr  = p;
    77be:	e9c5 3300 	strd	r3, r3, [r5]
		ip_addr_set_any(&buf->addr);
    77c2:	60a8      	str	r0, [r5, #8]
		*new_buf = buf;
    77c4:	6035      	str	r5, [r6, #0]
		return ERR_OK;
    77c6:	e7f5      	b.n	77b4 <netconn_recv+0x54>
		return netconn_recv_data(conn, (void **)new_buf);
    77c8:	4b05      	ldr	r3, [pc, #20]	; (77e0 <netconn_recv+0x80>)
    77ca:	4631      	mov	r1, r6
    77cc:	4620      	mov	r0, r4
}
    77ce:	b002      	add	sp, #8
    77d0:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		return netconn_recv_data(conn, (void **)new_buf);
    77d4:	4718      	bx	r3
    77d6:	bf00      	nop
    77d8:	00007bdd 	.word	0x00007bdd
    77dc:	00004c01 	.word	0x00004c01
    77e0:	00007515 	.word	0x00007515
    77e4:	00004c1d 	.word	0x00004c1d

000077e8 <netconn_recved>:
 *
 * @param conn the netconn for which to update the receive window
 * @param length amount of data processed (ATTENTION: this must be accurate!)
 */
void netconn_recved(struct netconn *conn, u32_t length)
{
    77e8:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
#if LWIP_TCP
	if ((conn != NULL) && (conn->type == NETCONN_TCP) && (netconn_get_noautorecved(conn))) {
    77ea:	b160      	cbz	r0, 7806 <netconn_recved+0x1e>
    77ec:	7803      	ldrb	r3, [r0, #0]
    77ee:	2b10      	cmp	r3, #16
    77f0:	d109      	bne.n	7806 <netconn_recved+0x1e>
    77f2:	7f03      	ldrb	r3, [r0, #28]
    77f4:	071b      	lsls	r3, r3, #28
    77f6:	d506      	bpl.n	7806 <netconn_recved+0x1e>
		struct api_msg msg;
		/* Let the stack know that we have taken the data. */
		/* TODO: Speedup: Don't block and wait for the answer here
		   (to prevent multiple thread-switches). */
		msg.function      = do_recv;
    77f8:	4b04      	ldr	r3, [pc, #16]	; (780c <netconn_recved+0x24>)
		msg.msg.conn      = conn;
		msg.msg.msg.r.len = length;
    77fa:	9103      	str	r1, [sp, #12]
		msg.msg.conn      = conn;
    77fc:	e9cd 3000 	strd	r3, r0, [sp]
		/* don't care for the return value of do_recv */
		TCPIP_APIMSG(&msg);
    7800:	4b03      	ldr	r3, [pc, #12]	; (7810 <netconn_recved+0x28>)
    7802:	4668      	mov	r0, sp
    7804:	4798      	blx	r3
	}
#else  /* LWIP_TCP */
	LWIP_UNUSED_ARG(conn);
	LWIP_UNUSED_ARG(length);
#endif /* LWIP_TCP */
}
    7806:	b007      	add	sp, #28
    7808:	f85d fb04 	ldr.w	pc, [sp], #4
    780c:	00001c19 	.word	0x00001c19
    7810:	0000a251 	.word	0x0000a251

00007814 <netconn_send>:
 * @param conn the UDP or RAW netconn over which to send data
 * @param buf a netbuf containing the data to send
 * @return ERR_OK if data was sent, any other err_t on error
 */
err_t netconn_send(struct netconn *conn, struct netbuf *buf)
{
    7814:	b510      	push	{r4, lr}
	struct api_msg msg;
	err_t          err;

	LWIP_ERROR("netconn_send: invalid conn", (conn != NULL), return ERR_ARG;);
    7816:	4604      	mov	r4, r0
{
    7818:	b086      	sub	sp, #24
	LWIP_ERROR("netconn_send: invalid conn", (conn != NULL), return ERR_ARG;);
    781a:	b900      	cbnz	r0, 781e <netconn_send+0xa>
    781c:	e7fe      	b.n	781c <netconn_send+0x8>

	LWIP_DEBUGF(API_LIB_DEBUG, ("netconn_send: sending %" U16_F " bytes\n", buf->p->tot_len));
	msg.function  = do_send;
    781e:	4b07      	ldr	r3, [pc, #28]	; (783c <netconn_send+0x28>)
	msg.msg.conn  = conn;
	msg.msg.msg.b = buf;
    7820:	9103      	str	r1, [sp, #12]
	msg.msg.conn  = conn;
    7822:	e9cd 3000 	strd	r3, r0, [sp]
	err           = TCPIP_APIMSG(&msg);
    7826:	4b06      	ldr	r3, [pc, #24]	; (7840 <netconn_send+0x2c>)
    7828:	4668      	mov	r0, sp
    782a:	4798      	blx	r3

	NETCONN_SET_SAFE_ERR(conn, err);
    782c:	f994 3008 	ldrsb.w	r3, [r4, #8]
    7830:	3309      	adds	r3, #9
    7832:	bfa8      	it	ge
    7834:	7220      	strbge	r0, [r4, #8]
	return err;
}
    7836:	b006      	add	sp, #24
    7838:	bd10      	pop	{r4, pc}
    783a:	bf00      	nop
    783c:	00001bc1 	.word	0x00001bc1
    7840:	0000a251 	.word	0x0000a251

00007844 <netconn_write_partly>:
 * - NETCONN_DONTBLOCK: only write the data if all dat can be written at once
 * @param bytes_written pointer to a location that receives the number of written bytes
 * @return ERR_OK if data was sent, any other err_t on error
 */
err_t netconn_write_partly(struct netconn *conn, const void *dataptr, size_t size, u8_t apiflags, size_t *bytes_written)
{
    7844:	b5f0      	push	{r4, r5, r6, r7, lr}
    7846:	b087      	sub	sp, #28
    7848:	4616      	mov	r6, r2
    784a:	9f0c      	ldr	r7, [sp, #48]	; 0x30
	struct api_msg msg;
	err_t          err;
	u8_t           dontblock;

	LWIP_ERROR("netconn_write: invalid conn", (conn != NULL), return ERR_ARG;);
    784c:	4605      	mov	r5, r0
    784e:	b900      	cbnz	r0, 7852 <netconn_write_partly+0xe>
    7850:	e7fe      	b.n	7850 <netconn_write_partly+0xc>
	LWIP_ERROR("netconn_write: invalid conn->type", (conn->type == NETCONN_TCP), return ERR_VAL;);
    7852:	7802      	ldrb	r2, [r0, #0]
    7854:	2a10      	cmp	r2, #16
    7856:	d000      	beq.n	785a <netconn_write_partly+0x16>
    7858:	e7fe      	b.n	7858 <netconn_write_partly+0x14>
	if (size == 0) {
    785a:	b306      	cbz	r6, 789e <netconn_write_partly+0x5a>
		return ERR_OK;
	}
	dontblock = netconn_is_nonblocking(conn) || (apiflags & NETCONN_DONTBLOCK);
	if (dontblock && !bytes_written) {
    785c:	7f04      	ldrb	r4, [r0, #28]
    785e:	f003 0204 	and.w	r2, r3, #4
    7862:	f004 0402 	and.w	r4, r4, #2
    7866:	4314      	orrs	r4, r2
    7868:	d001      	beq.n	786e <netconn_write_partly+0x2a>
    786a:	b1d7      	cbz	r7, 78a2 <netconn_write_partly+0x5e>
    786c:	2401      	movs	r4, #1
		   it has no way to return the number of bytes written. */
		return ERR_VAL;
	}

	/* non-blocking write sends as much  */
	msg.function           = do_write;
    786e:	4a0e      	ldr	r2, [pc, #56]	; (78a8 <netconn_write_partly+0x64>)
	msg.msg.conn           = conn;
	msg.msg.msg.w.dataptr  = dataptr;
	msg.msg.msg.w.apiflags = apiflags;
    7870:	f88d 3014 	strb.w	r3, [sp, #20]
#endif /* LWIP_SO_SNDTIMEO */

	/* For locking the core: this _can_ be delayed on low memory/low send buffer,
	   but if it is, this is done inside api_msg.c:do_write(), so we can use the
	   non-blocking version here. */
	err = TCPIP_APIMSG(&msg);
    7874:	4668      	mov	r0, sp
    7876:	4b0d      	ldr	r3, [pc, #52]	; (78ac <netconn_write_partly+0x68>)
	msg.msg.msg.w.dataptr  = dataptr;
    7878:	9103      	str	r1, [sp, #12]
	msg.msg.conn           = conn;
    787a:	e9cd 2500 	strd	r2, r5, [sp]
	msg.msg.msg.w.len      = size;
    787e:	9604      	str	r6, [sp, #16]
	err = TCPIP_APIMSG(&msg);
    7880:	4798      	blx	r3
	if ((err == ERR_OK) && (bytes_written != NULL)) {
    7882:	b918      	cbnz	r0, 788c <netconn_write_partly+0x48>
    7884:	b117      	cbz	r7, 788c <netconn_write_partly+0x48>
		if (dontblock
    7886:	b144      	cbz	r4, 789a <netconn_write_partly+0x56>
#if LWIP_SO_SNDTIMEO
		    || (conn->send_timeout != 0)
#endif /* LWIP_SO_SNDTIMEO */
		) {
			/* nonblocking write: maybe the data has been sent partly */
			*bytes_written = msg.msg.msg.w.len;
    7888:	9b04      	ldr	r3, [sp, #16]
    788a:	603b      	str	r3, [r7, #0]
			/* blocking call succeeded: all data has been sent if it */
			*bytes_written = size;
		}
	}

	NETCONN_SET_SAFE_ERR(conn, err);
    788c:	f995 3008 	ldrsb.w	r3, [r5, #8]
    7890:	3309      	adds	r3, #9
    7892:	db00      	blt.n	7896 <netconn_write_partly+0x52>
    7894:	7228      	strb	r0, [r5, #8]
	return err;
}
    7896:	b007      	add	sp, #28
    7898:	bdf0      	pop	{r4, r5, r6, r7, pc}
			*bytes_written = size;
    789a:	603e      	str	r6, [r7, #0]
    789c:	e7f6      	b.n	788c <netconn_write_partly+0x48>
		return ERR_OK;
    789e:	4630      	mov	r0, r6
    78a0:	e7f9      	b.n	7896 <netconn_write_partly+0x52>
		return ERR_VAL;
    78a2:	f06f 0005 	mvn.w	r0, #5
    78a6:	e7f6      	b.n	7896 <netconn_write_partly+0x52>
    78a8:	00001c61 	.word	0x00001c61
    78ac:	0000a251 	.word	0x0000a251

000078b0 <TCPIP_STACK_INTERFACE_0_stack_init>:
 *
 * @param netif the lwip network interface structure for this ethernetif
 * @return ERR_OK  if the loopif is initialized
 */
err_t TCPIP_STACK_INTERFACE_0_stack_init(struct netif *netif)
{
    78b0:	b508      	push	{r3, lr}
	LWIP_ASSERT("netif != NULL", (netif != NULL));
	LWIP_ASSERT("netif->state != NULL", (netif->state != NULL));

	netif->output     = etharp_output;
    78b2:	4a0d      	ldr	r2, [pc, #52]	; (78e8 <TCPIP_STACK_INTERFACE_0_stack_init+0x38>)
	netif->linkoutput = mac_low_level_output;

	/* device capabilities */
	TCPIP_STACK_INTERFACE_0_desc.flags = CONF_TCPIP_STACK_INTERFACE_0_FLAG;
    78b4:	4b0d      	ldr	r3, [pc, #52]	; (78ec <TCPIP_STACK_INTERFACE_0_stack_init+0x3c>)
	netif->output     = etharp_output;
    78b6:	6142      	str	r2, [r0, #20]
	netif->linkoutput = mac_low_level_output;
    78b8:	4a0d      	ldr	r2, [pc, #52]	; (78f0 <TCPIP_STACK_INTERFACE_0_stack_init+0x40>)
    78ba:	6182      	str	r2, [r0, #24]
	TCPIP_STACK_INTERFACE_0_desc.flags = CONF_TCPIP_STACK_INTERFACE_0_FLAG;
    78bc:	226a      	movs	r2, #106	; 0x6a
    78be:	f883 2031 	strb.w	r2, [r3, #49]	; 0x31
	TCPIP_STACK_INTERFACE_0_desc.mtu   = CONF_TCPIP_STACK_INTERFACE_0_MTU;
    78c2:	f44f 62c0 	mov.w	r2, #1536	; 0x600
    78c6:	851a      	strh	r2, [r3, #40]	; 0x28

	/* set MAC hardware address length */
	memcpy(TCPIP_STACK_INTERFACE_0_desc.hwaddr, TCPIP_STACK_INTERFACE_0_hwaddr, NETIF_MAX_HWADDR_LEN);
    78c8:	6b9a      	ldr	r2, [r3, #56]	; 0x38
    78ca:	f8c3 202b 	str.w	r2, [r3, #43]	; 0x2b
    78ce:	8f9a      	ldrh	r2, [r3, #60]	; 0x3c
    78d0:	f8a3 202f 	strh.w	r2, [r3, #47]	; 0x2f
	TCPIP_STACK_INTERFACE_0_desc.hwaddr_len = ETHARP_HWADDR_LEN;
    78d4:	2206      	movs	r2, #6
    78d6:	f883 202a 	strb.w	r2, [r3, #42]	; 0x2a

#if LWIP_NETIF_HOSTNAME
	/* Initialize interface hostname */
	LWIP_MACIF_desc.hostname = CONF_TCPIP_STACK_INTERFACE_0_HOSTNAME;
#endif
	memcpy(TCPIP_STACK_INTERFACE_0_desc.name, CONF_TCPIP_STACK_INTERFACE_0_HOSTNAME_ABBR, 2);
    78da:	f646 6265 	movw	r2, #28261	; 0x6e65
    78de:	865a      	strh	r2, [r3, #50]	; 0x32

	/* initialize the mac hardware */
	mac_low_level_init(netif);
    78e0:	4b04      	ldr	r3, [pc, #16]	; (78f4 <TCPIP_STACK_INTERFACE_0_stack_init+0x44>)
    78e2:	4798      	blx	r3

	return ERR_OK;
}
    78e4:	2000      	movs	r0, #0
    78e6:	bd08      	pop	{r3, pc}
    78e8:	000051ad 	.word	0x000051ad
    78ec:	20014960 	.word	0x20014960
    78f0:	000073ed 	.word	0x000073ed
    78f4:	000073c1 	.word	0x000073c1

000078f8 <TCPIP_STACK_INTERFACE_0_init>:
void TCPIP_STACK_INTERFACE_0_init(u8_t hwaddr[6])
{
    78f8:	b510      	push	{r4, lr}
    78fa:	b088      	sub	sp, #32
#else
	ipaddr_aton(CONF_TCPIP_STACK_INTERFACE_0_IP, &ip);
	ipaddr_aton(CONF_TCPIP_STACK_INTERFACE_0_NETMASK, &nm);
	ipaddr_aton(CONF_TCPIP_STACK_INTERFACE_0_GATEWAY, &gw);
#endif
	memcpy(TCPIP_STACK_INTERFACE_0_hwaddr, hwaddr, 6);
    78fc:	4c0b      	ldr	r4, [pc, #44]	; (792c <TCPIP_STACK_INTERFACE_0_init+0x34>)
	ip_addr_set_zero(&ip);
    78fe:	2300      	movs	r3, #0
	ip_addr_set_zero(&nm);
    7900:	e9cd 3305 	strd	r3, r3, [sp, #20]
	ip_addr_set_zero(&gw);
    7904:	9307      	str	r3, [sp, #28]
	memcpy(TCPIP_STACK_INTERFACE_0_hwaddr, hwaddr, 6);
    7906:	6803      	ldr	r3, [r0, #0]
    7908:	63a3      	str	r3, [r4, #56]	; 0x38
    790a:	8883      	ldrh	r3, [r0, #4]
    790c:	87a3      	strh	r3, [r4, #60]	; 0x3c

	netif_add(&TCPIP_STACK_INTERFACE_0_desc,
    790e:	4b08      	ldr	r3, [pc, #32]	; (7930 <TCPIP_STACK_INTERFACE_0_init+0x38>)
    7910:	9302      	str	r3, [sp, #8]
    7912:	4b08      	ldr	r3, [pc, #32]	; (7934 <TCPIP_STACK_INTERFACE_0_init+0x3c>)
    7914:	9301      	str	r3, [sp, #4]
    7916:	4b08      	ldr	r3, [pc, #32]	; (7938 <TCPIP_STACK_INTERFACE_0_init+0x40>)
    7918:	9300      	str	r3, [sp, #0]
    791a:	aa06      	add	r2, sp, #24
    791c:	ab07      	add	r3, sp, #28
    791e:	a905      	add	r1, sp, #20
    7920:	4620      	mov	r0, r4
    7922:	4c06      	ldr	r4, [pc, #24]	; (793c <TCPIP_STACK_INTERFACE_0_init+0x44>)
    7924:	47a0      	blx	r4
	          &nm,
	          &gw,
	          (void *)&COMMUNICATION_IO,
	          TCPIP_STACK_INTERFACE_0_stack_init,
	          ethernet_input);
}
    7926:	b008      	add	sp, #32
    7928:	bd10      	pop	{r4, pc}
    792a:	bf00      	nop
    792c:	20014960 	.word	0x20014960
    7930:	000052b9 	.word	0x000052b9
    7934:	000078b1 	.word	0x000078b1
    7938:	2000a520 	.word	0x2000a520
    793c:	0000a029 	.word	0x0000a029

00007940 <_init_chip>:
}

static inline void hri_nvmctrl_set_CTRLA_RWS_bf(const void *const hw, hri_nvmctrl_ctrla_reg_t mask)
{
	NVMCTRL_CRITICAL_SECTION_ENTER();
	((Nvmctrl *)hw)->CTRLA.reg |= NVMCTRL_CTRLA_RWS(mask);
    7940:	4a09      	ldr	r2, [pc, #36]	; (7968 <_init_chip+0x28>)
    7942:	8813      	ldrh	r3, [r2, #0]

/**
 * \brief Initialize the hardware abstraction layer
 */
void _init_chip(void)
{
    7944:	b510      	push	{r4, lr}
    7946:	b29b      	uxth	r3, r3
    7948:	8013      	strh	r3, [r2, #0]
	hri_nvmctrl_set_CTRLA_RWS_bf(NVMCTRL, CONF_NVM_WAIT_STATE);

	_osc32kctrl_init_sources();
    794a:	4b08      	ldr	r3, [pc, #32]	; (796c <_init_chip+0x2c>)
    794c:	4798      	blx	r3
	_oscctrl_init_sources();
    794e:	4b08      	ldr	r3, [pc, #32]	; (7970 <_init_chip+0x30>)
    7950:	4798      	blx	r3
	_mclk_init();
    7952:	4b08      	ldr	r3, [pc, #32]	; (7974 <_init_chip+0x34>)
    7954:	4798      	blx	r3
#if _GCLK_INIT_1ST
	_gclk_init_generators_by_fref(_GCLK_INIT_1ST);
#endif
	_oscctrl_init_referenced_generators();
    7956:	4b08      	ldr	r3, [pc, #32]	; (7978 <_init_chip+0x38>)
    7958:	4798      	blx	r3
#endif

#if CONF_CMCC_ENABLE
	cache_init();
#endif
}
    795a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	_gclk_init_generators_by_fref(_GCLK_INIT_LAST);
    795e:	4b07      	ldr	r3, [pc, #28]	; (797c <_init_chip+0x3c>)
    7960:	f640 70ff 	movw	r0, #4095	; 0xfff
    7964:	4718      	bx	r3
    7966:	bf00      	nop
    7968:	41004000 	.word	0x41004000
    796c:	000048a1 	.word	0x000048a1
    7970:	00007981 	.word	0x00007981
    7974:	00008ae1 	.word	0x00008ae1
    7978:	00007999 	.word	0x00007999
    797c:	00000f95 	.word	0x00000f95

00007980 <_oscctrl_init_sources>:
}

static inline void hri_oscctrl_write_XOSCCTRL_reg(const void *const hw, uint8_t index, hri_oscctrl_xoscctrl_reg_t data)
{
	OSCCTRL_CRITICAL_SECTION_ENTER();
	((Oscctrl *)hw)->XOSCCTRL[index].reg = data;
    7980:	4b03      	ldr	r3, [pc, #12]	; (7990 <_oscctrl_init_sources+0x10>)
    7982:	4a04      	ldr	r2, [pc, #16]	; (7994 <_oscctrl_init_sources+0x14>)
    7984:	619a      	str	r2, [r3, #24]
	return (((Oscctrl *)hw)->STATUS.reg & OSCCTRL_STATUS_XOSCRDY1) >> OSCCTRL_STATUS_XOSCRDY1_Pos;
    7986:	691a      	ldr	r2, [r3, #16]
	        | (CONF_XOSC1_XTALEN << OSCCTRL_XOSCCTRL_XTALEN_Pos) | (CONF_XOSC1_ENABLE << OSCCTRL_XOSCCTRL_ENABLE_Pos));
#endif

#if CONF_XOSC1_CONFIG == 1
#if CONF_XOSC1_ENABLE == 1
	while (!hri_oscctrl_get_STATUS_XOSCRDY1_bit(hw))
    7988:	0792      	lsls	r2, r2, #30
    798a:	d5fc      	bpl.n	7986 <_oscctrl_init_sources+0x6>
	hri_oscctrl_set_XOSCCTRL_ONDEMAND_bit(hw, 1);
#endif
#endif

	(void)hw;
}
    798c:	4770      	bx	lr
    798e:	bf00      	nop
    7990:	40001000 	.word	0x40001000
    7994:	03002606 	.word	0x03002606

00007998 <_oscctrl_init_referenced_generators>:
	hri_gclk_write_GENCTRL_SRC_bf(GCLK, 0, CONF_GCLK_GEN_0_SOURCE);
	while (hri_gclk_get_SYNCBUSY_GENCTRL0_bit(GCLK))
		;
#endif
	(void)hw;
}
    7998:	4770      	bx	lr
	...

0000799c <sys_init>:
	/* Initialize the the per-thread sys_timeouts structures
	   make sure there are no valid pids in the list */
	for (i = 0; i < SYS_THREAD_MAX; i++) {
		Threads_TimeoutsList[i].pid = 0;
	}
	NbActiveThreads = 0;
    799c:	4b01      	ldr	r3, [pc, #4]	; (79a4 <sys_init+0x8>)
    799e:	2200      	movs	r2, #0
    79a0:	801a      	strh	r2, [r3, #0]
}
    79a2:	4770      	bx	lr
    79a4:	2001499e 	.word	0x2001499e

000079a8 <sys_sem_new>:
 * \param count Initial state of the semaphore.
 *
 * \return ERR_OK for OK, other value indicates error.
 */
err_t sys_sem_new(sys_sem_t *sem, u8_t count)
{
    79a8:	b570      	push	{r4, r5, r6, lr}
    79aa:	460c      	mov	r4, r1
	err_t err_sem = ERR_MEM;

	/* Sanity check */
	if (sem != NULL) {
    79ac:	4605      	mov	r5, r0
    79ae:	b1f0      	cbz	r0, 79ee <sys_sem_new+0x46>
		portENTER_CRITICAL();
    79b0:	4b10      	ldr	r3, [pc, #64]	; (79f4 <sys_sem_new+0x4c>)
    79b2:	4798      	blx	r3

		vSemaphoreCreateBinary( *sem );
    79b4:	4b10      	ldr	r3, [pc, #64]	; (79f8 <sys_sem_new+0x50>)
    79b6:	2203      	movs	r2, #3
    79b8:	2100      	movs	r1, #0
    79ba:	2001      	movs	r0, #1
    79bc:	4798      	blx	r3
    79be:	6028      	str	r0, [r5, #0]
    79c0:	b120      	cbz	r0, 79cc <sys_sem_new+0x24>
    79c2:	2300      	movs	r3, #0
    79c4:	4e0d      	ldr	r6, [pc, #52]	; (79fc <sys_sem_new+0x54>)
    79c6:	461a      	mov	r2, r3
    79c8:	4619      	mov	r1, r3
    79ca:	47b0      	blx	r6
		if (*sem != SYS_SEM_NULL) {
    79cc:	6828      	ldr	r0, [r5, #0]
    79ce:	b148      	cbz	r0, 79e4 <sys_sem_new+0x3c>
				lwip_stats.sys.sem.max = lwip_stats.sys.sem.used;
			}

  #endif /* SYS_STATS */

			if (0 == count) { /* Means we want the sem to be
    79d0:	b95c      	cbnz	r4, 79ea <sys_sem_new+0x42>
			                     unavailable at init state. */
				xSemaphoreTake( *sem, 1);
    79d2:	4d0b      	ldr	r5, [pc, #44]	; (7a00 <sys_sem_new+0x58>)
    79d4:	4623      	mov	r3, r4
    79d6:	2201      	movs	r2, #1
    79d8:	4621      	mov	r1, r4
    79da:	47a8      	blx	r5
			}

			err_sem = ERR_OK;
		}

		portEXIT_CRITICAL();
    79dc:	4b09      	ldr	r3, [pc, #36]	; (7a04 <sys_sem_new+0x5c>)
    79de:	4798      	blx	r3
	}

	return err_sem;
}
    79e0:	4620      	mov	r0, r4
    79e2:	bd70      	pop	{r4, r5, r6, pc}
	err_t err_sem = ERR_MEM;
    79e4:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
    79e8:	e7f8      	b.n	79dc <sys_sem_new+0x34>
			err_sem = ERR_OK;
    79ea:	2400      	movs	r4, #0
    79ec:	e7f6      	b.n	79dc <sys_sem_new+0x34>
	err_t err_sem = ERR_MEM;
    79ee:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
    79f2:	e7f5      	b.n	79e0 <sys_sem_new+0x38>
    79f4:	00009d55 	.word	0x00009d55
    79f8:	0000054d 	.word	0x0000054d
    79fc:	00000611 	.word	0x00000611
    7a00:	00000951 	.word	0x00000951
    7a04:	00009d95 	.word	0x00009d95

00007a08 <sys_sem_free>:
 * \param sem Pointer to the semaphore.
 */
void sys_sem_free(sys_sem_t *sem)
{
	/* Sanity check */
	if (sem != NULL) {
    7a08:	b118      	cbz	r0, 7a12 <sys_sem_free+0xa>
		if (SYS_SEM_NULL != *sem) {
    7a0a:	6800      	ldr	r0, [r0, #0]
    7a0c:	b108      	cbz	r0, 7a12 <sys_sem_free+0xa>
  #if SYS_STATS 
			lwip_stats.sys.sem.used--;
  #endif /* SYS_STATS */
			vQueueDelete( *sem );
    7a0e:	4b01      	ldr	r3, [pc, #4]	; (7a14 <sys_sem_free+0xc>)
    7a10:	4718      	bx	r3
		}
	}
}
    7a12:	4770      	bx	lr
    7a14:	00000ae5 	.word	0x00000ae5

00007a18 <sys_sem_signal>:
 * \brief Signals (or releases) a semaphore.
 *
 * \param sem Pointer to the semaphore.
 */
void sys_sem_signal(sys_sem_t *sem)
{
    7a18:	b410      	push	{r4}
	/* Sanity check */
	if (sem != NULL) {
    7a1a:	b140      	cbz	r0, 7a2e <sys_sem_signal+0x16>
		xSemaphoreGive( *sem );
    7a1c:	4c05      	ldr	r4, [pc, #20]	; (7a34 <sys_sem_signal+0x1c>)
    7a1e:	6800      	ldr	r0, [r0, #0]
    7a20:	2300      	movs	r3, #0
    7a22:	46a4      	mov	ip, r4
    7a24:	461a      	mov	r2, r3
	}
}
    7a26:	f85d 4b04 	ldr.w	r4, [sp], #4
		xSemaphoreGive( *sem );
    7a2a:	4619      	mov	r1, r3
    7a2c:	4760      	bx	ip
}
    7a2e:	f85d 4b04 	ldr.w	r4, [sp], #4
    7a32:	4770      	bx	lr
    7a34:	00000611 	.word	0x00000611

00007a38 <sys_arch_sem_wait>:
 *
 * \return SYS_ARCH_TIMEOUT if times out, ERR_MEM for semaphore erro otherwise
 * return the milliseconds expired while waiting for the semaphore.
 */
u32_t sys_arch_sem_wait(sys_sem_t *sem, u32_t timeout)
{
    7a38:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    7a3c:	460e      	mov	r6, r1
	portTickType TickStop;
	/* Express the timeout in OS tick. */
	portTickType TickElapsed = (portTickType)(timeout / portTICK_RATE_MS);

	/* Sanity check */
	if (sem != NULL) {
    7a3e:	4605      	mov	r5, r0
    7a40:	b918      	cbnz	r0, 7a4a <sys_arch_sem_wait+0x12>
			TickElapsed = portMAX_DELAY - TickStart + TickStop;
		}

		return(TickElapsed * portTICK_RATE_MS);
	} else {
		return ERR_MEM;
    7a42:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
	}
}
    7a46:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		if (0 == TickElapsed) {
    7a4a:	4f0f      	ldr	r7, [pc, #60]	; (7a88 <sys_arch_sem_wait+0x50>)
    7a4c:	f8df 803c 	ldr.w	r8, [pc, #60]	; 7a8c <sys_arch_sem_wait+0x54>
    7a50:	b981      	cbnz	r1, 7a74 <sys_arch_sem_wait+0x3c>
			TickStart = xTaskGetTickCount();
    7a52:	47b8      	blx	r7
    7a54:	4604      	mov	r4, r0
			while (pdFALSE == xSemaphoreTake( *sem,	SYS_ARCH_BLOCKING_TICKTIMEOUT )) {
    7a56:	2300      	movs	r3, #0
    7a58:	6828      	ldr	r0, [r5, #0]
    7a5a:	f242 7210 	movw	r2, #10000	; 0x2710
    7a5e:	4619      	mov	r1, r3
    7a60:	47c0      	blx	r8
    7a62:	2800      	cmp	r0, #0
    7a64:	d0f7      	beq.n	7a56 <sys_arch_sem_wait+0x1e>
		TickStop = xTaskGetTickCount();
    7a66:	47b8      	blx	r7
		if (TickStop >= TickStart) {
    7a68:	4284      	cmp	r4, r0
			TickElapsed = portMAX_DELAY - TickStart + TickStop;
    7a6a:	bf88      	it	hi
    7a6c:	f100 30ff 	addhi.w	r0, r0, #4294967295	; 0xffffffff
    7a70:	1b00      	subs	r0, r0, r4
    7a72:	e7e8      	b.n	7a46 <sys_arch_sem_wait+0xe>
			TickStart = xTaskGetTickCount();
    7a74:	47b8      	blx	r7
			if (pdFALSE == xSemaphoreTake( *sem, TickElapsed )) {
    7a76:	2300      	movs	r3, #0
			TickStart = xTaskGetTickCount();
    7a78:	4604      	mov	r4, r0
			if (pdFALSE == xSemaphoreTake( *sem, TickElapsed )) {
    7a7a:	4632      	mov	r2, r6
    7a7c:	6828      	ldr	r0, [r5, #0]
    7a7e:	4619      	mov	r1, r3
    7a80:	47c0      	blx	r8
    7a82:	2800      	cmp	r0, #0
    7a84:	d1ef      	bne.n	7a66 <sys_arch_sem_wait+0x2e>
    7a86:	e7dc      	b.n	7a42 <sys_arch_sem_wait+0xa>
    7a88:	00008d99 	.word	0x00008d99
    7a8c:	00000951 	.word	0x00000951

00007a90 <sys_sem_valid>:
 * \return Semaphore number on valid, 0 for invalid.
 */
int sys_sem_valid(sys_sem_t *sem)
{
	return ((int)(*sem));
}
    7a90:	6800      	ldr	r0, [r0, #0]
    7a92:	4770      	bx	lr

00007a94 <sys_sem_set_invalid>:
 *
 * \param sem Pointer to the semaphore.
 */
void sys_sem_set_invalid(sys_sem_t *sem)
{
	*sem = NULL;
    7a94:	2300      	movs	r3, #0
    7a96:	6003      	str	r3, [r0, #0]
}
    7a98:	4770      	bx	lr
	...

00007a9c <sys_mbox_new>:
 * \param size Maximum "size" elements.
 *
 * \return ERR_OK if successfull or ERR_MEM on error.
 */
err_t sys_mbox_new(sys_mbox_t *mBoxNew, int size )
{
    7a9c:	b510      	push	{r4, lr}
    7a9e:	4604      	mov	r4, r0
    7aa0:	4608      	mov	r0, r1
	err_t err_mbox = ERR_MEM;

	/* Sanity check */
	if (mBoxNew != NULL) {
    7aa2:	b134      	cbz	r4, 7ab2 <sys_mbox_new+0x16>
		*mBoxNew = xQueueCreate( size, sizeof(void *));
    7aa4:	4b04      	ldr	r3, [pc, #16]	; (7ab8 <sys_mbox_new+0x1c>)
    7aa6:	2200      	movs	r2, #0
    7aa8:	2104      	movs	r1, #4
    7aaa:	4798      	blx	r3
    7aac:	6020      	str	r0, [r4, #0]
				lwip_stats.sys.mbox.max	= lwip_stats.sys.mbox.used;
			}
		}

  #endif /* SYS_STATS */
		err_mbox = ERR_OK;
    7aae:	2000      	movs	r0, #0
	}

	return(err_mbox);
}
    7ab0:	bd10      	pop	{r4, pc}
	err_t err_mbox = ERR_MEM;
    7ab2:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    7ab6:	e7fb      	b.n	7ab0 <sys_mbox_new+0x14>
    7ab8:	0000054d 	.word	0x0000054d

00007abc <sys_mbox_free>:
    7abc:	4b00      	ldr	r3, [pc, #0]	; (7ac0 <sys_mbox_free+0x4>)
    7abe:	4718      	bx	r3
    7ac0:	00007a09 	.word	0x00007a09

00007ac4 <sys_mbox_post>:
 *
 * \param mbox Pointer to the mailbox.
 * \param msg Pointer to the message to be post.
 */
void sys_mbox_post(sys_mbox_t *mbox, void *msg)
{
    7ac4:	b537      	push	{r0, r1, r2, r4, r5, lr}
	/* Sanit check */
	if (mbox != NULL) {
    7ac6:	4604      	mov	r4, r0
{
    7ac8:	9101      	str	r1, [sp, #4]
	if (mbox != NULL) {
    7aca:	b140      	cbz	r0, 7ade <sys_mbox_post+0x1a>
		while (pdTRUE != xQueueSend( *mbox, &msg, SYS_ARCH_BLOCKING_TICKTIMEOUT )) {
    7acc:	4d05      	ldr	r5, [pc, #20]	; (7ae4 <sys_mbox_post+0x20>)
    7ace:	6820      	ldr	r0, [r4, #0]
    7ad0:	2300      	movs	r3, #0
    7ad2:	f242 7210 	movw	r2, #10000	; 0x2710
    7ad6:	a901      	add	r1, sp, #4
    7ad8:	47a8      	blx	r5
    7ada:	2801      	cmp	r0, #1
    7adc:	d1f7      	bne.n	7ace <sys_mbox_post+0xa>
		}
	}
}
    7ade:	b003      	add	sp, #12
    7ae0:	bd30      	pop	{r4, r5, pc}
    7ae2:	bf00      	nop
    7ae4:	00000611 	.word	0x00000611

00007ae8 <sys_mbox_trypost>:
 * \param msg Pointer to the message to be post.
 *
 * \return ERR_MEM if the mailbox is full otherwise ERR_OK if the "msg" is posted.
 */
err_t sys_mbox_trypost(sys_mbox_t *mbox, void *msg)
{
    7ae8:	b51f      	push	{r0, r1, r2, r3, r4, lr}
    7aea:	9101      	str	r1, [sp, #4]
	err_t err_mbox = ERR_MEM;

	/* Sanity check */
	if (mbox != NULL) {
    7aec:	b330      	cbz	r0, 7b3c <sys_mbox_trypost+0x54>
		if (SCB->ICSR & SCB_ICSR_VECTACTIVE_Msk) {
    7aee:	4b15      	ldr	r3, [pc, #84]	; (7b44 <sys_mbox_trypost+0x5c>)
			portBASE_TYPE task_woken = 0;
			if (errQUEUE_FULL != xQueueSendFromISR( *mbox, &msg, &task_woken )) {
    7af0:	6800      	ldr	r0, [r0, #0]
		if (SCB->ICSR & SCB_ICSR_VECTACTIVE_Msk) {
    7af2:	685b      	ldr	r3, [r3, #4]
    7af4:	f3c3 0308 	ubfx	r3, r3, #0, #9
    7af8:	b1bb      	cbz	r3, 7b2a <sys_mbox_trypost+0x42>
			portBASE_TYPE task_woken = 0;
    7afa:	2300      	movs	r3, #0
			if (errQUEUE_FULL != xQueueSendFromISR( *mbox, &msg, &task_woken )) {
    7afc:	4c12      	ldr	r4, [pc, #72]	; (7b48 <sys_mbox_trypost+0x60>)
			portBASE_TYPE task_woken = 0;
    7afe:	9303      	str	r3, [sp, #12]
			if (errQUEUE_FULL != xQueueSendFromISR( *mbox, &msg, &task_woken )) {
    7b00:	aa03      	add	r2, sp, #12
    7b02:	a901      	add	r1, sp, #4
    7b04:	47a0      	blx	r4
				err_mbox = ERR_OK;
			}
			portEND_SWITCHING_ISR(task_woken);
    7b06:	9b03      	ldr	r3, [sp, #12]
			if (errQUEUE_FULL != xQueueSendFromISR( *mbox, &msg, &task_woken )) {
    7b08:	fab0 f080 	clz	r0, r0
    7b0c:	0940      	lsrs	r0, r0, #5
    7b0e:	4240      	negs	r0, r0
			portEND_SWITCHING_ISR(task_woken);
    7b10:	b14b      	cbz	r3, 7b26 <sys_mbox_trypost+0x3e>
    7b12:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
    7b16:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
    7b1a:	f8c3 2d04 	str.w	r2, [r3, #3332]	; 0xd04
    7b1e:	f3bf 8f4f 	dsb	sy
    7b22:	f3bf 8f6f 	isb	sy
				err_mbox = ERR_OK;
			}
		}
	}
	return (err_mbox);
}
    7b26:	b004      	add	sp, #16
    7b28:	bd10      	pop	{r4, pc}
			if (errQUEUE_FULL != xQueueSend( *mbox, &msg, 0 )) {
    7b2a:	4c08      	ldr	r4, [pc, #32]	; (7b4c <sys_mbox_trypost+0x64>)
    7b2c:	461a      	mov	r2, r3
    7b2e:	a901      	add	r1, sp, #4
    7b30:	47a0      	blx	r4
    7b32:	fab0 f080 	clz	r0, r0
    7b36:	0940      	lsrs	r0, r0, #5
    7b38:	4240      	negs	r0, r0
    7b3a:	e7f4      	b.n	7b26 <sys_mbox_trypost+0x3e>
	err_t err_mbox = ERR_MEM;
    7b3c:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    7b40:	e7f1      	b.n	7b26 <sys_mbox_trypost+0x3e>
    7b42:	bf00      	nop
    7b44:	e000ed00 	.word	0xe000ed00
    7b48:	000007b1 	.word	0x000007b1
    7b4c:	00000611 	.word	0x00000611

00007b50 <sys_arch_mbox_fetch>:
 *
 * \return Number of milliseconds spent waiting or SYS_ARCH_TIMEOUT if there was
 * a timeout. Or ERR_MEM if invalid pointer to message box.
 */
u32_t sys_arch_mbox_fetch(sys_mbox_t *mbox, void **msg, u32_t timeout)
{
    7b50:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
    7b54:	460d      	mov	r5, r1
    7b56:	4617      	mov	r7, r2
	void *tempoptr;
	/* Express the timeout in OS tick. */
	portTickType TickElapsed = (portTickType)(timeout / portTICK_RATE_MS);

	/* Sanity check */
	if (mbox != NULL) {
    7b58:	4606      	mov	r6, r0
    7b5a:	b318      	cbz	r0, 7ba4 <sys_arch_mbox_fetch+0x54>
		if (timeout && !TickElapsed) {
			TickElapsed = 1; /* Wait at least one tick */
		}

		if (msg == NULL) {
    7b5c:	b901      	cbnz	r1, 7b60 <sys_arch_mbox_fetch+0x10>
			msg = &tempoptr;
    7b5e:	ad01      	add	r5, sp, #4
		}

		/* NOTE: INCLUDE_xTaskGetSchedulerState must be set to 1 in
		 * FreeRTOSConfig.h for xTaskGetTickCount() to be available */
		if (0 == TickElapsed) {
    7b60:	f8df 8048 	ldr.w	r8, [pc, #72]	; 7bac <sys_arch_mbox_fetch+0x5c>
    7b64:	f8df 9048 	ldr.w	r9, [pc, #72]	; 7bb0 <sys_arch_mbox_fetch+0x60>
    7b68:	b997      	cbnz	r7, 7b90 <sys_arch_mbox_fetch+0x40>
			TickStart = xTaskGetTickCount();
    7b6a:	47c0      	blx	r8
    7b6c:	4604      	mov	r4, r0
			/* If "timeout" is 0, the thread should be blocked until
			 * a message arrives */
			while (pdFALSE == xQueueReceive( *mbox, &(*msg),
    7b6e:	6830      	ldr	r0, [r6, #0]
    7b70:	2300      	movs	r3, #0
    7b72:	f242 7210 	movw	r2, #10000	; 0x2710
    7b76:	4629      	mov	r1, r5
    7b78:	47c8      	blx	r9
    7b7a:	2800      	cmp	r0, #0
    7b7c:	d0f7      	beq.n	7b6e <sys_arch_mbox_fetch+0x1e>
			}
		}

		/* If the function gets a msg, it should return the number of ms
		 * spent waiting. */
		TickStop = xTaskGetTickCount();
    7b7e:	47c0      	blx	r8
		/* Take care of wrap-around. */
		if (TickStop >= TickStart) {
    7b80:	4284      	cmp	r4, r0
			TickElapsed = TickStop - TickStart;
		} else {
			TickElapsed = portMAX_DELAY - TickStart + TickStop;
    7b82:	bf88      	it	hi
    7b84:	f100 30ff 	addhi.w	r0, r0, #4294967295	; 0xffffffff
    7b88:	1b00      	subs	r0, r0, r4

		return(TickElapsed * portTICK_RATE_MS);
	} else {
		return ERR_MEM;
	}
}
    7b8a:	b003      	add	sp, #12
    7b8c:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
			TickStart = xTaskGetTickCount();
    7b90:	47c0      	blx	r8
			if (pdFALSE == xQueueReceive( *mbox, &(*msg), TickElapsed )) {
    7b92:	2300      	movs	r3, #0
			TickStart = xTaskGetTickCount();
    7b94:	4604      	mov	r4, r0
			if (pdFALSE == xQueueReceive( *mbox, &(*msg), TickElapsed )) {
    7b96:	463a      	mov	r2, r7
    7b98:	6830      	ldr	r0, [r6, #0]
    7b9a:	4629      	mov	r1, r5
    7b9c:	47c8      	blx	r9
    7b9e:	2800      	cmp	r0, #0
    7ba0:	d1ed      	bne.n	7b7e <sys_arch_mbox_fetch+0x2e>
				*msg = NULL;
    7ba2:	6028      	str	r0, [r5, #0]
		return ERR_MEM;
    7ba4:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    7ba8:	e7ef      	b.n	7b8a <sys_arch_mbox_fetch+0x3a>
    7baa:	bf00      	nop
    7bac:	00008d99 	.word	0x00008d99
    7bb0:	00000951 	.word	0x00000951

00007bb4 <sys_arch_mbox_tryfetch>:
 *
 * \return Number of milliseconds spent waiting or SYS_ARCH_TIMEOUT if there was
 * a timeout. Or ERR_MEM if invalid pointer to message box.
 */
u32_t sys_arch_mbox_tryfetch(sys_mbox_t *mbox, void **msg)
{
    7bb4:	b513      	push	{r0, r1, r4, lr}
	void *tempoptr;

	/* Sanity check */
	if (mbox != NULL) {
    7bb6:	b160      	cbz	r0, 7bd2 <sys_arch_mbox_tryfetch+0x1e>
		if (msg == NULL) {
    7bb8:	b901      	cbnz	r1, 7bbc <sys_arch_mbox_tryfetch+0x8>
			msg = &tempoptr;
    7bba:	a901      	add	r1, sp, #4
		}

		if (pdFALSE == xQueueReceive( *mbox, &(*msg), 0 )) {
    7bbc:	2300      	movs	r3, #0
    7bbe:	6800      	ldr	r0, [r0, #0]
    7bc0:	4c05      	ldr	r4, [pc, #20]	; (7bd8 <sys_arch_mbox_tryfetch+0x24>)
    7bc2:	461a      	mov	r2, r3
    7bc4:	47a0      	blx	r4
    7bc6:	fab0 f080 	clz	r0, r0
    7bca:	0940      	lsrs	r0, r0, #5
    7bcc:	4240      	negs	r0, r0
		/* On success 0 is returned. */
		return(0);
	} else {
		return(SYS_MBOX_EMPTY);
	}
}
    7bce:	b002      	add	sp, #8
    7bd0:	bd10      	pop	{r4, pc}
		return(SYS_MBOX_EMPTY);
    7bd2:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    7bd6:	e7fa      	b.n	7bce <sys_arch_mbox_tryfetch+0x1a>
    7bd8:	00000951 	.word	0x00000951

00007bdc <sys_mbox_valid>:
    7bdc:	6800      	ldr	r0, [r0, #0]
    7bde:	4770      	bx	lr

00007be0 <sys_mbox_set_invalid>:
    7be0:	2300      	movs	r3, #0
    7be2:	6003      	str	r3, [r0, #0]
    7be4:	4770      	bx	lr
	...

00007be8 <sys_thread_new>:
 *
 * \return The id of the new thread.
 */
sys_thread_t sys_thread_new(const char *name, lwip_thread_fn thread, void *arg,
		int stacksize, int prio)
{
    7be8:	b530      	push	{r4, r5, lr}
    7bea:	b087      	sub	sp, #28
    7bec:	4605      	mov	r5, r0
    7bee:	4608      	mov	r0, r1
    7bf0:	4619      	mov	r1, r3
	sys_thread_t newthread;
	portBASE_TYPE result;
	SYS_ARCH_DECL_PROTECT(protectionLevel);

	result = xTaskCreate( thread, (signed portCHAR *)name, stacksize, arg,
    7bf2:	ab05      	add	r3, sp, #20
    7bf4:	2400      	movs	r4, #0
    7bf6:	9301      	str	r3, [sp, #4]
    7bf8:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    7bfa:	9300      	str	r3, [sp, #0]
    7bfc:	e9cd 4402 	strd	r4, r4, [sp, #8]
    7c00:	4613      	mov	r3, r2
    7c02:	b28a      	uxth	r2, r1
    7c04:	4629      	mov	r1, r5
    7c06:	4d06      	ldr	r5, [pc, #24]	; (7c20 <sys_thread_new+0x38>)
    7c08:	47a8      	blx	r5
			prio, &newthread );

	/* Need to protect this -- preemption here could be a problem! */
	SYS_ARCH_PROTECT(protectionLevel);
	if (pdPASS == result) {
    7c0a:	2801      	cmp	r0, #1
		Threads_TimeoutsList[NbActiveThreads++].pid = newthread;
    7c0c:	bf0a      	itet	eq
    7c0e:	4a05      	ldreq	r2, [pc, #20]	; (7c24 <sys_thread_new+0x3c>)
	} else {
		newthread = NULL;
    7c10:	9405      	strne	r4, [sp, #20]
		Threads_TimeoutsList[NbActiveThreads++].pid = newthread;
    7c12:	8813      	ldrheq	r3, [r2, #0]
	}

	SYS_ARCH_UNPROTECT(protectionLevel);

	return(newthread);
}
    7c14:	9805      	ldr	r0, [sp, #20]
		Threads_TimeoutsList[NbActiveThreads++].pid = newthread;
    7c16:	bf04      	itt	eq
    7c18:	3301      	addeq	r3, #1
    7c1a:	8013      	strheq	r3, [r2, #0]
}
    7c1c:	b007      	add	sp, #28
    7c1e:	bd30      	pop	{r4, r5, pc}
    7c20:	00008b45 	.word	0x00008b45
    7c24:	2001499e 	.word	0x2001499e

00007c28 <hri_sercomusart_wait_for_sync>:
	return ((Sercom *)hw)->SPI.SYNCBUSY.reg & reg;
}

static inline void hri_sercomusart_wait_for_sync(const void *const hw, hri_sercomusart_syncbusy_reg_t reg)
{
	while (((Sercom *)hw)->USART.SYNCBUSY.reg & reg) {
    7c28:	69c3      	ldr	r3, [r0, #28]
    7c2a:	420b      	tst	r3, r1
    7c2c:	d1fc      	bne.n	7c28 <hri_sercomusart_wait_for_sync>
	};
}
    7c2e:	4770      	bx	lr

00007c30 <hri_sercomusart_clear_CTRLA_ENABLE_bit>:
}

static inline void hri_sercomusart_clear_CTRLA_ENABLE_bit(const void *const hw)
{
	SERCOM_CRITICAL_SECTION_ENTER();
	((Sercom *)hw)->USART.CTRLA.reg &= ~SERCOM_USART_CTRLA_ENABLE;
    7c30:	6802      	ldr	r2, [r0, #0]
	hri_sercomusart_wait_for_sync(hw, SERCOM_USART_SYNCBUSY_SWRST | SERCOM_USART_SYNCBUSY_ENABLE);
    7c32:	4b03      	ldr	r3, [pc, #12]	; (7c40 <hri_sercomusart_clear_CTRLA_ENABLE_bit+0x10>)
	((Sercom *)hw)->USART.CTRLA.reg &= ~SERCOM_USART_CTRLA_ENABLE;
    7c34:	f022 0202 	bic.w	r2, r2, #2
    7c38:	6002      	str	r2, [r0, #0]
	hri_sercomusart_wait_for_sync(hw, SERCOM_USART_SYNCBUSY_SWRST | SERCOM_USART_SYNCBUSY_ENABLE);
    7c3a:	2103      	movs	r1, #3
    7c3c:	4718      	bx	r3
    7c3e:	bf00      	nop
    7c40:	00007c29 	.word	0x00007c29

00007c44 <_sercom_get_hardware_index>:

/**
 * \brief Retrieve ordinal number of the given sercom hardware instance
 */
static uint8_t _sercom_get_hardware_index(const void *const hw)
{
    7c44:	b570      	push	{r4, r5, r6, lr}
	Sercom *const sercom_modules[] = SERCOM_INSTS;
    7c46:	4d0c      	ldr	r5, [pc, #48]	; (7c78 <_sercom_get_hardware_index+0x34>)
{
    7c48:	4606      	mov	r6, r0
	Sercom *const sercom_modules[] = SERCOM_INSTS;
    7c4a:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
{
    7c4c:	b088      	sub	sp, #32
	Sercom *const sercom_modules[] = SERCOM_INSTS;
    7c4e:	466c      	mov	r4, sp
    7c50:	c40f      	stmia	r4!, {r0, r1, r2, r3}
    7c52:	e895 000f 	ldmia.w	r5, {r0, r1, r2, r3}
    7c56:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
	/* Find index for SERCOM instance. */
	for (uint32_t i = 0; i < SERCOM_INST_NUM; i++) {
    7c5a:	466a      	mov	r2, sp
    7c5c:	2300      	movs	r3, #0
		if ((uint32_t)hw == (uint32_t)sercom_modules[i]) {
    7c5e:	f852 1b04 	ldr.w	r1, [r2], #4
    7c62:	42b1      	cmp	r1, r6
    7c64:	d102      	bne.n	7c6c <_sercom_get_hardware_index+0x28>
			return i;
    7c66:	b2d8      	uxtb	r0, r3
		}
	}
	return 0;
}
    7c68:	b008      	add	sp, #32
    7c6a:	bd70      	pop	{r4, r5, r6, pc}
	for (uint32_t i = 0; i < SERCOM_INST_NUM; i++) {
    7c6c:	3301      	adds	r3, #1
    7c6e:	2b08      	cmp	r3, #8
    7c70:	d1f5      	bne.n	7c5e <_sercom_get_hardware_index+0x1a>
	return 0;
    7c72:	2000      	movs	r0, #0
    7c74:	e7f8      	b.n	7c68 <_sercom_get_hardware_index+0x24>
    7c76:	bf00      	nop
    7c78:	0000b7d0 	.word	0x0000b7d0

00007c7c <_usart_init>:
 * \param[in] hw The pointer to hardware instance
 *
 * \return The status of initialization
 */
static int32_t _usart_init(void *const hw)
{
    7c7c:	b538      	push	{r3, r4, r5, lr}
	uint8_t sercom_offset = _sercom_get_hardware_index(hw);
    7c7e:	4b1b      	ldr	r3, [pc, #108]	; (7cec <_usart_init+0x70>)
{
    7c80:	4604      	mov	r4, r0
	uint8_t sercom_offset = _sercom_get_hardware_index(hw);
    7c82:	4798      	blx	r3
		if (_usarts[i].number == sercom_offset) {
    7c84:	2802      	cmp	r0, #2
    7c86:	d005      	beq.n	7c94 <_usart_init+0x18>
	ASSERT(false);
    7c88:	4919      	ldr	r1, [pc, #100]	; (7cf0 <_usart_init+0x74>)
    7c8a:	4b1a      	ldr	r3, [pc, #104]	; (7cf4 <_usart_init+0x78>)
    7c8c:	f240 2247 	movw	r2, #583	; 0x247
    7c90:	2000      	movs	r0, #0
    7c92:	4798      	blx	r3
	return ((Sercom *)hw)->USART.SYNCBUSY.reg & reg;
    7c94:	69e3      	ldr	r3, [r4, #28]
    7c96:	4d18      	ldr	r5, [pc, #96]	; (7cf8 <_usart_init+0x7c>)
	uint8_t i = _get_sercom_index(hw);

	if (!hri_sercomusart_is_syncing(hw, SERCOM_USART_SYNCBUSY_SWRST)) {
    7c98:	f013 0f01 	tst.w	r3, #1
    7c9c:	d10e      	bne.n	7cbc <_usart_init+0x40>

static inline hri_sercomusart_ctrla_reg_t hri_sercomusart_get_CTRLA_reg(const void *const           hw,
                                                                        hri_sercomusart_ctrla_reg_t mask)
{
	uint32_t tmp;
	hri_sercomusart_wait_for_sync(hw, SERCOM_USART_SYNCBUSY_SWRST | SERCOM_USART_SYNCBUSY_ENABLE);
    7c9e:	2103      	movs	r1, #3
    7ca0:	4620      	mov	r0, r4
    7ca2:	47a8      	blx	r5
	tmp = ((Sercom *)hw)->USART.CTRLA.reg;
    7ca4:	6823      	ldr	r3, [r4, #0]
		uint32_t mode = _usarts[i].ctrl_a & SERCOM_USART_CTRLA_MODE_Msk;
		if (hri_sercomusart_get_CTRLA_reg(hw, SERCOM_USART_CTRLA_ENABLE)) {
    7ca6:	079b      	lsls	r3, r3, #30
    7ca8:	d503      	bpl.n	7cb2 <_usart_init+0x36>
			hri_sercomusart_clear_CTRLA_ENABLE_bit(hw);
    7caa:	4b14      	ldr	r3, [pc, #80]	; (7cfc <_usart_init+0x80>)
    7cac:	4798      	blx	r3
			hri_sercomusart_wait_for_sync(hw, SERCOM_USART_SYNCBUSY_ENABLE);
    7cae:	2102      	movs	r1, #2
    7cb0:	47a8      	blx	r5
}

static inline void hri_sercomusart_write_CTRLA_reg(const void *const hw, hri_sercomusart_ctrla_reg_t data)
{
	SERCOM_CRITICAL_SECTION_ENTER();
	((Sercom *)hw)->USART.CTRLA.reg = data;
    7cb2:	2305      	movs	r3, #5
    7cb4:	6023      	str	r3, [r4, #0]
	hri_sercomusart_wait_for_sync(hw, SERCOM_USART_SYNCBUSY_SWRST | SERCOM_USART_SYNCBUSY_ENABLE);
    7cb6:	2103      	movs	r1, #3
    7cb8:	4620      	mov	r0, r4
    7cba:	47a8      	blx	r5
		}
		hri_sercomusart_write_CTRLA_reg(hw, SERCOM_USART_CTRLA_SWRST | mode);
	}
	hri_sercomusart_wait_for_sync(hw, SERCOM_USART_SYNCBUSY_SWRST);
    7cbc:	4620      	mov	r0, r4
    7cbe:	2101      	movs	r1, #1
    7cc0:	47a8      	blx	r5
	((Sercom *)hw)->USART.CTRLA.reg = data;
    7cc2:	4b0f      	ldr	r3, [pc, #60]	; (7d00 <_usart_init+0x84>)
    7cc4:	6023      	str	r3, [r4, #0]
	hri_sercomusart_wait_for_sync(hw, SERCOM_USART_SYNCBUSY_SWRST | SERCOM_USART_SYNCBUSY_ENABLE);
    7cc6:	2103      	movs	r1, #3
    7cc8:	47a8      	blx	r5
}

static inline void hri_sercomusart_write_CTRLB_reg(const void *const hw, hri_sercomusart_ctrlb_reg_t data)
{
	SERCOM_CRITICAL_SECTION_ENTER();
	((Sercom *)hw)->USART.CTRLB.reg = data;
    7cca:	f44f 3340 	mov.w	r3, #196608	; 0x30000
    7cce:	6063      	str	r3, [r4, #4]
	hri_sercomusart_wait_for_sync(hw, SERCOM_USART_SYNCBUSY_MASK);
    7cd0:	211f      	movs	r1, #31
    7cd2:	47a8      	blx	r5
}

static inline void hri_sercomusart_write_CTRLC_reg(const void *const hw, hri_sercomusart_ctrlc_reg_t data)
{
	SERCOM_CRITICAL_SECTION_ENTER();
	((Sercom *)hw)->USART.CTRLC.reg = data;
    7cd4:	4b0b      	ldr	r3, [pc, #44]	; (7d04 <_usart_init+0x88>)
    7cd6:	60a3      	str	r3, [r4, #8]
}

static inline void hri_sercomusart_write_BAUD_reg(const void *const hw, hri_sercomusart_baud_reg_t data)
{
	SERCOM_CRITICAL_SECTION_ENTER();
	((Sercom *)hw)->USART.BAUD.reg = data;
    7cd8:	f64f 43b9 	movw	r3, #64697	; 0xfcb9
    7cdc:	81a3      	strh	r3, [r4, #12]
}

static inline void hri_sercomusart_write_RXPL_reg(const void *const hw, hri_sercomusart_rxpl_reg_t data)
{
	SERCOM_CRITICAL_SECTION_ENTER();
	((Sercom *)hw)->USART.RXPL.reg = data;
    7cde:	2300      	movs	r3, #0
    7ce0:	73a3      	strb	r3, [r4, #14]

	hri_sercomusart_write_RXPL_reg(hw, _usarts[i].rxpl);
	hri_sercomusart_write_DBGCTRL_reg(hw, _usarts[i].debug_ctrl);

	return ERR_NONE;
}
    7ce2:	4618      	mov	r0, r3
}

static inline void hri_sercomusart_write_DBGCTRL_reg(const void *const hw, hri_sercomusart_dbgctrl_reg_t data)
{
	SERCOM_CRITICAL_SECTION_ENTER();
	((Sercom *)hw)->USART.DBGCTRL.reg = data;
    7ce4:	f884 3030 	strb.w	r3, [r4, #48]	; 0x30
    7ce8:	bd38      	pop	{r3, r4, r5, pc}
    7cea:	bf00      	nop
    7cec:	00007c45 	.word	0x00007c45
    7cf0:	0000b7b4 	.word	0x0000b7b4
    7cf4:	00008a15 	.word	0x00008a15
    7cf8:	00007c29 	.word	0x00007c29
    7cfc:	00007c31 	.word	0x00007c31
    7d00:	40100004 	.word	0x40100004
    7d04:	00700002 	.word	0x00700002

00007d08 <_usart_sync_init>:
{
    7d08:	b570      	push	{r4, r5, r6, lr}
	ASSERT(device);
    7d0a:	4605      	mov	r5, r0
    7d0c:	3800      	subs	r0, #0
{
    7d0e:	460c      	mov	r4, r1
	ASSERT(device);
    7d10:	4b05      	ldr	r3, [pc, #20]	; (7d28 <_usart_sync_init+0x20>)
    7d12:	4906      	ldr	r1, [pc, #24]	; (7d2c <_usart_sync_init+0x24>)
    7d14:	bf18      	it	ne
    7d16:	2001      	movne	r0, #1
    7d18:	22bb      	movs	r2, #187	; 0xbb
    7d1a:	4798      	blx	r3
	device->hw = hw;
    7d1c:	602c      	str	r4, [r5, #0]
	return _usart_init(hw);
    7d1e:	4620      	mov	r0, r4
    7d20:	4b03      	ldr	r3, [pc, #12]	; (7d30 <_usart_sync_init+0x28>)
}
    7d22:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	return _usart_init(hw);
    7d26:	4718      	bx	r3
    7d28:	00008a15 	.word	0x00008a15
    7d2c:	0000b7b4 	.word	0x0000b7b4
    7d30:	00007c7d 	.word	0x00007c7d

00007d34 <_usart_sync_enable>:
	hri_sercomusart_set_CTRLA_ENABLE_bit(device->hw);
    7d34:	6800      	ldr	r0, [r0, #0]
	((Sercom *)hw)->USART.CTRLA.reg |= SERCOM_USART_CTRLA_ENABLE;
    7d36:	6803      	ldr	r3, [r0, #0]
    7d38:	f043 0302 	orr.w	r3, r3, #2
    7d3c:	6003      	str	r3, [r0, #0]
	hri_sercomusart_wait_for_sync(hw, SERCOM_USART_SYNCBUSY_SWRST | SERCOM_USART_SYNCBUSY_ENABLE);
    7d3e:	2103      	movs	r1, #3
    7d40:	4b00      	ldr	r3, [pc, #0]	; (7d44 <_usart_sync_enable+0x10>)
    7d42:	4718      	bx	r3
    7d44:	00007c29 	.word	0x00007c29

00007d48 <_usart_sync_write_byte>:
	hri_sercomusart_write_DATA_reg(device->hw, data);
    7d48:	6803      	ldr	r3, [r0, #0]
	((Sercom *)hw)->USART.DATA.reg = data;
    7d4a:	6299      	str	r1, [r3, #40]	; 0x28
}
    7d4c:	4770      	bx	lr

00007d4e <_usart_sync_read_byte>:
	return hri_sercomusart_read_DATA_reg(device->hw);
    7d4e:	6803      	ldr	r3, [r0, #0]
	return ((Sercom *)hw)->USART.DATA.reg;
    7d50:	6a98      	ldr	r0, [r3, #40]	; 0x28
}
    7d52:	b2c0      	uxtb	r0, r0
    7d54:	4770      	bx	lr

00007d56 <_usart_sync_is_ready_to_send>:
	return hri_sercomusart_get_interrupt_DRE_bit(device->hw);
    7d56:	6803      	ldr	r3, [r0, #0]
	return (((Sercom *)hw)->USART.INTFLAG.reg & SERCOM_USART_INTFLAG_DRE) >> SERCOM_USART_INTFLAG_DRE_Pos;
    7d58:	7e18      	ldrb	r0, [r3, #24]
}
    7d5a:	f000 0001 	and.w	r0, r0, #1
    7d5e:	4770      	bx	lr

00007d60 <_usart_sync_is_transmit_done>:
	return hri_sercomusart_get_interrupt_TXC_bit(device->hw);
    7d60:	6803      	ldr	r3, [r0, #0]
	return (((Sercom *)hw)->USART.INTFLAG.reg & SERCOM_USART_INTFLAG_TXC) >> SERCOM_USART_INTFLAG_TXC_Pos;
    7d62:	7e18      	ldrb	r0, [r3, #24]
}
    7d64:	f3c0 0040 	ubfx	r0, r0, #1, #1
    7d68:	4770      	bx	lr

00007d6a <_usart_sync_is_byte_received>:
	return hri_sercomusart_get_interrupt_RXC_bit(device->hw);
    7d6a:	6803      	ldr	r3, [r0, #0]
	return (((Sercom *)hw)->USART.INTFLAG.reg & SERCOM_USART_INTFLAG_RXC) >> SERCOM_USART_INTFLAG_RXC_Pos;
    7d6c:	7e18      	ldrb	r0, [r3, #24]
}
    7d6e:	f3c0 0080 	ubfx	r0, r0, #2, #1
    7d72:	4770      	bx	lr

00007d74 <led_task>:
	((Port *)hw)->Group[submodule_index].OUTTGL.reg = mask;
    7d74:	4e05      	ldr	r6, [pc, #20]	; (7d8c <led_task+0x18>)
static void led_task(void *p)
{
	(void)p;
	for (;;) {
		gpio_toggle_pin_level(LED_0);
		os_sleep(led_blink_rate);
    7d76:	4d06      	ldr	r5, [pc, #24]	; (7d90 <led_task+0x1c>)
    7d78:	4c06      	ldr	r4, [pc, #24]	; (7d94 <led_task+0x20>)
{
    7d7a:	b580      	push	{r7, lr}
    7d7c:	f44f 2780 	mov.w	r7, #262144	; 0x40000
		os_sleep(led_blink_rate);
    7d80:	8828      	ldrh	r0, [r5, #0]
    7d82:	f8c6 711c 	str.w	r7, [r6, #284]	; 0x11c
    7d86:	47a0      	blx	r4
	for (;;) {
    7d88:	e7fa      	b.n	7d80 <led_task+0xc>
    7d8a:	bf00      	nop
    7d8c:	41008000 	.word	0x41008000
    7d90:	20000014 	.word	0x20000014
    7d94:	00008f85 	.word	0x00008f85

00007d98 <gmac_task>:
/**
 * \brief Task for GMAC.
 * Waits for GMAC interrupt and begins processing of received packets
 */
void gmac_task(void *pvParameters)
{
    7d98:	b570      	push	{r4, r5, r6, lr}
	gmac_device *ps_gmac_dev = pvParameters;

	while (1) {
		/* Wait for the counting RX notification semaphore. */
		xSemaphoreTake(ps_gmac_dev->rx_sem, portMAX_DELAY);
    7d9a:	4e06      	ldr	r6, [pc, #24]	; (7db4 <gmac_task+0x1c>)

		/* Process the incoming packet. */
		ethernetif_mac_input(ps_gmac_dev->netif);
    7d9c:	4d06      	ldr	r5, [pc, #24]	; (7db8 <gmac_task+0x20>)
{
    7d9e:	4604      	mov	r4, r0
		xSemaphoreTake(ps_gmac_dev->rx_sem, portMAX_DELAY);
    7da0:	2300      	movs	r3, #0
    7da2:	6860      	ldr	r0, [r4, #4]
    7da4:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
    7da8:	4619      	mov	r1, r3
    7daa:	47b0      	blx	r6
		ethernetif_mac_input(ps_gmac_dev->netif);
    7dac:	6820      	ldr	r0, [r4, #0]
    7dae:	47a8      	blx	r5
	while (1) {
    7db0:	e7f6      	b.n	7da0 <gmac_task+0x8>
    7db2:	bf00      	nop
    7db4:	00000951 	.word	0x00000951
    7db8:	0000747d 	.word	0x0000747d

00007dbc <gmac_handler_cb>:
{
    7dbc:	b507      	push	{r0, r1, r2, lr}
	portBASE_TYPE xGMACTaskWoken = pdFALSE;
    7dbe:	2300      	movs	r3, #0
    7dc0:	9301      	str	r3, [sp, #4]
	xSemaphoreGiveFromISR(gs_gmac_dev.rx_sem, &xGMACTaskWoken);
    7dc2:	4b0a      	ldr	r3, [pc, #40]	; (7dec <gmac_handler_cb+0x30>)
    7dc4:	a901      	add	r1, sp, #4
    7dc6:	6858      	ldr	r0, [r3, #4]
    7dc8:	4b09      	ldr	r3, [pc, #36]	; (7df0 <gmac_handler_cb+0x34>)
    7dca:	4798      	blx	r3
	portEND_SWITCHING_ISR(xGMACTaskWoken);
    7dcc:	9b01      	ldr	r3, [sp, #4]
    7dce:	b14b      	cbz	r3, 7de4 <gmac_handler_cb+0x28>
    7dd0:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
    7dd4:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
    7dd8:	f8c3 2d04 	str.w	r2, [r3, #3332]	; 0xd04
    7ddc:	f3bf 8f4f 	dsb	sy
    7de0:	f3bf 8f6f 	isb	sy
}
    7de4:	b003      	add	sp, #12
    7de6:	f85d fb04 	ldr.w	pc, [sp], #4
    7dea:	bf00      	nop
    7dec:	200149a0 	.word	0x200149a0
    7df0:	0000088d 	.word	0x0000088d

00007df4 <tcpip_init_done>:
{
    7df4:	b5f0      	push	{r4, r5, r6, r7, lr}
	u8_t mac[6] = {0x00, 0x00, 0x00, 0x00, 0x20, 0x76};
    7df6:	4b27      	ldr	r3, [pc, #156]	; (7e94 <tcpip_init_done+0xa0>)
	mac_async_register_callback(&COMMUNICATION_IO, MAC_ASYNC_RECEIVE_CB, gmac_handler_cb);
    7df8:	4c27      	ldr	r4, [pc, #156]	; (7e98 <tcpip_init_done+0xa4>)
    7dfa:	4a28      	ldr	r2, [pc, #160]	; (7e9c <tcpip_init_done+0xa8>)
	while ((ethernet_phy_get_link_status(&ETHERNET_PHY_0_desc, &link_up)) != ERR_NONE && !(link_up)) {
    7dfc:	4d28      	ldr	r5, [pc, #160]	; (7ea0 <tcpip_init_done+0xac>)
    7dfe:	4f29      	ldr	r7, [pc, #164]	; (7ea4 <tcpip_init_done+0xb0>)
{
    7e00:	b085      	sub	sp, #20
    7e02:	4606      	mov	r6, r0
	u8_t mac[6] = {0x00, 0x00, 0x00, 0x00, 0x20, 0x76};
    7e04:	6818      	ldr	r0, [r3, #0]
    7e06:	889b      	ldrh	r3, [r3, #4]
    7e08:	9002      	str	r0, [sp, #8]
    7e0a:	f8ad 300c 	strh.w	r3, [sp, #12]
	mac_async_register_callback(&COMMUNICATION_IO, MAC_ASYNC_RECEIVE_CB, gmac_handler_cb);
    7e0e:	4620      	mov	r0, r4
    7e10:	4b25      	ldr	r3, [pc, #148]	; (7ea8 <tcpip_init_done+0xb4>)
    7e12:	2100      	movs	r1, #0
    7e14:	4798      	blx	r3
	hri_gmac_set_IMR_RCOMP_bit(COMMUNICATION_IO.dev.hw);
    7e16:	6823      	ldr	r3, [r4, #0]
	((Gmac *)hw)->IDR.reg = GMAC_IMR_MFS;
}

static inline void hri_gmac_set_IMR_RCOMP_bit(const void *const hw)
{
	((Gmac *)hw)->IER.reg = GMAC_IMR_RCOMP;
    7e18:	2202      	movs	r2, #2
    7e1a:	629a      	str	r2, [r3, #40]	; 0x28
	while ((ethernet_phy_get_link_status(&ETHERNET_PHY_0_desc, &link_up)) != ERR_NONE && !(link_up)) {
    7e1c:	f105 0409 	add.w	r4, r5, #9
    7e20:	4b22      	ldr	r3, [pc, #136]	; (7eac <tcpip_init_done+0xb8>)
    7e22:	4621      	mov	r1, r4
    7e24:	4638      	mov	r0, r7
    7e26:	4798      	blx	r3
    7e28:	b110      	cbz	r0, 7e30 <tcpip_init_done+0x3c>
    7e2a:	7a6b      	ldrb	r3, [r5, #9]
    7e2c:	2b00      	cmp	r3, #0
    7e2e:	d02c      	beq.n	7e8a <tcpip_init_done+0x96>
	printf("\r\nEthernet link up\r\n\r\n");
    7e30:	4b1f      	ldr	r3, [pc, #124]	; (7eb0 <tcpip_init_done+0xbc>)
    7e32:	4820      	ldr	r0, [pc, #128]	; (7eb4 <tcpip_init_done+0xc0>)
	TCPIP_STACK_INTERFACE_0_desc.input = tcpip_input;
    7e34:	4c20      	ldr	r4, [pc, #128]	; (7eb8 <tcpip_init_done+0xc4>)
	printf("\r\nEthernet link up\r\n\r\n");
    7e36:	4798      	blx	r3
 */
__STATIC_INLINE void __NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if ((int32_t)(IRQn) >= 0)
  {
    NVIC->IP[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
    7e38:	4b20      	ldr	r3, [pc, #128]	; (7ebc <tcpip_init_done+0xc8>)
	mac_async_enable(&COMMUNICATION_IO);
    7e3a:	4817      	ldr	r0, [pc, #92]	; (7e98 <tcpip_init_done+0xa4>)
    7e3c:	2280      	movs	r2, #128	; 0x80
    7e3e:	f883 2354 	strb.w	r2, [r3, #852]	; 0x354
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
    7e42:	f44f 1280 	mov.w	r2, #1048576	; 0x100000
    7e46:	609a      	str	r2, [r3, #8]
    7e48:	4b1d      	ldr	r3, [pc, #116]	; (7ec0 <tcpip_init_done+0xcc>)
    7e4a:	4798      	blx	r3
	TCPIP_STACK_INTERFACE_0_init(mac);
    7e4c:	a802      	add	r0, sp, #8
    7e4e:	4b1d      	ldr	r3, [pc, #116]	; (7ec4 <tcpip_init_done+0xd0>)
    7e50:	4798      	blx	r3
	TCPIP_STACK_INTERFACE_0_desc.input = tcpip_input;
    7e52:	4b1d      	ldr	r3, [pc, #116]	; (7ec8 <tcpip_init_done+0xd4>)
    7e54:	6123      	str	r3, [r4, #16]
	gs_gmac_dev.rx_sem = xSemaphoreCreateCounting(CONF_GMAC_RXDESCR_NUM, 0);
    7e56:	2100      	movs	r1, #0
    7e58:	4b1c      	ldr	r3, [pc, #112]	; (7ecc <tcpip_init_done+0xd8>)
	gs_gmac_dev.netif = &TCPIP_STACK_INTERFACE_0_desc;
    7e5a:	602c      	str	r4, [r5, #0]
	gs_gmac_dev.rx_sem = xSemaphoreCreateCounting(CONF_GMAC_RXDESCR_NUM, 0);
    7e5c:	2010      	movs	r0, #16
    7e5e:	4798      	blx	r3
	id = sys_thread_new("GMAC", gmac_task, &gs_gmac_dev, netifINTERFACE_TASK_STACK_SIZE, netifINTERFACE_TASK_PRIORITY);
    7e60:	2302      	movs	r3, #2
    7e62:	4a0f      	ldr	r2, [pc, #60]	; (7ea0 <tcpip_init_done+0xac>)
    7e64:	491a      	ldr	r1, [pc, #104]	; (7ed0 <tcpip_init_done+0xdc>)
	gs_gmac_dev.rx_sem = xSemaphoreCreateCounting(CONF_GMAC_RXDESCR_NUM, 0);
    7e66:	6068      	str	r0, [r5, #4]
	id = sys_thread_new("GMAC", gmac_task, &gs_gmac_dev, netifINTERFACE_TASK_STACK_SIZE, netifINTERFACE_TASK_PRIORITY);
    7e68:	9300      	str	r3, [sp, #0]
    7e6a:	4d1a      	ldr	r5, [pc, #104]	; (7ed4 <tcpip_init_done+0xe0>)
    7e6c:	481a      	ldr	r0, [pc, #104]	; (7ed8 <tcpip_init_done+0xe4>)
    7e6e:	f44f 7300 	mov.w	r3, #512	; 0x200
    7e72:	47a8      	blx	r5
	netif_set_default(&TCPIP_STACK_INTERFACE_0_desc);
    7e74:	4620      	mov	r0, r4
    7e76:	4b19      	ldr	r3, [pc, #100]	; (7edc <tcpip_init_done+0xe8>)
    7e78:	4798      	blx	r3
	if (ERR_OK != dhcp_start(&TCPIP_STACK_INTERFACE_0_desc)) {
    7e7a:	4b19      	ldr	r3, [pc, #100]	; (7ee0 <tcpip_init_done+0xec>)
    7e7c:	4620      	mov	r0, r4
    7e7e:	4798      	blx	r3
	sys_sem_signal(sem); /* Signal the waiting thread that the TCP/IP init is done. */
    7e80:	4b18      	ldr	r3, [pc, #96]	; (7ee4 <tcpip_init_done+0xf0>)
    7e82:	4630      	mov	r0, r6
    7e84:	4798      	blx	r3
}
    7e86:	b005      	add	sp, #20
    7e88:	bdf0      	pop	{r4, r5, r6, r7, pc}
		os_sleep(20);
    7e8a:	4b17      	ldr	r3, [pc, #92]	; (7ee8 <tcpip_init_done+0xf4>)
    7e8c:	2014      	movs	r0, #20
    7e8e:	4798      	blx	r3
    7e90:	e7c6      	b.n	7e20 <tcpip_init_done+0x2c>
    7e92:	bf00      	nop
    7e94:	0000b838 	.word	0x0000b838
    7e98:	2000a520 	.word	0x2000a520
    7e9c:	00007dbd 	.word	0x00007dbd
    7ea0:	200149a0 	.word	0x200149a0
    7ea4:	200000a4 	.word	0x200000a4
    7ea8:	00004d2d 	.word	0x00004d2d
    7eac:	00001005 	.word	0x00001005
    7eb0:	0000a481 	.word	0x0000a481
    7eb4:	0000b819 	.word	0x0000b819
    7eb8:	20014960 	.word	0x20014960
    7ebc:	e000e100 	.word	0xe000e100
    7ec0:	00004c71 	.word	0x00004c71
    7ec4:	000078f9 	.word	0x000078f9
    7ec8:	0000a199 	.word	0x0000a199
    7ecc:	000005bd 	.word	0x000005bd
    7ed0:	00007d99 	.word	0x00007d99
    7ed4:	00007be9 	.word	0x00007be9
    7ed8:	0000b82f 	.word	0x0000b82f
    7edc:	0000a089 	.word	0x0000a089
    7ee0:	00006229 	.word	0x00006229
    7ee4:	00007a19 	.word	0x00007a19
    7ee8:	00008f85 	.word	0x00008f85

00007eec <task_led_create>:

/**
 * \brief Create OS task for LED blinking
 */
void task_led_create(void)
{
    7eec:	b51f      	push	{r0, r1, r2, r3, r4, lr}

	/* Create task to make led blink */
	if (xTaskCreate(led_task, "Led", TASK_LED_STACK_SIZE, NULL, TASK_LED_TASK_PRIORITY, &xLed_Task) != pdPASS) {
    7eee:	4a08      	ldr	r2, [pc, #32]	; (7f10 <task_led_create+0x24>)
    7ef0:	9201      	str	r2, [sp, #4]
    7ef2:	2300      	movs	r3, #0
    7ef4:	2201      	movs	r2, #1
    7ef6:	9200      	str	r2, [sp, #0]
    7ef8:	e9cd 3302 	strd	r3, r3, [sp, #8]
    7efc:	4905      	ldr	r1, [pc, #20]	; (7f14 <task_led_create+0x28>)
    7efe:	4806      	ldr	r0, [pc, #24]	; (7f18 <task_led_create+0x2c>)
    7f00:	4c06      	ldr	r4, [pc, #24]	; (7f1c <task_led_create+0x30>)
    7f02:	2280      	movs	r2, #128	; 0x80
    7f04:	47a0      	blx	r4
    7f06:	2801      	cmp	r0, #1
    7f08:	d000      	beq.n	7f0c <task_led_create+0x20>
		while (1) {
    7f0a:	e7fe      	b.n	7f0a <task_led_create+0x1e>
			;
		}
	}
}
    7f0c:	b004      	add	sp, #16
    7f0e:	bd10      	pop	{r4, pc}
    7f10:	200149ac 	.word	0x200149ac
    7f14:	0000b834 	.word	0x0000b834
    7f18:	00007d75 	.word	0x00007d75
    7f1c:	00008b45 	.word	0x00008b45

00007f20 <lwip_init>:

/**
 * Perform Sanity check of user-configurable values, and initialize all modules.
 */
void lwip_init(void)
{
    7f20:	b510      	push	{r4, lr}
	/* Modules initialization */
	stats_init();
#if !NO_SYS
	sys_init();
    7f22:	4b09      	ldr	r3, [pc, #36]	; (7f48 <lwip_init+0x28>)
    7f24:	4798      	blx	r3
#endif /* !NO_SYS */
	mem_init();
    7f26:	4b09      	ldr	r3, [pc, #36]	; (7f4c <lwip_init+0x2c>)
    7f28:	4798      	blx	r3
	memp_init();
    7f2a:	4b09      	ldr	r3, [pc, #36]	; (7f50 <lwip_init+0x30>)
    7f2c:	4798      	blx	r3
	pbuf_init();
	netif_init();
    7f2e:	4b09      	ldr	r3, [pc, #36]	; (7f54 <lwip_init+0x34>)
    7f30:	4798      	blx	r3
#if LWIP_SOCKET
	lwip_socket_init();
    7f32:	4b09      	ldr	r3, [pc, #36]	; (7f58 <lwip_init+0x38>)
    7f34:	4798      	blx	r3
#endif /* LWIP_ARP */
#if LWIP_RAW
	raw_init();
#endif /* LWIP_RAW */
#if LWIP_UDP
	udp_init();
    7f36:	4b09      	ldr	r3, [pc, #36]	; (7f5c <lwip_init+0x3c>)
    7f38:	4798      	blx	r3
#endif /* LWIP_UDP */
#if LWIP_TCP
	tcp_init();
    7f3a:	4b09      	ldr	r3, [pc, #36]	; (7f60 <lwip_init+0x40>)
    7f3c:	4798      	blx	r3
#endif /* LWIP_DNS */

#if LWIP_TIMERS
	sys_timeouts_init();
#endif /* LWIP_TIMERS */
}
    7f3e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	sys_timeouts_init();
    7f42:	4b08      	ldr	r3, [pc, #32]	; (7f64 <lwip_init+0x44>)
    7f44:	4718      	bx	r3
    7f46:	bf00      	nop
    7f48:	0000799d 	.word	0x0000799d
    7f4c:	00006639 	.word	0x00006639
    7f50:	00004bb1 	.word	0x00004bb1
    7f54:	00009fb1 	.word	0x00009fb1
    7f58:	000095f9 	.word	0x000095f9
    7f5c:	0000447d 	.word	0x0000447d
    7f60:	00006931 	.word	0x00006931
    7f64:	0000111d 	.word	0x0000111d

00007f68 <prvInsertTimerInActiveList>:
	BaseType_t xProcessTimerNow = pdFALSE;

	listSET_LIST_ITEM_VALUE(&(pxTimer->xTimerListItem), xNextExpiryTime);
	listSET_LIST_ITEM_OWNER(&(pxTimer->xTimerListItem), pxTimer);

	if (xNextExpiryTime <= xTimeNow) {
    7f68:	4291      	cmp	r1, r2
{
    7f6a:	b508      	push	{r3, lr}
	listSET_LIST_ITEM_VALUE(&(pxTimer->xTimerListItem), xNextExpiryTime);
    7f6c:	6041      	str	r1, [r0, #4]
	listSET_LIST_ITEM_OWNER(&(pxTimer->xTimerListItem), pxTimer);
    7f6e:	6100      	str	r0, [r0, #16]
	if (xNextExpiryTime <= xTimeNow) {
    7f70:	d80a      	bhi.n	7f88 <prvInsertTimerInActiveList+0x20>
		/* Has the expiry time elapsed between the command to start/reset a
		timer was issued, and the time the command was processed? */
		if ((xTimeNow - xCommandTime) >= pxTimer->xTimerPeriodInTicks) {
    7f72:	1ad2      	subs	r2, r2, r3
    7f74:	6983      	ldr	r3, [r0, #24]
    7f76:	429a      	cmp	r2, r3
    7f78:	d20e      	bcs.n	7f98 <prvInsertTimerInActiveList+0x30>
			/* The time between a command being issued and the command being
			processed actually exceeds the timers period.  */
			xProcessTimerNow = pdTRUE;
		} else {
			vListInsert(pxOverflowTimerList, &(pxTimer->xTimerListItem));
    7f7a:	4b08      	ldr	r3, [pc, #32]	; (7f9c <prvInsertTimerInActiveList+0x34>)
    7f7c:	1d01      	adds	r1, r0, #4
    7f7e:	6818      	ldr	r0, [r3, #0]
			/* If, since the command was issued, the tick count has overflowed
			but the expiry time has not, then the timer must have already passed
			its expiry time and should be processed immediately. */
			xProcessTimerNow = pdTRUE;
		} else {
			vListInsert(pxCurrentTimerList, &(pxTimer->xTimerListItem));
    7f80:	4b07      	ldr	r3, [pc, #28]	; (7fa0 <prvInsertTimerInActiveList+0x38>)
    7f82:	4798      	blx	r3
	BaseType_t xProcessTimerNow = pdFALSE;
    7f84:	2000      	movs	r0, #0
		}
	}

	return xProcessTimerNow;
}
    7f86:	bd08      	pop	{r3, pc}
		if ((xTimeNow < xCommandTime) && (xNextExpiryTime >= xCommandTime)) {
    7f88:	429a      	cmp	r2, r3
    7f8a:	d201      	bcs.n	7f90 <prvInsertTimerInActiveList+0x28>
    7f8c:	4299      	cmp	r1, r3
    7f8e:	d203      	bcs.n	7f98 <prvInsertTimerInActiveList+0x30>
			vListInsert(pxCurrentTimerList, &(pxTimer->xTimerListItem));
    7f90:	4b02      	ldr	r3, [pc, #8]	; (7f9c <prvInsertTimerInActiveList+0x34>)
    7f92:	1d01      	adds	r1, r0, #4
    7f94:	6858      	ldr	r0, [r3, #4]
    7f96:	e7f3      	b.n	7f80 <prvInsertTimerInActiveList+0x18>
			xProcessTimerNow = pdTRUE;
    7f98:	2001      	movs	r0, #1
	return xProcessTimerNow;
    7f9a:	e7f4      	b.n	7f86 <prvInsertTimerInActiveList+0x1e>
    7f9c:	200149b0 	.word	0x200149b0
    7fa0:	00001e31 	.word	0x00001e31

00007fa4 <prvCheckForValidListAndQueue>:
	pxOverflowTimerList = pxTemp;
}
/*-----------------------------------------------------------*/

static void prvCheckForValidListAndQueue(void)
{
    7fa4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	/* Check that the list from which active timers are referenced, and the
	queue used to communicate with the timer service, have been
	initialised. */
	taskENTER_CRITICAL();
	{
		if (xTimerQueue == NULL) {
    7fa8:	4c12      	ldr	r4, [pc, #72]	; (7ff4 <prvCheckForValidListAndQueue+0x50>)
	taskENTER_CRITICAL();
    7faa:	4b13      	ldr	r3, [pc, #76]	; (7ff8 <prvCheckForValidListAndQueue+0x54>)
    7fac:	4798      	blx	r3
		if (xTimerQueue == NULL) {
    7fae:	68a5      	ldr	r5, [r4, #8]
    7fb0:	b995      	cbnz	r5, 7fd8 <prvCheckForValidListAndQueue+0x34>
			vListInitialise(&xActiveTimerList1);
    7fb2:	f104 070c 	add.w	r7, r4, #12
    7fb6:	f8df 804c 	ldr.w	r8, [pc, #76]	; 8004 <prvCheckForValidListAndQueue+0x60>
    7fba:	4638      	mov	r0, r7
			vListInitialise(&xActiveTimerList2);
    7fbc:	f104 0620 	add.w	r6, r4, #32
			vListInitialise(&xActiveTimerList1);
    7fc0:	47c0      	blx	r8
			vListInitialise(&xActiveTimerList2);
    7fc2:	4630      	mov	r0, r6
    7fc4:	47c0      	blx	r8
			pxCurrentTimerList  = &xActiveTimerList1;
			pxOverflowTimerList = &xActiveTimerList2;
			xTimerQueue         = xQueueCreate((UBaseType_t)configTIMER_QUEUE_LENGTH, sizeof(DaemonTaskMessage_t));
    7fc6:	4b0d      	ldr	r3, [pc, #52]	; (7ffc <prvCheckForValidListAndQueue+0x58>)
    7fc8:	462a      	mov	r2, r5
    7fca:	210c      	movs	r1, #12
    7fcc:	2002      	movs	r0, #2
			pxOverflowTimerList = &xActiveTimerList2;
    7fce:	e9c4 6700 	strd	r6, r7, [r4]
			xTimerQueue         = xQueueCreate((UBaseType_t)configTIMER_QUEUE_LENGTH, sizeof(DaemonTaskMessage_t));
    7fd2:	4798      	blx	r3
			configASSERT(xTimerQueue);
    7fd4:	b120      	cbz	r0, 7fe0 <prvCheckForValidListAndQueue+0x3c>
			xTimerQueue         = xQueueCreate((UBaseType_t)configTIMER_QUEUE_LENGTH, sizeof(DaemonTaskMessage_t));
    7fd6:	60a0      	str	r0, [r4, #8]
		} else {
			mtCOVERAGE_TEST_MARKER();
		}
	}
	taskEXIT_CRITICAL();
}
    7fd8:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
	taskEXIT_CRITICAL();
    7fdc:	4b08      	ldr	r3, [pc, #32]	; (8000 <prvCheckForValidListAndQueue+0x5c>)
    7fde:	4718      	bx	r3
    7fe0:	f04f 0380 	mov.w	r3, #128	; 0x80
    7fe4:	f383 8811 	msr	BASEPRI, r3
    7fe8:	f3bf 8f6f 	isb	sy
    7fec:	f3bf 8f4f 	dsb	sy
			configASSERT(xTimerQueue);
    7ff0:	e7fe      	b.n	7ff0 <prvCheckForValidListAndQueue+0x4c>
    7ff2:	bf00      	nop
    7ff4:	200149b0 	.word	0x200149b0
    7ff8:	00009d55 	.word	0x00009d55
    7ffc:	0000054d 	.word	0x0000054d
    8000:	00009d95 	.word	0x00009d95
    8004:	00001dfd 	.word	0x00001dfd

00008008 <xTimerCreateTimerTask>:
{
    8008:	b51f      	push	{r0, r1, r2, r3, r4, lr}
	prvCheckForValidListAndQueue();
    800a:	4b0e      	ldr	r3, [pc, #56]	; (8044 <xTimerCreateTimerTask+0x3c>)
    800c:	4798      	blx	r3
	if (xTimerQueue != NULL) {
    800e:	4b0e      	ldr	r3, [pc, #56]	; (8048 <xTimerCreateTimerTask+0x40>)
    8010:	689b      	ldr	r3, [r3, #8]
    8012:	b163      	cbz	r3, 802e <xTimerCreateTimerTask+0x26>
			xReturn = xTaskCreate(prvTimerTask,
    8014:	2300      	movs	r3, #0
    8016:	2202      	movs	r2, #2
    8018:	9200      	str	r2, [sp, #0]
    801a:	e9cd 3302 	strd	r3, r3, [sp, #8]
    801e:	490b      	ldr	r1, [pc, #44]	; (804c <xTimerCreateTimerTask+0x44>)
    8020:	480b      	ldr	r0, [pc, #44]	; (8050 <xTimerCreateTimerTask+0x48>)
    8022:	4c0c      	ldr	r4, [pc, #48]	; (8054 <xTimerCreateTimerTask+0x4c>)
    8024:	9301      	str	r3, [sp, #4]
    8026:	f44f 7280 	mov.w	r2, #256	; 0x100
    802a:	47a0      	blx	r4
	configASSERT(xReturn);
    802c:	b940      	cbnz	r0, 8040 <xTimerCreateTimerTask+0x38>
    802e:	f04f 0380 	mov.w	r3, #128	; 0x80
    8032:	f383 8811 	msr	BASEPRI, r3
    8036:	f3bf 8f6f 	isb	sy
    803a:	f3bf 8f4f 	dsb	sy
    803e:	e7fe      	b.n	803e <xTimerCreateTimerTask+0x36>
}
    8040:	b004      	add	sp, #16
    8042:	bd10      	pop	{r4, pc}
    8044:	00007fa5 	.word	0x00007fa5
    8048:	200149b0 	.word	0x200149b0
    804c:	0000b83e 	.word	0x0000b83e
    8050:	00008161 	.word	0x00008161
    8054:	00008b45 	.word	0x00008b45

00008058 <xTimerGenericCommand>:
{
    8058:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
    805a:	4616      	mov	r6, r2
	configASSERT(xTimer);
    805c:	4604      	mov	r4, r0
{
    805e:	461a      	mov	r2, r3
	configASSERT(xTimer);
    8060:	b940      	cbnz	r0, 8074 <xTimerGenericCommand+0x1c>
    8062:	f04f 0380 	mov.w	r3, #128	; 0x80
    8066:	f383 8811 	msr	BASEPRI, r3
    806a:	f3bf 8f6f 	isb	sy
    806e:	f3bf 8f4f 	dsb	sy
    8072:	e7fe      	b.n	8072 <xTimerGenericCommand+0x1a>
	if (xTimerQueue != NULL) {
    8074:	4d0d      	ldr	r5, [pc, #52]	; (80ac <xTimerGenericCommand+0x54>)
    8076:	68a8      	ldr	r0, [r5, #8]
    8078:	b188      	cbz	r0, 809e <xTimerGenericCommand+0x46>
		if (xCommandID < tmrFIRST_FROM_ISR_COMMAND) {
    807a:	2905      	cmp	r1, #5
		xMessage.u.xTimerParameters.xMessageValue = xOptionalValue;
    807c:	e9cd 1601 	strd	r1, r6, [sp, #4]
		xMessage.u.xTimerParameters.pxTimer       = (Timer_t *)xTimer;
    8080:	9403      	str	r4, [sp, #12]
		if (xCommandID < tmrFIRST_FROM_ISR_COMMAND) {
    8082:	dc0e      	bgt.n	80a2 <xTimerGenericCommand+0x4a>
			if (xTaskGetSchedulerState() == taskSCHEDULER_RUNNING) {
    8084:	4b0a      	ldr	r3, [pc, #40]	; (80b0 <xTimerGenericCommand+0x58>)
    8086:	4c0b      	ldr	r4, [pc, #44]	; (80b4 <xTimerGenericCommand+0x5c>)
    8088:	4798      	blx	r3
    808a:	2802      	cmp	r0, #2
				xReturn = xQueueSendToBack(xTimerQueue, &xMessage, xTicksToWait);
    808c:	f04f 0300 	mov.w	r3, #0
    8090:	bf08      	it	eq
    8092:	9a08      	ldreq	r2, [sp, #32]
				xReturn = xQueueSendToBack(xTimerQueue, &xMessage, tmrNO_DELAY);
    8094:	68a8      	ldr	r0, [r5, #8]
    8096:	bf18      	it	ne
    8098:	461a      	movne	r2, r3
    809a:	a901      	add	r1, sp, #4
			xReturn = xQueueSendToBackFromISR(xTimerQueue, &xMessage, pxHigherPriorityTaskWoken);
    809c:	47a0      	blx	r4
}
    809e:	b004      	add	sp, #16
    80a0:	bd70      	pop	{r4, r5, r6, pc}
			xReturn = xQueueSendToBackFromISR(xTimerQueue, &xMessage, pxHigherPriorityTaskWoken);
    80a2:	4c05      	ldr	r4, [pc, #20]	; (80b8 <xTimerGenericCommand+0x60>)
    80a4:	2300      	movs	r3, #0
    80a6:	a901      	add	r1, sp, #4
    80a8:	e7f8      	b.n	809c <xTimerGenericCommand+0x44>
    80aa:	bf00      	nop
    80ac:	200149b0 	.word	0x200149b0
    80b0:	000092d5 	.word	0x000092d5
    80b4:	00000611 	.word	0x00000611
    80b8:	000007b1 	.word	0x000007b1

000080bc <prvSampleTimeNow>:
{
    80bc:	e92d 47ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, lr}
	xTimeNow = xTaskGetTickCount();
    80c0:	4b22      	ldr	r3, [pc, #136]	; (814c <prvSampleTimeNow+0x90>)
	if (xTimeNow < xLastTime) {
    80c2:	4d23      	ldr	r5, [pc, #140]	; (8150 <prvSampleTimeNow+0x94>)
{
    80c4:	4607      	mov	r7, r0
	xTimeNow = xTaskGetTickCount();
    80c6:	4798      	blx	r3
	if (xTimeNow < xLastTime) {
    80c8:	6b6b      	ldr	r3, [r5, #52]	; 0x34
    80ca:	4283      	cmp	r3, r0
	xTimeNow = xTaskGetTickCount();
    80cc:	4606      	mov	r6, r0
	if (xTimeNow < xLastTime) {
    80ce:	d93a      	bls.n	8146 <prvSampleTimeNow+0x8a>
		(void)uxListRemove(&(pxTimer->xTimerListItem));
    80d0:	f8df 8084 	ldr.w	r8, [pc, #132]	; 8158 <prvSampleTimeNow+0x9c>
				    = xTimerGenericCommand(pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY);
    80d4:	f8df 9084 	ldr.w	r9, [pc, #132]	; 815c <prvSampleTimeNow+0xa0>
	while (listLIST_IS_EMPTY(pxCurrentTimerList) == pdFALSE) {
    80d8:	686b      	ldr	r3, [r5, #4]
    80da:	681a      	ldr	r2, [r3, #0]
    80dc:	b94a      	cbnz	r2, 80f2 <prvSampleTimeNow+0x36>
	pxCurrentTimerList  = pxOverflowTimerList;
    80de:	682a      	ldr	r2, [r5, #0]
	pxOverflowTimerList = pxTemp;
    80e0:	e9c5 3200 	strd	r3, r2, [r5]
		*pxTimerListsWereSwitched = pdTRUE;
    80e4:	2301      	movs	r3, #1
}
    80e6:	4630      	mov	r0, r6
		*pxTimerListsWereSwitched = pdFALSE;
    80e8:	603b      	str	r3, [r7, #0]
	xLastTime = xTimeNow;
    80ea:	636e      	str	r6, [r5, #52]	; 0x34
}
    80ec:	b004      	add	sp, #16
    80ee:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY(pxCurrentTimerList);
    80f2:	68db      	ldr	r3, [r3, #12]
		pxTimer = (Timer_t *)listGET_OWNER_OF_HEAD_ENTRY(pxCurrentTimerList);
    80f4:	68dc      	ldr	r4, [r3, #12]
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY(pxCurrentTimerList);
    80f6:	f8d3 a000 	ldr.w	sl, [r3]
		(void)uxListRemove(&(pxTimer->xTimerListItem));
    80fa:	1d21      	adds	r1, r4, #4
    80fc:	4608      	mov	r0, r1
    80fe:	9103      	str	r1, [sp, #12]
    8100:	47c0      	blx	r8
		pxTimer->pxCallbackFunction((TimerHandle_t)pxTimer);
    8102:	6a63      	ldr	r3, [r4, #36]	; 0x24
    8104:	4620      	mov	r0, r4
    8106:	4798      	blx	r3
		if (pxTimer->uxAutoReload == (UBaseType_t)pdTRUE) {
    8108:	69e3      	ldr	r3, [r4, #28]
    810a:	9903      	ldr	r1, [sp, #12]
    810c:	2b01      	cmp	r3, #1
    810e:	d1e3      	bne.n	80d8 <prvSampleTimeNow+0x1c>
			xReloadTime = (xNextExpireTime + pxTimer->xTimerPeriodInTicks);
    8110:	69a3      	ldr	r3, [r4, #24]
    8112:	4453      	add	r3, sl
			if (xReloadTime > xNextExpireTime) {
    8114:	459a      	cmp	sl, r3
    8116:	d205      	bcs.n	8124 <prvSampleTimeNow+0x68>
				listSET_LIST_ITEM_VALUE(&(pxTimer->xTimerListItem), xReloadTime);
    8118:	6063      	str	r3, [r4, #4]
				vListInsert(pxCurrentTimerList, &(pxTimer->xTimerListItem));
    811a:	6868      	ldr	r0, [r5, #4]
    811c:	4b0d      	ldr	r3, [pc, #52]	; (8154 <prvSampleTimeNow+0x98>)
				listSET_LIST_ITEM_OWNER(&(pxTimer->xTimerListItem), pxTimer);
    811e:	6124      	str	r4, [r4, #16]
				vListInsert(pxCurrentTimerList, &(pxTimer->xTimerListItem));
    8120:	4798      	blx	r3
    8122:	e7d9      	b.n	80d8 <prvSampleTimeNow+0x1c>
				    = xTimerGenericCommand(pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY);
    8124:	2300      	movs	r3, #0
    8126:	9300      	str	r3, [sp, #0]
    8128:	4652      	mov	r2, sl
    812a:	4619      	mov	r1, r3
    812c:	4620      	mov	r0, r4
    812e:	47c8      	blx	r9
				configASSERT(xResult);
    8130:	2800      	cmp	r0, #0
    8132:	d1d1      	bne.n	80d8 <prvSampleTimeNow+0x1c>
    8134:	f04f 0380 	mov.w	r3, #128	; 0x80
    8138:	f383 8811 	msr	BASEPRI, r3
    813c:	f3bf 8f6f 	isb	sy
    8140:	f3bf 8f4f 	dsb	sy
    8144:	e7fe      	b.n	8144 <prvSampleTimeNow+0x88>
		*pxTimerListsWereSwitched = pdFALSE;
    8146:	2300      	movs	r3, #0
    8148:	e7cd      	b.n	80e6 <prvSampleTimeNow+0x2a>
    814a:	bf00      	nop
    814c:	00008d99 	.word	0x00008d99
    8150:	200149b0 	.word	0x200149b0
    8154:	00001e31 	.word	0x00001e31
    8158:	00001e5f 	.word	0x00001e5f
    815c:	00008059 	.word	0x00008059

00008160 <prvTimerTask>:
{
    8160:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	(void)uxListRemove(&(pxTimer->xTimerListItem));
    8164:	f8df a1ac 	ldr.w	sl, [pc, #428]	; 8314 <prvTimerTask+0x1b4>
{
    8168:	b087      	sub	sp, #28
	*pxListWasEmpty = listLIST_IS_EMPTY(pxCurrentTimerList);
    816a:	4f61      	ldr	r7, [pc, #388]	; (82f0 <prvTimerTask+0x190>)
    816c:	687b      	ldr	r3, [r7, #4]
    816e:	f8d3 b000 	ldr.w	fp, [r3]
	if (*pxListWasEmpty == pdFALSE) {
    8172:	f1bb 0f00 	cmp.w	fp, #0
    8176:	d035      	beq.n	81e4 <prvTimerTask+0x84>
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY(pxCurrentTimerList);
    8178:	68db      	ldr	r3, [r3, #12]
    817a:	681e      	ldr	r6, [r3, #0]
	vTaskSuspendAll();
    817c:	4b5d      	ldr	r3, [pc, #372]	; (82f4 <prvTimerTask+0x194>)
		xTimeNow = prvSampleTimeNow(&xTimerListsWereSwitched);
    817e:	4d5e      	ldr	r5, [pc, #376]	; (82f8 <prvTimerTask+0x198>)
	vTaskSuspendAll();
    8180:	4798      	blx	r3
		xTimeNow = prvSampleTimeNow(&xTimerListsWereSwitched);
    8182:	a803      	add	r0, sp, #12
    8184:	47a8      	blx	r5
		if (xTimerListsWereSwitched == pdFALSE) {
    8186:	9c03      	ldr	r4, [sp, #12]
    8188:	46a9      	mov	r9, r5
		xTimeNow = prvSampleTimeNow(&xTimerListsWereSwitched);
    818a:	4680      	mov	r8, r0
		if (xTimerListsWereSwitched == pdFALSE) {
    818c:	4d5b      	ldr	r5, [pc, #364]	; (82fc <prvTimerTask+0x19c>)
    818e:	2c00      	cmp	r4, #0
    8190:	d173      	bne.n	827a <prvTimerTask+0x11a>
			if ((xListWasEmpty == pdFALSE) && (xNextExpireTime <= xTimeNow)) {
    8192:	f1bb 0f00 	cmp.w	fp, #0
    8196:	d057      	beq.n	8248 <prvTimerTask+0xe8>
    8198:	42b0      	cmp	r0, r6
    819a:	d35a      	bcc.n	8252 <prvTimerTask+0xf2>
				(void)xTaskResumeAll();
    819c:	47a8      	blx	r5
	Timer_t *const pxTimer = (Timer_t *)listGET_OWNER_OF_HEAD_ENTRY(pxCurrentTimerList);
    819e:	687b      	ldr	r3, [r7, #4]
    81a0:	68db      	ldr	r3, [r3, #12]
    81a2:	68dd      	ldr	r5, [r3, #12]
	(void)uxListRemove(&(pxTimer->xTimerListItem));
    81a4:	1d28      	adds	r0, r5, #4
    81a6:	47d0      	blx	sl
	if (pxTimer->uxAutoReload == (UBaseType_t)pdTRUE) {
    81a8:	69eb      	ldr	r3, [r5, #28]
    81aa:	2b01      	cmp	r3, #1
    81ac:	d11c      	bne.n	81e8 <prvTimerTask+0x88>
		if (prvInsertTimerInActiveList(
    81ae:	69a9      	ldr	r1, [r5, #24]
    81b0:	4642      	mov	r2, r8
    81b2:	4633      	mov	r3, r6
    81b4:	f8df 8154 	ldr.w	r8, [pc, #340]	; 830c <prvTimerTask+0x1ac>
    81b8:	4431      	add	r1, r6
    81ba:	4628      	mov	r0, r5
    81bc:	47c0      	blx	r8
    81be:	2801      	cmp	r0, #1
    81c0:	d112      	bne.n	81e8 <prvTimerTask+0x88>
			xResult = xTimerGenericCommand(pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY);
    81c2:	9400      	str	r4, [sp, #0]
    81c4:	4623      	mov	r3, r4
    81c6:	4621      	mov	r1, r4
    81c8:	4632      	mov	r2, r6
    81ca:	4c4d      	ldr	r4, [pc, #308]	; (8300 <prvTimerTask+0x1a0>)
    81cc:	4628      	mov	r0, r5
    81ce:	47a0      	blx	r4
			configASSERT(xResult);
    81d0:	b950      	cbnz	r0, 81e8 <prvTimerTask+0x88>
    81d2:	f04f 0380 	mov.w	r3, #128	; 0x80
    81d6:	f383 8811 	msr	BASEPRI, r3
    81da:	f3bf 8f6f 	isb	sy
    81de:	f3bf 8f4f 	dsb	sy
    81e2:	e7fe      	b.n	81e2 <prvTimerTask+0x82>
		xNextExpireTime = (TickType_t)0U;
    81e4:	465e      	mov	r6, fp
    81e6:	e7c9      	b.n	817c <prvTimerTask+0x1c>
	pxTimer->pxCallbackFunction((TimerHandle_t)pxTimer);
    81e8:	6a6b      	ldr	r3, [r5, #36]	; 0x24
    81ea:	4628      	mov	r0, r5
    81ec:	4798      	blx	r3
	while (xQueueReceive(xTimerQueue, &xMessage, tmrNO_DELAY)
    81ee:	4d45      	ldr	r5, [pc, #276]	; (8304 <prvTimerTask+0x1a4>)
    81f0:	68b8      	ldr	r0, [r7, #8]
    81f2:	2300      	movs	r3, #0
    81f4:	461a      	mov	r2, r3
    81f6:	a903      	add	r1, sp, #12
    81f8:	47a8      	blx	r5
    81fa:	2800      	cmp	r0, #0
    81fc:	d0b5      	beq.n	816a <prvTimerTask+0xa>
		if (xMessage.xMessageID >= (BaseType_t)0) {
    81fe:	9b03      	ldr	r3, [sp, #12]
    8200:	2b00      	cmp	r3, #0
    8202:	dbf5      	blt.n	81f0 <prvTimerTask+0x90>
			pxTimer = xMessage.u.xTimerParameters.pxTimer;
    8204:	9c05      	ldr	r4, [sp, #20]
			if (listIS_CONTAINED_WITHIN(NULL, &(pxTimer->xTimerListItem)) == pdFALSE) {
    8206:	6963      	ldr	r3, [r4, #20]
    8208:	b10b      	cbz	r3, 820e <prvTimerTask+0xae>
				(void)uxListRemove(&(pxTimer->xTimerListItem));
    820a:	1d20      	adds	r0, r4, #4
    820c:	47d0      	blx	sl
			xTimeNow = prvSampleTimeNow(&xTimerListsWereSwitched);
    820e:	a802      	add	r0, sp, #8
    8210:	47c8      	blx	r9
			switch (xMessage.xMessageID) {
    8212:	9b03      	ldr	r3, [sp, #12]
			xTimeNow = prvSampleTimeNow(&xTimerListsWereSwitched);
    8214:	4602      	mov	r2, r0
			switch (xMessage.xMessageID) {
    8216:	2b09      	cmp	r3, #9
    8218:	d8ea      	bhi.n	81f0 <prvTimerTask+0x90>
    821a:	a101      	add	r1, pc, #4	; (adr r1, 8220 <prvTimerTask+0xc0>)
    821c:	f851 f023 	ldr.w	pc, [r1, r3, lsl #2]
    8220:	0000827f 	.word	0x0000827f
    8224:	0000827f 	.word	0x0000827f
    8228:	0000827f 	.word	0x0000827f
    822c:	000081f1 	.word	0x000081f1
    8230:	000082c3 	.word	0x000082c3
    8234:	000082e7 	.word	0x000082e7
    8238:	0000827f 	.word	0x0000827f
    823c:	0000827f 	.word	0x0000827f
    8240:	000081f1 	.word	0x000081f1
    8244:	000082c3 	.word	0x000082c3
					xListWasEmpty = listLIST_IS_EMPTY(pxOverflowTimerList);
    8248:	683b      	ldr	r3, [r7, #0]
    824a:	681c      	ldr	r4, [r3, #0]
    824c:	fab4 f484 	clz	r4, r4
    8250:	0964      	lsrs	r4, r4, #5
				vQueueWaitForMessageRestricted(xTimerQueue, (xNextExpireTime - xTimeNow), xListWasEmpty);
    8252:	68b8      	ldr	r0, [r7, #8]
    8254:	4b2c      	ldr	r3, [pc, #176]	; (8308 <prvTimerTask+0x1a8>)
    8256:	4622      	mov	r2, r4
    8258:	eba6 0108 	sub.w	r1, r6, r8
    825c:	4798      	blx	r3
				if (xTaskResumeAll() == pdFALSE) {
    825e:	47a8      	blx	r5
    8260:	2800      	cmp	r0, #0
    8262:	d1c4      	bne.n	81ee <prvTimerTask+0x8e>
					portYIELD_WITHIN_API();
    8264:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
    8268:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
    826c:	f8c3 2d04 	str.w	r2, [r3, #3332]	; 0xd04
    8270:	f3bf 8f4f 	dsb	sy
    8274:	f3bf 8f6f 	isb	sy
    8278:	e7b9      	b.n	81ee <prvTimerTask+0x8e>
			(void)xTaskResumeAll();
    827a:	47a8      	blx	r5
    827c:	e7b7      	b.n	81ee <prvTimerTask+0x8e>
				if (prvInsertTimerInActiveList(pxTimer,
    827e:	69a1      	ldr	r1, [r4, #24]
    8280:	9b04      	ldr	r3, [sp, #16]
    8282:	4e22      	ldr	r6, [pc, #136]	; (830c <prvTimerTask+0x1ac>)
    8284:	4419      	add	r1, r3
    8286:	4620      	mov	r0, r4
    8288:	47b0      	blx	r6
    828a:	2801      	cmp	r0, #1
    828c:	d1b0      	bne.n	81f0 <prvTimerTask+0x90>
					pxTimer->pxCallbackFunction((TimerHandle_t)pxTimer);
    828e:	6a63      	ldr	r3, [r4, #36]	; 0x24
    8290:	4620      	mov	r0, r4
    8292:	4798      	blx	r3
					if (pxTimer->uxAutoReload == (UBaseType_t)pdTRUE) {
    8294:	69e3      	ldr	r3, [r4, #28]
    8296:	2b01      	cmp	r3, #1
    8298:	d1aa      	bne.n	81f0 <prvTimerTask+0x90>
						xResult = xTimerGenericCommand(pxTimer,
    829a:	69a2      	ldr	r2, [r4, #24]
    829c:	9904      	ldr	r1, [sp, #16]
    829e:	2300      	movs	r3, #0
    82a0:	440a      	add	r2, r1
    82a2:	4620      	mov	r0, r4
    82a4:	9300      	str	r3, [sp, #0]
    82a6:	4c16      	ldr	r4, [pc, #88]	; (8300 <prvTimerTask+0x1a0>)
    82a8:	4619      	mov	r1, r3
    82aa:	47a0      	blx	r4
						configASSERT(xResult);
    82ac:	2800      	cmp	r0, #0
    82ae:	d19f      	bne.n	81f0 <prvTimerTask+0x90>
    82b0:	f04f 0380 	mov.w	r3, #128	; 0x80
    82b4:	f383 8811 	msr	BASEPRI, r3
    82b8:	f3bf 8f6f 	isb	sy
    82bc:	f3bf 8f4f 	dsb	sy
    82c0:	e7fe      	b.n	82c0 <prvTimerTask+0x160>
				pxTimer->xTimerPeriodInTicks = xMessage.u.xTimerParameters.xMessageValue;
    82c2:	9904      	ldr	r1, [sp, #16]
    82c4:	61a1      	str	r1, [r4, #24]
				configASSERT((pxTimer->xTimerPeriodInTicks > 0));
    82c6:	b941      	cbnz	r1, 82da <prvTimerTask+0x17a>
    82c8:	f04f 0380 	mov.w	r3, #128	; 0x80
    82cc:	f383 8811 	msr	BASEPRI, r3
    82d0:	f3bf 8f6f 	isb	sy
    82d4:	f3bf 8f4f 	dsb	sy
    82d8:	e7fe      	b.n	82d8 <prvTimerTask+0x178>
				(void)prvInsertTimerInActiveList(
    82da:	4603      	mov	r3, r0
    82dc:	4401      	add	r1, r0
    82de:	4620      	mov	r0, r4
    82e0:	4c0a      	ldr	r4, [pc, #40]	; (830c <prvTimerTask+0x1ac>)
    82e2:	47a0      	blx	r4
				break;
    82e4:	e784      	b.n	81f0 <prvTimerTask+0x90>
				vPortFree(pxTimer);
    82e6:	4b0a      	ldr	r3, [pc, #40]	; (8310 <prvTimerTask+0x1b0>)
    82e8:	4620      	mov	r0, r4
    82ea:	4798      	blx	r3
				break;
    82ec:	e780      	b.n	81f0 <prvTimerTask+0x90>
    82ee:	bf00      	nop
    82f0:	200149b0 	.word	0x200149b0
    82f4:	00008d85 	.word	0x00008d85
    82f8:	000080bd 	.word	0x000080bd
    82fc:	00008e99 	.word	0x00008e99
    8300:	00008059 	.word	0x00008059
    8304:	00000951 	.word	0x00000951
    8308:	00000b01 	.word	0x00000b01
    830c:	00007f69 	.word	0x00007f69
    8310:	00001db5 	.word	0x00001db5
    8314:	00001e5f 	.word	0x00001e5f

00008318 <lwip_standard_chksum>:
 * @param len length of data to be summed
 * @return host order (!) lwip checksum (non-inverted Internet sum)
 */

static u16_t lwip_standard_chksum(void *dataptr, int len)
{
    8318:	b573      	push	{r0, r1, r4, r5, r6, lr}
	u8_t * pb = (u8_t *)dataptr;
	u16_t *ps, t = 0;
    831a:	2300      	movs	r3, #0
	u32_t  sum = 0;
	int    odd = ((mem_ptr_t)pb & 1);

	/* Get aligned to u16_t */
	if (odd && len > 0) {
    831c:	f010 0401 	ands.w	r4, r0, #1
	u16_t *ps, t = 0;
    8320:	f8ad 3006 	strh.w	r3, [sp, #6]
	if (odd && len > 0) {
    8324:	d005      	beq.n	8332 <lwip_standard_chksum+0x1a>
    8326:	b351      	cbz	r1, 837e <lwip_standard_chksum+0x66>
		((u8_t *)&t)[1] = *pb++;
    8328:	f810 3b01 	ldrb.w	r3, [r0], #1
    832c:	f88d 3007 	strb.w	r3, [sp, #7]
		len--;
    8330:	3901      	subs	r1, #1
	}

	/* Add the bulk of the data */
	ps = (u16_t *)(void *)pb;
	while (len > 1) {
    8332:	f021 0301 	bic.w	r3, r1, #1
    8336:	084d      	lsrs	r5, r1, #1
    8338:	4403      	add	r3, r0
	u32_t  sum = 0;
    833a:	2200      	movs	r2, #0
	while (len > 1) {
    833c:	4298      	cmp	r0, r3
    833e:	d11a      	bne.n	8376 <lwip_standard_chksum+0x5e>
		sum += *ps++;
		len -= 2;
	}

	/* Consume left-over byte, if any */
	if (len > 0) {
    8340:	f06f 0301 	mvn.w	r3, #1
    8344:	fb03 1105 	mla	r1, r3, r5, r1
    8348:	2901      	cmp	r1, #1
    834a:	d102      	bne.n	8352 <lwip_standard_chksum+0x3a>
		((u8_t *)&t)[0] = *(u8_t *)ps;
    834c:	7803      	ldrb	r3, [r0, #0]
    834e:	f88d 3006 	strb.w	r3, [sp, #6]
	}

	/* Add end bytes */
	sum += t;
    8352:	f8bd 3006 	ldrh.w	r3, [sp, #6]
    8356:	4413      	add	r3, r2

	/* Fold 32-bit sum to 16 bits
	   calling this twice is propably faster than if statements... */
	sum = FOLD_U32T(sum);
    8358:	b298      	uxth	r0, r3
    835a:	eb00 4313 	add.w	r3, r0, r3, lsr #16
	sum = FOLD_U32T(sum);
    835e:	b298      	uxth	r0, r3
    8360:	eb00 4013 	add.w	r0, r0, r3, lsr #16

	/* Swap if alignment was odd */
	if (odd) {
    8364:	b124      	cbz	r4, 8370 <lwip_standard_chksum+0x58>
		sum = SWAP_BYTES_IN_WORD(sum);
    8366:	0203      	lsls	r3, r0, #8
    8368:	b29b      	uxth	r3, r3
    836a:	f3c0 2007 	ubfx	r0, r0, #8, #8
    836e:	4318      	orrs	r0, r3
	}

	return (u16_t)sum;
}
    8370:	b280      	uxth	r0, r0
    8372:	b002      	add	sp, #8
    8374:	bd70      	pop	{r4, r5, r6, pc}
		sum += *ps++;
    8376:	f830 6b02 	ldrh.w	r6, [r0], #2
    837a:	4432      	add	r2, r6
		len -= 2;
    837c:	e7de      	b.n	833c <lwip_standard_chksum+0x24>
	u32_t  sum = 0;
    837e:	460a      	mov	r2, r1
    8380:	e7e7      	b.n	8352 <lwip_standard_chksum+0x3a>
	...

00008384 <inet_chksum_pseudo>:
 * @param proto ip protocol (used for checksum of pseudo header)
 * @param proto_len length of the ip data part (used for checksum of pseudo header)
 * @return checksum (as u16_t) to be saved directly in the protocol header
 */
u16_t inet_chksum_pseudo(struct pbuf *p, ip_addr_t *src, ip_addr_t *dest, u8_t proto, u16_t proto_len)
{
    8384:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	u32_t        addr;
	struct pbuf *q;
	u8_t         swapped;

	acc     = 0;
	swapped = 0;
    8388:	2600      	movs	r6, #0
	/* iterate through all pbuf in chain */
	for (q = p; q != NULL; q = q->next) {
		LWIP_DEBUGF(INET_DEBUG,
		            ("inet_chksum_pseudo(): checksumming pbuf %p (has next %p) \n", (void *)q, (void *)q->next));
		acc += LWIP_CHKSUM(q->payload, q->len);
    838a:	f8df a084 	ldr.w	sl, [pc, #132]	; 8410 <inet_chksum_pseudo+0x8c>
{
    838e:	4605      	mov	r5, r0
    8390:	4689      	mov	r9, r1
    8392:	4690      	mov	r8, r2
    8394:	461f      	mov	r7, r3
	acc     = 0;
    8396:	4634      	mov	r4, r6
	for (q = p; q != NULL; q = q->next) {
    8398:	bb1d      	cbnz	r5, 83e2 <inet_chksum_pseudo+0x5e>
			acc     = SWAP_BYTES_IN_WORD(acc);
		}
		/*LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): wrapped lwip_chksum()=%"X32_F" \n", acc));*/
	}

	if (swapped) {
    839a:	b126      	cbz	r6, 83a6 <inet_chksum_pseudo+0x22>
		acc = SWAP_BYTES_IN_WORD(acc);
    839c:	0223      	lsls	r3, r4, #8
    839e:	b29b      	uxth	r3, r3
    83a0:	f3c4 2407 	ubfx	r4, r4, #8, #8
    83a4:	431c      	orrs	r4, r3
	}
	addr = ip4_addr_get_u32(src);
	acc += (addr & 0xffffUL);
	acc += ((addr >> 16) & 0xffffUL);
	addr = ip4_addr_get_u32(dest);
    83a6:	f8d8 2000 	ldr.w	r2, [r8]
	addr = ip4_addr_get_u32(src);
    83aa:	f8d9 3000 	ldr.w	r3, [r9]
	acc += (addr & 0xffffUL);
	acc += ((addr >> 16) & 0xffffUL);
	acc += (u32_t)htons((u16_t)proto);
    83ae:	4d17      	ldr	r5, [pc, #92]	; (840c <inet_chksum_pseudo+0x88>)
	acc += ((addr >> 16) & 0xffffUL);
    83b0:	0c11      	lsrs	r1, r2, #16
    83b2:	fa11 f282 	uxtah	r2, r1, r2
    83b6:	fa12 f283 	uxtah	r2, r2, r3
    83ba:	eb02 4213 	add.w	r2, r2, r3, lsr #16
	acc += (u32_t)htons((u16_t)proto);
    83be:	4638      	mov	r0, r7
	acc += ((addr >> 16) & 0xffffUL);
    83c0:	4414      	add	r4, r2
	acc += (u32_t)htons((u16_t)proto);
    83c2:	47a8      	blx	r5
    83c4:	4404      	add	r4, r0
	acc += (u32_t)htons(proto_len);
    83c6:	f8bd 0020 	ldrh.w	r0, [sp, #32]
    83ca:	47a8      	blx	r5
    83cc:	4420      	add	r0, r4

	/* Fold 32-bit sum to 16 bits
	   calling this twice is propably faster than if statements... */
	acc = FOLD_U32T(acc);
    83ce:	b284      	uxth	r4, r0
    83d0:	eb04 4410 	add.w	r4, r4, r0, lsr #16
	acc = FOLD_U32T(acc);
    83d4:	b2a0      	uxth	r0, r4
    83d6:	eb00 4014 	add.w	r0, r0, r4, lsr #16
	LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): pbuf chain lwip_chksum()=%" X32_F "\n", acc));
	return (u16_t) ~(acc & 0xffffUL);
    83da:	43c0      	mvns	r0, r0
}
    83dc:	b280      	uxth	r0, r0
    83de:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
		acc += LWIP_CHKSUM(q->payload, q->len);
    83e2:	8969      	ldrh	r1, [r5, #10]
    83e4:	6868      	ldr	r0, [r5, #4]
    83e6:	47d0      	blx	sl
    83e8:	4404      	add	r4, r0
		acc = FOLD_U32T(acc);
    83ea:	b2a3      	uxth	r3, r4
    83ec:	eb03 4414 	add.w	r4, r3, r4, lsr #16
		if (q->len % 2 != 0) {
    83f0:	896b      	ldrh	r3, [r5, #10]
    83f2:	07db      	lsls	r3, r3, #31
    83f4:	d507      	bpl.n	8406 <inet_chksum_pseudo+0x82>
			acc     = SWAP_BYTES_IN_WORD(acc);
    83f6:	0223      	lsls	r3, r4, #8
			swapped = 1 - swapped;
    83f8:	f1c6 0601 	rsb	r6, r6, #1
			acc     = SWAP_BYTES_IN_WORD(acc);
    83fc:	b29b      	uxth	r3, r3
    83fe:	f3c4 2407 	ubfx	r4, r4, #8, #8
			swapped = 1 - swapped;
    8402:	b2f6      	uxtb	r6, r6
			acc     = SWAP_BYTES_IN_WORD(acc);
    8404:	431c      	orrs	r4, r3
	for (q = p; q != NULL; q = q->next) {
    8406:	682d      	ldr	r5, [r5, #0]
    8408:	e7c6      	b.n	8398 <inet_chksum_pseudo+0x14>
    840a:	bf00      	nop
    840c:	00000d65 	.word	0x00000d65
    8410:	00008319 	.word	0x00008319

00008414 <inet_chksum>:
 * @param len length of the buffer to calculate the checksum
 * @return checksum (as u16_t) to be saved directly in the protocol header
 */

u16_t inet_chksum(void *dataptr, u16_t len)
{
    8414:	b508      	push	{r3, lr}
	return ~LWIP_CHKSUM(dataptr, len);
    8416:	4b02      	ldr	r3, [pc, #8]	; (8420 <inet_chksum+0xc>)
    8418:	4798      	blx	r3
    841a:	43c0      	mvns	r0, r0
}
    841c:	b280      	uxth	r0, r0
    841e:	bd08      	pop	{r3, pc}
    8420:	00008319 	.word	0x00008319

00008424 <inet_chksum_pbuf>:
 *
 * @param p pbuf chain over that the checksum should be calculated
 * @return checksum (as u16_t) to be saved directly in the protocol header
 */
u16_t inet_chksum_pbuf(struct pbuf *p)
{
    8424:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	u32_t        acc;
	struct pbuf *q;
	u8_t         swapped;

	acc     = 0;
	swapped = 0;
    8426:	2500      	movs	r5, #0
	for (q = p; q != NULL; q = q->next) {
		acc += LWIP_CHKSUM(q->payload, q->len);
    8428:	4f10      	ldr	r7, [pc, #64]	; (846c <inet_chksum_pbuf+0x48>)
{
    842a:	4606      	mov	r6, r0
	acc     = 0;
    842c:	462c      	mov	r4, r5
	for (q = p; q != NULL; q = q->next) {
    842e:	b946      	cbnz	r6, 8442 <inet_chksum_pbuf+0x1e>
			swapped = 1 - swapped;
			acc     = SWAP_BYTES_IN_WORD(acc);
		}
	}

	if (swapped) {
    8430:	b125      	cbz	r5, 843c <inet_chksum_pbuf+0x18>
		acc = SWAP_BYTES_IN_WORD(acc);
    8432:	0223      	lsls	r3, r4, #8
    8434:	b29b      	uxth	r3, r3
    8436:	f3c4 2407 	ubfx	r4, r4, #8, #8
    843a:	431c      	orrs	r4, r3
	}
	return (u16_t) ~(acc & 0xffffUL);
    843c:	43e0      	mvns	r0, r4
}
    843e:	b280      	uxth	r0, r0
    8440:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		acc += LWIP_CHKSUM(q->payload, q->len);
    8442:	8971      	ldrh	r1, [r6, #10]
    8444:	6870      	ldr	r0, [r6, #4]
    8446:	47b8      	blx	r7
		if (q->len % 2 != 0) {
    8448:	8973      	ldrh	r3, [r6, #10]
		acc += LWIP_CHKSUM(q->payload, q->len);
    844a:	4404      	add	r4, r0
		acc = FOLD_U32T(acc);
    844c:	b2a0      	uxth	r0, r4
		if (q->len % 2 != 0) {
    844e:	07db      	lsls	r3, r3, #31
		acc = FOLD_U32T(acc);
    8450:	eb00 4414 	add.w	r4, r0, r4, lsr #16
		if (q->len % 2 != 0) {
    8454:	d507      	bpl.n	8466 <inet_chksum_pbuf+0x42>
			acc     = SWAP_BYTES_IN_WORD(acc);
    8456:	0223      	lsls	r3, r4, #8
			swapped = 1 - swapped;
    8458:	f1c5 0501 	rsb	r5, r5, #1
			acc     = SWAP_BYTES_IN_WORD(acc);
    845c:	b29b      	uxth	r3, r3
    845e:	f3c4 2407 	ubfx	r4, r4, #8, #8
			swapped = 1 - swapped;
    8462:	b2ed      	uxtb	r5, r5
			acc     = SWAP_BYTES_IN_WORD(acc);
    8464:	431c      	orrs	r4, r3
	for (q = p; q != NULL; q = q->next) {
    8466:	6836      	ldr	r6, [r6, #0]
    8468:	e7e1      	b.n	842e <inet_chksum_pbuf+0xa>
    846a:	bf00      	nop
    846c:	00008319 	.word	0x00008319

00008470 <socket_basic_ethernet>:
	/* Start FreeRTOS scheduler */
	vTaskStartScheduler();
}

void socket_basic_ethernet(void *p)
{
    8470:	b5f0      	push	{r4, r5, r6, r7, lr}
    8472:	b08b      	sub	sp, #44	; 0x2c

	struct sockaddr_in address;
	int                s_create, new_socket;
	int                addrlen = sizeof(address);
	int                opt     = 1;
    8474:	2510      	movs	r5, #16
    8476:	2601      	movs	r6, #1
	int                socket_check;

	sys_sem_t sem;
	err_t     err_sem;
	err_sem = sys_sem_new(&sem, 0); /* Create a new semaphore. */
    8478:	4b2e      	ldr	r3, [pc, #184]	; (8534 <socket_basic_ethernet+0xc4>)
	print_ipaddress();

	/*Create a socket*/
	s_create = socket(AF_INET, 1, 0);

	setsockopt(s_create, SOL_SOCKET, SO_REUSEADDR | SO_REUSEPORT, &opt, sizeof(opt));
    847a:	4f2f      	ldr	r7, [pc, #188]	; (8538 <socket_basic_ethernet+0xc8>)
	err_sem = sys_sem_new(&sem, 0); /* Create a new semaphore. */
    847c:	2100      	movs	r1, #0
    847e:	a805      	add	r0, sp, #20
	int                opt     = 1;
    8480:	e9cd 5603 	strd	r5, r6, [sp, #12]
	err_sem = sys_sem_new(&sem, 0); /* Create a new semaphore. */
    8484:	4798      	blx	r3
	tcpip_init(tcpip_init_done, &sem);
    8486:	482d      	ldr	r0, [pc, #180]	; (853c <socket_basic_ethernet+0xcc>)
    8488:	4b2d      	ldr	r3, [pc, #180]	; (8540 <socket_basic_ethernet+0xd0>)
    848a:	a905      	add	r1, sp, #20
    848c:	4798      	blx	r3
	sys_sem_wait(&sem); /* Block until the lwIP stack is initialized. */
    848e:	2100      	movs	r1, #0
    8490:	4b2c      	ldr	r3, [pc, #176]	; (8544 <socket_basic_ethernet+0xd4>)
    8492:	a805      	add	r0, sp, #20
    8494:	4798      	blx	r3
	sys_sem_free(&sem); /* Free the semaphore. */
    8496:	a805      	add	r0, sp, #20
    8498:	4b2b      	ldr	r3, [pc, #172]	; (8548 <socket_basic_ethernet+0xd8>)
    849a:	4798      	blx	r3
	print_ipaddress();
    849c:	4b2b      	ldr	r3, [pc, #172]	; (854c <socket_basic_ethernet+0xdc>)
    849e:	4798      	blx	r3
	s_create = socket(AF_INET, 1, 0);
    84a0:	4631      	mov	r1, r6
    84a2:	4b2b      	ldr	r3, [pc, #172]	; (8550 <socket_basic_ethernet+0xe0>)
    84a4:	2200      	movs	r2, #0
    84a6:	2002      	movs	r0, #2
    84a8:	4798      	blx	r3
	setsockopt(s_create, SOL_SOCKET, SO_REUSEADDR | SO_REUSEPORT, &opt, sizeof(opt));
    84aa:	2304      	movs	r3, #4
    84ac:	f44f 7201 	mov.w	r2, #516	; 0x204
    84b0:	f640 71ff 	movw	r1, #4095	; 0xfff
    84b4:	9300      	str	r3, [sp, #0]
    84b6:	eb0d 0305 	add.w	r3, sp, r5
	s_create = socket(AF_INET, 1, 0);
    84ba:	4606      	mov	r6, r0
	setsockopt(s_create, SOL_SOCKET, SO_REUSEADDR | SO_REUSEPORT, &opt, sizeof(opt));
    84bc:	47b8      	blx	r7

	address.sin_family      = AF_INET;
    84be:	2302      	movs	r3, #2
    84c0:	f88d 3019 	strb.w	r3, [sp, #25]
	address.sin_addr.s_addr = htonl(IPADDR_ANY);
    84c4:	2000      	movs	r0, #0
    84c6:	4b23      	ldr	r3, [pc, #140]	; (8554 <socket_basic_ethernet+0xe4>)
    84c8:	4798      	blx	r3
	address.sin_port        = htons(HTTP_PORT);
    84ca:	4b23      	ldr	r3, [pc, #140]	; (8558 <socket_basic_ethernet+0xe8>)
	address.sin_addr.s_addr = htonl(IPADDR_ANY);
    84cc:	9007      	str	r0, [sp, #28]
	address.sin_port        = htons(HTTP_PORT);
    84ce:	2050      	movs	r0, #80	; 0x50
    84d0:	4798      	blx	r3
	/* bind the connection to port */
	socket_check = bind(s_create, (struct sockaddr *)&address, sizeof(address));
    84d2:	4b22      	ldr	r3, [pc, #136]	; (855c <socket_basic_ethernet+0xec>)
	address.sin_port        = htons(HTTP_PORT);
    84d4:	f8ad 001a 	strh.w	r0, [sp, #26]
	socket_check = bind(s_create, (struct sockaddr *)&address, sizeof(address));
    84d8:	462a      	mov	r2, r5
    84da:	a906      	add	r1, sp, #24
    84dc:	4630      	mov	r0, r6
    84de:	4798      	blx	r3
	if (socket_check < 0) {
    84e0:	2800      	cmp	r0, #0
    84e2:	db22      	blt.n	852a <socket_basic_ethernet+0xba>
		LWIP_DEBUGF(LWIP_DBG_ON, ("Bind error=%d\n", socket_check));
		goto socket_close;
	}
	/* tell the connection to listen for incoming connection requests */
	listen(s_create, 3);
    84e4:	4b1e      	ldr	r3, [pc, #120]	; (8560 <socket_basic_ethernet+0xf0>)
    84e6:	2103      	movs	r1, #3
    84e8:	4630      	mov	r0, r6
    84ea:	4798      	blx	r3

	for (;;) {
		new_socket = accept(s_create, (struct sockaddr *)&address, (socklen_t *)&addrlen);
    84ec:	4b1d      	ldr	r3, [pc, #116]	; (8564 <socket_basic_ethernet+0xf4>)
    84ee:	aa03      	add	r2, sp, #12
    84f0:	a906      	add	r1, sp, #24
    84f2:	4630      	mov	r0, r6
    84f4:	4798      	blx	r3

		if (new_socket <= 0) {
    84f6:	1e04      	subs	r4, r0, #0
    84f8:	dd17      	ble.n	852a <socket_basic_ethernet+0xba>
			LWIP_DEBUGF(LWIP_DBG_ON, ("Connection error=%d\n", new_socket));
			goto socket_close;
		}
		socket_check = read(new_socket, buffer, 1024);
    84fa:	491b      	ldr	r1, [pc, #108]	; (8568 <socket_basic_ethernet+0xf8>)
    84fc:	4b1b      	ldr	r3, [pc, #108]	; (856c <socket_basic_ethernet+0xfc>)
    84fe:	f44f 6280 	mov.w	r2, #1024	; 0x400
    8502:	4798      	blx	r3
		if (socket_check <= 0) {
    8504:	2800      	cmp	r0, #0
    8506:	dd10      	ble.n	852a <socket_basic_ethernet+0xba>
			LWIP_DEBUGF(LWIP_DBG_ON, ("Read error=%d\n", socket_check));
			goto socket_close;
		}
		/* Check if the request was an HTTP "GET /\r\n". */
		if (!strncmp(buffer, "GET", 3)) {
    8508:	4919      	ldr	r1, [pc, #100]	; (8570 <socket_basic_ethernet+0x100>)
    850a:	4817      	ldr	r0, [pc, #92]	; (8568 <socket_basic_ethernet+0xf8>)
    850c:	4b19      	ldr	r3, [pc, #100]	; (8574 <socket_basic_ethernet+0x104>)
    850e:	2203      	movs	r2, #3
    8510:	4798      	blx	r3
    8512:	b950      	cbnz	r0, 852a <socket_basic_ethernet+0xba>
			socket_check = write(new_socket, http_html_hdr, strlen(http_html_hdr));
    8514:	4918      	ldr	r1, [pc, #96]	; (8578 <socket_basic_ethernet+0x108>)
    8516:	4d19      	ldr	r5, [pc, #100]	; (857c <socket_basic_ethernet+0x10c>)
    8518:	222c      	movs	r2, #44	; 0x2c
    851a:	4620      	mov	r0, r4
    851c:	47a8      	blx	r5
			if (socket_check <= 0) {
    851e:	2800      	cmp	r0, #0
    8520:	dd03      	ble.n	852a <socket_basic_ethernet+0xba>
				LWIP_DEBUGF(LWIP_DBG_ON, ("Write error=%d\n", socket_check));
				goto socket_close;
			}

			/*Send the actual webpage*/
			socket_check = write(new_socket, socket_webpage, strlen(socket_webpage));
    8522:	4917      	ldr	r1, [pc, #92]	; (8580 <socket_basic_ethernet+0x110>)
    8524:	2277      	movs	r2, #119	; 0x77
    8526:	4620      	mov	r0, r4
    8528:	47a8      	blx	r5
				goto socket_close;
			}
		}
	/*Close connection*/
	socket_close:
		close(new_socket);
    852a:	4b16      	ldr	r3, [pc, #88]	; (8584 <socket_basic_ethernet+0x114>)
    852c:	4620      	mov	r0, r4
    852e:	4798      	blx	r3
		new_socket = accept(s_create, (struct sockaddr *)&address, (socklen_t *)&addrlen);
    8530:	e7dc      	b.n	84ec <socket_basic_ethernet+0x7c>
    8532:	bf00      	nop
    8534:	000079a9 	.word	0x000079a9
    8538:	00009bd5 	.word	0x00009bd5
    853c:	00007df5 	.word	0x00007df5
    8540:	0000a299 	.word	0x0000a299
    8544:	00007a39 	.word	0x00007a39
    8548:	00007a09 	.word	0x00007a09
    854c:	00004b31 	.word	0x00004b31
    8550:	00009b45 	.word	0x00009b45
    8554:	00000d71 	.word	0x00000d71
    8558:	00000d65 	.word	0x00000d65
    855c:	0000970d 	.word	0x0000970d
    8560:	000097c9 	.word	0x000097c9
    8564:	000095fd 	.word	0x000095fd
    8568:	200149e8 	.word	0x200149e8
    856c:	000099ed 	.word	0x000099ed
    8570:	0000b846 	.word	0x0000b846
    8574:	0000a62d 	.word	0x0000a62d
    8578:	0000b859 	.word	0x0000b859
    857c:	00009bc1 	.word	0x00009bc1
    8580:	0000b886 	.word	0x0000b886
    8584:	0000976d 	.word	0x0000976d

00008588 <basic_socket>:
{
    8588:	b51f      	push	{r0, r1, r2, r3, r4, lr}
	task_led_create();
    858a:	4b0b      	ldr	r3, [pc, #44]	; (85b8 <basic_socket+0x30>)
	if (xTaskCreate(socket_basic_ethernet,
    858c:	4c0b      	ldr	r4, [pc, #44]	; (85bc <basic_socket+0x34>)
	task_led_create();
    858e:	4798      	blx	r3
	if (xTaskCreate(socket_basic_ethernet,
    8590:	4a0b      	ldr	r2, [pc, #44]	; (85c0 <basic_socket+0x38>)
    8592:	9201      	str	r2, [sp, #4]
    8594:	2300      	movs	r3, #0
    8596:	2201      	movs	r2, #1
    8598:	9200      	str	r2, [sp, #0]
    859a:	e9cd 3302 	strd	r3, r3, [sp, #8]
    859e:	4909      	ldr	r1, [pc, #36]	; (85c4 <basic_socket+0x3c>)
    85a0:	4809      	ldr	r0, [pc, #36]	; (85c8 <basic_socket+0x40>)
    85a2:	f44f 7280 	mov.w	r2, #256	; 0x100
    85a6:	47a0      	blx	r4
    85a8:	2801      	cmp	r0, #1
    85aa:	d000      	beq.n	85ae <basic_socket+0x26>
		while (1)
    85ac:	e7fe      	b.n	85ac <basic_socket+0x24>
	vTaskStartScheduler();
    85ae:	4b07      	ldr	r3, [pc, #28]	; (85cc <basic_socket+0x44>)
}
    85b0:	b004      	add	sp, #16
    85b2:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	vTaskStartScheduler();
    85b6:	4718      	bx	r3
    85b8:	00007eed 	.word	0x00007eed
    85bc:	00008b45 	.word	0x00008b45
    85c0:	20014de8 	.word	0x20014de8
    85c4:	0000b84a 	.word	0x0000b84a
    85c8:	00008471 	.word	0x00008471
    85cc:	00008d05 	.word	0x00008d05

000085d0 <GMAC_Handler>:

/*
 * \internal GMAC interrupt handler
 */
void GMAC_Handler(void)
{
    85d0:	b513      	push	{r0, r1, r4, lr}
	volatile uint32_t tsr;
	volatile uint32_t rsr;

	tsr = hri_gmac_read_TSR_reg(_gmac_dev->hw);
    85d2:	4c11      	ldr	r4, [pc, #68]	; (8618 <GMAC_Handler+0x48>)
    85d4:	6820      	ldr	r0, [r4, #0]
    85d6:	6803      	ldr	r3, [r0, #0]
	GMAC_CRITICAL_SECTION_LEAVE();
}

static inline hri_gmac_tsr_reg_t hri_gmac_read_TSR_reg(const void *const hw)
{
	return ((Gmac *)hw)->TSR.reg;
    85d8:	695a      	ldr	r2, [r3, #20]
    85da:	9200      	str	r2, [sp, #0]
	GMAC_CRITICAL_SECTION_LEAVE();
}

static inline hri_gmac_rsr_reg_t hri_gmac_read_RSR_reg(const void *const hw)
{
	return ((Gmac *)hw)->RSR.reg;
    85dc:	6a1a      	ldr	r2, [r3, #32]
	rsr = hri_gmac_read_RSR_reg(_gmac_dev->hw);
    85de:	9201      	str	r2, [sp, #4]
	GMAC_CRITICAL_SECTION_LEAVE();
}

static inline hri_gmac_isr_reg_t hri_gmac_read_ISR_reg(const void *const hw)
{
	return ((Gmac *)hw)->ISR.reg;
    85e0:	6a5a      	ldr	r2, [r3, #36]	; 0x24
	/* Must be Clear ISR (Clear on read) */
	hri_gmac_read_ISR_reg(_gmac_dev->hw);

	/* Frame transmited */
	if (tsr & GMAC_TSR_TXCOMP) {
    85e2:	9a00      	ldr	r2, [sp, #0]
    85e4:	0692      	lsls	r2, r2, #26
    85e6:	d50a      	bpl.n	85fe <GMAC_Handler+0x2e>
		hri_gmac_write_TSR_reg(_gmac_dev->hw, tsr);
    85e8:	9a00      	ldr	r2, [sp, #0]
	((Gmac *)hw)->TSR.reg = data;
    85ea:	615a      	str	r2, [r3, #20]
		if ((_txbuf_descrs[_txbuf_index].status.bm.used) && (_gmac_dev->cb.transmited != NULL)) {
    85ec:	6863      	ldr	r3, [r4, #4]
    85ee:	eb04 03c3 	add.w	r3, r4, r3, lsl #3
    85f2:	7bdb      	ldrb	r3, [r3, #15]
    85f4:	09db      	lsrs	r3, r3, #7
    85f6:	d002      	beq.n	85fe <GMAC_Handler+0x2e>
    85f8:	6843      	ldr	r3, [r0, #4]
    85fa:	b103      	cbz	r3, 85fe <GMAC_Handler+0x2e>
			_gmac_dev->cb.transmited(_gmac_dev);
    85fc:	4798      	blx	r3
		}
	}

	/* Frame received */
	if (rsr & GMAC_RSR_REC) {
    85fe:	9b01      	ldr	r3, [sp, #4]
    8600:	079b      	lsls	r3, r3, #30
    8602:	d503      	bpl.n	860c <GMAC_Handler+0x3c>
		if (_gmac_dev->cb.received != NULL) {
    8604:	6820      	ldr	r0, [r4, #0]
    8606:	6883      	ldr	r3, [r0, #8]
    8608:	b103      	cbz	r3, 860c <GMAC_Handler+0x3c>
			_gmac_dev->cb.received(_gmac_dev);
    860a:	4798      	blx	r3
		}
	}
	hri_gmac_write_RSR_reg(_gmac_dev->hw, rsr);
    860c:	6823      	ldr	r3, [r4, #0]
    860e:	9a01      	ldr	r2, [sp, #4]
    8610:	681b      	ldr	r3, [r3, #0]
	((Gmac *)hw)->RSR.reg = data;
    8612:	621a      	str	r2, [r3, #32]
}
    8614:	b002      	add	sp, #8
    8616:	bd10      	pop	{r4, pc}
    8618:	20014e00 	.word	0x20014e00

0000861c <_mac_async_init>:
	((Gmac *)hw)->NCR.reg = data;
    861c:	2310      	movs	r3, #16

int32_t _mac_async_init(struct _mac_async_device *const dev, void *const hw)
{
    861e:	b5f0      	push	{r4, r5, r6, r7, lr}
	dev->hw = hw;
    8620:	6001      	str	r1, [r0, #0]
    8622:	600b      	str	r3, [r1, #0]
	((Gmac *)hw)->NCFGR.reg = data;
    8624:	4b22      	ldr	r3, [pc, #136]	; (86b0 <_mac_async_init+0x94>)
    8626:	604b      	str	r3, [r1, #4]
	((Gmac *)hw)->UR.reg = data;
    8628:	2200      	movs	r2, #0
	((Gmac *)hw)->DCFGR.reg = data;
    862a:	4b22      	ldr	r3, [pc, #136]	; (86b4 <_mac_async_init+0x98>)
	((Gmac *)hw)->UR.reg = data;
    862c:	60ca      	str	r2, [r1, #12]
	((Gmac *)hw)->DCFGR.reg = data;
    862e:	610b      	str	r3, [r1, #16]
}

static inline void hri_gmac_write_IPGS_reg(const void *const hw, hri_gmac_ipgs_reg_t data)
{
	GMAC_CRITICAL_SECTION_ENTER();
	((Gmac *)hw)->IPGS.reg = data;
    8630:	f240 1301 	movw	r3, #257	; 0x101
	((Gmac *)hw)->WOL.reg = data;
    8634:	f8c1 20b8 	str.w	r2, [r1, #184]	; 0xb8
	((Gmac *)hw)->IPGS.reg = data;
    8638:	f8c1 30bc 	str.w	r3, [r1, #188]	; 0xbc
		_txbuf_descrs[i].address        = (uint32_t)_txbuf[i];
    863c:	4b1e      	ldr	r3, [pc, #120]	; (86b8 <_mac_async_init+0x9c>)
    863e:	4e1f      	ldr	r6, [pc, #124]	; (86bc <_mac_async_init+0xa0>)
	_txbuf_index                                            = 0;
    8640:	605a      	str	r2, [r3, #4]
		_txbuf_descrs[i].address        = (uint32_t)_txbuf[i];
    8642:	f103 0420 	add.w	r4, r3, #32
    8646:	609c      	str	r4, [r3, #8]
		_txbuf_descrs[i].status.val     = 0;
    8648:	f04f 4400 	mov.w	r4, #2147483648	; 0x80000000
    864c:	60dc      	str	r4, [r3, #12]
		_txbuf_descrs[i].address        = (uint32_t)_txbuf[i];
    864e:	f203 54fc 	addw	r4, r3, #1532	; 0x5fc
    8652:	611c      	str	r4, [r3, #16]
		_txbuf_descrs[i].status.val     = 0;
    8654:	f04f 4440 	mov.w	r4, #3221225472	; 0xc0000000
    8658:	615c      	str	r4, [r3, #20]
	_last_txbuf_index                                       = 0;
    865a:	f8c3 2bd8 	str.w	r2, [r3, #3032]	; 0xbd8
	for (i = 0; i < CONF_GMAC_RXDESCR_NUM; i++) {
    865e:	f503 653e 	add.w	r5, r3, #3040	; 0xbe0
	_last_txbuf_index                                       = 0;
    8662:	4634      	mov	r4, r6
		_rxbuf_descrs[i].status.val  = 0;
    8664:	4617      	mov	r7, r2
	for (i = 0; i < CONF_GMAC_RXDESCR_NUM; i++) {
    8666:	3201      	adds	r2, #1
    8668:	2a10      	cmp	r2, #16
		_rxbuf_descrs[i].status.val  = 0;
    866a:	e9c4 5700 	strd	r5, r7, [r4]
	for (i = 0; i < CONF_GMAC_RXDESCR_NUM; i++) {
    866e:	f105 0580 	add.w	r5, r5, #128	; 0x80
    8672:	f104 0408 	add.w	r4, r4, #8
    8676:	d1f6      	bne.n	8666 <_mac_async_init+0x4a>
	_rxbuf_descrs[CONF_GMAC_RXDESCR_NUM - 1].address.bm.wrap = 1;
    8678:	4a11      	ldr	r2, [pc, #68]	; (86c0 <_mac_async_init+0xa4>)
	        | GMAC_DCFGR_DRBS(CONF_GMAC_DCFGR_DRBS) | (CONF_GMAC_DCFGR_DDRP ? GMAC_DCFGR_DDRP : 0));
	hri_gmac_write_WOL_reg(dev->hw, 0);
	hri_gmac_write_IPGS_reg(dev->hw, GMAC_IPGS_FL((CONF_GMAC_IPGS_FL_MUL << 8) | CONF_GMAC_IPGS_FL_DIV));
	_mac_init_bufdescr(dev);

	_gmac_dev = dev;
    867a:	6018      	str	r0, [r3, #0]
	_rxbuf_descrs[CONF_GMAC_RXDESCR_NUM - 1].address.bm.wrap = 1;
    867c:	f892 4360 	ldrb.w	r4, [r2, #864]	; 0x360
	_rxbuf_index                                             = 0;
    8680:	f8c2 7368 	str.w	r7, [r2, #872]	; 0x368
	_rxbuf_descrs[CONF_GMAC_RXDESCR_NUM - 1].address.bm.wrap = 1;
    8684:	f044 0402 	orr.w	r4, r4, #2
    8688:	f882 4360 	strb.w	r4, [r2, #864]	; 0x360
    NVIC->ICER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
    868c:	4b0d      	ldr	r3, [pc, #52]	; (86c4 <_mac_async_init+0xa8>)
	hri_gmac_write_TBQB_reg(dev->hw, (uint32_t)_txbuf_descrs);
    868e:	4a0e      	ldr	r2, [pc, #56]	; (86c8 <_mac_async_init+0xac>)
	((Gmac *)hw)->TBQB.reg = data;
    8690:	61ca      	str	r2, [r1, #28]
    8692:	f44f 1280 	mov.w	r2, #1048576	; 0x100000
	((Gmac *)hw)->RBQB.reg = data;
    8696:	618e      	str	r6, [r1, #24]
    8698:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88
  __ASM volatile ("dsb 0xF":::"memory");
    869c:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
    86a0:	f3bf 8f6f 	isb	sy
	NVIC_DisableIRQ(GMAC_IRQn);
	NVIC_ClearPendingIRQ(GMAC_IRQn);
	NVIC_EnableIRQ(GMAC_IRQn);

	return ERR_NONE;
}
    86a4:	2000      	movs	r0, #0
    NVIC->ICPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
    86a6:	f8c3 2188 	str.w	r2, [r3, #392]	; 0x188
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
    86aa:	609a      	str	r2, [r3, #8]
    86ac:	bdf0      	pop	{r4, r5, r6, r7, pc}
    86ae:	bf00      	nop
    86b0:	00100103 	.word	0x00100103
    86b4:	00020704 	.word	0x00020704
    86b8:	20014e00 	.word	0x20014e00
    86bc:	200161e0 	.word	0x200161e0
    86c0:	20015ef8 	.word	0x20015ef8
    86c4:	e000e100 	.word	0xe000e100
    86c8:	20014e08 	.word	0x20014e08

000086cc <_mac_async_enable>:
	return ERR_NONE;
}

int32_t _mac_async_enable(struct _mac_async_device *const dev)
{
	hri_gmac_set_NCR_reg(dev->hw, GMAC_NCR_RXEN | GMAC_NCR_TXEN);
    86cc:	6802      	ldr	r2, [r0, #0]
	((Gmac *)hw)->NCR.reg |= mask;
    86ce:	6813      	ldr	r3, [r2, #0]
    86d0:	f043 030c 	orr.w	r3, r3, #12
    86d4:	6013      	str	r3, [r2, #0]
	return ERR_NONE;
}
    86d6:	2000      	movs	r0, #0
    86d8:	4770      	bx	lr
	...

000086dc <_mac_async_write>:
	hri_gmac_clear_NCR_reg(dev->hw, GMAC_NCR_RXEN | GMAC_NCR_TXEN);
	return ERR_NONE;
}

int32_t _mac_async_write(struct _mac_async_device *const dev, uint8_t *buf, uint32_t len)
{
    86dc:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
	uint32_t pos;
	uint32_t blen;
	uint32_t i;

	if (_txbuf_descrs[_last_txbuf_index].status.bm.used && !_txbuf_descrs[_last_txbuf_index].status.bm.last_buf) {
    86e0:	4c3a      	ldr	r4, [pc, #232]	; (87cc <_mac_async_write+0xf0>)
    86e2:	f8d4 3bd8 	ldr.w	r3, [r4, #3032]	; 0xbd8
    86e6:	eb04 03c3 	add.w	r3, r4, r3, lsl #3
{
    86ea:	4680      	mov	r8, r0
	if (_txbuf_descrs[_last_txbuf_index].status.bm.used && !_txbuf_descrs[_last_txbuf_index].status.bm.last_buf) {
    86ec:	7bdb      	ldrb	r3, [r3, #15]
    86ee:	09db      	lsrs	r3, r3, #7
{
    86f0:	4616      	mov	r6, r2
	if (_txbuf_descrs[_last_txbuf_index].status.bm.used && !_txbuf_descrs[_last_txbuf_index].status.bm.last_buf) {
    86f2:	d012      	beq.n	871a <_mac_async_write+0x3e>
    86f4:	f8d4 3bd8 	ldr.w	r3, [r4, #3032]	; 0xbd8
    86f8:	eb04 03c3 	add.w	r3, r4, r3, lsl #3
    86fc:	7b5b      	ldrb	r3, [r3, #13]
    86fe:	09db      	lsrs	r3, r3, #7
    8700:	d10b      	bne.n	871a <_mac_async_write+0x3e>
		/* Set used flag from first descriptor to last descriptor,
		 * as DMA olny set the first used flag */
		for (i = 1; i < CONF_GMAC_TXDESCR_NUM; i++) {
			pos = _last_txbuf_index + i;
    8702:	f8d4 2bd8 	ldr.w	r2, [r4, #3032]	; 0xbd8
    8706:	1c53      	adds	r3, r2, #1
			if (pos >= CONF_GMAC_TXDESCR_NUM) {
    8708:	2b01      	cmp	r3, #1
    870a:	d900      	bls.n	870e <_mac_async_write+0x32>
				pos -= CONF_GMAC_TXDESCR_NUM;
    870c:	1e53      	subs	r3, r2, #1
			}
			_txbuf_descrs[pos].status.bm.used = 1;
    870e:	eb04 03c3 	add.w	r3, r4, r3, lsl #3
    8712:	7bda      	ldrb	r2, [r3, #15]
    8714:	f042 0280 	orr.w	r2, r2, #128	; 0x80
    8718:	73da      	strb	r2, [r3, #15]
				break;
			}
		}
	}

	if (!_txbuf_descrs[_txbuf_index].status.bm.used) {
    871a:	6863      	ldr	r3, [r4, #4]
    871c:	eb04 03c3 	add.w	r3, r4, r3, lsl #3
    8720:	7bdb      	ldrb	r3, [r3, #15]
    8722:	09db      	lsrs	r3, r3, #7
    8724:	d04e      	beq.n	87c4 <_mac_async_write+0xe8>
		return ERR_NO_RESOURCE;
	}

	/* Check if have enough buffers, the first buffer already checked */
	if (len > CONF_GMAC_TXBUF_SIZE) {
    8726:	f240 53dc 	movw	r3, #1500	; 0x5dc
    872a:	429e      	cmp	r6, r3
    872c:	d90a      	bls.n	8744 <_mac_async_write+0x68>
		for (i = 1; i < CONF_GMAC_TXDESCR_NUM; i++) {
			pos = _txbuf_index + i;
    872e:	6862      	ldr	r2, [r4, #4]
    8730:	1c53      	adds	r3, r2, #1
			if (pos >= CONF_GMAC_TXDESCR_NUM) {
    8732:	2b01      	cmp	r3, #1
				pos -= CONF_GMAC_TXDESCR_NUM;
    8734:	bf88      	it	hi
    8736:	f102 33ff 	addhi.w	r3, r2, #4294967295	; 0xffffffff
			}

			if (!_txbuf_descrs[pos].status.bm.used) {
    873a:	eb04 03c3 	add.w	r3, r4, r3, lsl #3
    873e:	7bdb      	ldrb	r3, [r3, #15]
    8740:	09db      	lsrs	r3, r3, #7
    8742:	d03f      	beq.n	87c4 <_mac_async_write+0xe8>
			if ((len - (CONF_GMAC_TXBUF_SIZE * i)) < CONF_GMAC_TXBUF_SIZE) {
				break;
			}
		}
	}
	_last_txbuf_index = _txbuf_index;
    8744:	6863      	ldr	r3, [r4, #4]
    8746:	f8c4 3bd8 	str.w	r3, [r4, #3032]	; 0xbd8

	/* Write data to transmit buffer */
	for (i = 0; i < CONF_GMAC_TXDESCR_NUM; i++) {
		blen = min(len, CONF_GMAC_TXBUF_SIZE);
		memcpy(_txbuf[_txbuf_index], buf + (i * CONF_GMAC_TXBUF_SIZE), blen);
    874a:	f8df b088 	ldr.w	fp, [pc, #136]	; 87d4 <_mac_async_write+0xf8>
    874e:	4b20      	ldr	r3, [pc, #128]	; (87d0 <_mac_async_write+0xf4>)
    8750:	460d      	mov	r5, r1
    8752:	f601 3ab8 	addw	sl, r1, #3000	; 0xbb8
		blen = min(len, CONF_GMAC_TXBUF_SIZE);
    8756:	f240 59dc 	movw	r9, #1500	; 0x5dc
    875a:	454e      	cmp	r6, r9
		memcpy(_txbuf[_txbuf_index], buf + (i * CONF_GMAC_TXBUF_SIZE), blen);
    875c:	6860      	ldr	r0, [r4, #4]
		blen = min(len, CONF_GMAC_TXBUF_SIZE);
    875e:	4637      	mov	r7, r6
    8760:	bf28      	it	cs
    8762:	464f      	movcs	r7, r9
		memcpy(_txbuf[_txbuf_index], buf + (i * CONF_GMAC_TXBUF_SIZE), blen);
    8764:	4629      	mov	r1, r5
    8766:	463a      	mov	r2, r7
    8768:	fb09 b000 	mla	r0, r9, r0, fp
    876c:	4798      	blx	r3
		len -= blen;

		if (len > 0) {
			/* Here the Used flag be set to zero */
			_txbuf_descrs[_txbuf_index].status.val = blen;
    876e:	6862      	ldr	r2, [r4, #4]
		if (len > 0) {
    8770:	4b17      	ldr	r3, [pc, #92]	; (87d0 <_mac_async_write+0xf4>)
			_txbuf_descrs[_txbuf_index].status.val = blen;
    8772:	eb04 02c2 	add.w	r2, r4, r2, lsl #3
		if (len > 0) {
    8776:	1bf6      	subs	r6, r6, r7
			_txbuf_descrs[_txbuf_index].status.val = blen;
    8778:	60d7      	str	r7, [r2, #12]
		} else {
			_txbuf_descrs[_txbuf_index].status.val         = blen;
			_txbuf_descrs[_txbuf_index].status.bm.last_buf = 1;
    877a:	bf01      	itttt	eq
    877c:	6862      	ldreq	r2, [r4, #4]
    877e:	eb04 02c2 	addeq.w	r2, r4, r2, lsl #3
    8782:	7b51      	ldrbeq	r1, [r2, #13]
    8784:	f041 0180 	orreq.w	r1, r1, #128	; 0x80
    8788:	bf08      	it	eq
    878a:	7351      	strbeq	r1, [r2, #13]
		}
		_txbuf_index++;
    878c:	6862      	ldr	r2, [r4, #4]
    878e:	3201      	adds	r2, #1
    8790:	6062      	str	r2, [r4, #4]
		if (_txbuf_index == CONF_GMAC_TXDESCR_NUM) {
    8792:	6862      	ldr	r2, [r4, #4]
    8794:	2a02      	cmp	r2, #2
    8796:	d105      	bne.n	87a4 <_mac_async_write+0xc8>
			_txbuf_index                                            = 0;
    8798:	2200      	movs	r2, #0
    879a:	6062      	str	r2, [r4, #4]
			_txbuf_descrs[CONF_GMAC_TXDESCR_NUM - 1].status.bm.wrap = 1;
    879c:	7de2      	ldrb	r2, [r4, #23]
    879e:	f042 0240 	orr.w	r2, r2, #64	; 0x40
    87a2:	75e2      	strb	r2, [r4, #23]
		}
		if (len == 0) {
    87a4:	b11e      	cbz	r6, 87ae <_mac_async_write+0xd2>
	for (i = 0; i < CONF_GMAC_TXDESCR_NUM; i++) {
    87a6:	f205 55dc 	addw	r5, r5, #1500	; 0x5dc
    87aa:	45aa      	cmp	sl, r5
    87ac:	d1d5      	bne.n	875a <_mac_async_write+0x7e>
  __ASM volatile ("dsb 0xF":::"memory");
    87ae:	f3bf 8f4f 	dsb	sy

	/* Data synchronization barrier */
	__DSB();

	/* Active Transmit */
	hri_gmac_set_NCR_reg(dev->hw, GMAC_NCR_TSTART);
    87b2:	f8d8 2000 	ldr.w	r2, [r8]
    87b6:	6813      	ldr	r3, [r2, #0]
    87b8:	f443 7300 	orr.w	r3, r3, #512	; 0x200
    87bc:	6013      	str	r3, [r2, #0]

	return ERR_NONE;
    87be:	2000      	movs	r0, #0
}
    87c0:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
		return ERR_NO_RESOURCE;
    87c4:	f06f 001b 	mvn.w	r0, #27
    87c8:	e7fa      	b.n	87c0 <_mac_async_write+0xe4>
    87ca:	bf00      	nop
    87cc:	20014e00 	.word	0x20014e00
    87d0:	0000a349 	.word	0x0000a349
    87d4:	20014e20 	.word	0x20014e20

000087d8 <_mac_async_read>:

uint32_t _mac_async_read(struct _mac_async_device *const dev, uint8_t *buf, uint32_t len)
{
    87d8:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
	uint32_t eof       = 0xFFFFFFFF; /* End of Frame index */
	uint32_t total_len = 0;          /* Total length of received package */

	(void)dev;
	for (i = 0; i < CONF_GMAC_RXDESCR_NUM; i++) {
		pos = _rxbuf_index + i;
    87dc:	4d35      	ldr	r5, [pc, #212]	; (88b4 <_mac_async_read+0xdc>)
{
    87de:	460b      	mov	r3, r1
    87e0:	4616      	mov	r6, r2
	uint32_t sof       = 0xFFFFFFFF; /* Start of Frame index */
    87e2:	f04f 37ff 	mov.w	r7, #4294967295	; 0xffffffff
	for (i = 0; i < CONF_GMAC_RXDESCR_NUM; i++) {
    87e6:	2400      	movs	r4, #0
		pos = _rxbuf_index + i;
    87e8:	f8d5 2368 	ldr.w	r2, [r5, #872]	; 0x368
    87ec:	4422      	add	r2, r4

		if (pos >= CONF_GMAC_RXDESCR_NUM) {
    87ee:	2a0f      	cmp	r2, #15
			pos -= CONF_GMAC_RXDESCR_NUM;
    87f0:	bf88      	it	hi
    87f2:	3a10      	subhi	r2, #16
		}

		/* No more data for Ethernet package */
		if (!_rxbuf_descrs[pos].address.bm.ownership) {
    87f4:	eb05 02c2 	add.w	r2, r5, r2, lsl #3
    87f8:	f892 12e8 	ldrb.w	r1, [r2, #744]	; 0x2e8
    87fc:	07c9      	lsls	r1, r1, #31
    87fe:	d51f      	bpl.n	8840 <_mac_async_read+0x68>
			break;
		}

		if (_rxbuf_descrs[pos].status.bm.sof) {
    8800:	f892 12ed 	ldrb.w	r1, [r2, #749]	; 0x2ed
    8804:	f011 0f40 	tst.w	r1, #64	; 0x40
    8808:	bf18      	it	ne
    880a:	4627      	movne	r7, r4
			sof = i;
		}

		if ((_rxbuf_descrs[pos].status.bm.eof) && (sof != 0xFFFFFFFF)) {
    880c:	09c9      	lsrs	r1, r1, #7
    880e:	f104 0801 	add.w	r8, r4, #1
    8812:	d012      	beq.n	883a <_mac_async_read+0x62>
    8814:	1c78      	adds	r0, r7, #1
    8816:	d010      	beq.n	883a <_mac_async_read+0x62>
			/* eof now indicate the number of bufs the frame used */
			eof = i;
			n   = _rxbuf_descrs[pos].status.bm.len;
    8818:	f8b2 22ec 	ldrh.w	r2, [r2, #748]	; 0x2ec
    881c:	f3c2 020c 	ubfx	r2, r2, #0, #13
			len = min(n, len);
    8820:	4296      	cmp	r6, r2
    8822:	bf28      	it	cs
    8824:	4616      	movcs	r6, r2
	uint32_t total_len = 0;          /* Total length of received package */
    8826:	f04f 0900 	mov.w	r9, #0
	} else {
		j = i;
	}

	/* Copy data to user buffer */
	for (i = 0; i < j; i++) {
    882a:	46ca      	mov	sl, r9

		_rxbuf_descrs[_rxbuf_index].address.bm.ownership = 0;
		_rxbuf_index++;

		if (_rxbuf_index == CONF_GMAC_RXDESCR_NUM) {
			_rxbuf_index = 0;
    882c:	46cb      	mov	fp, r9
	for (i = 0; i < j; i++) {
    882e:	45c2      	cmp	sl, r8
    8830:	d10e      	bne.n	8850 <_mac_async_read+0x78>
		}
	}

	return total_len;
}
    8832:	4648      	mov	r0, r9
    8834:	b003      	add	sp, #12
    8836:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	for (i = 0; i < CONF_GMAC_RXDESCR_NUM; i++) {
    883a:	4644      	mov	r4, r8
    883c:	2c10      	cmp	r4, #16
    883e:	d1d3      	bne.n	87e8 <_mac_async_read+0x10>
	} else if (sof != 0xFFFFFFFF) {
    8840:	1c7a      	adds	r2, r7, #1
    8842:	d101      	bne.n	8848 <_mac_async_read+0x70>
    8844:	46a0      	mov	r8, r4
    8846:	e000      	b.n	884a <_mac_async_read+0x72>
    8848:	46b8      	mov	r8, r7
    884a:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
    884e:	e7ea      	b.n	8826 <_mac_async_read+0x4e>
		if (eof != 0xFFFFFFFF && i >= sof && i <= eof && len > 0) {
    8850:	1c61      	adds	r1, r4, #1
    8852:	d016      	beq.n	8882 <_mac_async_read+0xaa>
    8854:	45ba      	cmp	sl, r7
    8856:	d314      	bcc.n	8882 <_mac_async_read+0xaa>
    8858:	45a2      	cmp	sl, r4
    885a:	d812      	bhi.n	8882 <_mac_async_read+0xaa>
    885c:	b18e      	cbz	r6, 8882 <_mac_async_read+0xaa>
			memcpy(buf, _rxbuf[_rxbuf_index], n);
    885e:	f8d5 1368 	ldr.w	r1, [r5, #872]	; 0x368
    8862:	4815      	ldr	r0, [pc, #84]	; (88b8 <_mac_async_read+0xe0>)
			n = min(len, CONF_GMAC_RXBUF_SIZE);
    8864:	2e80      	cmp	r6, #128	; 0x80
    8866:	4632      	mov	r2, r6
			memcpy(buf, _rxbuf[_rxbuf_index], n);
    8868:	eb00 11c1 	add.w	r1, r0, r1, lsl #7
			n = min(len, CONF_GMAC_RXBUF_SIZE);
    886c:	bf28      	it	cs
    886e:	2280      	movcs	r2, #128	; 0x80
			memcpy(buf, _rxbuf[_rxbuf_index], n);
    8870:	4618      	mov	r0, r3
    8872:	4b12      	ldr	r3, [pc, #72]	; (88bc <_mac_async_read+0xe4>)
    8874:	9201      	str	r2, [sp, #4]
    8876:	4798      	blx	r3
			buf += n;
    8878:	9a01      	ldr	r2, [sp, #4]
			memcpy(buf, _rxbuf[_rxbuf_index], n);
    887a:	4603      	mov	r3, r0
			buf += n;
    887c:	4413      	add	r3, r2
			total_len += n;
    887e:	4491      	add	r9, r2
			len -= n;
    8880:	1ab6      	subs	r6, r6, r2
		_rxbuf_descrs[_rxbuf_index].address.bm.ownership = 0;
    8882:	f8d5 2368 	ldr.w	r2, [r5, #872]	; 0x368
    8886:	eb05 02c2 	add.w	r2, r5, r2, lsl #3
	for (i = 0; i < j; i++) {
    888a:	f10a 0a01 	add.w	sl, sl, #1
		_rxbuf_descrs[_rxbuf_index].address.bm.ownership = 0;
    888e:	f892 12e8 	ldrb.w	r1, [r2, #744]	; 0x2e8
    8892:	f36f 0100 	bfc	r1, #0, #1
    8896:	f882 12e8 	strb.w	r1, [r2, #744]	; 0x2e8
		_rxbuf_index++;
    889a:	f8d5 2368 	ldr.w	r2, [r5, #872]	; 0x368
    889e:	3201      	adds	r2, #1
    88a0:	f8c5 2368 	str.w	r2, [r5, #872]	; 0x368
		if (_rxbuf_index == CONF_GMAC_RXDESCR_NUM) {
    88a4:	f8d5 2368 	ldr.w	r2, [r5, #872]	; 0x368
    88a8:	2a10      	cmp	r2, #16
			_rxbuf_index = 0;
    88aa:	bf08      	it	eq
    88ac:	f8c5 b368 	streq.w	fp, [r5, #872]	; 0x368
	for (i = 0; i < j; i++) {
    88b0:	e7bd      	b.n	882e <_mac_async_read+0x56>
    88b2:	bf00      	nop
    88b4:	20015ef8 	.word	0x20015ef8
    88b8:	200159e0 	.word	0x200159e0
    88bc:	0000a349 	.word	0x0000a349

000088c0 <_mac_async_read_len>:
uint32_t _mac_async_read_len(struct _mac_async_device *const dev)
{
	uint32_t i;
	uint32_t pos;
	bool     sof       = false; /* Start of Frame */
	uint32_t total_len = 0;     /* Total length of received package */
    88c0:	2000      	movs	r0, #0

	(void)dev;

	for (i = 0; i < CONF_GMAC_RXDESCR_NUM; i++) {
		pos = _rxbuf_index + i;
    88c2:	4913      	ldr	r1, [pc, #76]	; (8910 <_mac_async_read_len+0x50>)
{
    88c4:	b570      	push	{r4, r5, r6, lr}
	for (i = 0; i < CONF_GMAC_RXDESCR_NUM; i++) {
    88c6:	4602      	mov	r2, r0
	bool     sof       = false; /* Start of Frame */
    88c8:	4606      	mov	r6, r0
		pos = _rxbuf_index + i;
    88ca:	f8d1 3368 	ldr.w	r3, [r1, #872]	; 0x368
    88ce:	4413      	add	r3, r2

		if (pos >= CONF_GMAC_RXDESCR_NUM) {
    88d0:	2b0f      	cmp	r3, #15
			pos -= CONF_GMAC_RXDESCR_NUM;
    88d2:	bf88      	it	hi
    88d4:	3b10      	subhi	r3, #16
		}

		/* No more data for Ethernet package */
		if (!(_rxbuf_descrs[pos].address.bm.ownership)) {
    88d6:	00dc      	lsls	r4, r3, #3
    88d8:	eb01 03c3 	add.w	r3, r1, r3, lsl #3
    88dc:	f893 52e8 	ldrb.w	r5, [r3, #744]	; 0x2e8
    88e0:	f015 0501 	ands.w	r5, r5, #1
    88e4:	d013      	beq.n	890e <_mac_async_read_len+0x4e>
			break;
		}

		if (_rxbuf_descrs[pos].status.bm.sof) {
    88e6:	f893 32ed 	ldrb.w	r3, [r3, #749]	; 0x2ed
    88ea:	065b      	lsls	r3, r3, #25
    88ec:	d400      	bmi.n	88f0 <_mac_async_read_len+0x30>
			sof = true;
		}
		if (sof == true) {
    88ee:	b136      	cbz	r6, 88fe <_mac_async_read_len+0x3e>
			total_len += _rxbuf_descrs[pos].status.bm.len;
    88f0:	190b      	adds	r3, r1, r4
    88f2:	462e      	mov	r6, r5
    88f4:	f8b3 32ec 	ldrh.w	r3, [r3, #748]	; 0x2ec
    88f8:	f3c3 030c 	ubfx	r3, r3, #0, #13
    88fc:	4418      	add	r0, r3
		}

		if (_rxbuf_descrs[pos].status.bm.eof) {
    88fe:	440c      	add	r4, r1
    8900:	f894 32ed 	ldrb.w	r3, [r4, #749]	; 0x2ed
    8904:	09db      	lsrs	r3, r3, #7
    8906:	d102      	bne.n	890e <_mac_async_read_len+0x4e>
	for (i = 0; i < CONF_GMAC_RXDESCR_NUM; i++) {
    8908:	3201      	adds	r2, #1
    890a:	2a10      	cmp	r2, #16
    890c:	d1dd      	bne.n	88ca <_mac_async_read_len+0xa>
			break;
		}
	}

	return total_len;
}
    890e:	bd70      	pop	{r4, r5, r6, pc}
    8910:	20015ef8 	.word	0x20015ef8

00008914 <_mac_async_register_callback>:
}

int32_t _mac_async_register_callback(struct _mac_async_device *const dev, const enum mac_async_cb_type type,
                                     const FUNC_PTR func)
{
	switch (type) {
    8914:	b151      	cbz	r1, 892c <_mac_async_register_callback+0x18>
    8916:	2901      	cmp	r1, #1
    8918:	d10d      	bne.n	8936 <_mac_async_register_callback+0x22>
	case MAC_ASYNC_TRANSMIT_CB:
		dev->cb.transmited = (_mac_async_cb_t)func;
		if (func) {
			hri_gmac_set_IMR_TCOMP_bit(dev->hw);
    891a:	6803      	ldr	r3, [r0, #0]
		dev->cb.transmited = (_mac_async_cb_t)func;
    891c:	6042      	str	r2, [r0, #4]
		if (func) {
    891e:	2180      	movs	r1, #128	; 0x80
    8920:	b112      	cbz	r2, 8928 <_mac_async_register_callback+0x14>
	((Gmac *)hw)->IER.reg = GMAC_IMR_TCOMP;
    8922:	6299      	str	r1, [r3, #40]	; 0x28
		}
		break;
	default:
		return ERR_INVALID_ARG;
	}
	return ERR_NONE;
    8924:	2000      	movs	r0, #0
}
    8926:	4770      	bx	lr
	((Gmac *)hw)->IDR.reg = GMAC_IMR_TCOMP;
    8928:	62d9      	str	r1, [r3, #44]	; 0x2c
    892a:	e7fb      	b.n	8924 <_mac_async_register_callback+0x10>
			hri_gmac_set_IMR_TCOMP_bit(dev->hw);
    892c:	6803      	ldr	r3, [r0, #0]
		dev->cb.received = (_mac_async_cb_t)func;
    892e:	6082      	str	r2, [r0, #8]
		if (func) {
    8930:	2002      	movs	r0, #2
	((Gmac *)hw)->IER.reg = GMAC_IMR_RCOMP;
    8932:	6298      	str	r0, [r3, #40]	; 0x28
    8934:	e7f6      	b.n	8924 <_mac_async_register_callback+0x10>
	switch (type) {
    8936:	f06f 000c 	mvn.w	r0, #12
}
    893a:	4770      	bx	lr

0000893c <_mac_async_set_filter>:

int32_t _mac_async_set_filter(struct _mac_async_device *const dev, uint8_t index, struct mac_async_filter *filter)
{
    893c:	b570      	push	{r4, r5, r6, lr}
    893e:	460c      	mov	r4, r1
    8940:	4606      	mov	r6, r0
	ASSERT(index < 4);
    8942:	2c03      	cmp	r4, #3
{
    8944:	4615      	mov	r5, r2
	ASSERT(index < 4);
    8946:	bf8c      	ite	hi
    8948:	2000      	movhi	r0, #0
    894a:	2001      	movls	r0, #1
    894c:	4909      	ldr	r1, [pc, #36]	; (8974 <_mac_async_set_filter+0x38>)
    894e:	4b0a      	ldr	r3, [pc, #40]	; (8978 <_mac_async_set_filter+0x3c>)
    8950:	f240 12cf 	movw	r2, #463	; 0x1cf
    8954:	4798      	blx	r3

	hri_gmac_write_SAB_reg(dev->hw, index, *((uint32_t *)(filter->mac)));
    8956:	6833      	ldr	r3, [r6, #0]
    8958:	6829      	ldr	r1, [r5, #0]
	((Gmac *)hw)->Sa[submodule_index].SAB.reg = data;
    895a:	eb03 02c4 	add.w	r2, r3, r4, lsl #3
	((Gmac *)hw)->TIDM[index].reg = data;
    895e:	342a      	adds	r4, #42	; 0x2a
	((Gmac *)hw)->Sa[submodule_index].SAB.reg = data;
    8960:	f8c2 1088 	str.w	r1, [r2, #136]	; 0x88
	hri_gmac_write_SAT_reg(dev->hw, index, *((uint16_t *)(filter->mac + 4)));
    8964:	88a9      	ldrh	r1, [r5, #4]
	((Gmac *)hw)->Sa[submodule_index].SAT.reg = data;
    8966:	f8c2 108c 	str.w	r1, [r2, #140]	; 0x8c

	hri_gmac_write_TIDM_reg(dev->hw, index, GMAC_TIDM_TID(*((uint16_t *)(filter->tid)) | filter->tid_enable << 31));
    896a:	88ea      	ldrh	r2, [r5, #6]
	((Gmac *)hw)->TIDM[index].reg = data;
    896c:	f843 2024 	str.w	r2, [r3, r4, lsl #2]
	return ERR_NONE;
}
    8970:	2000      	movs	r0, #0
    8972:	bd70      	pop	{r4, r5, r6, pc}
    8974:	0000b8fe 	.word	0x0000b8fe
    8978:	00008a15 	.word	0x00008a15

0000897c <_mac_async_read_phy_reg>:
	return ERR_NONE;
}

int32_t _mac_async_read_phy_reg(struct _mac_async_device *const dev, uint16_t addr, uint16_t reg, uint16_t *data)
{
	hri_gmac_set_NCR_reg(dev->hw, GMAC_NCR_MPE);
    897c:	6800      	ldr	r0, [r0, #0]
	hri_gmac_write_MAN_reg(dev->hw,
	                       GMAC_MAN_OP(2) |            /* 0x02 read operation */
	                           CONF_GMAC_CLTTO << 30 | /* Clause 22/45 operation */
	                           GMAC_MAN_WTN(0x2) |     /* Must be written to 0x2 */
	                           GMAC_MAN_PHYA(addr) | GMAC_MAN_REGA(reg));
    897e:	05c9      	lsls	r1, r1, #23
    8980:	0492      	lsls	r2, r2, #18
    8982:	f001 6178 	and.w	r1, r1, #260046848	; 0xf800000
    8986:	f402 02f8 	and.w	r2, r2, #8126464	; 0x7c0000
{
    898a:	b510      	push	{r4, lr}
	                           GMAC_MAN_PHYA(addr) | GMAC_MAN_REGA(reg));
    898c:	4311      	orrs	r1, r2
	((Gmac *)hw)->NCR.reg |= mask;
    898e:	6804      	ldr	r4, [r0, #0]
    8990:	f041 41c0 	orr.w	r1, r1, #1610612736	; 0x60000000
    8994:	f044 0410 	orr.w	r4, r4, #16
    8998:	f441 3100 	orr.w	r1, r1, #131072	; 0x20000
    899c:	6004      	str	r4, [r0, #0]
	((Gmac *)hw)->MAN.reg = data;
    899e:	6341      	str	r1, [r0, #52]	; 0x34
	return (((Gmac *)hw)->NSR.reg & GMAC_NSR_IDLE) >> GMAC_NSR_IDLE_Pos;
    89a0:	6882      	ldr	r2, [r0, #8]

	/* Wait for the read operation complete */
	while (!hri_gmac_get_NSR_IDLE_bit(dev->hw)) {
    89a2:	0752      	lsls	r2, r2, #29
    89a4:	d5fc      	bpl.n	89a0 <_mac_async_read_phy_reg+0x24>
	return ((Gmac *)hw)->MAN.reg;
    89a6:	6b42      	ldr	r2, [r0, #52]	; 0x34
	}

	*data = GMAC_MAN_DATA(hri_gmac_read_MAN_reg(dev->hw));
    89a8:	801a      	strh	r2, [r3, #0]
	((Gmac *)hw)->NCR.reg &= ~mask;
    89aa:	6803      	ldr	r3, [r0, #0]
    89ac:	f023 0310 	bic.w	r3, r3, #16
    89b0:	6003      	str	r3, [r0, #0]
	hri_gmac_clear_NCR_reg(dev->hw, GMAC_NCR_MPE);

	return ERR_NONE;
}
    89b2:	2000      	movs	r0, #0
    89b4:	bd10      	pop	{r4, pc}
	...

000089b8 <_write>:
#include <stdio.h>

int __attribute__((weak)) _write(int file, char *ptr, int len); /* Remove GCC compiler warning */

int __attribute__((weak)) _write(int file, char *ptr, int len)
{
    89b8:	b508      	push	{r3, lr}
    89ba:	4603      	mov	r3, r0
	int n = 0;

	if ((file != 1) && (file != 2) && (file != 3)) {
    89bc:	3b01      	subs	r3, #1
    89be:	2b02      	cmp	r3, #2
{
    89c0:	4608      	mov	r0, r1
    89c2:	4611      	mov	r1, r2
	if ((file != 1) && (file != 2) && (file != 3)) {
    89c4:	d804      	bhi.n	89d0 <_write+0x18>
		return -1;
	}

	n = stdio_io_write((const uint8_t *)ptr, len);
    89c6:	4b04      	ldr	r3, [pc, #16]	; (89d8 <_write+0x20>)
    89c8:	4798      	blx	r3
	if (n < 0) {
    89ca:	ea40 70e0 	orr.w	r0, r0, r0, asr #31
		return -1;
	}

	return n;
}
    89ce:	bd08      	pop	{r3, pc}
		return -1;
    89d0:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    89d4:	e7fb      	b.n	89ce <_write+0x16>
    89d6:	bf00      	nop
    89d8:	000002ed 	.word	0x000002ed

000089dc <RAMECC_Handler>:
	return tmp;
}

static inline hri_ramecc_intflag_reg_t hri_ramecc_read_INTFLAG_reg(const void *const hw)
{
	return ((Ramecc *)hw)->INTFLAG.reg;
    89dc:	4a0b      	ldr	r2, [pc, #44]	; (8a0c <RAMECC_Handler+0x30>)
    89de:	7893      	ldrb	r3, [r2, #2]

/**
 * \internal RAMECC interrupt handler
 */
void RAMECC_Handler(void)
{
    89e0:	b082      	sub	sp, #8
    89e2:	b2db      	uxtb	r3, r3
	struct _ramecc_device *dev      = (struct _ramecc_device *)&device;
	volatile uint32_t      int_mask = hri_ramecc_read_INTFLAG_reg(RAMECC);
    89e4:	9301      	str	r3, [sp, #4]

	if (int_mask & RAMECC_INTFLAG_DUALE && dev->ramecc_cb.dual_bit_err) {
    89e6:	9b01      	ldr	r3, [sp, #4]
    89e8:	0799      	lsls	r1, r3, #30
    89ea:	d505      	bpl.n	89f8 <RAMECC_Handler+0x1c>
    89ec:	4b08      	ldr	r3, [pc, #32]	; (8a10 <RAMECC_Handler+0x34>)
    89ee:	681b      	ldr	r3, [r3, #0]
    89f0:	b113      	cbz	r3, 89f8 <RAMECC_Handler+0x1c>
	return tmp;
}

static inline hri_ramecc_erraddr_reg_t hri_ramecc_read_ERRADDR_reg(const void *const hw)
{
	return ((Ramecc *)hw)->ERRADDR.reg;
    89f2:	6850      	ldr	r0, [r2, #4]
	} else if (int_mask & RAMECC_INTFLAG_SINGLEE && dev->ramecc_cb.single_bit_err) {
		dev->ramecc_cb.single_bit_err((uint32_t)hri_ramecc_read_ERRADDR_reg(RAMECC));
	} else {
		return;
	}
}
    89f4:	b002      	add	sp, #8
		dev->ramecc_cb.single_bit_err((uint32_t)hri_ramecc_read_ERRADDR_reg(RAMECC));
    89f6:	4718      	bx	r3
	} else if (int_mask & RAMECC_INTFLAG_SINGLEE && dev->ramecc_cb.single_bit_err) {
    89f8:	9b01      	ldr	r3, [sp, #4]
    89fa:	07db      	lsls	r3, r3, #31
    89fc:	d504      	bpl.n	8a08 <RAMECC_Handler+0x2c>
    89fe:	4b04      	ldr	r3, [pc, #16]	; (8a10 <RAMECC_Handler+0x34>)
    8a00:	685b      	ldr	r3, [r3, #4]
    8a02:	b10b      	cbz	r3, 8a08 <RAMECC_Handler+0x2c>
    8a04:	4a01      	ldr	r2, [pc, #4]	; (8a0c <RAMECC_Handler+0x30>)
    8a06:	e7f4      	b.n	89f2 <RAMECC_Handler+0x16>
}
    8a08:	b002      	add	sp, #8
    8a0a:	4770      	bx	lr
    8a0c:	41020000 	.word	0x41020000
    8a10:	20016264 	.word	0x20016264

00008a14 <assert>:
/**
 * \brief Assert function
 */
void assert(const bool condition, const char *const file, const int line)
{
	if (!(condition)) {
    8a14:	b900      	cbnz	r0, 8a18 <assert+0x4>
		__asm("BKPT #0");
    8a16:	be00      	bkpt	0x0000
	}
	(void)file;
	(void)line;
}
    8a18:	4770      	bx	lr

00008a1a <ip4_addr_isbroadcast>:
{
	ip_addr_t ipaddr;
	ip4_addr_set_u32(&ipaddr, addr);

	/* all ones (broadcast) or all zeroes (old skool broadcast) */
	if ((~addr == IPADDR_ANY) || (addr == IPADDR_ANY)) {
    8a1a:	1e43      	subs	r3, r0, #1
    8a1c:	3303      	adds	r3, #3
{
    8a1e:	4602      	mov	r2, r0
	if ((~addr == IPADDR_ANY) || (addr == IPADDR_ANY)) {
    8a20:	d812      	bhi.n	8a48 <ip4_addr_isbroadcast+0x2e>
		return 1;
		/* no broadcast support on this network interface? */
	} else if ((netif->flags & NETIF_FLAG_BROADCAST) == 0) {
    8a22:	f891 3031 	ldrb.w	r3, [r1, #49]	; 0x31
    8a26:	f013 0002 	ands.w	r0, r3, #2
    8a2a:	d010      	beq.n	8a4e <ip4_addr_isbroadcast+0x34>
		/* the given address cannot be a broadcast address
		 * nor can we check against any broadcast addresses */
		return 0;
		/* address matches network interface address exactly? => no broadcast */
	} else if (addr == ip4_addr_get_u32(&netif->ip_addr)) {
    8a2c:	684b      	ldr	r3, [r1, #4]
    8a2e:	4293      	cmp	r3, r2
    8a30:	d00c      	beq.n	8a4c <ip4_addr_isbroadcast+0x32>
		return 0;
		/*  on the same (sub) network... */
	} else if (ip_addr_netcmp(&ipaddr, &(netif->ip_addr), &(netif->netmask))
    8a32:	6888      	ldr	r0, [r1, #8]
    8a34:	4053      	eors	r3, r2
    8a36:	4203      	tst	r3, r0
    8a38:	d108      	bne.n	8a4c <ip4_addr_isbroadcast+0x32>
	           /* ...and host identifier bits are all ones? =>... */
	           && ((addr & ~ip4_addr_get_u32(&netif->netmask))
    8a3a:	43c3      	mvns	r3, r0
    8a3c:	ea22 0000 	bic.w	r0, r2, r0
	               == (IPADDR_BROADCAST & ~ip4_addr_get_u32(&netif->netmask)))) {
		/* => network broadcast address */
		return 1;
	} else {
		return 0;
    8a40:	1ac3      	subs	r3, r0, r3
    8a42:	4258      	negs	r0, r3
    8a44:	4158      	adcs	r0, r3
    8a46:	4770      	bx	lr
		return 1;
    8a48:	2001      	movs	r0, #1
    8a4a:	4770      	bx	lr
		return 0;
    8a4c:	2000      	movs	r0, #0
	}
}
    8a4e:	4770      	bx	lr

00008a50 <ipaddr_ntoa_r>:
 * @param buflen length of buf
 * @return either pointer to buf which now holds the ASCII
 *         representation of addr or NULL if buf was too small
 */
char *ipaddr_ntoa_r(const ip_addr_t *addr, char *buf, int buflen)
{
    8a50:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
	u8_t  rem;
	u8_t  n;
	u8_t  i;
	int   len = 0;

	s_addr = ip4_addr_get_u32(addr);
    8a54:	6803      	ldr	r3, [r0, #0]
    8a56:	9301      	str	r3, [sp, #4]

	rp = buf;
	ap = (u8_t *)&s_addr;
	for (n = 0; n < 4; n++) {
    8a58:	f10d 0c04 	add.w	ip, sp, #4
	rp = buf;
    8a5c:	460d      	mov	r5, r1
	s_addr = ip4_addr_get_u32(addr);
    8a5e:	2004      	movs	r0, #4
	int   len = 0;
    8a60:	2600      	movs	r6, #0
		i = 0;
		do {
			rem = *ap % (u8_t)10;
    8a62:	f04f 0e0a 	mov.w	lr, #10
			*rp++ = inv[i];
		}
		if (len++ >= buflen) {
			return NULL;
		}
		*rp++ = '.';
    8a66:	f04f 082e 	mov.w	r8, #46	; 0x2e
    8a6a:	f81c 4b01 	ldrb.w	r4, [ip], #1
		i = 0;
    8a6e:	2700      	movs	r7, #0
			rem = *ap % (u8_t)10;
    8a70:	fbb4 f3fe 	udiv	r3, r4, lr
    8a74:	46a2      	mov	sl, r4
    8a76:	fb0e 4913 	mls	r9, lr, r3, r4
			*ap /= (u8_t)10;
    8a7a:	b2dc      	uxtb	r4, r3
			inv[i++] = '0' + rem;
    8a7c:	463b      	mov	r3, r7
    8a7e:	f103 0b08 	add.w	fp, r3, #8
    8a82:	44eb      	add	fp, sp
    8a84:	3701      	adds	r7, #1
    8a86:	f109 0930 	add.w	r9, r9, #48	; 0x30
		} while (*ap);
    8a8a:	f1ba 0f09 	cmp.w	sl, #9
			inv[i++] = '0' + rem;
    8a8e:	b2ff      	uxtb	r7, r7
    8a90:	f80b 9c08 	strb.w	r9, [fp, #-8]
		} while (*ap);
    8a94:	d8ec      	bhi.n	8a70 <ipaddr_ntoa_r+0x20>
    8a96:	f80c 4c01 	strb.w	r4, [ip, #-1]
    8a9a:	4637      	mov	r7, r6
    8a9c:	462c      	mov	r4, r5
		while (i--) {
    8a9e:	2bff      	cmp	r3, #255	; 0xff
			if (len++ >= buflen) {
    8aa0:	f106 0601 	add.w	r6, r6, #1
		while (i--) {
    8aa4:	d10d      	bne.n	8ac2 <ipaddr_ntoa_r+0x72>
		if (len++ >= buflen) {
    8aa6:	4297      	cmp	r7, r2
    8aa8:	da18      	bge.n	8adc <ipaddr_ntoa_r+0x8c>
		*rp++ = '.';
    8aaa:	4625      	mov	r5, r4
	for (n = 0; n < 4; n++) {
    8aac:	3801      	subs	r0, #1
    8aae:	f010 00ff 	ands.w	r0, r0, #255	; 0xff
		*rp++ = '.';
    8ab2:	f805 8b01 	strb.w	r8, [r5], #1
	for (n = 0; n < 4; n++) {
    8ab6:	d1d8      	bne.n	8a6a <ipaddr_ntoa_r+0x1a>
		ap++;
	}
	*--rp = 0;
    8ab8:	7020      	strb	r0, [r4, #0]
	return buf;
    8aba:	4608      	mov	r0, r1
}
    8abc:	b003      	add	sp, #12
    8abe:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
			if (len++ >= buflen) {
    8ac2:	1e5d      	subs	r5, r3, #1
    8ac4:	4297      	cmp	r7, r2
    8ac6:	b2ed      	uxtb	r5, r5
    8ac8:	da08      	bge.n	8adc <ipaddr_ntoa_r+0x8c>
			*rp++ = inv[i];
    8aca:	3308      	adds	r3, #8
    8acc:	446b      	add	r3, sp
			if (len++ >= buflen) {
    8ace:	4637      	mov	r7, r6
			*rp++ = inv[i];
    8ad0:	f813 3c08 	ldrb.w	r3, [r3, #-8]
    8ad4:	f804 3b01 	strb.w	r3, [r4], #1
    8ad8:	462b      	mov	r3, r5
    8ada:	e7e0      	b.n	8a9e <ipaddr_ntoa_r+0x4e>
				return NULL;
    8adc:	2000      	movs	r0, #0
    8ade:	e7ed      	b.n	8abc <ipaddr_ntoa_r+0x6c>

00008ae0 <_mclk_init>:
	((Mclk *)hw)->CPUDIV.reg = data;
    8ae0:	4b01      	ldr	r3, [pc, #4]	; (8ae8 <_mclk_init+0x8>)
    8ae2:	2201      	movs	r2, #1
    8ae4:	715a      	strb	r2, [r3, #5]
 */
void _mclk_init(void)
{
	void *hw = (void *)MCLK;
	hri_mclk_write_CPUDIV_reg(hw, MCLK_CPUDIV_DIV(CONF_MCLK_CPUDIV));
}
    8ae6:	4770      	bx	lr
    8ae8:	40000800 	.word	0x40000800

00008aec <prvResetNextTaskUnblockTime>:

static void prvResetNextTaskUnblockTime(void)
{
	TCB_t *pxTCB;

	if (listLIST_IS_EMPTY(pxDelayedTaskList) != pdFALSE) {
    8aec:	4b06      	ldr	r3, [pc, #24]	; (8b08 <prvResetNextTaskUnblockTime+0x1c>)
    8aee:	6a9a      	ldr	r2, [r3, #40]	; 0x28
    8af0:	6812      	ldr	r2, [r2, #0]
    8af2:	b91a      	cbnz	r2, 8afc <prvResetNextTaskUnblockTime+0x10>
		/* The new current delayed list is empty.  Set xNextTaskUnblockTime to
		the maximum possible value so it is	extremely unlikely that the
		if( xTickCount >= xNextTaskUnblockTime ) test will pass until
		there is an item in the delayed list. */
		xNextTaskUnblockTime = portMAX_DELAY;
    8af4:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
		/* The new current delayed list is not empty, get the value of
		the item at the head of the delayed list.  This is the time at
		which the task at the head of the delayed list should be removed
		from the Blocked state. */
		(pxTCB)              = (TCB_t *)listGET_OWNER_OF_HEAD_ENTRY(pxDelayedTaskList);
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE(&((pxTCB)->xGenericListItem));
    8af8:	62da      	str	r2, [r3, #44]	; 0x2c
	}
}
    8afa:	4770      	bx	lr
		(pxTCB)              = (TCB_t *)listGET_OWNER_OF_HEAD_ENTRY(pxDelayedTaskList);
    8afc:	6a9a      	ldr	r2, [r3, #40]	; 0x28
    8afe:	68d2      	ldr	r2, [r2, #12]
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE(&((pxTCB)->xGenericListItem));
    8b00:	68d2      	ldr	r2, [r2, #12]
    8b02:	6852      	ldr	r2, [r2, #4]
    8b04:	e7f8      	b.n	8af8 <prvResetNextTaskUnblockTime+0xc>
    8b06:	bf00      	nop
    8b08:	20016274 	.word	0x20016274

00008b0c <prvAddCurrentTaskToDelayedList>:
{
    8b0c:	b570      	push	{r4, r5, r6, lr}
	listSET_LIST_ITEM_VALUE(&(pxCurrentTCB->xGenericListItem), xTimeToWake);
    8b0e:	4c0b      	ldr	r4, [pc, #44]	; (8b3c <prvAddCurrentTaskToDelayedList+0x30>)
    8b10:	6b23      	ldr	r3, [r4, #48]	; 0x30
    8b12:	6058      	str	r0, [r3, #4]
	if (xTimeToWake < xTickCount) {
    8b14:	6b63      	ldr	r3, [r4, #52]	; 0x34
    8b16:	4283      	cmp	r3, r0
{
    8b18:	4605      	mov	r5, r0
    8b1a:	4b09      	ldr	r3, [pc, #36]	; (8b40 <prvAddCurrentTaskToDelayedList+0x34>)
	if (xTimeToWake < xTickCount) {
    8b1c:	d905      	bls.n	8b2a <prvAddCurrentTaskToDelayedList+0x1e>
		vListInsert(pxOverflowDelayedTaskList, &(pxCurrentTCB->xGenericListItem));
    8b1e:	6ba0      	ldr	r0, [r4, #56]	; 0x38
    8b20:	6b21      	ldr	r1, [r4, #48]	; 0x30
}
    8b22:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		vListInsert(pxOverflowDelayedTaskList, &(pxCurrentTCB->xGenericListItem));
    8b26:	3104      	adds	r1, #4
    8b28:	4718      	bx	r3
		vListInsert(pxDelayedTaskList, &(pxCurrentTCB->xGenericListItem));
    8b2a:	6aa0      	ldr	r0, [r4, #40]	; 0x28
    8b2c:	6b21      	ldr	r1, [r4, #48]	; 0x30
    8b2e:	3104      	adds	r1, #4
    8b30:	4798      	blx	r3
		if (xTimeToWake < xNextTaskUnblockTime) {
    8b32:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
    8b34:	429d      	cmp	r5, r3
			xNextTaskUnblockTime = xTimeToWake;
    8b36:	bf38      	it	cc
    8b38:	62e5      	strcc	r5, [r4, #44]	; 0x2c
}
    8b3a:	bd70      	pop	{r4, r5, r6, pc}
    8b3c:	20016274 	.word	0x20016274
    8b40:	00001e31 	.word	0x00001e31

00008b44 <xTaskGenericCreate>:
{
    8b44:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    8b48:	9f0a      	ldr	r7, [sp, #40]	; 0x28
    8b4a:	9e0c      	ldr	r6, [sp, #48]	; 0x30
    8b4c:	4688      	mov	r8, r1
    8b4e:	4615      	mov	r5, r2
    8b50:	469a      	mov	sl, r3
	configASSERT(pxTaskCode);
    8b52:	4681      	mov	r9, r0
    8b54:	b940      	cbnz	r0, 8b68 <xTaskGenericCreate+0x24>
    8b56:	f04f 0380 	mov.w	r3, #128	; 0x80
    8b5a:	f383 8811 	msr	BASEPRI, r3
    8b5e:	f3bf 8f6f 	isb	sy
    8b62:	f3bf 8f4f 	dsb	sy
    8b66:	e7fe      	b.n	8b66 <xTaskGenericCreate+0x22>
	configASSERT(((uxPriority & (UBaseType_t)(~portPRIVILEGE_BIT)) < (UBaseType_t)configMAX_PRIORITIES));
    8b68:	2f04      	cmp	r7, #4
    8b6a:	d908      	bls.n	8b7e <xTaskGenericCreate+0x3a>
    8b6c:	f04f 0380 	mov.w	r3, #128	; 0x80
    8b70:	f383 8811 	msr	BASEPRI, r3
    8b74:	f3bf 8f6f 	isb	sy
    8b78:	f3bf 8f4f 	dsb	sy
    8b7c:	e7fe      	b.n	8b7c <xTaskGenericCreate+0x38>
		pxStack = (StackType_t *)pvPortMallocAligned(
    8b7e:	4c56      	ldr	r4, [pc, #344]	; (8cd8 <xTaskGenericCreate+0x194>)
    8b80:	b92e      	cbnz	r6, 8b8e <xTaskGenericCreate+0x4a>
    8b82:	0090      	lsls	r0, r2, #2
    8b84:	47a0      	blx	r4
		if (pxStack != NULL) {
    8b86:	4606      	mov	r6, r0
    8b88:	2800      	cmp	r0, #0
    8b8a:	f000 8096 	beq.w	8cba <xTaskGenericCreate+0x176>
			pxNewTCB = (TCB_t *)pvPortMalloc(sizeof(TCB_t));
    8b8e:	2054      	movs	r0, #84	; 0x54
    8b90:	47a0      	blx	r4
			if (pxNewTCB != NULL) {
    8b92:	4604      	mov	r4, r0
    8b94:	2800      	cmp	r0, #0
    8b96:	f000 808d 	beq.w	8cb4 <xTaskGenericCreate+0x170>
			(void)memset(pxNewTCB->pxStack, (int)tskSTACK_FILL_BYTE, (size_t)usStackDepth * sizeof(StackType_t));
    8b9a:	00ad      	lsls	r5, r5, #2
    8b9c:	462a      	mov	r2, r5
    8b9e:	4b4f      	ldr	r3, [pc, #316]	; (8cdc <xTaskGenericCreate+0x198>)
				pxNewTCB->pxStack = pxStack;
    8ba0:	6306      	str	r6, [r0, #48]	; 0x30
			(void)memset(pxNewTCB->pxStack, (int)tskSTACK_FILL_BYTE, (size_t)usStackDepth * sizeof(StackType_t));
    8ba2:	21a5      	movs	r1, #165	; 0xa5
    8ba4:	4630      	mov	r0, r6
    8ba6:	4798      	blx	r3
			pxTopOfStack = pxNewTCB->pxStack + (usStackDepth - (uint16_t)1);
    8ba8:	6b22      	ldr	r2, [r4, #48]	; 0x30
    8baa:	3d04      	subs	r5, #4
    8bac:	4415      	add	r5, r2
    8bae:	f108 33ff 	add.w	r3, r8, #4294967295	; 0xffffffff
			                      & (~((portPOINTER_SIZE_TYPE)
    8bb2:	f025 0507 	bic.w	r5, r5, #7
	for (x = (UBaseType_t)0; x < (UBaseType_t)configMAX_TASK_NAME_LEN; x++) {
    8bb6:	f104 0234 	add.w	r2, r4, #52	; 0x34
    8bba:	f108 0807 	add.w	r8, r8, #7
		pxTCB->pcTaskName[x] = pcName[x];
    8bbe:	f813 1f01 	ldrb.w	r1, [r3, #1]!
    8bc2:	f802 1b01 	strb.w	r1, [r2], #1
		if (pcName[x] == 0x00) {
    8bc6:	b109      	cbz	r1, 8bcc <xTaskGenericCreate+0x88>
	for (x = (UBaseType_t)0; x < (UBaseType_t)configMAX_TASK_NAME_LEN; x++) {
    8bc8:	4598      	cmp	r8, r3
    8bca:	d1f8      	bne.n	8bbe <xTaskGenericCreate+0x7a>
	pxTCB->pcTaskName[configMAX_TASK_NAME_LEN - 1] = '\0';
    8bcc:	2600      	movs	r6, #0
	vListInitialiseItem(&(pxTCB->xGenericListItem));
    8bce:	f104 0804 	add.w	r8, r4, #4
    8bd2:	f8df b128 	ldr.w	fp, [pc, #296]	; 8cfc <xTaskGenericCreate+0x1b8>
	pxTCB->pcTaskName[configMAX_TASK_NAME_LEN - 1] = '\0';
    8bd6:	f884 603b 	strb.w	r6, [r4, #59]	; 0x3b
	vListInitialiseItem(&(pxTCB->xGenericListItem));
    8bda:	4640      	mov	r0, r8
		pxTCB->uxMutexesHeld  = 0;
    8bdc:	e9c4 7611 	strd	r7, r6, [r4, #68]	; 0x44
	pxTCB->uxPriority = uxPriority;
    8be0:	62e7      	str	r7, [r4, #44]	; 0x2c
	vListInitialiseItem(&(pxTCB->xGenericListItem));
    8be2:	47d8      	blx	fp
	vListInitialiseItem(&(pxTCB->xEventListItem));
    8be4:	f104 0018 	add.w	r0, r4, #24
    8be8:	47d8      	blx	fp
	listSET_LIST_ITEM_VALUE(
    8bea:	f1c7 0305 	rsb	r3, r7, #5
    8bee:	61a3      	str	r3, [r4, #24]
		pxTCB->ulNotifiedValue = 0;
    8bf0:	64e6      	str	r6, [r4, #76]	; 0x4c
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack(pxTopOfStack, pxTaskCode, pvParameters);
    8bf2:	4b3b      	ldr	r3, [pc, #236]	; (8ce0 <xTaskGenericCreate+0x19c>)
	listSET_LIST_ITEM_OWNER(&(pxTCB->xGenericListItem), pxTCB);
    8bf4:	6124      	str	r4, [r4, #16]
	listSET_LIST_ITEM_OWNER(&(pxTCB->xEventListItem), pxTCB);
    8bf6:	6264      	str	r4, [r4, #36]	; 0x24
		pxTCB->eNotifyState    = eNotWaitingNotification;
    8bf8:	f884 6050 	strb.w	r6, [r4, #80]	; 0x50
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack(pxTopOfStack, pxTaskCode, pvParameters);
    8bfc:	4652      	mov	r2, sl
    8bfe:	4649      	mov	r1, r9
    8c00:	4628      	mov	r0, r5
    8c02:	4798      	blx	r3
		if ((void *)pxCreatedTask != NULL) {
    8c04:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack(pxTopOfStack, pxTaskCode, pvParameters);
    8c06:	6020      	str	r0, [r4, #0]
		if ((void *)pxCreatedTask != NULL) {
    8c08:	b103      	cbz	r3, 8c0c <xTaskGenericCreate+0xc8>
			*pxCreatedTask = (TaskHandle_t)pxNewTCB;
    8c0a:	601c      	str	r4, [r3, #0]
			uxCurrentNumberOfTasks++;
    8c0c:	4d35      	ldr	r5, [pc, #212]	; (8ce4 <xTaskGenericCreate+0x1a0>)
		taskENTER_CRITICAL();
    8c0e:	4b36      	ldr	r3, [pc, #216]	; (8ce8 <xTaskGenericCreate+0x1a4>)
    8c10:	4798      	blx	r3
			uxCurrentNumberOfTasks++;
    8c12:	6beb      	ldr	r3, [r5, #60]	; 0x3c
    8c14:	3301      	adds	r3, #1
    8c16:	63eb      	str	r3, [r5, #60]	; 0x3c
			if (pxCurrentTCB == NULL) {
    8c18:	6b2e      	ldr	r6, [r5, #48]	; 0x30
    8c1a:	f105 0a40 	add.w	sl, r5, #64	; 0x40
    8c1e:	2e00      	cmp	r6, #0
    8c20:	d14f      	bne.n	8cc2 <xTaskGenericCreate+0x17e>
				pxCurrentTCB = pxNewTCB;
    8c22:	632c      	str	r4, [r5, #48]	; 0x30
				if (uxCurrentNumberOfTasks == (UBaseType_t)1) {
    8c24:	6beb      	ldr	r3, [r5, #60]	; 0x3c
    8c26:	2b01      	cmp	r3, #1
    8c28:	d11c      	bne.n	8c64 <xTaskGenericCreate+0x120>
		vListInitialise(&(pxReadyTasksLists[uxPriority]));
    8c2a:	f8df 90d4 	ldr.w	r9, [pc, #212]	; 8d00 <xTaskGenericCreate+0x1bc>
    8c2e:	46d3      	mov	fp, sl
    8c30:	4658      	mov	r0, fp
	for (uxPriority = (UBaseType_t)0U; uxPriority < (UBaseType_t)configMAX_PRIORITIES; uxPriority++) {
    8c32:	3601      	adds	r6, #1
		vListInitialise(&(pxReadyTasksLists[uxPriority]));
    8c34:	47c8      	blx	r9
	for (uxPriority = (UBaseType_t)0U; uxPriority < (UBaseType_t)configMAX_PRIORITIES; uxPriority++) {
    8c36:	2e05      	cmp	r6, #5
    8c38:	f10b 0b14 	add.w	fp, fp, #20
    8c3c:	d1f8      	bne.n	8c30 <xTaskGenericCreate+0xec>
	vListInitialise(&xDelayedTaskList1);
    8c3e:	4e2b      	ldr	r6, [pc, #172]	; (8cec <xTaskGenericCreate+0x1a8>)
    8c40:	4630      	mov	r0, r6
	vListInitialise(&xDelayedTaskList2);
    8c42:	f106 0b14 	add.w	fp, r6, #20
	vListInitialise(&xDelayedTaskList1);
    8c46:	47c8      	blx	r9
	vListInitialise(&xDelayedTaskList2);
    8c48:	4658      	mov	r0, fp
    8c4a:	47c8      	blx	r9
	vListInitialise(&xPendingReadyList);
    8c4c:	f1a6 0090 	sub.w	r0, r6, #144	; 0x90
    8c50:	47c8      	blx	r9
		vListInitialise(&xTasksWaitingTermination);
    8c52:	f106 0028 	add.w	r0, r6, #40	; 0x28
    8c56:	47c8      	blx	r9
		vListInitialise(&xSuspendedTaskList);
    8c58:	f1a6 00a4 	sub.w	r0, r6, #164	; 0xa4
    8c5c:	47c8      	blx	r9
	pxDelayedTaskList         = &xDelayedTaskList1;
    8c5e:	62ae      	str	r6, [r5, #40]	; 0x28
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
    8c60:	f8c5 b038 	str.w	fp, [r5, #56]	; 0x38
			uxTaskNumber++;
    8c64:	f8d5 30e4 	ldr.w	r3, [r5, #228]	; 0xe4
			prvAddTaskToReadyList(pxNewTCB);
    8c68:	f8d5 20e8 	ldr.w	r2, [r5, #232]	; 0xe8
			uxTaskNumber++;
    8c6c:	3301      	adds	r3, #1
    8c6e:	f8c5 30e4 	str.w	r3, [r5, #228]	; 0xe4
				pxNewTCB->uxTCBNumber = uxTaskNumber;
    8c72:	63e3      	str	r3, [r4, #60]	; 0x3c
			prvAddTaskToReadyList(pxNewTCB);
    8c74:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
    8c76:	2014      	movs	r0, #20
    8c78:	4293      	cmp	r3, r2
    8c7a:	bf88      	it	hi
    8c7c:	f8c5 30e8 	strhi.w	r3, [r5, #232]	; 0xe8
    8c80:	fb00 a003 	mla	r0, r0, r3, sl
    8c84:	4641      	mov	r1, r8
    8c86:	4b1a      	ldr	r3, [pc, #104]	; (8cf0 <xTaskGenericCreate+0x1ac>)
    8c88:	4798      	blx	r3
		taskEXIT_CRITICAL();
    8c8a:	4b1a      	ldr	r3, [pc, #104]	; (8cf4 <xTaskGenericCreate+0x1b0>)
    8c8c:	4798      	blx	r3
		if (xSchedulerRunning != pdFALSE) {
    8c8e:	f8d5 30e0 	ldr.w	r3, [r5, #224]	; 0xe0
    8c92:	b16b      	cbz	r3, 8cb0 <xTaskGenericCreate+0x16c>
			if (pxCurrentTCB->uxPriority < uxPriority) {
    8c94:	6b2b      	ldr	r3, [r5, #48]	; 0x30
    8c96:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    8c98:	42bb      	cmp	r3, r7
    8c9a:	d209      	bcs.n	8cb0 <xTaskGenericCreate+0x16c>
				taskYIELD_IF_USING_PREEMPTION();
    8c9c:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
    8ca0:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
    8ca4:	f8c3 2d04 	str.w	r2, [r3, #3332]	; 0xd04
    8ca8:	f3bf 8f4f 	dsb	sy
    8cac:	f3bf 8f6f 	isb	sy
			xReturn = pdPASS;
    8cb0:	2001      	movs	r0, #1
	return xReturn;
    8cb2:	e004      	b.n	8cbe <xTaskGenericCreate+0x17a>
				vPortFree(pxStack);
    8cb4:	4b10      	ldr	r3, [pc, #64]	; (8cf8 <xTaskGenericCreate+0x1b4>)
    8cb6:	4630      	mov	r0, r6
    8cb8:	4798      	blx	r3
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    8cba:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
}
    8cbe:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
				if (xSchedulerRunning == pdFALSE) {
    8cc2:	f8d5 30e0 	ldr.w	r3, [r5, #224]	; 0xe0
    8cc6:	2b00      	cmp	r3, #0
    8cc8:	d1cc      	bne.n	8c64 <xTaskGenericCreate+0x120>
					if (pxCurrentTCB->uxPriority <= uxPriority) {
    8cca:	6b2b      	ldr	r3, [r5, #48]	; 0x30
    8ccc:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    8cce:	42bb      	cmp	r3, r7
						pxCurrentTCB = pxNewTCB;
    8cd0:	bf98      	it	ls
    8cd2:	632c      	strls	r4, [r5, #48]	; 0x30
    8cd4:	e7c6      	b.n	8c64 <xTaskGenericCreate+0x120>
    8cd6:	bf00      	nop
    8cd8:	00001d01 	.word	0x00001d01
    8cdc:	0000a365 	.word	0x0000a365
    8ce0:	00009d11 	.word	0x00009d11
    8ce4:	20016274 	.word	0x20016274
    8ce8:	00009d55 	.word	0x00009d55
    8cec:	20016318 	.word	0x20016318
    8cf0:	00001e19 	.word	0x00001e19
    8cf4:	00009d95 	.word	0x00009d95
    8cf8:	00001db5 	.word	0x00001db5
    8cfc:	00001e13 	.word	0x00001e13
    8d00:	00001dfd 	.word	0x00001dfd

00008d04 <vTaskStartScheduler>:
{
    8d04:	b530      	push	{r4, r5, lr}
		xReturn = xTaskCreate(prvIdleTask,
    8d06:	2400      	movs	r4, #0
{
    8d08:	b085      	sub	sp, #20
		xReturn = xTaskCreate(prvIdleTask,
    8d0a:	e9cd 4402 	strd	r4, r4, [sp, #8]
    8d0e:	e9cd 4400 	strd	r4, r4, [sp]
    8d12:	4916      	ldr	r1, [pc, #88]	; (8d6c <vTaskStartScheduler+0x68>)
    8d14:	4816      	ldr	r0, [pc, #88]	; (8d70 <vTaskStartScheduler+0x6c>)
    8d16:	4d17      	ldr	r5, [pc, #92]	; (8d74 <vTaskStartScheduler+0x70>)
    8d18:	4623      	mov	r3, r4
    8d1a:	2240      	movs	r2, #64	; 0x40
    8d1c:	47a8      	blx	r5
		if (xReturn == pdPASS) {
    8d1e:	2801      	cmp	r0, #1
    8d20:	d117      	bne.n	8d52 <vTaskStartScheduler+0x4e>
			xReturn = xTimerCreateTimerTask();
    8d22:	4b15      	ldr	r3, [pc, #84]	; (8d78 <vTaskStartScheduler+0x74>)
    8d24:	4798      	blx	r3
	if (xReturn == pdPASS) {
    8d26:	2801      	cmp	r0, #1
    8d28:	d113      	bne.n	8d52 <vTaskStartScheduler+0x4e>
    8d2a:	f04f 0380 	mov.w	r3, #128	; 0x80
    8d2e:	f383 8811 	msr	BASEPRI, r3
    8d32:	f3bf 8f6f 	isb	sy
    8d36:	f3bf 8f4f 	dsb	sy
		xNextTaskUnblockTime = portMAX_DELAY;
    8d3a:	4b10      	ldr	r3, [pc, #64]	; (8d7c <vTaskStartScheduler+0x78>)
    8d3c:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
    8d40:	62da      	str	r2, [r3, #44]	; 0x2c
		xSchedulerRunning    = pdTRUE;
    8d42:	f8c3 00e0 	str.w	r0, [r3, #224]	; 0xe0
		xTickCount           = (TickType_t)0U;
    8d46:	635c      	str	r4, [r3, #52]	; 0x34
		if (xPortStartScheduler() != pdFALSE) {
    8d48:	4b0d      	ldr	r3, [pc, #52]	; (8d80 <vTaskStartScheduler+0x7c>)
}
    8d4a:	b005      	add	sp, #20
    8d4c:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
		if (xPortStartScheduler() != pdFALSE) {
    8d50:	4718      	bx	r3
		configASSERT(xReturn);
    8d52:	b940      	cbnz	r0, 8d66 <vTaskStartScheduler+0x62>
    8d54:	f04f 0380 	mov.w	r3, #128	; 0x80
    8d58:	f383 8811 	msr	BASEPRI, r3
    8d5c:	f3bf 8f6f 	isb	sy
    8d60:	f3bf 8f4f 	dsb	sy
    8d64:	e7fe      	b.n	8d64 <vTaskStartScheduler+0x60>
}
    8d66:	b005      	add	sp, #20
    8d68:	bd30      	pop	{r4, r5, pc}
    8d6a:	bf00      	nop
    8d6c:	0000b920 	.word	0x0000b920
    8d70:	00008fed 	.word	0x00008fed
    8d74:	00008b45 	.word	0x00008b45
    8d78:	00008009 	.word	0x00008009
    8d7c:	20016274 	.word	0x20016274
    8d80:	00009e61 	.word	0x00009e61

00008d84 <vTaskSuspendAll>:
	++uxSchedulerSuspended;
    8d84:	4a03      	ldr	r2, [pc, #12]	; (8d94 <vTaskSuspendAll+0x10>)
    8d86:	f8d2 30f0 	ldr.w	r3, [r2, #240]	; 0xf0
    8d8a:	3301      	adds	r3, #1
    8d8c:	f8c2 30f0 	str.w	r3, [r2, #240]	; 0xf0
}
    8d90:	4770      	bx	lr
    8d92:	bf00      	nop
    8d94:	20016274 	.word	0x20016274

00008d98 <xTaskGetTickCount>:
		xTicks = xTickCount;
    8d98:	4b01      	ldr	r3, [pc, #4]	; (8da0 <xTaskGetTickCount+0x8>)
    8d9a:	6b58      	ldr	r0, [r3, #52]	; 0x34
}
    8d9c:	4770      	bx	lr
    8d9e:	bf00      	nop
    8da0:	20016274 	.word	0x20016274

00008da4 <xTaskIncrementTick>:
{
    8da4:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
	if (uxSchedulerSuspended == (UBaseType_t)pdFALSE) {
    8da8:	4c36      	ldr	r4, [pc, #216]	; (8e84 <xTaskIncrementTick+0xe0>)
    8daa:	f8d4 30f0 	ldr.w	r3, [r4, #240]	; 0xf0
    8dae:	2b00      	cmp	r3, #0
    8db0:	d160      	bne.n	8e74 <xTaskIncrementTick+0xd0>
		++xTickCount;
    8db2:	6b63      	ldr	r3, [r4, #52]	; 0x34
    8db4:	3301      	adds	r3, #1
    8db6:	6363      	str	r3, [r4, #52]	; 0x34
			const TickType_t xConstTickCount = xTickCount;
    8db8:	6b67      	ldr	r7, [r4, #52]	; 0x34
			if (xConstTickCount == (TickType_t)0U) {
    8dba:	b9b7      	cbnz	r7, 8dea <xTaskIncrementTick+0x46>
				taskSWITCH_DELAYED_LISTS();
    8dbc:	6aa3      	ldr	r3, [r4, #40]	; 0x28
    8dbe:	681b      	ldr	r3, [r3, #0]
    8dc0:	b143      	cbz	r3, 8dd4 <xTaskIncrementTick+0x30>
    8dc2:	f04f 0380 	mov.w	r3, #128	; 0x80
    8dc6:	f383 8811 	msr	BASEPRI, r3
    8dca:	f3bf 8f6f 	isb	sy
    8dce:	f3bf 8f4f 	dsb	sy
    8dd2:	e7fe      	b.n	8dd2 <xTaskIncrementTick+0x2e>
    8dd4:	6aa3      	ldr	r3, [r4, #40]	; 0x28
    8dd6:	6ba2      	ldr	r2, [r4, #56]	; 0x38
    8dd8:	62a2      	str	r2, [r4, #40]	; 0x28
    8dda:	63a3      	str	r3, [r4, #56]	; 0x38
    8ddc:	f8d4 30f4 	ldr.w	r3, [r4, #244]	; 0xf4
    8de0:	3301      	adds	r3, #1
    8de2:	f8c4 30f4 	str.w	r3, [r4, #244]	; 0xf4
    8de6:	4b28      	ldr	r3, [pc, #160]	; (8e88 <xTaskIncrementTick+0xe4>)
    8de8:	4798      	blx	r3
			if (xConstTickCount >= xNextTaskUnblockTime) {
    8dea:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
    8dec:	42bb      	cmp	r3, r7
	BaseType_t xSwitchRequired = pdFALSE;
    8dee:	f04f 0500 	mov.w	r5, #0
			if (xConstTickCount >= xNextTaskUnblockTime) {
    8df2:	d910      	bls.n	8e16 <xTaskIncrementTick+0x72>
			if (listCURRENT_LIST_LENGTH(&(pxReadyTasksLists[pxCurrentTCB->uxPriority])) > (UBaseType_t)1) {
    8df4:	6b23      	ldr	r3, [r4, #48]	; 0x30
    8df6:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    8df8:	2214      	movs	r2, #20
    8dfa:	fb02 4303 	mla	r3, r2, r3, r4
    8dfe:	6c1b      	ldr	r3, [r3, #64]	; 0x40
				xSwitchRequired = pdTRUE;
    8e00:	2b02      	cmp	r3, #2
    8e02:	bf28      	it	cs
    8e04:	2501      	movcs	r5, #1
		if (xYieldPending != pdFALSE) {
    8e06:	f8d4 30fc 	ldr.w	r3, [r4, #252]	; 0xfc
			xSwitchRequired = pdTRUE;
    8e0a:	2b00      	cmp	r3, #0
}
    8e0c:	bf0c      	ite	eq
    8e0e:	4628      	moveq	r0, r5
    8e10:	2001      	movne	r0, #1
    8e12:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
						(void)uxListRemove(&(pxTCB->xGenericListItem));
    8e16:	f8df 8074 	ldr.w	r8, [pc, #116]	; 8e8c <xTaskIncrementTick+0xe8>
						prvAddTaskToReadyList(pxTCB);
    8e1a:	f8df a074 	ldr.w	sl, [pc, #116]	; 8e90 <xTaskIncrementTick+0xec>
    8e1e:	f8df 9074 	ldr.w	r9, [pc, #116]	; 8e94 <xTaskIncrementTick+0xf0>
					if (listLIST_IS_EMPTY(pxDelayedTaskList) != pdFALSE) {
    8e22:	6aa3      	ldr	r3, [r4, #40]	; 0x28
    8e24:	681b      	ldr	r3, [r3, #0]
    8e26:	b91b      	cbnz	r3, 8e30 <xTaskIncrementTick+0x8c>
						xNextTaskUnblockTime = portMAX_DELAY;
    8e28:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
							xNextTaskUnblockTime = xItemValue;
    8e2c:	62e3      	str	r3, [r4, #44]	; 0x2c
							break;
    8e2e:	e7e1      	b.n	8df4 <xTaskIncrementTick+0x50>
						pxTCB      = (TCB_t *)listGET_OWNER_OF_HEAD_ENTRY(pxDelayedTaskList);
    8e30:	6aa3      	ldr	r3, [r4, #40]	; 0x28
    8e32:	68db      	ldr	r3, [r3, #12]
    8e34:	68de      	ldr	r6, [r3, #12]
						xItemValue = listGET_LIST_ITEM_VALUE(&(pxTCB->xGenericListItem));
    8e36:	6873      	ldr	r3, [r6, #4]
						if (xConstTickCount < xItemValue) {
    8e38:	429f      	cmp	r7, r3
    8e3a:	d3f7      	bcc.n	8e2c <xTaskIncrementTick+0x88>
						(void)uxListRemove(&(pxTCB->xGenericListItem));
    8e3c:	f106 0b04 	add.w	fp, r6, #4
    8e40:	4658      	mov	r0, fp
    8e42:	47c0      	blx	r8
						if (listLIST_ITEM_CONTAINER(&(pxTCB->xEventListItem)) != NULL) {
    8e44:	6ab3      	ldr	r3, [r6, #40]	; 0x28
    8e46:	b113      	cbz	r3, 8e4e <xTaskIncrementTick+0xaa>
							(void)uxListRemove(&(pxTCB->xEventListItem));
    8e48:	f106 0018 	add.w	r0, r6, #24
    8e4c:	47c0      	blx	r8
						prvAddTaskToReadyList(pxTCB);
    8e4e:	6af3      	ldr	r3, [r6, #44]	; 0x2c
    8e50:	f8d4 20e8 	ldr.w	r2, [r4, #232]	; 0xe8
    8e54:	2014      	movs	r0, #20
    8e56:	4293      	cmp	r3, r2
    8e58:	fb00 a003 	mla	r0, r0, r3, sl
    8e5c:	4659      	mov	r1, fp
    8e5e:	bf88      	it	hi
    8e60:	f8c4 30e8 	strhi.w	r3, [r4, #232]	; 0xe8
    8e64:	47c8      	blx	r9
							if (pxTCB->uxPriority >= pxCurrentTCB->uxPriority) {
    8e66:	6b23      	ldr	r3, [r4, #48]	; 0x30
    8e68:	6af2      	ldr	r2, [r6, #44]	; 0x2c
    8e6a:	6adb      	ldr	r3, [r3, #44]	; 0x2c
								xSwitchRequired = pdTRUE;
    8e6c:	429a      	cmp	r2, r3
    8e6e:	bf28      	it	cs
    8e70:	2501      	movcs	r5, #1
    8e72:	e7d6      	b.n	8e22 <xTaskIncrementTick+0x7e>
		++uxPendedTicks;
    8e74:	f8d4 30f8 	ldr.w	r3, [r4, #248]	; 0xf8
    8e78:	3301      	adds	r3, #1
    8e7a:	f8c4 30f8 	str.w	r3, [r4, #248]	; 0xf8
	BaseType_t xSwitchRequired = pdFALSE;
    8e7e:	2500      	movs	r5, #0
    8e80:	e7c1      	b.n	8e06 <xTaskIncrementTick+0x62>
    8e82:	bf00      	nop
    8e84:	20016274 	.word	0x20016274
    8e88:	00008aed 	.word	0x00008aed
    8e8c:	00001e5f 	.word	0x00001e5f
    8e90:	200162b4 	.word	0x200162b4
    8e94:	00001e19 	.word	0x00001e19

00008e98 <xTaskResumeAll>:
{
    8e98:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
	configASSERT(uxSchedulerSuspended);
    8e9c:	4c33      	ldr	r4, [pc, #204]	; (8f6c <xTaskResumeAll+0xd4>)
    8e9e:	f8d4 30f0 	ldr.w	r3, [r4, #240]	; 0xf0
    8ea2:	b943      	cbnz	r3, 8eb6 <xTaskResumeAll+0x1e>
    8ea4:	f04f 0380 	mov.w	r3, #128	; 0x80
    8ea8:	f383 8811 	msr	BASEPRI, r3
    8eac:	f3bf 8f6f 	isb	sy
    8eb0:	f3bf 8f4f 	dsb	sy
    8eb4:	e7fe      	b.n	8eb4 <xTaskResumeAll+0x1c>
	taskENTER_CRITICAL();
    8eb6:	4b2e      	ldr	r3, [pc, #184]	; (8f70 <xTaskResumeAll+0xd8>)
    8eb8:	4798      	blx	r3
		--uxSchedulerSuspended;
    8eba:	f8d4 30f0 	ldr.w	r3, [r4, #240]	; 0xf0
    8ebe:	3b01      	subs	r3, #1
    8ec0:	f8c4 30f0 	str.w	r3, [r4, #240]	; 0xf0
		if (uxSchedulerSuspended == (UBaseType_t)pdFALSE) {
    8ec4:	f8d4 30f0 	ldr.w	r3, [r4, #240]	; 0xf0
    8ec8:	b133      	cbz	r3, 8ed8 <xTaskResumeAll+0x40>
	BaseType_t xAlreadyYielded = pdFALSE;
    8eca:	2400      	movs	r4, #0
	taskEXIT_CRITICAL();
    8ecc:	4b29      	ldr	r3, [pc, #164]	; (8f74 <xTaskResumeAll+0xdc>)
    8ece:	4798      	blx	r3
}
    8ed0:	4620      	mov	r0, r4
    8ed2:	b002      	add	sp, #8
    8ed4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
			if (uxCurrentNumberOfTasks > (UBaseType_t)0U) {
    8ed8:	6be3      	ldr	r3, [r4, #60]	; 0x3c
    8eda:	2b00      	cmp	r3, #0
    8edc:	d0f5      	beq.n	8eca <xTaskResumeAll+0x32>
					(void)uxListRemove(&(pxTCB->xEventListItem));
    8ede:	4e26      	ldr	r6, [pc, #152]	; (8f78 <xTaskResumeAll+0xe0>)
					prvAddTaskToReadyList(pxTCB);
    8ee0:	f104 0740 	add.w	r7, r4, #64	; 0x40
    8ee4:	f8df 8098 	ldr.w	r8, [pc, #152]	; 8f80 <xTaskResumeAll+0xe8>
				while (listLIST_IS_EMPTY(&xPendingReadyList) == pdFALSE) {
    8ee8:	6963      	ldr	r3, [r4, #20]
    8eea:	b9b3      	cbnz	r3, 8f1a <xTaskResumeAll+0x82>
				if (uxPendedTicks > (UBaseType_t)0U) {
    8eec:	f8d4 30f8 	ldr.w	r3, [r4, #248]	; 0xf8
    8ef0:	b123      	cbz	r3, 8efc <xTaskResumeAll+0x64>
						if (xTaskIncrementTick() != pdFALSE) {
    8ef2:	4d22      	ldr	r5, [pc, #136]	; (8f7c <xTaskResumeAll+0xe4>)
							xYieldPending = pdTRUE;
    8ef4:	2601      	movs	r6, #1
					while (uxPendedTicks > (UBaseType_t)0U) {
    8ef6:	f8d4 30f8 	ldr.w	r3, [r4, #248]	; 0xf8
    8efa:	bb63      	cbnz	r3, 8f56 <xTaskResumeAll+0xbe>
				if (xYieldPending == pdTRUE) {
    8efc:	f8d4 40fc 	ldr.w	r4, [r4, #252]	; 0xfc
    8f00:	2c01      	cmp	r4, #1
    8f02:	d1e2      	bne.n	8eca <xTaskResumeAll+0x32>
					taskYIELD_IF_USING_PREEMPTION();
    8f04:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
    8f08:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
    8f0c:	f8c3 2d04 	str.w	r2, [r3, #3332]	; 0xd04
    8f10:	f3bf 8f4f 	dsb	sy
    8f14:	f3bf 8f6f 	isb	sy
    8f18:	e7d8      	b.n	8ecc <xTaskResumeAll+0x34>
					pxTCB = (TCB_t *)listGET_OWNER_OF_HEAD_ENTRY((&xPendingReadyList));
    8f1a:	6a23      	ldr	r3, [r4, #32]
    8f1c:	68dd      	ldr	r5, [r3, #12]
					(void)uxListRemove(&(pxTCB->xEventListItem));
    8f1e:	f105 0018 	add.w	r0, r5, #24
    8f22:	47b0      	blx	r6
					(void)uxListRemove(&(pxTCB->xGenericListItem));
    8f24:	1d29      	adds	r1, r5, #4
    8f26:	4608      	mov	r0, r1
    8f28:	9101      	str	r1, [sp, #4]
    8f2a:	47b0      	blx	r6
					prvAddTaskToReadyList(pxTCB);
    8f2c:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
    8f2e:	f8d4 20e8 	ldr.w	r2, [r4, #232]	; 0xe8
    8f32:	9901      	ldr	r1, [sp, #4]
    8f34:	2014      	movs	r0, #20
    8f36:	4293      	cmp	r3, r2
    8f38:	fb00 7003 	mla	r0, r0, r3, r7
    8f3c:	bf88      	it	hi
    8f3e:	f8c4 30e8 	strhi.w	r3, [r4, #232]	; 0xe8
    8f42:	47c0      	blx	r8
					if (pxTCB->uxPriority >= pxCurrentTCB->uxPriority) {
    8f44:	6b23      	ldr	r3, [r4, #48]	; 0x30
    8f46:	6aea      	ldr	r2, [r5, #44]	; 0x2c
    8f48:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    8f4a:	429a      	cmp	r2, r3
    8f4c:	d3cc      	bcc.n	8ee8 <xTaskResumeAll+0x50>
						xYieldPending = pdTRUE;
    8f4e:	2301      	movs	r3, #1
    8f50:	f8c4 30fc 	str.w	r3, [r4, #252]	; 0xfc
    8f54:	e7c6      	b.n	8ee4 <xTaskResumeAll+0x4c>
						if (xTaskIncrementTick() != pdFALSE) {
    8f56:	47a8      	blx	r5
    8f58:	b108      	cbz	r0, 8f5e <xTaskResumeAll+0xc6>
							xYieldPending = pdTRUE;
    8f5a:	f8c4 60fc 	str.w	r6, [r4, #252]	; 0xfc
						--uxPendedTicks;
    8f5e:	f8d4 30f8 	ldr.w	r3, [r4, #248]	; 0xf8
    8f62:	3b01      	subs	r3, #1
    8f64:	f8c4 30f8 	str.w	r3, [r4, #248]	; 0xf8
    8f68:	e7c5      	b.n	8ef6 <xTaskResumeAll+0x5e>
    8f6a:	bf00      	nop
    8f6c:	20016274 	.word	0x20016274
    8f70:	00009d55 	.word	0x00009d55
    8f74:	00009d95 	.word	0x00009d95
    8f78:	00001e5f 	.word	0x00001e5f
    8f7c:	00008da5 	.word	0x00008da5
    8f80:	00001e19 	.word	0x00001e19

00008f84 <vTaskDelay>:
{
    8f84:	b510      	push	{r4, lr}
	if (xTicksToDelay > (TickType_t)0U) {
    8f86:	b950      	cbnz	r0, 8f9e <vTaskDelay+0x1a>
		portYIELD_WITHIN_API();
    8f88:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
    8f8c:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
    8f90:	f8c3 2d04 	str.w	r2, [r3, #3332]	; 0xd04
    8f94:	f3bf 8f4f 	dsb	sy
    8f98:	f3bf 8f6f 	isb	sy
}
    8f9c:	bd10      	pop	{r4, pc}
		configASSERT(uxSchedulerSuspended == 0);
    8f9e:	490e      	ldr	r1, [pc, #56]	; (8fd8 <vTaskDelay+0x54>)
    8fa0:	f8d1 30f0 	ldr.w	r3, [r1, #240]	; 0xf0
    8fa4:	b143      	cbz	r3, 8fb8 <vTaskDelay+0x34>
    8fa6:	f04f 0380 	mov.w	r3, #128	; 0x80
    8faa:	f383 8811 	msr	BASEPRI, r3
    8fae:	f3bf 8f6f 	isb	sy
    8fb2:	f3bf 8f4f 	dsb	sy
    8fb6:	e7fe      	b.n	8fb6 <vTaskDelay+0x32>
		vTaskSuspendAll();
    8fb8:	4b08      	ldr	r3, [pc, #32]	; (8fdc <vTaskDelay+0x58>)
    8fba:	4798      	blx	r3
			xTimeToWake = xTickCount + xTicksToDelay;
    8fbc:	6b4c      	ldr	r4, [r1, #52]	; 0x34
			if (uxListRemove(&(pxCurrentTCB->xGenericListItem)) == (UBaseType_t)0) {
    8fbe:	4b08      	ldr	r3, [pc, #32]	; (8fe0 <vTaskDelay+0x5c>)
			xTimeToWake = xTickCount + xTicksToDelay;
    8fc0:	4404      	add	r4, r0
			if (uxListRemove(&(pxCurrentTCB->xGenericListItem)) == (UBaseType_t)0) {
    8fc2:	6b08      	ldr	r0, [r1, #48]	; 0x30
    8fc4:	3004      	adds	r0, #4
    8fc6:	4798      	blx	r3
			prvAddCurrentTaskToDelayedList(xTimeToWake);
    8fc8:	4b06      	ldr	r3, [pc, #24]	; (8fe4 <vTaskDelay+0x60>)
    8fca:	4620      	mov	r0, r4
    8fcc:	4798      	blx	r3
		xAlreadyYielded = xTaskResumeAll();
    8fce:	4b06      	ldr	r3, [pc, #24]	; (8fe8 <vTaskDelay+0x64>)
    8fd0:	4798      	blx	r3
	if (xAlreadyYielded == pdFALSE) {
    8fd2:	2800      	cmp	r0, #0
    8fd4:	d0d8      	beq.n	8f88 <vTaskDelay+0x4>
    8fd6:	e7e1      	b.n	8f9c <vTaskDelay+0x18>
    8fd8:	20016274 	.word	0x20016274
    8fdc:	00008d85 	.word	0x00008d85
    8fe0:	00001e5f 	.word	0x00001e5f
    8fe4:	00008b0d 	.word	0x00008b0d
    8fe8:	00008e99 	.word	0x00008e99

00008fec <prvIdleTask>:
{
    8fec:	b580      	push	{r7, lr}
		while (uxTasksDeleted > (UBaseType_t)0U) {
    8fee:	4c19      	ldr	r4, [pc, #100]	; (9054 <prvIdleTask+0x68>)
			vTaskSuspendAll();
    8ff0:	4f19      	ldr	r7, [pc, #100]	; (9058 <prvIdleTask+0x6c>)
			(void)xTaskResumeAll();
    8ff2:	4d1a      	ldr	r5, [pc, #104]	; (905c <prvIdleTask+0x70>)
		while (uxTasksDeleted > (UBaseType_t)0U) {
    8ff4:	f8d4 30ec 	ldr.w	r3, [r4, #236]	; 0xec
    8ff8:	b96b      	cbnz	r3, 9016 <prvIdleTask+0x2a>
			if (listCURRENT_LIST_LENGTH(&(pxReadyTasksLists[tskIDLE_PRIORITY])) > (UBaseType_t)1) {
    8ffa:	6c23      	ldr	r3, [r4, #64]	; 0x40
    8ffc:	2b01      	cmp	r3, #1
    8ffe:	d9f8      	bls.n	8ff2 <prvIdleTask+0x6>
				taskYIELD();
    9000:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
    9004:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
    9008:	f8c3 2d04 	str.w	r2, [r3, #3332]	; 0xd04
    900c:	f3bf 8f4f 	dsb	sy
    9010:	f3bf 8f6f 	isb	sy
    9014:	e7ed      	b.n	8ff2 <prvIdleTask+0x6>
			vTaskSuspendAll();
    9016:	47b8      	blx	r7
				xListIsEmpty = listLIST_IS_EMPTY(&xTasksWaitingTermination);
    9018:	f8d4 60cc 	ldr.w	r6, [r4, #204]	; 0xcc
			(void)xTaskResumeAll();
    901c:	47a8      	blx	r5
			if (xListIsEmpty == pdFALSE) {
    901e:	2e00      	cmp	r6, #0
    9020:	d0e8      	beq.n	8ff4 <prvIdleTask+0x8>
				taskENTER_CRITICAL();
    9022:	4b0f      	ldr	r3, [pc, #60]	; (9060 <prvIdleTask+0x74>)
		vPortFreeAligned(pxTCB->pxStack);
    9024:	4e0f      	ldr	r6, [pc, #60]	; (9064 <prvIdleTask+0x78>)
				taskENTER_CRITICAL();
    9026:	4798      	blx	r3
					pxTCB = (TCB_t *)listGET_OWNER_OF_HEAD_ENTRY((&xTasksWaitingTermination));
    9028:	f8d4 30d8 	ldr.w	r3, [r4, #216]	; 0xd8
    902c:	68dd      	ldr	r5, [r3, #12]
					(void)uxListRemove(&(pxTCB->xGenericListItem));
    902e:	4b0e      	ldr	r3, [pc, #56]	; (9068 <prvIdleTask+0x7c>)
    9030:	1d28      	adds	r0, r5, #4
    9032:	4798      	blx	r3
					--uxCurrentNumberOfTasks;
    9034:	6be3      	ldr	r3, [r4, #60]	; 0x3c
    9036:	3b01      	subs	r3, #1
    9038:	63e3      	str	r3, [r4, #60]	; 0x3c
					--uxTasksDeleted;
    903a:	f8d4 30ec 	ldr.w	r3, [r4, #236]	; 0xec
    903e:	3b01      	subs	r3, #1
    9040:	f8c4 30ec 	str.w	r3, [r4, #236]	; 0xec
				taskEXIT_CRITICAL();
    9044:	4b09      	ldr	r3, [pc, #36]	; (906c <prvIdleTask+0x80>)
    9046:	4798      	blx	r3
		vPortFreeAligned(pxTCB->pxStack);
    9048:	6b28      	ldr	r0, [r5, #48]	; 0x30
    904a:	47b0      	blx	r6
	vPortFree(pxTCB);
    904c:	4628      	mov	r0, r5
    904e:	47b0      	blx	r6
}
    9050:	e7cf      	b.n	8ff2 <prvIdleTask+0x6>
    9052:	bf00      	nop
    9054:	20016274 	.word	0x20016274
    9058:	00008d85 	.word	0x00008d85
    905c:	00008e99 	.word	0x00008e99
    9060:	00009d55 	.word	0x00009d55
    9064:	00001db5 	.word	0x00001db5
    9068:	00001e5f 	.word	0x00001e5f
    906c:	00009d95 	.word	0x00009d95

00009070 <vTaskSwitchContext>:
	if (uxSchedulerSuspended != (UBaseType_t)pdFALSE) {
    9070:	4b1b      	ldr	r3, [pc, #108]	; (90e0 <vTaskSwitchContext+0x70>)
    9072:	f8d3 20f0 	ldr.w	r2, [r3, #240]	; 0xf0
{
    9076:	b530      	push	{r4, r5, lr}
	if (uxSchedulerSuspended != (UBaseType_t)pdFALSE) {
    9078:	b11a      	cbz	r2, 9082 <vTaskSwitchContext+0x12>
		xYieldPending = pdTRUE;
    907a:	2201      	movs	r2, #1
    907c:	f8c3 20fc 	str.w	r2, [r3, #252]	; 0xfc
}
    9080:	bd30      	pop	{r4, r5, pc}
		xYieldPending = pdFALSE;
    9082:	f8c3 20fc 	str.w	r2, [r3, #252]	; 0xfc
		taskSELECT_HIGHEST_PRIORITY_TASK();
    9086:	2214      	movs	r2, #20
    9088:	f8d3 10e8 	ldr.w	r1, [r3, #232]	; 0xe8
    908c:	fb02 3101 	mla	r1, r2, r1, r3
    9090:	6c09      	ldr	r1, [r1, #64]	; 0x40
    9092:	b199      	cbz	r1, 90bc <vTaskSwitchContext+0x4c>
    9094:	f8d3 10e8 	ldr.w	r1, [r3, #232]	; 0xe8
    9098:	4d12      	ldr	r5, [pc, #72]	; (90e4 <vTaskSwitchContext+0x74>)
    909a:	434a      	muls	r2, r1
    909c:	1898      	adds	r0, r3, r2
    909e:	442a      	add	r2, r5
    90a0:	6c44      	ldr	r4, [r0, #68]	; 0x44
    90a2:	6864      	ldr	r4, [r4, #4]
    90a4:	6444      	str	r4, [r0, #68]	; 0x44
    90a6:	4294      	cmp	r4, r2
    90a8:	bf04      	itt	eq
    90aa:	6862      	ldreq	r2, [r4, #4]
    90ac:	6442      	streq	r2, [r0, #68]	; 0x44
    90ae:	2214      	movs	r2, #20
    90b0:	fb02 3101 	mla	r1, r2, r1, r3
    90b4:	6c4a      	ldr	r2, [r1, #68]	; 0x44
    90b6:	68d2      	ldr	r2, [r2, #12]
    90b8:	631a      	str	r2, [r3, #48]	; 0x30
}
    90ba:	e7e1      	b.n	9080 <vTaskSwitchContext+0x10>
		taskSELECT_HIGHEST_PRIORITY_TASK();
    90bc:	f8d3 10e8 	ldr.w	r1, [r3, #232]	; 0xe8
    90c0:	b941      	cbnz	r1, 90d4 <vTaskSwitchContext+0x64>
    90c2:	f04f 0380 	mov.w	r3, #128	; 0x80
    90c6:	f383 8811 	msr	BASEPRI, r3
    90ca:	f3bf 8f6f 	isb	sy
    90ce:	f3bf 8f4f 	dsb	sy
    90d2:	e7fe      	b.n	90d2 <vTaskSwitchContext+0x62>
    90d4:	f8d3 10e8 	ldr.w	r1, [r3, #232]	; 0xe8
    90d8:	3901      	subs	r1, #1
    90da:	f8c3 10e8 	str.w	r1, [r3, #232]	; 0xe8
    90de:	e7d3      	b.n	9088 <vTaskSwitchContext+0x18>
    90e0:	20016274 	.word	0x20016274
    90e4:	200162bc 	.word	0x200162bc

000090e8 <vTaskPlaceOnEventList>:
{
    90e8:	b570      	push	{r4, r5, r6, lr}
    90ea:	460d      	mov	r5, r1
	configASSERT(pxEventList);
    90ec:	b940      	cbnz	r0, 9100 <vTaskPlaceOnEventList+0x18>
    90ee:	f04f 0380 	mov.w	r3, #128	; 0x80
    90f2:	f383 8811 	msr	BASEPRI, r3
    90f6:	f3bf 8f6f 	isb	sy
    90fa:	f3bf 8f4f 	dsb	sy
    90fe:	e7fe      	b.n	90fe <vTaskPlaceOnEventList+0x16>
	vListInsert(pxEventList, &(pxCurrentTCB->xEventListItem));
    9100:	4c0b      	ldr	r4, [pc, #44]	; (9130 <vTaskPlaceOnEventList+0x48>)
    9102:	4b0c      	ldr	r3, [pc, #48]	; (9134 <vTaskPlaceOnEventList+0x4c>)
    9104:	6b21      	ldr	r1, [r4, #48]	; 0x30
    9106:	3118      	adds	r1, #24
    9108:	4798      	blx	r3
	if (uxListRemove(&(pxCurrentTCB->xGenericListItem)) == (UBaseType_t)0) {
    910a:	6b20      	ldr	r0, [r4, #48]	; 0x30
    910c:	4b0a      	ldr	r3, [pc, #40]	; (9138 <vTaskPlaceOnEventList+0x50>)
    910e:	3004      	adds	r0, #4
    9110:	4798      	blx	r3
		if (xTicksToWait == portMAX_DELAY) {
    9112:	1c6b      	adds	r3, r5, #1
    9114:	d106      	bne.n	9124 <vTaskPlaceOnEventList+0x3c>
			vListInsertEnd(&xSuspendedTaskList, &(pxCurrentTCB->xGenericListItem));
    9116:	6b21      	ldr	r1, [r4, #48]	; 0x30
    9118:	4b08      	ldr	r3, [pc, #32]	; (913c <vTaskPlaceOnEventList+0x54>)
    911a:	4620      	mov	r0, r4
    911c:	3104      	adds	r1, #4
}
    911e:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
			vListInsertEnd(&xSuspendedTaskList, &(pxCurrentTCB->xGenericListItem));
    9122:	4718      	bx	r3
			xTimeToWake = xTickCount + xTicksToWait;
    9124:	6b60      	ldr	r0, [r4, #52]	; 0x34
			prvAddCurrentTaskToDelayedList(xTimeToWake);
    9126:	4b06      	ldr	r3, [pc, #24]	; (9140 <vTaskPlaceOnEventList+0x58>)
    9128:	4428      	add	r0, r5
}
    912a:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
			prvAddCurrentTaskToDelayedList(xTimeToWake);
    912e:	4718      	bx	r3
    9130:	20016274 	.word	0x20016274
    9134:	00001e31 	.word	0x00001e31
    9138:	00001e5f 	.word	0x00001e5f
    913c:	00001e19 	.word	0x00001e19
    9140:	00008b0d 	.word	0x00008b0d

00009144 <vTaskPlaceOnEventListRestricted>:
{
    9144:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    9148:	460d      	mov	r5, r1
    914a:	4616      	mov	r6, r2
	configASSERT(pxEventList);
    914c:	b940      	cbnz	r0, 9160 <vTaskPlaceOnEventListRestricted+0x1c>
    914e:	f04f 0380 	mov.w	r3, #128	; 0x80
    9152:	f383 8811 	msr	BASEPRI, r3
    9156:	f3bf 8f6f 	isb	sy
    915a:	f3bf 8f4f 	dsb	sy
    915e:	e7fe      	b.n	915e <vTaskPlaceOnEventListRestricted+0x1a>
	vListInsertEnd(pxEventList, &(pxCurrentTCB->xEventListItem));
    9160:	4c0b      	ldr	r4, [pc, #44]	; (9190 <vTaskPlaceOnEventListRestricted+0x4c>)
    9162:	4f0c      	ldr	r7, [pc, #48]	; (9194 <vTaskPlaceOnEventListRestricted+0x50>)
    9164:	6b21      	ldr	r1, [r4, #48]	; 0x30
    9166:	3118      	adds	r1, #24
    9168:	47b8      	blx	r7
	if (uxListRemove(&(pxCurrentTCB->xGenericListItem)) == (UBaseType_t)0) {
    916a:	6b20      	ldr	r0, [r4, #48]	; 0x30
    916c:	4b0a      	ldr	r3, [pc, #40]	; (9198 <vTaskPlaceOnEventListRestricted+0x54>)
    916e:	3004      	adds	r0, #4
    9170:	4798      	blx	r3
		if (xWaitIndefinitely == pdTRUE) {
    9172:	2e01      	cmp	r6, #1
    9174:	d106      	bne.n	9184 <vTaskPlaceOnEventListRestricted+0x40>
			vListInsertEnd(&xSuspendedTaskList, &(pxCurrentTCB->xGenericListItem));
    9176:	6b21      	ldr	r1, [r4, #48]	; 0x30
    9178:	4620      	mov	r0, r4
    917a:	463b      	mov	r3, r7
    917c:	3104      	adds	r1, #4
}
    917e:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
			vListInsertEnd(&xSuspendedTaskList, &(pxCurrentTCB->xGenericListItem));
    9182:	4718      	bx	r3
			xTimeToWake = xTickCount + xTicksToWait;
    9184:	6b60      	ldr	r0, [r4, #52]	; 0x34
			prvAddCurrentTaskToDelayedList(xTimeToWake);
    9186:	4b05      	ldr	r3, [pc, #20]	; (919c <vTaskPlaceOnEventListRestricted+0x58>)
    9188:	4428      	add	r0, r5
}
    918a:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
			prvAddCurrentTaskToDelayedList(xTimeToWake);
    918e:	4718      	bx	r3
    9190:	20016274 	.word	0x20016274
    9194:	00001e19 	.word	0x00001e19
    9198:	00001e5f 	.word	0x00001e5f
    919c:	00008b0d 	.word	0x00008b0d

000091a0 <xTaskRemoveFromEventList>:
	pxUnblockedTCB = (TCB_t *)listGET_OWNER_OF_HEAD_ENTRY(pxEventList);
    91a0:	68c3      	ldr	r3, [r0, #12]
{
    91a2:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
	pxUnblockedTCB = (TCB_t *)listGET_OWNER_OF_HEAD_ENTRY(pxEventList);
    91a4:	68dd      	ldr	r5, [r3, #12]
	configASSERT(pxUnblockedTCB);
    91a6:	b945      	cbnz	r5, 91ba <xTaskRemoveFromEventList+0x1a>
    91a8:	f04f 0380 	mov.w	r3, #128	; 0x80
    91ac:	f383 8811 	msr	BASEPRI, r3
    91b0:	f3bf 8f6f 	isb	sy
    91b4:	f3bf 8f4f 	dsb	sy
    91b8:	e7fe      	b.n	91b8 <xTaskRemoveFromEventList+0x18>
	(void)uxListRemove(&(pxUnblockedTCB->xEventListItem));
    91ba:	f105 0118 	add.w	r1, r5, #24
	if (uxSchedulerSuspended == (UBaseType_t)pdFALSE) {
    91be:	4c14      	ldr	r4, [pc, #80]	; (9210 <xTaskRemoveFromEventList+0x70>)
	(void)uxListRemove(&(pxUnblockedTCB->xEventListItem));
    91c0:	4f14      	ldr	r7, [pc, #80]	; (9214 <xTaskRemoveFromEventList+0x74>)
    91c2:	9101      	str	r1, [sp, #4]
    91c4:	4608      	mov	r0, r1
    91c6:	47b8      	blx	r7
	if (uxSchedulerSuspended == (UBaseType_t)pdFALSE) {
    91c8:	f8d4 30f0 	ldr.w	r3, [r4, #240]	; 0xf0
    91cc:	4e12      	ldr	r6, [pc, #72]	; (9218 <xTaskRemoveFromEventList+0x78>)
    91ce:	9901      	ldr	r1, [sp, #4]
    91d0:	b9db      	cbnz	r3, 920a <xTaskRemoveFromEventList+0x6a>
		(void)uxListRemove(&(pxUnblockedTCB->xGenericListItem));
    91d2:	1d29      	adds	r1, r5, #4
    91d4:	4608      	mov	r0, r1
    91d6:	9101      	str	r1, [sp, #4]
    91d8:	47b8      	blx	r7
		prvAddTaskToReadyList(pxUnblockedTCB);
    91da:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
    91dc:	f8d4 20e8 	ldr.w	r2, [r4, #232]	; 0xe8
    91e0:	9901      	ldr	r1, [sp, #4]
    91e2:	4293      	cmp	r3, r2
    91e4:	4a0d      	ldr	r2, [pc, #52]	; (921c <xTaskRemoveFromEventList+0x7c>)
    91e6:	bf88      	it	hi
    91e8:	f8c4 30e8 	strhi.w	r3, [r4, #232]	; 0xe8
    91ec:	2014      	movs	r0, #20
    91ee:	fb00 2003 	mla	r0, r0, r3, r2
		vListInsertEnd(&(xPendingReadyList), &(pxUnblockedTCB->xEventListItem));
    91f2:	47b0      	blx	r6
	if (pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority) {
    91f4:	6b23      	ldr	r3, [r4, #48]	; 0x30
    91f6:	6aea      	ldr	r2, [r5, #44]	; 0x2c
    91f8:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    91fa:	429a      	cmp	r2, r3
		xYieldPending = pdTRUE;
    91fc:	bf8a      	itet	hi
    91fe:	2001      	movhi	r0, #1
		xReturn = pdFALSE;
    9200:	2000      	movls	r0, #0
		xYieldPending = pdTRUE;
    9202:	f8c4 00fc 	strhi.w	r0, [r4, #252]	; 0xfc
}
    9206:	b003      	add	sp, #12
    9208:	bdf0      	pop	{r4, r5, r6, r7, pc}
		vListInsertEnd(&(xPendingReadyList), &(pxUnblockedTCB->xEventListItem));
    920a:	f104 0014 	add.w	r0, r4, #20
    920e:	e7f0      	b.n	91f2 <xTaskRemoveFromEventList+0x52>
    9210:	20016274 	.word	0x20016274
    9214:	00001e5f 	.word	0x00001e5f
    9218:	00001e19 	.word	0x00001e19
    921c:	200162b4 	.word	0x200162b4

00009220 <vTaskSetTimeOutState>:
	configASSERT(pxTimeOut);
    9220:	b940      	cbnz	r0, 9234 <vTaskSetTimeOutState+0x14>
    9222:	f04f 0380 	mov.w	r3, #128	; 0x80
    9226:	f383 8811 	msr	BASEPRI, r3
    922a:	f3bf 8f6f 	isb	sy
    922e:	f3bf 8f4f 	dsb	sy
    9232:	e7fe      	b.n	9232 <vTaskSetTimeOutState+0x12>
	pxTimeOut->xOverflowCount  = xNumOfOverflows;
    9234:	4b03      	ldr	r3, [pc, #12]	; (9244 <vTaskSetTimeOutState+0x24>)
    9236:	f8d3 20f4 	ldr.w	r2, [r3, #244]	; 0xf4
	pxTimeOut->xTimeOnEntering = xTickCount;
    923a:	6b5b      	ldr	r3, [r3, #52]	; 0x34
	pxTimeOut->xOverflowCount  = xNumOfOverflows;
    923c:	6002      	str	r2, [r0, #0]
	pxTimeOut->xTimeOnEntering = xTickCount;
    923e:	6043      	str	r3, [r0, #4]
}
    9240:	4770      	bx	lr
    9242:	bf00      	nop
    9244:	20016274 	.word	0x20016274

00009248 <xTaskCheckForTimeOut>:
{
    9248:	b570      	push	{r4, r5, r6, lr}
    924a:	460d      	mov	r5, r1
	configASSERT(pxTimeOut);
    924c:	4604      	mov	r4, r0
    924e:	b940      	cbnz	r0, 9262 <xTaskCheckForTimeOut+0x1a>
    9250:	f04f 0380 	mov.w	r3, #128	; 0x80
    9254:	f383 8811 	msr	BASEPRI, r3
    9258:	f3bf 8f6f 	isb	sy
    925c:	f3bf 8f4f 	dsb	sy
    9260:	e7fe      	b.n	9260 <xTaskCheckForTimeOut+0x18>
	configASSERT(pxTicksToWait);
    9262:	b941      	cbnz	r1, 9276 <xTaskCheckForTimeOut+0x2e>
    9264:	f04f 0380 	mov.w	r3, #128	; 0x80
    9268:	f383 8811 	msr	BASEPRI, r3
    926c:	f3bf 8f6f 	isb	sy
    9270:	f3bf 8f4f 	dsb	sy
    9274:	e7fe      	b.n	9274 <xTaskCheckForTimeOut+0x2c>
	taskENTER_CRITICAL();
    9276:	4b0f      	ldr	r3, [pc, #60]	; (92b4 <xTaskCheckForTimeOut+0x6c>)
    9278:	4798      	blx	r3
		if (*pxTicksToWait == portMAX_DELAY) {
    927a:	682b      	ldr	r3, [r5, #0]
		const TickType_t xConstTickCount = xTickCount;
    927c:	4a0e      	ldr	r2, [pc, #56]	; (92b8 <xTaskCheckForTimeOut+0x70>)
		if (*pxTicksToWait == portMAX_DELAY) {
    927e:	1c58      	adds	r0, r3, #1
		const TickType_t xConstTickCount = xTickCount;
    9280:	6b51      	ldr	r1, [r2, #52]	; 0x34
		if (*pxTicksToWait == portMAX_DELAY) {
    9282:	d010      	beq.n	92a6 <xTaskCheckForTimeOut+0x5e>
		    if ((xNumOfOverflows != pxTimeOut->xOverflowCount)
    9284:	f8d2 00f4 	ldr.w	r0, [r2, #244]	; 0xf4
    9288:	e9d4 6200 	ldrd	r6, r2, [r4]
    928c:	4286      	cmp	r6, r0
    928e:	d001      	beq.n	9294 <xTaskCheckForTimeOut+0x4c>
		        && (xConstTickCount >= pxTimeOut->xTimeOnEntering)) /*lint !e525 Indentation preferred as is to make
    9290:	4291      	cmp	r1, r2
    9292:	d20d      	bcs.n	92b0 <xTaskCheckForTimeOut+0x68>
		} else if ((xConstTickCount - pxTimeOut->xTimeOnEntering) < *pxTicksToWait) {
    9294:	1a88      	subs	r0, r1, r2
    9296:	4283      	cmp	r3, r0
    9298:	d90a      	bls.n	92b0 <xTaskCheckForTimeOut+0x68>
			*pxTicksToWait -= (xConstTickCount - pxTimeOut->xTimeOnEntering);
    929a:	1a5b      	subs	r3, r3, r1
    929c:	4413      	add	r3, r2
    929e:	602b      	str	r3, [r5, #0]
			vTaskSetTimeOutState(pxTimeOut);
    92a0:	4620      	mov	r0, r4
    92a2:	4b06      	ldr	r3, [pc, #24]	; (92bc <xTaskCheckForTimeOut+0x74>)
    92a4:	4798      	blx	r3
			xReturn = pdFALSE;
    92a6:	2400      	movs	r4, #0
	taskEXIT_CRITICAL();
    92a8:	4b05      	ldr	r3, [pc, #20]	; (92c0 <xTaskCheckForTimeOut+0x78>)
    92aa:	4798      	blx	r3
}
    92ac:	4620      	mov	r0, r4
    92ae:	bd70      	pop	{r4, r5, r6, pc}
			xReturn = pdTRUE;
    92b0:	2401      	movs	r4, #1
    92b2:	e7f9      	b.n	92a8 <xTaskCheckForTimeOut+0x60>
    92b4:	00009d55 	.word	0x00009d55
    92b8:	20016274 	.word	0x20016274
    92bc:	00009221 	.word	0x00009221
    92c0:	00009d95 	.word	0x00009d95

000092c4 <vTaskMissedYield>:
	xYieldPending = pdTRUE;
    92c4:	4b02      	ldr	r3, [pc, #8]	; (92d0 <vTaskMissedYield+0xc>)
    92c6:	2201      	movs	r2, #1
    92c8:	f8c3 20fc 	str.w	r2, [r3, #252]	; 0xfc
}
    92cc:	4770      	bx	lr
    92ce:	bf00      	nop
    92d0:	20016274 	.word	0x20016274

000092d4 <xTaskGetSchedulerState>:

BaseType_t xTaskGetSchedulerState(void)
{
	BaseType_t xReturn;

	if (xSchedulerRunning == pdFALSE) {
    92d4:	4b06      	ldr	r3, [pc, #24]	; (92f0 <xTaskGetSchedulerState+0x1c>)
    92d6:	f8d3 20e0 	ldr.w	r2, [r3, #224]	; 0xe0
    92da:	b132      	cbz	r2, 92ea <xTaskGetSchedulerState+0x16>
		xReturn = taskSCHEDULER_NOT_STARTED;
	} else {
		if (uxSchedulerSuspended == (UBaseType_t)pdFALSE) {
    92dc:	f8d3 30f0 	ldr.w	r3, [r3, #240]	; 0xf0
			xReturn = taskSCHEDULER_RUNNING;
		} else {
			xReturn = taskSCHEDULER_SUSPENDED;
    92e0:	2b00      	cmp	r3, #0
    92e2:	bf0c      	ite	eq
    92e4:	2002      	moveq	r0, #2
    92e6:	2000      	movne	r0, #0
    92e8:	4770      	bx	lr
		xReturn = taskSCHEDULER_NOT_STARTED;
    92ea:	2001      	movs	r0, #1
		}
	}

	return xReturn;
}
    92ec:	4770      	bx	lr
    92ee:	bf00      	nop
    92f0:	20016274 	.word	0x20016274

000092f4 <vTaskPriorityInherit>:
	/*-----------------------------------------------------------*/

#if (configUSE_MUTEXES == 1)

void vTaskPriorityInherit(TaskHandle_t const pxMutexHolder)
{
    92f4:	b573      	push	{r0, r1, r4, r5, r6, lr}
	TCB_t *const pxTCB = (TCB_t *)pxMutexHolder;

	/* If the mutex was given back by an interrupt while the queue was
	locked then the mutex holder might now be NULL. */
	if (pxMutexHolder != NULL) {
    92f6:	4604      	mov	r4, r0
    92f8:	2800      	cmp	r0, #0
    92fa:	d02c      	beq.n	9356 <vTaskPriorityInherit+0x62>
		/* If the holder of the mutex has a priority below the priority of
		the task attempting to obtain the mutex then it will temporarily
		inherit the priority of the task attempting to obtain the mutex. */
		if (pxTCB->uxPriority < pxCurrentTCB->uxPriority) {
    92fc:	4d18      	ldr	r5, [pc, #96]	; (9360 <vTaskPriorityInherit+0x6c>)
    92fe:	6ac3      	ldr	r3, [r0, #44]	; 0x2c
    9300:	6b2a      	ldr	r2, [r5, #48]	; 0x30
    9302:	6ad2      	ldr	r2, [r2, #44]	; 0x2c
    9304:	4293      	cmp	r3, r2
    9306:	d226      	bcs.n	9356 <vTaskPriorityInherit+0x62>
			/* Adjust the mutex holder state to account for its new
			priority.  Only reset the event list item value if the value is
			not	being used for anything else. */
			if ((listGET_LIST_ITEM_VALUE(&(pxTCB->xEventListItem)) & taskEVENT_LIST_ITEM_VALUE_IN_USE) == 0UL) {
    9308:	6982      	ldr	r2, [r0, #24]
				mtCOVERAGE_TEST_MARKER();
			}

			/* If the task being modified is in the ready state it will need
			to be moved into a new list. */
			if (listIS_CONTAINED_WITHIN(&(pxReadyTasksLists[pxTCB->uxPriority]), &(pxTCB->xGenericListItem))
    930a:	4e16      	ldr	r6, [pc, #88]	; (9364 <vTaskPriorityInherit+0x70>)
			if ((listGET_LIST_ITEM_VALUE(&(pxTCB->xEventListItem)) & taskEVENT_LIST_ITEM_VALUE_IN_USE) == 0UL) {
    930c:	2a00      	cmp	r2, #0
				listSET_LIST_ITEM_VALUE(
    930e:	bfa1      	itttt	ge
    9310:	6b2a      	ldrge	r2, [r5, #48]	; 0x30
    9312:	6ad2      	ldrge	r2, [r2, #44]	; 0x2c
    9314:	f1c2 0205 	rsbge	r2, r2, #5
    9318:	6182      	strge	r2, [r0, #24]
			if (listIS_CONTAINED_WITHIN(&(pxReadyTasksLists[pxTCB->uxPriority]), &(pxTCB->xGenericListItem))
    931a:	2214      	movs	r2, #20
    931c:	fb02 6303 	mla	r3, r2, r3, r6
			    != pdFALSE) {
    9320:	6942      	ldr	r2, [r0, #20]
    9322:	429a      	cmp	r2, r3
    9324:	d114      	bne.n	9350 <vTaskPriorityInherit+0x5c>
				if (uxListRemove(&(pxTCB->xGenericListItem)) == (UBaseType_t)0) {
    9326:	1d01      	adds	r1, r0, #4
    9328:	4b0f      	ldr	r3, [pc, #60]	; (9368 <vTaskPriorityInherit+0x74>)
    932a:	9101      	str	r1, [sp, #4]
    932c:	4608      	mov	r0, r1
    932e:	4798      	blx	r3
				} else {
					mtCOVERAGE_TEST_MARKER();
				}

				/* Inherit the priority before being moved into the new list. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
    9330:	6b2b      	ldr	r3, [r5, #48]	; 0x30
				prvAddTaskToReadyList(pxTCB);
    9332:	f8d5 20e8 	ldr.w	r2, [r5, #232]	; 0xe8
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
    9336:	6adb      	ldr	r3, [r3, #44]	; 0x2c
				prvAddTaskToReadyList(pxTCB);
    9338:	9901      	ldr	r1, [sp, #4]
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
    933a:	62e3      	str	r3, [r4, #44]	; 0x2c
				prvAddTaskToReadyList(pxTCB);
    933c:	4293      	cmp	r3, r2
    933e:	d80c      	bhi.n	935a <vTaskPriorityInherit+0x66>
    9340:	2014      	movs	r0, #20
    9342:	fb00 6003 	mla	r0, r0, r3, r6
    9346:	4b09      	ldr	r3, [pc, #36]	; (936c <vTaskPriorityInherit+0x78>)
			mtCOVERAGE_TEST_MARKER();
		}
	} else {
		mtCOVERAGE_TEST_MARKER();
	}
}
    9348:	b002      	add	sp, #8
    934a:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
				prvAddTaskToReadyList(pxTCB);
    934e:	4718      	bx	r3
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
    9350:	6b2b      	ldr	r3, [r5, #48]	; 0x30
    9352:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    9354:	62c3      	str	r3, [r0, #44]	; 0x2c
}
    9356:	b002      	add	sp, #8
    9358:	bd70      	pop	{r4, r5, r6, pc}
				prvAddTaskToReadyList(pxTCB);
    935a:	f8c5 30e8 	str.w	r3, [r5, #232]	; 0xe8
    935e:	e7ef      	b.n	9340 <vTaskPriorityInherit+0x4c>
    9360:	20016274 	.word	0x20016274
    9364:	200162b4 	.word	0x200162b4
    9368:	00001e5f 	.word	0x00001e5f
    936c:	00001e19 	.word	0x00001e19

00009370 <xTaskPriorityDisinherit>:
	/*-----------------------------------------------------------*/

#if (configUSE_MUTEXES == 1)

BaseType_t xTaskPriorityDisinherit(TaskHandle_t const pxMutexHolder)
{
    9370:	b537      	push	{r0, r1, r2, r4, r5, lr}
	TCB_t *const pxTCB   = (TCB_t *)pxMutexHolder;
	BaseType_t   xReturn = pdFALSE;

	if (pxMutexHolder != NULL) {
    9372:	b910      	cbnz	r0, 937a <xTaskPriorityDisinherit+0xa>
	BaseType_t   xReturn = pdFALSE;
    9374:	2000      	movs	r0, #0
	} else {
		mtCOVERAGE_TEST_MARKER();
	}

	return xReturn;
}
    9376:	b003      	add	sp, #12
    9378:	bd30      	pop	{r4, r5, pc}
		configASSERT(pxTCB == pxCurrentTCB);
    937a:	4d1c      	ldr	r5, [pc, #112]	; (93ec <xTaskPriorityDisinherit+0x7c>)
    937c:	6b2c      	ldr	r4, [r5, #48]	; 0x30
    937e:	4284      	cmp	r4, r0
    9380:	d008      	beq.n	9394 <xTaskPriorityDisinherit+0x24>
    9382:	f04f 0380 	mov.w	r3, #128	; 0x80
    9386:	f383 8811 	msr	BASEPRI, r3
    938a:	f3bf 8f6f 	isb	sy
    938e:	f3bf 8f4f 	dsb	sy
    9392:	e7fe      	b.n	9392 <xTaskPriorityDisinherit+0x22>
		configASSERT(pxTCB->uxMutexesHeld);
    9394:	6ca3      	ldr	r3, [r4, #72]	; 0x48
    9396:	b943      	cbnz	r3, 93aa <xTaskPriorityDisinherit+0x3a>
    9398:	f04f 0380 	mov.w	r3, #128	; 0x80
    939c:	f383 8811 	msr	BASEPRI, r3
    93a0:	f3bf 8f6f 	isb	sy
    93a4:	f3bf 8f4f 	dsb	sy
    93a8:	e7fe      	b.n	93a8 <xTaskPriorityDisinherit+0x38>
		if (pxTCB->uxPriority != pxTCB->uxBasePriority) {
    93aa:	6ae1      	ldr	r1, [r4, #44]	; 0x2c
    93ac:	6c62      	ldr	r2, [r4, #68]	; 0x44
		(pxTCB->uxMutexesHeld)--;
    93ae:	3b01      	subs	r3, #1
		if (pxTCB->uxPriority != pxTCB->uxBasePriority) {
    93b0:	4291      	cmp	r1, r2
		(pxTCB->uxMutexesHeld)--;
    93b2:	64a3      	str	r3, [r4, #72]	; 0x48
		if (pxTCB->uxPriority != pxTCB->uxBasePriority) {
    93b4:	d0de      	beq.n	9374 <xTaskPriorityDisinherit+0x4>
			if (pxTCB->uxMutexesHeld == (UBaseType_t)0) {
    93b6:	2b00      	cmp	r3, #0
    93b8:	d1dc      	bne.n	9374 <xTaskPriorityDisinherit+0x4>
				if (uxListRemove(&(pxTCB->xGenericListItem)) == (UBaseType_t)0) {
    93ba:	1d21      	adds	r1, r4, #4
    93bc:	4b0c      	ldr	r3, [pc, #48]	; (93f0 <xTaskPriorityDisinherit+0x80>)
    93be:	9101      	str	r1, [sp, #4]
    93c0:	4608      	mov	r0, r1
    93c2:	4798      	blx	r3
				pxTCB->uxPriority = pxTCB->uxBasePriority;
    93c4:	6c63      	ldr	r3, [r4, #68]	; 0x44
    93c6:	62e3      	str	r3, [r4, #44]	; 0x2c
				listSET_LIST_ITEM_VALUE(
    93c8:	f1c3 0205 	rsb	r2, r3, #5
    93cc:	61a2      	str	r2, [r4, #24]
				prvAddTaskToReadyList(pxTCB);
    93ce:	f8d5 20e8 	ldr.w	r2, [r5, #232]	; 0xe8
    93d2:	9901      	ldr	r1, [sp, #4]
    93d4:	4293      	cmp	r3, r2
    93d6:	4a07      	ldr	r2, [pc, #28]	; (93f4 <xTaskPriorityDisinherit+0x84>)
    93d8:	bf88      	it	hi
    93da:	f8c5 30e8 	strhi.w	r3, [r5, #232]	; 0xe8
    93de:	2014      	movs	r0, #20
    93e0:	fb00 2003 	mla	r0, r0, r3, r2
    93e4:	4b04      	ldr	r3, [pc, #16]	; (93f8 <xTaskPriorityDisinherit+0x88>)
    93e6:	4798      	blx	r3
				xReturn = pdTRUE;
    93e8:	2001      	movs	r0, #1
	return xReturn;
    93ea:	e7c4      	b.n	9376 <xTaskPriorityDisinherit+0x6>
    93ec:	20016274 	.word	0x20016274
    93f0:	00001e5f 	.word	0x00001e5f
    93f4:	200162b4 	.word	0x200162b4
    93f8:	00001e19 	.word	0x00001e19

000093fc <pvTaskIncrementMutexHeldCount>:

void *pvTaskIncrementMutexHeldCount(void)
{
	/* If xSemaphoreCreateMutex() is called before any tasks have been created
	then pxCurrentTCB will be NULL. */
	if (pxCurrentTCB != NULL) {
    93fc:	4b04      	ldr	r3, [pc, #16]	; (9410 <pvTaskIncrementMutexHeldCount+0x14>)
    93fe:	6b1a      	ldr	r2, [r3, #48]	; 0x30
    9400:	b11a      	cbz	r2, 940a <pvTaskIncrementMutexHeldCount+0xe>
		(pxCurrentTCB->uxMutexesHeld)++;
    9402:	6b19      	ldr	r1, [r3, #48]	; 0x30
    9404:	6c8a      	ldr	r2, [r1, #72]	; 0x48
    9406:	3201      	adds	r2, #1
    9408:	648a      	str	r2, [r1, #72]	; 0x48
	}

	return pxCurrentTCB;
    940a:	6b18      	ldr	r0, [r3, #48]	; 0x30
}
    940c:	4770      	bx	lr
    940e:	bf00      	nop
    9410:	20016274 	.word	0x20016274

00009414 <get_socket>:
 */
static struct lwip_sock *get_socket(int s)
{
	struct lwip_sock *sock;

	if ((s < 0) || (s >= NUM_SOCKETS)) {
    9414:	2803      	cmp	r0, #3
    9416:	d808      	bhi.n	942a <get_socket+0x16>
		LWIP_DEBUGF(SOCKETS_DEBUG, ("get_socket(%d): invalid\n", s));
		set_errno(EBADF);
		return NULL;
	}

	sock = &sockets[s];
    9418:	2318      	movs	r3, #24
    941a:	4a05      	ldr	r2, [pc, #20]	; (9430 <get_socket+0x1c>)
    941c:	4343      	muls	r3, r0
    941e:	18d0      	adds	r0, r2, r3

	if (!sock->conn) {
    9420:	58d3      	ldr	r3, [r2, r3]
		return NULL;
    9422:	2b00      	cmp	r3, #0
    9424:	bf08      	it	eq
    9426:	2000      	moveq	r0, #0
    9428:	4770      	bx	lr
    942a:	2000      	movs	r0, #0
		set_errno(EBADF);
		return NULL;
	}

	return sock;
}
    942c:	4770      	bx	lr
    942e:	bf00      	nop
    9430:	20016374 	.word	0x20016374

00009434 <alloc_socket>:

	/* allocate a new socket identifier */
	for (i = 0; i < NUM_SOCKETS; ++i) {
		/* Protect socket array */
		SYS_ARCH_PROTECT(lev);
		if (!sockets[i].conn) {
    9434:	4b0d      	ldr	r3, [pc, #52]	; (946c <alloc_socket+0x38>)
{
    9436:	b570      	push	{r4, r5, r6, lr}
    9438:	4604      	mov	r4, r0
		if (!sockets[i].conn) {
    943a:	2618      	movs	r6, #24
	for (i = 0; i < NUM_SOCKETS; ++i) {
    943c:	2000      	movs	r0, #0
		if (!sockets[i].conn) {
    943e:	fb06 f500 	mul.w	r5, r6, r0
    9442:	58ea      	ldr	r2, [r5, r3]
    9444:	b962      	cbnz	r2, 9460 <alloc_socket+0x2c>
			sockets[i].conn = newconn;
    9446:	195e      	adds	r6, r3, r5
    9448:	515c      	str	r4, [r3, r5]
			/* The socket is not yet known to anyone, so no need to protect
			   after having marked it as used. */
			SYS_ARCH_UNPROTECT(lev);
			sockets[i].lastdata   = NULL;
			sockets[i].lastoffset = 0;
    944a:	e9c6 2201 	strd	r2, r2, [r6, #4]
			sockets[i].rcvevent   = 0;
			/* TCP sendbuf is empty, but the socket is not yet writable until connected
			 * (unless it has been created by accept()). */
			sockets[i].sendevent      = (newconn->type == NETCONN_TCP ? (accepted != 0) : 1);
    944e:	7824      	ldrb	r4, [r4, #0]
			sockets[i].errevent       = 0;
    9450:	81f2      	strh	r2, [r6, #14]
			sockets[i].sendevent      = (newconn->type == NETCONN_TCP ? (accepted != 0) : 1);
    9452:	2c10      	cmp	r4, #16
			sockets[i].err            = 0;
			sockets[i].select_waiting = 0;
    9454:	e9c6 2204 	strd	r2, r2, [r6, #16]
			sockets[i].sendevent      = (newconn->type == NETCONN_TCP ? (accepted != 0) : 1);
    9458:	bf18      	it	ne
    945a:	2101      	movne	r1, #1
    945c:	81b1      	strh	r1, [r6, #12]
			return i;
		}
		SYS_ARCH_UNPROTECT(lev);
	}
	return -1;
}
    945e:	bd70      	pop	{r4, r5, r6, pc}
	for (i = 0; i < NUM_SOCKETS; ++i) {
    9460:	3001      	adds	r0, #1
    9462:	2804      	cmp	r0, #4
    9464:	d1eb      	bne.n	943e <alloc_socket+0xa>
	return -1;
    9466:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    946a:	e7f8      	b.n	945e <alloc_socket+0x2a>
    946c:	20016374 	.word	0x20016374

00009470 <event_callback>:
/**
 * Callback registered in the netconn layer for each socket-netconn.
 * Processes recvevent (data available) and wakes up tasks waiting for select.
 */
static void event_callback(struct netconn *conn, enum netconn_evt evt, u16_t len)
{
    9470:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
	SYS_ARCH_DECL_PROTECT(lev);

	LWIP_UNUSED_ARG(len);

	/* Get socket */
	if (conn) {
    9474:	b128      	cbz	r0, 9482 <event_callback+0x12>
		s = conn->socket;
    9476:	6985      	ldr	r5, [r0, #24]
		if (s < 0) {
    9478:	2d00      	cmp	r5, #0
    947a:	da04      	bge.n	9486 <event_callback+0x16>
			 * Just count down (or up) if that's the case and we
			 * will use the data later. Note that only receive events
			 * can happen before the new socket is set up. */
			SYS_ARCH_PROTECT(lev);
			if (conn->socket < 0) {
				if (evt == NETCONN_EVT_RCVPLUS) {
    947c:	b909      	cbnz	r1, 9482 <event_callback+0x12>
					conn->socket--;
    947e:	3d01      	subs	r5, #1
    9480:	6185      	str	r5, [r0, #24]
			/* someone has changed select_cb_list, restart at the beginning */
			goto again;
		}
	}
	SYS_ARCH_UNPROTECT(lev);
}
    9482:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
		sock = get_socket(s);
    9486:	4b30      	ldr	r3, [pc, #192]	; (9548 <event_callback+0xd8>)
    9488:	4628      	mov	r0, r5
    948a:	4798      	blx	r3
		if (!sock) {
    948c:	4604      	mov	r4, r0
    948e:	2800      	cmp	r0, #0
    9490:	d0f7      	beq.n	9482 <event_callback+0x12>
	switch (evt) {
    9492:	2904      	cmp	r1, #4
    9494:	d807      	bhi.n	94a6 <event_callback+0x36>
    9496:	e8df f001 	tbb	[pc, r1]
    949a:	4303      	.short	0x4303
    949c:	4946      	.short	0x4946
    949e:	4b          	.byte	0x4b
    949f:	00          	.byte	0x00
		sock->rcvevent++;
    94a0:	8943      	ldrh	r3, [r0, #10]
    94a2:	3301      	adds	r3, #1
		sock->rcvevent--;
    94a4:	8163      	strh	r3, [r4, #10]
	if (sock->select_waiting == 0) {
    94a6:	6963      	ldr	r3, [r4, #20]
    94a8:	2b00      	cmp	r3, #0
    94aa:	d0ea      	beq.n	9482 <event_callback+0x12>
				if (scb->readset && FD_ISSET(s, scb->readset)) {
    94ac:	116f      	asrs	r7, r5, #5
    94ae:	f04f 0801 	mov.w	r8, #1
				if (!do_signal && scb->exceptset && FD_ISSET(s, scb->exceptset)) {
    94b2:	f005 051f 	and.w	r5, r5, #31
	for (scb = select_cb_list; scb != NULL; scb = scb->next) {
    94b6:	f8df 9094 	ldr.w	r9, [pc, #148]	; 954c <event_callback+0xdc>
				sys_sem_signal(&scb->sem);
    94ba:	f8df b094 	ldr.w	fp, [pc, #148]	; 9550 <event_callback+0xe0>
    94be:	fa08 f805 	lsl.w	r8, r8, r5
	for (scb = select_cb_list; scb != NULL; scb = scb->next) {
    94c2:	f8d9 6060 	ldr.w	r6, [r9, #96]	; 0x60
				scb->sem_signalled = 1;
    94c6:	f04f 0a01 	mov.w	sl, #1
	for (scb = select_cb_list; scb != NULL; scb = scb->next) {
    94ca:	2e00      	cmp	r6, #0
    94cc:	d0d9      	beq.n	9482 <event_callback+0x12>
		if (scb->sem_signalled == 0) {
    94ce:	6973      	ldr	r3, [r6, #20]
    94d0:	b9f3      	cbnz	r3, 9510 <event_callback+0xa0>
			if (sock->rcvevent > 0) {
    94d2:	f9b4 200a 	ldrsh.w	r2, [r4, #10]
    94d6:	2a00      	cmp	r2, #0
    94d8:	dd06      	ble.n	94e8 <event_callback+0x78>
				if (scb->readset && FD_ISSET(s, scb->readset)) {
    94da:	68b2      	ldr	r2, [r6, #8]
    94dc:	b122      	cbz	r2, 94e8 <event_callback+0x78>
    94de:	f852 3027 	ldr.w	r3, [r2, r7, lsl #2]
    94e2:	40eb      	lsrs	r3, r5
    94e4:	f003 0301 	and.w	r3, r3, #1
			if (sock->sendevent != 0) {
    94e8:	89a2      	ldrh	r2, [r4, #12]
    94ea:	b13a      	cbz	r2, 94fc <event_callback+0x8c>
				if (!do_signal && scb->writeset && FD_ISSET(s, scb->writeset)) {
    94ec:	b933      	cbnz	r3, 94fc <event_callback+0x8c>
    94ee:	68f2      	ldr	r2, [r6, #12]
    94f0:	b122      	cbz	r2, 94fc <event_callback+0x8c>
    94f2:	f852 3027 	ldr.w	r3, [r2, r7, lsl #2]
    94f6:	40eb      	lsrs	r3, r5
    94f8:	f003 0301 	and.w	r3, r3, #1
			if (sock->errevent != 0) {
    94fc:	89e2      	ldrh	r2, [r4, #14]
    94fe:	b1d2      	cbz	r2, 9536 <event_callback+0xc6>
				if (!do_signal && scb->exceptset && FD_ISSET(s, scb->exceptset)) {
    9500:	b9db      	cbnz	r3, 953a <event_callback+0xca>
    9502:	6933      	ldr	r3, [r6, #16]
    9504:	b123      	cbz	r3, 9510 <event_callback+0xa0>
    9506:	f853 3027 	ldr.w	r3, [r3, r7, lsl #2]
    950a:	ea18 0f03 	tst.w	r8, r3
    950e:	d114      	bne.n	953a <event_callback+0xca>
		last_select_cb_ctr = select_cb_ctr;
    9510:	f8d9 3064 	ldr.w	r3, [r9, #100]	; 0x64
		if (last_select_cb_ctr != select_cb_ctr) {
    9514:	f8d9 2064 	ldr.w	r2, [r9, #100]	; 0x64
    9518:	429a      	cmp	r2, r3
    951a:	d1d2      	bne.n	94c2 <event_callback+0x52>
	for (scb = select_cb_list; scb != NULL; scb = scb->next) {
    951c:	6836      	ldr	r6, [r6, #0]
    951e:	e7d4      	b.n	94ca <event_callback+0x5a>
		sock->rcvevent--;
    9520:	8943      	ldrh	r3, [r0, #10]
    9522:	3b01      	subs	r3, #1
    9524:	e7be      	b.n	94a4 <event_callback+0x34>
		sock->sendevent = 1;
    9526:	2301      	movs	r3, #1
		sock->sendevent = 0;
    9528:	81a3      	strh	r3, [r4, #12]
		break;
    952a:	e7bc      	b.n	94a6 <event_callback+0x36>
		sock->sendevent = 0;
    952c:	2300      	movs	r3, #0
    952e:	e7fb      	b.n	9528 <event_callback+0xb8>
		sock->errevent = 1;
    9530:	2301      	movs	r3, #1
    9532:	81c3      	strh	r3, [r0, #14]
		break;
    9534:	e7b7      	b.n	94a6 <event_callback+0x36>
			if (do_signal) {
    9536:	2b00      	cmp	r3, #0
    9538:	d0ea      	beq.n	9510 <event_callback+0xa0>
				scb->sem_signalled = 1;
    953a:	f8c6 a014 	str.w	sl, [r6, #20]
				sys_sem_signal(&scb->sem);
    953e:	f106 0018 	add.w	r0, r6, #24
    9542:	47d8      	blx	fp
    9544:	e7e4      	b.n	9510 <event_callback+0xa0>
    9546:	bf00      	nop
    9548:	00009415 	.word	0x00009415
    954c:	20016374 	.word	0x20016374
    9550:	00007a19 	.word	0x00007a19

00009554 <lwip_setsockopt_internal>:
	sock = data->sock;
#ifdef LWIP_DEBUG
	s = data->s;
#endif /* LWIP_DEBUG */
	level   = data->level;
	optname = data->optname;
    9554:	e9d0 1301 	ldrd	r1, r3, [r0, #4]
	optval  = data->optval;
    9558:	68c2      	ldr	r2, [r0, #12]
		case SO_REUSEADDR:
		case SO_REUSEPORT:
#endif      /* SO_REUSE */
			/* UNIMPL case SO_USELOOPBACK: */
			if (*(int *)optval) {
				ip_set_option(sock->conn->pcb.ip, optname);
    955a:	6800      	ldr	r0, [r0, #0]
	switch (level) {
    955c:	2906      	cmp	r1, #6
{
    955e:	b410      	push	{r4}
				ip_set_option(sock->conn->pcb.ip, optname);
    9560:	6800      	ldr	r0, [r0, #0]
	switch (level) {
    9562:	d032      	beq.n	95ca <lwip_setsockopt_internal+0x76>
    9564:	f640 74ff 	movw	r4, #4095	; 0xfff
    9568:	42a1      	cmp	r1, r4
    956a:	d008      	beq.n	957e <lwip_setsockopt_internal+0x2a>
    956c:	b9b1      	cbnz	r1, 959c <lwip_setsockopt_internal+0x48>
		} /* switch (optname) */
		break;

		/* Level: IPPROTO_IP */
	case IPPROTO_IP:
		switch (optname) {
    956e:	2b01      	cmp	r3, #1
    9570:	d027      	beq.n	95c2 <lwip_setsockopt_internal+0x6e>
    9572:	2b02      	cmp	r3, #2
    9574:	d112      	bne.n	959c <lwip_setsockopt_internal+0x48>
		case IP_TTL:
			sock->conn->pcb.ip->ttl = (u8_t)(*(int *)optval);
    9576:	6843      	ldr	r3, [r0, #4]
    9578:	6812      	ldr	r2, [r2, #0]
    957a:	729a      	strb	r2, [r3, #10]
			LWIP_DEBUGF(SOCKETS_DEBUG,
			            ("lwip_setsockopt(%d, IPPROTO_IP, IP_TTL, ..) -> %d\n", s, sock->conn->pcb.ip->ttl));
			break;
    957c:	e00e      	b.n	959c <lwip_setsockopt_internal+0x48>
		switch (optname) {
    957e:	2b20      	cmp	r3, #32
    9580:	d005      	beq.n	958e <lwip_setsockopt_internal+0x3a>
    9582:	f241 010a 	movw	r1, #4106	; 0x100a
    9586:	428b      	cmp	r3, r1
    9588:	d010      	beq.n	95ac <lwip_setsockopt_internal+0x58>
    958a:	2b08      	cmp	r3, #8
    958c:	d106      	bne.n	959c <lwip_setsockopt_internal+0x48>
				ip_set_option(sock->conn->pcb.ip, optname);
    958e:	6841      	ldr	r1, [r0, #4]
			if (*(int *)optval) {
    9590:	6814      	ldr	r4, [r2, #0]
    9592:	7a0a      	ldrb	r2, [r1, #8]
				ip_set_option(sock->conn->pcb.ip, optname);
    9594:	b25b      	sxtb	r3, r3
			if (*(int *)optval) {
    9596:	b134      	cbz	r4, 95a6 <lwip_setsockopt_internal+0x52>
				ip_set_option(sock->conn->pcb.ip, optname);
    9598:	4313      	orrs	r3, r2
				ip_reset_option(sock->conn->pcb.ip, optname);
    959a:	720b      	strb	r3, [r1, #8]
#endif /* LWIP_UDP */
	default:
		LWIP_ASSERT("unhandled level", 0);
		break;
	} /* switch (level) */
	sys_sem_signal(&sock->conn->op_completed);
    959c:	4b15      	ldr	r3, [pc, #84]	; (95f4 <lwip_setsockopt_internal+0xa0>)
}
    959e:	f85d 4b04 	ldr.w	r4, [sp], #4
	sys_sem_signal(&sock->conn->op_completed);
    95a2:	300c      	adds	r0, #12
    95a4:	4718      	bx	r3
				ip_reset_option(sock->conn->pcb.ip, optname);
    95a6:	ea22 0303 	bic.w	r3, r2, r3
    95aa:	e7f6      	b.n	959a <lwip_setsockopt_internal+0x46>
				ip_set_option(sock->conn->pcb.ip, optname);
    95ac:	6841      	ldr	r1, [r0, #4]
			if (*(int *)optval) {
    95ae:	6812      	ldr	r2, [r2, #0]
				udp_setflags(sock->conn->pcb.udp, udp_flags(sock->conn->pcb.udp) | UDP_FLAGS_NOCHKSUM);
    95b0:	7c0b      	ldrb	r3, [r1, #16]
			if (*(int *)optval) {
    95b2:	b11a      	cbz	r2, 95bc <lwip_setsockopt_internal+0x68>
				udp_setflags(sock->conn->pcb.udp, udp_flags(sock->conn->pcb.udp) | UDP_FLAGS_NOCHKSUM);
    95b4:	f043 0301 	orr.w	r3, r3, #1
				udp_setflags(sock->conn->pcb.udp, udp_flags(sock->conn->pcb.udp) & ~UDP_FLAGS_NOCHKSUM);
    95b8:	740b      	strb	r3, [r1, #16]
    95ba:	e7ef      	b.n	959c <lwip_setsockopt_internal+0x48>
    95bc:	f023 0301 	bic.w	r3, r3, #1
    95c0:	e7fa      	b.n	95b8 <lwip_setsockopt_internal+0x64>
			sock->conn->pcb.ip->tos = (u8_t)(*(int *)optval);
    95c2:	6843      	ldr	r3, [r0, #4]
    95c4:	6812      	ldr	r2, [r2, #0]
    95c6:	725a      	strb	r2, [r3, #9]
			break;
    95c8:	e7e8      	b.n	959c <lwip_setsockopt_internal+0x48>
		switch (optname) {
    95ca:	2b01      	cmp	r3, #1
    95cc:	d006      	beq.n	95dc <lwip_setsockopt_internal+0x88>
    95ce:	2b02      	cmp	r3, #2
    95d0:	d1e4      	bne.n	959c <lwip_setsockopt_internal+0x48>
			sock->conn->pcb.tcp->keep_idle = (u32_t)(*(int *)optval);
    95d2:	6843      	ldr	r3, [r0, #4]
    95d4:	6812      	ldr	r2, [r2, #0]
    95d6:	f8c3 2090 	str.w	r2, [r3, #144]	; 0x90
			break;
    95da:	e7df      	b.n	959c <lwip_setsockopt_internal+0x48>
				ip_set_option(sock->conn->pcb.ip, optname);
    95dc:	6841      	ldr	r1, [r0, #4]
			if (*(int *)optval) {
    95de:	6812      	ldr	r2, [r2, #0]
				tcp_nagle_disable(sock->conn->pcb.tcp);
    95e0:	7f8b      	ldrb	r3, [r1, #30]
			if (*(int *)optval) {
    95e2:	b11a      	cbz	r2, 95ec <lwip_setsockopt_internal+0x98>
				tcp_nagle_disable(sock->conn->pcb.tcp);
    95e4:	f043 0340 	orr.w	r3, r3, #64	; 0x40
				tcp_nagle_enable(sock->conn->pcb.tcp);
    95e8:	778b      	strb	r3, [r1, #30]
    95ea:	e7d7      	b.n	959c <lwip_setsockopt_internal+0x48>
    95ec:	f023 0340 	bic.w	r3, r3, #64	; 0x40
    95f0:	e7fa      	b.n	95e8 <lwip_setsockopt_internal+0x94>
    95f2:	bf00      	nop
    95f4:	00007a19 	.word	0x00007a19

000095f8 <lwip_socket_init>:
}
    95f8:	4770      	bx	lr
	...

000095fc <lwip_accept>:
{
    95fc:	b5f0      	push	{r4, r5, r6, r7, lr}
	sock = get_socket(s);
    95fe:	4b3a      	ldr	r3, [pc, #232]	; (96e8 <lwip_accept+0xec>)
{
    9600:	b089      	sub	sp, #36	; 0x24
    9602:	4616      	mov	r6, r2
	sock = get_socket(s);
    9604:	4798      	blx	r3
{
    9606:	460f      	mov	r7, r1
	if (!sock) {
    9608:	4605      	mov	r5, r0
    960a:	b148      	cbz	r0, 9620 <lwip_accept+0x24>
	if (netconn_is_nonblocking(sock->conn) && (sock->rcvevent <= 0)) {
    960c:	6800      	ldr	r0, [r0, #0]
    960e:	7f03      	ldrb	r3, [r0, #28]
    9610:	079a      	lsls	r2, r3, #30
    9612:	d508      	bpl.n	9626 <lwip_accept+0x2a>
    9614:	f9b5 300a 	ldrsh.w	r3, [r5, #10]
    9618:	2b00      	cmp	r3, #0
    961a:	dc04      	bgt.n	9626 <lwip_accept+0x2a>
		sock_set_errno(sock, EWOULDBLOCK);
    961c:	230b      	movs	r3, #11
		sock_set_errno(sock, err_to_errno(err));
    961e:	612b      	str	r3, [r5, #16]
		return -1;
    9620:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
    9624:	e00a      	b.n	963c <lwip_accept+0x40>
	err = netconn_accept(sock->conn, &newconn);
    9626:	4b31      	ldr	r3, [pc, #196]	; (96ec <lwip_accept+0xf0>)
    9628:	a902      	add	r1, sp, #8
    962a:	4798      	blx	r3
	if (err != ERR_OK) {
    962c:	4603      	mov	r3, r0
    962e:	b178      	cbz	r0, 9650 <lwip_accept+0x54>
		if (netconn_type(sock->conn) != NETCONN_TCP) {
    9630:	682a      	ldr	r2, [r5, #0]
    9632:	7812      	ldrb	r2, [r2, #0]
    9634:	2a10      	cmp	r2, #16
    9636:	d004      	beq.n	9642 <lwip_accept+0x46>
			sock_set_errno(sock, EOPNOTSUPP);
    9638:	245f      	movs	r4, #95	; 0x5f
    963a:	612c      	str	r4, [r5, #16]
}
    963c:	4620      	mov	r0, r4
    963e:	b009      	add	sp, #36	; 0x24
    9640:	bdf0      	pop	{r4, r5, r6, r7, pc}
		sock_set_errno(sock, err_to_errno(err));
    9642:	4243      	negs	r3, r0
    9644:	2b0f      	cmp	r3, #15
    9646:	d819      	bhi.n	967c <lwip_accept+0x80>
    9648:	4a29      	ldr	r2, [pc, #164]	; (96f0 <lwip_accept+0xf4>)
    964a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    964e:	e7e6      	b.n	961e <lwip_accept+0x22>
	netconn_set_noautorecved(newconn, 1);
    9650:	9802      	ldr	r0, [sp, #8]
	err = netconn_peer(newconn, &naddr, &port);
    9652:	4c28      	ldr	r4, [pc, #160]	; (96f4 <lwip_accept+0xf8>)
	netconn_set_noautorecved(newconn, 1);
    9654:	7f02      	ldrb	r2, [r0, #28]
    9656:	f042 0208 	orr.w	r2, r2, #8
    965a:	7702      	strb	r2, [r0, #28]
	err = netconn_peer(newconn, &naddr, &port);
    965c:	a903      	add	r1, sp, #12
    965e:	f10d 0206 	add.w	r2, sp, #6
    9662:	47a0      	blx	r4
	if (err != ERR_OK) {
    9664:	4604      	mov	r4, r0
    9666:	b158      	cbz	r0, 9680 <lwip_accept+0x84>
		netconn_delete(newconn);
    9668:	9802      	ldr	r0, [sp, #8]
    966a:	4b23      	ldr	r3, [pc, #140]	; (96f8 <lwip_accept+0xfc>)
		sock_set_errno(sock, err_to_errno(err));
    966c:	4264      	negs	r4, r4
		netconn_delete(newconn);
    966e:	4798      	blx	r3
		sock_set_errno(sock, err_to_errno(err));
    9670:	2c0f      	cmp	r4, #15
    9672:	d803      	bhi.n	967c <lwip_accept+0x80>
    9674:	4b1e      	ldr	r3, [pc, #120]	; (96f0 <lwip_accept+0xf4>)
    9676:	f853 3024 	ldr.w	r3, [r3, r4, lsl #2]
    967a:	e7d0      	b.n	961e <lwip_accept+0x22>
    967c:	2305      	movs	r3, #5
    967e:	e7ce      	b.n	961e <lwip_accept+0x22>
	if (NULL != addr) {
    9680:	b1bf      	cbz	r7, 96b2 <lwip_accept+0xb6>
		sin.sin_len    = sizeof(sin);
    9682:	f44f 7304 	mov.w	r3, #528	; 0x210
		memset(&sin, 0, sizeof(sin));
    9686:	e9cd 0006 	strd	r0, r0, [sp, #24]
		sin.sin_len    = sizeof(sin);
    968a:	f8ad 3010 	strh.w	r3, [sp, #16]
		sin.sin_port   = htons(port);
    968e:	f8bd 0006 	ldrh.w	r0, [sp, #6]
    9692:	4b1a      	ldr	r3, [pc, #104]	; (96fc <lwip_accept+0x100>)
    9694:	4798      	blx	r3
		inet_addr_from_ipaddr(&sin.sin_addr, &naddr);
    9696:	9b03      	ldr	r3, [sp, #12]
    9698:	9305      	str	r3, [sp, #20]
		if (*addrlen > sizeof(sin))
    969a:	6833      	ldr	r3, [r6, #0]
		sin.sin_port   = htons(port);
    969c:	f8ad 0012 	strh.w	r0, [sp, #18]
		if (*addrlen > sizeof(sin))
    96a0:	2b10      	cmp	r3, #16
			*addrlen = sizeof(sin);
    96a2:	bf84      	itt	hi
    96a4:	2310      	movhi	r3, #16
    96a6:	6033      	strhi	r3, [r6, #0]
		MEMCPY(addr, &sin, *addrlen);
    96a8:	6832      	ldr	r2, [r6, #0]
    96aa:	4b15      	ldr	r3, [pc, #84]	; (9700 <lwip_accept+0x104>)
    96ac:	a904      	add	r1, sp, #16
    96ae:	4638      	mov	r0, r7
    96b0:	4798      	blx	r3
	newsock = alloc_socket(newconn, 1);
    96b2:	4b14      	ldr	r3, [pc, #80]	; (9704 <lwip_accept+0x108>)
    96b4:	9802      	ldr	r0, [sp, #8]
    96b6:	2101      	movs	r1, #1
    96b8:	4798      	blx	r3
	if (newsock == -1) {
    96ba:	1c43      	adds	r3, r0, #1
	newsock = alloc_socket(newconn, 1);
    96bc:	4604      	mov	r4, r0
	if (newsock == -1) {
    96be:	d105      	bne.n	96cc <lwip_accept+0xd0>
		netconn_delete(newconn);
    96c0:	4b0d      	ldr	r3, [pc, #52]	; (96f8 <lwip_accept+0xfc>)
    96c2:	9802      	ldr	r0, [sp, #8]
    96c4:	4798      	blx	r3
		sock_set_errno(sock, ENFILE);
    96c6:	2317      	movs	r3, #23
	sock_set_errno(sock, 0);
    96c8:	612b      	str	r3, [r5, #16]
	return newsock;
    96ca:	e7b7      	b.n	963c <lwip_accept+0x40>
	nsock->rcvevent += (s16_t)(-1 - newconn->socket);
    96cc:	4a0e      	ldr	r2, [pc, #56]	; (9708 <lwip_accept+0x10c>)
    96ce:	9902      	ldr	r1, [sp, #8]
    96d0:	2318      	movs	r3, #24
    96d2:	fb03 2200 	mla	r2, r3, r0, r2
    96d6:	698b      	ldr	r3, [r1, #24]
    96d8:	8950      	ldrh	r0, [r2, #10]
    96da:	43db      	mvns	r3, r3
    96dc:	4403      	add	r3, r0
    96de:	8153      	strh	r3, [r2, #10]
	newconn->socket = newsock;
    96e0:	618c      	str	r4, [r1, #24]
	sock_set_errno(sock, 0);
    96e2:	2300      	movs	r3, #0
    96e4:	e7f0      	b.n	96c8 <lwip_accept+0xcc>
    96e6:	bf00      	nop
    96e8:	00009415 	.word	0x00009415
    96ec:	000076e5 	.word	0x000076e5
    96f0:	0000b934 	.word	0x0000b934
    96f4:	00007649 	.word	0x00007649
    96f8:	0000761d 	.word	0x0000761d
    96fc:	00000d65 	.word	0x00000d65
    9700:	0000a349 	.word	0x0000a349
    9704:	00009435 	.word	0x00009435
    9708:	20016374 	.word	0x20016374

0000970c <lwip_bind>:
{
    970c:	b537      	push	{r0, r1, r2, r4, r5, lr}
	sock = get_socket(s);
    970e:	4b13      	ldr	r3, [pc, #76]	; (975c <lwip_bind+0x50>)
{
    9710:	4615      	mov	r5, r2
	sock = get_socket(s);
    9712:	4798      	blx	r3
	if (!sock) {
    9714:	4604      	mov	r4, r0
    9716:	b1d8      	cbz	r0, 9750 <lwip_bind+0x44>
	LWIP_ERROR(
    9718:	2d10      	cmp	r5, #16
    971a:	d104      	bne.n	9726 <lwip_bind+0x1a>
    971c:	784b      	ldrb	r3, [r1, #1]
    971e:	2b02      	cmp	r3, #2
    9720:	d101      	bne.n	9726 <lwip_bind+0x1a>
    9722:	078b      	lsls	r3, r1, #30
    9724:	d000      	beq.n	9728 <lwip_bind+0x1c>
    9726:	e7fe      	b.n	9726 <lwip_bind+0x1a>
	inet_addr_to_ipaddr(&local_addr, &name_in->sin_addr);
    9728:	684b      	ldr	r3, [r1, #4]
	err = netconn_bind(sock->conn, &local_addr, ntohs(local_port));
    972a:	6805      	ldr	r5, [r0, #0]
	inet_addr_to_ipaddr(&local_addr, &name_in->sin_addr);
    972c:	9301      	str	r3, [sp, #4]
	err = netconn_bind(sock->conn, &local_addr, ntohs(local_port));
    972e:	8848      	ldrh	r0, [r1, #2]
    9730:	4b0b      	ldr	r3, [pc, #44]	; (9760 <lwip_bind+0x54>)
    9732:	4798      	blx	r3
    9734:	4b0b      	ldr	r3, [pc, #44]	; (9764 <lwip_bind+0x58>)
    9736:	4602      	mov	r2, r0
    9738:	a901      	add	r1, sp, #4
    973a:	4628      	mov	r0, r5
    973c:	4798      	blx	r3
	if (err != ERR_OK) {
    973e:	b150      	cbz	r0, 9756 <lwip_bind+0x4a>
		sock_set_errno(sock, err_to_errno(err));
    9740:	4243      	negs	r3, r0
    9742:	2b0f      	cmp	r3, #15
    9744:	bf96      	itet	ls
    9746:	4a08      	ldrls	r2, [pc, #32]	; (9768 <lwip_bind+0x5c>)
    9748:	2305      	movhi	r3, #5
    974a:	f852 3023 	ldrls.w	r3, [r2, r3, lsl #2]
    974e:	6123      	str	r3, [r4, #16]
		return -1;
    9750:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    9754:	e000      	b.n	9758 <lwip_bind+0x4c>
	sock_set_errno(sock, 0);
    9756:	6120      	str	r0, [r4, #16]
}
    9758:	b003      	add	sp, #12
    975a:	bd30      	pop	{r4, r5, pc}
    975c:	00009415 	.word	0x00009415
    9760:	00000d6b 	.word	0x00000d6b
    9764:	00007685 	.word	0x00007685
    9768:	0000b934 	.word	0x0000b934

0000976c <lwip_close>:
{
    976c:	b570      	push	{r4, r5, r6, lr}
	sock = get_socket(s);
    976e:	4b12      	ldr	r3, [pc, #72]	; (97b8 <lwip_close+0x4c>)
    9770:	4798      	blx	r3
	if (!sock) {
    9772:	4604      	mov	r4, r0
    9774:	b1d0      	cbz	r0, 97ac <lwip_close+0x40>
	if (sock->conn != NULL) {
    9776:	6800      	ldr	r0, [r0, #0]
    9778:	b198      	cbz	r0, 97a2 <lwip_close+0x36>
		is_tcp = netconn_type(sock->conn) == NETCONN_TCP;
    977a:	7805      	ldrb	r5, [r0, #0]
    977c:	f1a5 0310 	sub.w	r3, r5, #16
    9780:	425d      	negs	r5, r3
    9782:	415d      	adcs	r5, r3
	netconn_delete(sock->conn);
    9784:	4b0d      	ldr	r3, [pc, #52]	; (97bc <lwip_close+0x50>)
    9786:	4798      	blx	r3
	lastdata         = sock->lastdata;
    9788:	6860      	ldr	r0, [r4, #4]
	sock->lastdata   = NULL;
    978a:	2600      	movs	r6, #0
    978c:	6066      	str	r6, [r4, #4]
	sock->lastoffset = 0;
    978e:	8126      	strh	r6, [r4, #8]
	sock->err        = 0;
    9790:	6126      	str	r6, [r4, #16]
	sock->conn = NULL;
    9792:	6026      	str	r6, [r4, #0]
	if (lastdata != NULL) {
    9794:	b168      	cbz	r0, 97b2 <lwip_close+0x46>
		if (is_tcp) {
    9796:	b135      	cbz	r5, 97a6 <lwip_close+0x3a>
			pbuf_free((struct pbuf *)lastdata);
    9798:	4b09      	ldr	r3, [pc, #36]	; (97c0 <lwip_close+0x54>)
    979a:	4798      	blx	r3
	return 0;
    979c:	4635      	mov	r5, r6
}
    979e:	4628      	mov	r0, r5
    97a0:	bd70      	pop	{r4, r5, r6, pc}
	int               is_tcp = 0;
    97a2:	4605      	mov	r5, r0
    97a4:	e7ee      	b.n	9784 <lwip_close+0x18>
			netbuf_delete((struct netbuf *)lastdata);
    97a6:	4b07      	ldr	r3, [pc, #28]	; (97c4 <lwip_close+0x58>)
    97a8:	4798      	blx	r3
    97aa:	e7f8      	b.n	979e <lwip_close+0x32>
		return -1;
    97ac:	f04f 35ff 	mov.w	r5, #4294967295	; 0xffffffff
    97b0:	e7f5      	b.n	979e <lwip_close+0x32>
	return 0;
    97b2:	4605      	mov	r5, r0
    97b4:	e7f3      	b.n	979e <lwip_close+0x32>
    97b6:	bf00      	nop
    97b8:	00009415 	.word	0x00009415
    97bc:	0000761d 	.word	0x0000761d
    97c0:	000030e5 	.word	0x000030e5
    97c4:	00000d7d 	.word	0x00000d7d

000097c8 <lwip_listen>:
{
    97c8:	b510      	push	{r4, lr}
	sock = get_socket(s);
    97ca:	4b0e      	ldr	r3, [pc, #56]	; (9804 <lwip_listen+0x3c>)
    97cc:	4798      	blx	r3
	if (!sock) {
    97ce:	4604      	mov	r4, r0
    97d0:	b1a8      	cbz	r0, 97fe <lwip_listen+0x36>
	err = netconn_listen_with_backlog(sock->conn, (u8_t)backlog);
    97d2:	f381 0108 	usat	r1, #8, r1
    97d6:	6800      	ldr	r0, [r0, #0]
    97d8:	4b0b      	ldr	r3, [pc, #44]	; (9808 <lwip_listen+0x40>)
    97da:	b2c9      	uxtb	r1, r1
    97dc:	4798      	blx	r3
	if (err != ERR_OK) {
    97de:	b120      	cbz	r0, 97ea <lwip_listen+0x22>
		if (netconn_type(sock->conn) != NETCONN_TCP) {
    97e0:	6823      	ldr	r3, [r4, #0]
    97e2:	781b      	ldrb	r3, [r3, #0]
    97e4:	2b10      	cmp	r3, #16
    97e6:	d002      	beq.n	97ee <lwip_listen+0x26>
			sock_set_errno(sock, EOPNOTSUPP);
    97e8:	205f      	movs	r0, #95	; 0x5f
	sock_set_errno(sock, 0);
    97ea:	6120      	str	r0, [r4, #16]
}
    97ec:	bd10      	pop	{r4, pc}
		sock_set_errno(sock, err_to_errno(err));
    97ee:	4243      	negs	r3, r0
    97f0:	2b0f      	cmp	r3, #15
    97f2:	bf96      	itet	ls
    97f4:	4a05      	ldrls	r2, [pc, #20]	; (980c <lwip_listen+0x44>)
    97f6:	2305      	movhi	r3, #5
    97f8:	f852 3023 	ldrls.w	r3, [r2, r3, lsl #2]
    97fc:	6123      	str	r3, [r4, #16]
		return -1;
    97fe:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    9802:	e7f3      	b.n	97ec <lwip_listen+0x24>
    9804:	00009415 	.word	0x00009415
    9808:	000076b9 	.word	0x000076b9
    980c:	0000b934 	.word	0x0000b934

00009810 <lwip_recvfrom>:
{
    9810:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    9814:	b08b      	sub	sp, #44	; 0x2c
    9816:	469b      	mov	fp, r3
	void *            buf = NULL;
    9818:	2500      	movs	r5, #0
	sock = get_socket(s);
    981a:	4b69      	ldr	r3, [pc, #420]	; (99c0 <lwip_recvfrom+0x1b0>)
{
    981c:	9101      	str	r1, [sp, #4]
    981e:	4690      	mov	r8, r2
	void *            buf = NULL;
    9820:	9504      	str	r5, [sp, #16]
	sock = get_socket(s);
    9822:	4798      	blx	r3
{
    9824:	f8dd 9054 	ldr.w	r9, [sp, #84]	; 0x54
	if (!sock) {
    9828:	4604      	mov	r4, r0
    982a:	2800      	cmp	r0, #0
    982c:	d05b      	beq.n	98e6 <lwip_recvfrom+0xd6>
		if (sock->lastdata) {
    982e:	6863      	ldr	r3, [r4, #4]
    9830:	2b00      	cmp	r3, #0
    9832:	d045      	beq.n	98c0 <lwip_recvfrom+0xb0>
			buf = sock->lastdata;
    9834:	9304      	str	r3, [sp, #16]
		if (netconn_type(sock->conn) == NETCONN_TCP) {
    9836:	6823      	ldr	r3, [r4, #0]
			p = (struct pbuf *)buf;
    9838:	f8dd a010 	ldr.w	sl, [sp, #16]
		if (netconn_type(sock->conn) == NETCONN_TCP) {
    983c:	781b      	ldrb	r3, [r3, #0]
		pbuf_copy_partial(p, (u8_t *)mem + off, copylen, sock->lastoffset);
    983e:	9901      	ldr	r1, [sp, #4]
		if (netconn_type(sock->conn) == NETCONN_TCP) {
    9840:	2b10      	cmp	r3, #16
			p = ((struct netbuf *)buf)->p;
    9842:	bf18      	it	ne
    9844:	f8da a000 	ldrne.w	sl, [sl]
		buflen -= sock->lastoffset;
    9848:	8923      	ldrh	r3, [r4, #8]
		buflen = p->tot_len;
    984a:	f8ba 6008 	ldrh.w	r6, [sl, #8]
		buflen -= sock->lastoffset;
    984e:	1af6      	subs	r6, r6, r3
    9850:	b2b2      	uxth	r2, r6
		if (len > buflen) {
    9852:	4542      	cmp	r2, r8
		buflen -= sock->lastoffset;
    9854:	9200      	str	r2, [sp, #0]
			copylen = buflen;
    9856:	bf38      	it	cc
    9858:	9f00      	ldrcc	r7, [sp, #0]
		pbuf_copy_partial(p, (u8_t *)mem + off, copylen, sock->lastoffset);
    985a:	4e5a      	ldr	r6, [pc, #360]	; (99c4 <lwip_recvfrom+0x1b4>)
			copylen = (u16_t)len;
    985c:	bf28      	it	cs
    985e:	fa1f f788 	uxthcs.w	r7, r8
		pbuf_copy_partial(p, (u8_t *)mem + off, copylen, sock->lastoffset);
    9862:	463a      	mov	r2, r7
    9864:	4429      	add	r1, r5
    9866:	4650      	mov	r0, sl
    9868:	47b0      	blx	r6
		if (netconn_type(sock->conn) == NETCONN_TCP) {
    986a:	6820      	ldr	r0, [r4, #0]
    986c:	7803      	ldrb	r3, [r0, #0]
			if ((len <= 0) || (p->flags & PBUF_FLAG_PUSH) || (sock->rcvevent <= 0) || ((flags & MSG_PEEK) != 0)) {
    986e:	f00b 0201 	and.w	r2, fp, #1
		if (netconn_type(sock->conn) == NETCONN_TCP) {
    9872:	2b10      	cmp	r3, #16
		off += copylen;
    9874:	443d      	add	r5, r7
			if ((len <= 0) || (p->flags & PBUF_FLAG_PUSH) || (sock->rcvevent <= 0) || ((flags & MSG_PEEK) != 0)) {
    9876:	4616      	mov	r6, r2
		if (netconn_type(sock->conn) == NETCONN_TCP) {
    9878:	d156      	bne.n	9928 <lwip_recvfrom+0x118>
			if ((len <= 0) || (p->flags & PBUF_FLAG_PUSH) || (sock->rcvevent <= 0) || ((flags & MSG_PEEK) != 0)) {
    987a:	ebb8 0807 	subs.w	r8, r8, r7
    987e:	d053      	beq.n	9928 <lwip_recvfrom+0x118>
    9880:	f89a a00d 	ldrb.w	sl, [sl, #13]
    9884:	f01a 0a01 	ands.w	sl, sl, #1
    9888:	d14e      	bne.n	9928 <lwip_recvfrom+0x118>
    988a:	f9b4 200a 	ldrsh.w	r2, [r4, #10]
    988e:	2a00      	cmp	r2, #0
    9890:	dd4a      	ble.n	9928 <lwip_recvfrom+0x118>
    9892:	2e00      	cmp	r6, #0
    9894:	f040 808c 	bne.w	99b0 <lwip_recvfrom+0x1a0>
			if ((netconn_type(sock->conn) == NETCONN_TCP) && (buflen - copylen > 0)) {
    9898:	6823      	ldr	r3, [r4, #0]
				sock->lastdata = buf;
    989a:	9804      	ldr	r0, [sp, #16]
			if ((netconn_type(sock->conn) == NETCONN_TCP) && (buflen - copylen > 0)) {
    989c:	781b      	ldrb	r3, [r3, #0]
    989e:	2b10      	cmp	r3, #16
    98a0:	d17b      	bne.n	999a <lwip_recvfrom+0x18a>
    98a2:	9a00      	ldr	r2, [sp, #0]
    98a4:	1bd6      	subs	r6, r2, r7
    98a6:	2e00      	cmp	r6, #0
    98a8:	dd77      	ble.n	999a <lwip_recvfrom+0x18a>
				sock->lastoffset += copylen;
    98aa:	8923      	ldrh	r3, [r4, #8]
				sock->lastdata = buf;
    98ac:	6060      	str	r0, [r4, #4]
				sock->lastoffset += copylen;
    98ae:	441f      	add	r7, r3
    98b0:	8127      	strh	r7, [r4, #8]
	} while (!done);
    98b2:	f1ba 0f00 	cmp.w	sl, #0
    98b6:	d0ba      	beq.n	982e <lwip_recvfrom+0x1e>
	if (off > 0) {
    98b8:	b975      	cbnz	r5, 98d8 <lwip_recvfrom+0xc8>
	sock_set_errno(sock, 0);
    98ba:	2300      	movs	r3, #0
    98bc:	6123      	str	r3, [r4, #16]
	return off;
    98be:	e02c      	b.n	991a <lwip_recvfrom+0x10a>
			if (((flags & MSG_DONTWAIT) || netconn_is_nonblocking(sock->conn)) && (sock->rcvevent <= 0)) {
    98c0:	f01b 0f08 	tst.w	fp, #8
    98c4:	d103      	bne.n	98ce <lwip_recvfrom+0xbe>
    98c6:	6823      	ldr	r3, [r4, #0]
    98c8:	7f1b      	ldrb	r3, [r3, #28]
    98ca:	079b      	lsls	r3, r3, #30
    98cc:	d50e      	bpl.n	98ec <lwip_recvfrom+0xdc>
    98ce:	f9b4 300a 	ldrsh.w	r3, [r4, #10]
    98d2:	2b00      	cmp	r3, #0
    98d4:	dc0a      	bgt.n	98ec <lwip_recvfrom+0xdc>
				if (off > 0) {
    98d6:	b125      	cbz	r5, 98e2 <lwip_recvfrom+0xd2>
		netconn_recved(sock->conn, (u32_t)off);
    98d8:	6820      	ldr	r0, [r4, #0]
    98da:	4b3b      	ldr	r3, [pc, #236]	; (99c8 <lwip_recvfrom+0x1b8>)
    98dc:	4629      	mov	r1, r5
    98de:	4798      	blx	r3
    98e0:	e7eb      	b.n	98ba <lwip_recvfrom+0xaa>
				sock_set_errno(sock, EWOULDBLOCK);
    98e2:	230b      	movs	r3, #11
    98e4:	6123      	str	r3, [r4, #16]
		return -1;
    98e6:	f04f 35ff 	mov.w	r5, #4294967295	; 0xffffffff
    98ea:	e016      	b.n	991a <lwip_recvfrom+0x10a>
			if (netconn_type(sock->conn) == NETCONN_TCP) {
    98ec:	6820      	ldr	r0, [r4, #0]
    98ee:	7803      	ldrb	r3, [r0, #0]
    98f0:	2b10      	cmp	r3, #16
				err = netconn_recv_tcp_pbuf(sock->conn, (struct pbuf **)&buf);
    98f2:	bf0c      	ite	eq
    98f4:	4b35      	ldreq	r3, [pc, #212]	; (99cc <lwip_recvfrom+0x1bc>)
				err = netconn_recv(sock->conn, (struct netbuf **)&buf);
    98f6:	4b36      	ldrne	r3, [pc, #216]	; (99d0 <lwip_recvfrom+0x1c0>)
				err = netconn_recv_tcp_pbuf(sock->conn, (struct pbuf **)&buf);
    98f8:	a904      	add	r1, sp, #16
				err = netconn_recv(sock->conn, (struct netbuf **)&buf);
    98fa:	4798      	blx	r3
			if (err != ERR_OK) {
    98fc:	b188      	cbz	r0, 9922 <lwip_recvfrom+0x112>
				if (off > 0) {
    98fe:	2d00      	cmp	r5, #0
    9900:	d1ea      	bne.n	98d8 <lwip_recvfrom+0xc8>
				sock_set_errno(sock, err_to_errno(err));
    9902:	4243      	negs	r3, r0
    9904:	2b0f      	cmp	r3, #15
    9906:	bf96      	itet	ls
    9908:	4a32      	ldrls	r2, [pc, #200]	; (99d4 <lwip_recvfrom+0x1c4>)
    990a:	2305      	movhi	r3, #5
    990c:	f852 3023 	ldrls.w	r3, [r2, r3, lsl #2]
    9910:	6123      	str	r3, [r4, #16]
				if (err == ERR_CLSD) {
    9912:	300c      	adds	r0, #12
    9914:	bf18      	it	ne
    9916:	2001      	movne	r0, #1
    9918:	4245      	negs	r5, r0
}
    991a:	4628      	mov	r0, r5
    991c:	b00b      	add	sp, #44	; 0x2c
    991e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
			sock->lastdata = buf;
    9922:	9b04      	ldr	r3, [sp, #16]
    9924:	6063      	str	r3, [r4, #4]
    9926:	e786      	b.n	9836 <lwip_recvfrom+0x26>
			if (from && fromlen) {
    9928:	9a14      	ldr	r2, [sp, #80]	; 0x50
    992a:	b352      	cbz	r2, 9982 <lwip_recvfrom+0x172>
    992c:	f1b9 0f00 	cmp.w	r9, #0
    9930:	d027      	beq.n	9982 <lwip_recvfrom+0x172>
				if (netconn_type(sock->conn) == NETCONN_TCP) {
    9932:	2b10      	cmp	r3, #16
    9934:	d12a      	bne.n	998c <lwip_recvfrom+0x17c>
					netconn_getaddr(sock->conn, addr, &port, 0);
    9936:	f8df a0b0 	ldr.w	sl, [pc, #176]	; 99e8 <lwip_recvfrom+0x1d8>
    993a:	2300      	movs	r3, #0
    993c:	f10d 020e 	add.w	r2, sp, #14
    9940:	a905      	add	r1, sp, #20
    9942:	47d0      	blx	sl
					addr = &fromaddr;
    9944:	f10d 0a14 	add.w	sl, sp, #20
				memset(&sin, 0, sizeof(sin));
    9948:	2300      	movs	r3, #0
    994a:	e9cd 3308 	strd	r3, r3, [sp, #32]
				sin.sin_len    = sizeof(sin);
    994e:	f44f 7304 	mov.w	r3, #528	; 0x210
    9952:	f8ad 3018 	strh.w	r3, [sp, #24]
				sin.sin_port   = htons(port);
    9956:	f8bd 000e 	ldrh.w	r0, [sp, #14]
    995a:	4b1f      	ldr	r3, [pc, #124]	; (99d8 <lwip_recvfrom+0x1c8>)
    995c:	4798      	blx	r3
				inet_addr_from_ipaddr(&sin.sin_addr, addr);
    995e:	f8da 3000 	ldr.w	r3, [sl]
    9962:	9307      	str	r3, [sp, #28]
				if (*fromlen > sizeof(sin)) {
    9964:	f8d9 3000 	ldr.w	r3, [r9]
				sin.sin_port   = htons(port);
    9968:	f8ad 001a 	strh.w	r0, [sp, #26]
				if (*fromlen > sizeof(sin)) {
    996c:	2b10      	cmp	r3, #16
					*fromlen = sizeof(sin);
    996e:	bf84      	itt	hi
    9970:	2310      	movhi	r3, #16
    9972:	f8c9 3000 	strhi.w	r3, [r9]
				MEMCPY(from, &sin, *fromlen);
    9976:	f8d9 2000 	ldr.w	r2, [r9]
    997a:	9814      	ldr	r0, [sp, #80]	; 0x50
    997c:	4b17      	ldr	r3, [pc, #92]	; (99dc <lwip_recvfrom+0x1cc>)
    997e:	a906      	add	r1, sp, #24
    9980:	4798      	blx	r3
		if ((flags & MSG_PEEK) == 0) {
    9982:	2e00      	cmp	r6, #0
    9984:	d198      	bne.n	98b8 <lwip_recvfrom+0xa8>
    9986:	f04f 0a01 	mov.w	sl, #1
    998a:	e785      	b.n	9898 <lwip_recvfrom+0x88>
					addr = netbuf_fromaddr((struct netbuf *)buf);
    998c:	9b04      	ldr	r3, [sp, #16]
    998e:	f103 0a08 	add.w	sl, r3, #8
					port = netbuf_fromport((struct netbuf *)buf);
    9992:	899b      	ldrh	r3, [r3, #12]
    9994:	f8ad 300e 	strh.w	r3, [sp, #14]
    9998:	e7d6      	b.n	9948 <lwip_recvfrom+0x138>
				sock->lastdata   = NULL;
    999a:	2200      	movs	r2, #0
				if (netconn_type(sock->conn) == NETCONN_TCP) {
    999c:	2b10      	cmp	r3, #16
				sock->lastdata   = NULL;
    999e:	6062      	str	r2, [r4, #4]
				sock->lastoffset = 0;
    99a0:	8122      	strh	r2, [r4, #8]
				if (netconn_type(sock->conn) == NETCONN_TCP) {
    99a2:	d102      	bne.n	99aa <lwip_recvfrom+0x19a>
					pbuf_free((struct pbuf *)buf);
    99a4:	4b0e      	ldr	r3, [pc, #56]	; (99e0 <lwip_recvfrom+0x1d0>)
    99a6:	4798      	blx	r3
    99a8:	e783      	b.n	98b2 <lwip_recvfrom+0xa2>
					netbuf_delete((struct netbuf *)buf);
    99aa:	4b0e      	ldr	r3, [pc, #56]	; (99e4 <lwip_recvfrom+0x1d4>)
    99ac:	4798      	blx	r3
    99ae:	e780      	b.n	98b2 <lwip_recvfrom+0xa2>
			if (from && fromlen) {
    99b0:	9b14      	ldr	r3, [sp, #80]	; 0x50
    99b2:	2b00      	cmp	r3, #0
    99b4:	d080      	beq.n	98b8 <lwip_recvfrom+0xa8>
    99b6:	f1b9 0f00 	cmp.w	r9, #0
    99ba:	d1bc      	bne.n	9936 <lwip_recvfrom+0x126>
    99bc:	e7e1      	b.n	9982 <lwip_recvfrom+0x172>
    99be:	bf00      	nop
    99c0:	00009415 	.word	0x00009415
    99c4:	00003385 	.word	0x00003385
    99c8:	000077e9 	.word	0x000077e9
    99cc:	0000774d 	.word	0x0000774d
    99d0:	00007761 	.word	0x00007761
    99d4:	0000b934 	.word	0x0000b934
    99d8:	00000d65 	.word	0x00000d65
    99dc:	0000a349 	.word	0x0000a349
    99e0:	000030e5 	.word	0x000030e5
    99e4:	00000d7d 	.word	0x00000d7d
    99e8:	00007649 	.word	0x00007649

000099ec <lwip_read>:
{
    99ec:	b513      	push	{r0, r1, r4, lr}
	return lwip_recvfrom(s, mem, len, 0, NULL, NULL);
    99ee:	2300      	movs	r3, #0
    99f0:	e9cd 3300 	strd	r3, r3, [sp]
    99f4:	4c01      	ldr	r4, [pc, #4]	; (99fc <lwip_read+0x10>)
    99f6:	47a0      	blx	r4
}
    99f8:	b002      	add	sp, #8
    99fa:	bd10      	pop	{r4, pc}
    99fc:	00009811 	.word	0x00009811

00009a00 <lwip_sendto>:
{
    9a00:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
    9a04:	b087      	sub	sp, #28
    9a06:	4614      	mov	r4, r2
	sock = get_socket(s);
    9a08:	4a28      	ldr	r2, [pc, #160]	; (9aac <lwip_sendto+0xac>)
{
    9a0a:	9301      	str	r3, [sp, #4]
    9a0c:	4680      	mov	r8, r0
	sock = get_socket(s);
    9a0e:	4790      	blx	r2
{
    9a10:	e9dd 590e 	ldrd	r5, r9, [sp, #56]	; 0x38
	if (!sock) {
    9a14:	9b01      	ldr	r3, [sp, #4]
{
    9a16:	460f      	mov	r7, r1
	if (!sock) {
    9a18:	4606      	mov	r6, r0
    9a1a:	b920      	cbnz	r0, 9a26 <lwip_sendto+0x26>
		return -1;
    9a1c:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
}
    9a20:	b007      	add	sp, #28
    9a22:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
	if (sock->conn->type == NETCONN_TCP) {
    9a26:	6802      	ldr	r2, [r0, #0]
    9a28:	7812      	ldrb	r2, [r2, #0]
    9a2a:	2a10      	cmp	r2, #16
    9a2c:	d107      	bne.n	9a3e <lwip_sendto+0x3e>
		return lwip_send(s, data, size, flags);
    9a2e:	4622      	mov	r2, r4
    9a30:	4c1f      	ldr	r4, [pc, #124]	; (9ab0 <lwip_sendto+0xb0>)
    9a32:	4640      	mov	r0, r8
    9a34:	46a4      	mov	ip, r4
}
    9a36:	b007      	add	sp, #28
    9a38:	e8bd 43f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, lr}
		return lwip_send(s, data, size, flags);
    9a3c:	4760      	bx	ip
	LWIP_ERROR(
    9a3e:	b915      	cbnz	r5, 9a46 <lwip_sendto+0x46>
    9a40:	f1b9 0f00 	cmp.w	r9, #0
    9a44:	d008      	beq.n	9a58 <lwip_sendto+0x58>
    9a46:	f1b9 0f10 	cmp.w	r9, #16
    9a4a:	d104      	bne.n	9a56 <lwip_sendto+0x56>
    9a4c:	786b      	ldrb	r3, [r5, #1]
    9a4e:	2b02      	cmp	r3, #2
    9a50:	d101      	bne.n	9a56 <lwip_sendto+0x56>
    9a52:	07ab      	lsls	r3, r5, #30
    9a54:	d000      	beq.n	9a58 <lwip_sendto+0x58>
    9a56:	e7fe      	b.n	9a56 <lwip_sendto+0x56>
	buf.p = buf.ptr = NULL;
    9a58:	2300      	movs	r3, #0
    9a5a:	e9cd 3302 	strd	r3, r3, [sp, #8]
	if (to) {
    9a5e:	b30d      	cbz	r5, 9aa4 <lwip_sendto+0xa4>
		inet_addr_to_ipaddr(&buf.addr, &to_in->sin_addr);
    9a60:	686b      	ldr	r3, [r5, #4]
    9a62:	9304      	str	r3, [sp, #16]
		remote_port = ntohs(to_in->sin_port);
    9a64:	8868      	ldrh	r0, [r5, #2]
    9a66:	4b13      	ldr	r3, [pc, #76]	; (9ab4 <lwip_sendto+0xb4>)
    9a68:	4798      	blx	r3
		netbuf_fromport(&buf) = remote_port;
    9a6a:	f8ad 0014 	strh.w	r0, [sp, #20]
	err = netbuf_ref(&buf, data, short_size);
    9a6e:	4b12      	ldr	r3, [pc, #72]	; (9ab8 <lwip_sendto+0xb8>)
    9a70:	b2a2      	uxth	r2, r4
    9a72:	4639      	mov	r1, r7
    9a74:	a802      	add	r0, sp, #8
    9a76:	4798      	blx	r3
	if (err == ERR_OK) {
    9a78:	4605      	mov	r5, r0
    9a7a:	b920      	cbnz	r0, 9a86 <lwip_sendto+0x86>
		err = netconn_send(sock->conn, &buf);
    9a7c:	6830      	ldr	r0, [r6, #0]
    9a7e:	4b0f      	ldr	r3, [pc, #60]	; (9abc <lwip_sendto+0xbc>)
    9a80:	a902      	add	r1, sp, #8
    9a82:	4798      	blx	r3
    9a84:	4605      	mov	r5, r0
	netbuf_free(&buf);
    9a86:	4b0e      	ldr	r3, [pc, #56]	; (9ac0 <lwip_sendto+0xc0>)
    9a88:	a802      	add	r0, sp, #8
    9a8a:	4798      	blx	r3
	sock_set_errno(sock, err_to_errno(err));
    9a8c:	426b      	negs	r3, r5
    9a8e:	2b0f      	cmp	r3, #15
    9a90:	bf96      	itet	ls
    9a92:	4a0c      	ldrls	r2, [pc, #48]	; (9ac4 <lwip_sendto+0xc4>)
    9a94:	2305      	movhi	r3, #5
    9a96:	f852 3023 	ldrls.w	r3, [r2, r3, lsl #2]
    9a9a:	6133      	str	r3, [r6, #16]
	return (err == ERR_OK ? short_size : -1);
    9a9c:	2d00      	cmp	r5, #0
    9a9e:	d1bd      	bne.n	9a1c <lwip_sendto+0x1c>
    9aa0:	b2a0      	uxth	r0, r4
    9aa2:	e7bd      	b.n	9a20 <lwip_sendto+0x20>
		ip_addr_set_any(&buf.addr);
    9aa4:	9504      	str	r5, [sp, #16]
		netbuf_fromport(&buf) = 0;
    9aa6:	f8ad 5014 	strh.w	r5, [sp, #20]
    9aaa:	e7e0      	b.n	9a6e <lwip_sendto+0x6e>
    9aac:	00009415 	.word	0x00009415
    9ab0:	00009ac9 	.word	0x00009ac9
    9ab4:	00000d6b 	.word	0x00000d6b
    9ab8:	00000dc5 	.word	0x00000dc5
    9abc:	00007815 	.word	0x00007815
    9ac0:	00000da9 	.word	0x00000da9
    9ac4:	0000b934 	.word	0x0000b934

00009ac8 <lwip_send>:
{
    9ac8:	b570      	push	{r4, r5, r6, lr}
    9aca:	b086      	sub	sp, #24
    9acc:	461c      	mov	r4, r3
	sock = get_socket(s);
    9ace:	4b19      	ldr	r3, [pc, #100]	; (9b34 <lwip_send+0x6c>)
{
    9ad0:	9203      	str	r2, [sp, #12]
    9ad2:	4606      	mov	r6, r0
	sock = get_socket(s);
    9ad4:	4798      	blx	r3
	if (!sock) {
    9ad6:	9a03      	ldr	r2, [sp, #12]
    9ad8:	4605      	mov	r5, r0
    9ada:	b918      	cbnz	r0, 9ae4 <lwip_send+0x1c>
		return -1;
    9adc:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
}
    9ae0:	b006      	add	sp, #24
    9ae2:	bd70      	pop	{r4, r5, r6, pc}
	if (sock->conn->type != NETCONN_TCP) {
    9ae4:	6800      	ldr	r0, [r0, #0]
    9ae6:	7803      	ldrb	r3, [r0, #0]
    9ae8:	2b10      	cmp	r3, #16
    9aea:	f04f 0300 	mov.w	r3, #0
    9aee:	d006      	beq.n	9afe <lwip_send+0x36>
		return lwip_sendto(s, data, size, flags, NULL, 0);
    9af0:	e9cd 3300 	strd	r3, r3, [sp]
    9af4:	4630      	mov	r0, r6
    9af6:	4623      	mov	r3, r4
    9af8:	4c0f      	ldr	r4, [pc, #60]	; (9b38 <lwip_send+0x70>)
    9afa:	47a0      	blx	r4
    9afc:	e7f0      	b.n	9ae0 <lwip_send+0x18>
	written = 0;
    9afe:	9305      	str	r3, [sp, #20]
	    = NETCONN_COPY | ((flags & MSG_MORE) ? NETCONN_MORE : 0) | ((flags & MSG_DONTWAIT) ? NETCONN_DONTBLOCK : 0);
    9b00:	10e6      	asrs	r6, r4, #3
    9b02:	1063      	asrs	r3, r4, #1
    9b04:	f006 0602 	and.w	r6, r6, #2
    9b08:	f003 0304 	and.w	r3, r3, #4
	err     = netconn_write_partly(sock->conn, data, size, write_flags, &written);
    9b0c:	ac05      	add	r4, sp, #20
	    = NETCONN_COPY | ((flags & MSG_MORE) ? NETCONN_MORE : 0) | ((flags & MSG_DONTWAIT) ? NETCONN_DONTBLOCK : 0);
    9b0e:	4333      	orrs	r3, r6
	err     = netconn_write_partly(sock->conn, data, size, write_flags, &written);
    9b10:	9400      	str	r4, [sp, #0]
    9b12:	f043 0301 	orr.w	r3, r3, #1
    9b16:	4c09      	ldr	r4, [pc, #36]	; (9b3c <lwip_send+0x74>)
    9b18:	47a0      	blx	r4
	sock_set_errno(sock, err_to_errno(err));
    9b1a:	4243      	negs	r3, r0
    9b1c:	2b0f      	cmp	r3, #15
    9b1e:	bf96      	itet	ls
    9b20:	4a07      	ldrls	r2, [pc, #28]	; (9b40 <lwip_send+0x78>)
    9b22:	2305      	movhi	r3, #5
    9b24:	f852 3023 	ldrls.w	r3, [r2, r3, lsl #2]
    9b28:	612b      	str	r3, [r5, #16]
	return (err == ERR_OK ? (int)written : -1);
    9b2a:	2800      	cmp	r0, #0
    9b2c:	d1d6      	bne.n	9adc <lwip_send+0x14>
    9b2e:	9805      	ldr	r0, [sp, #20]
    9b30:	e7d6      	b.n	9ae0 <lwip_send+0x18>
    9b32:	bf00      	nop
    9b34:	00009415 	.word	0x00009415
    9b38:	00009a01 	.word	0x00009a01
    9b3c:	00007845 	.word	0x00007845
    9b40:	0000b934 	.word	0x0000b934

00009b44 <lwip_socket>:
	switch (type) {
    9b44:	2902      	cmp	r1, #2
{
    9b46:	b538      	push	{r3, r4, r5, lr}
    9b48:	4613      	mov	r3, r2
	switch (type) {
    9b4a:	d01a      	beq.n	9b82 <lwip_socket+0x3e>
    9b4c:	2903      	cmp	r1, #3
    9b4e:	d005      	beq.n	9b5c <lwip_socket+0x18>
    9b50:	2901      	cmp	r1, #1
    9b52:	d01e      	beq.n	9b92 <lwip_socket+0x4e>
		return -1;
    9b54:	f04f 35ff 	mov.w	r5, #4294967295	; 0xffffffff
}
    9b58:	4628      	mov	r0, r5
    9b5a:	bd38      	pop	{r3, r4, r5, pc}
		conn = netconn_new_with_proto_and_callback(NETCONN_RAW, (u8_t)protocol, event_callback);
    9b5c:	4a14      	ldr	r2, [pc, #80]	; (9bb0 <lwip_socket+0x6c>)
    9b5e:	b2d9      	uxtb	r1, r3
    9b60:	2040      	movs	r0, #64	; 0x40
		conn = netconn_new_with_callback((protocol == IPPROTO_UDPLITE) ? NETCONN_UDPLITE : NETCONN_UDP, event_callback);
    9b62:	4b14      	ldr	r3, [pc, #80]	; (9bb4 <lwip_socket+0x70>)
    9b64:	4798      	blx	r3
    9b66:	4604      	mov	r4, r0
	if (!conn) {
    9b68:	2800      	cmp	r0, #0
    9b6a:	d0f3      	beq.n	9b54 <lwip_socket+0x10>
	i = alloc_socket(conn, 0);
    9b6c:	4b12      	ldr	r3, [pc, #72]	; (9bb8 <lwip_socket+0x74>)
    9b6e:	2100      	movs	r1, #0
    9b70:	4620      	mov	r0, r4
    9b72:	4798      	blx	r3
	if (i == -1) {
    9b74:	1c43      	adds	r3, r0, #1
	i = alloc_socket(conn, 0);
    9b76:	4605      	mov	r5, r0
	if (i == -1) {
    9b78:	d118      	bne.n	9bac <lwip_socket+0x68>
		netconn_delete(conn);
    9b7a:	4b10      	ldr	r3, [pc, #64]	; (9bbc <lwip_socket+0x78>)
    9b7c:	4620      	mov	r0, r4
    9b7e:	4798      	blx	r3
		return -1;
    9b80:	e7ea      	b.n	9b58 <lwip_socket+0x14>
		conn = netconn_new_with_callback((protocol == IPPROTO_UDPLITE) ? NETCONN_UDPLITE : NETCONN_UDP, event_callback);
    9b82:	2a88      	cmp	r2, #136	; 0x88
    9b84:	f04f 0100 	mov.w	r1, #0
    9b88:	4a09      	ldr	r2, [pc, #36]	; (9bb0 <lwip_socket+0x6c>)
    9b8a:	bf0c      	ite	eq
    9b8c:	2021      	moveq	r0, #33	; 0x21
    9b8e:	2020      	movne	r0, #32
    9b90:	e7e7      	b.n	9b62 <lwip_socket+0x1e>
		conn = netconn_new_with_callback(NETCONN_TCP, event_callback);
    9b92:	4a07      	ldr	r2, [pc, #28]	; (9bb0 <lwip_socket+0x6c>)
    9b94:	4b07      	ldr	r3, [pc, #28]	; (9bb4 <lwip_socket+0x70>)
    9b96:	2100      	movs	r1, #0
    9b98:	2010      	movs	r0, #16
    9b9a:	4798      	blx	r3
		if (conn != NULL) {
    9b9c:	4604      	mov	r4, r0
    9b9e:	2800      	cmp	r0, #0
    9ba0:	d0d8      	beq.n	9b54 <lwip_socket+0x10>
			netconn_set_noautorecved(conn, 1);
    9ba2:	7f03      	ldrb	r3, [r0, #28]
    9ba4:	f043 0308 	orr.w	r3, r3, #8
    9ba8:	7703      	strb	r3, [r0, #28]
	if (!conn) {
    9baa:	e7df      	b.n	9b6c <lwip_socket+0x28>
	conn->socket = i;
    9bac:	61a0      	str	r0, [r4, #24]
	return i;
    9bae:	e7d3      	b.n	9b58 <lwip_socket+0x14>
    9bb0:	00009471 	.word	0x00009471
    9bb4:	000075c1 	.word	0x000075c1
    9bb8:	00009435 	.word	0x00009435
    9bbc:	0000761d 	.word	0x0000761d

00009bc0 <lwip_write>:
{
    9bc0:	b410      	push	{r4}
	return lwip_send(s, data, size, 0);
    9bc2:	4c03      	ldr	r4, [pc, #12]	; (9bd0 <lwip_write+0x10>)
    9bc4:	2300      	movs	r3, #0
    9bc6:	46a4      	mov	ip, r4
}
    9bc8:	f85d 4b04 	ldr.w	r4, [sp], #4
	return lwip_send(s, data, size, 0);
    9bcc:	4760      	bx	ip
    9bce:	bf00      	nop
    9bd0:	00009ac9 	.word	0x00009ac9

00009bd4 <lwip_setsockopt>:
{
    9bd4:	b570      	push	{r4, r5, r6, lr}
    9bd6:	461e      	mov	r6, r3
    9bd8:	b086      	sub	sp, #24
	struct lwip_sock *             sock = get_socket(s);
    9bda:	4b30      	ldr	r3, [pc, #192]	; (9c9c <lwip_setsockopt+0xc8>)
{
    9bdc:	4615      	mov	r5, r2
	struct lwip_sock *             sock = get_socket(s);
    9bde:	4798      	blx	r3
	if (!sock) {
    9be0:	4604      	mov	r4, r0
    9be2:	b110      	cbz	r0, 9bea <lwip_setsockopt+0x16>
	if (NULL == optval) {
    9be4:	b92e      	cbnz	r6, 9bf2 <lwip_setsockopt+0x1e>
		sock_set_errno(sock, EFAULT);
    9be6:	230e      	movs	r3, #14
    9be8:	6103      	str	r3, [r0, #16]
		return -1;
    9bea:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
}
    9bee:	b006      	add	sp, #24
    9bf0:	bd70      	pop	{r4, r5, r6, pc}
	switch (level) {
    9bf2:	2906      	cmp	r1, #6
    9bf4:	d026      	beq.n	9c44 <lwip_setsockopt+0x70>
    9bf6:	f640 73ff 	movw	r3, #4095	; 0xfff
    9bfa:	4299      	cmp	r1, r3
    9bfc:	d002      	beq.n	9c04 <lwip_setsockopt+0x30>
    9bfe:	b1e9      	cbz	r1, 9c3c <lwip_setsockopt+0x68>
    9c00:	205c      	movs	r0, #92	; 0x5c
    9c02:	e046      	b.n	9c92 <lwip_setsockopt+0xbe>
		switch (optname) {
    9c04:	2d20      	cmp	r5, #32
    9c06:	d005      	beq.n	9c14 <lwip_setsockopt+0x40>
    9c08:	f241 030a 	movw	r3, #4106	; 0x100a
    9c0c:	429d      	cmp	r5, r3
    9c0e:	d006      	beq.n	9c1e <lwip_setsockopt+0x4a>
    9c10:	2d08      	cmp	r5, #8
    9c12:	d1f5      	bne.n	9c00 <lwip_setsockopt+0x2c>
			if (optlen < sizeof(int)) {
    9c14:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    9c16:	2b03      	cmp	r3, #3
    9c18:	d81e      	bhi.n	9c58 <lwip_setsockopt+0x84>
				err = EINVAL;
    9c1a:	2016      	movs	r0, #22
    9c1c:	e039      	b.n	9c92 <lwip_setsockopt+0xbe>
			if (optlen < sizeof(int)) {
    9c1e:	9b0a      	ldr	r3, [sp, #40]	; 0x28
				err = EINVAL;
    9c20:	2b03      	cmp	r3, #3
			if ((sock->conn->type != NETCONN_UDP) || ((udp_flags(sock->conn->pcb.udp) & UDP_FLAGS_UDPLITE) != 0)) {
    9c22:	6823      	ldr	r3, [r4, #0]
    9c24:	781a      	ldrb	r2, [r3, #0]
				err = EINVAL;
    9c26:	bf8c      	ite	hi
    9c28:	2000      	movhi	r0, #0
    9c2a:	2016      	movls	r0, #22
			if ((sock->conn->type != NETCONN_UDP) || ((udp_flags(sock->conn->pcb.udp) & UDP_FLAGS_UDPLITE) != 0)) {
    9c2c:	2a20      	cmp	r2, #32
    9c2e:	d103      	bne.n	9c38 <lwip_setsockopt+0x64>
    9c30:	685b      	ldr	r3, [r3, #4]
    9c32:	7c1b      	ldrb	r3, [r3, #16]
    9c34:	079b      	lsls	r3, r3, #30
    9c36:	d52a      	bpl.n	9c8e <lwip_setsockopt+0xba>
				err = EAFNOSUPPORT;
    9c38:	2061      	movs	r0, #97	; 0x61
    9c3a:	e02a      	b.n	9c92 <lwip_setsockopt+0xbe>
		switch (optname) {
    9c3c:	1e6b      	subs	r3, r5, #1
    9c3e:	2b01      	cmp	r3, #1
    9c40:	d9e8      	bls.n	9c14 <lwip_setsockopt+0x40>
    9c42:	e7dd      	b.n	9c00 <lwip_setsockopt+0x2c>
		if (optlen < sizeof(int)) {
    9c44:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    9c46:	2b03      	cmp	r3, #3
    9c48:	d9e7      	bls.n	9c1a <lwip_setsockopt+0x46>
		if (sock->conn->type != NETCONN_TCP)
    9c4a:	6803      	ldr	r3, [r0, #0]
    9c4c:	781b      	ldrb	r3, [r3, #0]
    9c4e:	2b10      	cmp	r3, #16
    9c50:	d121      	bne.n	9c96 <lwip_setsockopt+0xc2>
		switch (optname) {
    9c52:	1e6b      	subs	r3, r5, #1
    9c54:	2b01      	cmp	r3, #1
    9c56:	d8d3      	bhi.n	9c00 <lwip_setsockopt+0x2c>
	data.optlen  = &optlen;
    9c58:	ab0a      	add	r3, sp, #40	; 0x28
	data.level   = level;
    9c5a:	e9cd 4100 	strd	r4, r1, [sp]
	data.optval  = (void *)optval;
    9c5e:	e9cd 5602 	strd	r5, r6, [sp, #8]
	data.optlen  = &optlen;
    9c62:	9304      	str	r3, [sp, #16]
	data.err     = err;
    9c64:	2500      	movs	r5, #0
	tcpip_callback(lwip_setsockopt_internal, &data);
    9c66:	4b0e      	ldr	r3, [pc, #56]	; (9ca0 <lwip_setsockopt+0xcc>)
    9c68:	480e      	ldr	r0, [pc, #56]	; (9ca4 <lwip_setsockopt+0xd0>)
	data.err     = err;
    9c6a:	f88d 5014 	strb.w	r5, [sp, #20]
	tcpip_callback(lwip_setsockopt_internal, &data);
    9c6e:	2201      	movs	r2, #1
    9c70:	4669      	mov	r1, sp
    9c72:	4798      	blx	r3
	sys_arch_sem_wait(&sock->conn->op_completed, 0);
    9c74:	6820      	ldr	r0, [r4, #0]
    9c76:	4b0c      	ldr	r3, [pc, #48]	; (9ca8 <lwip_setsockopt+0xd4>)
    9c78:	4629      	mov	r1, r5
    9c7a:	300c      	adds	r0, #12
    9c7c:	4798      	blx	r3
	err = data.err;
    9c7e:	f99d 0014 	ldrsb.w	r0, [sp, #20]
	sock_set_errno(sock, err);
    9c82:	6120      	str	r0, [r4, #16]
	return err ? -1 : 0;
    9c84:	1b40      	subs	r0, r0, r5
    9c86:	bf18      	it	ne
    9c88:	2001      	movne	r0, #1
    9c8a:	4240      	negs	r0, r0
    9c8c:	e7af      	b.n	9bee <lwip_setsockopt+0x1a>
	if (err != ERR_OK) {
    9c8e:	2800      	cmp	r0, #0
    9c90:	d0e2      	beq.n	9c58 <lwip_setsockopt+0x84>
		sock_set_errno(sock, err);
    9c92:	6120      	str	r0, [r4, #16]
    9c94:	e7a9      	b.n	9bea <lwip_setsockopt+0x16>
			return 0;
    9c96:	2000      	movs	r0, #0
    9c98:	e7a9      	b.n	9bee <lwip_setsockopt+0x1a>
    9c9a:	bf00      	nop
    9c9c:	00009415 	.word	0x00009415
    9ca0:	0000a1ed 	.word	0x0000a1ed
    9ca4:	00009555 	.word	0x00009555
    9ca8:	00007a39 	.word	0x00007a39

00009cac <prvTaskExitError>:
	its caller as there is nothing to return to.  If a task wants to exit it
	should instead call vTaskDelete( NULL ).

	Artificially force an assert() to be triggered if configASSERT() is
	defined, then stop here so application writers can catch the error. */
	configASSERT(uxCriticalNesting == ~0UL);
    9cac:	4b0a      	ldr	r3, [pc, #40]	; (9cd8 <prvTaskExitError+0x2c>)
    9cae:	681b      	ldr	r3, [r3, #0]
    9cb0:	3301      	adds	r3, #1
    9cb2:	d008      	beq.n	9cc6 <prvTaskExitError+0x1a>
    9cb4:	f04f 0380 	mov.w	r3, #128	; 0x80
    9cb8:	f383 8811 	msr	BASEPRI, r3
    9cbc:	f3bf 8f6f 	isb	sy
    9cc0:	f3bf 8f4f 	dsb	sy
    9cc4:	e7fe      	b.n	9cc4 <prvTaskExitError+0x18>
    9cc6:	f04f 0380 	mov.w	r3, #128	; 0x80
    9cca:	f383 8811 	msr	BASEPRI, r3
    9cce:	f3bf 8f6f 	isb	sy
    9cd2:	f3bf 8f4f 	dsb	sy
	portDISABLE_INTERRUPTS();
	for (;;)
    9cd6:	e7fe      	b.n	9cd6 <prvTaskExitError+0x2a>
    9cd8:	20000018 	.word	0x20000018

00009cdc <prvPortStartFirstTask>:
}
/*-----------------------------------------------------------*/

static void prvPortStartFirstTask(void)
{
	__asm volatile(" ldr r0, =0xE000ED08 	\n" /* Use the NVIC offset register to locate the stack. */
    9cdc:	4806      	ldr	r0, [pc, #24]	; (9cf8 <prvPortStartFirstTask+0x1c>)
    9cde:	6800      	ldr	r0, [r0, #0]
    9ce0:	6800      	ldr	r0, [r0, #0]
    9ce2:	f380 8808 	msr	MSP, r0
    9ce6:	b662      	cpsie	i
    9ce8:	b661      	cpsie	f
    9cea:	f3bf 8f4f 	dsb	sy
    9cee:	f3bf 8f6f 	isb	sy
    9cf2:	df00      	svc	0
    9cf4:	bf00      	nop
	               " cpsie f				\n"
	               " dsb					\n"
	               " isb					\n"
	               " svc 0					\n" /* System call to start first task. */
	               " nop					\n");
}
    9cf6:	0000      	.short	0x0000
    9cf8:	e000ed08 	.word	0xe000ed08

00009cfc <vPortEnableVFP>:
/*-----------------------------------------------------------*/

/* This is a naked function. */
static void vPortEnableVFP(void)
{
	__asm volatile("	ldr.w r0, =0xE000ED88		\n" /* The FPU enable bits are in the CPACR. */
    9cfc:	f8df 000c 	ldr.w	r0, [pc, #12]	; 9d0c <vPortEnableVFP+0x10>
    9d00:	6801      	ldr	r1, [r0, #0]
    9d02:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
    9d06:	6001      	str	r1, [r0, #0]
    9d08:	4770      	bx	lr
	               "	ldr r1, [r0]				\n"
	               "								\n"
	               "	orr r1, r1, #( 0xf << 20 )	\n" /* Enable CP10 and CP11 coprocessors, then save back. */
	               "	str r1, [r0]				\n"
	               "	bx r14						");
}
    9d0a:	0000      	.short	0x0000
    9d0c:	e000ed88 	.word	0xe000ed88

00009d10 <pxPortInitialiseStack>:
	*pxTopOfStack = portINITIAL_XPSR; /* xPSR */
    9d10:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
	*pxTopOfStack = (StackType_t)pxCode; /* PC */
    9d14:	e940 1302 	strd	r1, r3, [r0, #-8]
	*pxTopOfStack = (StackType_t)portTASK_RETURN_ADDRESS; /* LR */
    9d18:	4b05      	ldr	r3, [pc, #20]	; (9d30 <pxPortInitialiseStack+0x20>)
    9d1a:	f840 3c0c 	str.w	r3, [r0, #-12]
	*pxTopOfStack = portINITIAL_EXEC_RETURN;
    9d1e:	f06f 0302 	mvn.w	r3, #2
	*pxTopOfStack = (StackType_t)pvParameters; /* R0 */
    9d22:	f840 2c20 	str.w	r2, [r0, #-32]
	*pxTopOfStack = portINITIAL_EXEC_RETURN;
    9d26:	f840 3c24 	str.w	r3, [r0, #-36]
}
    9d2a:	3844      	subs	r0, #68	; 0x44
    9d2c:	4770      	bx	lr
    9d2e:	bf00      	nop
    9d30:	00009cad 	.word	0x00009cad

00009d34 <SVCall_Handler>:
	__asm volatile("	ldr	r3, pxCurrentTCBConst2		\n" /* Restore the context. */
    9d34:	4b06      	ldr	r3, [pc, #24]	; (9d50 <pxCurrentTCBConst2>)
    9d36:	6819      	ldr	r1, [r3, #0]
    9d38:	6808      	ldr	r0, [r1, #0]
    9d3a:	e8b0 4ff0 	ldmia.w	r0!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    9d3e:	f380 8809 	msr	PSP, r0
    9d42:	f3bf 8f6f 	isb	sy
    9d46:	f04f 0000 	mov.w	r0, #0
    9d4a:	f380 8811 	msr	BASEPRI, r0
    9d4e:	4770      	bx	lr

00009d50 <pxCurrentTCBConst2>:
    9d50:	200162a4 	.word	0x200162a4

00009d54 <vPortEnterCritical>:
    9d54:	f04f 0380 	mov.w	r3, #128	; 0x80
    9d58:	f383 8811 	msr	BASEPRI, r3
    9d5c:	f3bf 8f6f 	isb	sy
    9d60:	f3bf 8f4f 	dsb	sy
	uxCriticalNesting++;
    9d64:	4a0a      	ldr	r2, [pc, #40]	; (9d90 <vPortEnterCritical+0x3c>)
    9d66:	6813      	ldr	r3, [r2, #0]
    9d68:	3301      	adds	r3, #1
	if (uxCriticalNesting == 1) {
    9d6a:	2b01      	cmp	r3, #1
	uxCriticalNesting++;
    9d6c:	6013      	str	r3, [r2, #0]
	if (uxCriticalNesting == 1) {
    9d6e:	d10e      	bne.n	9d8e <vPortEnterCritical+0x3a>
		configASSERT((portNVIC_INT_CTRL_REG & portVECTACTIVE_MASK) == 0);
    9d70:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
    9d74:	f8d3 3d04 	ldr.w	r3, [r3, #3332]	; 0xd04
    9d78:	b2db      	uxtb	r3, r3
    9d7a:	b143      	cbz	r3, 9d8e <vPortEnterCritical+0x3a>
    9d7c:	f04f 0380 	mov.w	r3, #128	; 0x80
    9d80:	f383 8811 	msr	BASEPRI, r3
    9d84:	f3bf 8f6f 	isb	sy
    9d88:	f3bf 8f4f 	dsb	sy
    9d8c:	e7fe      	b.n	9d8c <vPortEnterCritical+0x38>
}
    9d8e:	4770      	bx	lr
    9d90:	20000018 	.word	0x20000018

00009d94 <vPortExitCritical>:
	configASSERT(uxCriticalNesting);
    9d94:	4a08      	ldr	r2, [pc, #32]	; (9db8 <vPortExitCritical+0x24>)
    9d96:	6813      	ldr	r3, [r2, #0]
    9d98:	b943      	cbnz	r3, 9dac <vPortExitCritical+0x18>
    9d9a:	f04f 0380 	mov.w	r3, #128	; 0x80
    9d9e:	f383 8811 	msr	BASEPRI, r3
    9da2:	f3bf 8f6f 	isb	sy
    9da6:	f3bf 8f4f 	dsb	sy
    9daa:	e7fe      	b.n	9daa <vPortExitCritical+0x16>
	uxCriticalNesting--;
    9dac:	3b01      	subs	r3, #1
    9dae:	6013      	str	r3, [r2, #0]
	if (uxCriticalNesting == 0) {
    9db0:	b90b      	cbnz	r3, 9db6 <vPortExitCritical+0x22>
	__asm volatile("	msr basepri, %0	" ::"r"(ulNewMaskValue));
    9db2:	f383 8811 	msr	BASEPRI, r3
}
    9db6:	4770      	bx	lr
    9db8:	20000018 	.word	0x20000018

00009dbc <PendSV_Handler>:
	__asm volatile(
    9dbc:	f3ef 8009 	mrs	r0, PSP
    9dc0:	f3bf 8f6f 	isb	sy
    9dc4:	4b14      	ldr	r3, [pc, #80]	; (9e18 <pxCurrentTCBConst>)
    9dc6:	681a      	ldr	r2, [r3, #0]
    9dc8:	f01e 0f10 	tst.w	lr, #16
    9dcc:	bf08      	it	eq
    9dce:	ed20 8a10 	vstmdbeq	r0!, {s16-s31}
    9dd2:	e920 4ff0 	stmdb	r0!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    9dd6:	6010      	str	r0, [r2, #0]
    9dd8:	f84d 3d04 	str.w	r3, [sp, #-4]!
    9ddc:	f04f 0080 	mov.w	r0, #128	; 0x80
    9de0:	f380 8811 	msr	BASEPRI, r0
    9de4:	f3bf 8f4f 	dsb	sy
    9de8:	f3bf 8f6f 	isb	sy
    9dec:	f7ff f940 	bl	9070 <vTaskSwitchContext>
    9df0:	f04f 0000 	mov.w	r0, #0
    9df4:	f380 8811 	msr	BASEPRI, r0
    9df8:	bc08      	pop	{r3}
    9dfa:	6819      	ldr	r1, [r3, #0]
    9dfc:	6808      	ldr	r0, [r1, #0]
    9dfe:	e8b0 4ff0 	ldmia.w	r0!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    9e02:	f01e 0f10 	tst.w	lr, #16
    9e06:	bf08      	it	eq
    9e08:	ecb0 8a10 	vldmiaeq	r0!, {s16-s31}
    9e0c:	f380 8809 	msr	PSP, r0
    9e10:	f3bf 8f6f 	isb	sy
    9e14:	4770      	bx	lr
    9e16:	bf00      	nop

00009e18 <pxCurrentTCBConst>:
    9e18:	200162a4 	.word	0x200162a4

00009e1c <SysTick_Handler>:
{
    9e1c:	b508      	push	{r3, lr}
	__asm volatile("	mrs %0, basepri											\n"
    9e1e:	f3ef 8311 	mrs	r3, BASEPRI
    9e22:	f04f 0280 	mov.w	r2, #128	; 0x80
    9e26:	f382 8811 	msr	BASEPRI, r2
    9e2a:	f3bf 8f6f 	isb	sy
    9e2e:	f3bf 8f4f 	dsb	sy
		if (xTaskIncrementTick() != pdFALSE) {
    9e32:	4b06      	ldr	r3, [pc, #24]	; (9e4c <SysTick_Handler+0x30>)
    9e34:	4798      	blx	r3
    9e36:	b128      	cbz	r0, 9e44 <SysTick_Handler+0x28>
			portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT;
    9e38:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
    9e3c:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
    9e40:	f8c3 2d04 	str.w	r2, [r3, #3332]	; 0xd04
	__asm volatile("	msr basepri, %0	" ::"r"(ulNewMaskValue));
    9e44:	2300      	movs	r3, #0
    9e46:	f383 8811 	msr	BASEPRI, r3
}
    9e4a:	bd08      	pop	{r3, pc}
    9e4c:	00008da5 	.word	0x00008da5

00009e50 <vPortSetupTimerInterrupt>:
	portNVIC_SYSTICK_LOAD_REG = (configSYSTICK_CLOCK_HZ / configTICK_RATE_HZ) - 1UL;
    9e50:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
    9e54:	f642 62df 	movw	r2, #11999	; 0x2edf
    9e58:	615a      	str	r2, [r3, #20]
	portNVIC_SYSTICK_CTRL_REG = (portNVIC_SYSTICK_CLK_BIT | portNVIC_SYSTICK_INT_BIT | portNVIC_SYSTICK_ENABLE_BIT);
    9e5a:	2207      	movs	r2, #7
    9e5c:	611a      	str	r2, [r3, #16]
}
    9e5e:	4770      	bx	lr

00009e60 <xPortStartScheduler>:
	configASSERT(portCPUID != portCORTEX_M7_r0p1_ID);
    9e60:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
{
    9e64:	b513      	push	{r0, r1, r4, lr}
	configASSERT(portCPUID != portCORTEX_M7_r0p1_ID);
    9e66:	4a34      	ldr	r2, [pc, #208]	; (9f38 <xPortStartScheduler+0xd8>)
    9e68:	f8d3 1d00 	ldr.w	r1, [r3, #3328]	; 0xd00
    9e6c:	4291      	cmp	r1, r2
    9e6e:	d108      	bne.n	9e82 <xPortStartScheduler+0x22>
	__asm volatile("	mov %0, %1												\n"
    9e70:	f04f 0380 	mov.w	r3, #128	; 0x80
    9e74:	f383 8811 	msr	BASEPRI, r3
    9e78:	f3bf 8f6f 	isb	sy
    9e7c:	f3bf 8f4f 	dsb	sy
    9e80:	e7fe      	b.n	9e80 <xPortStartScheduler+0x20>
	configASSERT(portCPUID != portCORTEX_M7_r0p0_ID);
    9e82:	f8d3 2d00 	ldr.w	r2, [r3, #3328]	; 0xd00
    9e86:	4b2d      	ldr	r3, [pc, #180]	; (9f3c <xPortStartScheduler+0xdc>)
    9e88:	429a      	cmp	r2, r3
    9e8a:	d108      	bne.n	9e9e <xPortStartScheduler+0x3e>
    9e8c:	f04f 0380 	mov.w	r3, #128	; 0x80
    9e90:	f383 8811 	msr	BASEPRI, r3
    9e94:	f3bf 8f6f 	isb	sy
    9e98:	f3bf 8f4f 	dsb	sy
    9e9c:	e7fe      	b.n	9e9c <xPortStartScheduler+0x3c>
		ulOriginalPriority = *pucFirstUserPriorityRegister;
    9e9e:	4b28      	ldr	r3, [pc, #160]	; (9f40 <xPortStartScheduler+0xe0>)
    9ea0:	781a      	ldrb	r2, [r3, #0]
    9ea2:	b2d2      	uxtb	r2, r2
    9ea4:	9201      	str	r2, [sp, #4]
		*pucFirstUserPriorityRegister = portMAX_8_BIT_VALUE;
    9ea6:	22ff      	movs	r2, #255	; 0xff
    9ea8:	701a      	strb	r2, [r3, #0]
		ucMaxPriorityValue = *pucFirstUserPriorityRegister;
    9eaa:	781b      	ldrb	r3, [r3, #0]
		ucMaxSysCallPriority = configMAX_SYSCALL_INTERRUPT_PRIORITY & ucMaxPriorityValue;
    9eac:	4a25      	ldr	r2, [pc, #148]	; (9f44 <xPortStartScheduler+0xe4>)
		ucMaxPriorityValue = *pucFirstUserPriorityRegister;
    9eae:	b2db      	uxtb	r3, r3
    9eb0:	f88d 3003 	strb.w	r3, [sp, #3]
		ucMaxSysCallPriority = configMAX_SYSCALL_INTERRUPT_PRIORITY & ucMaxPriorityValue;
    9eb4:	f89d 3003 	ldrb.w	r3, [sp, #3]
    9eb8:	f003 0380 	and.w	r3, r3, #128	; 0x80
    9ebc:	7013      	strb	r3, [r2, #0]
		ulMaxPRIGROUPValue = portMAX_PRIGROUP_BITS;
    9ebe:	2307      	movs	r3, #7
    9ec0:	6053      	str	r3, [r2, #4]
		while ((ucMaxPriorityValue & portTOP_BIT_OF_BYTE) == portTOP_BIT_OF_BYTE) {
    9ec2:	2100      	movs	r1, #0
    9ec4:	f89d 0003 	ldrb.w	r0, [sp, #3]
    9ec8:	0600      	lsls	r0, r0, #24
    9eca:	f103 34ff 	add.w	r4, r3, #4294967295	; 0xffffffff
    9ece:	d429      	bmi.n	9f24 <xPortStartScheduler+0xc4>
    9ed0:	b101      	cbz	r1, 9ed4 <xPortStartScheduler+0x74>
    9ed2:	6053      	str	r3, [r2, #4]
		ulMaxPRIGROUPValue <<= portPRIGROUP_SHIFT;
    9ed4:	6853      	ldr	r3, [r2, #4]
    9ed6:	021b      	lsls	r3, r3, #8
		ulMaxPRIGROUPValue &= portPRIORITY_GROUP_MASK;
    9ed8:	f403 63e0 	and.w	r3, r3, #1792	; 0x700
    9edc:	6053      	str	r3, [r2, #4]
		*pucFirstUserPriorityRegister = ulOriginalPriority;
    9ede:	9b01      	ldr	r3, [sp, #4]
    9ee0:	4a17      	ldr	r2, [pc, #92]	; (9f40 <xPortStartScheduler+0xe0>)
	portNVIC_SYSPRI2_REG |= portNVIC_PENDSV_PRI;
    9ee2:	f04f 24e0 	mov.w	r4, #3758153728	; 0xe000e000
		*pucFirstUserPriorityRegister = ulOriginalPriority;
    9ee6:	b2db      	uxtb	r3, r3
    9ee8:	7013      	strb	r3, [r2, #0]
	portNVIC_SYSPRI2_REG |= portNVIC_PENDSV_PRI;
    9eea:	f8d4 3d20 	ldr.w	r3, [r4, #3360]	; 0xd20
    9eee:	f443 0360 	orr.w	r3, r3, #14680064	; 0xe00000
    9ef2:	f8c4 3d20 	str.w	r3, [r4, #3360]	; 0xd20
	portNVIC_SYSPRI2_REG |= portNVIC_SYSTICK_PRI;
    9ef6:	f8d4 3d20 	ldr.w	r3, [r4, #3360]	; 0xd20
    9efa:	f043 4360 	orr.w	r3, r3, #3758096384	; 0xe0000000
    9efe:	f8c4 3d20 	str.w	r3, [r4, #3360]	; 0xd20
	vPortSetupTimerInterrupt();
    9f02:	4b11      	ldr	r3, [pc, #68]	; (9f48 <xPortStartScheduler+0xe8>)
    9f04:	4798      	blx	r3
	uxCriticalNesting = 0;
    9f06:	4b11      	ldr	r3, [pc, #68]	; (9f4c <xPortStartScheduler+0xec>)
    9f08:	2200      	movs	r2, #0
    9f0a:	601a      	str	r2, [r3, #0]
	vPortEnableVFP();
    9f0c:	4b10      	ldr	r3, [pc, #64]	; (9f50 <xPortStartScheduler+0xf0>)
    9f0e:	4798      	blx	r3
	*(portFPCCR) |= portASPEN_AND_LSPEN_BITS;
    9f10:	f8d4 3f34 	ldr.w	r3, [r4, #3892]	; 0xf34
    9f14:	f043 4340 	orr.w	r3, r3, #3221225472	; 0xc0000000
    9f18:	f8c4 3f34 	str.w	r3, [r4, #3892]	; 0xf34
	prvPortStartFirstTask();
    9f1c:	4b0d      	ldr	r3, [pc, #52]	; (9f54 <xPortStartScheduler+0xf4>)
    9f1e:	4798      	blx	r3
	prvTaskExitError();
    9f20:	4b0d      	ldr	r3, [pc, #52]	; (9f58 <xPortStartScheduler+0xf8>)
    9f22:	4798      	blx	r3
			ucMaxPriorityValue <<= (uint8_t)0x01;
    9f24:	f89d 3003 	ldrb.w	r3, [sp, #3]
    9f28:	005b      	lsls	r3, r3, #1
    9f2a:	b2db      	uxtb	r3, r3
    9f2c:	f88d 3003 	strb.w	r3, [sp, #3]
    9f30:	2101      	movs	r1, #1
    9f32:	4623      	mov	r3, r4
    9f34:	e7c6      	b.n	9ec4 <xPortStartScheduler+0x64>
    9f36:	bf00      	nop
    9f38:	410fc271 	.word	0x410fc271
    9f3c:	410fc270 	.word	0x410fc270
    9f40:	e000e400 	.word	0xe000e400
    9f44:	200163dc 	.word	0x200163dc
    9f48:	00009e51 	.word	0x00009e51
    9f4c:	20000018 	.word	0x20000018
    9f50:	00009cfd 	.word	0x00009cfd
    9f54:	00009cdd 	.word	0x00009cdd
    9f58:	00009cad 	.word	0x00009cad

00009f5c <vPortValidateInterruptPriority>:
{
	uint32_t ulCurrentInterrupt;
	uint8_t  ucCurrentPriority;

	/* Obtain the number of the currently executing interrupt. */
	__asm volatile("mrs %0, ipsr" : "=r"(ulCurrentInterrupt));
    9f5c:	f3ef 8305 	mrs	r3, IPSR

	/* Is the interrupt number a user defined interrupt? */
	if (ulCurrentInterrupt >= portFIRST_USER_INTERRUPT_NUMBER) {
    9f60:	2b0f      	cmp	r3, #15
    9f62:	4a11      	ldr	r2, [pc, #68]	; (9fa8 <vPortValidateInterruptPriority+0x4c>)
    9f64:	d90d      	bls.n	9f82 <vPortValidateInterruptPriority+0x26>
		/* Look up the interrupt's priority. */
		ucCurrentPriority = pcInterruptPriorityRegisters[ulCurrentInterrupt];
    9f66:	4911      	ldr	r1, [pc, #68]	; (9fac <vPortValidateInterruptPriority+0x50>)
    9f68:	5c5b      	ldrb	r3, [r3, r1]
		interrupt entry is as fast and simple as possible.

		The following links provide detailed information:
		http://www.freertos.org/RTOS-Cortex-M3-M4.html
		http://www.freertos.org/FAQHelp.html */
		configASSERT(ucCurrentPriority >= ucMaxSysCallPriority);
    9f6a:	7811      	ldrb	r1, [r2, #0]
    9f6c:	4299      	cmp	r1, r3
    9f6e:	d908      	bls.n	9f82 <vPortValidateInterruptPriority+0x26>
    9f70:	f04f 0380 	mov.w	r3, #128	; 0x80
    9f74:	f383 8811 	msr	BASEPRI, r3
    9f78:	f3bf 8f6f 	isb	sy
    9f7c:	f3bf 8f4f 	dsb	sy
    9f80:	e7fe      	b.n	9f80 <vPortValidateInterruptPriority+0x24>
	configuration then the correct setting can be achieved on all Cortex-M
	devices by calling NVIC_SetPriorityGrouping( 0 ); before starting the
	scheduler.  Note however that some vendor specific peripheral libraries
	assume a non-zero priority group setting, in which cases using a value
	of zero will result in unpredicable behaviour. */
	configASSERT((portAIRCR_REG & portPRIORITY_GROUP_MASK) <= ulMaxPRIGROUPValue);
    9f82:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
    9f86:	6852      	ldr	r2, [r2, #4]
    9f88:	f8d3 3d0c 	ldr.w	r3, [r3, #3340]	; 0xd0c
    9f8c:	f403 63e0 	and.w	r3, r3, #1792	; 0x700
    9f90:	4293      	cmp	r3, r2
    9f92:	d908      	bls.n	9fa6 <vPortValidateInterruptPriority+0x4a>
    9f94:	f04f 0380 	mov.w	r3, #128	; 0x80
    9f98:	f383 8811 	msr	BASEPRI, r3
    9f9c:	f3bf 8f6f 	isb	sy
    9fa0:	f3bf 8f4f 	dsb	sy
    9fa4:	e7fe      	b.n	9fa4 <vPortValidateInterruptPriority+0x48>
}
    9fa6:	4770      	bx	lr
    9fa8:	200163dc 	.word	0x200163dc
    9fac:	e000e3f0 	.word	0xe000e3f0

00009fb0 <netif_init>:
	netif_add(&loop_netif, &loop_ipaddr, &loop_netmask, &loop_gw, NULL, netif_loopif_init, tcpip_input);
#endif /* NO_SYS */
	netif_set_up(&loop_netif);

#endif /* LWIP_HAVE_LOOPIF */
}
    9fb0:	4770      	bx	lr
	...

00009fb4 <netif_set_ipaddr>:
 *
 * @note call netif_set_addr() if you also want to change netmask and
 * default gateway
 */
void netif_set_ipaddr(struct netif *netif, ip_addr_t *ipaddr)
{
    9fb4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    9fb6:	4605      	mov	r5, r0
#if LWIP_TCP
	struct tcp_pcb *       pcb;
	struct tcp_pcb_listen *lpcb;

	/* address is actually being changed? */
	if (ipaddr && (ip_addr_cmp(ipaddr, &(netif->ip_addr))) == 0) {
    9fb8:	460c      	mov	r4, r1
    9fba:	b159      	cbz	r1, 9fd4 <netif_set_ipaddr+0x20>
    9fbc:	680a      	ldr	r2, [r1, #0]
    9fbe:	6843      	ldr	r3, [r0, #4]
    9fc0:	429a      	cmp	r2, r3
    9fc2:	d006      	beq.n	9fd2 <netif_set_ipaddr+0x1e>
		/* extern struct tcp_pcb *tcp_active_pcbs; defined by tcp.h */
		LWIP_DEBUGF(NETIF_DEBUG | LWIP_DBG_STATE, ("netif_set_ipaddr: netif address being changed\n"));
		pcb = tcp_active_pcbs;
    9fc4:	4b0d      	ldr	r3, [pc, #52]	; (9ffc <netif_set_ipaddr+0x48>)
#endif /* LWIP_AUTOIP */
			) {
				/* this connection must be aborted */
				struct tcp_pcb *next = pcb->next;
				LWIP_DEBUGF(NETIF_DEBUG | LWIP_DBG_STATE, ("netif_set_ipaddr: aborting TCP pcb %p\n", (void *)pcb));
				tcp_abort(pcb);
    9fc6:	4e0e      	ldr	r6, [pc, #56]	; (a000 <netif_set_ipaddr+0x4c>)
		pcb = tcp_active_pcbs;
    9fc8:	6818      	ldr	r0, [r3, #0]
		while (pcb != NULL) {
    9fca:	b928      	cbnz	r0, 9fd8 <netif_set_ipaddr+0x24>
				pcb = next;
			} else {
				pcb = pcb->next;
			}
		}
		for (lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
    9fcc:	4b0d      	ldr	r3, [pc, #52]	; (a004 <netif_set_ipaddr+0x50>)
    9fce:	681b      	ldr	r3, [r3, #0]
    9fd0:	b953      	cbnz	r3, 9fe8 <netif_set_ipaddr+0x34>
	}
#endif
	snmp_delete_ipaddridx_tree(netif);
	snmp_delete_iprteidx_tree(0, netif);
	/* set new IP address to netif */
	ip_addr_set(&(netif->ip_addr), ipaddr);
    9fd2:	6824      	ldr	r4, [r4, #0]
    9fd4:	606c      	str	r4, [r5, #4]
	             netif->name[1],
	             ip4_addr1_16(&netif->ip_addr),
	             ip4_addr2_16(&netif->ip_addr),
	             ip4_addr3_16(&netif->ip_addr),
	             ip4_addr4_16(&netif->ip_addr)));
}
    9fd6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
			if (ip_addr_cmp(&(pcb->local_ip), &(netif->ip_addr))
    9fd8:	6802      	ldr	r2, [r0, #0]
    9fda:	686b      	ldr	r3, [r5, #4]
				struct tcp_pcb *next = pcb->next;
    9fdc:	68c7      	ldr	r7, [r0, #12]
			if (ip_addr_cmp(&(pcb->local_ip), &(netif->ip_addr))
    9fde:	429a      	cmp	r2, r3
    9fe0:	d100      	bne.n	9fe4 <netif_set_ipaddr+0x30>
				tcp_abort(pcb);
    9fe2:	47b0      	blx	r6
{
    9fe4:	4638      	mov	r0, r7
    9fe6:	e7f0      	b.n	9fca <netif_set_ipaddr+0x16>
			if ((!(ip_addr_isany(&(lpcb->local_ip)))) && (ip_addr_cmp(&(lpcb->local_ip), &(netif->ip_addr)))) {
    9fe8:	681a      	ldr	r2, [r3, #0]
    9fea:	b122      	cbz	r2, 9ff6 <netif_set_ipaddr+0x42>
    9fec:	6869      	ldr	r1, [r5, #4]
    9fee:	428a      	cmp	r2, r1
				ip_addr_set(&(lpcb->local_ip), ipaddr);
    9ff0:	bf04      	itt	eq
    9ff2:	6822      	ldreq	r2, [r4, #0]
    9ff4:	601a      	streq	r2, [r3, #0]
		for (lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
    9ff6:	68db      	ldr	r3, [r3, #12]
    9ff8:	e7ea      	b.n	9fd0 <netif_set_ipaddr+0x1c>
    9ffa:	bf00      	nop
    9ffc:	20014950 	.word	0x20014950
    a000:	00007275 	.word	0x00007275
    a004:	20014944 	.word	0x20014944

0000a008 <netif_set_addr>:
{
    a008:	b570      	push	{r4, r5, r6, lr}
    a00a:	4615      	mov	r5, r2
    a00c:	461c      	mov	r4, r3
	netif_set_ipaddr(netif, ipaddr);
    a00e:	4b05      	ldr	r3, [pc, #20]	; (a024 <netif_set_addr+0x1c>)
{
    a010:	4606      	mov	r6, r0
	netif_set_ipaddr(netif, ipaddr);
    a012:	4798      	blx	r3
 */
void netif_set_netmask(struct netif *netif, ip_addr_t *netmask)
{
	snmp_delete_iprteidx_tree(0, netif);
	/* set new netmask to netif */
	ip_addr_set(&(netif->netmask), netmask);
    a014:	b105      	cbz	r5, a018 <netif_set_addr+0x10>
    a016:	682d      	ldr	r5, [r5, #0]
    a018:	60b5      	str	r5, [r6, #8]
	ip_addr_set(&(netif->gw), gw);
    a01a:	b104      	cbz	r4, a01e <netif_set_addr+0x16>
    a01c:	6824      	ldr	r4, [r4, #0]
    a01e:	60f4      	str	r4, [r6, #12]
}
    a020:	bd70      	pop	{r4, r5, r6, pc}
    a022:	bf00      	nop
    a024:	00009fb5 	.word	0x00009fb5

0000a028 <netif_add>:
{
    a028:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	netif->state = state;
    a02a:	9e06      	ldr	r6, [sp, #24]
    a02c:	6206      	str	r6, [r0, #32]
	netif->num   = netif_num++;
    a02e:	4e10      	ldr	r6, [pc, #64]	; (a070 <netif_add+0x48>)
    a030:	7937      	ldrb	r7, [r6, #4]
    a032:	f880 7034 	strb.w	r7, [r0, #52]	; 0x34
	ip_addr_set_zero(&netif->ip_addr);
    a036:	2500      	movs	r5, #0
	netif->num   = netif_num++;
    a038:	f107 0c01 	add.w	ip, r7, #1
	netif->input = input;
    a03c:	9f08      	ldr	r7, [sp, #32]
    a03e:	6107      	str	r7, [r0, #16]
	ip_addr_set_zero(&netif->netmask);
    a040:	e9c0 5501 	strd	r5, r5, [r0, #4]
{
    a044:	4604      	mov	r4, r0
	ip_addr_set_zero(&netif->gw);
    a046:	60c5      	str	r5, [r0, #12]
	netif->flags = 0;
    a048:	f880 5031 	strb.w	r5, [r0, #49]	; 0x31
	netif->dhcp = NULL;
    a04c:	6245      	str	r5, [r0, #36]	; 0x24
	netif->status_callback = NULL;
    a04e:	61c5      	str	r5, [r0, #28]
	netif_set_addr(netif, ipaddr, netmask, gw);
    a050:	4f08      	ldr	r7, [pc, #32]	; (a074 <netif_add+0x4c>)
	netif->num   = netif_num++;
    a052:	f886 c004 	strb.w	ip, [r6, #4]
	netif_set_addr(netif, ipaddr, netmask, gw);
    a056:	47b8      	blx	r7
	if (init(netif) != ERR_OK) {
    a058:	9b07      	ldr	r3, [sp, #28]
    a05a:	4620      	mov	r0, r4
    a05c:	4798      	blx	r3
    a05e:	b920      	cbnz	r0, a06a <netif_add+0x42>
	netif->next = netif_list;
    a060:	6833      	ldr	r3, [r6, #0]
    a062:	6023      	str	r3, [r4, #0]
	netif_list  = netif;
    a064:	6034      	str	r4, [r6, #0]
}
    a066:	4620      	mov	r0, r4
    a068:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		return NULL;
    a06a:	462c      	mov	r4, r5
    a06c:	e7fb      	b.n	a066 <netif_add+0x3e>
    a06e:	bf00      	nop
    a070:	200163e4 	.word	0x200163e4
    a074:	0000a009 	.word	0x0000a009

0000a078 <netif_set_gw>:
	ip_addr_set(&(netif->gw), gw);
    a078:	b101      	cbz	r1, a07c <netif_set_gw+0x4>
    a07a:	6809      	ldr	r1, [r1, #0]
    a07c:	60c1      	str	r1, [r0, #12]
}
    a07e:	4770      	bx	lr

0000a080 <netif_set_netmask>:
	ip_addr_set(&(netif->netmask), netmask);
    a080:	b101      	cbz	r1, a084 <netif_set_netmask+0x4>
    a082:	6809      	ldr	r1, [r1, #0]
    a084:	6081      	str	r1, [r0, #8]
	             netif->name[1],
	             ip4_addr1_16(&netif->netmask),
	             ip4_addr2_16(&netif->netmask),
	             ip4_addr3_16(&netif->netmask),
	             ip4_addr4_16(&netif->netmask)));
}
    a086:	4770      	bx	lr

0000a088 <netif_set_default>:
		snmp_delete_iprteidx_tree(1, netif);
	} else {
		/* install default route */
		snmp_insert_iprteidx_tree(1, netif);
	}
	netif_default = netif;
    a088:	4b01      	ldr	r3, [pc, #4]	; (a090 <netif_set_default+0x8>)
    a08a:	6098      	str	r0, [r3, #8]
	LWIP_DEBUGF(
	    NETIF_DEBUG,
	    ("netif: setting default interface %c%c\n", netif ? netif->name[0] : '\'', netif ? netif->name[1] : '\''));
}
    a08c:	4770      	bx	lr
    a08e:	bf00      	nop
    a090:	200163e4 	.word	0x200163e4

0000a094 <netif_set_up>:
 * up once configured.
 *
 * @see dhcp_start()
 */
void netif_set_up(struct netif *netif)
{
    a094:	b510      	push	{r4, lr}
	if (!(netif->flags & NETIF_FLAG_UP)) {
    a096:	f890 3031 	ldrb.w	r3, [r0, #49]	; 0x31
    a09a:	07da      	lsls	r2, r3, #31
{
    a09c:	4604      	mov	r4, r0
	if (!(netif->flags & NETIF_FLAG_UP)) {
    a09e:	d412      	bmi.n	a0c6 <netif_set_up+0x32>
		netif->flags |= NETIF_FLAG_UP;
    a0a0:	f043 0301 	orr.w	r3, r3, #1
    a0a4:	f880 3031 	strb.w	r3, [r0, #49]	; 0x31

#if LWIP_SNMP
		snmp_get_sysuptime(&netif->ts);
#endif /* LWIP_SNMP */

		NETIF_STATUS_CALLBACK(netif);
    a0a8:	69c3      	ldr	r3, [r0, #28]
    a0aa:	b103      	cbz	r3, a0ae <netif_set_up+0x1a>
    a0ac:	4798      	blx	r3

		if (netif->flags & NETIF_FLAG_LINK_UP) {
#if LWIP_ARP
			/* For Ethernet network interfaces, we would like to send a "gratuitous ARP" */
			if (netif->flags & (NETIF_FLAG_ETHARP)) {
    a0ae:	f894 3031 	ldrb.w	r3, [r4, #49]	; 0x31
    a0b2:	f003 0330 	and.w	r3, r3, #48	; 0x30
    a0b6:	2b30      	cmp	r3, #48	; 0x30
    a0b8:	d105      	bne.n	a0c6 <netif_set_up+0x32>
				etharp_gratuitous(netif);
    a0ba:	1d21      	adds	r1, r4, #4
    a0bc:	4620      	mov	r0, r4
    a0be:	4b02      	ldr	r3, [pc, #8]	; (a0c8 <netif_set_up+0x34>)
				igmp_report_groups(netif);
			}
#endif /* LWIP_IGMP */
		}
	}
}
    a0c0:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
				etharp_gratuitous(netif);
    a0c4:	4718      	bx	r3
}
    a0c6:	bd10      	pop	{r4, pc}
    a0c8:	00004fa5 	.word	0x00004fa5

0000a0cc <netif_set_down>:
 * up once configured.
 *
 * @see dhcp_start()
 */
void netif_set_down(struct netif *netif)
{
    a0cc:	b510      	push	{r4, lr}
	if (netif->flags & NETIF_FLAG_UP) {
    a0ce:	f890 3031 	ldrb.w	r3, [r0, #49]	; 0x31
    a0d2:	07da      	lsls	r2, r3, #31
{
    a0d4:	4604      	mov	r4, r0
	if (netif->flags & NETIF_FLAG_UP) {
    a0d6:	d50d      	bpl.n	a0f4 <netif_set_down+0x28>
		netif->flags &= ~NETIF_FLAG_UP;
    a0d8:	f023 0201 	bic.w	r2, r3, #1
#if LWIP_SNMP
		snmp_get_sysuptime(&netif->ts);
#endif

#if LWIP_ARP
		if (netif->flags & NETIF_FLAG_ETHARP) {
    a0dc:	069b      	lsls	r3, r3, #26
		netif->flags &= ~NETIF_FLAG_UP;
    a0de:	f880 2031 	strb.w	r2, [r0, #49]	; 0x31
		if (netif->flags & NETIF_FLAG_ETHARP) {
    a0e2:	d501      	bpl.n	a0e8 <netif_set_down+0x1c>
			etharp_cleanup_netif(netif);
    a0e4:	4b04      	ldr	r3, [pc, #16]	; (a0f8 <netif_set_down+0x2c>)
    a0e6:	4798      	blx	r3
		}
#endif /* LWIP_ARP */
		NETIF_STATUS_CALLBACK(netif);
    a0e8:	69e3      	ldr	r3, [r4, #28]
    a0ea:	b11b      	cbz	r3, a0f4 <netif_set_down+0x28>
    a0ec:	4620      	mov	r0, r4
	}
}
    a0ee:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		NETIF_STATUS_CALLBACK(netif);
    a0f2:	4718      	bx	r3
}
    a0f4:	bd10      	pop	{r4, pc}
    a0f6:	bf00      	nop
    a0f8:	00004f79 	.word	0x00004f79

0000a0fc <tcpip_thread>:
 * thread context.
 *
 * @param arg unused argument
 */
static void tcpip_thread(void *arg)
{
    a0fc:	b507      	push	{r0, r1, r2, lr}
	struct tcpip_msg *msg;
	LWIP_UNUSED_ARG(arg);

	if (tcpip_init_done != NULL) {
    a0fe:	4a1e      	ldr	r2, [pc, #120]	; (a178 <tcpip_thread+0x7c>)
    a100:	6813      	ldr	r3, [r2, #0]
    a102:	b10b      	cbz	r3, a108 <tcpip_thread+0xc>
		tcpip_init_done(tcpip_init_done_arg);
    a104:	6850      	ldr	r0, [r2, #4]
    a106:	4798      	blx	r3
	LOCK_TCPIP_CORE();
	while (1) { /* MAIN Loop */
		UNLOCK_TCPIP_CORE();
		LWIP_TCPIP_THREAD_ALIVE();
		/* wait for a message, timeouts are processed while waiting */
		sys_timeouts_mbox_fetch(&mbox, (void **)&msg);
    a108:	4e1c      	ldr	r6, [pc, #112]	; (a17c <tcpip_thread+0x80>)
    a10a:	4d1d      	ldr	r5, [pc, #116]	; (a180 <tcpip_thread+0x84>)
#endif /* LWIP_TCPIP_TIMEOUT */

		case TCPIP_MSG_CALLBACK:
			LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip_thread: CALLBACK %p\n", (void *)msg));
			msg->msg.cb.function(msg->msg.cb.ctx);
			memp_free(MEMP_TCPIP_MSG_API, msg);
    a10c:	4c1d      	ldr	r4, [pc, #116]	; (a184 <tcpip_thread+0x88>)
		sys_timeouts_mbox_fetch(&mbox, (void **)&msg);
    a10e:	a901      	add	r1, sp, #4
    a110:	4630      	mov	r0, r6
    a112:	47a8      	blx	r5
		switch (msg->type) {
    a114:	9b01      	ldr	r3, [sp, #4]
    a116:	781a      	ldrb	r2, [r3, #0]
    a118:	2a05      	cmp	r2, #5
    a11a:	d8f8      	bhi.n	a10e <tcpip_thread+0x12>
    a11c:	e8df f002 	tbb	[pc, r2]
    a120:	1e160803 	.word	0x1e160803
    a124:	2723      	.short	0x2723
			msg->msg.apimsg->function(&(msg->msg.apimsg->msg));
    a126:	6898      	ldr	r0, [r3, #8]
    a128:	f850 3b04 	ldr.w	r3, [r0], #4
    a12c:	4798      	blx	r3
			break;
    a12e:	e7ee      	b.n	a10e <tcpip_thread+0x12>
			msg->msg.apimsg->function(&(msg->msg.apimsg->msg));
    a130:	e9d3 0102 	ldrd	r0, r1, [r3, #8]
			if (msg->msg.inp.netif->flags & (NETIF_FLAG_ETHARP | NETIF_FLAG_ETHERNET)) {
    a134:	f891 3031 	ldrb.w	r3, [r1, #49]	; 0x31
    a138:	f013 0f60 	tst.w	r3, #96	; 0x60
				ethernet_input(msg->msg.inp.p, msg->msg.inp.netif);
    a13c:	bf14      	ite	ne
    a13e:	4b12      	ldrne	r3, [pc, #72]	; (a188 <tcpip_thread+0x8c>)
				ip_input(msg->msg.inp.p, msg->msg.inp.netif);
    a140:	4b12      	ldreq	r3, [pc, #72]	; (a18c <tcpip_thread+0x90>)
    a142:	4798      	blx	r3
			memp_free(MEMP_TCPIP_MSG_INPKT, msg);
    a144:	9901      	ldr	r1, [sp, #4]
    a146:	2009      	movs	r0, #9
			memp_free(MEMP_TCPIP_MSG_API, msg);
    a148:	47a0      	blx	r4
			break;
    a14a:	e7e0      	b.n	a10e <tcpip_thread+0x12>
			sys_timeout(msg->msg.tmo.msecs, msg->msg.tmo.h, msg->msg.tmo.arg);
    a14c:	e9d3 1203 	ldrd	r1, r2, [r3, #12]
    a150:	6898      	ldr	r0, [r3, #8]
    a152:	4b0f      	ldr	r3, [pc, #60]	; (a190 <tcpip_thread+0x94>)
    a154:	4798      	blx	r3
			memp_free(MEMP_TCPIP_MSG_API, msg);
    a156:	9901      	ldr	r1, [sp, #4]
    a158:	2008      	movs	r0, #8
    a15a:	e7f5      	b.n	a148 <tcpip_thread+0x4c>
			sys_untimeout(msg->msg.tmo.h, msg->msg.tmo.arg);
    a15c:	e9d3 0103 	ldrd	r0, r1, [r3, #12]
    a160:	4b0c      	ldr	r3, [pc, #48]	; (a194 <tcpip_thread+0x98>)
    a162:	4798      	blx	r3
			memp_free(MEMP_TCPIP_MSG_API, msg);
    a164:	e7f7      	b.n	a156 <tcpip_thread+0x5a>
			msg->msg.cb.function(msg->msg.cb.ctx);
    a166:	e9d3 2002 	ldrd	r2, r0, [r3, #8]
    a16a:	4790      	blx	r2
			memp_free(MEMP_TCPIP_MSG_API, msg);
    a16c:	e7f3      	b.n	a156 <tcpip_thread+0x5a>
			break;

		case TCPIP_MSG_CALLBACK_STATIC:
			LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip_thread: CALLBACK_STATIC %p\n", (void *)msg));
			msg->msg.cb.function(msg->msg.cb.ctx);
    a16e:	e9d3 2002 	ldrd	r2, r0, [r3, #8]
    a172:	4790      	blx	r2
			break;
    a174:	e7cb      	b.n	a10e <tcpip_thread+0x12>
    a176:	bf00      	nop
    a178:	200163f0 	.word	0x200163f0
    a17c:	200163f8 	.word	0x200163f8
    a180:	00001241 	.word	0x00001241
    a184:	00004c1d 	.word	0x00004c1d
    a188:	000052b9 	.word	0x000052b9
    a18c:	00006395 	.word	0x00006395
    a190:	00001049 	.word	0x00001049
    a194:	000011f5 	.word	0x000011f5

0000a198 <tcpip_input>:
 *          to an IP header (if inp doesn't have NETIF_FLAG_ETHARP or
 *          NETIF_FLAG_ETHERNET flags)
 * @param inp the network interface on which the packet was received
 */
err_t tcpip_input(struct pbuf *p, struct netif *inp)
{
    a198:	b570      	push	{r4, r5, r6, lr}
	UNLOCK_TCPIP_CORE();
	return ret;
#else  /* LWIP_TCPIP_CORE_LOCKING_INPUT */
	struct tcpip_msg *msg;

	if (!sys_mbox_valid(&mbox)) {
    a19a:	4b0f      	ldr	r3, [pc, #60]	; (a1d8 <tcpip_input+0x40>)
{
    a19c:	4606      	mov	r6, r0
	if (!sys_mbox_valid(&mbox)) {
    a19e:	480f      	ldr	r0, [pc, #60]	; (a1dc <tcpip_input+0x44>)
{
    a1a0:	460d      	mov	r5, r1
	if (!sys_mbox_valid(&mbox)) {
    a1a2:	4798      	blx	r3
    a1a4:	b1a0      	cbz	r0, a1d0 <tcpip_input+0x38>
		return ERR_VAL;
	}
	msg = (struct tcpip_msg *)memp_malloc(MEMP_TCPIP_MSG_INPKT);
    a1a6:	4b0e      	ldr	r3, [pc, #56]	; (a1e0 <tcpip_input+0x48>)
    a1a8:	2009      	movs	r0, #9
    a1aa:	4798      	blx	r3
	if (msg == NULL) {
    a1ac:	4604      	mov	r4, r0
    a1ae:	b160      	cbz	r0, a1ca <tcpip_input+0x32>
		return ERR_MEM;
	}

	msg->type          = TCPIP_MSG_INPKT;
    a1b0:	2301      	movs	r3, #1
    a1b2:	7003      	strb	r3, [r0, #0]
	msg->msg.inp.p     = p;
	msg->msg.inp.netif = inp;
    a1b4:	e9c0 6502 	strd	r6, r5, [r0, #8]
	if (sys_mbox_trypost(&mbox, msg) != ERR_OK) {
    a1b8:	4601      	mov	r1, r0
    a1ba:	4b0a      	ldr	r3, [pc, #40]	; (a1e4 <tcpip_input+0x4c>)
    a1bc:	4807      	ldr	r0, [pc, #28]	; (a1dc <tcpip_input+0x44>)
    a1be:	4798      	blx	r3
    a1c0:	b140      	cbz	r0, a1d4 <tcpip_input+0x3c>
		memp_free(MEMP_TCPIP_MSG_INPKT, msg);
    a1c2:	4b09      	ldr	r3, [pc, #36]	; (a1e8 <tcpip_input+0x50>)
    a1c4:	4621      	mov	r1, r4
    a1c6:	2009      	movs	r0, #9
    a1c8:	4798      	blx	r3
		return ERR_MEM;
    a1ca:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    a1ce:	e001      	b.n	a1d4 <tcpip_input+0x3c>
		return ERR_VAL;
    a1d0:	f06f 0005 	mvn.w	r0, #5
		return ERR_MEM;
	}
	return ERR_OK;
#endif /* LWIP_TCPIP_CORE_LOCKING_INPUT */
}
    a1d4:	bd70      	pop	{r4, r5, r6, pc}
    a1d6:	bf00      	nop
    a1d8:	00007bdd 	.word	0x00007bdd
    a1dc:	200163f8 	.word	0x200163f8
    a1e0:	00004c01 	.word	0x00004c01
    a1e4:	00007ae9 	.word	0x00007ae9
    a1e8:	00004c1d 	.word	0x00004c1d

0000a1ec <tcpip_callback_with_block>:
 * @param ctx parameter passed to f
 * @param block 1 to block until the request is posted, 0 to non-blocking mode
 * @return ERR_OK if the function was called, another err_t if not
 */
err_t tcpip_callback_with_block(tcpip_callback_fn function, void *ctx, u8_t block)
{
    a1ec:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    a1ee:	4607      	mov	r7, r0
	struct tcpip_msg *msg;

	if (sys_mbox_valid(&mbox)) {
    a1f0:	4b11      	ldr	r3, [pc, #68]	; (a238 <tcpip_callback_with_block+0x4c>)
    a1f2:	4812      	ldr	r0, [pc, #72]	; (a23c <tcpip_callback_with_block+0x50>)
{
    a1f4:	460e      	mov	r6, r1
    a1f6:	4615      	mov	r5, r2
	if (sys_mbox_valid(&mbox)) {
    a1f8:	4798      	blx	r3
    a1fa:	b1d0      	cbz	r0, a232 <tcpip_callback_with_block+0x46>
		msg = (struct tcpip_msg *)memp_malloc(MEMP_TCPIP_MSG_API);
    a1fc:	4b10      	ldr	r3, [pc, #64]	; (a240 <tcpip_callback_with_block+0x54>)
    a1fe:	2008      	movs	r0, #8
    a200:	4798      	blx	r3
		if (msg == NULL) {
    a202:	4604      	mov	r4, r0
    a204:	b190      	cbz	r0, a22c <tcpip_callback_with_block+0x40>
			return ERR_MEM;
		}

		msg->type            = TCPIP_MSG_CALLBACK;
    a206:	2304      	movs	r3, #4
		msg->msg.cb.function = function;
		msg->msg.cb.ctx      = ctx;
    a208:	e9c0 7602 	strd	r7, r6, [r0, #8]
		msg->type            = TCPIP_MSG_CALLBACK;
    a20c:	7003      	strb	r3, [r0, #0]
		if (block) {
			sys_mbox_post(&mbox, msg);
    a20e:	4601      	mov	r1, r0
    a210:	480a      	ldr	r0, [pc, #40]	; (a23c <tcpip_callback_with_block+0x50>)
		if (block) {
    a212:	b11d      	cbz	r5, a21c <tcpip_callback_with_block+0x30>
			sys_mbox_post(&mbox, msg);
    a214:	4b0b      	ldr	r3, [pc, #44]	; (a244 <tcpip_callback_with_block+0x58>)
    a216:	4798      	blx	r3
			if (sys_mbox_trypost(&mbox, msg) != ERR_OK) {
				memp_free(MEMP_TCPIP_MSG_API, msg);
				return ERR_MEM;
			}
		}
		return ERR_OK;
    a218:	2000      	movs	r0, #0
	}
	return ERR_VAL;
}
    a21a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
			if (sys_mbox_trypost(&mbox, msg) != ERR_OK) {
    a21c:	4b0a      	ldr	r3, [pc, #40]	; (a248 <tcpip_callback_with_block+0x5c>)
    a21e:	4798      	blx	r3
    a220:	2800      	cmp	r0, #0
    a222:	d0fa      	beq.n	a21a <tcpip_callback_with_block+0x2e>
				memp_free(MEMP_TCPIP_MSG_API, msg);
    a224:	4b09      	ldr	r3, [pc, #36]	; (a24c <tcpip_callback_with_block+0x60>)
    a226:	4621      	mov	r1, r4
    a228:	2008      	movs	r0, #8
    a22a:	4798      	blx	r3
			return ERR_MEM;
    a22c:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    a230:	e7f3      	b.n	a21a <tcpip_callback_with_block+0x2e>
	return ERR_VAL;
    a232:	f06f 0005 	mvn.w	r0, #5
    a236:	e7f0      	b.n	a21a <tcpip_callback_with_block+0x2e>
    a238:	00007bdd 	.word	0x00007bdd
    a23c:	200163f8 	.word	0x200163f8
    a240:	00004c01 	.word	0x00004c01
    a244:	00007ac5 	.word	0x00007ac5
    a248:	00007ae9 	.word	0x00007ae9
    a24c:	00004c1d 	.word	0x00004c1d

0000a250 <tcpip_apimsg>:
 *
 * @param apimsg a struct containing the function to call and its parameters
 * @return ERR_OK if the function was called, another err_t if not
 */
err_t tcpip_apimsg(struct api_msg *apimsg)
{
    a250:	b530      	push	{r4, r5, lr}
#ifdef LWIP_DEBUG
	/* catch functions that don't set err */
	apimsg->msg.err = ERR_VAL;
#endif

	if (sys_mbox_valid(&mbox)) {
    a252:	4b0d      	ldr	r3, [pc, #52]	; (a288 <tcpip_apimsg+0x38>)
{
    a254:	b087      	sub	sp, #28
    a256:	4604      	mov	r4, r0
	if (sys_mbox_valid(&mbox)) {
    a258:	480c      	ldr	r0, [pc, #48]	; (a28c <tcpip_apimsg+0x3c>)
    a25a:	4798      	blx	r3
    a25c:	b180      	cbz	r0, a280 <tcpip_apimsg+0x30>
		msg.type       = TCPIP_MSG_API;
		msg.msg.apimsg = apimsg;
		sys_mbox_post(&mbox, &msg);
    a25e:	480b      	ldr	r0, [pc, #44]	; (a28c <tcpip_apimsg+0x3c>)
    a260:	4b0b      	ldr	r3, [pc, #44]	; (a290 <tcpip_apimsg+0x40>)
		msg.msg.apimsg = apimsg;
    a262:	9403      	str	r4, [sp, #12]
		msg.type       = TCPIP_MSG_API;
    a264:	2500      	movs	r5, #0
		sys_mbox_post(&mbox, &msg);
    a266:	a901      	add	r1, sp, #4
		msg.type       = TCPIP_MSG_API;
    a268:	f88d 5004 	strb.w	r5, [sp, #4]
		sys_mbox_post(&mbox, &msg);
    a26c:	4798      	blx	r3
		sys_arch_sem_wait(&apimsg->msg.conn->op_completed, 0);
    a26e:	6860      	ldr	r0, [r4, #4]
    a270:	4b08      	ldr	r3, [pc, #32]	; (a294 <tcpip_apimsg+0x44>)
    a272:	4629      	mov	r1, r5
    a274:	300c      	adds	r0, #12
    a276:	4798      	blx	r3
		return apimsg->msg.err;
    a278:	f994 0008 	ldrsb.w	r0, [r4, #8]
	}
	return ERR_VAL;
}
    a27c:	b007      	add	sp, #28
    a27e:	bd30      	pop	{r4, r5, pc}
	return ERR_VAL;
    a280:	f06f 0005 	mvn.w	r0, #5
    a284:	e7fa      	b.n	a27c <tcpip_apimsg+0x2c>
    a286:	bf00      	nop
    a288:	00007bdd 	.word	0x00007bdd
    a28c:	200163f8 	.word	0x200163f8
    a290:	00007ac5 	.word	0x00007ac5
    a294:	00007a39 	.word	0x00007a39

0000a298 <tcpip_init>:
 *
 * @param initfunc a function to call when tcpip_thread is running and finished initializing
 * @param arg argument to pass to initfunc
 */
void tcpip_init(tcpip_init_done_fn initfunc, void *arg)
{
    a298:	b537      	push	{r0, r1, r2, r4, r5, lr}
	lwip_init();
    a29a:	4b0b      	ldr	r3, [pc, #44]	; (a2c8 <tcpip_init+0x30>)
{
    a29c:	4605      	mov	r5, r0
    a29e:	460c      	mov	r4, r1
	lwip_init();
    a2a0:	4798      	blx	r3

	tcpip_init_done     = initfunc;
    a2a2:	480a      	ldr	r0, [pc, #40]	; (a2cc <tcpip_init+0x34>)
	tcpip_init_done_arg = arg;
	if (sys_mbox_new(&mbox, TCPIP_MBOX_SIZE) != ERR_OK) {
    a2a4:	4b0a      	ldr	r3, [pc, #40]	; (a2d0 <tcpip_init+0x38>)
	tcpip_init_done_arg = arg;
    a2a6:	e9c0 5400 	strd	r5, r4, [r0]
	if (sys_mbox_new(&mbox, TCPIP_MBOX_SIZE) != ERR_OK) {
    a2aa:	2110      	movs	r1, #16
    a2ac:	3008      	adds	r0, #8
    a2ae:	4798      	blx	r3
	if (sys_mutex_new(&lock_tcpip_core) != ERR_OK) {
		LWIP_ASSERT("failed to create lock_tcpip_core", 0);
	}
#endif /* LWIP_TCPIP_CORE_LOCKING */

	sys_thread_new(TCPIP_THREAD_NAME, tcpip_thread, NULL, TCPIP_THREAD_STACKSIZE, TCPIP_THREAD_PRIO);
    a2b0:	2301      	movs	r3, #1
    a2b2:	9300      	str	r3, [sp, #0]
    a2b4:	4907      	ldr	r1, [pc, #28]	; (a2d4 <tcpip_init+0x3c>)
    a2b6:	4c08      	ldr	r4, [pc, #32]	; (a2d8 <tcpip_init+0x40>)
    a2b8:	4808      	ldr	r0, [pc, #32]	; (a2dc <tcpip_init+0x44>)
    a2ba:	f44f 6383 	mov.w	r3, #1048	; 0x418
    a2be:	2200      	movs	r2, #0
    a2c0:	47a0      	blx	r4
}
    a2c2:	b003      	add	sp, #12
    a2c4:	bd30      	pop	{r4, r5, pc}
    a2c6:	bf00      	nop
    a2c8:	00007f21 	.word	0x00007f21
    a2cc:	200163f0 	.word	0x200163f0
    a2d0:	00007a9d 	.word	0x00007a9d
    a2d4:	0000a0fd 	.word	0x0000a0fd
    a2d8:	00007be9 	.word	0x00007be9
    a2dc:	0000b974 	.word	0x0000b974

0000a2e0 <__libc_init_array>:
    a2e0:	b570      	push	{r4, r5, r6, lr}
    a2e2:	4d0d      	ldr	r5, [pc, #52]	; (a318 <__libc_init_array+0x38>)
    a2e4:	4c0d      	ldr	r4, [pc, #52]	; (a31c <__libc_init_array+0x3c>)
    a2e6:	1b64      	subs	r4, r4, r5
    a2e8:	10a4      	asrs	r4, r4, #2
    a2ea:	2600      	movs	r6, #0
    a2ec:	42a6      	cmp	r6, r4
    a2ee:	d109      	bne.n	a304 <__libc_init_array+0x24>
    a2f0:	4d0b      	ldr	r5, [pc, #44]	; (a320 <__libc_init_array+0x40>)
    a2f2:	4c0c      	ldr	r4, [pc, #48]	; (a324 <__libc_init_array+0x44>)
    a2f4:	f001 fb92 	bl	ba1c <_init>
    a2f8:	1b64      	subs	r4, r4, r5
    a2fa:	10a4      	asrs	r4, r4, #2
    a2fc:	2600      	movs	r6, #0
    a2fe:	42a6      	cmp	r6, r4
    a300:	d105      	bne.n	a30e <__libc_init_array+0x2e>
    a302:	bd70      	pop	{r4, r5, r6, pc}
    a304:	f855 3b04 	ldr.w	r3, [r5], #4
    a308:	4798      	blx	r3
    a30a:	3601      	adds	r6, #1
    a30c:	e7ee      	b.n	a2ec <__libc_init_array+0xc>
    a30e:	f855 3b04 	ldr.w	r3, [r5], #4
    a312:	4798      	blx	r3
    a314:	3601      	adds	r6, #1
    a316:	e7f2      	b.n	a2fe <__libc_init_array+0x1e>
    a318:	0000ba28 	.word	0x0000ba28
    a31c:	0000ba28 	.word	0x0000ba28
    a320:	0000ba28 	.word	0x0000ba28
    a324:	0000ba2c 	.word	0x0000ba2c

0000a328 <memcmp>:
    a328:	b510      	push	{r4, lr}
    a32a:	3901      	subs	r1, #1
    a32c:	4402      	add	r2, r0
    a32e:	4290      	cmp	r0, r2
    a330:	d101      	bne.n	a336 <memcmp+0xe>
    a332:	2000      	movs	r0, #0
    a334:	e005      	b.n	a342 <memcmp+0x1a>
    a336:	7803      	ldrb	r3, [r0, #0]
    a338:	f811 4f01 	ldrb.w	r4, [r1, #1]!
    a33c:	42a3      	cmp	r3, r4
    a33e:	d001      	beq.n	a344 <memcmp+0x1c>
    a340:	1b18      	subs	r0, r3, r4
    a342:	bd10      	pop	{r4, pc}
    a344:	3001      	adds	r0, #1
    a346:	e7f2      	b.n	a32e <memcmp+0x6>

0000a348 <memcpy>:
    a348:	440a      	add	r2, r1
    a34a:	4291      	cmp	r1, r2
    a34c:	f100 33ff 	add.w	r3, r0, #4294967295	; 0xffffffff
    a350:	d100      	bne.n	a354 <memcpy+0xc>
    a352:	4770      	bx	lr
    a354:	b510      	push	{r4, lr}
    a356:	f811 4b01 	ldrb.w	r4, [r1], #1
    a35a:	f803 4f01 	strb.w	r4, [r3, #1]!
    a35e:	4291      	cmp	r1, r2
    a360:	d1f9      	bne.n	a356 <memcpy+0xe>
    a362:	bd10      	pop	{r4, pc}

0000a364 <memset>:
    a364:	4402      	add	r2, r0
    a366:	4603      	mov	r3, r0
    a368:	4293      	cmp	r3, r2
    a36a:	d100      	bne.n	a36e <memset+0xa>
    a36c:	4770      	bx	lr
    a36e:	f803 1b01 	strb.w	r1, [r3], #1
    a372:	e7f9      	b.n	a368 <memset+0x4>

0000a374 <iprintf>:
    a374:	b40f      	push	{r0, r1, r2, r3}
    a376:	4b0a      	ldr	r3, [pc, #40]	; (a3a0 <iprintf+0x2c>)
    a378:	b513      	push	{r0, r1, r4, lr}
    a37a:	681c      	ldr	r4, [r3, #0]
    a37c:	b124      	cbz	r4, a388 <iprintf+0x14>
    a37e:	69a3      	ldr	r3, [r4, #24]
    a380:	b913      	cbnz	r3, a388 <iprintf+0x14>
    a382:	4620      	mov	r0, r4
    a384:	f000 fb3c 	bl	aa00 <__sinit>
    a388:	ab05      	add	r3, sp, #20
    a38a:	9a04      	ldr	r2, [sp, #16]
    a38c:	68a1      	ldr	r1, [r4, #8]
    a38e:	9301      	str	r3, [sp, #4]
    a390:	4620      	mov	r0, r4
    a392:	f000 fd49 	bl	ae28 <_vfiprintf_r>
    a396:	b002      	add	sp, #8
    a398:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    a39c:	b004      	add	sp, #16
    a39e:	4770      	bx	lr
    a3a0:	2000001c 	.word	0x2000001c

0000a3a4 <_puts_r>:
    a3a4:	b570      	push	{r4, r5, r6, lr}
    a3a6:	460e      	mov	r6, r1
    a3a8:	4605      	mov	r5, r0
    a3aa:	b118      	cbz	r0, a3b4 <_puts_r+0x10>
    a3ac:	6983      	ldr	r3, [r0, #24]
    a3ae:	b90b      	cbnz	r3, a3b4 <_puts_r+0x10>
    a3b0:	f000 fb26 	bl	aa00 <__sinit>
    a3b4:	69ab      	ldr	r3, [r5, #24]
    a3b6:	68ac      	ldr	r4, [r5, #8]
    a3b8:	b913      	cbnz	r3, a3c0 <_puts_r+0x1c>
    a3ba:	4628      	mov	r0, r5
    a3bc:	f000 fb20 	bl	aa00 <__sinit>
    a3c0:	4b2c      	ldr	r3, [pc, #176]	; (a474 <_puts_r+0xd0>)
    a3c2:	429c      	cmp	r4, r3
    a3c4:	d120      	bne.n	a408 <_puts_r+0x64>
    a3c6:	686c      	ldr	r4, [r5, #4]
    a3c8:	6e63      	ldr	r3, [r4, #100]	; 0x64
    a3ca:	07db      	lsls	r3, r3, #31
    a3cc:	d405      	bmi.n	a3da <_puts_r+0x36>
    a3ce:	89a3      	ldrh	r3, [r4, #12]
    a3d0:	0598      	lsls	r0, r3, #22
    a3d2:	d402      	bmi.n	a3da <_puts_r+0x36>
    a3d4:	6da0      	ldr	r0, [r4, #88]	; 0x58
    a3d6:	f000 fbb1 	bl	ab3c <__retarget_lock_acquire_recursive>
    a3da:	89a3      	ldrh	r3, [r4, #12]
    a3dc:	0719      	lsls	r1, r3, #28
    a3de:	d51d      	bpl.n	a41c <_puts_r+0x78>
    a3e0:	6923      	ldr	r3, [r4, #16]
    a3e2:	b1db      	cbz	r3, a41c <_puts_r+0x78>
    a3e4:	3e01      	subs	r6, #1
    a3e6:	68a3      	ldr	r3, [r4, #8]
    a3e8:	f816 1f01 	ldrb.w	r1, [r6, #1]!
    a3ec:	3b01      	subs	r3, #1
    a3ee:	60a3      	str	r3, [r4, #8]
    a3f0:	bb39      	cbnz	r1, a442 <_puts_r+0x9e>
    a3f2:	2b00      	cmp	r3, #0
    a3f4:	da38      	bge.n	a468 <_puts_r+0xc4>
    a3f6:	4622      	mov	r2, r4
    a3f8:	210a      	movs	r1, #10
    a3fa:	4628      	mov	r0, r5
    a3fc:	f000 f92a 	bl	a654 <__swbuf_r>
    a400:	3001      	adds	r0, #1
    a402:	d011      	beq.n	a428 <_puts_r+0x84>
    a404:	250a      	movs	r5, #10
    a406:	e011      	b.n	a42c <_puts_r+0x88>
    a408:	4b1b      	ldr	r3, [pc, #108]	; (a478 <_puts_r+0xd4>)
    a40a:	429c      	cmp	r4, r3
    a40c:	d101      	bne.n	a412 <_puts_r+0x6e>
    a40e:	68ac      	ldr	r4, [r5, #8]
    a410:	e7da      	b.n	a3c8 <_puts_r+0x24>
    a412:	4b1a      	ldr	r3, [pc, #104]	; (a47c <_puts_r+0xd8>)
    a414:	429c      	cmp	r4, r3
    a416:	bf08      	it	eq
    a418:	68ec      	ldreq	r4, [r5, #12]
    a41a:	e7d5      	b.n	a3c8 <_puts_r+0x24>
    a41c:	4621      	mov	r1, r4
    a41e:	4628      	mov	r0, r5
    a420:	f000 f96a 	bl	a6f8 <__swsetup_r>
    a424:	2800      	cmp	r0, #0
    a426:	d0dd      	beq.n	a3e4 <_puts_r+0x40>
    a428:	f04f 35ff 	mov.w	r5, #4294967295	; 0xffffffff
    a42c:	6e63      	ldr	r3, [r4, #100]	; 0x64
    a42e:	07da      	lsls	r2, r3, #31
    a430:	d405      	bmi.n	a43e <_puts_r+0x9a>
    a432:	89a3      	ldrh	r3, [r4, #12]
    a434:	059b      	lsls	r3, r3, #22
    a436:	d402      	bmi.n	a43e <_puts_r+0x9a>
    a438:	6da0      	ldr	r0, [r4, #88]	; 0x58
    a43a:	f000 fb80 	bl	ab3e <__retarget_lock_release_recursive>
    a43e:	4628      	mov	r0, r5
    a440:	bd70      	pop	{r4, r5, r6, pc}
    a442:	2b00      	cmp	r3, #0
    a444:	da04      	bge.n	a450 <_puts_r+0xac>
    a446:	69a2      	ldr	r2, [r4, #24]
    a448:	429a      	cmp	r2, r3
    a44a:	dc06      	bgt.n	a45a <_puts_r+0xb6>
    a44c:	290a      	cmp	r1, #10
    a44e:	d004      	beq.n	a45a <_puts_r+0xb6>
    a450:	6823      	ldr	r3, [r4, #0]
    a452:	1c5a      	adds	r2, r3, #1
    a454:	6022      	str	r2, [r4, #0]
    a456:	7019      	strb	r1, [r3, #0]
    a458:	e7c5      	b.n	a3e6 <_puts_r+0x42>
    a45a:	4622      	mov	r2, r4
    a45c:	4628      	mov	r0, r5
    a45e:	f000 f8f9 	bl	a654 <__swbuf_r>
    a462:	3001      	adds	r0, #1
    a464:	d1bf      	bne.n	a3e6 <_puts_r+0x42>
    a466:	e7df      	b.n	a428 <_puts_r+0x84>
    a468:	6823      	ldr	r3, [r4, #0]
    a46a:	250a      	movs	r5, #10
    a46c:	1c5a      	adds	r2, r3, #1
    a46e:	6022      	str	r2, [r4, #0]
    a470:	701d      	strb	r5, [r3, #0]
    a472:	e7db      	b.n	a42c <_puts_r+0x88>
    a474:	0000b9a8 	.word	0x0000b9a8
    a478:	0000b9c8 	.word	0x0000b9c8
    a47c:	0000b988 	.word	0x0000b988

0000a480 <puts>:
    a480:	4b02      	ldr	r3, [pc, #8]	; (a48c <puts+0xc>)
    a482:	4601      	mov	r1, r0
    a484:	6818      	ldr	r0, [r3, #0]
    a486:	f7ff bf8d 	b.w	a3a4 <_puts_r>
    a48a:	bf00      	nop
    a48c:	2000001c 	.word	0x2000001c

0000a490 <setbuf>:
    a490:	2900      	cmp	r1, #0
    a492:	f44f 6380 	mov.w	r3, #1024	; 0x400
    a496:	bf0c      	ite	eq
    a498:	2202      	moveq	r2, #2
    a49a:	2200      	movne	r2, #0
    a49c:	f000 b800 	b.w	a4a0 <setvbuf>

0000a4a0 <setvbuf>:
    a4a0:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
    a4a4:	461d      	mov	r5, r3
    a4a6:	4b5d      	ldr	r3, [pc, #372]	; (a61c <setvbuf+0x17c>)
    a4a8:	681f      	ldr	r7, [r3, #0]
    a4aa:	4604      	mov	r4, r0
    a4ac:	460e      	mov	r6, r1
    a4ae:	4690      	mov	r8, r2
    a4b0:	b127      	cbz	r7, a4bc <setvbuf+0x1c>
    a4b2:	69bb      	ldr	r3, [r7, #24]
    a4b4:	b913      	cbnz	r3, a4bc <setvbuf+0x1c>
    a4b6:	4638      	mov	r0, r7
    a4b8:	f000 faa2 	bl	aa00 <__sinit>
    a4bc:	4b58      	ldr	r3, [pc, #352]	; (a620 <setvbuf+0x180>)
    a4be:	429c      	cmp	r4, r3
    a4c0:	d167      	bne.n	a592 <setvbuf+0xf2>
    a4c2:	687c      	ldr	r4, [r7, #4]
    a4c4:	f1b8 0f02 	cmp.w	r8, #2
    a4c8:	d006      	beq.n	a4d8 <setvbuf+0x38>
    a4ca:	f1b8 0f01 	cmp.w	r8, #1
    a4ce:	f200 809f 	bhi.w	a610 <setvbuf+0x170>
    a4d2:	2d00      	cmp	r5, #0
    a4d4:	f2c0 809c 	blt.w	a610 <setvbuf+0x170>
    a4d8:	6e63      	ldr	r3, [r4, #100]	; 0x64
    a4da:	07db      	lsls	r3, r3, #31
    a4dc:	d405      	bmi.n	a4ea <setvbuf+0x4a>
    a4de:	89a3      	ldrh	r3, [r4, #12]
    a4e0:	0598      	lsls	r0, r3, #22
    a4e2:	d402      	bmi.n	a4ea <setvbuf+0x4a>
    a4e4:	6da0      	ldr	r0, [r4, #88]	; 0x58
    a4e6:	f000 fb29 	bl	ab3c <__retarget_lock_acquire_recursive>
    a4ea:	4621      	mov	r1, r4
    a4ec:	4638      	mov	r0, r7
    a4ee:	f000 f9f3 	bl	a8d8 <_fflush_r>
    a4f2:	6b61      	ldr	r1, [r4, #52]	; 0x34
    a4f4:	b141      	cbz	r1, a508 <setvbuf+0x68>
    a4f6:	f104 0344 	add.w	r3, r4, #68	; 0x44
    a4fa:	4299      	cmp	r1, r3
    a4fc:	d002      	beq.n	a504 <setvbuf+0x64>
    a4fe:	4638      	mov	r0, r7
    a500:	f000 fb8c 	bl	ac1c <_free_r>
    a504:	2300      	movs	r3, #0
    a506:	6363      	str	r3, [r4, #52]	; 0x34
    a508:	2300      	movs	r3, #0
    a50a:	61a3      	str	r3, [r4, #24]
    a50c:	6063      	str	r3, [r4, #4]
    a50e:	89a3      	ldrh	r3, [r4, #12]
    a510:	0619      	lsls	r1, r3, #24
    a512:	d503      	bpl.n	a51c <setvbuf+0x7c>
    a514:	6921      	ldr	r1, [r4, #16]
    a516:	4638      	mov	r0, r7
    a518:	f000 fb80 	bl	ac1c <_free_r>
    a51c:	89a3      	ldrh	r3, [r4, #12]
    a51e:	f423 634a 	bic.w	r3, r3, #3232	; 0xca0
    a522:	f023 0303 	bic.w	r3, r3, #3
    a526:	f1b8 0f02 	cmp.w	r8, #2
    a52a:	81a3      	strh	r3, [r4, #12]
    a52c:	d06c      	beq.n	a608 <setvbuf+0x168>
    a52e:	ab01      	add	r3, sp, #4
    a530:	466a      	mov	r2, sp
    a532:	4621      	mov	r1, r4
    a534:	4638      	mov	r0, r7
    a536:	f000 fb03 	bl	ab40 <__swhatbuf_r>
    a53a:	89a3      	ldrh	r3, [r4, #12]
    a53c:	4318      	orrs	r0, r3
    a53e:	81a0      	strh	r0, [r4, #12]
    a540:	2d00      	cmp	r5, #0
    a542:	d130      	bne.n	a5a6 <setvbuf+0x106>
    a544:	9d00      	ldr	r5, [sp, #0]
    a546:	4628      	mov	r0, r5
    a548:	f000 fb60 	bl	ac0c <malloc>
    a54c:	4606      	mov	r6, r0
    a54e:	2800      	cmp	r0, #0
    a550:	d155      	bne.n	a5fe <setvbuf+0x15e>
    a552:	f8dd 9000 	ldr.w	r9, [sp]
    a556:	45a9      	cmp	r9, r5
    a558:	d14a      	bne.n	a5f0 <setvbuf+0x150>
    a55a:	f04f 35ff 	mov.w	r5, #4294967295	; 0xffffffff
    a55e:	2200      	movs	r2, #0
    a560:	60a2      	str	r2, [r4, #8]
    a562:	f104 0247 	add.w	r2, r4, #71	; 0x47
    a566:	6022      	str	r2, [r4, #0]
    a568:	6122      	str	r2, [r4, #16]
    a56a:	2201      	movs	r2, #1
    a56c:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
    a570:	6162      	str	r2, [r4, #20]
    a572:	6e62      	ldr	r2, [r4, #100]	; 0x64
    a574:	f043 0302 	orr.w	r3, r3, #2
    a578:	07d2      	lsls	r2, r2, #31
    a57a:	81a3      	strh	r3, [r4, #12]
    a57c:	d405      	bmi.n	a58a <setvbuf+0xea>
    a57e:	f413 7f00 	tst.w	r3, #512	; 0x200
    a582:	d102      	bne.n	a58a <setvbuf+0xea>
    a584:	6da0      	ldr	r0, [r4, #88]	; 0x58
    a586:	f000 fada 	bl	ab3e <__retarget_lock_release_recursive>
    a58a:	4628      	mov	r0, r5
    a58c:	b003      	add	sp, #12
    a58e:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    a592:	4b24      	ldr	r3, [pc, #144]	; (a624 <setvbuf+0x184>)
    a594:	429c      	cmp	r4, r3
    a596:	d101      	bne.n	a59c <setvbuf+0xfc>
    a598:	68bc      	ldr	r4, [r7, #8]
    a59a:	e793      	b.n	a4c4 <setvbuf+0x24>
    a59c:	4b22      	ldr	r3, [pc, #136]	; (a628 <setvbuf+0x188>)
    a59e:	429c      	cmp	r4, r3
    a5a0:	bf08      	it	eq
    a5a2:	68fc      	ldreq	r4, [r7, #12]
    a5a4:	e78e      	b.n	a4c4 <setvbuf+0x24>
    a5a6:	2e00      	cmp	r6, #0
    a5a8:	d0cd      	beq.n	a546 <setvbuf+0xa6>
    a5aa:	69bb      	ldr	r3, [r7, #24]
    a5ac:	b913      	cbnz	r3, a5b4 <setvbuf+0x114>
    a5ae:	4638      	mov	r0, r7
    a5b0:	f000 fa26 	bl	aa00 <__sinit>
    a5b4:	f1b8 0f01 	cmp.w	r8, #1
    a5b8:	bf08      	it	eq
    a5ba:	89a3      	ldrheq	r3, [r4, #12]
    a5bc:	6026      	str	r6, [r4, #0]
    a5be:	bf04      	itt	eq
    a5c0:	f043 0301 	orreq.w	r3, r3, #1
    a5c4:	81a3      	strheq	r3, [r4, #12]
    a5c6:	89a2      	ldrh	r2, [r4, #12]
    a5c8:	f012 0308 	ands.w	r3, r2, #8
    a5cc:	e9c4 6504 	strd	r6, r5, [r4, #16]
    a5d0:	d01c      	beq.n	a60c <setvbuf+0x16c>
    a5d2:	07d3      	lsls	r3, r2, #31
    a5d4:	bf41      	itttt	mi
    a5d6:	2300      	movmi	r3, #0
    a5d8:	426d      	negmi	r5, r5
    a5da:	60a3      	strmi	r3, [r4, #8]
    a5dc:	61a5      	strmi	r5, [r4, #24]
    a5de:	bf58      	it	pl
    a5e0:	60a5      	strpl	r5, [r4, #8]
    a5e2:	6e65      	ldr	r5, [r4, #100]	; 0x64
    a5e4:	f015 0501 	ands.w	r5, r5, #1
    a5e8:	d115      	bne.n	a616 <setvbuf+0x176>
    a5ea:	f412 7f00 	tst.w	r2, #512	; 0x200
    a5ee:	e7c8      	b.n	a582 <setvbuf+0xe2>
    a5f0:	4648      	mov	r0, r9
    a5f2:	f000 fb0b 	bl	ac0c <malloc>
    a5f6:	4606      	mov	r6, r0
    a5f8:	2800      	cmp	r0, #0
    a5fa:	d0ae      	beq.n	a55a <setvbuf+0xba>
    a5fc:	464d      	mov	r5, r9
    a5fe:	89a3      	ldrh	r3, [r4, #12]
    a600:	f043 0380 	orr.w	r3, r3, #128	; 0x80
    a604:	81a3      	strh	r3, [r4, #12]
    a606:	e7d0      	b.n	a5aa <setvbuf+0x10a>
    a608:	2500      	movs	r5, #0
    a60a:	e7a8      	b.n	a55e <setvbuf+0xbe>
    a60c:	60a3      	str	r3, [r4, #8]
    a60e:	e7e8      	b.n	a5e2 <setvbuf+0x142>
    a610:	f04f 35ff 	mov.w	r5, #4294967295	; 0xffffffff
    a614:	e7b9      	b.n	a58a <setvbuf+0xea>
    a616:	2500      	movs	r5, #0
    a618:	e7b7      	b.n	a58a <setvbuf+0xea>
    a61a:	bf00      	nop
    a61c:	2000001c 	.word	0x2000001c
    a620:	0000b9a8 	.word	0x0000b9a8
    a624:	0000b9c8 	.word	0x0000b9c8
    a628:	0000b988 	.word	0x0000b988

0000a62c <strncmp>:
    a62c:	b510      	push	{r4, lr}
    a62e:	4603      	mov	r3, r0
    a630:	b172      	cbz	r2, a650 <strncmp+0x24>
    a632:	3901      	subs	r1, #1
    a634:	1884      	adds	r4, r0, r2
    a636:	f813 0b01 	ldrb.w	r0, [r3], #1
    a63a:	f811 2f01 	ldrb.w	r2, [r1, #1]!
    a63e:	4290      	cmp	r0, r2
    a640:	d101      	bne.n	a646 <strncmp+0x1a>
    a642:	42a3      	cmp	r3, r4
    a644:	d101      	bne.n	a64a <strncmp+0x1e>
    a646:	1a80      	subs	r0, r0, r2
    a648:	bd10      	pop	{r4, pc}
    a64a:	2800      	cmp	r0, #0
    a64c:	d1f3      	bne.n	a636 <strncmp+0xa>
    a64e:	e7fa      	b.n	a646 <strncmp+0x1a>
    a650:	4610      	mov	r0, r2
    a652:	e7f9      	b.n	a648 <strncmp+0x1c>

0000a654 <__swbuf_r>:
    a654:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    a656:	460e      	mov	r6, r1
    a658:	4614      	mov	r4, r2
    a65a:	4605      	mov	r5, r0
    a65c:	b118      	cbz	r0, a666 <__swbuf_r+0x12>
    a65e:	6983      	ldr	r3, [r0, #24]
    a660:	b90b      	cbnz	r3, a666 <__swbuf_r+0x12>
    a662:	f000 f9cd 	bl	aa00 <__sinit>
    a666:	4b21      	ldr	r3, [pc, #132]	; (a6ec <__swbuf_r+0x98>)
    a668:	429c      	cmp	r4, r3
    a66a:	d12b      	bne.n	a6c4 <__swbuf_r+0x70>
    a66c:	686c      	ldr	r4, [r5, #4]
    a66e:	69a3      	ldr	r3, [r4, #24]
    a670:	60a3      	str	r3, [r4, #8]
    a672:	89a3      	ldrh	r3, [r4, #12]
    a674:	071a      	lsls	r2, r3, #28
    a676:	d52f      	bpl.n	a6d8 <__swbuf_r+0x84>
    a678:	6923      	ldr	r3, [r4, #16]
    a67a:	b36b      	cbz	r3, a6d8 <__swbuf_r+0x84>
    a67c:	6923      	ldr	r3, [r4, #16]
    a67e:	6820      	ldr	r0, [r4, #0]
    a680:	1ac0      	subs	r0, r0, r3
    a682:	6963      	ldr	r3, [r4, #20]
    a684:	b2f6      	uxtb	r6, r6
    a686:	4283      	cmp	r3, r0
    a688:	4637      	mov	r7, r6
    a68a:	dc04      	bgt.n	a696 <__swbuf_r+0x42>
    a68c:	4621      	mov	r1, r4
    a68e:	4628      	mov	r0, r5
    a690:	f000 f922 	bl	a8d8 <_fflush_r>
    a694:	bb30      	cbnz	r0, a6e4 <__swbuf_r+0x90>
    a696:	68a3      	ldr	r3, [r4, #8]
    a698:	3b01      	subs	r3, #1
    a69a:	60a3      	str	r3, [r4, #8]
    a69c:	6823      	ldr	r3, [r4, #0]
    a69e:	1c5a      	adds	r2, r3, #1
    a6a0:	6022      	str	r2, [r4, #0]
    a6a2:	701e      	strb	r6, [r3, #0]
    a6a4:	6963      	ldr	r3, [r4, #20]
    a6a6:	3001      	adds	r0, #1
    a6a8:	4283      	cmp	r3, r0
    a6aa:	d004      	beq.n	a6b6 <__swbuf_r+0x62>
    a6ac:	89a3      	ldrh	r3, [r4, #12]
    a6ae:	07db      	lsls	r3, r3, #31
    a6b0:	d506      	bpl.n	a6c0 <__swbuf_r+0x6c>
    a6b2:	2e0a      	cmp	r6, #10
    a6b4:	d104      	bne.n	a6c0 <__swbuf_r+0x6c>
    a6b6:	4621      	mov	r1, r4
    a6b8:	4628      	mov	r0, r5
    a6ba:	f000 f90d 	bl	a8d8 <_fflush_r>
    a6be:	b988      	cbnz	r0, a6e4 <__swbuf_r+0x90>
    a6c0:	4638      	mov	r0, r7
    a6c2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    a6c4:	4b0a      	ldr	r3, [pc, #40]	; (a6f0 <__swbuf_r+0x9c>)
    a6c6:	429c      	cmp	r4, r3
    a6c8:	d101      	bne.n	a6ce <__swbuf_r+0x7a>
    a6ca:	68ac      	ldr	r4, [r5, #8]
    a6cc:	e7cf      	b.n	a66e <__swbuf_r+0x1a>
    a6ce:	4b09      	ldr	r3, [pc, #36]	; (a6f4 <__swbuf_r+0xa0>)
    a6d0:	429c      	cmp	r4, r3
    a6d2:	bf08      	it	eq
    a6d4:	68ec      	ldreq	r4, [r5, #12]
    a6d6:	e7ca      	b.n	a66e <__swbuf_r+0x1a>
    a6d8:	4621      	mov	r1, r4
    a6da:	4628      	mov	r0, r5
    a6dc:	f000 f80c 	bl	a6f8 <__swsetup_r>
    a6e0:	2800      	cmp	r0, #0
    a6e2:	d0cb      	beq.n	a67c <__swbuf_r+0x28>
    a6e4:	f04f 37ff 	mov.w	r7, #4294967295	; 0xffffffff
    a6e8:	e7ea      	b.n	a6c0 <__swbuf_r+0x6c>
    a6ea:	bf00      	nop
    a6ec:	0000b9a8 	.word	0x0000b9a8
    a6f0:	0000b9c8 	.word	0x0000b9c8
    a6f4:	0000b988 	.word	0x0000b988

0000a6f8 <__swsetup_r>:
    a6f8:	4b32      	ldr	r3, [pc, #200]	; (a7c4 <__swsetup_r+0xcc>)
    a6fa:	b570      	push	{r4, r5, r6, lr}
    a6fc:	681d      	ldr	r5, [r3, #0]
    a6fe:	4606      	mov	r6, r0
    a700:	460c      	mov	r4, r1
    a702:	b125      	cbz	r5, a70e <__swsetup_r+0x16>
    a704:	69ab      	ldr	r3, [r5, #24]
    a706:	b913      	cbnz	r3, a70e <__swsetup_r+0x16>
    a708:	4628      	mov	r0, r5
    a70a:	f000 f979 	bl	aa00 <__sinit>
    a70e:	4b2e      	ldr	r3, [pc, #184]	; (a7c8 <__swsetup_r+0xd0>)
    a710:	429c      	cmp	r4, r3
    a712:	d10f      	bne.n	a734 <__swsetup_r+0x3c>
    a714:	686c      	ldr	r4, [r5, #4]
    a716:	89a3      	ldrh	r3, [r4, #12]
    a718:	f9b4 200c 	ldrsh.w	r2, [r4, #12]
    a71c:	0719      	lsls	r1, r3, #28
    a71e:	d42c      	bmi.n	a77a <__swsetup_r+0x82>
    a720:	06dd      	lsls	r5, r3, #27
    a722:	d411      	bmi.n	a748 <__swsetup_r+0x50>
    a724:	2309      	movs	r3, #9
    a726:	6033      	str	r3, [r6, #0]
    a728:	f042 0340 	orr.w	r3, r2, #64	; 0x40
    a72c:	81a3      	strh	r3, [r4, #12]
    a72e:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    a732:	e03e      	b.n	a7b2 <__swsetup_r+0xba>
    a734:	4b25      	ldr	r3, [pc, #148]	; (a7cc <__swsetup_r+0xd4>)
    a736:	429c      	cmp	r4, r3
    a738:	d101      	bne.n	a73e <__swsetup_r+0x46>
    a73a:	68ac      	ldr	r4, [r5, #8]
    a73c:	e7eb      	b.n	a716 <__swsetup_r+0x1e>
    a73e:	4b24      	ldr	r3, [pc, #144]	; (a7d0 <__swsetup_r+0xd8>)
    a740:	429c      	cmp	r4, r3
    a742:	bf08      	it	eq
    a744:	68ec      	ldreq	r4, [r5, #12]
    a746:	e7e6      	b.n	a716 <__swsetup_r+0x1e>
    a748:	0758      	lsls	r0, r3, #29
    a74a:	d512      	bpl.n	a772 <__swsetup_r+0x7a>
    a74c:	6b61      	ldr	r1, [r4, #52]	; 0x34
    a74e:	b141      	cbz	r1, a762 <__swsetup_r+0x6a>
    a750:	f104 0344 	add.w	r3, r4, #68	; 0x44
    a754:	4299      	cmp	r1, r3
    a756:	d002      	beq.n	a75e <__swsetup_r+0x66>
    a758:	4630      	mov	r0, r6
    a75a:	f000 fa5f 	bl	ac1c <_free_r>
    a75e:	2300      	movs	r3, #0
    a760:	6363      	str	r3, [r4, #52]	; 0x34
    a762:	89a3      	ldrh	r3, [r4, #12]
    a764:	f023 0324 	bic.w	r3, r3, #36	; 0x24
    a768:	81a3      	strh	r3, [r4, #12]
    a76a:	2300      	movs	r3, #0
    a76c:	6063      	str	r3, [r4, #4]
    a76e:	6923      	ldr	r3, [r4, #16]
    a770:	6023      	str	r3, [r4, #0]
    a772:	89a3      	ldrh	r3, [r4, #12]
    a774:	f043 0308 	orr.w	r3, r3, #8
    a778:	81a3      	strh	r3, [r4, #12]
    a77a:	6923      	ldr	r3, [r4, #16]
    a77c:	b94b      	cbnz	r3, a792 <__swsetup_r+0x9a>
    a77e:	89a3      	ldrh	r3, [r4, #12]
    a780:	f403 7320 	and.w	r3, r3, #640	; 0x280
    a784:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
    a788:	d003      	beq.n	a792 <__swsetup_r+0x9a>
    a78a:	4621      	mov	r1, r4
    a78c:	4630      	mov	r0, r6
    a78e:	f000 f9fd 	bl	ab8c <__smakebuf_r>
    a792:	89a0      	ldrh	r0, [r4, #12]
    a794:	f9b4 200c 	ldrsh.w	r2, [r4, #12]
    a798:	f010 0301 	ands.w	r3, r0, #1
    a79c:	d00a      	beq.n	a7b4 <__swsetup_r+0xbc>
    a79e:	2300      	movs	r3, #0
    a7a0:	60a3      	str	r3, [r4, #8]
    a7a2:	6963      	ldr	r3, [r4, #20]
    a7a4:	425b      	negs	r3, r3
    a7a6:	61a3      	str	r3, [r4, #24]
    a7a8:	6923      	ldr	r3, [r4, #16]
    a7aa:	b943      	cbnz	r3, a7be <__swsetup_r+0xc6>
    a7ac:	f010 0080 	ands.w	r0, r0, #128	; 0x80
    a7b0:	d1ba      	bne.n	a728 <__swsetup_r+0x30>
    a7b2:	bd70      	pop	{r4, r5, r6, pc}
    a7b4:	0781      	lsls	r1, r0, #30
    a7b6:	bf58      	it	pl
    a7b8:	6963      	ldrpl	r3, [r4, #20]
    a7ba:	60a3      	str	r3, [r4, #8]
    a7bc:	e7f4      	b.n	a7a8 <__swsetup_r+0xb0>
    a7be:	2000      	movs	r0, #0
    a7c0:	e7f7      	b.n	a7b2 <__swsetup_r+0xba>
    a7c2:	bf00      	nop
    a7c4:	2000001c 	.word	0x2000001c
    a7c8:	0000b9a8 	.word	0x0000b9a8
    a7cc:	0000b9c8 	.word	0x0000b9c8
    a7d0:	0000b988 	.word	0x0000b988

0000a7d4 <__sflush_r>:
    a7d4:	898a      	ldrh	r2, [r1, #12]
    a7d6:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    a7d8:	4605      	mov	r5, r0
    a7da:	0710      	lsls	r0, r2, #28
    a7dc:	460c      	mov	r4, r1
    a7de:	d457      	bmi.n	a890 <__sflush_r+0xbc>
    a7e0:	684b      	ldr	r3, [r1, #4]
    a7e2:	2b00      	cmp	r3, #0
    a7e4:	dc04      	bgt.n	a7f0 <__sflush_r+0x1c>
    a7e6:	6c0b      	ldr	r3, [r1, #64]	; 0x40
    a7e8:	2b00      	cmp	r3, #0
    a7ea:	dc01      	bgt.n	a7f0 <__sflush_r+0x1c>
    a7ec:	2000      	movs	r0, #0
    a7ee:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    a7f0:	6ae6      	ldr	r6, [r4, #44]	; 0x2c
    a7f2:	2e00      	cmp	r6, #0
    a7f4:	d0fa      	beq.n	a7ec <__sflush_r+0x18>
    a7f6:	2300      	movs	r3, #0
    a7f8:	f412 5280 	ands.w	r2, r2, #4096	; 0x1000
    a7fc:	682f      	ldr	r7, [r5, #0]
    a7fe:	602b      	str	r3, [r5, #0]
    a800:	d032      	beq.n	a868 <__sflush_r+0x94>
    a802:	6d60      	ldr	r0, [r4, #84]	; 0x54
    a804:	89a3      	ldrh	r3, [r4, #12]
    a806:	075a      	lsls	r2, r3, #29
    a808:	d505      	bpl.n	a816 <__sflush_r+0x42>
    a80a:	6863      	ldr	r3, [r4, #4]
    a80c:	1ac0      	subs	r0, r0, r3
    a80e:	6b63      	ldr	r3, [r4, #52]	; 0x34
    a810:	b10b      	cbz	r3, a816 <__sflush_r+0x42>
    a812:	6c23      	ldr	r3, [r4, #64]	; 0x40
    a814:	1ac0      	subs	r0, r0, r3
    a816:	2300      	movs	r3, #0
    a818:	4602      	mov	r2, r0
    a81a:	6ae6      	ldr	r6, [r4, #44]	; 0x2c
    a81c:	6a21      	ldr	r1, [r4, #32]
    a81e:	4628      	mov	r0, r5
    a820:	47b0      	blx	r6
    a822:	1c43      	adds	r3, r0, #1
    a824:	89a3      	ldrh	r3, [r4, #12]
    a826:	d106      	bne.n	a836 <__sflush_r+0x62>
    a828:	6829      	ldr	r1, [r5, #0]
    a82a:	291d      	cmp	r1, #29
    a82c:	d82c      	bhi.n	a888 <__sflush_r+0xb4>
    a82e:	4a29      	ldr	r2, [pc, #164]	; (a8d4 <__sflush_r+0x100>)
    a830:	40ca      	lsrs	r2, r1
    a832:	07d6      	lsls	r6, r2, #31
    a834:	d528      	bpl.n	a888 <__sflush_r+0xb4>
    a836:	2200      	movs	r2, #0
    a838:	6062      	str	r2, [r4, #4]
    a83a:	04d9      	lsls	r1, r3, #19
    a83c:	6922      	ldr	r2, [r4, #16]
    a83e:	6022      	str	r2, [r4, #0]
    a840:	d504      	bpl.n	a84c <__sflush_r+0x78>
    a842:	1c42      	adds	r2, r0, #1
    a844:	d101      	bne.n	a84a <__sflush_r+0x76>
    a846:	682b      	ldr	r3, [r5, #0]
    a848:	b903      	cbnz	r3, a84c <__sflush_r+0x78>
    a84a:	6560      	str	r0, [r4, #84]	; 0x54
    a84c:	6b61      	ldr	r1, [r4, #52]	; 0x34
    a84e:	602f      	str	r7, [r5, #0]
    a850:	2900      	cmp	r1, #0
    a852:	d0cb      	beq.n	a7ec <__sflush_r+0x18>
    a854:	f104 0344 	add.w	r3, r4, #68	; 0x44
    a858:	4299      	cmp	r1, r3
    a85a:	d002      	beq.n	a862 <__sflush_r+0x8e>
    a85c:	4628      	mov	r0, r5
    a85e:	f000 f9dd 	bl	ac1c <_free_r>
    a862:	2000      	movs	r0, #0
    a864:	6360      	str	r0, [r4, #52]	; 0x34
    a866:	e7c2      	b.n	a7ee <__sflush_r+0x1a>
    a868:	6a21      	ldr	r1, [r4, #32]
    a86a:	2301      	movs	r3, #1
    a86c:	4628      	mov	r0, r5
    a86e:	47b0      	blx	r6
    a870:	1c41      	adds	r1, r0, #1
    a872:	d1c7      	bne.n	a804 <__sflush_r+0x30>
    a874:	682b      	ldr	r3, [r5, #0]
    a876:	2b00      	cmp	r3, #0
    a878:	d0c4      	beq.n	a804 <__sflush_r+0x30>
    a87a:	2b1d      	cmp	r3, #29
    a87c:	d001      	beq.n	a882 <__sflush_r+0xae>
    a87e:	2b16      	cmp	r3, #22
    a880:	d101      	bne.n	a886 <__sflush_r+0xb2>
    a882:	602f      	str	r7, [r5, #0]
    a884:	e7b2      	b.n	a7ec <__sflush_r+0x18>
    a886:	89a3      	ldrh	r3, [r4, #12]
    a888:	f043 0340 	orr.w	r3, r3, #64	; 0x40
    a88c:	81a3      	strh	r3, [r4, #12]
    a88e:	e7ae      	b.n	a7ee <__sflush_r+0x1a>
    a890:	690f      	ldr	r7, [r1, #16]
    a892:	2f00      	cmp	r7, #0
    a894:	d0aa      	beq.n	a7ec <__sflush_r+0x18>
    a896:	0793      	lsls	r3, r2, #30
    a898:	680e      	ldr	r6, [r1, #0]
    a89a:	bf08      	it	eq
    a89c:	694b      	ldreq	r3, [r1, #20]
    a89e:	600f      	str	r7, [r1, #0]
    a8a0:	bf18      	it	ne
    a8a2:	2300      	movne	r3, #0
    a8a4:	1bf6      	subs	r6, r6, r7
    a8a6:	608b      	str	r3, [r1, #8]
    a8a8:	2e00      	cmp	r6, #0
    a8aa:	dd9f      	ble.n	a7ec <__sflush_r+0x18>
    a8ac:	6a21      	ldr	r1, [r4, #32]
    a8ae:	f8d4 c028 	ldr.w	ip, [r4, #40]	; 0x28
    a8b2:	4633      	mov	r3, r6
    a8b4:	463a      	mov	r2, r7
    a8b6:	4628      	mov	r0, r5
    a8b8:	47e0      	blx	ip
    a8ba:	2800      	cmp	r0, #0
    a8bc:	dc06      	bgt.n	a8cc <__sflush_r+0xf8>
    a8be:	89a3      	ldrh	r3, [r4, #12]
    a8c0:	f043 0340 	orr.w	r3, r3, #64	; 0x40
    a8c4:	81a3      	strh	r3, [r4, #12]
    a8c6:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    a8ca:	e790      	b.n	a7ee <__sflush_r+0x1a>
    a8cc:	4407      	add	r7, r0
    a8ce:	1a36      	subs	r6, r6, r0
    a8d0:	e7ea      	b.n	a8a8 <__sflush_r+0xd4>
    a8d2:	bf00      	nop
    a8d4:	20400001 	.word	0x20400001

0000a8d8 <_fflush_r>:
    a8d8:	b538      	push	{r3, r4, r5, lr}
    a8da:	690b      	ldr	r3, [r1, #16]
    a8dc:	4605      	mov	r5, r0
    a8de:	460c      	mov	r4, r1
    a8e0:	b913      	cbnz	r3, a8e8 <_fflush_r+0x10>
    a8e2:	2500      	movs	r5, #0
    a8e4:	4628      	mov	r0, r5
    a8e6:	bd38      	pop	{r3, r4, r5, pc}
    a8e8:	b118      	cbz	r0, a8f2 <_fflush_r+0x1a>
    a8ea:	6983      	ldr	r3, [r0, #24]
    a8ec:	b90b      	cbnz	r3, a8f2 <_fflush_r+0x1a>
    a8ee:	f000 f887 	bl	aa00 <__sinit>
    a8f2:	4b14      	ldr	r3, [pc, #80]	; (a944 <_fflush_r+0x6c>)
    a8f4:	429c      	cmp	r4, r3
    a8f6:	d11b      	bne.n	a930 <_fflush_r+0x58>
    a8f8:	686c      	ldr	r4, [r5, #4]
    a8fa:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
    a8fe:	2b00      	cmp	r3, #0
    a900:	d0ef      	beq.n	a8e2 <_fflush_r+0xa>
    a902:	6e62      	ldr	r2, [r4, #100]	; 0x64
    a904:	07d0      	lsls	r0, r2, #31
    a906:	d404      	bmi.n	a912 <_fflush_r+0x3a>
    a908:	0599      	lsls	r1, r3, #22
    a90a:	d402      	bmi.n	a912 <_fflush_r+0x3a>
    a90c:	6da0      	ldr	r0, [r4, #88]	; 0x58
    a90e:	f000 f915 	bl	ab3c <__retarget_lock_acquire_recursive>
    a912:	4628      	mov	r0, r5
    a914:	4621      	mov	r1, r4
    a916:	f7ff ff5d 	bl	a7d4 <__sflush_r>
    a91a:	6e63      	ldr	r3, [r4, #100]	; 0x64
    a91c:	07da      	lsls	r2, r3, #31
    a91e:	4605      	mov	r5, r0
    a920:	d4e0      	bmi.n	a8e4 <_fflush_r+0xc>
    a922:	89a3      	ldrh	r3, [r4, #12]
    a924:	059b      	lsls	r3, r3, #22
    a926:	d4dd      	bmi.n	a8e4 <_fflush_r+0xc>
    a928:	6da0      	ldr	r0, [r4, #88]	; 0x58
    a92a:	f000 f908 	bl	ab3e <__retarget_lock_release_recursive>
    a92e:	e7d9      	b.n	a8e4 <_fflush_r+0xc>
    a930:	4b05      	ldr	r3, [pc, #20]	; (a948 <_fflush_r+0x70>)
    a932:	429c      	cmp	r4, r3
    a934:	d101      	bne.n	a93a <_fflush_r+0x62>
    a936:	68ac      	ldr	r4, [r5, #8]
    a938:	e7df      	b.n	a8fa <_fflush_r+0x22>
    a93a:	4b04      	ldr	r3, [pc, #16]	; (a94c <_fflush_r+0x74>)
    a93c:	429c      	cmp	r4, r3
    a93e:	bf08      	it	eq
    a940:	68ec      	ldreq	r4, [r5, #12]
    a942:	e7da      	b.n	a8fa <_fflush_r+0x22>
    a944:	0000b9a8 	.word	0x0000b9a8
    a948:	0000b9c8 	.word	0x0000b9c8
    a94c:	0000b988 	.word	0x0000b988

0000a950 <std>:
    a950:	2300      	movs	r3, #0
    a952:	b510      	push	{r4, lr}
    a954:	4604      	mov	r4, r0
    a956:	e9c0 3300 	strd	r3, r3, [r0]
    a95a:	e9c0 3304 	strd	r3, r3, [r0, #16]
    a95e:	6083      	str	r3, [r0, #8]
    a960:	8181      	strh	r1, [r0, #12]
    a962:	6643      	str	r3, [r0, #100]	; 0x64
    a964:	81c2      	strh	r2, [r0, #14]
    a966:	6183      	str	r3, [r0, #24]
    a968:	4619      	mov	r1, r3
    a96a:	2208      	movs	r2, #8
    a96c:	305c      	adds	r0, #92	; 0x5c
    a96e:	f7ff fcf9 	bl	a364 <memset>
    a972:	4b05      	ldr	r3, [pc, #20]	; (a988 <std+0x38>)
    a974:	6263      	str	r3, [r4, #36]	; 0x24
    a976:	4b05      	ldr	r3, [pc, #20]	; (a98c <std+0x3c>)
    a978:	62a3      	str	r3, [r4, #40]	; 0x28
    a97a:	4b05      	ldr	r3, [pc, #20]	; (a990 <std+0x40>)
    a97c:	62e3      	str	r3, [r4, #44]	; 0x2c
    a97e:	4b05      	ldr	r3, [pc, #20]	; (a994 <std+0x44>)
    a980:	6224      	str	r4, [r4, #32]
    a982:	6323      	str	r3, [r4, #48]	; 0x30
    a984:	bd10      	pop	{r4, pc}
    a986:	bf00      	nop
    a988:	0000b3d1 	.word	0x0000b3d1
    a98c:	0000b3f3 	.word	0x0000b3f3
    a990:	0000b42b 	.word	0x0000b42b
    a994:	0000b44f 	.word	0x0000b44f

0000a998 <_cleanup_r>:
    a998:	4901      	ldr	r1, [pc, #4]	; (a9a0 <_cleanup_r+0x8>)
    a99a:	f000 b8af 	b.w	aafc <_fwalk_reent>
    a99e:	bf00      	nop
    a9a0:	0000a8d9 	.word	0x0000a8d9

0000a9a4 <__sfmoreglue>:
    a9a4:	b570      	push	{r4, r5, r6, lr}
    a9a6:	2268      	movs	r2, #104	; 0x68
    a9a8:	1e4d      	subs	r5, r1, #1
    a9aa:	4355      	muls	r5, r2
    a9ac:	460e      	mov	r6, r1
    a9ae:	f105 0174 	add.w	r1, r5, #116	; 0x74
    a9b2:	f000 f99d 	bl	acf0 <_malloc_r>
    a9b6:	4604      	mov	r4, r0
    a9b8:	b140      	cbz	r0, a9cc <__sfmoreglue+0x28>
    a9ba:	2100      	movs	r1, #0
    a9bc:	e9c0 1600 	strd	r1, r6, [r0]
    a9c0:	300c      	adds	r0, #12
    a9c2:	60a0      	str	r0, [r4, #8]
    a9c4:	f105 0268 	add.w	r2, r5, #104	; 0x68
    a9c8:	f7ff fccc 	bl	a364 <memset>
    a9cc:	4620      	mov	r0, r4
    a9ce:	bd70      	pop	{r4, r5, r6, pc}

0000a9d0 <__sfp_lock_acquire>:
    a9d0:	4801      	ldr	r0, [pc, #4]	; (a9d8 <__sfp_lock_acquire+0x8>)
    a9d2:	f000 b8b3 	b.w	ab3c <__retarget_lock_acquire_recursive>
    a9d6:	bf00      	nop
    a9d8:	200163fd 	.word	0x200163fd

0000a9dc <__sfp_lock_release>:
    a9dc:	4801      	ldr	r0, [pc, #4]	; (a9e4 <__sfp_lock_release+0x8>)
    a9de:	f000 b8ae 	b.w	ab3e <__retarget_lock_release_recursive>
    a9e2:	bf00      	nop
    a9e4:	200163fd 	.word	0x200163fd

0000a9e8 <__sinit_lock_acquire>:
    a9e8:	4801      	ldr	r0, [pc, #4]	; (a9f0 <__sinit_lock_acquire+0x8>)
    a9ea:	f000 b8a7 	b.w	ab3c <__retarget_lock_acquire_recursive>
    a9ee:	bf00      	nop
    a9f0:	200163fe 	.word	0x200163fe

0000a9f4 <__sinit_lock_release>:
    a9f4:	4801      	ldr	r0, [pc, #4]	; (a9fc <__sinit_lock_release+0x8>)
    a9f6:	f000 b8a2 	b.w	ab3e <__retarget_lock_release_recursive>
    a9fa:	bf00      	nop
    a9fc:	200163fe 	.word	0x200163fe

0000aa00 <__sinit>:
    aa00:	b510      	push	{r4, lr}
    aa02:	4604      	mov	r4, r0
    aa04:	f7ff fff0 	bl	a9e8 <__sinit_lock_acquire>
    aa08:	69a3      	ldr	r3, [r4, #24]
    aa0a:	b11b      	cbz	r3, aa14 <__sinit+0x14>
    aa0c:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    aa10:	f7ff bff0 	b.w	a9f4 <__sinit_lock_release>
    aa14:	e9c4 3312 	strd	r3, r3, [r4, #72]	; 0x48
    aa18:	6523      	str	r3, [r4, #80]	; 0x50
    aa1a:	4b13      	ldr	r3, [pc, #76]	; (aa68 <__sinit+0x68>)
    aa1c:	4a13      	ldr	r2, [pc, #76]	; (aa6c <__sinit+0x6c>)
    aa1e:	681b      	ldr	r3, [r3, #0]
    aa20:	62a2      	str	r2, [r4, #40]	; 0x28
    aa22:	42a3      	cmp	r3, r4
    aa24:	bf04      	itt	eq
    aa26:	2301      	moveq	r3, #1
    aa28:	61a3      	streq	r3, [r4, #24]
    aa2a:	4620      	mov	r0, r4
    aa2c:	f000 f820 	bl	aa70 <__sfp>
    aa30:	6060      	str	r0, [r4, #4]
    aa32:	4620      	mov	r0, r4
    aa34:	f000 f81c 	bl	aa70 <__sfp>
    aa38:	60a0      	str	r0, [r4, #8]
    aa3a:	4620      	mov	r0, r4
    aa3c:	f000 f818 	bl	aa70 <__sfp>
    aa40:	2200      	movs	r2, #0
    aa42:	60e0      	str	r0, [r4, #12]
    aa44:	2104      	movs	r1, #4
    aa46:	6860      	ldr	r0, [r4, #4]
    aa48:	f7ff ff82 	bl	a950 <std>
    aa4c:	68a0      	ldr	r0, [r4, #8]
    aa4e:	2201      	movs	r2, #1
    aa50:	2109      	movs	r1, #9
    aa52:	f7ff ff7d 	bl	a950 <std>
    aa56:	68e0      	ldr	r0, [r4, #12]
    aa58:	2202      	movs	r2, #2
    aa5a:	2112      	movs	r1, #18
    aa5c:	f7ff ff78 	bl	a950 <std>
    aa60:	2301      	movs	r3, #1
    aa62:	61a3      	str	r3, [r4, #24]
    aa64:	e7d2      	b.n	aa0c <__sinit+0xc>
    aa66:	bf00      	nop
    aa68:	0000b984 	.word	0x0000b984
    aa6c:	0000a999 	.word	0x0000a999

0000aa70 <__sfp>:
    aa70:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    aa72:	4607      	mov	r7, r0
    aa74:	f7ff ffac 	bl	a9d0 <__sfp_lock_acquire>
    aa78:	4b1e      	ldr	r3, [pc, #120]	; (aaf4 <__sfp+0x84>)
    aa7a:	681e      	ldr	r6, [r3, #0]
    aa7c:	69b3      	ldr	r3, [r6, #24]
    aa7e:	b913      	cbnz	r3, aa86 <__sfp+0x16>
    aa80:	4630      	mov	r0, r6
    aa82:	f7ff ffbd 	bl	aa00 <__sinit>
    aa86:	3648      	adds	r6, #72	; 0x48
    aa88:	e9d6 3401 	ldrd	r3, r4, [r6, #4]
    aa8c:	3b01      	subs	r3, #1
    aa8e:	d503      	bpl.n	aa98 <__sfp+0x28>
    aa90:	6833      	ldr	r3, [r6, #0]
    aa92:	b30b      	cbz	r3, aad8 <__sfp+0x68>
    aa94:	6836      	ldr	r6, [r6, #0]
    aa96:	e7f7      	b.n	aa88 <__sfp+0x18>
    aa98:	f9b4 500c 	ldrsh.w	r5, [r4, #12]
    aa9c:	b9d5      	cbnz	r5, aad4 <__sfp+0x64>
    aa9e:	4b16      	ldr	r3, [pc, #88]	; (aaf8 <__sfp+0x88>)
    aaa0:	60e3      	str	r3, [r4, #12]
    aaa2:	f104 0058 	add.w	r0, r4, #88	; 0x58
    aaa6:	6665      	str	r5, [r4, #100]	; 0x64
    aaa8:	f000 f847 	bl	ab3a <__retarget_lock_init_recursive>
    aaac:	f7ff ff96 	bl	a9dc <__sfp_lock_release>
    aab0:	e9c4 5501 	strd	r5, r5, [r4, #4]
    aab4:	e9c4 5504 	strd	r5, r5, [r4, #16]
    aab8:	6025      	str	r5, [r4, #0]
    aaba:	61a5      	str	r5, [r4, #24]
    aabc:	2208      	movs	r2, #8
    aabe:	4629      	mov	r1, r5
    aac0:	f104 005c 	add.w	r0, r4, #92	; 0x5c
    aac4:	f7ff fc4e 	bl	a364 <memset>
    aac8:	e9c4 550d 	strd	r5, r5, [r4, #52]	; 0x34
    aacc:	e9c4 5512 	strd	r5, r5, [r4, #72]	; 0x48
    aad0:	4620      	mov	r0, r4
    aad2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    aad4:	3468      	adds	r4, #104	; 0x68
    aad6:	e7d9      	b.n	aa8c <__sfp+0x1c>
    aad8:	2104      	movs	r1, #4
    aada:	4638      	mov	r0, r7
    aadc:	f7ff ff62 	bl	a9a4 <__sfmoreglue>
    aae0:	4604      	mov	r4, r0
    aae2:	6030      	str	r0, [r6, #0]
    aae4:	2800      	cmp	r0, #0
    aae6:	d1d5      	bne.n	aa94 <__sfp+0x24>
    aae8:	f7ff ff78 	bl	a9dc <__sfp_lock_release>
    aaec:	230c      	movs	r3, #12
    aaee:	603b      	str	r3, [r7, #0]
    aaf0:	e7ee      	b.n	aad0 <__sfp+0x60>
    aaf2:	bf00      	nop
    aaf4:	0000b984 	.word	0x0000b984
    aaf8:	ffff0001 	.word	0xffff0001

0000aafc <_fwalk_reent>:
    aafc:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    ab00:	4606      	mov	r6, r0
    ab02:	4688      	mov	r8, r1
    ab04:	f100 0448 	add.w	r4, r0, #72	; 0x48
    ab08:	2700      	movs	r7, #0
    ab0a:	e9d4 9501 	ldrd	r9, r5, [r4, #4]
    ab0e:	f1b9 0901 	subs.w	r9, r9, #1
    ab12:	d505      	bpl.n	ab20 <_fwalk_reent+0x24>
    ab14:	6824      	ldr	r4, [r4, #0]
    ab16:	2c00      	cmp	r4, #0
    ab18:	d1f7      	bne.n	ab0a <_fwalk_reent+0xe>
    ab1a:	4638      	mov	r0, r7
    ab1c:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    ab20:	89ab      	ldrh	r3, [r5, #12]
    ab22:	2b01      	cmp	r3, #1
    ab24:	d907      	bls.n	ab36 <_fwalk_reent+0x3a>
    ab26:	f9b5 300e 	ldrsh.w	r3, [r5, #14]
    ab2a:	3301      	adds	r3, #1
    ab2c:	d003      	beq.n	ab36 <_fwalk_reent+0x3a>
    ab2e:	4629      	mov	r1, r5
    ab30:	4630      	mov	r0, r6
    ab32:	47c0      	blx	r8
    ab34:	4307      	orrs	r7, r0
    ab36:	3568      	adds	r5, #104	; 0x68
    ab38:	e7e9      	b.n	ab0e <_fwalk_reent+0x12>

0000ab3a <__retarget_lock_init_recursive>:
    ab3a:	4770      	bx	lr

0000ab3c <__retarget_lock_acquire_recursive>:
    ab3c:	4770      	bx	lr

0000ab3e <__retarget_lock_release_recursive>:
    ab3e:	4770      	bx	lr

0000ab40 <__swhatbuf_r>:
    ab40:	b570      	push	{r4, r5, r6, lr}
    ab42:	460e      	mov	r6, r1
    ab44:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
    ab48:	2900      	cmp	r1, #0
    ab4a:	b096      	sub	sp, #88	; 0x58
    ab4c:	4614      	mov	r4, r2
    ab4e:	461d      	mov	r5, r3
    ab50:	da08      	bge.n	ab64 <__swhatbuf_r+0x24>
    ab52:	f9b6 300c 	ldrsh.w	r3, [r6, #12]
    ab56:	2200      	movs	r2, #0
    ab58:	602a      	str	r2, [r5, #0]
    ab5a:	061a      	lsls	r2, r3, #24
    ab5c:	d410      	bmi.n	ab80 <__swhatbuf_r+0x40>
    ab5e:	f44f 6380 	mov.w	r3, #1024	; 0x400
    ab62:	e00e      	b.n	ab82 <__swhatbuf_r+0x42>
    ab64:	466a      	mov	r2, sp
    ab66:	f000 fc99 	bl	b49c <_fstat_r>
    ab6a:	2800      	cmp	r0, #0
    ab6c:	dbf1      	blt.n	ab52 <__swhatbuf_r+0x12>
    ab6e:	9a01      	ldr	r2, [sp, #4]
    ab70:	f402 4270 	and.w	r2, r2, #61440	; 0xf000
    ab74:	f5a2 5300 	sub.w	r3, r2, #8192	; 0x2000
    ab78:	425a      	negs	r2, r3
    ab7a:	415a      	adcs	r2, r3
    ab7c:	602a      	str	r2, [r5, #0]
    ab7e:	e7ee      	b.n	ab5e <__swhatbuf_r+0x1e>
    ab80:	2340      	movs	r3, #64	; 0x40
    ab82:	2000      	movs	r0, #0
    ab84:	6023      	str	r3, [r4, #0]
    ab86:	b016      	add	sp, #88	; 0x58
    ab88:	bd70      	pop	{r4, r5, r6, pc}
	...

0000ab8c <__smakebuf_r>:
    ab8c:	898b      	ldrh	r3, [r1, #12]
    ab8e:	b573      	push	{r0, r1, r4, r5, r6, lr}
    ab90:	079d      	lsls	r5, r3, #30
    ab92:	4606      	mov	r6, r0
    ab94:	460c      	mov	r4, r1
    ab96:	d507      	bpl.n	aba8 <__smakebuf_r+0x1c>
    ab98:	f104 0347 	add.w	r3, r4, #71	; 0x47
    ab9c:	6023      	str	r3, [r4, #0]
    ab9e:	6123      	str	r3, [r4, #16]
    aba0:	2301      	movs	r3, #1
    aba2:	6163      	str	r3, [r4, #20]
    aba4:	b002      	add	sp, #8
    aba6:	bd70      	pop	{r4, r5, r6, pc}
    aba8:	ab01      	add	r3, sp, #4
    abaa:	466a      	mov	r2, sp
    abac:	f7ff ffc8 	bl	ab40 <__swhatbuf_r>
    abb0:	9900      	ldr	r1, [sp, #0]
    abb2:	4605      	mov	r5, r0
    abb4:	4630      	mov	r0, r6
    abb6:	f000 f89b 	bl	acf0 <_malloc_r>
    abba:	b948      	cbnz	r0, abd0 <__smakebuf_r+0x44>
    abbc:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
    abc0:	059a      	lsls	r2, r3, #22
    abc2:	d4ef      	bmi.n	aba4 <__smakebuf_r+0x18>
    abc4:	f023 0303 	bic.w	r3, r3, #3
    abc8:	f043 0302 	orr.w	r3, r3, #2
    abcc:	81a3      	strh	r3, [r4, #12]
    abce:	e7e3      	b.n	ab98 <__smakebuf_r+0xc>
    abd0:	4b0d      	ldr	r3, [pc, #52]	; (ac08 <__smakebuf_r+0x7c>)
    abd2:	62b3      	str	r3, [r6, #40]	; 0x28
    abd4:	89a3      	ldrh	r3, [r4, #12]
    abd6:	6020      	str	r0, [r4, #0]
    abd8:	f043 0380 	orr.w	r3, r3, #128	; 0x80
    abdc:	81a3      	strh	r3, [r4, #12]
    abde:	9b00      	ldr	r3, [sp, #0]
    abe0:	6163      	str	r3, [r4, #20]
    abe2:	9b01      	ldr	r3, [sp, #4]
    abe4:	6120      	str	r0, [r4, #16]
    abe6:	b15b      	cbz	r3, ac00 <__smakebuf_r+0x74>
    abe8:	f9b4 100e 	ldrsh.w	r1, [r4, #14]
    abec:	4630      	mov	r0, r6
    abee:	f000 fc67 	bl	b4c0 <_isatty_r>
    abf2:	b128      	cbz	r0, ac00 <__smakebuf_r+0x74>
    abf4:	89a3      	ldrh	r3, [r4, #12]
    abf6:	f023 0303 	bic.w	r3, r3, #3
    abfa:	f043 0301 	orr.w	r3, r3, #1
    abfe:	81a3      	strh	r3, [r4, #12]
    ac00:	89a0      	ldrh	r0, [r4, #12]
    ac02:	4305      	orrs	r5, r0
    ac04:	81a5      	strh	r5, [r4, #12]
    ac06:	e7cd      	b.n	aba4 <__smakebuf_r+0x18>
    ac08:	0000a999 	.word	0x0000a999

0000ac0c <malloc>:
    ac0c:	4b02      	ldr	r3, [pc, #8]	; (ac18 <malloc+0xc>)
    ac0e:	4601      	mov	r1, r0
    ac10:	6818      	ldr	r0, [r3, #0]
    ac12:	f000 b86d 	b.w	acf0 <_malloc_r>
    ac16:	bf00      	nop
    ac18:	2000001c 	.word	0x2000001c

0000ac1c <_free_r>:
    ac1c:	b538      	push	{r3, r4, r5, lr}
    ac1e:	4605      	mov	r5, r0
    ac20:	2900      	cmp	r1, #0
    ac22:	d041      	beq.n	aca8 <_free_r+0x8c>
    ac24:	f851 3c04 	ldr.w	r3, [r1, #-4]
    ac28:	1f0c      	subs	r4, r1, #4
    ac2a:	2b00      	cmp	r3, #0
    ac2c:	bfb8      	it	lt
    ac2e:	18e4      	addlt	r4, r4, r3
    ac30:	f000 fcbe 	bl	b5b0 <__malloc_lock>
    ac34:	4a1d      	ldr	r2, [pc, #116]	; (acac <_free_r+0x90>)
    ac36:	6813      	ldr	r3, [r2, #0]
    ac38:	b933      	cbnz	r3, ac48 <_free_r+0x2c>
    ac3a:	6063      	str	r3, [r4, #4]
    ac3c:	6014      	str	r4, [r2, #0]
    ac3e:	4628      	mov	r0, r5
    ac40:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
    ac44:	f000 bcba 	b.w	b5bc <__malloc_unlock>
    ac48:	42a3      	cmp	r3, r4
    ac4a:	d908      	bls.n	ac5e <_free_r+0x42>
    ac4c:	6820      	ldr	r0, [r4, #0]
    ac4e:	1821      	adds	r1, r4, r0
    ac50:	428b      	cmp	r3, r1
    ac52:	bf01      	itttt	eq
    ac54:	6819      	ldreq	r1, [r3, #0]
    ac56:	685b      	ldreq	r3, [r3, #4]
    ac58:	1809      	addeq	r1, r1, r0
    ac5a:	6021      	streq	r1, [r4, #0]
    ac5c:	e7ed      	b.n	ac3a <_free_r+0x1e>
    ac5e:	461a      	mov	r2, r3
    ac60:	685b      	ldr	r3, [r3, #4]
    ac62:	b10b      	cbz	r3, ac68 <_free_r+0x4c>
    ac64:	42a3      	cmp	r3, r4
    ac66:	d9fa      	bls.n	ac5e <_free_r+0x42>
    ac68:	6811      	ldr	r1, [r2, #0]
    ac6a:	1850      	adds	r0, r2, r1
    ac6c:	42a0      	cmp	r0, r4
    ac6e:	d10b      	bne.n	ac88 <_free_r+0x6c>
    ac70:	6820      	ldr	r0, [r4, #0]
    ac72:	4401      	add	r1, r0
    ac74:	1850      	adds	r0, r2, r1
    ac76:	4283      	cmp	r3, r0
    ac78:	6011      	str	r1, [r2, #0]
    ac7a:	d1e0      	bne.n	ac3e <_free_r+0x22>
    ac7c:	6818      	ldr	r0, [r3, #0]
    ac7e:	685b      	ldr	r3, [r3, #4]
    ac80:	6053      	str	r3, [r2, #4]
    ac82:	4401      	add	r1, r0
    ac84:	6011      	str	r1, [r2, #0]
    ac86:	e7da      	b.n	ac3e <_free_r+0x22>
    ac88:	d902      	bls.n	ac90 <_free_r+0x74>
    ac8a:	230c      	movs	r3, #12
    ac8c:	602b      	str	r3, [r5, #0]
    ac8e:	e7d6      	b.n	ac3e <_free_r+0x22>
    ac90:	6820      	ldr	r0, [r4, #0]
    ac92:	1821      	adds	r1, r4, r0
    ac94:	428b      	cmp	r3, r1
    ac96:	bf04      	itt	eq
    ac98:	6819      	ldreq	r1, [r3, #0]
    ac9a:	685b      	ldreq	r3, [r3, #4]
    ac9c:	6063      	str	r3, [r4, #4]
    ac9e:	bf04      	itt	eq
    aca0:	1809      	addeq	r1, r1, r0
    aca2:	6021      	streq	r1, [r4, #0]
    aca4:	6054      	str	r4, [r2, #4]
    aca6:	e7ca      	b.n	ac3e <_free_r+0x22>
    aca8:	bd38      	pop	{r3, r4, r5, pc}
    acaa:	bf00      	nop
    acac:	20016400 	.word	0x20016400

0000acb0 <sbrk_aligned>:
    acb0:	b570      	push	{r4, r5, r6, lr}
    acb2:	4e0e      	ldr	r6, [pc, #56]	; (acec <sbrk_aligned+0x3c>)
    acb4:	460c      	mov	r4, r1
    acb6:	6831      	ldr	r1, [r6, #0]
    acb8:	4605      	mov	r5, r0
    acba:	b911      	cbnz	r1, acc2 <sbrk_aligned+0x12>
    acbc:	f000 fb78 	bl	b3b0 <_sbrk_r>
    acc0:	6030      	str	r0, [r6, #0]
    acc2:	4621      	mov	r1, r4
    acc4:	4628      	mov	r0, r5
    acc6:	f000 fb73 	bl	b3b0 <_sbrk_r>
    acca:	1c43      	adds	r3, r0, #1
    accc:	d00a      	beq.n	ace4 <sbrk_aligned+0x34>
    acce:	1cc4      	adds	r4, r0, #3
    acd0:	f024 0403 	bic.w	r4, r4, #3
    acd4:	42a0      	cmp	r0, r4
    acd6:	d007      	beq.n	ace8 <sbrk_aligned+0x38>
    acd8:	1a21      	subs	r1, r4, r0
    acda:	4628      	mov	r0, r5
    acdc:	f000 fb68 	bl	b3b0 <_sbrk_r>
    ace0:	3001      	adds	r0, #1
    ace2:	d101      	bne.n	ace8 <sbrk_aligned+0x38>
    ace4:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
    ace8:	4620      	mov	r0, r4
    acea:	bd70      	pop	{r4, r5, r6, pc}
    acec:	20016404 	.word	0x20016404

0000acf0 <_malloc_r>:
    acf0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    acf4:	1ccd      	adds	r5, r1, #3
    acf6:	f025 0503 	bic.w	r5, r5, #3
    acfa:	3508      	adds	r5, #8
    acfc:	2d0c      	cmp	r5, #12
    acfe:	bf38      	it	cc
    ad00:	250c      	movcc	r5, #12
    ad02:	2d00      	cmp	r5, #0
    ad04:	4607      	mov	r7, r0
    ad06:	db01      	blt.n	ad0c <_malloc_r+0x1c>
    ad08:	42a9      	cmp	r1, r5
    ad0a:	d905      	bls.n	ad18 <_malloc_r+0x28>
    ad0c:	230c      	movs	r3, #12
    ad0e:	603b      	str	r3, [r7, #0]
    ad10:	2600      	movs	r6, #0
    ad12:	4630      	mov	r0, r6
    ad14:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    ad18:	4e2e      	ldr	r6, [pc, #184]	; (add4 <_malloc_r+0xe4>)
    ad1a:	f000 fc49 	bl	b5b0 <__malloc_lock>
    ad1e:	6833      	ldr	r3, [r6, #0]
    ad20:	461c      	mov	r4, r3
    ad22:	bb34      	cbnz	r4, ad72 <_malloc_r+0x82>
    ad24:	4629      	mov	r1, r5
    ad26:	4638      	mov	r0, r7
    ad28:	f7ff ffc2 	bl	acb0 <sbrk_aligned>
    ad2c:	1c43      	adds	r3, r0, #1
    ad2e:	4604      	mov	r4, r0
    ad30:	d14d      	bne.n	adce <_malloc_r+0xde>
    ad32:	6834      	ldr	r4, [r6, #0]
    ad34:	4626      	mov	r6, r4
    ad36:	2e00      	cmp	r6, #0
    ad38:	d140      	bne.n	adbc <_malloc_r+0xcc>
    ad3a:	6823      	ldr	r3, [r4, #0]
    ad3c:	4631      	mov	r1, r6
    ad3e:	4638      	mov	r0, r7
    ad40:	eb04 0803 	add.w	r8, r4, r3
    ad44:	f000 fb34 	bl	b3b0 <_sbrk_r>
    ad48:	4580      	cmp	r8, r0
    ad4a:	d13a      	bne.n	adc2 <_malloc_r+0xd2>
    ad4c:	6821      	ldr	r1, [r4, #0]
    ad4e:	3503      	adds	r5, #3
    ad50:	1a6d      	subs	r5, r5, r1
    ad52:	f025 0503 	bic.w	r5, r5, #3
    ad56:	3508      	adds	r5, #8
    ad58:	2d0c      	cmp	r5, #12
    ad5a:	bf38      	it	cc
    ad5c:	250c      	movcc	r5, #12
    ad5e:	4629      	mov	r1, r5
    ad60:	4638      	mov	r0, r7
    ad62:	f7ff ffa5 	bl	acb0 <sbrk_aligned>
    ad66:	3001      	adds	r0, #1
    ad68:	d02b      	beq.n	adc2 <_malloc_r+0xd2>
    ad6a:	6823      	ldr	r3, [r4, #0]
    ad6c:	442b      	add	r3, r5
    ad6e:	6023      	str	r3, [r4, #0]
    ad70:	e00e      	b.n	ad90 <_malloc_r+0xa0>
    ad72:	6822      	ldr	r2, [r4, #0]
    ad74:	1b52      	subs	r2, r2, r5
    ad76:	d41e      	bmi.n	adb6 <_malloc_r+0xc6>
    ad78:	2a0b      	cmp	r2, #11
    ad7a:	d916      	bls.n	adaa <_malloc_r+0xba>
    ad7c:	1961      	adds	r1, r4, r5
    ad7e:	42a3      	cmp	r3, r4
    ad80:	6025      	str	r5, [r4, #0]
    ad82:	bf18      	it	ne
    ad84:	6059      	strne	r1, [r3, #4]
    ad86:	6863      	ldr	r3, [r4, #4]
    ad88:	bf08      	it	eq
    ad8a:	6031      	streq	r1, [r6, #0]
    ad8c:	5162      	str	r2, [r4, r5]
    ad8e:	604b      	str	r3, [r1, #4]
    ad90:	4638      	mov	r0, r7
    ad92:	f104 060b 	add.w	r6, r4, #11
    ad96:	f000 fc11 	bl	b5bc <__malloc_unlock>
    ad9a:	f026 0607 	bic.w	r6, r6, #7
    ad9e:	1d23      	adds	r3, r4, #4
    ada0:	1af2      	subs	r2, r6, r3
    ada2:	d0b6      	beq.n	ad12 <_malloc_r+0x22>
    ada4:	1b9b      	subs	r3, r3, r6
    ada6:	50a3      	str	r3, [r4, r2]
    ada8:	e7b3      	b.n	ad12 <_malloc_r+0x22>
    adaa:	6862      	ldr	r2, [r4, #4]
    adac:	42a3      	cmp	r3, r4
    adae:	bf0c      	ite	eq
    adb0:	6032      	streq	r2, [r6, #0]
    adb2:	605a      	strne	r2, [r3, #4]
    adb4:	e7ec      	b.n	ad90 <_malloc_r+0xa0>
    adb6:	4623      	mov	r3, r4
    adb8:	6864      	ldr	r4, [r4, #4]
    adba:	e7b2      	b.n	ad22 <_malloc_r+0x32>
    adbc:	4634      	mov	r4, r6
    adbe:	6876      	ldr	r6, [r6, #4]
    adc0:	e7b9      	b.n	ad36 <_malloc_r+0x46>
    adc2:	230c      	movs	r3, #12
    adc4:	603b      	str	r3, [r7, #0]
    adc6:	4638      	mov	r0, r7
    adc8:	f000 fbf8 	bl	b5bc <__malloc_unlock>
    adcc:	e7a1      	b.n	ad12 <_malloc_r+0x22>
    adce:	6025      	str	r5, [r4, #0]
    add0:	e7de      	b.n	ad90 <_malloc_r+0xa0>
    add2:	bf00      	nop
    add4:	20016400 	.word	0x20016400

0000add8 <__sfputc_r>:
    add8:	6893      	ldr	r3, [r2, #8]
    adda:	3b01      	subs	r3, #1
    addc:	2b00      	cmp	r3, #0
    adde:	b410      	push	{r4}
    ade0:	6093      	str	r3, [r2, #8]
    ade2:	da07      	bge.n	adf4 <__sfputc_r+0x1c>
    ade4:	6994      	ldr	r4, [r2, #24]
    ade6:	42a3      	cmp	r3, r4
    ade8:	db01      	blt.n	adee <__sfputc_r+0x16>
    adea:	290a      	cmp	r1, #10
    adec:	d102      	bne.n	adf4 <__sfputc_r+0x1c>
    adee:	bc10      	pop	{r4}
    adf0:	f7ff bc30 	b.w	a654 <__swbuf_r>
    adf4:	6813      	ldr	r3, [r2, #0]
    adf6:	1c58      	adds	r0, r3, #1
    adf8:	6010      	str	r0, [r2, #0]
    adfa:	7019      	strb	r1, [r3, #0]
    adfc:	4608      	mov	r0, r1
    adfe:	bc10      	pop	{r4}
    ae00:	4770      	bx	lr

0000ae02 <__sfputs_r>:
    ae02:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    ae04:	4606      	mov	r6, r0
    ae06:	460f      	mov	r7, r1
    ae08:	4614      	mov	r4, r2
    ae0a:	18d5      	adds	r5, r2, r3
    ae0c:	42ac      	cmp	r4, r5
    ae0e:	d101      	bne.n	ae14 <__sfputs_r+0x12>
    ae10:	2000      	movs	r0, #0
    ae12:	e007      	b.n	ae24 <__sfputs_r+0x22>
    ae14:	f814 1b01 	ldrb.w	r1, [r4], #1
    ae18:	463a      	mov	r2, r7
    ae1a:	4630      	mov	r0, r6
    ae1c:	f7ff ffdc 	bl	add8 <__sfputc_r>
    ae20:	1c43      	adds	r3, r0, #1
    ae22:	d1f3      	bne.n	ae0c <__sfputs_r+0xa>
    ae24:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	...

0000ae28 <_vfiprintf_r>:
    ae28:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    ae2c:	460d      	mov	r5, r1
    ae2e:	b09d      	sub	sp, #116	; 0x74
    ae30:	4614      	mov	r4, r2
    ae32:	4698      	mov	r8, r3
    ae34:	4606      	mov	r6, r0
    ae36:	b118      	cbz	r0, ae40 <_vfiprintf_r+0x18>
    ae38:	6983      	ldr	r3, [r0, #24]
    ae3a:	b90b      	cbnz	r3, ae40 <_vfiprintf_r+0x18>
    ae3c:	f7ff fde0 	bl	aa00 <__sinit>
    ae40:	4b89      	ldr	r3, [pc, #548]	; (b068 <_vfiprintf_r+0x240>)
    ae42:	429d      	cmp	r5, r3
    ae44:	d11b      	bne.n	ae7e <_vfiprintf_r+0x56>
    ae46:	6875      	ldr	r5, [r6, #4]
    ae48:	6e6b      	ldr	r3, [r5, #100]	; 0x64
    ae4a:	07d9      	lsls	r1, r3, #31
    ae4c:	d405      	bmi.n	ae5a <_vfiprintf_r+0x32>
    ae4e:	89ab      	ldrh	r3, [r5, #12]
    ae50:	059a      	lsls	r2, r3, #22
    ae52:	d402      	bmi.n	ae5a <_vfiprintf_r+0x32>
    ae54:	6da8      	ldr	r0, [r5, #88]	; 0x58
    ae56:	f7ff fe71 	bl	ab3c <__retarget_lock_acquire_recursive>
    ae5a:	89ab      	ldrh	r3, [r5, #12]
    ae5c:	071b      	lsls	r3, r3, #28
    ae5e:	d501      	bpl.n	ae64 <_vfiprintf_r+0x3c>
    ae60:	692b      	ldr	r3, [r5, #16]
    ae62:	b9eb      	cbnz	r3, aea0 <_vfiprintf_r+0x78>
    ae64:	4629      	mov	r1, r5
    ae66:	4630      	mov	r0, r6
    ae68:	f7ff fc46 	bl	a6f8 <__swsetup_r>
    ae6c:	b1c0      	cbz	r0, aea0 <_vfiprintf_r+0x78>
    ae6e:	6e6b      	ldr	r3, [r5, #100]	; 0x64
    ae70:	07dc      	lsls	r4, r3, #31
    ae72:	d50e      	bpl.n	ae92 <_vfiprintf_r+0x6a>
    ae74:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    ae78:	b01d      	add	sp, #116	; 0x74
    ae7a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    ae7e:	4b7b      	ldr	r3, [pc, #492]	; (b06c <_vfiprintf_r+0x244>)
    ae80:	429d      	cmp	r5, r3
    ae82:	d101      	bne.n	ae88 <_vfiprintf_r+0x60>
    ae84:	68b5      	ldr	r5, [r6, #8]
    ae86:	e7df      	b.n	ae48 <_vfiprintf_r+0x20>
    ae88:	4b79      	ldr	r3, [pc, #484]	; (b070 <_vfiprintf_r+0x248>)
    ae8a:	429d      	cmp	r5, r3
    ae8c:	bf08      	it	eq
    ae8e:	68f5      	ldreq	r5, [r6, #12]
    ae90:	e7da      	b.n	ae48 <_vfiprintf_r+0x20>
    ae92:	89ab      	ldrh	r3, [r5, #12]
    ae94:	0598      	lsls	r0, r3, #22
    ae96:	d4ed      	bmi.n	ae74 <_vfiprintf_r+0x4c>
    ae98:	6da8      	ldr	r0, [r5, #88]	; 0x58
    ae9a:	f7ff fe50 	bl	ab3e <__retarget_lock_release_recursive>
    ae9e:	e7e9      	b.n	ae74 <_vfiprintf_r+0x4c>
    aea0:	2300      	movs	r3, #0
    aea2:	9309      	str	r3, [sp, #36]	; 0x24
    aea4:	2320      	movs	r3, #32
    aea6:	f88d 3029 	strb.w	r3, [sp, #41]	; 0x29
    aeaa:	f8cd 800c 	str.w	r8, [sp, #12]
    aeae:	2330      	movs	r3, #48	; 0x30
    aeb0:	f8df 81c0 	ldr.w	r8, [pc, #448]	; b074 <_vfiprintf_r+0x24c>
    aeb4:	f88d 302a 	strb.w	r3, [sp, #42]	; 0x2a
    aeb8:	f04f 0901 	mov.w	r9, #1
    aebc:	4623      	mov	r3, r4
    aebe:	469a      	mov	sl, r3
    aec0:	f813 2b01 	ldrb.w	r2, [r3], #1
    aec4:	b10a      	cbz	r2, aeca <_vfiprintf_r+0xa2>
    aec6:	2a25      	cmp	r2, #37	; 0x25
    aec8:	d1f9      	bne.n	aebe <_vfiprintf_r+0x96>
    aeca:	ebba 0b04 	subs.w	fp, sl, r4
    aece:	d00b      	beq.n	aee8 <_vfiprintf_r+0xc0>
    aed0:	465b      	mov	r3, fp
    aed2:	4622      	mov	r2, r4
    aed4:	4629      	mov	r1, r5
    aed6:	4630      	mov	r0, r6
    aed8:	f7ff ff93 	bl	ae02 <__sfputs_r>
    aedc:	3001      	adds	r0, #1
    aede:	f000 80aa 	beq.w	b036 <_vfiprintf_r+0x20e>
    aee2:	9a09      	ldr	r2, [sp, #36]	; 0x24
    aee4:	445a      	add	r2, fp
    aee6:	9209      	str	r2, [sp, #36]	; 0x24
    aee8:	f89a 3000 	ldrb.w	r3, [sl]
    aeec:	2b00      	cmp	r3, #0
    aeee:	f000 80a2 	beq.w	b036 <_vfiprintf_r+0x20e>
    aef2:	2300      	movs	r3, #0
    aef4:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
    aef8:	e9cd 2305 	strd	r2, r3, [sp, #20]
    aefc:	f10a 0a01 	add.w	sl, sl, #1
    af00:	9304      	str	r3, [sp, #16]
    af02:	9307      	str	r3, [sp, #28]
    af04:	f88d 3053 	strb.w	r3, [sp, #83]	; 0x53
    af08:	931a      	str	r3, [sp, #104]	; 0x68
    af0a:	4654      	mov	r4, sl
    af0c:	2205      	movs	r2, #5
    af0e:	f814 1b01 	ldrb.w	r1, [r4], #1
    af12:	4858      	ldr	r0, [pc, #352]	; (b074 <_vfiprintf_r+0x24c>)
    af14:	f000 fafc 	bl	b510 <memchr>
    af18:	9a04      	ldr	r2, [sp, #16]
    af1a:	b9d8      	cbnz	r0, af54 <_vfiprintf_r+0x12c>
    af1c:	06d1      	lsls	r1, r2, #27
    af1e:	bf44      	itt	mi
    af20:	2320      	movmi	r3, #32
    af22:	f88d 3053 	strbmi.w	r3, [sp, #83]	; 0x53
    af26:	0713      	lsls	r3, r2, #28
    af28:	bf44      	itt	mi
    af2a:	232b      	movmi	r3, #43	; 0x2b
    af2c:	f88d 3053 	strbmi.w	r3, [sp, #83]	; 0x53
    af30:	f89a 3000 	ldrb.w	r3, [sl]
    af34:	2b2a      	cmp	r3, #42	; 0x2a
    af36:	d015      	beq.n	af64 <_vfiprintf_r+0x13c>
    af38:	9a07      	ldr	r2, [sp, #28]
    af3a:	4654      	mov	r4, sl
    af3c:	2000      	movs	r0, #0
    af3e:	f04f 0c0a 	mov.w	ip, #10
    af42:	4621      	mov	r1, r4
    af44:	f811 3b01 	ldrb.w	r3, [r1], #1
    af48:	3b30      	subs	r3, #48	; 0x30
    af4a:	2b09      	cmp	r3, #9
    af4c:	d94e      	bls.n	afec <_vfiprintf_r+0x1c4>
    af4e:	b1b0      	cbz	r0, af7e <_vfiprintf_r+0x156>
    af50:	9207      	str	r2, [sp, #28]
    af52:	e014      	b.n	af7e <_vfiprintf_r+0x156>
    af54:	eba0 0308 	sub.w	r3, r0, r8
    af58:	fa09 f303 	lsl.w	r3, r9, r3
    af5c:	4313      	orrs	r3, r2
    af5e:	9304      	str	r3, [sp, #16]
    af60:	46a2      	mov	sl, r4
    af62:	e7d2      	b.n	af0a <_vfiprintf_r+0xe2>
    af64:	9b03      	ldr	r3, [sp, #12]
    af66:	1d19      	adds	r1, r3, #4
    af68:	681b      	ldr	r3, [r3, #0]
    af6a:	9103      	str	r1, [sp, #12]
    af6c:	2b00      	cmp	r3, #0
    af6e:	bfbb      	ittet	lt
    af70:	425b      	neglt	r3, r3
    af72:	f042 0202 	orrlt.w	r2, r2, #2
    af76:	9307      	strge	r3, [sp, #28]
    af78:	9307      	strlt	r3, [sp, #28]
    af7a:	bfb8      	it	lt
    af7c:	9204      	strlt	r2, [sp, #16]
    af7e:	7823      	ldrb	r3, [r4, #0]
    af80:	2b2e      	cmp	r3, #46	; 0x2e
    af82:	d10c      	bne.n	af9e <_vfiprintf_r+0x176>
    af84:	7863      	ldrb	r3, [r4, #1]
    af86:	2b2a      	cmp	r3, #42	; 0x2a
    af88:	d135      	bne.n	aff6 <_vfiprintf_r+0x1ce>
    af8a:	9b03      	ldr	r3, [sp, #12]
    af8c:	1d1a      	adds	r2, r3, #4
    af8e:	681b      	ldr	r3, [r3, #0]
    af90:	9203      	str	r2, [sp, #12]
    af92:	2b00      	cmp	r3, #0
    af94:	bfb8      	it	lt
    af96:	f04f 33ff 	movlt.w	r3, #4294967295	; 0xffffffff
    af9a:	3402      	adds	r4, #2
    af9c:	9305      	str	r3, [sp, #20]
    af9e:	f8df a0d8 	ldr.w	sl, [pc, #216]	; b078 <_vfiprintf_r+0x250>
    afa2:	7821      	ldrb	r1, [r4, #0]
    afa4:	2203      	movs	r2, #3
    afa6:	4650      	mov	r0, sl
    afa8:	f000 fab2 	bl	b510 <memchr>
    afac:	b140      	cbz	r0, afc0 <_vfiprintf_r+0x198>
    afae:	2340      	movs	r3, #64	; 0x40
    afb0:	eba0 000a 	sub.w	r0, r0, sl
    afb4:	fa03 f000 	lsl.w	r0, r3, r0
    afb8:	9b04      	ldr	r3, [sp, #16]
    afba:	4303      	orrs	r3, r0
    afbc:	3401      	adds	r4, #1
    afbe:	9304      	str	r3, [sp, #16]
    afc0:	f814 1b01 	ldrb.w	r1, [r4], #1
    afc4:	482d      	ldr	r0, [pc, #180]	; (b07c <_vfiprintf_r+0x254>)
    afc6:	f88d 1028 	strb.w	r1, [sp, #40]	; 0x28
    afca:	2206      	movs	r2, #6
    afcc:	f000 faa0 	bl	b510 <memchr>
    afd0:	2800      	cmp	r0, #0
    afd2:	d03f      	beq.n	b054 <_vfiprintf_r+0x22c>
    afd4:	4b2a      	ldr	r3, [pc, #168]	; (b080 <_vfiprintf_r+0x258>)
    afd6:	bb1b      	cbnz	r3, b020 <_vfiprintf_r+0x1f8>
    afd8:	9b03      	ldr	r3, [sp, #12]
    afda:	3307      	adds	r3, #7
    afdc:	f023 0307 	bic.w	r3, r3, #7
    afe0:	3308      	adds	r3, #8
    afe2:	9303      	str	r3, [sp, #12]
    afe4:	9b09      	ldr	r3, [sp, #36]	; 0x24
    afe6:	443b      	add	r3, r7
    afe8:	9309      	str	r3, [sp, #36]	; 0x24
    afea:	e767      	b.n	aebc <_vfiprintf_r+0x94>
    afec:	fb0c 3202 	mla	r2, ip, r2, r3
    aff0:	460c      	mov	r4, r1
    aff2:	2001      	movs	r0, #1
    aff4:	e7a5      	b.n	af42 <_vfiprintf_r+0x11a>
    aff6:	2300      	movs	r3, #0
    aff8:	3401      	adds	r4, #1
    affa:	9305      	str	r3, [sp, #20]
    affc:	4619      	mov	r1, r3
    affe:	f04f 0c0a 	mov.w	ip, #10
    b002:	4620      	mov	r0, r4
    b004:	f810 2b01 	ldrb.w	r2, [r0], #1
    b008:	3a30      	subs	r2, #48	; 0x30
    b00a:	2a09      	cmp	r2, #9
    b00c:	d903      	bls.n	b016 <_vfiprintf_r+0x1ee>
    b00e:	2b00      	cmp	r3, #0
    b010:	d0c5      	beq.n	af9e <_vfiprintf_r+0x176>
    b012:	9105      	str	r1, [sp, #20]
    b014:	e7c3      	b.n	af9e <_vfiprintf_r+0x176>
    b016:	fb0c 2101 	mla	r1, ip, r1, r2
    b01a:	4604      	mov	r4, r0
    b01c:	2301      	movs	r3, #1
    b01e:	e7f0      	b.n	b002 <_vfiprintf_r+0x1da>
    b020:	ab03      	add	r3, sp, #12
    b022:	9300      	str	r3, [sp, #0]
    b024:	462a      	mov	r2, r5
    b026:	4b17      	ldr	r3, [pc, #92]	; (b084 <_vfiprintf_r+0x25c>)
    b028:	a904      	add	r1, sp, #16
    b02a:	4630      	mov	r0, r6
    b02c:	f3af 8000 	nop.w
    b030:	4607      	mov	r7, r0
    b032:	1c78      	adds	r0, r7, #1
    b034:	d1d6      	bne.n	afe4 <_vfiprintf_r+0x1bc>
    b036:	6e6b      	ldr	r3, [r5, #100]	; 0x64
    b038:	07d9      	lsls	r1, r3, #31
    b03a:	d405      	bmi.n	b048 <_vfiprintf_r+0x220>
    b03c:	89ab      	ldrh	r3, [r5, #12]
    b03e:	059a      	lsls	r2, r3, #22
    b040:	d402      	bmi.n	b048 <_vfiprintf_r+0x220>
    b042:	6da8      	ldr	r0, [r5, #88]	; 0x58
    b044:	f7ff fd7b 	bl	ab3e <__retarget_lock_release_recursive>
    b048:	89ab      	ldrh	r3, [r5, #12]
    b04a:	065b      	lsls	r3, r3, #25
    b04c:	f53f af12 	bmi.w	ae74 <_vfiprintf_r+0x4c>
    b050:	9809      	ldr	r0, [sp, #36]	; 0x24
    b052:	e711      	b.n	ae78 <_vfiprintf_r+0x50>
    b054:	ab03      	add	r3, sp, #12
    b056:	9300      	str	r3, [sp, #0]
    b058:	462a      	mov	r2, r5
    b05a:	4b0a      	ldr	r3, [pc, #40]	; (b084 <_vfiprintf_r+0x25c>)
    b05c:	a904      	add	r1, sp, #16
    b05e:	4630      	mov	r0, r6
    b060:	f000 f880 	bl	b164 <_printf_i>
    b064:	e7e4      	b.n	b030 <_vfiprintf_r+0x208>
    b066:	bf00      	nop
    b068:	0000b9a8 	.word	0x0000b9a8
    b06c:	0000b9c8 	.word	0x0000b9c8
    b070:	0000b988 	.word	0x0000b988
    b074:	0000b9e8 	.word	0x0000b9e8
    b078:	0000b9ee 	.word	0x0000b9ee
    b07c:	0000b9f2 	.word	0x0000b9f2
    b080:	00000000 	.word	0x00000000
    b084:	0000ae03 	.word	0x0000ae03

0000b088 <_printf_common>:
    b088:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    b08c:	4616      	mov	r6, r2
    b08e:	4699      	mov	r9, r3
    b090:	688a      	ldr	r2, [r1, #8]
    b092:	690b      	ldr	r3, [r1, #16]
    b094:	f8dd 8020 	ldr.w	r8, [sp, #32]
    b098:	4293      	cmp	r3, r2
    b09a:	bfb8      	it	lt
    b09c:	4613      	movlt	r3, r2
    b09e:	6033      	str	r3, [r6, #0]
    b0a0:	f891 2043 	ldrb.w	r2, [r1, #67]	; 0x43
    b0a4:	4607      	mov	r7, r0
    b0a6:	460c      	mov	r4, r1
    b0a8:	b10a      	cbz	r2, b0ae <_printf_common+0x26>
    b0aa:	3301      	adds	r3, #1
    b0ac:	6033      	str	r3, [r6, #0]
    b0ae:	6823      	ldr	r3, [r4, #0]
    b0b0:	0699      	lsls	r1, r3, #26
    b0b2:	bf42      	ittt	mi
    b0b4:	6833      	ldrmi	r3, [r6, #0]
    b0b6:	3302      	addmi	r3, #2
    b0b8:	6033      	strmi	r3, [r6, #0]
    b0ba:	6825      	ldr	r5, [r4, #0]
    b0bc:	f015 0506 	ands.w	r5, r5, #6
    b0c0:	d106      	bne.n	b0d0 <_printf_common+0x48>
    b0c2:	f104 0a19 	add.w	sl, r4, #25
    b0c6:	68e3      	ldr	r3, [r4, #12]
    b0c8:	6832      	ldr	r2, [r6, #0]
    b0ca:	1a9b      	subs	r3, r3, r2
    b0cc:	42ab      	cmp	r3, r5
    b0ce:	dc26      	bgt.n	b11e <_printf_common+0x96>
    b0d0:	f894 2043 	ldrb.w	r2, [r4, #67]	; 0x43
    b0d4:	1e13      	subs	r3, r2, #0
    b0d6:	6822      	ldr	r2, [r4, #0]
    b0d8:	bf18      	it	ne
    b0da:	2301      	movne	r3, #1
    b0dc:	0692      	lsls	r2, r2, #26
    b0de:	d42b      	bmi.n	b138 <_printf_common+0xb0>
    b0e0:	f104 0243 	add.w	r2, r4, #67	; 0x43
    b0e4:	4649      	mov	r1, r9
    b0e6:	4638      	mov	r0, r7
    b0e8:	47c0      	blx	r8
    b0ea:	3001      	adds	r0, #1
    b0ec:	d01e      	beq.n	b12c <_printf_common+0xa4>
    b0ee:	6823      	ldr	r3, [r4, #0]
    b0f0:	68e5      	ldr	r5, [r4, #12]
    b0f2:	6832      	ldr	r2, [r6, #0]
    b0f4:	f003 0306 	and.w	r3, r3, #6
    b0f8:	2b04      	cmp	r3, #4
    b0fa:	bf08      	it	eq
    b0fc:	1aad      	subeq	r5, r5, r2
    b0fe:	68a3      	ldr	r3, [r4, #8]
    b100:	6922      	ldr	r2, [r4, #16]
    b102:	bf0c      	ite	eq
    b104:	ea25 75e5 	biceq.w	r5, r5, r5, asr #31
    b108:	2500      	movne	r5, #0
    b10a:	4293      	cmp	r3, r2
    b10c:	bfc4      	itt	gt
    b10e:	1a9b      	subgt	r3, r3, r2
    b110:	18ed      	addgt	r5, r5, r3
    b112:	2600      	movs	r6, #0
    b114:	341a      	adds	r4, #26
    b116:	42b5      	cmp	r5, r6
    b118:	d11a      	bne.n	b150 <_printf_common+0xc8>
    b11a:	2000      	movs	r0, #0
    b11c:	e008      	b.n	b130 <_printf_common+0xa8>
    b11e:	2301      	movs	r3, #1
    b120:	4652      	mov	r2, sl
    b122:	4649      	mov	r1, r9
    b124:	4638      	mov	r0, r7
    b126:	47c0      	blx	r8
    b128:	3001      	adds	r0, #1
    b12a:	d103      	bne.n	b134 <_printf_common+0xac>
    b12c:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    b130:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    b134:	3501      	adds	r5, #1
    b136:	e7c6      	b.n	b0c6 <_printf_common+0x3e>
    b138:	18e1      	adds	r1, r4, r3
    b13a:	1c5a      	adds	r2, r3, #1
    b13c:	2030      	movs	r0, #48	; 0x30
    b13e:	f881 0043 	strb.w	r0, [r1, #67]	; 0x43
    b142:	4422      	add	r2, r4
    b144:	f894 1045 	ldrb.w	r1, [r4, #69]	; 0x45
    b148:	f882 1043 	strb.w	r1, [r2, #67]	; 0x43
    b14c:	3302      	adds	r3, #2
    b14e:	e7c7      	b.n	b0e0 <_printf_common+0x58>
    b150:	2301      	movs	r3, #1
    b152:	4622      	mov	r2, r4
    b154:	4649      	mov	r1, r9
    b156:	4638      	mov	r0, r7
    b158:	47c0      	blx	r8
    b15a:	3001      	adds	r0, #1
    b15c:	d0e6      	beq.n	b12c <_printf_common+0xa4>
    b15e:	3601      	adds	r6, #1
    b160:	e7d9      	b.n	b116 <_printf_common+0x8e>
	...

0000b164 <_printf_i>:
    b164:	e92d 47ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, lr}
    b168:	7e0f      	ldrb	r7, [r1, #24]
    b16a:	9d0c      	ldr	r5, [sp, #48]	; 0x30
    b16c:	2f78      	cmp	r7, #120	; 0x78
    b16e:	4691      	mov	r9, r2
    b170:	4680      	mov	r8, r0
    b172:	460c      	mov	r4, r1
    b174:	469a      	mov	sl, r3
    b176:	f101 0243 	add.w	r2, r1, #67	; 0x43
    b17a:	d807      	bhi.n	b18c <_printf_i+0x28>
    b17c:	2f62      	cmp	r7, #98	; 0x62
    b17e:	d80a      	bhi.n	b196 <_printf_i+0x32>
    b180:	2f00      	cmp	r7, #0
    b182:	f000 80d8 	beq.w	b336 <_printf_i+0x1d2>
    b186:	2f58      	cmp	r7, #88	; 0x58
    b188:	f000 80a3 	beq.w	b2d2 <_printf_i+0x16e>
    b18c:	f104 0542 	add.w	r5, r4, #66	; 0x42
    b190:	f884 7042 	strb.w	r7, [r4, #66]	; 0x42
    b194:	e03a      	b.n	b20c <_printf_i+0xa8>
    b196:	f1a7 0363 	sub.w	r3, r7, #99	; 0x63
    b19a:	2b15      	cmp	r3, #21
    b19c:	d8f6      	bhi.n	b18c <_printf_i+0x28>
    b19e:	a101      	add	r1, pc, #4	; (adr r1, b1a4 <_printf_i+0x40>)
    b1a0:	f851 f023 	ldr.w	pc, [r1, r3, lsl #2]
    b1a4:	0000b1fd 	.word	0x0000b1fd
    b1a8:	0000b211 	.word	0x0000b211
    b1ac:	0000b18d 	.word	0x0000b18d
    b1b0:	0000b18d 	.word	0x0000b18d
    b1b4:	0000b18d 	.word	0x0000b18d
    b1b8:	0000b18d 	.word	0x0000b18d
    b1bc:	0000b211 	.word	0x0000b211
    b1c0:	0000b18d 	.word	0x0000b18d
    b1c4:	0000b18d 	.word	0x0000b18d
    b1c8:	0000b18d 	.word	0x0000b18d
    b1cc:	0000b18d 	.word	0x0000b18d
    b1d0:	0000b31d 	.word	0x0000b31d
    b1d4:	0000b241 	.word	0x0000b241
    b1d8:	0000b2ff 	.word	0x0000b2ff
    b1dc:	0000b18d 	.word	0x0000b18d
    b1e0:	0000b18d 	.word	0x0000b18d
    b1e4:	0000b33f 	.word	0x0000b33f
    b1e8:	0000b18d 	.word	0x0000b18d
    b1ec:	0000b241 	.word	0x0000b241
    b1f0:	0000b18d 	.word	0x0000b18d
    b1f4:	0000b18d 	.word	0x0000b18d
    b1f8:	0000b307 	.word	0x0000b307
    b1fc:	682b      	ldr	r3, [r5, #0]
    b1fe:	1d1a      	adds	r2, r3, #4
    b200:	681b      	ldr	r3, [r3, #0]
    b202:	602a      	str	r2, [r5, #0]
    b204:	f104 0542 	add.w	r5, r4, #66	; 0x42
    b208:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42
    b20c:	2301      	movs	r3, #1
    b20e:	e0a3      	b.n	b358 <_printf_i+0x1f4>
    b210:	6820      	ldr	r0, [r4, #0]
    b212:	6829      	ldr	r1, [r5, #0]
    b214:	0606      	lsls	r6, r0, #24
    b216:	f101 0304 	add.w	r3, r1, #4
    b21a:	d50a      	bpl.n	b232 <_printf_i+0xce>
    b21c:	680e      	ldr	r6, [r1, #0]
    b21e:	602b      	str	r3, [r5, #0]
    b220:	2e00      	cmp	r6, #0
    b222:	da03      	bge.n	b22c <_printf_i+0xc8>
    b224:	232d      	movs	r3, #45	; 0x2d
    b226:	4276      	negs	r6, r6
    b228:	f884 3043 	strb.w	r3, [r4, #67]	; 0x43
    b22c:	485e      	ldr	r0, [pc, #376]	; (b3a8 <_printf_i+0x244>)
    b22e:	230a      	movs	r3, #10
    b230:	e019      	b.n	b266 <_printf_i+0x102>
    b232:	680e      	ldr	r6, [r1, #0]
    b234:	602b      	str	r3, [r5, #0]
    b236:	f010 0f40 	tst.w	r0, #64	; 0x40
    b23a:	bf18      	it	ne
    b23c:	b236      	sxthne	r6, r6
    b23e:	e7ef      	b.n	b220 <_printf_i+0xbc>
    b240:	682b      	ldr	r3, [r5, #0]
    b242:	6820      	ldr	r0, [r4, #0]
    b244:	1d19      	adds	r1, r3, #4
    b246:	6029      	str	r1, [r5, #0]
    b248:	0601      	lsls	r1, r0, #24
    b24a:	d501      	bpl.n	b250 <_printf_i+0xec>
    b24c:	681e      	ldr	r6, [r3, #0]
    b24e:	e002      	b.n	b256 <_printf_i+0xf2>
    b250:	0646      	lsls	r6, r0, #25
    b252:	d5fb      	bpl.n	b24c <_printf_i+0xe8>
    b254:	881e      	ldrh	r6, [r3, #0]
    b256:	4854      	ldr	r0, [pc, #336]	; (b3a8 <_printf_i+0x244>)
    b258:	2f6f      	cmp	r7, #111	; 0x6f
    b25a:	bf0c      	ite	eq
    b25c:	2308      	moveq	r3, #8
    b25e:	230a      	movne	r3, #10
    b260:	2100      	movs	r1, #0
    b262:	f884 1043 	strb.w	r1, [r4, #67]	; 0x43
    b266:	6865      	ldr	r5, [r4, #4]
    b268:	60a5      	str	r5, [r4, #8]
    b26a:	2d00      	cmp	r5, #0
    b26c:	bfa2      	ittt	ge
    b26e:	6821      	ldrge	r1, [r4, #0]
    b270:	f021 0104 	bicge.w	r1, r1, #4
    b274:	6021      	strge	r1, [r4, #0]
    b276:	b90e      	cbnz	r6, b27c <_printf_i+0x118>
    b278:	2d00      	cmp	r5, #0
    b27a:	d04d      	beq.n	b318 <_printf_i+0x1b4>
    b27c:	4615      	mov	r5, r2
    b27e:	fbb6 f1f3 	udiv	r1, r6, r3
    b282:	fb03 6711 	mls	r7, r3, r1, r6
    b286:	5dc7      	ldrb	r7, [r0, r7]
    b288:	f805 7d01 	strb.w	r7, [r5, #-1]!
    b28c:	4637      	mov	r7, r6
    b28e:	42bb      	cmp	r3, r7
    b290:	460e      	mov	r6, r1
    b292:	d9f4      	bls.n	b27e <_printf_i+0x11a>
    b294:	2b08      	cmp	r3, #8
    b296:	d10b      	bne.n	b2b0 <_printf_i+0x14c>
    b298:	6823      	ldr	r3, [r4, #0]
    b29a:	07de      	lsls	r6, r3, #31
    b29c:	d508      	bpl.n	b2b0 <_printf_i+0x14c>
    b29e:	6923      	ldr	r3, [r4, #16]
    b2a0:	6861      	ldr	r1, [r4, #4]
    b2a2:	4299      	cmp	r1, r3
    b2a4:	bfde      	ittt	le
    b2a6:	2330      	movle	r3, #48	; 0x30
    b2a8:	f805 3c01 	strble.w	r3, [r5, #-1]
    b2ac:	f105 35ff 	addle.w	r5, r5, #4294967295	; 0xffffffff
    b2b0:	1b52      	subs	r2, r2, r5
    b2b2:	6122      	str	r2, [r4, #16]
    b2b4:	f8cd a000 	str.w	sl, [sp]
    b2b8:	464b      	mov	r3, r9
    b2ba:	aa03      	add	r2, sp, #12
    b2bc:	4621      	mov	r1, r4
    b2be:	4640      	mov	r0, r8
    b2c0:	f7ff fee2 	bl	b088 <_printf_common>
    b2c4:	3001      	adds	r0, #1
    b2c6:	d14c      	bne.n	b362 <_printf_i+0x1fe>
    b2c8:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    b2cc:	b004      	add	sp, #16
    b2ce:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    b2d2:	4835      	ldr	r0, [pc, #212]	; (b3a8 <_printf_i+0x244>)
    b2d4:	f881 7045 	strb.w	r7, [r1, #69]	; 0x45
    b2d8:	6829      	ldr	r1, [r5, #0]
    b2da:	6823      	ldr	r3, [r4, #0]
    b2dc:	f851 6b04 	ldr.w	r6, [r1], #4
    b2e0:	6029      	str	r1, [r5, #0]
    b2e2:	061d      	lsls	r5, r3, #24
    b2e4:	d514      	bpl.n	b310 <_printf_i+0x1ac>
    b2e6:	07df      	lsls	r7, r3, #31
    b2e8:	bf44      	itt	mi
    b2ea:	f043 0320 	orrmi.w	r3, r3, #32
    b2ee:	6023      	strmi	r3, [r4, #0]
    b2f0:	b91e      	cbnz	r6, b2fa <_printf_i+0x196>
    b2f2:	6823      	ldr	r3, [r4, #0]
    b2f4:	f023 0320 	bic.w	r3, r3, #32
    b2f8:	6023      	str	r3, [r4, #0]
    b2fa:	2310      	movs	r3, #16
    b2fc:	e7b0      	b.n	b260 <_printf_i+0xfc>
    b2fe:	6823      	ldr	r3, [r4, #0]
    b300:	f043 0320 	orr.w	r3, r3, #32
    b304:	6023      	str	r3, [r4, #0]
    b306:	2378      	movs	r3, #120	; 0x78
    b308:	4828      	ldr	r0, [pc, #160]	; (b3ac <_printf_i+0x248>)
    b30a:	f884 3045 	strb.w	r3, [r4, #69]	; 0x45
    b30e:	e7e3      	b.n	b2d8 <_printf_i+0x174>
    b310:	0659      	lsls	r1, r3, #25
    b312:	bf48      	it	mi
    b314:	b2b6      	uxthmi	r6, r6
    b316:	e7e6      	b.n	b2e6 <_printf_i+0x182>
    b318:	4615      	mov	r5, r2
    b31a:	e7bb      	b.n	b294 <_printf_i+0x130>
    b31c:	682b      	ldr	r3, [r5, #0]
    b31e:	6826      	ldr	r6, [r4, #0]
    b320:	6961      	ldr	r1, [r4, #20]
    b322:	1d18      	adds	r0, r3, #4
    b324:	6028      	str	r0, [r5, #0]
    b326:	0635      	lsls	r5, r6, #24
    b328:	681b      	ldr	r3, [r3, #0]
    b32a:	d501      	bpl.n	b330 <_printf_i+0x1cc>
    b32c:	6019      	str	r1, [r3, #0]
    b32e:	e002      	b.n	b336 <_printf_i+0x1d2>
    b330:	0670      	lsls	r0, r6, #25
    b332:	d5fb      	bpl.n	b32c <_printf_i+0x1c8>
    b334:	8019      	strh	r1, [r3, #0]
    b336:	2300      	movs	r3, #0
    b338:	6123      	str	r3, [r4, #16]
    b33a:	4615      	mov	r5, r2
    b33c:	e7ba      	b.n	b2b4 <_printf_i+0x150>
    b33e:	682b      	ldr	r3, [r5, #0]
    b340:	1d1a      	adds	r2, r3, #4
    b342:	602a      	str	r2, [r5, #0]
    b344:	681d      	ldr	r5, [r3, #0]
    b346:	6862      	ldr	r2, [r4, #4]
    b348:	2100      	movs	r1, #0
    b34a:	4628      	mov	r0, r5
    b34c:	f000 f8e0 	bl	b510 <memchr>
    b350:	b108      	cbz	r0, b356 <_printf_i+0x1f2>
    b352:	1b40      	subs	r0, r0, r5
    b354:	6060      	str	r0, [r4, #4]
    b356:	6863      	ldr	r3, [r4, #4]
    b358:	6123      	str	r3, [r4, #16]
    b35a:	2300      	movs	r3, #0
    b35c:	f884 3043 	strb.w	r3, [r4, #67]	; 0x43
    b360:	e7a8      	b.n	b2b4 <_printf_i+0x150>
    b362:	6923      	ldr	r3, [r4, #16]
    b364:	462a      	mov	r2, r5
    b366:	4649      	mov	r1, r9
    b368:	4640      	mov	r0, r8
    b36a:	47d0      	blx	sl
    b36c:	3001      	adds	r0, #1
    b36e:	d0ab      	beq.n	b2c8 <_printf_i+0x164>
    b370:	6823      	ldr	r3, [r4, #0]
    b372:	079b      	lsls	r3, r3, #30
    b374:	d413      	bmi.n	b39e <_printf_i+0x23a>
    b376:	68e0      	ldr	r0, [r4, #12]
    b378:	9b03      	ldr	r3, [sp, #12]
    b37a:	4298      	cmp	r0, r3
    b37c:	bfb8      	it	lt
    b37e:	4618      	movlt	r0, r3
    b380:	e7a4      	b.n	b2cc <_printf_i+0x168>
    b382:	2301      	movs	r3, #1
    b384:	4632      	mov	r2, r6
    b386:	4649      	mov	r1, r9
    b388:	4640      	mov	r0, r8
    b38a:	47d0      	blx	sl
    b38c:	3001      	adds	r0, #1
    b38e:	d09b      	beq.n	b2c8 <_printf_i+0x164>
    b390:	3501      	adds	r5, #1
    b392:	68e3      	ldr	r3, [r4, #12]
    b394:	9903      	ldr	r1, [sp, #12]
    b396:	1a5b      	subs	r3, r3, r1
    b398:	42ab      	cmp	r3, r5
    b39a:	dcf2      	bgt.n	b382 <_printf_i+0x21e>
    b39c:	e7eb      	b.n	b376 <_printf_i+0x212>
    b39e:	2500      	movs	r5, #0
    b3a0:	f104 0619 	add.w	r6, r4, #25
    b3a4:	e7f5      	b.n	b392 <_printf_i+0x22e>
    b3a6:	bf00      	nop
    b3a8:	0000b9f9 	.word	0x0000b9f9
    b3ac:	0000ba0a 	.word	0x0000ba0a

0000b3b0 <_sbrk_r>:
    b3b0:	b538      	push	{r3, r4, r5, lr}
    b3b2:	4d06      	ldr	r5, [pc, #24]	; (b3cc <_sbrk_r+0x1c>)
    b3b4:	2300      	movs	r3, #0
    b3b6:	4604      	mov	r4, r0
    b3b8:	4608      	mov	r0, r1
    b3ba:	602b      	str	r3, [r5, #0]
    b3bc:	f7f5 fbc8 	bl	b50 <_sbrk>
    b3c0:	1c43      	adds	r3, r0, #1
    b3c2:	d102      	bne.n	b3ca <_sbrk_r+0x1a>
    b3c4:	682b      	ldr	r3, [r5, #0]
    b3c6:	b103      	cbz	r3, b3ca <_sbrk_r+0x1a>
    b3c8:	6023      	str	r3, [r4, #0]
    b3ca:	bd38      	pop	{r3, r4, r5, pc}
    b3cc:	20016408 	.word	0x20016408

0000b3d0 <__sread>:
    b3d0:	b510      	push	{r4, lr}
    b3d2:	460c      	mov	r4, r1
    b3d4:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
    b3d8:	f000 f8f6 	bl	b5c8 <_read_r>
    b3dc:	2800      	cmp	r0, #0
    b3de:	bfab      	itete	ge
    b3e0:	6d63      	ldrge	r3, [r4, #84]	; 0x54
    b3e2:	89a3      	ldrhlt	r3, [r4, #12]
    b3e4:	181b      	addge	r3, r3, r0
    b3e6:	f423 5380 	biclt.w	r3, r3, #4096	; 0x1000
    b3ea:	bfac      	ite	ge
    b3ec:	6563      	strge	r3, [r4, #84]	; 0x54
    b3ee:	81a3      	strhlt	r3, [r4, #12]
    b3f0:	bd10      	pop	{r4, pc}

0000b3f2 <__swrite>:
    b3f2:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    b3f6:	461f      	mov	r7, r3
    b3f8:	898b      	ldrh	r3, [r1, #12]
    b3fa:	05db      	lsls	r3, r3, #23
    b3fc:	4605      	mov	r5, r0
    b3fe:	460c      	mov	r4, r1
    b400:	4616      	mov	r6, r2
    b402:	d505      	bpl.n	b410 <__swrite+0x1e>
    b404:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
    b408:	2302      	movs	r3, #2
    b40a:	2200      	movs	r2, #0
    b40c:	f000 f868 	bl	b4e0 <_lseek_r>
    b410:	89a3      	ldrh	r3, [r4, #12]
    b412:	f9b4 100e 	ldrsh.w	r1, [r4, #14]
    b416:	f423 5380 	bic.w	r3, r3, #4096	; 0x1000
    b41a:	81a3      	strh	r3, [r4, #12]
    b41c:	4632      	mov	r2, r6
    b41e:	463b      	mov	r3, r7
    b420:	4628      	mov	r0, r5
    b422:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
    b426:	f000 b817 	b.w	b458 <_write_r>

0000b42a <__sseek>:
    b42a:	b510      	push	{r4, lr}
    b42c:	460c      	mov	r4, r1
    b42e:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
    b432:	f000 f855 	bl	b4e0 <_lseek_r>
    b436:	1c43      	adds	r3, r0, #1
    b438:	89a3      	ldrh	r3, [r4, #12]
    b43a:	bf15      	itete	ne
    b43c:	6560      	strne	r0, [r4, #84]	; 0x54
    b43e:	f423 5380 	biceq.w	r3, r3, #4096	; 0x1000
    b442:	f443 5380 	orrne.w	r3, r3, #4096	; 0x1000
    b446:	81a3      	strheq	r3, [r4, #12]
    b448:	bf18      	it	ne
    b44a:	81a3      	strhne	r3, [r4, #12]
    b44c:	bd10      	pop	{r4, pc}

0000b44e <__sclose>:
    b44e:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
    b452:	f000 b813 	b.w	b47c <_close_r>
	...

0000b458 <_write_r>:
    b458:	b538      	push	{r3, r4, r5, lr}
    b45a:	4d07      	ldr	r5, [pc, #28]	; (b478 <_write_r+0x20>)
    b45c:	4604      	mov	r4, r0
    b45e:	4608      	mov	r0, r1
    b460:	4611      	mov	r1, r2
    b462:	2200      	movs	r2, #0
    b464:	602a      	str	r2, [r5, #0]
    b466:	461a      	mov	r2, r3
    b468:	f7fd faa6 	bl	89b8 <_write>
    b46c:	1c43      	adds	r3, r0, #1
    b46e:	d102      	bne.n	b476 <_write_r+0x1e>
    b470:	682b      	ldr	r3, [r5, #0]
    b472:	b103      	cbz	r3, b476 <_write_r+0x1e>
    b474:	6023      	str	r3, [r4, #0]
    b476:	bd38      	pop	{r3, r4, r5, pc}
    b478:	20016408 	.word	0x20016408

0000b47c <_close_r>:
    b47c:	b538      	push	{r3, r4, r5, lr}
    b47e:	4d06      	ldr	r5, [pc, #24]	; (b498 <_close_r+0x1c>)
    b480:	2300      	movs	r3, #0
    b482:	4604      	mov	r4, r0
    b484:	4608      	mov	r0, r1
    b486:	602b      	str	r3, [r5, #0]
    b488:	f7f5 fb70 	bl	b6c <_close>
    b48c:	1c43      	adds	r3, r0, #1
    b48e:	d102      	bne.n	b496 <_close_r+0x1a>
    b490:	682b      	ldr	r3, [r5, #0]
    b492:	b103      	cbz	r3, b496 <_close_r+0x1a>
    b494:	6023      	str	r3, [r4, #0]
    b496:	bd38      	pop	{r3, r4, r5, pc}
    b498:	20016408 	.word	0x20016408

0000b49c <_fstat_r>:
    b49c:	b538      	push	{r3, r4, r5, lr}
    b49e:	4d07      	ldr	r5, [pc, #28]	; (b4bc <_fstat_r+0x20>)
    b4a0:	2300      	movs	r3, #0
    b4a2:	4604      	mov	r4, r0
    b4a4:	4608      	mov	r0, r1
    b4a6:	4611      	mov	r1, r2
    b4a8:	602b      	str	r3, [r5, #0]
    b4aa:	f7f5 fb62 	bl	b72 <_fstat>
    b4ae:	1c43      	adds	r3, r0, #1
    b4b0:	d102      	bne.n	b4b8 <_fstat_r+0x1c>
    b4b2:	682b      	ldr	r3, [r5, #0]
    b4b4:	b103      	cbz	r3, b4b8 <_fstat_r+0x1c>
    b4b6:	6023      	str	r3, [r4, #0]
    b4b8:	bd38      	pop	{r3, r4, r5, pc}
    b4ba:	bf00      	nop
    b4bc:	20016408 	.word	0x20016408

0000b4c0 <_isatty_r>:
    b4c0:	b538      	push	{r3, r4, r5, lr}
    b4c2:	4d06      	ldr	r5, [pc, #24]	; (b4dc <_isatty_r+0x1c>)
    b4c4:	2300      	movs	r3, #0
    b4c6:	4604      	mov	r4, r0
    b4c8:	4608      	mov	r0, r1
    b4ca:	602b      	str	r3, [r5, #0]
    b4cc:	f7f5 fb56 	bl	b7c <_isatty>
    b4d0:	1c43      	adds	r3, r0, #1
    b4d2:	d102      	bne.n	b4da <_isatty_r+0x1a>
    b4d4:	682b      	ldr	r3, [r5, #0]
    b4d6:	b103      	cbz	r3, b4da <_isatty_r+0x1a>
    b4d8:	6023      	str	r3, [r4, #0]
    b4da:	bd38      	pop	{r3, r4, r5, pc}
    b4dc:	20016408 	.word	0x20016408

0000b4e0 <_lseek_r>:
    b4e0:	b538      	push	{r3, r4, r5, lr}
    b4e2:	4d07      	ldr	r5, [pc, #28]	; (b500 <_lseek_r+0x20>)
    b4e4:	4604      	mov	r4, r0
    b4e6:	4608      	mov	r0, r1
    b4e8:	4611      	mov	r1, r2
    b4ea:	2200      	movs	r2, #0
    b4ec:	602a      	str	r2, [r5, #0]
    b4ee:	461a      	mov	r2, r3
    b4f0:	f7f5 fb46 	bl	b80 <_lseek>
    b4f4:	1c43      	adds	r3, r0, #1
    b4f6:	d102      	bne.n	b4fe <_lseek_r+0x1e>
    b4f8:	682b      	ldr	r3, [r5, #0]
    b4fa:	b103      	cbz	r3, b4fe <_lseek_r+0x1e>
    b4fc:	6023      	str	r3, [r4, #0]
    b4fe:	bd38      	pop	{r3, r4, r5, pc}
    b500:	20016408 	.word	0x20016408
	...

0000b510 <memchr>:
    b510:	f001 01ff 	and.w	r1, r1, #255	; 0xff
    b514:	2a10      	cmp	r2, #16
    b516:	db2b      	blt.n	b570 <memchr+0x60>
    b518:	f010 0f07 	tst.w	r0, #7
    b51c:	d008      	beq.n	b530 <memchr+0x20>
    b51e:	f810 3b01 	ldrb.w	r3, [r0], #1
    b522:	3a01      	subs	r2, #1
    b524:	428b      	cmp	r3, r1
    b526:	d02d      	beq.n	b584 <memchr+0x74>
    b528:	f010 0f07 	tst.w	r0, #7
    b52c:	b342      	cbz	r2, b580 <memchr+0x70>
    b52e:	d1f6      	bne.n	b51e <memchr+0xe>
    b530:	b4f0      	push	{r4, r5, r6, r7}
    b532:	ea41 2101 	orr.w	r1, r1, r1, lsl #8
    b536:	ea41 4101 	orr.w	r1, r1, r1, lsl #16
    b53a:	f022 0407 	bic.w	r4, r2, #7
    b53e:	f07f 0700 	mvns.w	r7, #0
    b542:	2300      	movs	r3, #0
    b544:	e8f0 5602 	ldrd	r5, r6, [r0], #8
    b548:	3c08      	subs	r4, #8
    b54a:	ea85 0501 	eor.w	r5, r5, r1
    b54e:	ea86 0601 	eor.w	r6, r6, r1
    b552:	fa85 f547 	uadd8	r5, r5, r7
    b556:	faa3 f587 	sel	r5, r3, r7
    b55a:	fa86 f647 	uadd8	r6, r6, r7
    b55e:	faa5 f687 	sel	r6, r5, r7
    b562:	b98e      	cbnz	r6, b588 <memchr+0x78>
    b564:	d1ee      	bne.n	b544 <memchr+0x34>
    b566:	bcf0      	pop	{r4, r5, r6, r7}
    b568:	f001 01ff 	and.w	r1, r1, #255	; 0xff
    b56c:	f002 0207 	and.w	r2, r2, #7
    b570:	b132      	cbz	r2, b580 <memchr+0x70>
    b572:	f810 3b01 	ldrb.w	r3, [r0], #1
    b576:	3a01      	subs	r2, #1
    b578:	ea83 0301 	eor.w	r3, r3, r1
    b57c:	b113      	cbz	r3, b584 <memchr+0x74>
    b57e:	d1f8      	bne.n	b572 <memchr+0x62>
    b580:	2000      	movs	r0, #0
    b582:	4770      	bx	lr
    b584:	3801      	subs	r0, #1
    b586:	4770      	bx	lr
    b588:	2d00      	cmp	r5, #0
    b58a:	bf06      	itte	eq
    b58c:	4635      	moveq	r5, r6
    b58e:	3803      	subeq	r0, #3
    b590:	3807      	subne	r0, #7
    b592:	f015 0f01 	tst.w	r5, #1
    b596:	d107      	bne.n	b5a8 <memchr+0x98>
    b598:	3001      	adds	r0, #1
    b59a:	f415 7f80 	tst.w	r5, #256	; 0x100
    b59e:	bf02      	ittt	eq
    b5a0:	3001      	addeq	r0, #1
    b5a2:	f415 3fc0 	tsteq.w	r5, #98304	; 0x18000
    b5a6:	3001      	addeq	r0, #1
    b5a8:	bcf0      	pop	{r4, r5, r6, r7}
    b5aa:	3801      	subs	r0, #1
    b5ac:	4770      	bx	lr
    b5ae:	bf00      	nop

0000b5b0 <__malloc_lock>:
    b5b0:	4801      	ldr	r0, [pc, #4]	; (b5b8 <__malloc_lock+0x8>)
    b5b2:	f7ff bac3 	b.w	ab3c <__retarget_lock_acquire_recursive>
    b5b6:	bf00      	nop
    b5b8:	200163fc 	.word	0x200163fc

0000b5bc <__malloc_unlock>:
    b5bc:	4801      	ldr	r0, [pc, #4]	; (b5c4 <__malloc_unlock+0x8>)
    b5be:	f7ff babe 	b.w	ab3e <__retarget_lock_release_recursive>
    b5c2:	bf00      	nop
    b5c4:	200163fc 	.word	0x200163fc

0000b5c8 <_read_r>:
    b5c8:	b538      	push	{r3, r4, r5, lr}
    b5ca:	4d07      	ldr	r5, [pc, #28]	; (b5e8 <_read_r+0x20>)
    b5cc:	4604      	mov	r4, r0
    b5ce:	4608      	mov	r0, r1
    b5d0:	4611      	mov	r1, r2
    b5d2:	2200      	movs	r2, #0
    b5d4:	602a      	str	r2, [r5, #0]
    b5d6:	461a      	mov	r2, r3
    b5d8:	f7f5 fccc 	bl	f74 <_read>
    b5dc:	1c43      	adds	r3, r0, #1
    b5de:	d102      	bne.n	b5e6 <_read_r+0x1e>
    b5e0:	682b      	ldr	r3, [r5, #0]
    b5e2:	b103      	cbz	r3, b5e6 <_read_r+0x1e>
    b5e4:	6023      	str	r3, [r4, #0]
    b5e6:	bd38      	pop	{r3, r4, r5, pc}
    b5e8:	20016408 	.word	0x20016408
    b5ec:	682f2e2e 	.word	0x682f2e2e
    b5f0:	732f6c61 	.word	0x732f6c61
    b5f4:	682f6372 	.word	0x682f6372
    b5f8:	755f6c61 	.word	0x755f6c61
    b5fc:	74726173 	.word	0x74726173
    b600:	6e79735f 	.word	0x6e79735f
    b604:	00632e63 	.word	0x00632e63
    b608:	652f2e2e 	.word	0x652f2e2e
    b60c:	72656874 	.word	0x72656874
    b610:	5f74656e 	.word	0x5f74656e
    b614:	2f796870 	.word	0x2f796870
    b618:	65687465 	.word	0x65687465
    b61c:	74656e72 	.word	0x74656e72
    b620:	7968705f 	.word	0x7968705f
    b624:	632e      	.short	0x632e
	...

0000b627 <CSWTCH.10>:
    b627:	2438 0010 5049 415f 4444 2052 2020 3a20     8$..IP_ADDR    :
    b637:	2520 0d73 000a 454e 5f54 414d 4b53 2020      %s...NET_MASK  
    b647:	3a20 2520 0d73 000a 4147 4554 4157 5f59      : %s...GATEWAY_
    b657:	5049 3a20 2520 0d73 000a 0a0d 6f53 6b63     IP : %s.....Sock
    b667:	7465 4120 4950 6920 706d 656c 656d 746e     et API implement
    b677:	7461 6f69 0d6e                               ation..

0000b67e <memp_num>:
    b67e:	0004 0005 0008 0010 0005 000f 0002 0004     ................
    b68e:	0008 0008 0005 0010 0010                    ..........

0000b698 <memp_sizes>:
    b698:	0020 0098 001c 0010 0020 0018 0010 002c      ....... .....,.
    b6a8:	0014 0014 0010 0010 05fc 2e2e 682f 6c61     ............/hal
    b6b8:	732f 6372 682f 6c61 6d5f 6361 615f 7973     /src/hal_mac_asy
    b6c8:	636e 632e ff00 ffff ffff 00ff 0000 0000     nc.c............
	...

0000b6da <ethbroadcast>:
    b6da:	ffff ffff ffff                              ......

0000b6e0 <ethzero>:
    b6e0:	0000 0000 0000 2e2e 682f 6c61 732f 6372     ......../hal/src
    b6f0:	682f 6c61 695f 2e6f 0063 4c43 534f 4445     /hal_io.c.CLOSED
    b700:	4c00 5349 4554 004e 5953 5f4e 4553 544e     .LISTEN.SYN_SENT
    b710:	5300 4e59 525f 5643 0044 5345 4154 4c42     .SYN_RCVD.ESTABL
    b720:	5349 4548 0044 4946 5f4e 4157 5449 315f     ISHED.FIN_WAIT_1
    b730:	4600 4e49 575f 4941 5f54 0032 4c43 534f     .FIN_WAIT_2.CLOS
    b740:	5f45 4157 5449 4300 4f4c 4953 474e 4c00     E_WAIT.CLOSING.L
    b750:	5341 5f54 4341 004b 4954 454d 575f 4941     AST_ACK.TIME_WAI
    b760:	0054 0000                                   T...

0000b764 <tcp_pcb_lists>:
    b764:	4944 2001 493c 2001 4950 2001 4958 2001     DI. <I. PI. XI. 

0000b774 <tcp_persist_backoff>:
    b774:	0603 180c 6030                               ....0`x

0000b77b <tcp_backoff>:
    b77b:	0201 0403 0605 0707 0707 0707                .............

0000b788 <tcp_state_str>:
    b788:	b6fa 0000 b701 0000 b708 0000 b711 0000     ................
    b798:	b71a 0000 b726 0000 b731 0000 b73c 0000     ....&...1...<...
    b7a8:	b747 0000 b74f 0000 b758 0000 2e2e 682f     G...O...X...../h
    b7b8:	6c70 732f 7265 6f63 2f6d 7068 5f6c 6573     pl/sercom/hpl_se
    b7c8:	6372 6d6f 632e 0000 3000 4000 3400 4000     rcom.c...0.@.4.@
    b7d8:	2000 4101 4000 4101 0000 4300 0400 4300     . .A.@.A...C...C
    b7e8:	0800 4300 0c00 4300                         ...C...C

0000b7f0 <_i2cms>:
	...

0000b808 <sercomspi_regs>:
	...
    b818:	0d00 450a 6874 7265 656e 2074 696c 6b6e     ...Ethernet link
    b828:	7520 0d70 0d0a 4700 414d 0043 654c 0064      up....GMAC.Led.
    b838:	0000 0000 7620 6d54 2072 7653 0063 4547     .... vTmr Svc.GE
    b848:	0054 7445 6568 6e72 7465 625f 7361 6369     T.Ethernet_basic
	...

0000b859 <http_html_hdr>:
    b859:	5448 5054 312f 302e 3220 3030 4f20 0d4b     HTTP/1.0 200 OK.
    b869:	430a 6e6f 6574 746e 742d 7079 3a65 7420     .Content-type: t
    b879:	7865 2f74 7468 6c6d 0a0d 0a0d                ext/html.....

0000b886 <socket_webpage>:
    b886:	683c 6d74 3e6c 3c20 6568 6461 3c3e 6974     <html> <head><ti
    b896:	6c74 3e65 6142 6973 2063 6577 7062 6761     tle>Basic webpag
    b8a6:	3c65 742f 7469 656c 3c3e 682f 6165 3e64     e</title></head>
    b8b6:	3c20 6f62 7964 203e 6557 636c 6d6f 2065      <body> Welcome 
    b8c6:	6f74 7920 756f 2072 6162 6973 2063 6577     to your basic we
    b8d6:	7062 6761 2065 7375 6e69 2067 6f53 6b63     bpage using Sock
    b8e6:	7465 4120 4950 202e 2f3c 6f62 7964 203e     et API. </body> 
    b8f6:	2f3c 7468 6c6d 003e 2e2e 682f 6c70 672f     </html>.../hpl/g
    b906:	616d 2f63 7068 5f6c 6d67 6361 632e 0000     mac/hpl_gmac.c..
	...

0000b918 <ip_addr_broadcast>:
    b918:	ffff ffff                                   ....

0000b91c <ip_addr_any>:
    b91c:	0000 0000 4449 454c 0900 6325 2509 0975     ....IDLE..%c.%u.
    b92c:	7525 2509 0d75 000a                         %u.%u...

0000b934 <err_to_errno_table>:
    b934:	0000 0000 000c 0000 0069 0000 000b 0000     ........i.......
    b944:	0071 0000 0073 0000 0016 0000 000b 0000     q...s...........
    b954:	0062 0000 0072 0000 0067 0000 0068 0000     b...r...g...h...
    b964:	006b 0000 006b 0000 0005 0000 ffff ffff     k...k...........
    b974:	6374 6970 5f70 6874 6572 6461 0000 0000     tcpip_thread....

0000b984 <_global_impure_ptr>:
    b984:	0020 2000                                    .. 

0000b988 <__sf_fake_stderr>:
	...

0000b9a8 <__sf_fake_stdin>:
	...

0000b9c8 <__sf_fake_stdout>:
	...
    b9e8:	2d23 2b30 0020 6c68 004c 6665 4567 4746     #-0+ .hlL.efgEFG
    b9f8:	3000 3231 3433 3635 3837 4139 4342 4544     .0123456789ABCDE
    ba08:	0046 3130 3332 3534 3736 3938 6261 6463     F.0123456789abcd
    ba18:	6665 0000                                   ef..

0000ba1c <_init>:
    ba1c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    ba1e:	bf00      	nop
    ba20:	bcf8      	pop	{r3, r4, r5, r6, r7}
    ba22:	bc08      	pop	{r3}
    ba24:	469e      	mov	lr, r3
    ba26:	4770      	bx	lr

0000ba28 <__frame_dummy_init_array_entry>:
    ba28:	0289 0000                                   ....

0000ba2c <_fini>:
    ba2c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    ba2e:	bf00      	nop
    ba30:	bcf8      	pop	{r3, r4, r5, r6, r7}
    ba32:	bc08      	pop	{r3}
    ba34:	469e      	mov	lr, r3
    ba36:	4770      	bx	lr

0000ba38 <__do_global_dtors_aux_fini_array_entry>:
    ba38:	0265 0000                                   e...
