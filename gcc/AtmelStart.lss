
AtmelStart.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         0000abac  00000000  00000000  00010000  2**4
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .relocate     0000007c  20000000  0000abac  00020000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bkupram      00000000  47000000  47000000  0002007c  2**0
                  CONTENTS
  3 .qspi         00000000  04000000  04000000  0002007c  2**0
                  CONTENTS
  4 .bss          0001632c  20000080  0000ac40  00020080  2**5
                  ALLOC
  5 .stack        00010004  200163ac  00020f6c  00020080  2**0
                  ALLOC
  6 .ARM.attributes 0000002e  00000000  00000000  0002007c  2**0
                  CONTENTS, READONLY
  7 .comment      00000049  00000000  00000000  000200aa  2**0
                  CONTENTS, READONLY
  8 .debug_info   00043d9a  00000000  00000000  000200f3  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
  9 .debug_abbrev 00008ad0  00000000  00000000  00063e8d  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 10 .debug_loc    0001be1c  00000000  00000000  0006c95d  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 11 .debug_aranges 000019c0  00000000  00000000  00088779  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 12 .debug_ranges 00002e50  00000000  00000000  0008a139  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 13 .debug_macro  0003eb14  00000000  00000000  0008cf89  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 14 .debug_line   00031dee  00000000  00000000  000cba9d  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 15 .debug_str    0012e99f  00000000  00000000  000fd88b  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 16 .debug_frame  000054d8  00000000  00000000  0022c22c  2**2
                  CONTENTS, READONLY, DEBUGGING, OCTETS

Disassembly of section .text:

00000000 <exception_table>:
       0:	b0 63 02 20 e5 47 00 00 e1 47 00 00 e1 47 00 00     .c. .G...G...G..
      10:	e1 47 00 00 e1 47 00 00 e1 47 00 00 00 00 00 00     .G...G...G......
	...
      2c:	d5 8e 00 00 e1 47 00 00 00 00 00 00 5d 8f 00 00     .....G......]...
      3c:	bd 8f 00 00 e1 47 00 00 e1 47 00 00 e1 47 00 00     .....G...G...G..
      4c:	e1 47 00 00 e1 47 00 00 e1 47 00 00 e1 47 00 00     .G...G...G...G..
      5c:	e1 47 00 00 e1 47 00 00 e1 47 00 00 e1 47 00 00     .G...G...G...G..
      6c:	e1 47 00 00 e1 47 00 00 e1 47 00 00 e1 47 00 00     .G...G...G...G..
      7c:	e1 47 00 00 e1 47 00 00 e1 47 00 00 e1 47 00 00     .G...G...G...G..
      8c:	e1 47 00 00 e1 47 00 00 e1 47 00 00 e1 47 00 00     .G...G...G...G..
      9c:	e1 47 00 00 e1 47 00 00 e1 47 00 00 e1 47 00 00     .G...G...G...G..
      ac:	e1 47 00 00 e1 47 00 00 e1 47 00 00 e1 47 00 00     .G...G...G...G..
      bc:	e1 47 00 00 e1 47 00 00 e1 47 00 00 e1 47 00 00     .G...G...G...G..
      cc:	e1 47 00 00 e1 47 00 00 e1 47 00 00 e1 47 00 00     .G...G...G...G..
      dc:	e1 47 00 00 e1 47 00 00 e1 47 00 00 00 00 00 00     .G...G...G......
	...
      f4:	71 7a 00 00 e1 47 00 00 e1 47 00 00 e1 47 00 00     qz...G...G...G..
     104:	e1 47 00 00 e1 47 00 00 e1 47 00 00 e1 47 00 00     .G...G...G...G..
     114:	e1 47 00 00 e1 47 00 00 e1 47 00 00 e1 47 00 00     .G...G...G...G..
     124:	e1 47 00 00 e1 47 00 00 e1 47 00 00 e1 47 00 00     .G...G...G...G..
     134:	e1 47 00 00 e1 47 00 00 e1 47 00 00 e1 47 00 00     .G...G...G...G..
     144:	e1 47 00 00 e1 47 00 00 e1 47 00 00 e1 47 00 00     .G...G...G...G..
     154:	e1 47 00 00 e1 47 00 00 e1 47 00 00 e1 47 00 00     .G...G...G...G..
     164:	e1 47 00 00 e1 47 00 00 e1 47 00 00 e1 47 00 00     .G...G...G...G..
     174:	e1 47 00 00 e1 47 00 00 e1 47 00 00 e1 47 00 00     .G...G...G...G..
     184:	e1 47 00 00 e1 47 00 00 e1 47 00 00 65 76 00 00     .G...G...G..ev..
     194:	e1 47 00 00 e1 47 00 00 e1 47 00 00 e1 47 00 00     .G...G...G...G..
     1a4:	e1 47 00 00 e1 47 00 00 e1 47 00 00 e1 47 00 00     .G...G...G...G..
     1b4:	e1 47 00 00 e1 47 00 00 e1 47 00 00 e1 47 00 00     .G...G...G...G..
     1c4:	e1 47 00 00 e1 47 00 00 e1 47 00 00 e1 47 00 00     .G...G...G...G..
     1d4:	e1 47 00 00 e1 47 00 00 e1 47 00 00 e1 47 00 00     .G...G...G...G..
     1e4:	e1 47 00 00 e1 47 00 00 e1 47 00 00 e1 47 00 00     .G...G...G...G..
     1f4:	e1 47 00 00 e1 47 00 00 e1 47 00 00 e1 47 00 00     .G...G...G...G..
     204:	e1 47 00 00 e1 47 00 00 e1 47 00 00 e1 47 00 00     .G...G...G...G..
     214:	e1 47 00 00 e1 47 00 00 e1 47 00 00 e1 47 00 00     .G...G...G...G..
     224:	e1 47 00 00 e1 47 00 00 e1 47 00 00 e1 47 00 00     .G...G...G...G..
     234:	e1 47 00 00 e1 47 00 00 e1 47 00 00 e1 47 00 00     .G...G...G...G..
     244:	e1 47 00 00 e1 47 00 00 e1 47 00 00 e1 47 00 00     .G...G...G...G..
     254:	e1 47 00 00 e1 47 00 00 e1 47 00 00 e1 47 00 00     .G...G...G...G..

00000264 <__do_global_dtors_aux>:
     264:	b510      	push	{r4, lr}
     266:	4c05      	ldr	r4, [pc, #20]	; (27c <__do_global_dtors_aux+0x18>)
     268:	7823      	ldrb	r3, [r4, #0]
     26a:	b933      	cbnz	r3, 27a <__do_global_dtors_aux+0x16>
     26c:	4b04      	ldr	r3, [pc, #16]	; (280 <__do_global_dtors_aux+0x1c>)
     26e:	b113      	cbz	r3, 276 <__do_global_dtors_aux+0x12>
     270:	4804      	ldr	r0, [pc, #16]	; (284 <__do_global_dtors_aux+0x20>)
     272:	f3af 8000 	nop.w
     276:	2301      	movs	r3, #1
     278:	7023      	strb	r3, [r4, #0]
     27a:	bd10      	pop	{r4, pc}
     27c:	20000080 	.word	0x20000080
     280:	00000000 	.word	0x00000000
     284:	0000abac 	.word	0x0000abac

00000288 <frame_dummy>:
     288:	b508      	push	{r3, lr}
     28a:	4b03      	ldr	r3, [pc, #12]	; (298 <frame_dummy+0x10>)
     28c:	b11b      	cbz	r3, 296 <frame_dummy+0xe>
     28e:	4903      	ldr	r1, [pc, #12]	; (29c <frame_dummy+0x14>)
     290:	4803      	ldr	r0, [pc, #12]	; (2a0 <frame_dummy+0x18>)
     292:	f3af 8000 	nop.w
     296:	bd08      	pop	{r3, pc}
     298:	00000000 	.word	0x00000000
     29c:	20000084 	.word	0x20000084
     2a0:	0000abac 	.word	0x0000abac

000002a4 <stdio_io_init>:

/** IO descriptor for STDIO access. */
static struct io_descriptor *stdio_io = NULL;

void stdio_io_init(struct io_descriptor *io)
{
     2a4:	b570      	push	{r4, r5, r6, lr}
#if defined(__GNUC__)
	/* Specify that stdout and stdin should not be buffered. */
	setbuf(stdout, NULL);
     2a6:	4e07      	ldr	r6, [pc, #28]	; (2c4 <stdio_io_init+0x20>)
     2a8:	4d07      	ldr	r5, [pc, #28]	; (2c8 <stdio_io_init+0x24>)
     2aa:	6833      	ldr	r3, [r6, #0]
{
     2ac:	4604      	mov	r4, r0
	setbuf(stdout, NULL);
     2ae:	2100      	movs	r1, #0
     2b0:	6898      	ldr	r0, [r3, #8]
     2b2:	47a8      	blx	r5
	setbuf(stdin, NULL);
     2b4:	6833      	ldr	r3, [r6, #0]
     2b6:	2100      	movs	r1, #0
     2b8:	6858      	ldr	r0, [r3, #4]
     2ba:	47a8      	blx	r5
	 * and AVR GCC library:
	 * - printf() emits one character at a time.
	 * - getchar() requests only 1 byte to exit.
	 */
#endif
	stdio_io = io;
     2bc:	4b03      	ldr	r3, [pc, #12]	; (2cc <stdio_io_init+0x28>)
     2be:	601c      	str	r4, [r3, #0]
}
     2c0:	bd70      	pop	{r4, r5, r6, pc}
     2c2:	bf00      	nop
     2c4:	20000018 	.word	0x20000018
     2c8:	000095ed 	.word	0x000095ed
     2cc:	2000009c 	.word	0x2000009c

000002d0 <stdio_io_read>:
	stdio_io = io;
}

int32_t stdio_io_read(uint8_t *buf, const int32_t len)
{
	if (stdio_io == NULL) {
     2d0:	4a04      	ldr	r2, [pc, #16]	; (2e4 <stdio_io_read+0x14>)
{
     2d2:	4603      	mov	r3, r0
	if (stdio_io == NULL) {
     2d4:	6810      	ldr	r0, [r2, #0]
     2d6:	b118      	cbz	r0, 2e0 <stdio_io_read+0x10>
		return 0;
	}
	return io_read(stdio_io, buf, len);
     2d8:	b28a      	uxth	r2, r1
     2da:	4619      	mov	r1, r3
     2dc:	4b02      	ldr	r3, [pc, #8]	; (2e8 <stdio_io_read+0x18>)
     2de:	4718      	bx	r3
}
     2e0:	4770      	bx	lr
     2e2:	bf00      	nop
     2e4:	2000009c 	.word	0x2000009c
     2e8:	000053bd 	.word	0x000053bd

000002ec <stdio_io_write>:

int32_t stdio_io_write(const uint8_t *buf, const int32_t len)
{
	if (stdio_io == NULL) {
     2ec:	4a04      	ldr	r2, [pc, #16]	; (300 <stdio_io_write+0x14>)
{
     2ee:	4603      	mov	r3, r0
	if (stdio_io == NULL) {
     2f0:	6810      	ldr	r0, [r2, #0]
     2f2:	b118      	cbz	r0, 2fc <stdio_io_write+0x10>
		return 0;
	}
	return io_write(stdio_io, buf, len);
     2f4:	b28a      	uxth	r2, r1
     2f6:	4619      	mov	r1, r3
     2f8:	4b02      	ldr	r3, [pc, #8]	; (304 <stdio_io_write+0x18>)
     2fa:	4718      	bx	r3
}
     2fc:	4770      	bx	lr
     2fe:	bf00      	nop
     300:	2000009c 	.word	0x2000009c
     304:	0000538d 	.word	0x0000538d

00000308 <prvCopyDataToQueue>:

#endif /* configUSE_TRACE_FACILITY */
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue(Queue_t *const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition)
{
     308:	b570      	push	{r4, r5, r6, lr}
     30a:	4615      	mov	r5, r2
	BaseType_t xReturn = pdFALSE;

	if (pxQueue->uxItemSize == (UBaseType_t)0) {
     30c:	6c02      	ldr	r2, [r0, #64]	; 0x40
{
     30e:	4604      	mov	r4, r0
	if (pxQueue->uxItemSize == (UBaseType_t)0) {
     310:	b96a      	cbnz	r2, 32e <prvCopyDataToQueue+0x26>
#if (configUSE_MUTEXES == 1)
		{
			if (pxQueue->uxQueueType == queueQUEUE_IS_MUTEX) {
     312:	6806      	ldr	r6, [r0, #0]
     314:	b10e      	cbz	r6, 31a <prvCopyDataToQueue+0x12>
	BaseType_t xReturn = pdFALSE;
     316:	2500      	movs	r5, #0
     318:	e004      	b.n	324 <prvCopyDataToQueue+0x1c>
				/* The mutex is no longer being held. */
				xReturn                = xTaskPriorityDisinherit((void *)pxQueue->pxMutexHolder);
     31a:	6840      	ldr	r0, [r0, #4]
     31c:	4b16      	ldr	r3, [pc, #88]	; (378 <prvCopyDataToQueue+0x70>)
     31e:	4798      	blx	r3
				pxQueue->pxMutexHolder = NULL;
     320:	6066      	str	r6, [r4, #4]
				xReturn                = xTaskPriorityDisinherit((void *)pxQueue->pxMutexHolder);
     322:	4605      	mov	r5, r0
		} else {
			mtCOVERAGE_TEST_MARKER();
		}
	}

	++(pxQueue->uxMessagesWaiting);
     324:	6ba3      	ldr	r3, [r4, #56]	; 0x38
     326:	3301      	adds	r3, #1
     328:	63a3      	str	r3, [r4, #56]	; 0x38

	return xReturn;
}
     32a:	4628      	mov	r0, r5
     32c:	bd70      	pop	{r4, r5, r6, pc}
	} else if (xPosition == queueSEND_TO_BACK) {
     32e:	4b13      	ldr	r3, [pc, #76]	; (37c <prvCopyDataToQueue+0x74>)
     330:	b95d      	cbnz	r5, 34a <prvCopyDataToQueue+0x42>
		(void)memcpy((void *)pxQueue->pcWriteTo,
     332:	6880      	ldr	r0, [r0, #8]
     334:	4798      	blx	r3
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
     336:	68a3      	ldr	r3, [r4, #8]
     338:	6c22      	ldr	r2, [r4, #64]	; 0x40
     33a:	4413      	add	r3, r2
		if (pxQueue->pcWriteTo >= pxQueue->pcTail) /*lint !e946 MISRA exception justified as comparison of pointers is
     33c:	6862      	ldr	r2, [r4, #4]
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
     33e:	60a3      	str	r3, [r4, #8]
		if (pxQueue->pcWriteTo >= pxQueue->pcTail) /*lint !e946 MISRA exception justified as comparison of pointers is
     340:	4293      	cmp	r3, r2
     342:	d3e8      	bcc.n	316 <prvCopyDataToQueue+0xe>
			pxQueue->pcWriteTo = pxQueue->pcHead;
     344:	6823      	ldr	r3, [r4, #0]
     346:	60a3      	str	r3, [r4, #8]
     348:	e7ec      	b.n	324 <prvCopyDataToQueue+0x1c>
		(void)memcpy((void *)pxQueue->u.pcReadFrom,
     34a:	68c0      	ldr	r0, [r0, #12]
     34c:	4798      	blx	r3
		pxQueue->u.pcReadFrom -= pxQueue->uxItemSize;
     34e:	6c22      	ldr	r2, [r4, #64]	; 0x40
     350:	68e3      	ldr	r3, [r4, #12]
     352:	4251      	negs	r1, r2
     354:	1a9b      	subs	r3, r3, r2
		if (pxQueue->u.pcReadFrom
     356:	6822      	ldr	r2, [r4, #0]
		pxQueue->u.pcReadFrom -= pxQueue->uxItemSize;
     358:	60e3      	str	r3, [r4, #12]
		if (pxQueue->u.pcReadFrom
     35a:	4293      	cmp	r3, r2
			pxQueue->u.pcReadFrom = (pxQueue->pcTail - pxQueue->uxItemSize);
     35c:	bf3e      	ittt	cc
     35e:	6863      	ldrcc	r3, [r4, #4]
     360:	185b      	addcc	r3, r3, r1
     362:	60e3      	strcc	r3, [r4, #12]
		if (xPosition == queueOVERWRITE) {
     364:	2d02      	cmp	r5, #2
     366:	d1d6      	bne.n	316 <prvCopyDataToQueue+0xe>
			if (pxQueue->uxMessagesWaiting > (UBaseType_t)0) {
     368:	6ba3      	ldr	r3, [r4, #56]	; 0x38
     36a:	2b00      	cmp	r3, #0
     36c:	d0d3      	beq.n	316 <prvCopyDataToQueue+0xe>
				--(pxQueue->uxMessagesWaiting);
     36e:	6ba3      	ldr	r3, [r4, #56]	; 0x38
     370:	3b01      	subs	r3, #1
     372:	63a3      	str	r3, [r4, #56]	; 0x38
     374:	e7cf      	b.n	316 <prvCopyDataToQueue+0xe>
     376:	bf00      	nop
     378:	00008511 	.word	0x00008511
     37c:	000094a5 	.word	0x000094a5

00000380 <prvNotifyQueueSetContainer>:
	/*-----------------------------------------------------------*/

#if (configUSE_QUEUE_SETS == 1)

static BaseType_t prvNotifyQueueSetContainer(const Queue_t *const pxQueue, const BaseType_t xCopyPosition)
{
     380:	b537      	push	{r0, r1, r2, r4, r5, lr}
	Queue_t *  pxQueueSetContainer = pxQueue->pxQueueSetContainer;
     382:	6d44      	ldr	r4, [r0, #84]	; 0x54
{
     384:	9001      	str	r0, [sp, #4]
     386:	460a      	mov	r2, r1
	BaseType_t xReturn             = pdFALSE;

	/* This function must be called form a critical section. */

	configASSERT(pxQueueSetContainer);
     388:	b944      	cbnz	r4, 39c <prvNotifyQueueSetContainer+0x1c>

portFORCE_INLINE static void vPortRaiseBASEPRI(void)
{
	uint32_t ulNewBASEPRI;

	__asm volatile("	mov %0, %1												\n"
     38a:	f04f 0380 	mov.w	r3, #128	; 0x80
     38e:	f383 8811 	msr	BASEPRI, r3
     392:	f3bf 8f6f 	isb	sy
     396:	f3bf 8f4f 	dsb	sy
     39a:	e7fe      	b.n	39a <prvNotifyQueueSetContainer+0x1a>
	configASSERT(pxQueueSetContainer->uxMessagesWaiting < pxQueueSetContainer->uxLength);
     39c:	6ba1      	ldr	r1, [r4, #56]	; 0x38
     39e:	6be3      	ldr	r3, [r4, #60]	; 0x3c
     3a0:	4299      	cmp	r1, r3
     3a2:	d308      	bcc.n	3b6 <prvNotifyQueueSetContainer+0x36>
     3a4:	f04f 0380 	mov.w	r3, #128	; 0x80
     3a8:	f383 8811 	msr	BASEPRI, r3
     3ac:	f3bf 8f6f 	isb	sy
     3b0:	f3bf 8f4f 	dsb	sy
     3b4:	e7fe      	b.n	3b4 <prvNotifyQueueSetContainer+0x34>

	if (pxQueueSetContainer->uxMessagesWaiting < pxQueueSetContainer->uxLength) {
     3b6:	6ba1      	ldr	r1, [r4, #56]	; 0x38
     3b8:	428b      	cmp	r3, r1
     3ba:	d917      	bls.n	3ec <prvNotifyQueueSetContainer+0x6c>
		traceQUEUE_SEND(pxQueueSetContainer);

		/* The data copied is the handle of the queue that contains data. */
		xReturn = prvCopyDataToQueue(pxQueueSetContainer, &pxQueue, xCopyPosition);
     3bc:	4b0c      	ldr	r3, [pc, #48]	; (3f0 <prvNotifyQueueSetContainer+0x70>)
     3be:	a901      	add	r1, sp, #4
     3c0:	4620      	mov	r0, r4
     3c2:	4798      	blx	r3

		if (pxQueueSetContainer->xTxLock == queueUNLOCKED) {
     3c4:	6ca3      	ldr	r3, [r4, #72]	; 0x48
     3c6:	3301      	adds	r3, #1
		xReturn = prvCopyDataToQueue(pxQueueSetContainer, &pxQueue, xCopyPosition);
     3c8:	4605      	mov	r5, r0
		if (pxQueueSetContainer->xTxLock == queueUNLOCKED) {
     3ca:	d10b      	bne.n	3e4 <prvNotifyQueueSetContainer+0x64>
			if (listLIST_IS_EMPTY(&(pxQueueSetContainer->xTasksWaitingToReceive)) == pdFALSE) {
     3cc:	6a63      	ldr	r3, [r4, #36]	; 0x24
     3ce:	b133      	cbz	r3, 3de <prvNotifyQueueSetContainer+0x5e>
				if (xTaskRemoveFromEventList(&(pxQueueSetContainer->xTasksWaitingToReceive)) != pdFALSE) {
     3d0:	4b08      	ldr	r3, [pc, #32]	; (3f4 <prvNotifyQueueSetContainer+0x74>)
     3d2:	f104 0024 	add.w	r0, r4, #36	; 0x24
     3d6:	4798      	blx	r3
					/* The task waiting has a higher priority. */
					xReturn = pdTRUE;
     3d8:	2800      	cmp	r0, #0
     3da:	bf18      	it	ne
     3dc:	2501      	movne	r5, #1
	} else {
		mtCOVERAGE_TEST_MARKER();
	}

	return xReturn;
}
     3de:	4628      	mov	r0, r5
     3e0:	b003      	add	sp, #12
     3e2:	bd30      	pop	{r4, r5, pc}
			(pxQueueSetContainer->xTxLock)++;
     3e4:	6ca3      	ldr	r3, [r4, #72]	; 0x48
     3e6:	3301      	adds	r3, #1
     3e8:	64a3      	str	r3, [r4, #72]	; 0x48
     3ea:	e7f8      	b.n	3de <prvNotifyQueueSetContainer+0x5e>
	BaseType_t xReturn             = pdFALSE;
     3ec:	2500      	movs	r5, #0
	return xReturn;
     3ee:	e7f6      	b.n	3de <prvNotifyQueueSetContainer+0x5e>
     3f0:	00000309 	.word	0x00000309
     3f4:	00008341 	.word	0x00008341

000003f8 <prvCopyDataFromQueue>:
{
     3f8:	4603      	mov	r3, r0
     3fa:	b410      	push	{r4}
	if (pxQueue->uxItemSize != (UBaseType_t)0) {
     3fc:	6c1a      	ldr	r2, [r3, #64]	; 0x40
{
     3fe:	4608      	mov	r0, r1
	if (pxQueue->uxItemSize != (UBaseType_t)0) {
     400:	b16a      	cbz	r2, 41e <prvCopyDataFromQueue+0x26>
		pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
     402:	68dc      	ldr	r4, [r3, #12]
		if (pxQueue->u.pcReadFrom >= pxQueue->pcTail) /*lint !e946 MISRA exception justified as use of the relational
     404:	6859      	ldr	r1, [r3, #4]
		pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
     406:	4414      	add	r4, r2
		if (pxQueue->u.pcReadFrom >= pxQueue->pcTail) /*lint !e946 MISRA exception justified as use of the relational
     408:	428c      	cmp	r4, r1
			pxQueue->u.pcReadFrom = pxQueue->pcHead;
     40a:	bf28      	it	cs
     40c:	6819      	ldrcs	r1, [r3, #0]
		pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
     40e:	60dc      	str	r4, [r3, #12]
			pxQueue->u.pcReadFrom = pxQueue->pcHead;
     410:	bf28      	it	cs
     412:	60d9      	strcs	r1, [r3, #12]
		(void)memcpy((void *)pvBuffer,
     414:	68d9      	ldr	r1, [r3, #12]
}
     416:	f85d 4b04 	ldr.w	r4, [sp], #4
		(void)memcpy((void *)pvBuffer,
     41a:	4b02      	ldr	r3, [pc, #8]	; (424 <prvCopyDataFromQueue+0x2c>)
     41c:	4718      	bx	r3
}
     41e:	f85d 4b04 	ldr.w	r4, [sp], #4
     422:	4770      	bx	lr
     424:	000094a5 	.word	0x000094a5

00000428 <prvUnlockQueue>:
{
     428:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	taskENTER_CRITICAL();
     42c:	4e1f      	ldr	r6, [pc, #124]	; (4ac <prvUnlockQueue+0x84>)
						if (xTaskRemoveFromEventList(&(pxQueue->xTasksWaitingToReceive)) != pdFALSE) {
     42e:	4d20      	ldr	r5, [pc, #128]	; (4b0 <prvUnlockQueue+0x88>)
						vTaskMissedYield();
     430:	4f20      	ldr	r7, [pc, #128]	; (4b4 <prvUnlockQueue+0x8c>)
					if (prvNotifyQueueSetContainer(pxQueue, queueSEND_TO_BACK) == pdTRUE) {
     432:	f8df 8088 	ldr.w	r8, [pc, #136]	; 4bc <prvUnlockQueue+0x94>
{
     436:	4604      	mov	r4, r0
	taskENTER_CRITICAL();
     438:	47b0      	blx	r6
		while (pxQueue->xTxLock > queueLOCKED_UNMODIFIED) {
     43a:	6ca3      	ldr	r3, [r4, #72]	; 0x48
     43c:	2b00      	cmp	r3, #0
     43e:	dc14      	bgt.n	46a <prvUnlockQueue+0x42>
		pxQueue->xTxLock = queueUNLOCKED;
     440:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
     444:	64a3      	str	r3, [r4, #72]	; 0x48
	taskEXIT_CRITICAL();
     446:	4d1c      	ldr	r5, [pc, #112]	; (4b8 <prvUnlockQueue+0x90>)
				if (xTaskRemoveFromEventList(&(pxQueue->xTasksWaitingToSend)) != pdFALSE) {
     448:	4f19      	ldr	r7, [pc, #100]	; (4b0 <prvUnlockQueue+0x88>)
					vTaskMissedYield();
     44a:	f8df 8068 	ldr.w	r8, [pc, #104]	; 4b4 <prvUnlockQueue+0x8c>
	taskEXIT_CRITICAL();
     44e:	47a8      	blx	r5
	taskENTER_CRITICAL();
     450:	47b0      	blx	r6
				if (xTaskRemoveFromEventList(&(pxQueue->xTasksWaitingToSend)) != pdFALSE) {
     452:	f104 0610 	add.w	r6, r4, #16
		while (pxQueue->xRxLock > queueLOCKED_UNMODIFIED) {
     456:	6c63      	ldr	r3, [r4, #68]	; 0x44
     458:	2b00      	cmp	r3, #0
     45a:	dc1b      	bgt.n	494 <prvUnlockQueue+0x6c>
		pxQueue->xRxLock = queueUNLOCKED;
     45c:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
     460:	6463      	str	r3, [r4, #68]	; 0x44
	taskEXIT_CRITICAL();
     462:	462b      	mov	r3, r5
}
     464:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
	taskEXIT_CRITICAL();
     468:	4718      	bx	r3
				if (pxQueue->pxQueueSetContainer != NULL) {
     46a:	6d63      	ldr	r3, [r4, #84]	; 0x54
     46c:	b14b      	cbz	r3, 482 <prvUnlockQueue+0x5a>
					if (prvNotifyQueueSetContainer(pxQueue, queueSEND_TO_BACK) == pdTRUE) {
     46e:	2100      	movs	r1, #0
     470:	4620      	mov	r0, r4
     472:	47c0      	blx	r8
     474:	2801      	cmp	r0, #1
     476:	d100      	bne.n	47a <prvUnlockQueue+0x52>
						vTaskMissedYield();
     478:	47b8      	blx	r7
			--(pxQueue->xTxLock);
     47a:	6ca3      	ldr	r3, [r4, #72]	; 0x48
     47c:	3b01      	subs	r3, #1
     47e:	64a3      	str	r3, [r4, #72]	; 0x48
     480:	e7db      	b.n	43a <prvUnlockQueue+0x12>
					if (listLIST_IS_EMPTY(&(pxQueue->xTasksWaitingToReceive)) == pdFALSE) {
     482:	6a63      	ldr	r3, [r4, #36]	; 0x24
     484:	2b00      	cmp	r3, #0
     486:	d0db      	beq.n	440 <prvUnlockQueue+0x18>
						if (xTaskRemoveFromEventList(&(pxQueue->xTasksWaitingToReceive)) != pdFALSE) {
     488:	f104 0024 	add.w	r0, r4, #36	; 0x24
     48c:	47a8      	blx	r5
     48e:	2800      	cmp	r0, #0
     490:	d0f3      	beq.n	47a <prvUnlockQueue+0x52>
     492:	e7f1      	b.n	478 <prvUnlockQueue+0x50>
			if (listLIST_IS_EMPTY(&(pxQueue->xTasksWaitingToSend)) == pdFALSE) {
     494:	6923      	ldr	r3, [r4, #16]
     496:	2b00      	cmp	r3, #0
     498:	d0e0      	beq.n	45c <prvUnlockQueue+0x34>
				if (xTaskRemoveFromEventList(&(pxQueue->xTasksWaitingToSend)) != pdFALSE) {
     49a:	4630      	mov	r0, r6
     49c:	47b8      	blx	r7
     49e:	b100      	cbz	r0, 4a2 <prvUnlockQueue+0x7a>
					vTaskMissedYield();
     4a0:	47c0      	blx	r8
				--(pxQueue->xRxLock);
     4a2:	6c63      	ldr	r3, [r4, #68]	; 0x44
     4a4:	3b01      	subs	r3, #1
     4a6:	6463      	str	r3, [r4, #68]	; 0x44
     4a8:	e7d5      	b.n	456 <prvUnlockQueue+0x2e>
     4aa:	bf00      	nop
     4ac:	00008ef5 	.word	0x00008ef5
     4b0:	00008341 	.word	0x00008341
     4b4:	00008465 	.word	0x00008465
     4b8:	00008f35 	.word	0x00008f35
     4bc:	00000381 	.word	0x00000381

000004c0 <xQueueGenericReset>:
{
     4c0:	b538      	push	{r3, r4, r5, lr}
     4c2:	460d      	mov	r5, r1
	configASSERT(pxQueue);
     4c4:	4604      	mov	r4, r0
     4c6:	b940      	cbnz	r0, 4da <xQueueGenericReset+0x1a>
     4c8:	f04f 0380 	mov.w	r3, #128	; 0x80
     4cc:	f383 8811 	msr	BASEPRI, r3
     4d0:	f3bf 8f6f 	isb	sy
     4d4:	f3bf 8f4f 	dsb	sy
     4d8:	e7fe      	b.n	4d8 <xQueueGenericReset+0x18>
	taskENTER_CRITICAL();
     4da:	4b18      	ldr	r3, [pc, #96]	; (53c <xQueueGenericReset+0x7c>)
     4dc:	4798      	blx	r3
		pxQueue->pcTail            = pxQueue->pcHead + (pxQueue->uxLength * pxQueue->uxItemSize);
     4de:	e9d4 310f 	ldrd	r3, r1, [r4, #60]	; 0x3c
     4e2:	6822      	ldr	r2, [r4, #0]
		pxQueue->pcWriteTo         = pxQueue->pcHead;
     4e4:	60a2      	str	r2, [r4, #8]
		pxQueue->pcTail            = pxQueue->pcHead + (pxQueue->uxLength * pxQueue->uxItemSize);
     4e6:	434b      	muls	r3, r1
     4e8:	18d0      	adds	r0, r2, r3
		pxQueue->u.pcReadFrom      = pxQueue->pcHead + ((pxQueue->uxLength - (UBaseType_t)1U) * pxQueue->uxItemSize);
     4ea:	1a5b      	subs	r3, r3, r1
     4ec:	4413      	add	r3, r2
		pxQueue->pcTail            = pxQueue->pcHead + (pxQueue->uxLength * pxQueue->uxItemSize);
     4ee:	6060      	str	r0, [r4, #4]
		pxQueue->u.pcReadFrom      = pxQueue->pcHead + ((pxQueue->uxLength - (UBaseType_t)1U) * pxQueue->uxItemSize);
     4f0:	60e3      	str	r3, [r4, #12]
		pxQueue->uxMessagesWaiting = (UBaseType_t)0U;
     4f2:	2000      	movs	r0, #0
		pxQueue->xRxLock           = queueUNLOCKED;
     4f4:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
		pxQueue->uxMessagesWaiting = (UBaseType_t)0U;
     4f8:	63a0      	str	r0, [r4, #56]	; 0x38
		pxQueue->xRxLock           = queueUNLOCKED;
     4fa:	6463      	str	r3, [r4, #68]	; 0x44
		pxQueue->xTxLock           = queueUNLOCKED;
     4fc:	64a3      	str	r3, [r4, #72]	; 0x48
		if (xNewQueue == pdFALSE) {
     4fe:	b9ad      	cbnz	r5, 52c <xQueueGenericReset+0x6c>
			if (listLIST_IS_EMPTY(&(pxQueue->xTasksWaitingToSend)) == pdFALSE) {
     500:	6923      	ldr	r3, [r4, #16]
     502:	b17b      	cbz	r3, 524 <xQueueGenericReset+0x64>
				if (xTaskRemoveFromEventList(&(pxQueue->xTasksWaitingToSend)) == pdTRUE) {
     504:	4b0e      	ldr	r3, [pc, #56]	; (540 <xQueueGenericReset+0x80>)
     506:	f104 0010 	add.w	r0, r4, #16
     50a:	4798      	blx	r3
     50c:	2801      	cmp	r0, #1
     50e:	d109      	bne.n	524 <xQueueGenericReset+0x64>
					queueYIELD_IF_USING_PREEMPTION();
     510:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
     514:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
     518:	f8c3 2d04 	str.w	r2, [r3, #3332]	; 0xd04
     51c:	f3bf 8f4f 	dsb	sy
     520:	f3bf 8f6f 	isb	sy
	taskEXIT_CRITICAL();
     524:	4b07      	ldr	r3, [pc, #28]	; (544 <xQueueGenericReset+0x84>)
     526:	4798      	blx	r3
}
     528:	2001      	movs	r0, #1
     52a:	bd38      	pop	{r3, r4, r5, pc}
			vListInitialise(&(pxQueue->xTasksWaitingToSend));
     52c:	f104 0010 	add.w	r0, r4, #16
     530:	4d05      	ldr	r5, [pc, #20]	; (548 <xQueueGenericReset+0x88>)
     532:	47a8      	blx	r5
			vListInitialise(&(pxQueue->xTasksWaitingToReceive));
     534:	f104 0024 	add.w	r0, r4, #36	; 0x24
     538:	47a8      	blx	r5
     53a:	e7f3      	b.n	524 <xQueueGenericReset+0x64>
     53c:	00008ef5 	.word	0x00008ef5
     540:	00008341 	.word	0x00008341
     544:	00008f35 	.word	0x00008f35
     548:	00001d99 	.word	0x00001d99

0000054c <xQueueGenericCreate>:
{
     54c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
     54e:	460d      	mov	r5, r1
     550:	4617      	mov	r7, r2
	configASSERT(uxQueueLength > (UBaseType_t)0);
     552:	4606      	mov	r6, r0
     554:	b940      	cbnz	r0, 568 <xQueueGenericCreate+0x1c>
     556:	f04f 0380 	mov.w	r3, #128	; 0x80
     55a:	f383 8811 	msr	BASEPRI, r3
     55e:	f3bf 8f6f 	isb	sy
     562:	f3bf 8f4f 	dsb	sy
     566:	e7fe      	b.n	566 <xQueueGenericCreate+0x1a>
	if (uxItemSize == (UBaseType_t)0) {
     568:	b179      	cbz	r1, 58a <xQueueGenericCreate+0x3e>
		xQueueSizeInBytes = (size_t)(uxQueueLength * uxItemSize)
     56a:	4348      	muls	r0, r1
     56c:	3001      	adds	r0, #1
	pxNewQueue = (Queue_t *)pvPortMalloc(sizeof(Queue_t) + xQueueSizeInBytes);
     56e:	4b11      	ldr	r3, [pc, #68]	; (5b4 <xQueueGenericCreate+0x68>)
     570:	3058      	adds	r0, #88	; 0x58
     572:	4798      	blx	r3
	if (pxNewQueue != NULL) {
     574:	4604      	mov	r4, r0
     576:	b950      	cbnz	r0, 58e <xQueueGenericCreate+0x42>
     578:	f04f 0380 	mov.w	r3, #128	; 0x80
     57c:	f383 8811 	msr	BASEPRI, r3
     580:	f3bf 8f6f 	isb	sy
     584:	f3bf 8f4f 	dsb	sy
	configASSERT(xReturn);
     588:	e7fe      	b.n	588 <xQueueGenericCreate+0x3c>
		xQueueSizeInBytes = (size_t)0;
     58a:	4608      	mov	r0, r1
     58c:	e7ef      	b.n	56e <xQueueGenericCreate+0x22>
		if (uxItemSize == (UBaseType_t)0) {
     58e:	b175      	cbz	r5, 5ae <xQueueGenericCreate+0x62>
			pxNewQueue->pcHead = ((int8_t *)pxNewQueue) + sizeof(Queue_t);
     590:	f100 0358 	add.w	r3, r0, #88	; 0x58
     594:	6023      	str	r3, [r4, #0]
		pxNewQueue->uxItemSize = uxItemSize;
     596:	e9c4 650f 	strd	r6, r5, [r4, #60]	; 0x3c
		(void)xQueueGenericReset(pxNewQueue, pdTRUE);
     59a:	4b07      	ldr	r3, [pc, #28]	; (5b8 <xQueueGenericCreate+0x6c>)
     59c:	2101      	movs	r1, #1
     59e:	4620      	mov	r0, r4
     5a0:	4798      	blx	r3
			pxNewQueue->pxQueueSetContainer = NULL;
     5a2:	2300      	movs	r3, #0
			pxNewQueue->ucQueueType = ucQueueType;
     5a4:	f884 7050 	strb.w	r7, [r4, #80]	; 0x50
			pxNewQueue->pxQueueSetContainer = NULL;
     5a8:	6563      	str	r3, [r4, #84]	; 0x54
}
     5aa:	4620      	mov	r0, r4
     5ac:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
     5ae:	4603      	mov	r3, r0
     5b0:	e7f0      	b.n	594 <xQueueGenericCreate+0x48>
     5b2:	bf00      	nop
     5b4:	00001c9d 	.word	0x00001c9d
     5b8:	000004c1 	.word	0x000004c1

000005bc <xQueueCreateCountingSemaphore>:
{
     5bc:	b510      	push	{r4, lr}
     5be:	460c      	mov	r4, r1
	configASSERT(uxMaxCount != 0);
     5c0:	b940      	cbnz	r0, 5d4 <xQueueCreateCountingSemaphore+0x18>
     5c2:	f04f 0380 	mov.w	r3, #128	; 0x80
     5c6:	f383 8811 	msr	BASEPRI, r3
     5ca:	f3bf 8f6f 	isb	sy
     5ce:	f3bf 8f4f 	dsb	sy
     5d2:	e7fe      	b.n	5d2 <xQueueCreateCountingSemaphore+0x16>
	configASSERT(uxInitialCount <= uxMaxCount);
     5d4:	4288      	cmp	r0, r1
     5d6:	d208      	bcs.n	5ea <xQueueCreateCountingSemaphore+0x2e>
     5d8:	f04f 0380 	mov.w	r3, #128	; 0x80
     5dc:	f383 8811 	msr	BASEPRI, r3
     5e0:	f3bf 8f6f 	isb	sy
     5e4:	f3bf 8f4f 	dsb	sy
     5e8:	e7fe      	b.n	5e8 <xQueueCreateCountingSemaphore+0x2c>
	xHandle = xQueueGenericCreate(uxMaxCount, queueSEMAPHORE_QUEUE_ITEM_LENGTH, queueQUEUE_TYPE_COUNTING_SEMAPHORE);
     5ea:	4b08      	ldr	r3, [pc, #32]	; (60c <xQueueCreateCountingSemaphore+0x50>)
     5ec:	2202      	movs	r2, #2
     5ee:	2100      	movs	r1, #0
     5f0:	4798      	blx	r3
	if (xHandle != NULL) {
     5f2:	b108      	cbz	r0, 5f8 <xQueueCreateCountingSemaphore+0x3c>
		((Queue_t *)xHandle)->uxMessagesWaiting = uxInitialCount;
     5f4:	6384      	str	r4, [r0, #56]	; 0x38
}
     5f6:	bd10      	pop	{r4, pc}
     5f8:	f04f 0380 	mov.w	r3, #128	; 0x80
     5fc:	f383 8811 	msr	BASEPRI, r3
     600:	f3bf 8f6f 	isb	sy
     604:	f3bf 8f4f 	dsb	sy
	configASSERT(xHandle);
     608:	e7fe      	b.n	608 <xQueueCreateCountingSemaphore+0x4c>
     60a:	bf00      	nop
     60c:	0000054d 	.word	0x0000054d

00000610 <xQueueGenericSend>:
{
     610:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
     614:	b085      	sub	sp, #20
     616:	4689      	mov	r9, r1
     618:	9201      	str	r2, [sp, #4]
     61a:	461e      	mov	r6, r3
	configASSERT(pxQueue);
     61c:	4604      	mov	r4, r0
     61e:	b940      	cbnz	r0, 632 <xQueueGenericSend+0x22>
     620:	f04f 0380 	mov.w	r3, #128	; 0x80
     624:	f383 8811 	msr	BASEPRI, r3
     628:	f3bf 8f6f 	isb	sy
     62c:	f3bf 8f4f 	dsb	sy
     630:	e7fe      	b.n	630 <xQueueGenericSend+0x20>
	configASSERT(!((pvItemToQueue == NULL) && (pxQueue->uxItemSize != (UBaseType_t)0U)));
     632:	b951      	cbnz	r1, 64a <xQueueGenericSend+0x3a>
     634:	6c03      	ldr	r3, [r0, #64]	; 0x40
     636:	b143      	cbz	r3, 64a <xQueueGenericSend+0x3a>
     638:	f04f 0380 	mov.w	r3, #128	; 0x80
     63c:	f383 8811 	msr	BASEPRI, r3
     640:	f3bf 8f6f 	isb	sy
     644:	f3bf 8f4f 	dsb	sy
     648:	e7fe      	b.n	648 <xQueueGenericSend+0x38>
	configASSERT(!((xCopyPosition == queueOVERWRITE) && (pxQueue->uxLength != 1)));
     64a:	2e02      	cmp	r6, #2
     64c:	d10b      	bne.n	666 <xQueueGenericSend+0x56>
     64e:	6be3      	ldr	r3, [r4, #60]	; 0x3c
     650:	2b01      	cmp	r3, #1
     652:	d008      	beq.n	666 <xQueueGenericSend+0x56>
     654:	f04f 0380 	mov.w	r3, #128	; 0x80
     658:	f383 8811 	msr	BASEPRI, r3
     65c:	f3bf 8f6f 	isb	sy
     660:	f3bf 8f4f 	dsb	sy
     664:	e7fe      	b.n	664 <xQueueGenericSend+0x54>
		configASSERT(!((xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED) && (xTicksToWait != 0)));
     666:	4b46      	ldr	r3, [pc, #280]	; (780 <xQueueGenericSend+0x170>)
     668:	4798      	blx	r3
     66a:	4680      	mov	r8, r0
     66c:	b950      	cbnz	r0, 684 <xQueueGenericSend+0x74>
     66e:	9b01      	ldr	r3, [sp, #4]
     670:	b153      	cbz	r3, 688 <xQueueGenericSend+0x78>
     672:	f04f 0380 	mov.w	r3, #128	; 0x80
     676:	f383 8811 	msr	BASEPRI, r3
     67a:	f3bf 8f6f 	isb	sy
     67e:	f3bf 8f4f 	dsb	sy
     682:	e7fe      	b.n	682 <xQueueGenericSend+0x72>
     684:	f04f 0800 	mov.w	r8, #0
		taskENTER_CRITICAL();
     688:	f8df a11c 	ldr.w	sl, [pc, #284]	; 7a8 <xQueueGenericSend+0x198>
     68c:	4f3d      	ldr	r7, [pc, #244]	; (784 <xQueueGenericSend+0x174>)
     68e:	46d3      	mov	fp, sl
     690:	e041      	b.n	716 <xQueueGenericSend+0x106>
						if (listLIST_IS_EMPTY(&(pxQueue->xTasksWaitingToReceive)) == pdFALSE) {
     692:	6a63      	ldr	r3, [r4, #36]	; 0x24
     694:	b123      	cbz	r3, 6a0 <xQueueGenericSend+0x90>
							if (xTaskRemoveFromEventList(&(pxQueue->xTasksWaitingToReceive)) == pdTRUE) {
     696:	4b3c      	ldr	r3, [pc, #240]	; (788 <xQueueGenericSend+0x178>)
     698:	f104 0024 	add.w	r0, r4, #36	; 0x24
     69c:	4798      	blx	r3
     69e:	e04d      	b.n	73c <xQueueGenericSend+0x12c>
						} else if (xYieldRequired != pdFALSE) {
     6a0:	2800      	cmp	r0, #0
     6a2:	d14d      	bne.n	740 <xQueueGenericSend+0x130>
				taskEXIT_CRITICAL();
     6a4:	47b8      	blx	r7
				return pdPASS;
     6a6:	2001      	movs	r0, #1
}
     6a8:	b005      	add	sp, #20
     6aa:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
				if (xTicksToWait == (TickType_t)0) {
     6ae:	9d01      	ldr	r5, [sp, #4]
     6b0:	b915      	cbnz	r5, 6b8 <xQueueGenericSend+0xa8>
					taskEXIT_CRITICAL();
     6b2:	47b8      	blx	r7
			return errQUEUE_FULL;
     6b4:	2000      	movs	r0, #0
     6b6:	e7f7      	b.n	6a8 <xQueueGenericSend+0x98>
				} else if (xEntryTimeSet == pdFALSE) {
     6b8:	f1b8 0f00 	cmp.w	r8, #0
     6bc:	d102      	bne.n	6c4 <xQueueGenericSend+0xb4>
					vTaskSetTimeOutState(&xTimeOut);
     6be:	4b33      	ldr	r3, [pc, #204]	; (78c <xQueueGenericSend+0x17c>)
     6c0:	a802      	add	r0, sp, #8
     6c2:	4798      	blx	r3
		taskEXIT_CRITICAL();
     6c4:	47b8      	blx	r7
		vTaskSuspendAll();
     6c6:	4b32      	ldr	r3, [pc, #200]	; (790 <xQueueGenericSend+0x180>)
     6c8:	f8df 80e0 	ldr.w	r8, [pc, #224]	; 7ac <xQueueGenericSend+0x19c>
     6cc:	4d31      	ldr	r5, [pc, #196]	; (794 <xQueueGenericSend+0x184>)
     6ce:	4798      	blx	r3
		prvLockQueue(pxQueue);
     6d0:	47d8      	blx	fp
     6d2:	6c63      	ldr	r3, [r4, #68]	; 0x44
     6d4:	3301      	adds	r3, #1
     6d6:	bf04      	itt	eq
     6d8:	2300      	moveq	r3, #0
     6da:	6463      	streq	r3, [r4, #68]	; 0x44
     6dc:	6ca3      	ldr	r3, [r4, #72]	; 0x48
     6de:	3301      	adds	r3, #1
     6e0:	bf04      	itt	eq
     6e2:	2300      	moveq	r3, #0
     6e4:	64a3      	streq	r3, [r4, #72]	; 0x48
     6e6:	47b8      	blx	r7
		if (xTaskCheckForTimeOut(&xTimeOut, &xTicksToWait) == pdFALSE) {
     6e8:	4b2b      	ldr	r3, [pc, #172]	; (798 <xQueueGenericSend+0x188>)
     6ea:	a901      	add	r1, sp, #4
     6ec:	a802      	add	r0, sp, #8
     6ee:	4798      	blx	r3
     6f0:	2800      	cmp	r0, #0
     6f2:	d140      	bne.n	776 <xQueueGenericSend+0x166>
	taskENTER_CRITICAL();
     6f4:	47d8      	blx	fp
		if (pxQueue->uxMessagesWaiting == pxQueue->uxLength) {
     6f6:	6ba2      	ldr	r2, [r4, #56]	; 0x38
     6f8:	6be3      	ldr	r3, [r4, #60]	; 0x3c
     6fa:	429a      	cmp	r2, r3
     6fc:	d12b      	bne.n	756 <xQueueGenericSend+0x146>
	taskEXIT_CRITICAL();
     6fe:	47b8      	blx	r7
				vTaskPlaceOnEventList(&(pxQueue->xTasksWaitingToSend), xTicksToWait);
     700:	9901      	ldr	r1, [sp, #4]
     702:	4b26      	ldr	r3, [pc, #152]	; (79c <xQueueGenericSend+0x18c>)
     704:	f104 0010 	add.w	r0, r4, #16
     708:	4798      	blx	r3
				prvUnlockQueue(pxQueue);
     70a:	4620      	mov	r0, r4
     70c:	47c0      	blx	r8
				if (xTaskResumeAll() == pdFALSE) {
     70e:	47a8      	blx	r5
     710:	b330      	cbz	r0, 760 <xQueueGenericSend+0x150>
     712:	f04f 0801 	mov.w	r8, #1
		taskENTER_CRITICAL();
     716:	47d0      	blx	sl
			if ((pxQueue->uxMessagesWaiting < pxQueue->uxLength) || (xCopyPosition == queueOVERWRITE)) {
     718:	6ba2      	ldr	r2, [r4, #56]	; 0x38
     71a:	6be3      	ldr	r3, [r4, #60]	; 0x3c
     71c:	429a      	cmp	r2, r3
     71e:	d301      	bcc.n	724 <xQueueGenericSend+0x114>
     720:	2e02      	cmp	r6, #2
     722:	d1c4      	bne.n	6ae <xQueueGenericSend+0x9e>
				xYieldRequired = prvCopyDataToQueue(pxQueue, pvItemToQueue, xCopyPosition);
     724:	4b1e      	ldr	r3, [pc, #120]	; (7a0 <xQueueGenericSend+0x190>)
     726:	4632      	mov	r2, r6
     728:	4649      	mov	r1, r9
     72a:	4620      	mov	r0, r4
     72c:	4798      	blx	r3
					if (pxQueue->pxQueueSetContainer != NULL) {
     72e:	6d63      	ldr	r3, [r4, #84]	; 0x54
     730:	2b00      	cmp	r3, #0
     732:	d0ae      	beq.n	692 <xQueueGenericSend+0x82>
						if (prvNotifyQueueSetContainer(pxQueue, xCopyPosition) == pdTRUE) {
     734:	4b1b      	ldr	r3, [pc, #108]	; (7a4 <xQueueGenericSend+0x194>)
     736:	4631      	mov	r1, r6
     738:	4620      	mov	r0, r4
     73a:	4798      	blx	r3
							if (xTaskRemoveFromEventList(&(pxQueue->xTasksWaitingToReceive)) == pdTRUE) {
     73c:	2801      	cmp	r0, #1
     73e:	d1b1      	bne.n	6a4 <xQueueGenericSend+0x94>
							queueYIELD_IF_USING_PREEMPTION();
     740:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
     744:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
     748:	f8c3 2d04 	str.w	r2, [r3, #3332]	; 0xd04
     74c:	f3bf 8f4f 	dsb	sy
     750:	f3bf 8f6f 	isb	sy
     754:	e7a6      	b.n	6a4 <xQueueGenericSend+0x94>
	taskEXIT_CRITICAL();
     756:	47b8      	blx	r7
				prvUnlockQueue(pxQueue);
     758:	4620      	mov	r0, r4
     75a:	47c0      	blx	r8
				(void)xTaskResumeAll();
     75c:	47a8      	blx	r5
     75e:	e7d8      	b.n	712 <xQueueGenericSend+0x102>
					portYIELD_WITHIN_API();
     760:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
     764:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
     768:	f8c3 2d04 	str.w	r2, [r3, #3332]	; 0xd04
     76c:	f3bf 8f4f 	dsb	sy
     770:	f3bf 8f6f 	isb	sy
     774:	e7cd      	b.n	712 <xQueueGenericSend+0x102>
			prvUnlockQueue(pxQueue);
     776:	4620      	mov	r0, r4
     778:	47c0      	blx	r8
			(void)xTaskResumeAll();
     77a:	47a8      	blx	r5
     77c:	e79a      	b.n	6b4 <xQueueGenericSend+0xa4>
     77e:	bf00      	nop
     780:	00008475 	.word	0x00008475
     784:	00008f35 	.word	0x00008f35
     788:	00008341 	.word	0x00008341
     78c:	000083c1 	.word	0x000083c1
     790:	00007f25 	.word	0x00007f25
     794:	00008039 	.word	0x00008039
     798:	000083e9 	.word	0x000083e9
     79c:	00008289 	.word	0x00008289
     7a0:	00000309 	.word	0x00000309
     7a4:	00000381 	.word	0x00000381
     7a8:	00008ef5 	.word	0x00008ef5
     7ac:	00000429 	.word	0x00000429

000007b0 <xQueueGenericSendFromISR>:
{
     7b0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
     7b4:	460f      	mov	r7, r1
     7b6:	4616      	mov	r6, r2
     7b8:	461d      	mov	r5, r3
	configASSERT(pxQueue);
     7ba:	4604      	mov	r4, r0
     7bc:	b940      	cbnz	r0, 7d0 <xQueueGenericSendFromISR+0x20>
     7be:	f04f 0380 	mov.w	r3, #128	; 0x80
     7c2:	f383 8811 	msr	BASEPRI, r3
     7c6:	f3bf 8f6f 	isb	sy
     7ca:	f3bf 8f4f 	dsb	sy
     7ce:	e7fe      	b.n	7ce <xQueueGenericSendFromISR+0x1e>
	configASSERT(!((pvItemToQueue == NULL) && (pxQueue->uxItemSize != (UBaseType_t)0U)));
     7d0:	b951      	cbnz	r1, 7e8 <xQueueGenericSendFromISR+0x38>
     7d2:	6c03      	ldr	r3, [r0, #64]	; 0x40
     7d4:	b143      	cbz	r3, 7e8 <xQueueGenericSendFromISR+0x38>
     7d6:	f04f 0380 	mov.w	r3, #128	; 0x80
     7da:	f383 8811 	msr	BASEPRI, r3
     7de:	f3bf 8f6f 	isb	sy
     7e2:	f3bf 8f4f 	dsb	sy
     7e6:	e7fe      	b.n	7e6 <xQueueGenericSendFromISR+0x36>
	configASSERT(!((xCopyPosition == queueOVERWRITE) && (pxQueue->uxLength != 1)));
     7e8:	2d02      	cmp	r5, #2
     7ea:	d10b      	bne.n	804 <xQueueGenericSendFromISR+0x54>
     7ec:	6be3      	ldr	r3, [r4, #60]	; 0x3c
     7ee:	2b01      	cmp	r3, #1
     7f0:	d008      	beq.n	804 <xQueueGenericSendFromISR+0x54>
     7f2:	f04f 0380 	mov.w	r3, #128	; 0x80
     7f6:	f383 8811 	msr	BASEPRI, r3
     7fa:	f3bf 8f6f 	isb	sy
     7fe:	f3bf 8f4f 	dsb	sy
     802:	e7fe      	b.n	802 <xQueueGenericSendFromISR+0x52>
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
     804:	4b1d      	ldr	r3, [pc, #116]	; (87c <xQueueGenericSendFromISR+0xcc>)
     806:	4798      	blx	r3

portFORCE_INLINE static uint32_t ulPortRaiseBASEPRI(void)
{
	uint32_t ulOriginalBASEPRI, ulNewBASEPRI;

	__asm volatile("	mrs %0, basepri											\n"
     808:	f3ef 8811 	mrs	r8, BASEPRI
     80c:	f04f 0380 	mov.w	r3, #128	; 0x80
     810:	f383 8811 	msr	BASEPRI, r3
     814:	f3bf 8f6f 	isb	sy
     818:	f3bf 8f4f 	dsb	sy
		if ((pxQueue->uxMessagesWaiting < pxQueue->uxLength) || (xCopyPosition == queueOVERWRITE)) {
     81c:	6ba2      	ldr	r2, [r4, #56]	; 0x38
     81e:	6be3      	ldr	r3, [r4, #60]	; 0x3c
     820:	429a      	cmp	r2, r3
     822:	d301      	bcc.n	828 <xQueueGenericSendFromISR+0x78>
     824:	2d02      	cmp	r5, #2
     826:	d126      	bne.n	876 <xQueueGenericSendFromISR+0xc6>
			(void)prvCopyDataToQueue(pxQueue, pvItemToQueue, xCopyPosition);
     828:	4b15      	ldr	r3, [pc, #84]	; (880 <xQueueGenericSendFromISR+0xd0>)
     82a:	462a      	mov	r2, r5
     82c:	4639      	mov	r1, r7
     82e:	4620      	mov	r0, r4
     830:	4798      	blx	r3
			if (pxQueue->xTxLock == queueUNLOCKED) {
     832:	6ca3      	ldr	r3, [r4, #72]	; 0x48
     834:	3301      	adds	r3, #1
     836:	d11a      	bne.n	86e <xQueueGenericSendFromISR+0xbe>
					if (pxQueue->pxQueueSetContainer != NULL) {
     838:	6d63      	ldr	r3, [r4, #84]	; 0x54
     83a:	b13b      	cbz	r3, 84c <xQueueGenericSendFromISR+0x9c>
						if (prvNotifyQueueSetContainer(pxQueue, xCopyPosition) == pdTRUE) {
     83c:	4b11      	ldr	r3, [pc, #68]	; (884 <xQueueGenericSendFromISR+0xd4>)
     83e:	4629      	mov	r1, r5
     840:	4620      	mov	r0, r4
     842:	4798      	blx	r3
     844:	2801      	cmp	r0, #1
     846:	d00a      	beq.n	85e <xQueueGenericSendFromISR+0xae>
			xReturn = pdPASS;
     848:	2001      	movs	r0, #1
     84a:	e00c      	b.n	866 <xQueueGenericSendFromISR+0xb6>
						if (listLIST_IS_EMPTY(&(pxQueue->xTasksWaitingToReceive)) == pdFALSE) {
     84c:	6a63      	ldr	r3, [r4, #36]	; 0x24
     84e:	2b00      	cmp	r3, #0
     850:	d0fa      	beq.n	848 <xQueueGenericSendFromISR+0x98>
							if (xTaskRemoveFromEventList(&(pxQueue->xTasksWaitingToReceive)) != pdFALSE) {
     852:	4b0d      	ldr	r3, [pc, #52]	; (888 <xQueueGenericSendFromISR+0xd8>)
     854:	f104 0024 	add.w	r0, r4, #36	; 0x24
     858:	4798      	blx	r3
     85a:	2800      	cmp	r0, #0
     85c:	d0f4      	beq.n	848 <xQueueGenericSendFromISR+0x98>
							if (pxHigherPriorityTaskWoken != NULL) {
     85e:	2e00      	cmp	r6, #0
     860:	d0f2      	beq.n	848 <xQueueGenericSendFromISR+0x98>
								*pxHigherPriorityTaskWoken = pdTRUE;
     862:	2001      	movs	r0, #1
     864:	6030      	str	r0, [r6, #0]
}
/*-----------------------------------------------------------*/

portFORCE_INLINE static void vPortSetBASEPRI(uint32_t ulNewMaskValue)
{
	__asm volatile("	msr basepri, %0	" ::"r"(ulNewMaskValue));
     866:	f388 8811 	msr	BASEPRI, r8
}
     86a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
				++(pxQueue->xTxLock);
     86e:	6ca3      	ldr	r3, [r4, #72]	; 0x48
     870:	3301      	adds	r3, #1
     872:	64a3      	str	r3, [r4, #72]	; 0x48
     874:	e7e8      	b.n	848 <xQueueGenericSendFromISR+0x98>
			xReturn = errQUEUE_FULL;
     876:	2000      	movs	r0, #0
     878:	e7f5      	b.n	866 <xQueueGenericSendFromISR+0xb6>
     87a:	bf00      	nop
     87c:	000090fd 	.word	0x000090fd
     880:	00000309 	.word	0x00000309
     884:	00000381 	.word	0x00000381
     888:	00008341 	.word	0x00008341

0000088c <xQueueGiveFromISR>:
{
     88c:	b570      	push	{r4, r5, r6, lr}
     88e:	460d      	mov	r5, r1
	configASSERT(pxQueue);
     890:	4604      	mov	r4, r0
     892:	b940      	cbnz	r0, 8a6 <xQueueGiveFromISR+0x1a>
	__asm volatile("	mov %0, %1												\n"
     894:	f04f 0380 	mov.w	r3, #128	; 0x80
     898:	f383 8811 	msr	BASEPRI, r3
     89c:	f3bf 8f6f 	isb	sy
     8a0:	f3bf 8f4f 	dsb	sy
     8a4:	e7fe      	b.n	8a4 <xQueueGiveFromISR+0x18>
	configASSERT(pxQueue->uxItemSize == 0);
     8a6:	6c03      	ldr	r3, [r0, #64]	; 0x40
     8a8:	b143      	cbz	r3, 8bc <xQueueGiveFromISR+0x30>
     8aa:	f04f 0380 	mov.w	r3, #128	; 0x80
     8ae:	f383 8811 	msr	BASEPRI, r3
     8b2:	f3bf 8f6f 	isb	sy
     8b6:	f3bf 8f4f 	dsb	sy
     8ba:	e7fe      	b.n	8ba <xQueueGiveFromISR+0x2e>
	configASSERT(!((pxQueue->uxQueueType == queueQUEUE_IS_MUTEX) && (pxQueue->pxMutexHolder != NULL)));
     8bc:	6803      	ldr	r3, [r0, #0]
     8be:	b953      	cbnz	r3, 8d6 <xQueueGiveFromISR+0x4a>
     8c0:	6843      	ldr	r3, [r0, #4]
     8c2:	b143      	cbz	r3, 8d6 <xQueueGiveFromISR+0x4a>
     8c4:	f04f 0380 	mov.w	r3, #128	; 0x80
     8c8:	f383 8811 	msr	BASEPRI, r3
     8cc:	f3bf 8f6f 	isb	sy
     8d0:	f3bf 8f4f 	dsb	sy
     8d4:	e7fe      	b.n	8d4 <xQueueGiveFromISR+0x48>
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
     8d6:	4b1b      	ldr	r3, [pc, #108]	; (944 <xQueueGiveFromISR+0xb8>)
     8d8:	4798      	blx	r3
	__asm volatile("	mrs %0, basepri											\n"
     8da:	f3ef 8611 	mrs	r6, BASEPRI
     8de:	f04f 0380 	mov.w	r3, #128	; 0x80
     8e2:	f383 8811 	msr	BASEPRI, r3
     8e6:	f3bf 8f6f 	isb	sy
     8ea:	f3bf 8f4f 	dsb	sy
		if (pxQueue->uxMessagesWaiting < pxQueue->uxLength) {
     8ee:	6ba2      	ldr	r2, [r4, #56]	; 0x38
     8f0:	6be3      	ldr	r3, [r4, #60]	; 0x3c
     8f2:	429a      	cmp	r2, r3
     8f4:	d223      	bcs.n	93e <xQueueGiveFromISR+0xb2>
			++(pxQueue->uxMessagesWaiting);
     8f6:	6ba3      	ldr	r3, [r4, #56]	; 0x38
     8f8:	3301      	adds	r3, #1
     8fa:	63a3      	str	r3, [r4, #56]	; 0x38
			if (pxQueue->xTxLock == queueUNLOCKED) {
     8fc:	6ca3      	ldr	r3, [r4, #72]	; 0x48
     8fe:	3301      	adds	r3, #1
     900:	d119      	bne.n	936 <xQueueGiveFromISR+0xaa>
					if (pxQueue->pxQueueSetContainer != NULL) {
     902:	6d63      	ldr	r3, [r4, #84]	; 0x54
     904:	b13b      	cbz	r3, 916 <xQueueGiveFromISR+0x8a>
						if (prvNotifyQueueSetContainer(pxQueue, queueSEND_TO_BACK) == pdTRUE) {
     906:	4b10      	ldr	r3, [pc, #64]	; (948 <xQueueGiveFromISR+0xbc>)
     908:	2100      	movs	r1, #0
     90a:	4620      	mov	r0, r4
     90c:	4798      	blx	r3
     90e:	2801      	cmp	r0, #1
     910:	d00a      	beq.n	928 <xQueueGiveFromISR+0x9c>
			xReturn = pdPASS;
     912:	2001      	movs	r0, #1
     914:	e00c      	b.n	930 <xQueueGiveFromISR+0xa4>
						if (listLIST_IS_EMPTY(&(pxQueue->xTasksWaitingToReceive)) == pdFALSE) {
     916:	6a63      	ldr	r3, [r4, #36]	; 0x24
     918:	2b00      	cmp	r3, #0
     91a:	d0fa      	beq.n	912 <xQueueGiveFromISR+0x86>
							if (xTaskRemoveFromEventList(&(pxQueue->xTasksWaitingToReceive)) != pdFALSE) {
     91c:	4b0b      	ldr	r3, [pc, #44]	; (94c <xQueueGiveFromISR+0xc0>)
     91e:	f104 0024 	add.w	r0, r4, #36	; 0x24
     922:	4798      	blx	r3
     924:	2800      	cmp	r0, #0
     926:	d0f4      	beq.n	912 <xQueueGiveFromISR+0x86>
							if (pxHigherPriorityTaskWoken != NULL) {
     928:	2d00      	cmp	r5, #0
     92a:	d0f2      	beq.n	912 <xQueueGiveFromISR+0x86>
								*pxHigherPriorityTaskWoken = pdTRUE;
     92c:	2001      	movs	r0, #1
     92e:	6028      	str	r0, [r5, #0]
	__asm volatile("	msr basepri, %0	" ::"r"(ulNewMaskValue));
     930:	f386 8811 	msr	BASEPRI, r6
}
     934:	bd70      	pop	{r4, r5, r6, pc}
				++(pxQueue->xTxLock);
     936:	6ca3      	ldr	r3, [r4, #72]	; 0x48
     938:	3301      	adds	r3, #1
     93a:	64a3      	str	r3, [r4, #72]	; 0x48
     93c:	e7e9      	b.n	912 <xQueueGiveFromISR+0x86>
			xReturn = errQUEUE_FULL;
     93e:	2000      	movs	r0, #0
     940:	e7f6      	b.n	930 <xQueueGiveFromISR+0xa4>
     942:	bf00      	nop
     944:	000090fd 	.word	0x000090fd
     948:	00000381 	.word	0x00000381
     94c:	00008341 	.word	0x00008341

00000950 <xQueueGenericReceive>:
{
     950:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
     954:	b085      	sub	sp, #20
     956:	4688      	mov	r8, r1
     958:	9201      	str	r2, [sp, #4]
     95a:	4699      	mov	r9, r3
	configASSERT(pxQueue);
     95c:	4604      	mov	r4, r0
     95e:	b940      	cbnz	r0, 972 <xQueueGenericReceive+0x22>
	__asm volatile("	mov %0, %1												\n"
     960:	f04f 0380 	mov.w	r3, #128	; 0x80
     964:	f383 8811 	msr	BASEPRI, r3
     968:	f3bf 8f6f 	isb	sy
     96c:	f3bf 8f4f 	dsb	sy
     970:	e7fe      	b.n	970 <xQueueGenericReceive+0x20>
	configASSERT(!((pvBuffer == NULL) && (pxQueue->uxItemSize != (UBaseType_t)0U)));
     972:	b951      	cbnz	r1, 98a <xQueueGenericReceive+0x3a>
     974:	6c03      	ldr	r3, [r0, #64]	; 0x40
     976:	b143      	cbz	r3, 98a <xQueueGenericReceive+0x3a>
     978:	f04f 0380 	mov.w	r3, #128	; 0x80
     97c:	f383 8811 	msr	BASEPRI, r3
     980:	f3bf 8f6f 	isb	sy
     984:	f3bf 8f4f 	dsb	sy
     988:	e7fe      	b.n	988 <xQueueGenericReceive+0x38>
		configASSERT(!((xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED) && (xTicksToWait != 0)));
     98a:	4b49      	ldr	r3, [pc, #292]	; (ab0 <xQueueGenericReceive+0x160>)
     98c:	4798      	blx	r3
     98e:	4607      	mov	r7, r0
     990:	b950      	cbnz	r0, 9a8 <xQueueGenericReceive+0x58>
     992:	9b01      	ldr	r3, [sp, #4]
     994:	b14b      	cbz	r3, 9aa <xQueueGenericReceive+0x5a>
     996:	f04f 0380 	mov.w	r3, #128	; 0x80
     99a:	f383 8811 	msr	BASEPRI, r3
     99e:	f3bf 8f6f 	isb	sy
     9a2:	f3bf 8f4f 	dsb	sy
     9a6:	e7fe      	b.n	9a6 <xQueueGenericReceive+0x56>
     9a8:	2700      	movs	r7, #0
		taskENTER_CRITICAL();
     9aa:	f8df b134 	ldr.w	fp, [pc, #308]	; ae0 <xQueueGenericReceive+0x190>
     9ae:	4d41      	ldr	r5, [pc, #260]	; (ab4 <xQueueGenericReceive+0x164>)
     9b0:	46da      	mov	sl, fp
     9b2:	e051      	b.n	a58 <xQueueGenericReceive+0x108>
					if (listLIST_IS_EMPTY(&(pxQueue->xTasksWaitingToReceive)) == pdFALSE) {
     9b4:	6a63      	ldr	r3, [r4, #36]	; 0x24
					pxQueue->u.pcReadFrom = pcOriginalReadPosition;
     9b6:	60e6      	str	r6, [r4, #12]
					if (listLIST_IS_EMPTY(&(pxQueue->xTasksWaitingToReceive)) == pdFALSE) {
     9b8:	b12b      	cbz	r3, 9c6 <xQueueGenericReceive+0x76>
						if (xTaskRemoveFromEventList(&(pxQueue->xTasksWaitingToReceive)) != pdFALSE) {
     9ba:	4b3f      	ldr	r3, [pc, #252]	; (ab8 <xQueueGenericReceive+0x168>)
     9bc:	f104 0024 	add.w	r0, r4, #36	; 0x24
     9c0:	4798      	blx	r3
     9c2:	2800      	cmp	r0, #0
     9c4:	d165      	bne.n	a92 <xQueueGenericReceive+0x142>
				taskEXIT_CRITICAL();
     9c6:	47a8      	blx	r5
				return pdPASS;
     9c8:	2001      	movs	r0, #1
}
     9ca:	b005      	add	sp, #20
     9cc:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
				if (xTicksToWait == (TickType_t)0) {
     9d0:	9e01      	ldr	r6, [sp, #4]
     9d2:	b916      	cbnz	r6, 9da <xQueueGenericReceive+0x8a>
					taskEXIT_CRITICAL();
     9d4:	47a8      	blx	r5
			return errQUEUE_EMPTY;
     9d6:	2000      	movs	r0, #0
     9d8:	e7f7      	b.n	9ca <xQueueGenericReceive+0x7a>
				} else if (xEntryTimeSet == pdFALSE) {
     9da:	b917      	cbnz	r7, 9e2 <xQueueGenericReceive+0x92>
					vTaskSetTimeOutState(&xTimeOut);
     9dc:	4b37      	ldr	r3, [pc, #220]	; (abc <xQueueGenericReceive+0x16c>)
     9de:	a802      	add	r0, sp, #8
     9e0:	4798      	blx	r3
		taskEXIT_CRITICAL();
     9e2:	47a8      	blx	r5
		vTaskSuspendAll();
     9e4:	4b36      	ldr	r3, [pc, #216]	; (ac0 <xQueueGenericReceive+0x170>)
     9e6:	4f37      	ldr	r7, [pc, #220]	; (ac4 <xQueueGenericReceive+0x174>)
     9e8:	4e37      	ldr	r6, [pc, #220]	; (ac8 <xQueueGenericReceive+0x178>)
     9ea:	4798      	blx	r3
		prvLockQueue(pxQueue);
     9ec:	47d0      	blx	sl
     9ee:	6c63      	ldr	r3, [r4, #68]	; 0x44
     9f0:	3301      	adds	r3, #1
     9f2:	bf04      	itt	eq
     9f4:	2300      	moveq	r3, #0
     9f6:	6463      	streq	r3, [r4, #68]	; 0x44
     9f8:	6ca3      	ldr	r3, [r4, #72]	; 0x48
     9fa:	3301      	adds	r3, #1
     9fc:	bf04      	itt	eq
     9fe:	2300      	moveq	r3, #0
     a00:	64a3      	streq	r3, [r4, #72]	; 0x48
     a02:	47a8      	blx	r5
		if (xTaskCheckForTimeOut(&xTimeOut, &xTicksToWait) == pdFALSE) {
     a04:	4b31      	ldr	r3, [pc, #196]	; (acc <xQueueGenericReceive+0x17c>)
     a06:	a901      	add	r1, sp, #4
     a08:	a802      	add	r0, sp, #8
     a0a:	4798      	blx	r3
     a0c:	2800      	cmp	r0, #0
     a0e:	d14b      	bne.n	aa8 <xQueueGenericReceive+0x158>
	taskENTER_CRITICAL();
     a10:	47d0      	blx	sl
		if (pxQueue->uxMessagesWaiting == (UBaseType_t)0) {
     a12:	6ba3      	ldr	r3, [r4, #56]	; 0x38
     a14:	b9db      	cbnz	r3, a4e <xQueueGenericReceive+0xfe>
	taskEXIT_CRITICAL();
     a16:	47a8      	blx	r5
					if (pxQueue->uxQueueType == queueQUEUE_IS_MUTEX) {
     a18:	6823      	ldr	r3, [r4, #0]
     a1a:	b923      	cbnz	r3, a26 <xQueueGenericReceive+0xd6>
						taskENTER_CRITICAL();
     a1c:	47d0      	blx	sl
							vTaskPriorityInherit((void *)pxQueue->pxMutexHolder);
     a1e:	6860      	ldr	r0, [r4, #4]
     a20:	4b2b      	ldr	r3, [pc, #172]	; (ad0 <xQueueGenericReceive+0x180>)
     a22:	4798      	blx	r3
						taskEXIT_CRITICAL();
     a24:	47a8      	blx	r5
				vTaskPlaceOnEventList(&(pxQueue->xTasksWaitingToReceive), xTicksToWait);
     a26:	9901      	ldr	r1, [sp, #4]
     a28:	4b2a      	ldr	r3, [pc, #168]	; (ad4 <xQueueGenericReceive+0x184>)
     a2a:	f104 0024 	add.w	r0, r4, #36	; 0x24
     a2e:	4798      	blx	r3
				prvUnlockQueue(pxQueue);
     a30:	4620      	mov	r0, r4
     a32:	47b8      	blx	r7
				if (xTaskResumeAll() == pdFALSE) {
     a34:	47b0      	blx	r6
     a36:	b970      	cbnz	r0, a56 <xQueueGenericReceive+0x106>
					portYIELD_WITHIN_API();
     a38:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
     a3c:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
     a40:	f8c3 2d04 	str.w	r2, [r3, #3332]	; 0xd04
     a44:	f3bf 8f4f 	dsb	sy
     a48:	f3bf 8f6f 	isb	sy
     a4c:	e003      	b.n	a56 <xQueueGenericReceive+0x106>
	taskEXIT_CRITICAL();
     a4e:	47a8      	blx	r5
				prvUnlockQueue(pxQueue);
     a50:	4620      	mov	r0, r4
     a52:	47b8      	blx	r7
				(void)xTaskResumeAll();
     a54:	47b0      	blx	r6
     a56:	2701      	movs	r7, #1
		taskENTER_CRITICAL();
     a58:	47d8      	blx	fp
			if (pxQueue->uxMessagesWaiting > (UBaseType_t)0) {
     a5a:	6ba3      	ldr	r3, [r4, #56]	; 0x38
     a5c:	2b00      	cmp	r3, #0
     a5e:	d0b7      	beq.n	9d0 <xQueueGenericReceive+0x80>
				prvCopyDataFromQueue(pxQueue, pvBuffer);
     a60:	4b1d      	ldr	r3, [pc, #116]	; (ad8 <xQueueGenericReceive+0x188>)
				pcOriginalReadPosition = pxQueue->u.pcReadFrom;
     a62:	68e6      	ldr	r6, [r4, #12]
				prvCopyDataFromQueue(pxQueue, pvBuffer);
     a64:	4641      	mov	r1, r8
     a66:	4620      	mov	r0, r4
     a68:	4798      	blx	r3
				if (xJustPeeking == pdFALSE) {
     a6a:	f1b9 0f00 	cmp.w	r9, #0
     a6e:	d1a1      	bne.n	9b4 <xQueueGenericReceive+0x64>
					--(pxQueue->uxMessagesWaiting);
     a70:	6ba3      	ldr	r3, [r4, #56]	; 0x38
     a72:	3b01      	subs	r3, #1
     a74:	63a3      	str	r3, [r4, #56]	; 0x38
						if (pxQueue->uxQueueType == queueQUEUE_IS_MUTEX) {
     a76:	6823      	ldr	r3, [r4, #0]
     a78:	b913      	cbnz	r3, a80 <xQueueGenericReceive+0x130>
							    = (int8_t *)pvTaskIncrementMutexHeldCount(); /*lint !e961 Cast is not redundant as
     a7a:	4b18      	ldr	r3, [pc, #96]	; (adc <xQueueGenericReceive+0x18c>)
     a7c:	4798      	blx	r3
     a7e:	6060      	str	r0, [r4, #4]
					if (listLIST_IS_EMPTY(&(pxQueue->xTasksWaitingToSend)) == pdFALSE) {
     a80:	6923      	ldr	r3, [r4, #16]
     a82:	2b00      	cmp	r3, #0
     a84:	d09f      	beq.n	9c6 <xQueueGenericReceive+0x76>
						if (xTaskRemoveFromEventList(&(pxQueue->xTasksWaitingToSend)) == pdTRUE) {
     a86:	4b0c      	ldr	r3, [pc, #48]	; (ab8 <xQueueGenericReceive+0x168>)
     a88:	f104 0010 	add.w	r0, r4, #16
     a8c:	4798      	blx	r3
     a8e:	2801      	cmp	r0, #1
     a90:	d199      	bne.n	9c6 <xQueueGenericReceive+0x76>
							queueYIELD_IF_USING_PREEMPTION();
     a92:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
     a96:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
     a9a:	f8c3 2d04 	str.w	r2, [r3, #3332]	; 0xd04
     a9e:	f3bf 8f4f 	dsb	sy
     aa2:	f3bf 8f6f 	isb	sy
     aa6:	e78e      	b.n	9c6 <xQueueGenericReceive+0x76>
			prvUnlockQueue(pxQueue);
     aa8:	4620      	mov	r0, r4
     aaa:	47b8      	blx	r7
			(void)xTaskResumeAll();
     aac:	47b0      	blx	r6
     aae:	e792      	b.n	9d6 <xQueueGenericReceive+0x86>
     ab0:	00008475 	.word	0x00008475
     ab4:	00008f35 	.word	0x00008f35
     ab8:	00008341 	.word	0x00008341
     abc:	000083c1 	.word	0x000083c1
     ac0:	00007f25 	.word	0x00007f25
     ac4:	00000429 	.word	0x00000429
     ac8:	00008039 	.word	0x00008039
     acc:	000083e9 	.word	0x000083e9
     ad0:	00008495 	.word	0x00008495
     ad4:	00008289 	.word	0x00008289
     ad8:	000003f9 	.word	0x000003f9
     adc:	0000859d 	.word	0x0000859d
     ae0:	00008ef5 	.word	0x00008ef5

00000ae4 <vQueueDelete>:
	configASSERT(pxQueue);
     ae4:	b940      	cbnz	r0, af8 <vQueueDelete+0x14>
     ae6:	f04f 0380 	mov.w	r3, #128	; 0x80
     aea:	f383 8811 	msr	BASEPRI, r3
     aee:	f3bf 8f6f 	isb	sy
     af2:	f3bf 8f4f 	dsb	sy
     af6:	e7fe      	b.n	af6 <vQueueDelete+0x12>
	vPortFree(pxQueue);
     af8:	4b00      	ldr	r3, [pc, #0]	; (afc <vQueueDelete+0x18>)
     afa:	4718      	bx	r3
     afc:	00001d51 	.word	0x00001d51

00000b00 <vQueueWaitForMessageRestricted>:
{
     b00:	b570      	push	{r4, r5, r6, lr}
     b02:	4604      	mov	r4, r0
	prvLockQueue(pxQueue);
     b04:	4b0e      	ldr	r3, [pc, #56]	; (b40 <vQueueWaitForMessageRestricted+0x40>)
{
     b06:	460d      	mov	r5, r1
     b08:	4616      	mov	r6, r2
	prvLockQueue(pxQueue);
     b0a:	4798      	blx	r3
     b0c:	6c63      	ldr	r3, [r4, #68]	; 0x44
     b0e:	3301      	adds	r3, #1
     b10:	bf04      	itt	eq
     b12:	2300      	moveq	r3, #0
     b14:	6463      	streq	r3, [r4, #68]	; 0x44
     b16:	6ca3      	ldr	r3, [r4, #72]	; 0x48
     b18:	3301      	adds	r3, #1
     b1a:	bf04      	itt	eq
     b1c:	2300      	moveq	r3, #0
     b1e:	64a3      	streq	r3, [r4, #72]	; 0x48
     b20:	4b08      	ldr	r3, [pc, #32]	; (b44 <vQueueWaitForMessageRestricted+0x44>)
     b22:	4798      	blx	r3
	if (pxQueue->uxMessagesWaiting == (UBaseType_t)0U) {
     b24:	6ba3      	ldr	r3, [r4, #56]	; 0x38
     b26:	b92b      	cbnz	r3, b34 <vQueueWaitForMessageRestricted+0x34>
		vTaskPlaceOnEventListRestricted(&(pxQueue->xTasksWaitingToReceive), xTicksToWait, xWaitIndefinitely);
     b28:	4b07      	ldr	r3, [pc, #28]	; (b48 <vQueueWaitForMessageRestricted+0x48>)
     b2a:	4632      	mov	r2, r6
     b2c:	4629      	mov	r1, r5
     b2e:	f104 0024 	add.w	r0, r4, #36	; 0x24
     b32:	4798      	blx	r3
	prvUnlockQueue(pxQueue);
     b34:	4620      	mov	r0, r4
     b36:	4b05      	ldr	r3, [pc, #20]	; (b4c <vQueueWaitForMessageRestricted+0x4c>)
}
     b38:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	prvUnlockQueue(pxQueue);
     b3c:	4718      	bx	r3
     b3e:	bf00      	nop
     b40:	00008ef5 	.word	0x00008ef5
     b44:	00008f35 	.word	0x00008f35
     b48:	000082e5 	.word	0x000082e5
     b4c:	00000429 	.word	0x00000429

00000b50 <_sbrk>:
extern caddr_t _sbrk(int incr)
{
	static unsigned char *heap = NULL;
	unsigned char *       prev_heap;

	if (heap == NULL) {
     b50:	4a04      	ldr	r2, [pc, #16]	; (b64 <_sbrk+0x14>)
     b52:	6811      	ldr	r1, [r2, #0]
{
     b54:	4603      	mov	r3, r0
	if (heap == NULL) {
     b56:	b909      	cbnz	r1, b5c <_sbrk+0xc>
		heap = (unsigned char *)&_end;
     b58:	4903      	ldr	r1, [pc, #12]	; (b68 <_sbrk+0x18>)
     b5a:	6011      	str	r1, [r2, #0]
	}
	prev_heap = heap;
     b5c:	6810      	ldr	r0, [r2, #0]

	heap += incr;
     b5e:	4403      	add	r3, r0
     b60:	6013      	str	r3, [r2, #0]

	return (caddr_t)prev_heap;
}
     b62:	4770      	bx	lr
     b64:	200000a0 	.word	0x200000a0
     b68:	200263b0 	.word	0x200263b0

00000b6c <_close>:
 */
extern int _close(int file)
{
	(void)file;
	return -1;
}
     b6c:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
     b70:	4770      	bx	lr

00000b72 <_fstat>:
 * \brief Replacement of C library of _fstat
 */
extern int _fstat(int file, struct stat *st)
{
	(void)file;
	st->st_mode = S_IFCHR;
     b72:	f44f 5300 	mov.w	r3, #8192	; 0x2000
     b76:	604b      	str	r3, [r1, #4]

	return 0;
}
     b78:	2000      	movs	r0, #0
     b7a:	4770      	bx	lr

00000b7c <_isatty>:
 */
extern int _isatty(int file)
{
	(void)file;
	return 1;
}
     b7c:	2001      	movs	r0, #1
     b7e:	4770      	bx	lr

00000b80 <_lseek>:
 */
extern int _lseek(int file, int ptr, int dir)
{
	(void)file, (void)ptr, (void)dir;
	return 0;
}
     b80:	2000      	movs	r0, #0
     b82:	4770      	bx	lr

00000b84 <icmp_send_response>:
 *          p->payload pointing to the IP header
 * @param type Type of the ICMP header
 * @param code Code of the ICMP header
 */
static void icmp_send_response(struct pbuf *p, u8_t type, u8_t code)
{
     b84:	e92d 41ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, lr}
	/* we can use the echo header here */
	struct icmp_echo_hdr *icmphdr;
	ip_addr_t             iphdr_src;

	/* ICMP header + IP header + 8 bytes of data */
	q = pbuf_alloc(PBUF_IP, sizeof(struct icmp_echo_hdr) + IP_HLEN + ICMP_DEST_UNREACH_DATASIZE, PBUF_RAM);
     b88:	4b1b      	ldr	r3, [pc, #108]	; (bf8 <icmp_send_response+0x74>)
{
     b8a:	4604      	mov	r4, r0
     b8c:	4688      	mov	r8, r1
     b8e:	4616      	mov	r6, r2
	q = pbuf_alloc(PBUF_IP, sizeof(struct icmp_echo_hdr) + IP_HLEN + ICMP_DEST_UNREACH_DATASIZE, PBUF_RAM);
     b90:	2124      	movs	r1, #36	; 0x24
     b92:	2200      	movs	r2, #0
     b94:	2001      	movs	r0, #1
     b96:	4798      	blx	r3
	if (q == NULL) {
     b98:	4605      	mov	r5, r0
     b9a:	b350      	cbz	r0, bf2 <icmp_send_response+0x6e>
		return;
	}
	LWIP_ASSERT("check that first pbuf can hold icmp message",
	            (q->len >= (sizeof(struct icmp_echo_hdr) + IP_HLEN + ICMP_DEST_UNREACH_DATASIZE)));

	iphdr = (struct ip_hdr *)p->payload;
     b9c:	6867      	ldr	r7, [r4, #4]
	ip_addr_debug_print(ICMP_DEBUG, &(iphdr->src));
	LWIP_DEBUGF(ICMP_DEBUG, (" to "));
	ip_addr_debug_print(ICMP_DEBUG, &(iphdr->dest));
	LWIP_DEBUGF(ICMP_DEBUG, ("\n"));

	icmphdr        = (struct icmp_echo_hdr *)q->payload;
     b9e:	6844      	ldr	r4, [r0, #4]
	icmphdr->type  = type;
	icmphdr->code  = code;
	icmphdr->id    = 0;
     ba0:	2300      	movs	r3, #0
     ba2:	7123      	strb	r3, [r4, #4]
     ba4:	7163      	strb	r3, [r4, #5]
	icmphdr->seqno = 0;
     ba6:	71a3      	strb	r3, [r4, #6]
     ba8:	71e3      	strb	r3, [r4, #7]
	icmphdr->type  = type;
     baa:	f884 8000 	strb.w	r8, [r4]
	icmphdr->code  = code;
     bae:	7066      	strb	r6, [r4, #1]

	/* copy fields from original packet */
	SMEMCPY(
     bb0:	463b      	mov	r3, r7
     bb2:	f104 0208 	add.w	r2, r4, #8
     bb6:	f107 011c 	add.w	r1, r7, #28
     bba:	f853 0b04 	ldr.w	r0, [r3], #4
     bbe:	f842 0b04 	str.w	r0, [r2], #4
     bc2:	428b      	cmp	r3, r1
     bc4:	d1f9      	bne.n	bba <icmp_send_response+0x36>
	    (u8_t *)q->payload + sizeof(struct icmp_echo_hdr), (u8_t *)p->payload, IP_HLEN + ICMP_DEST_UNREACH_DATASIZE);

	/* calculate checksum */
	icmphdr->chksum = 0;
     bc6:	2600      	movs	r6, #0
	icmphdr->chksum = inet_chksum(icmphdr, q->len);
     bc8:	8969      	ldrh	r1, [r5, #10]
     bca:	4b0c      	ldr	r3, [pc, #48]	; (bfc <icmp_send_response+0x78>)
	icmphdr->chksum = 0;
     bcc:	70a6      	strb	r6, [r4, #2]
     bce:	70e6      	strb	r6, [r4, #3]
	icmphdr->chksum = inet_chksum(icmphdr, q->len);
     bd0:	4620      	mov	r0, r4
     bd2:	4798      	blx	r3
     bd4:	8060      	strh	r0, [r4, #2]
	ICMP_STATS_INC(icmp.xmit);
	/* increase number of messages attempted to send */
	snmp_inc_icmpoutmsgs();
	/* increase number of destination unreachable messages attempted to send */
	snmp_inc_icmpouttimeexcds();
	ip_addr_copy(iphdr_src, iphdr->src);
     bd6:	68fb      	ldr	r3, [r7, #12]
     bd8:	9303      	str	r3, [sp, #12]
	ip_output(q, NULL, &iphdr_src, ICMP_TTL, 0, IP_PROTO_ICMP);
     bda:	2301      	movs	r3, #1
     bdc:	e9cd 6300 	strd	r6, r3, [sp]
     be0:	4c07      	ldr	r4, [pc, #28]	; (c00 <icmp_send_response+0x7c>)
     be2:	23ff      	movs	r3, #255	; 0xff
     be4:	aa03      	add	r2, sp, #12
     be6:	4631      	mov	r1, r6
     be8:	4628      	mov	r0, r5
     bea:	47a0      	blx	r4
	pbuf_free(q);
     bec:	4b05      	ldr	r3, [pc, #20]	; (c04 <icmp_send_response+0x80>)
     bee:	4628      	mov	r0, r5
     bf0:	4798      	blx	r3
}
     bf2:	b004      	add	sp, #16
     bf4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
     bf8:	000030d9 	.word	0x000030d9
     bfc:	000074a9 	.word	0x000074a9
     c00:	00005671 	.word	0x00005671
     c04:	00003081 	.word	0x00003081

00000c08 <icmp_input>:
{
     c08:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	iphdr = (struct ip_hdr *)p->payload;
     c0c:	6846      	ldr	r6, [r0, #4]
	if (pbuf_header(p, -hlen) || (p->tot_len < sizeof(u16_t) * 2)) {
     c0e:	4f45      	ldr	r7, [pc, #276]	; (d24 <icmp_input+0x11c>)
	hlen  = IPH_HL(iphdr) * 4;
     c10:	7835      	ldrb	r5, [r6, #0]
     c12:	f8df 8134 	ldr.w	r8, [pc, #308]	; d48 <icmp_input+0x140>
     c16:	f005 050f 	and.w	r5, r5, #15
     c1a:	00ad      	lsls	r5, r5, #2
{
     c1c:	b087      	sub	sp, #28
	if (pbuf_header(p, -hlen) || (p->tot_len < sizeof(u16_t) * 2)) {
     c1e:	f1c5 0a00 	rsb	sl, r5, #0
     c22:	fa0f fa8a 	sxth.w	sl, sl
{
     c26:	9105      	str	r1, [sp, #20]
	if (pbuf_header(p, -hlen) || (p->tot_len < sizeof(u16_t) * 2)) {
     c28:	4651      	mov	r1, sl
{
     c2a:	4604      	mov	r4, r0
	if (pbuf_header(p, -hlen) || (p->tot_len < sizeof(u16_t) * 2)) {
     c2c:	47b8      	blx	r7
     c2e:	b998      	cbnz	r0, c58 <icmp_input+0x50>
     c30:	8923      	ldrh	r3, [r4, #8]
     c32:	2b03      	cmp	r3, #3
     c34:	d910      	bls.n	c58 <icmp_input+0x50>
	type = *((u8_t *)p->payload);
     c36:	6863      	ldr	r3, [r4, #4]
	switch (type) {
     c38:	781b      	ldrb	r3, [r3, #0]
     c3a:	2b08      	cmp	r3, #8
     c3c:	d10c      	bne.n	c58 <icmp_input+0x50>
		if (ip_addr_ismulticast(&current_iphdr_dest)) {
     c3e:	f8df b100 	ldr.w	fp, [pc, #256]	; d40 <icmp_input+0x138>
		if (ip_addr_isbroadcast(&current_iphdr_dest, inp)) {
     c42:	9905      	ldr	r1, [sp, #20]
		if (ip_addr_ismulticast(&current_iphdr_dest)) {
     c44:	f8db 0000 	ldr.w	r0, [fp]
		if (ip_addr_isbroadcast(&current_iphdr_dest, inp)) {
     c48:	4a37      	ldr	r2, [pc, #220]	; (d28 <icmp_input+0x120>)
		if (ip_addr_ismulticast(&current_iphdr_dest)) {
     c4a:	f000 09f0 	and.w	r9, r0, #240	; 0xf0
		if (ip_addr_isbroadcast(&current_iphdr_dest, inp)) {
     c4e:	4790      	blx	r2
     c50:	b910      	cbnz	r0, c58 <icmp_input+0x50>
		if (!accepted) {
     c52:	f1b9 0fe0 	cmp.w	r9, #224	; 0xe0
     c56:	d105      	bne.n	c64 <icmp_input+0x5c>
	pbuf_free(p);
     c58:	4620      	mov	r0, r4
     c5a:	4643      	mov	r3, r8
}
     c5c:	b007      	add	sp, #28
     c5e:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	pbuf_free(p);
     c62:	4718      	bx	r3
		if (p->tot_len < sizeof(struct icmp_echo_hdr)) {
     c64:	8923      	ldrh	r3, [r4, #8]
     c66:	2b07      	cmp	r3, #7
     c68:	d9f6      	bls.n	c58 <icmp_input+0x50>
		if (inet_chksum_pbuf(p) != 0) {
     c6a:	4b30      	ldr	r3, [pc, #192]	; (d2c <icmp_input+0x124>)
     c6c:	4620      	mov	r0, r4
     c6e:	4798      	blx	r3
     c70:	2800      	cmp	r0, #0
     c72:	d1f1      	bne.n	c58 <icmp_input+0x50>
		if (pbuf_header(p, (PBUF_IP_HLEN + PBUF_LINK_HLEN))) {
     c74:	2124      	movs	r1, #36	; 0x24
     c76:	4620      	mov	r0, r4
	hlen  = IPH_HL(iphdr) * 4;
     c78:	b22d      	sxth	r5, r5
		if (pbuf_header(p, (PBUF_IP_HLEN + PBUF_LINK_HLEN))) {
     c7a:	47b8      	blx	r7
     c7c:	2800      	cmp	r0, #0
     c7e:	d04a      	beq.n	d16 <icmp_input+0x10e>
			if (pbuf_header(p, hlen)) {
     c80:	4629      	mov	r1, r5
     c82:	4620      	mov	r0, r4
     c84:	47b8      	blx	r7
     c86:	4602      	mov	r2, r0
     c88:	2800      	cmp	r0, #0
     c8a:	d1e5      	bne.n	c58 <icmp_input+0x50>
			r = pbuf_alloc(PBUF_LINK, p->tot_len, PBUF_RAM);
     c8c:	8921      	ldrh	r1, [r4, #8]
     c8e:	4b28      	ldr	r3, [pc, #160]	; (d30 <icmp_input+0x128>)
     c90:	2002      	movs	r0, #2
     c92:	4798      	blx	r3
			if (r == NULL) {
     c94:	4681      	mov	r9, r0
     c96:	2800      	cmp	r0, #0
     c98:	d0de      	beq.n	c58 <icmp_input+0x50>
			if (pbuf_copy(r, p) != ERR_OK) {
     c9a:	4a26      	ldr	r2, [pc, #152]	; (d34 <icmp_input+0x12c>)
     c9c:	4621      	mov	r1, r4
     c9e:	4790      	blx	r2
     ca0:	2800      	cmp	r0, #0
     ca2:	d1d9      	bne.n	c58 <icmp_input+0x50>
			if (pbuf_header(r, -hlen)) {
     ca4:	4651      	mov	r1, sl
     ca6:	4648      	mov	r0, r9
			iphdr = (struct ip_hdr *)r->payload;
     ca8:	f8d9 6004 	ldr.w	r6, [r9, #4]
			if (pbuf_header(r, -hlen)) {
     cac:	47b8      	blx	r7
     cae:	2800      	cmp	r0, #0
     cb0:	d1d2      	bne.n	c58 <icmp_input+0x50>
			pbuf_free(p);
     cb2:	4620      	mov	r0, r4
     cb4:	47c0      	blx	r8
			p = r;
     cb6:	464c      	mov	r4, r9
		ip_addr_copy(iphdr->src, *ip_current_dest_addr());
     cb8:	f8db 3000 	ldr.w	r3, [fp]
		iecho = (struct icmp_echo_hdr *)p->payload;
     cbc:	6862      	ldr	r2, [r4, #4]
		ip_addr_copy(iphdr->src, *ip_current_dest_addr());
     cbe:	60f3      	str	r3, [r6, #12]
		ip_addr_copy(iphdr->dest, *ip_current_src_addr());
     cc0:	4b1d      	ldr	r3, [pc, #116]	; (d38 <icmp_input+0x130>)
     cc2:	681b      	ldr	r3, [r3, #0]
     cc4:	6133      	str	r3, [r6, #16]
		ICMPH_TYPE_SET(iecho, ICMP_ER);
     cc6:	2300      	movs	r3, #0
     cc8:	7013      	strb	r3, [r2, #0]
		if (iecho->chksum >= PP_HTONS(0xffffU - (ICMP_ECHO << 8))) {
     cca:	8853      	ldrh	r3, [r2, #2]
     ccc:	f64f 71f6 	movw	r1, #65526	; 0xfff6
     cd0:	428b      	cmp	r3, r1
			iecho->chksum += PP_HTONS(ICMP_ECHO << 8) + 1;
     cd2:	bf8c      	ite	hi
     cd4:	3309      	addhi	r3, #9
			iecho->chksum += PP_HTONS(ICMP_ECHO << 8);
     cd6:	3308      	addls	r3, #8
     cd8:	b29b      	uxth	r3, r3
     cda:	8053      	strh	r3, [r2, #2]
		IPH_TTL_SET(iphdr, ICMP_TTL);
     cdc:	f04f 0aff 	mov.w	sl, #255	; 0xff
		IPH_CHKSUM_SET(iphdr, 0);
     ce0:	2300      	movs	r3, #0
     ce2:	72b3      	strb	r3, [r6, #10]
     ce4:	72f3      	strb	r3, [r6, #11]
		IPH_CHKSUM_SET(iphdr, inet_chksum(iphdr, IP_HLEN));
     ce6:	2114      	movs	r1, #20
     ce8:	4b14      	ldr	r3, [pc, #80]	; (d3c <icmp_input+0x134>)
		IPH_TTL_SET(iphdr, ICMP_TTL);
     cea:	f886 a008 	strb.w	sl, [r6, #8]
		IPH_CHKSUM_SET(iphdr, inet_chksum(iphdr, IP_HLEN));
     cee:	4630      	mov	r0, r6
     cf0:	4798      	blx	r3
		if (pbuf_header(p, hlen)) {
     cf2:	4629      	mov	r1, r5
		IPH_CHKSUM_SET(iphdr, inet_chksum(iphdr, IP_HLEN));
     cf4:	8170      	strh	r0, [r6, #10]
		if (pbuf_header(p, hlen)) {
     cf6:	4620      	mov	r0, r4
     cf8:	47b8      	blx	r7
     cfa:	4602      	mov	r2, r0
     cfc:	2800      	cmp	r0, #0
     cfe:	d1ab      	bne.n	c58 <icmp_input+0x50>
			ret = ip_output_if(p, ip_current_dest_addr(), IP_HDRINCL, ICMP_TTL, 0, IP_PROTO_ICMP, inp);
     d00:	9b05      	ldr	r3, [sp, #20]
     d02:	9302      	str	r3, [sp, #8]
     d04:	2301      	movs	r3, #1
     d06:	e9cd 0300 	strd	r0, r3, [sp]
     d0a:	490d      	ldr	r1, [pc, #52]	; (d40 <icmp_input+0x138>)
     d0c:	4d0d      	ldr	r5, [pc, #52]	; (d44 <icmp_input+0x13c>)
     d0e:	4653      	mov	r3, sl
     d10:	4620      	mov	r0, r4
     d12:	47a8      	blx	r5
	pbuf_free(p);
     d14:	e7a0      	b.n	c58 <icmp_input+0x50>
			if (pbuf_header(p, -(s16_t)(PBUF_IP_HLEN + PBUF_LINK_HLEN))) {
     d16:	f06f 0123 	mvn.w	r1, #35	; 0x23
     d1a:	4620      	mov	r0, r4
     d1c:	47b8      	blx	r7
     d1e:	2800      	cmp	r0, #0
     d20:	d0ca      	beq.n	cb8 <icmp_input+0xb0>
     d22:	e799      	b.n	c58 <icmp_input+0x50>
     d24:	00003029 	.word	0x00003029
     d28:	00007aaf 	.word	0x00007aaf
     d2c:	000074b9 	.word	0x000074b9
     d30:	000030d9 	.word	0x000030d9
     d34:	0000328d 	.word	0x0000328d
     d38:	200110b4 	.word	0x200110b4
     d3c:	000074a9 	.word	0x000074a9
     d40:	200110b0 	.word	0x200110b0
     d44:	00005585 	.word	0x00005585
     d48:	00003081 	.word	0x00003081

00000d4c <icmp_dest_unreach>:
{
     d4c:	460a      	mov	r2, r1
	icmp_send_response(p, ICMP_DUR, t);
     d4e:	4b01      	ldr	r3, [pc, #4]	; (d54 <icmp_dest_unreach+0x8>)
     d50:	2103      	movs	r1, #3
     d52:	4718      	bx	r3
     d54:	00000b85 	.word	0x00000b85

00000d58 <icmp_time_exceeded>:
{
     d58:	460a      	mov	r2, r1
	icmp_send_response(p, ICMP_TE, t);
     d5a:	4b01      	ldr	r3, [pc, #4]	; (d60 <icmp_time_exceeded+0x8>)
     d5c:	210b      	movs	r1, #11
     d5e:	4718      	bx	r3
     d60:	00000b85 	.word	0x00000b85

00000d64 <lwip_htons>:
 * @param n u16_t in host byte order
 * @return n in network byte order
 */
u16_t lwip_htons(u16_t n)
{
	return ((n & 0xff) << 8) | ((n & 0xff00) >> 8);
     d64:	ba40      	rev16	r0, r0
}
     d66:	b280      	uxth	r0, r0
     d68:	4770      	bx	lr

00000d6a <lwip_ntohs>:
     d6a:	ba40      	rev16	r0, r0
     d6c:	b280      	uxth	r0, r0
     d6e:	4770      	bx	lr

00000d70 <lwip_htonl>:
 * @return n in network byte order
 */
u32_t lwip_htonl(u32_t n)
{
	return ((n & 0xff) << 24) | ((n & 0xff00) << 8) | ((n & 0xff0000UL) >> 8) | ((n & 0xff000000UL) >> 24);
}
     d70:	ba00      	rev	r0, r0
     d72:	4770      	bx	lr

00000d74 <lwip_ntohl>:
 * @param n u32_t in network byte order
 * @return n in host byte order
 */
u32_t lwip_ntohl(u32_t n)
{
	return lwip_htonl(n);
     d74:	4b00      	ldr	r3, [pc, #0]	; (d78 <lwip_ntohl+0x4>)
     d76:	4718      	bx	r3
     d78:	00000d71 	.word	0x00000d71

00000d7c <netbuf_delete>:
 * Deallocate a netbuf allocated by netbuf_new().
 *
 * @param buf pointer to a netbuf allocated by netbuf_new()
 */
void netbuf_delete(struct netbuf *buf)
{
     d7c:	b510      	push	{r4, lr}
	if (buf != NULL) {
     d7e:	4604      	mov	r4, r0
     d80:	b160      	cbz	r0, d9c <netbuf_delete+0x20>
		if (buf->p != NULL) {
     d82:	6800      	ldr	r0, [r0, #0]
     d84:	b120      	cbz	r0, d90 <netbuf_delete+0x14>
			pbuf_free(buf->p);
     d86:	4b06      	ldr	r3, [pc, #24]	; (da0 <netbuf_delete+0x24>)
     d88:	4798      	blx	r3
			buf->p = buf->ptr = NULL;
     d8a:	2300      	movs	r3, #0
     d8c:	e9c4 3300 	strd	r3, r3, [r4]
		}
		memp_free(MEMP_NETBUF, buf);
     d90:	4621      	mov	r1, r4
     d92:	4b04      	ldr	r3, [pc, #16]	; (da4 <netbuf_delete+0x28>)
	}
}
     d94:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		memp_free(MEMP_NETBUF, buf);
     d98:	2006      	movs	r0, #6
     d9a:	4718      	bx	r3
}
     d9c:	bd10      	pop	{r4, pc}
     d9e:	bf00      	nop
     da0:	00003081 	.word	0x00003081
     da4:	00004b49 	.word	0x00004b49

00000da8 <netbuf_free>:
 * Free the packet buffer included in a netbuf
 *
 * @param buf pointer to the netbuf which contains the packet buffer to free
 */
void netbuf_free(struct netbuf *buf)
{
     da8:	b510      	push	{r4, lr}
	LWIP_ERROR("netbuf_free: invalid buf", (buf != NULL), return;);
     daa:	4604      	mov	r4, r0
     dac:	b900      	cbnz	r0, db0 <netbuf_free+0x8>
     dae:	e7fe      	b.n	dae <netbuf_free+0x6>
	if (buf->p != NULL) {
     db0:	6800      	ldr	r0, [r0, #0]
     db2:	b108      	cbz	r0, db8 <netbuf_free+0x10>
		pbuf_free(buf->p);
     db4:	4b02      	ldr	r3, [pc, #8]	; (dc0 <netbuf_free+0x18>)
     db6:	4798      	blx	r3
	}
	buf->p = buf->ptr = NULL;
     db8:	2300      	movs	r3, #0
     dba:	e9c4 3300 	strd	r3, r3, [r4]
}
     dbe:	bd10      	pop	{r4, pc}
     dc0:	00003081 	.word	0x00003081

00000dc4 <netbuf_ref>:
 * @param size size of the data
 * @return ERR_OK if data is referenced
 *         ERR_MEM if data couldn't be referenced due to lack of memory
 */
err_t netbuf_ref(struct netbuf *buf, const void *dataptr, u16_t size)
{
     dc4:	b570      	push	{r4, r5, r6, lr}
     dc6:	460e      	mov	r6, r1
     dc8:	4615      	mov	r5, r2
	LWIP_ERROR("netbuf_ref: invalid buf", (buf != NULL), return ERR_ARG;);
     dca:	4604      	mov	r4, r0
     dcc:	b900      	cbnz	r0, dd0 <netbuf_ref+0xc>
     dce:	e7fe      	b.n	dce <netbuf_ref+0xa>
	if (buf->p != NULL) {
     dd0:	6800      	ldr	r0, [r0, #0]
     dd2:	b108      	cbz	r0, dd8 <netbuf_ref+0x14>
		pbuf_free(buf->p);
     dd4:	4b09      	ldr	r3, [pc, #36]	; (dfc <netbuf_ref+0x38>)
     dd6:	4798      	blx	r3
	}
	buf->p = pbuf_alloc(PBUF_TRANSPORT, 0, PBUF_REF);
     dd8:	2100      	movs	r1, #0
     dda:	4b09      	ldr	r3, [pc, #36]	; (e00 <netbuf_ref+0x3c>)
     ddc:	2202      	movs	r2, #2
     dde:	4608      	mov	r0, r1
     de0:	4798      	blx	r3
     de2:	6020      	str	r0, [r4, #0]
	if (buf->p == NULL) {
     de4:	b918      	cbnz	r0, dee <netbuf_ref+0x2a>
		buf->ptr = NULL;
     de6:	6060      	str	r0, [r4, #4]
		return ERR_MEM;
     de8:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
	}
	buf->p->payload = (void *)dataptr;
	buf->p->len = buf->p->tot_len = size;
	buf->ptr                      = buf->p;
	return ERR_OK;
}
     dec:	bd70      	pop	{r4, r5, r6, pc}
	buf->p->payload = (void *)dataptr;
     dee:	6046      	str	r6, [r0, #4]
	buf->p->len = buf->p->tot_len = size;
     df0:	8105      	strh	r5, [r0, #8]
     df2:	8145      	strh	r5, [r0, #10]
	buf->ptr                      = buf->p;
     df4:	6060      	str	r0, [r4, #4]
	return ERR_OK;
     df6:	2000      	movs	r0, #0
     df8:	e7f8      	b.n	dec <netbuf_ref+0x28>
     dfa:	bf00      	nop
     dfc:	00003081 	.word	0x00003081
     e00:	000030d9 	.word	0x000030d9

00000e04 <ETHERNET_PHY_0_init>:
#include <ethernet_phy_main.h>

struct ethernet_phy_descriptor ETHERNET_PHY_0_desc;

void ETHERNET_PHY_0_init(void)
{
     e04:	b510      	push	{r4, lr}
	mac_async_enable(&COMMUNICATION_IO);
     e06:	4905      	ldr	r1, [pc, #20]	; (e1c <ETHERNET_PHY_0_init+0x18>)
     e08:	4b05      	ldr	r3, [pc, #20]	; (e20 <ETHERNET_PHY_0_init+0x1c>)
     e0a:	4608      	mov	r0, r1
     e0c:	4798      	blx	r3
	ethernet_phy_init(&ETHERNET_PHY_0_desc, &COMMUNICATION_IO, CONF_ETHERNET_PHY_0_IEEE8023_MII_PHY_ADDRESS);
#if CONF_ETHERNET_PHY_0_IEEE8023_MII_CONTROL_REG0_SETTING == 1
	ethernet_phy_write_reg(&ETHERNET_PHY_0_desc, MDIO_REG0_BMCR, CONF_ETHERNET_PHY_0_IEEE8023_MII_CONTROL_REG0);
#endif /* CONF_ETHERNET_PHY_0_IEEE8023_MII_CONTROL_REG0_SETTING */
}
     e0e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	ethernet_phy_init(&ETHERNET_PHY_0_desc, &COMMUNICATION_IO, CONF_ETHERNET_PHY_0_IEEE8023_MII_PHY_ADDRESS);
     e12:	4902      	ldr	r1, [pc, #8]	; (e1c <ETHERNET_PHY_0_init+0x18>)
     e14:	4803      	ldr	r0, [pc, #12]	; (e24 <ETHERNET_PHY_0_init+0x20>)
     e16:	4b04      	ldr	r3, [pc, #16]	; (e28 <ETHERNET_PHY_0_init+0x24>)
     e18:	2200      	movs	r2, #0
     e1a:	4718      	bx	r3
     e1c:	2000a520 	.word	0x2000a520
     e20:	00004b9d 	.word	0x00004b9d
     e24:	200000a4 	.word	0x200000a4
     e28:	00000fd5 	.word	0x00000fd5

00000e2c <ethernet_phys_init>:
}

void ethernet_phys_init(void)
{

	ETHERNET_PHY_0_init();
     e2c:	4b00      	ldr	r3, [pc, #0]	; (e30 <ethernet_phys_init+0x4>)
     e2e:	4718      	bx	r3
     e30:	00000e05 	.word	0x00000e05

00000e34 <usart_sync_write>:
 * \param[in] length The number of bytes to write
 *
 * \return The number of bytes written.
 */
static int32_t usart_sync_write(struct io_descriptor *const io_descr, const uint8_t *const buf, const uint16_t length)
{
     e34:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
     e38:	460e      	mov	r6, r1
     e3a:	4615      	mov	r5, r2
	uint32_t                      offset = 0;
	struct usart_sync_descriptor *descr  = CONTAINER_OF(io_descr, struct usart_sync_descriptor, io);

	ASSERT(io_descr && buf && length);
     e3c:	4604      	mov	r4, r0
     e3e:	b118      	cbz	r0, e48 <usart_sync_write+0x14>
     e40:	b329      	cbz	r1, e8e <usart_sync_write+0x5a>
     e42:	1e10      	subs	r0, r2, #0
     e44:	bf18      	it	ne
     e46:	2001      	movne	r0, #1
     e48:	4912      	ldr	r1, [pc, #72]	; (e94 <usart_sync_write+0x60>)
     e4a:	4b13      	ldr	r3, [pc, #76]	; (e98 <usart_sync_write+0x64>)
	while (!_usart_sync_is_ready_to_send(&descr->device))
     e4c:	4f13      	ldr	r7, [pc, #76]	; (e9c <usart_sync_write+0x68>)
	ASSERT(io_descr && buf && length);
     e4e:	22f1      	movs	r2, #241	; 0xf1
     e50:	4798      	blx	r3
	while (!_usart_sync_is_ready_to_send(&descr->device))
     e52:	3408      	adds	r4, #8
     e54:	46b9      	mov	r9, r7
     e56:	4620      	mov	r0, r4
     e58:	47b8      	blx	r7
     e5a:	2800      	cmp	r0, #0
     e5c:	d0fb      	beq.n	e56 <usart_sync_write+0x22>
		;
	do {
		_usart_sync_write_byte(&descr->device, buf[offset]);
     e5e:	f8df 8044 	ldr.w	r8, [pc, #68]	; ea4 <usart_sync_write+0x70>
	uint32_t                      offset = 0;
     e62:	2700      	movs	r7, #0
		_usart_sync_write_byte(&descr->device, buf[offset]);
     e64:	5df1      	ldrb	r1, [r6, r7]
     e66:	4620      	mov	r0, r4
     e68:	47c0      	blx	r8
		while (!_usart_sync_is_ready_to_send(&descr->device))
     e6a:	4620      	mov	r0, r4
     e6c:	47c8      	blx	r9
     e6e:	2800      	cmp	r0, #0
     e70:	d0fb      	beq.n	e6a <usart_sync_write+0x36>
			;
	} while (++offset < length);
     e72:	3701      	adds	r7, #1
     e74:	42bd      	cmp	r5, r7
     e76:	d8f5      	bhi.n	e64 <usart_sync_write+0x30>
     e78:	2d00      	cmp	r5, #0
	while (!_usart_sync_is_transmit_done(&descr->device))
     e7a:	4e09      	ldr	r6, [pc, #36]	; (ea0 <usart_sync_write+0x6c>)
	} while (++offset < length);
     e7c:	bf08      	it	eq
     e7e:	2501      	moveq	r5, #1
	while (!_usart_sync_is_transmit_done(&descr->device))
     e80:	4620      	mov	r0, r4
     e82:	47b0      	blx	r6
     e84:	2800      	cmp	r0, #0
     e86:	d0fb      	beq.n	e80 <usart_sync_write+0x4c>
		;
	return (int32_t)offset;
}
     e88:	4628      	mov	r0, r5
     e8a:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
	ASSERT(io_descr && buf && length);
     e8e:	4608      	mov	r0, r1
     e90:	e7da      	b.n	e48 <usart_sync_write+0x14>
     e92:	bf00      	nop
     e94:	0000a73c 	.word	0x0000a73c
     e98:	00007aa9 	.word	0x00007aa9
     e9c:	00006deb 	.word	0x00006deb
     ea0:	00006df5 	.word	0x00006df5
     ea4:	00006ddd 	.word	0x00006ddd

00000ea8 <usart_sync_read>:
 * \param[in] length The size of a buffer
 *
 * \return The number of bytes read.
 */
static int32_t usart_sync_read(struct io_descriptor *const io_descr, uint8_t *const buf, const uint16_t length)
{
     ea8:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
     eac:	460e      	mov	r6, r1
     eae:	4615      	mov	r5, r2
	uint32_t                      offset = 0;
	struct usart_sync_descriptor *descr  = CONTAINER_OF(io_descr, struct usart_sync_descriptor, io);

	ASSERT(io_descr && buf && length);
     eb0:	4604      	mov	r4, r0
     eb2:	b118      	cbz	r0, ebc <usart_sync_read+0x14>
     eb4:	b1e9      	cbz	r1, ef2 <usart_sync_read+0x4a>
     eb6:	1e10      	subs	r0, r2, #0
     eb8:	bf18      	it	ne
     eba:	2001      	movne	r0, #1
     ebc:	490e      	ldr	r1, [pc, #56]	; (ef8 <usart_sync_read+0x50>)
     ebe:	4b0f      	ldr	r3, [pc, #60]	; (efc <usart_sync_read+0x54>)
	do {
		while (!_usart_sync_is_byte_received(&descr->device))
     ec0:	f8df 903c 	ldr.w	r9, [pc, #60]	; f00 <usart_sync_read+0x58>
			;
		buf[offset] = _usart_sync_read_byte(&descr->device);
     ec4:	f8df 803c 	ldr.w	r8, [pc, #60]	; f04 <usart_sync_read+0x5c>
	ASSERT(io_descr && buf && length);
     ec8:	f44f 7286 	mov.w	r2, #268	; 0x10c
     ecc:	4798      	blx	r3
	uint32_t                      offset = 0;
     ece:	2700      	movs	r7, #0
		while (!_usart_sync_is_byte_received(&descr->device))
     ed0:	3408      	adds	r4, #8
     ed2:	4620      	mov	r0, r4
     ed4:	47c8      	blx	r9
     ed6:	2800      	cmp	r0, #0
     ed8:	d0fb      	beq.n	ed2 <usart_sync_read+0x2a>
		buf[offset] = _usart_sync_read_byte(&descr->device);
     eda:	4620      	mov	r0, r4
     edc:	47c0      	blx	r8
     ede:	55f0      	strb	r0, [r6, r7]
	} while (++offset < length);
     ee0:	3701      	adds	r7, #1
     ee2:	42bd      	cmp	r5, r7
     ee4:	d8f5      	bhi.n	ed2 <usart_sync_read+0x2a>
     ee6:	2d00      	cmp	r5, #0

	return (int32_t)offset;
}
     ee8:	bf14      	ite	ne
     eea:	4628      	movne	r0, r5
     eec:	2001      	moveq	r0, #1
     eee:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
	ASSERT(io_descr && buf && length);
     ef2:	4608      	mov	r0, r1
     ef4:	e7e2      	b.n	ebc <usart_sync_read+0x14>
     ef6:	bf00      	nop
     ef8:	0000a73c 	.word	0x0000a73c
     efc:	00007aa9 	.word	0x00007aa9
     f00:	00006dff 	.word	0x00006dff
     f04:	00006de3 	.word	0x00006de3

00000f08 <usart_sync_init>:
{
     f08:	b538      	push	{r3, r4, r5, lr}
     f0a:	460d      	mov	r5, r1
	ASSERT(descr && hw);
     f0c:	4604      	mov	r4, r0
     f0e:	b110      	cbz	r0, f16 <usart_sync_init+0xe>
     f10:	1e08      	subs	r0, r1, #0
     f12:	bf18      	it	ne
     f14:	2001      	movne	r0, #1
     f16:	4907      	ldr	r1, [pc, #28]	; (f34 <usart_sync_init+0x2c>)
     f18:	4b07      	ldr	r3, [pc, #28]	; (f38 <usart_sync_init+0x30>)
     f1a:	2234      	movs	r2, #52	; 0x34
     f1c:	4798      	blx	r3
	init_status = _usart_sync_init(&descr->device, hw);
     f1e:	4b07      	ldr	r3, [pc, #28]	; (f3c <usart_sync_init+0x34>)
     f20:	4629      	mov	r1, r5
     f22:	f104 0008 	add.w	r0, r4, #8
     f26:	4798      	blx	r3
	if (init_status) {
     f28:	b918      	cbnz	r0, f32 <usart_sync_init+0x2a>
	descr->io.read  = usart_sync_read;
     f2a:	4b05      	ldr	r3, [pc, #20]	; (f40 <usart_sync_init+0x38>)
     f2c:	6063      	str	r3, [r4, #4]
	descr->io.write = usart_sync_write;
     f2e:	4b05      	ldr	r3, [pc, #20]	; (f44 <usart_sync_init+0x3c>)
     f30:	6023      	str	r3, [r4, #0]
}
     f32:	bd38      	pop	{r3, r4, r5, pc}
     f34:	0000a73c 	.word	0x0000a73c
     f38:	00007aa9 	.word	0x00007aa9
     f3c:	00006d9d 	.word	0x00006d9d
     f40:	00000ea9 	.word	0x00000ea9
     f44:	00000e35 	.word	0x00000e35

00000f48 <usart_sync_enable>:
{
     f48:	b510      	push	{r4, lr}
	ASSERT(descr);
     f4a:	4604      	mov	r4, r0
     f4c:	3800      	subs	r0, #0
     f4e:	bf18      	it	ne
     f50:	2001      	movne	r0, #1
     f52:	4905      	ldr	r1, [pc, #20]	; (f68 <usart_sync_enable+0x20>)
     f54:	4b05      	ldr	r3, [pc, #20]	; (f6c <usart_sync_enable+0x24>)
     f56:	2253      	movs	r2, #83	; 0x53
     f58:	4798      	blx	r3
	_usart_sync_enable(&descr->device);
     f5a:	f104 0008 	add.w	r0, r4, #8
     f5e:	4b04      	ldr	r3, [pc, #16]	; (f70 <usart_sync_enable+0x28>)
     f60:	4798      	blx	r3
}
     f62:	2000      	movs	r0, #0
     f64:	bd10      	pop	{r4, pc}
     f66:	bf00      	nop
     f68:	0000a73c 	.word	0x0000a73c
     f6c:	00007aa9 	.word	0x00007aa9
     f70:	00006dc9 	.word	0x00006dc9

00000f74 <_read>:
#include <stdio.h>

int __attribute__((weak)) _read(int file, char *ptr, int len); /* Remove GCC compiler warning */

int __attribute__((weak)) _read(int file, char *ptr, int len)
{
     f74:	b508      	push	{r3, lr}
     f76:	4603      	mov	r3, r0
     f78:	4608      	mov	r0, r1
     f7a:	4611      	mov	r1, r2
	int n = 0;

	if (file != 0) {
     f7c:	b923      	cbnz	r3, f88 <_read+0x14>
		return -1;
	}

	n = stdio_io_read((uint8_t *)ptr, len);
     f7e:	4b04      	ldr	r3, [pc, #16]	; (f90 <_read+0x1c>)
     f80:	4798      	blx	r3
	if (n < 0) {
     f82:	ea40 70e0 	orr.w	r0, r0, r0, asr #31
		return -1;
	}

	return n;
}
     f86:	bd08      	pop	{r3, pc}
		return -1;
     f88:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
     f8c:	e7fb      	b.n	f86 <_read+0x12>
     f8e:	bf00      	nop
     f90:	000002d1 	.word	0x000002d1

00000f94 <_gclk_init_generators_by_fref>:

void _gclk_init_generators_by_fref(uint32_t bm)
{

#if CONF_GCLK_GENERATOR_0_CONFIG == 1
	if (bm & (1ul << 0)) {
     f94:	07c3      	lsls	r3, r0, #31
     f96:	d507      	bpl.n	fa8 <_gclk_init_generators_by_fref+0x14>
}

static inline void hri_gclk_write_GENCTRL_reg(const void *const hw, uint8_t index, hri_gclk_genctrl_reg_t data)
{
	GCLK_CRITICAL_SECTION_ENTER();
	((Gclk *)hw)->GENCTRL[index].reg = data;
     f98:	4b04      	ldr	r3, [pc, #16]	; (fac <_gclk_init_generators_by_fref+0x18>)
     f9a:	4a05      	ldr	r2, [pc, #20]	; (fb0 <_gclk_init_generators_by_fref+0x1c>)
     f9c:	621a      	str	r2, [r3, #32]
	while (((Gclk *)hw)->SYNCBUSY.reg & reg) {
     f9e:	f643 72fd 	movw	r2, #16381	; 0x3ffd
     fa2:	6859      	ldr	r1, [r3, #4]
     fa4:	4211      	tst	r1, r2
     fa6:	d1fc      	bne.n	fa2 <_gclk_init_generators_by_fref+0xe>
		        | (CONF_GCLK_GEN_11_DIVSEL << GCLK_GENCTRL_DIVSEL_Pos) | (CONF_GCLK_GEN_11_OE << GCLK_GENCTRL_OE_Pos)
		        | (CONF_GCLK_GEN_11_OOV << GCLK_GENCTRL_OOV_Pos) | (CONF_GCLK_GEN_11_IDC << GCLK_GENCTRL_IDC_Pos)
		        | (CONF_GCLK_GENERATOR_11_CONFIG << GCLK_GENCTRL_GENEN_Pos) | CONF_GCLK_GEN_11_SOURCE);
	}
#endif
}
     fa8:	4770      	bx	lr
     faa:	bf00      	nop
     fac:	40001c00 	.word	0x40001c00
     fb0:	00010101 	.word	0x00010101

00000fb4 <stdio_redirect_init>:
	/* Print welcome message */
	printf("\r\nHello ATMEL World!\r\n");
}

void stdio_redirect_init(void)
{
     fb4:	b510      	push	{r4, lr}

	usart_sync_enable(&TARGET_IO);
     fb6:	4c04      	ldr	r4, [pc, #16]	; (fc8 <stdio_redirect_init+0x14>)
     fb8:	4b04      	ldr	r3, [pc, #16]	; (fcc <stdio_redirect_init+0x18>)
     fba:	4620      	mov	r0, r4
     fbc:	4798      	blx	r3
	stdio_io_init(&TARGET_IO.io);
     fbe:	4620      	mov	r0, r4
     fc0:	4b03      	ldr	r3, [pc, #12]	; (fd0 <stdio_redirect_init+0x1c>)
}
     fc2:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	stdio_io_init(&TARGET_IO.io);
     fc6:	4718      	bx	r3
     fc8:	2000a514 	.word	0x2000a514
     fcc:	00000f49 	.word	0x00000f49
     fd0:	000002a5 	.word	0x000002a5

00000fd4 <ethernet_phy_init>:
/**
 * \brief Perform a HW initialization to the PHY
 */
int32_t ethernet_phy_init(struct ethernet_phy_descriptor *const descr, struct mac_async_descriptor *const mac,
                          uint16_t addr)
{
     fd4:	b570      	push	{r4, r5, r6, lr}
     fd6:	460d      	mov	r5, r1
     fd8:	4616      	mov	r6, r2
	ASSERT(descr && mac && (addr <= 0x1F));
     fda:	4604      	mov	r4, r0
     fdc:	b120      	cbz	r0, fe8 <ethernet_phy_init+0x14>
     fde:	b159      	cbz	r1, ff8 <ethernet_phy_init+0x24>
     fe0:	2a1f      	cmp	r2, #31
     fe2:	bf8c      	ite	hi
     fe4:	2000      	movhi	r0, #0
     fe6:	2001      	movls	r0, #1
     fe8:	4904      	ldr	r1, [pc, #16]	; (ffc <ethernet_phy_init+0x28>)
     fea:	4b05      	ldr	r3, [pc, #20]	; (1000 <ethernet_phy_init+0x2c>)
     fec:	222a      	movs	r2, #42	; 0x2a
     fee:	4798      	blx	r3

	descr->mac  = mac;
     ff0:	6025      	str	r5, [r4, #0]
	descr->addr = addr;
     ff2:	80a6      	strh	r6, [r4, #4]
	return ERR_NONE;
}
     ff4:	2000      	movs	r0, #0
     ff6:	bd70      	pop	{r4, r5, r6, pc}
	ASSERT(descr && mac && (addr <= 0x1F));
     ff8:	4608      	mov	r0, r1
     ffa:	e7f5      	b.n	fe8 <ethernet_phy_init+0x14>
     ffc:	0000a758 	.word	0x0000a758
    1000:	00007aa9 	.word	0x00007aa9

00001004 <ethernet_phy_get_link_status>:

/**
 * \brief Get PHY link status
 */
int32_t ethernet_phy_get_link_status(struct ethernet_phy_descriptor *const descr, bool *status)
{
    1004:	b537      	push	{r0, r1, r2, r4, r5, lr}
    1006:	460d      	mov	r5, r1
	int32_t  rst;
	uint16_t val;

	ASSERT(descr && descr->mac && status);
    1008:	4604      	mov	r4, r0
    100a:	b120      	cbz	r0, 1016 <ethernet_phy_get_link_status+0x12>
    100c:	6800      	ldr	r0, [r0, #0]
    100e:	b110      	cbz	r0, 1016 <ethernet_phy_get_link_status+0x12>
    1010:	1e08      	subs	r0, r1, #0
    1012:	bf18      	it	ne
    1014:	2001      	movne	r0, #1
    1016:	4909      	ldr	r1, [pc, #36]	; (103c <ethernet_phy_get_link_status+0x38>)
    1018:	4b09      	ldr	r3, [pc, #36]	; (1040 <ethernet_phy_get_link_status+0x3c>)
    101a:	22a9      	movs	r2, #169	; 0xa9
    101c:	4798      	blx	r3
	rst = mac_async_read_phy_reg(descr->mac, descr->addr, MDIO_REG1_BMSR, &val);
    101e:	88a1      	ldrh	r1, [r4, #4]
    1020:	6820      	ldr	r0, [r4, #0]
    1022:	4c08      	ldr	r4, [pc, #32]	; (1044 <ethernet_phy_get_link_status+0x40>)
    1024:	f10d 0306 	add.w	r3, sp, #6
    1028:	2201      	movs	r2, #1
    102a:	47a0      	blx	r4
	if (rst == ERR_NONE) {
    102c:	b920      	cbnz	r0, 1038 <ethernet_phy_get_link_status+0x34>
		*status = (val & MDIO_REG1_BIT_LINK_STATUS) ? true : false;
    102e:	f8bd 3006 	ldrh.w	r3, [sp, #6]
    1032:	f3c3 0380 	ubfx	r3, r3, #2, #1
    1036:	702b      	strb	r3, [r5, #0]
	}
	return rst;
}
    1038:	b003      	add	sp, #12
    103a:	bd30      	pop	{r4, r5, pc}
    103c:	0000a758 	.word	0x0000a758
    1040:	00007aa9 	.word	0x00007aa9
    1044:	00004ce1 	.word	0x00004ce1

00001048 <sys_timeout>:
#if LWIP_DEBUG_TIMERNAMES
void sys_timeout_debug(u32_t msecs, sys_timeout_handler handler, void *arg, const char *handler_name)
#else  /* LWIP_DEBUG_TIMERNAMES */
void sys_timeout(u32_t msecs, sys_timeout_handler handler, void *arg)
#endif /* LWIP_DEBUG_TIMERNAMES */
{
    1048:	b570      	push	{r4, r5, r6, lr}
	struct sys_timeo *timeout, *t;

	timeout = (struct sys_timeo *)memp_malloc(MEMP_SYS_TIMEOUT);
    104a:	4b14      	ldr	r3, [pc, #80]	; (109c <sys_timeout+0x54>)
{
    104c:	4604      	mov	r4, r0
	timeout = (struct sys_timeo *)memp_malloc(MEMP_SYS_TIMEOUT);
    104e:	200a      	movs	r0, #10
{
    1050:	460e      	mov	r6, r1
    1052:	4615      	mov	r5, r2
	timeout = (struct sys_timeo *)memp_malloc(MEMP_SYS_TIMEOUT);
    1054:	4798      	blx	r3
	if (timeout == NULL) {
    1056:	b140      	cbz	r0, 106a <sys_timeout+0x22>
	LWIP_DEBUGF(
	    TIMERS_DEBUG,
	    ("sys_timeout: %p msecs=%" U32_F " handler=%s arg=%p\n", (void *)timeout, msecs, handler_name, (void *)arg));
#endif /* LWIP_DEBUG_TIMERNAMES */

	if (next_timeout == NULL) {
    1058:	4911      	ldr	r1, [pc, #68]	; (10a0 <sys_timeout+0x58>)
	timeout->time = msecs;
    105a:	6044      	str	r4, [r0, #4]
	timeout->next = NULL;
    105c:	2300      	movs	r3, #0
    105e:	6003      	str	r3, [r0, #0]
	if (next_timeout == NULL) {
    1060:	680b      	ldr	r3, [r1, #0]
	timeout->arg  = arg;
    1062:	e9c0 6502 	strd	r6, r5, [r0, #8]
	if (next_timeout == NULL) {
    1066:	b90b      	cbnz	r3, 106c <sys_timeout+0x24>
	}

	if (next_timeout->time > msecs) {
		next_timeout->time -= msecs;
		timeout->next = next_timeout;
		next_timeout  = timeout;
    1068:	6008      	str	r0, [r1, #0]
				t->next       = timeout;
				break;
			}
		}
	}
}
    106a:	bd70      	pop	{r4, r5, r6, pc}
	if (next_timeout->time > msecs) {
    106c:	685a      	ldr	r2, [r3, #4]
    106e:	42a2      	cmp	r2, r4
    1070:	d903      	bls.n	107a <sys_timeout+0x32>
		next_timeout->time -= msecs;
    1072:	1b12      	subs	r2, r2, r4
    1074:	605a      	str	r2, [r3, #4]
		timeout->next = next_timeout;
    1076:	6003      	str	r3, [r0, #0]
    1078:	e7f6      	b.n	1068 <sys_timeout+0x20>
			timeout->time -= t->time;
    107a:	685a      	ldr	r2, [r3, #4]
    107c:	6841      	ldr	r1, [r0, #4]
    107e:	461e      	mov	r6, r3
			if (t->next == NULL || t->next->time > timeout->time) {
    1080:	681b      	ldr	r3, [r3, #0]
			timeout->time -= t->time;
    1082:	1a8d      	subs	r5, r1, r2
    1084:	6045      	str	r5, [r0, #4]
			if (t->next == NULL || t->next->time > timeout->time) {
    1086:	b12b      	cbz	r3, 1094 <sys_timeout+0x4c>
    1088:	685c      	ldr	r4, [r3, #4]
    108a:	42a5      	cmp	r5, r4
    108c:	d2f5      	bcs.n	107a <sys_timeout+0x32>
					t->next->time -= timeout->time;
    108e:	4422      	add	r2, r4
    1090:	1a52      	subs	r2, r2, r1
    1092:	605a      	str	r2, [r3, #4]
				timeout->next = t->next;
    1094:	6003      	str	r3, [r0, #0]
				t->next       = timeout;
    1096:	6030      	str	r0, [r6, #0]
				break;
    1098:	e7e7      	b.n	106a <sys_timeout+0x22>
    109a:	bf00      	nop
    109c:	00004b2d 	.word	0x00004b2d
    10a0:	200000ac 	.word	0x200000ac

000010a4 <tcp_timer_needed>:
	if (!tcpip_tcp_timer_active && (tcp_active_pcbs || tcp_tw_pcbs)) {
    10a4:	4b08      	ldr	r3, [pc, #32]	; (10c8 <tcp_timer_needed+0x24>)
    10a6:	685a      	ldr	r2, [r3, #4]
    10a8:	b962      	cbnz	r2, 10c4 <tcp_timer_needed+0x20>
    10aa:	4a08      	ldr	r2, [pc, #32]	; (10cc <tcp_timer_needed+0x28>)
    10ac:	6812      	ldr	r2, [r2, #0]
    10ae:	b912      	cbnz	r2, 10b6 <tcp_timer_needed+0x12>
    10b0:	4a07      	ldr	r2, [pc, #28]	; (10d0 <tcp_timer_needed+0x2c>)
    10b2:	6812      	ldr	r2, [r2, #0]
    10b4:	b132      	cbz	r2, 10c4 <tcp_timer_needed+0x20>
		tcpip_tcp_timer_active = 1;
    10b6:	2201      	movs	r2, #1
    10b8:	605a      	str	r2, [r3, #4]
		sys_timeout(TCP_TMR_INTERVAL, tcpip_tcp_timer, NULL);
    10ba:	4906      	ldr	r1, [pc, #24]	; (10d4 <tcp_timer_needed+0x30>)
    10bc:	4b06      	ldr	r3, [pc, #24]	; (10d8 <tcp_timer_needed+0x34>)
    10be:	2200      	movs	r2, #0
    10c0:	20fa      	movs	r0, #250	; 0xfa
    10c2:	4718      	bx	r3
}
    10c4:	4770      	bx	lr
    10c6:	bf00      	nop
    10c8:	200000ac 	.word	0x200000ac
    10cc:	200148fc 	.word	0x200148fc
    10d0:	20014904 	.word	0x20014904
    10d4:	000010dd 	.word	0x000010dd
    10d8:	00001049 	.word	0x00001049

000010dc <tcpip_tcp_timer>:
	tcp_tmr();
    10dc:	4b09      	ldr	r3, [pc, #36]	; (1104 <tcpip_tcp_timer+0x28>)
{
    10de:	b510      	push	{r4, lr}
	tcp_tmr();
    10e0:	4798      	blx	r3
	if (tcp_active_pcbs || tcp_tw_pcbs) {
    10e2:	4b09      	ldr	r3, [pc, #36]	; (1108 <tcpip_tcp_timer+0x2c>)
    10e4:	681b      	ldr	r3, [r3, #0]
    10e6:	b913      	cbnz	r3, 10ee <tcpip_tcp_timer+0x12>
    10e8:	4b08      	ldr	r3, [pc, #32]	; (110c <tcpip_tcp_timer+0x30>)
    10ea:	681b      	ldr	r3, [r3, #0]
    10ec:	b133      	cbz	r3, 10fc <tcpip_tcp_timer+0x20>
}
    10ee:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		sys_timeout(TCP_TMR_INTERVAL, tcpip_tcp_timer, NULL);
    10f2:	4907      	ldr	r1, [pc, #28]	; (1110 <tcpip_tcp_timer+0x34>)
    10f4:	4b07      	ldr	r3, [pc, #28]	; (1114 <tcpip_tcp_timer+0x38>)
    10f6:	2200      	movs	r2, #0
    10f8:	20fa      	movs	r0, #250	; 0xfa
    10fa:	4718      	bx	r3
		tcpip_tcp_timer_active = 0;
    10fc:	4a06      	ldr	r2, [pc, #24]	; (1118 <tcpip_tcp_timer+0x3c>)
    10fe:	6053      	str	r3, [r2, #4]
}
    1100:	bd10      	pop	{r4, pc}
    1102:	bf00      	nop
    1104:	000061b9 	.word	0x000061b9
    1108:	200148fc 	.word	0x200148fc
    110c:	20014904 	.word	0x20014904
    1110:	000010dd 	.word	0x000010dd
    1114:	00001049 	.word	0x00001049
    1118:	200000ac 	.word	0x200000ac

0000111c <sys_timeouts_init>:
{
    111c:	b510      	push	{r4, lr}
	sys_timeout(IP_TMR_INTERVAL, ip_reass_timer, NULL);
    111e:	4c07      	ldr	r4, [pc, #28]	; (113c <sys_timeouts_init+0x20>)
    1120:	4907      	ldr	r1, [pc, #28]	; (1140 <sys_timeouts_init+0x24>)
    1122:	2200      	movs	r2, #0
    1124:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
    1128:	47a0      	blx	r4
	sys_timeout(ARP_TMR_INTERVAL, arp_timer, NULL);
    112a:	4623      	mov	r3, r4
    112c:	4905      	ldr	r1, [pc, #20]	; (1144 <sys_timeouts_init+0x28>)
}
    112e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	sys_timeout(ARP_TMR_INTERVAL, arp_timer, NULL);
    1132:	2200      	movs	r2, #0
    1134:	f241 3088 	movw	r0, #5000	; 0x1388
    1138:	4718      	bx	r3
    113a:	bf00      	nop
    113c:	00001049 	.word	0x00001049
    1140:	0000116d 	.word	0x0000116d
    1144:	00001149 	.word	0x00001149

00001148 <arp_timer>:
{
    1148:	b510      	push	{r4, lr}
	etharp_tmr();
    114a:	4b05      	ldr	r3, [pc, #20]	; (1160 <arp_timer+0x18>)
    114c:	4798      	blx	r3
}
    114e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	sys_timeout(ARP_TMR_INTERVAL, arp_timer, NULL);
    1152:	4904      	ldr	r1, [pc, #16]	; (1164 <arp_timer+0x1c>)
    1154:	4b04      	ldr	r3, [pc, #16]	; (1168 <arp_timer+0x20>)
    1156:	2200      	movs	r2, #0
    1158:	f241 3088 	movw	r0, #5000	; 0x1388
    115c:	4718      	bx	r3
    115e:	bf00      	nop
    1160:	00004e61 	.word	0x00004e61
    1164:	00001149 	.word	0x00001149
    1168:	00001049 	.word	0x00001049

0000116c <ip_reass_timer>:
{
    116c:	b510      	push	{r4, lr}
	ip_reass_tmr();
    116e:	4b05      	ldr	r3, [pc, #20]	; (1184 <ip_reass_timer+0x18>)
    1170:	4798      	blx	r3
}
    1172:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	sys_timeout(IP_TMR_INTERVAL, ip_reass_timer, NULL);
    1176:	4904      	ldr	r1, [pc, #16]	; (1188 <ip_reass_timer+0x1c>)
    1178:	4b04      	ldr	r3, [pc, #16]	; (118c <ip_reass_timer+0x20>)
    117a:	2200      	movs	r2, #0
    117c:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
    1180:	4718      	bx	r3
    1182:	bf00      	nop
    1184:	00002ab9 	.word	0x00002ab9
    1188:	0000116d 	.word	0x0000116d
    118c:	00001049 	.word	0x00001049

00001190 <sys_untimeout>:
 *
 * @param handler callback function that would be called by the timeout
 * @param arg callback argument that would be passed to handler
 */
void sys_untimeout(sys_timeout_handler handler, void *arg)
{
    1190:	b470      	push	{r4, r5, r6}
	struct sys_timeo *prev_t, *t;

	if (next_timeout == NULL) {
    1192:	4d10      	ldr	r5, [pc, #64]	; (11d4 <sys_untimeout+0x44>)
{
    1194:	460c      	mov	r4, r1
	if (next_timeout == NULL) {
    1196:	6829      	ldr	r1, [r5, #0]
    1198:	b1d1      	cbz	r1, 11d0 <sys_untimeout+0x40>
		return;
	}

	for (t = next_timeout, prev_t = NULL; t != NULL; prev_t = t, t = t->next) {
    119a:	2200      	movs	r2, #0
		if ((t->h == handler) && (t->arg == arg)) {
    119c:	688b      	ldr	r3, [r1, #8]
    119e:	4283      	cmp	r3, r0
    11a0:	680b      	ldr	r3, [r1, #0]
    11a2:	d112      	bne.n	11ca <sys_untimeout+0x3a>
    11a4:	68ce      	ldr	r6, [r1, #12]
    11a6:	42a6      	cmp	r6, r4
    11a8:	d10f      	bne.n	11ca <sys_untimeout+0x3a>
			/* We have a match */
			/* Unlink from previous in list */
			if (prev_t == NULL) {
    11aa:	b962      	cbnz	r2, 11c6 <sys_untimeout+0x36>
				next_timeout = t->next;
    11ac:	602b      	str	r3, [r5, #0]
			} else {
				prev_t->next = t->next;
			}
			/* If not the last one, add time of this one back to next */
			if (t->next != NULL) {
    11ae:	680b      	ldr	r3, [r1, #0]
    11b0:	b11b      	cbz	r3, 11ba <sys_untimeout+0x2a>
				t->next->time += t->time;
    11b2:	685a      	ldr	r2, [r3, #4]
    11b4:	6848      	ldr	r0, [r1, #4]
    11b6:	4402      	add	r2, r0
    11b8:	605a      	str	r2, [r3, #4]
			memp_free(MEMP_SYS_TIMEOUT, t);
			return;
		}
	}
	return;
}
    11ba:	bc70      	pop	{r4, r5, r6}
			memp_free(MEMP_SYS_TIMEOUT, t);
    11bc:	4b06      	ldr	r3, [pc, #24]	; (11d8 <sys_untimeout+0x48>)
    11be:	200a      	movs	r0, #10
    11c0:	4718      	bx	r3
    11c2:	4619      	mov	r1, r3
    11c4:	e7ea      	b.n	119c <sys_untimeout+0xc>
				prev_t->next = t->next;
    11c6:	6013      	str	r3, [r2, #0]
    11c8:	e7f1      	b.n	11ae <sys_untimeout+0x1e>
	for (t = next_timeout, prev_t = NULL; t != NULL; prev_t = t, t = t->next) {
    11ca:	460a      	mov	r2, r1
    11cc:	2b00      	cmp	r3, #0
    11ce:	d1f8      	bne.n	11c2 <sys_untimeout+0x32>
}
    11d0:	bc70      	pop	{r4, r5, r6}
    11d2:	4770      	bx	lr
    11d4:	200000ac 	.word	0x200000ac
    11d8:	00004b49 	.word	0x00004b49

000011dc <sys_timeouts_mbox_fetch>:
 *
 * @param mbox the mbox to fetch the message from
 * @param msg the place to store the message
 */
void sys_timeouts_mbox_fetch(sys_mbox_t *mbox, void **msg)
{
    11dc:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	struct sys_timeo *  tmptimeout;
	sys_timeout_handler handler;
	void *              arg;

again:
	if (!next_timeout) {
    11e0:	4c15      	ldr	r4, [pc, #84]	; (1238 <sys_timeouts_mbox_fetch+0x5c>)
		time_needed = sys_arch_mbox_fetch(mbox, msg, 0);
	} else {
		if (next_timeout->time > 0) {
			time_needed = sys_arch_mbox_fetch(mbox, msg, next_timeout->time);
    11e2:	4f16      	ldr	r7, [pc, #88]	; (123c <sys_timeouts_mbox_fetch+0x60>)
{
    11e4:	4605      	mov	r5, r0
    11e6:	460e      	mov	r6, r1
	if (!next_timeout) {
    11e8:	6822      	ldr	r2, [r4, #0]
    11ea:	b92a      	cbnz	r2, 11f8 <sys_timeouts_mbox_fetch+0x1c>
		time_needed = sys_arch_mbox_fetch(mbox, msg, 0);
    11ec:	4631      	mov	r1, r6
    11ee:	4628      	mov	r0, r5
    11f0:	4b12      	ldr	r3, [pc, #72]	; (123c <sys_timeouts_mbox_fetch+0x60>)
			} else {
				next_timeout->time = 0;
			}
		}
	}
}
    11f2:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
		time_needed = sys_arch_mbox_fetch(mbox, msg, 0);
    11f6:	4718      	bx	r3
		if (next_timeout->time > 0) {
    11f8:	6852      	ldr	r2, [r2, #4]
    11fa:	b96a      	cbnz	r2, 1218 <sys_timeouts_mbox_fetch+0x3c>
			tmptimeout   = next_timeout;
    11fc:	6821      	ldr	r1, [r4, #0]
			arg          = tmptimeout->arg;
    11fe:	e9d1 8902 	ldrd	r8, r9, [r1, #8]
			next_timeout = tmptimeout->next;
    1202:	680b      	ldr	r3, [r1, #0]
    1204:	6023      	str	r3, [r4, #0]
			memp_free(MEMP_SYS_TIMEOUT, tmptimeout);
    1206:	200a      	movs	r0, #10
    1208:	4b0d      	ldr	r3, [pc, #52]	; (1240 <sys_timeouts_mbox_fetch+0x64>)
    120a:	4798      	blx	r3
			if (handler != NULL) {
    120c:	f1b8 0f00 	cmp.w	r8, #0
    1210:	d0ea      	beq.n	11e8 <sys_timeouts_mbox_fetch+0xc>
				handler(arg);
    1212:	4648      	mov	r0, r9
    1214:	47c0      	blx	r8
    1216:	e7e7      	b.n	11e8 <sys_timeouts_mbox_fetch+0xc>
			time_needed = sys_arch_mbox_fetch(mbox, msg, next_timeout->time);
    1218:	4631      	mov	r1, r6
    121a:	4628      	mov	r0, r5
    121c:	47b8      	blx	r7
		if (time_needed == SYS_ARCH_TIMEOUT) {
    121e:	1c42      	adds	r2, r0, #1
			time_needed = sys_arch_mbox_fetch(mbox, msg, next_timeout->time);
    1220:	4603      	mov	r3, r0
		if (time_needed == SYS_ARCH_TIMEOUT) {
    1222:	d0eb      	beq.n	11fc <sys_timeouts_mbox_fetch+0x20>
			if (time_needed < next_timeout->time) {
    1224:	6822      	ldr	r2, [r4, #0]
    1226:	6850      	ldr	r0, [r2, #4]
    1228:	4298      	cmp	r0, r3
				next_timeout->time -= time_needed;
    122a:	bf8b      	itete	hi
    122c:	1ac0      	subhi	r0, r0, r3
				next_timeout->time = 0;
    122e:	2300      	movls	r3, #0
				next_timeout->time -= time_needed;
    1230:	6050      	strhi	r0, [r2, #4]
				next_timeout->time = 0;
    1232:	6053      	strls	r3, [r2, #4]
}
    1234:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    1238:	200000ac 	.word	0x200000ac
    123c:	00006be5 	.word	0x00006be5
    1240:	00004b49 	.word	0x00004b49

00001244 <err_tcp>:
 * The application thread has then to decide what to do.
 *
 * @see tcp.h (struct tcp_pcb.err) for parameters
 */
static void err_tcp(void *arg, err_t err)
{
    1244:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	old_state   = conn->state;
	conn->state = NETCONN_NONE;

	/* Notify the user layer about a connection error. Used to signal
	   select. */
	API_EVENT(conn, NETCONN_EVT_ERROR, 0);
    1248:	6a83      	ldr	r3, [r0, #40]	; 0x28
	old_state   = conn->state;
    124a:	7846      	ldrb	r6, [r0, #1]
	conn->last_err = err;
    124c:	7201      	strb	r1, [r0, #8]
	conn->pcb.tcp = NULL;
    124e:	2200      	movs	r2, #0
{
    1250:	4604      	mov	r4, r0
    1252:	460d      	mov	r5, r1
	conn->pcb.tcp = NULL;
    1254:	6042      	str	r2, [r0, #4]
	conn->state = NETCONN_NONE;
    1256:	7042      	strb	r2, [r0, #1]
	API_EVENT(conn, NETCONN_EVT_ERROR, 0);
    1258:	b10b      	cbz	r3, 125e <err_tcp+0x1a>
    125a:	2104      	movs	r1, #4
    125c:	4798      	blx	r3
	/* Try to release selects pending on 'read' or 'write', too.
	   They will get an error if they actually try to read or write. */
	API_EVENT(conn, NETCONN_EVT_RCVPLUS, 0);
    125e:	6aa3      	ldr	r3, [r4, #40]	; 0x28
    1260:	b11b      	cbz	r3, 126a <err_tcp+0x26>
    1262:	2200      	movs	r2, #0
    1264:	4611      	mov	r1, r2
    1266:	4620      	mov	r0, r4
    1268:	4798      	blx	r3
	API_EVENT(conn, NETCONN_EVT_SENDPLUS, 0);
    126a:	6aa3      	ldr	r3, [r4, #40]	; 0x28
    126c:	b11b      	cbz	r3, 1276 <err_tcp+0x32>
    126e:	2200      	movs	r2, #0
    1270:	2102      	movs	r1, #2
    1272:	4620      	mov	r0, r4
    1274:	4798      	blx	r3

	/* pass NULL-message to recvmbox to wake up pending recv */
	if (sys_mbox_valid(&conn->recvmbox)) {
    1276:	f104 0810 	add.w	r8, r4, #16
    127a:	4f14      	ldr	r7, [pc, #80]	; (12cc <err_tcp+0x88>)
    127c:	4640      	mov	r0, r8
    127e:	47b8      	blx	r7
    1280:	b118      	cbz	r0, 128a <err_tcp+0x46>
		/* use trypost to prevent deadlock */
		sys_mbox_trypost(&conn->recvmbox, NULL);
    1282:	4b13      	ldr	r3, [pc, #76]	; (12d0 <err_tcp+0x8c>)
    1284:	2100      	movs	r1, #0
    1286:	4640      	mov	r0, r8
    1288:	4798      	blx	r3
	}
	/* pass NULL-message to acceptmbox to wake up pending accept */
	if (sys_mbox_valid(&conn->acceptmbox)) {
    128a:	f104 0814 	add.w	r8, r4, #20
    128e:	4640      	mov	r0, r8
    1290:	47b8      	blx	r7
    1292:	b118      	cbz	r0, 129c <err_tcp+0x58>
		/* use trypost to preven deadlock */
		sys_mbox_trypost(&conn->acceptmbox, NULL);
    1294:	4b0e      	ldr	r3, [pc, #56]	; (12d0 <err_tcp+0x8c>)
    1296:	2100      	movs	r1, #0
    1298:	4640      	mov	r0, r8
    129a:	4798      	blx	r3
	}

	if ((old_state == NETCONN_WRITE) || (old_state == NETCONN_CLOSE) || (old_state == NETCONN_CONNECT)) {
    129c:	2e01      	cmp	r6, #1
    129e:	d002      	beq.n	12a6 <err_tcp+0x62>
    12a0:	3e03      	subs	r6, #3
    12a2:	2e01      	cmp	r6, #1
    12a4:	d80f      	bhi.n	12c6 <err_tcp+0x82>
		/* calling do_writemore/do_close_internal is not necessary
		   since the pcb has already been deleted! */
		int was_nonblocking_connect = IN_NONBLOCKING_CONNECT(conn);
    12a6:	7f23      	ldrb	r3, [r4, #28]
		SET_NONBLOCKING_CONNECT(conn, 0);
    12a8:	f023 0204 	bic.w	r2, r3, #4

		if (!was_nonblocking_connect) {
    12ac:	f013 0304 	ands.w	r3, r3, #4
		SET_NONBLOCKING_CONNECT(conn, 0);
    12b0:	7722      	strb	r2, [r4, #28]
		if (!was_nonblocking_connect) {
    12b2:	d108      	bne.n	12c6 <err_tcp+0x82>
			/* set error return code */
			LWIP_ASSERT("conn->current_msg != NULL", conn->current_msg != NULL);
			conn->current_msg->err = err;
    12b4:	6a62      	ldr	r2, [r4, #36]	; 0x24
    12b6:	7115      	strb	r5, [r2, #4]
			conn->current_msg      = NULL;
			/* wake up the waiting task */
			sys_sem_signal(&conn->op_completed);
    12b8:	f104 000c 	add.w	r0, r4, #12
			conn->current_msg      = NULL;
    12bc:	6263      	str	r3, [r4, #36]	; 0x24
		}
	} else {
		LWIP_ASSERT("conn->current_msg == NULL", conn->current_msg == NULL);
	}
}
    12be:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
			sys_sem_signal(&conn->op_completed);
    12c2:	4b04      	ldr	r3, [pc, #16]	; (12d4 <err_tcp+0x90>)
    12c4:	4718      	bx	r3
}
    12c6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    12ca:	bf00      	nop
    12cc:	00006c71 	.word	0x00006c71
    12d0:	00006b7d 	.word	0x00006b7d
    12d4:	00006aad 	.word	0x00006aad

000012d8 <recv_udp>:
{
    12d8:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
    12dc:	4617      	mov	r7, r2
    12de:	f8bd 9028 	ldrh.w	r9, [sp, #40]	; 0x28
    12e2:	461d      	mov	r5, r3
	if ((conn == NULL) || !sys_mbox_valid(&conn->recvmbox)) {
    12e4:	4606      	mov	r6, r0
    12e6:	b128      	cbz	r0, 12f4 <recv_udp+0x1c>
    12e8:	f100 0810 	add.w	r8, r0, #16
    12ec:	4b17      	ldr	r3, [pc, #92]	; (134c <recv_udp+0x74>)
    12ee:	4640      	mov	r0, r8
    12f0:	4798      	blx	r3
    12f2:	b928      	cbnz	r0, 1300 <recv_udp+0x28>
		pbuf_free(p);
    12f4:	4b16      	ldr	r3, [pc, #88]	; (1350 <recv_udp+0x78>)
    12f6:	4638      	mov	r0, r7
}
    12f8:	b003      	add	sp, #12
    12fa:	e8bd 43f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, lr}
		pbuf_free(p);
    12fe:	4718      	bx	r3
	buf = (struct netbuf *)memp_malloc(MEMP_NETBUF);
    1300:	4b14      	ldr	r3, [pc, #80]	; (1354 <recv_udp+0x7c>)
    1302:	2006      	movs	r0, #6
    1304:	4798      	blx	r3
	if (buf == NULL) {
    1306:	4604      	mov	r4, r0
    1308:	2800      	cmp	r0, #0
    130a:	d0f3      	beq.n	12f4 <recv_udp+0x1c>
		buf->ptr = p;
    130c:	e9c0 7700 	strd	r7, r7, [r0]
		ip_addr_set(&buf->addr, addr);
    1310:	b105      	cbz	r5, 1314 <recv_udp+0x3c>
    1312:	682d      	ldr	r5, [r5, #0]
	len = p->tot_len;
    1314:	893a      	ldrh	r2, [r7, #8]
	if (sys_mbox_trypost(&conn->recvmbox, buf) != ERR_OK) {
    1316:	4b10      	ldr	r3, [pc, #64]	; (1358 <recv_udp+0x80>)
		ip_addr_set(&buf->addr, addr);
    1318:	60a5      	str	r5, [r4, #8]
	if (sys_mbox_trypost(&conn->recvmbox, buf) != ERR_OK) {
    131a:	4621      	mov	r1, r4
		buf->port = port;
    131c:	f8a4 900c 	strh.w	r9, [r4, #12]
	if (sys_mbox_trypost(&conn->recvmbox, buf) != ERR_OK) {
    1320:	4640      	mov	r0, r8
	len = p->tot_len;
    1322:	9201      	str	r2, [sp, #4]
	if (sys_mbox_trypost(&conn->recvmbox, buf) != ERR_OK) {
    1324:	4798      	blx	r3
    1326:	9a01      	ldr	r2, [sp, #4]
    1328:	4601      	mov	r1, r0
    132a:	b128      	cbz	r0, 1338 <recv_udp+0x60>
		netbuf_delete(buf);
    132c:	4b0b      	ldr	r3, [pc, #44]	; (135c <recv_udp+0x84>)
    132e:	4620      	mov	r0, r4
}
    1330:	b003      	add	sp, #12
    1332:	e8bd 43f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, lr}
		netbuf_delete(buf);
    1336:	4718      	bx	r3
		API_EVENT(conn, NETCONN_EVT_RCVPLUS, len);
    1338:	6ab3      	ldr	r3, [r6, #40]	; 0x28
    133a:	b123      	cbz	r3, 1346 <recv_udp+0x6e>
    133c:	4630      	mov	r0, r6
}
    133e:	b003      	add	sp, #12
    1340:	e8bd 43f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, lr}
		API_EVENT(conn, NETCONN_EVT_RCVPLUS, len);
    1344:	4718      	bx	r3
}
    1346:	b003      	add	sp, #12
    1348:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    134c:	00006c71 	.word	0x00006c71
    1350:	00003081 	.word	0x00003081
    1354:	00004b2d 	.word	0x00004b2d
    1358:	00006b7d 	.word	0x00006b7d
    135c:	00000d7d 	.word	0x00000d7d

00001360 <setup_tcp>:
 * and their arguments.
 *
 * @param conn the TCP netconn to setup
 */
static void setup_tcp(struct netconn *conn)
{
    1360:	b507      	push	{r0, r1, r2, lr}
	struct tcp_pcb *pcb;

	pcb = conn->pcb.tcp;
	tcp_arg(pcb, conn);
    1362:	4b0c      	ldr	r3, [pc, #48]	; (1394 <setup_tcp+0x34>)
{
    1364:	4601      	mov	r1, r0
	pcb = conn->pcb.tcp;
    1366:	6840      	ldr	r0, [r0, #4]
	tcp_arg(pcb, conn);
    1368:	9001      	str	r0, [sp, #4]
    136a:	4798      	blx	r3
	tcp_recv(pcb, recv_tcp);
    136c:	9801      	ldr	r0, [sp, #4]
    136e:	490a      	ldr	r1, [pc, #40]	; (1398 <setup_tcp+0x38>)
    1370:	4b0a      	ldr	r3, [pc, #40]	; (139c <setup_tcp+0x3c>)
    1372:	4798      	blx	r3
	tcp_sent(pcb, sent_tcp);
    1374:	9801      	ldr	r0, [sp, #4]
    1376:	490a      	ldr	r1, [pc, #40]	; (13a0 <setup_tcp+0x40>)
    1378:	4b0a      	ldr	r3, [pc, #40]	; (13a4 <setup_tcp+0x44>)
    137a:	4798      	blx	r3
	tcp_poll(pcb, poll_tcp, 4);
    137c:	9801      	ldr	r0, [sp, #4]
    137e:	490a      	ldr	r1, [pc, #40]	; (13a8 <setup_tcp+0x48>)
    1380:	4b0a      	ldr	r3, [pc, #40]	; (13ac <setup_tcp+0x4c>)
    1382:	2204      	movs	r2, #4
    1384:	4798      	blx	r3
	tcp_err(pcb, err_tcp);
    1386:	490a      	ldr	r1, [pc, #40]	; (13b0 <setup_tcp+0x50>)
    1388:	9801      	ldr	r0, [sp, #4]
    138a:	4b0a      	ldr	r3, [pc, #40]	; (13b4 <setup_tcp+0x54>)
}
    138c:	b003      	add	sp, #12
    138e:	f85d eb04 	ldr.w	lr, [sp], #4
	tcp_err(pcb, err_tcp);
    1392:	4718      	bx	r3
    1394:	00005ba5 	.word	0x00005ba5
    1398:	000014c9 	.word	0x000014c9
    139c:	00005ba9 	.word	0x00005ba9
    13a0:	00001649 	.word	0x00001649
    13a4:	00005baf 	.word	0x00005baf
    13a8:	00001699 	.word	0x00001699
    13ac:	00005bbd 	.word	0x00005bbd
    13b0:	00001245 	.word	0x00001245
    13b4:	00005bb3 	.word	0x00005bb3

000013b8 <do_close_internal>:
	LWIP_ASSERT("this is for tcp netconns only", (conn->type == NETCONN_TCP));
	LWIP_ASSERT("conn must be in state NETCONN_CLOSE", (conn->state == NETCONN_CLOSE));
	LWIP_ASSERT("pcb already closed", (conn->pcb.tcp != NULL));
	LWIP_ASSERT("conn->current_msg != NULL", conn->current_msg != NULL);

	shut    = conn->current_msg->msg.sd.shut;
    13b8:	6a43      	ldr	r3, [r0, #36]	; 0x24
{
    13ba:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	shut    = conn->current_msg->msg.sd.shut;
    13be:	7a1d      	ldrb	r5, [r3, #8]
	shut_tx = shut & NETCONN_SHUT_WR;
	/* shutting down both ends is the same as closing */
	close = shut == NETCONN_SHUT_RDWR;

	/* Set back some callback pointers */
	if (close) {
    13c0:	2d03      	cmp	r5, #3
{
    13c2:	4604      	mov	r4, r0
	shut_rx = shut & NETCONN_SHUT_RD;
    13c4:	f005 0701 	and.w	r7, r5, #1
	shut_tx = shut & NETCONN_SHUT_WR;
    13c8:	f005 0602 	and.w	r6, r5, #2
	if (close) {
    13cc:	d103      	bne.n	13d6 <do_close_internal+0x1e>
		tcp_arg(conn->pcb.tcp, NULL);
    13ce:	6840      	ldr	r0, [r0, #4]
    13d0:	4b31      	ldr	r3, [pc, #196]	; (1498 <do_close_internal+0xe0>)
    13d2:	2100      	movs	r1, #0
    13d4:	4798      	blx	r3
	}
	if (conn->pcb.tcp->state == LISTEN) {
    13d6:	6860      	ldr	r0, [r4, #4]
    13d8:	7e03      	ldrb	r3, [r0, #24]
    13da:	2b01      	cmp	r3, #1
    13dc:	d10a      	bne.n	13f4 <do_close_internal+0x3c>
		tcp_accept(conn->pcb.tcp, NULL);
    13de:	4b2f      	ldr	r3, [pc, #188]	; (149c <do_close_internal+0xe4>)
    13e0:	2100      	movs	r1, #0
    13e2:	4798      	blx	r3
			tcp_poll(conn->pcb.tcp, NULL, 4);
			tcp_err(conn->pcb.tcp, NULL);
		}
	}
	/* Try to close the connection */
	if (close) {
    13e4:	2d03      	cmp	r5, #3
    13e6:	d01d      	beq.n	1424 <do_close_internal+0x6c>
		err = tcp_close(conn->pcb.tcp);
	} else {
		err = tcp_shutdown(conn->pcb.tcp, shut_rx, shut_tx);
    13e8:	6860      	ldr	r0, [r4, #4]
    13ea:	4b2d      	ldr	r3, [pc, #180]	; (14a0 <do_close_internal+0xe8>)
    13ec:	4632      	mov	r2, r6
    13ee:	4639      	mov	r1, r7
    13f0:	4798      	blx	r3
    13f2:	e01a      	b.n	142a <do_close_internal+0x72>
		if (shut_rx) {
    13f4:	b137      	cbz	r7, 1404 <do_close_internal+0x4c>
			tcp_recv(conn->pcb.tcp, NULL);
    13f6:	4b2b      	ldr	r3, [pc, #172]	; (14a4 <do_close_internal+0xec>)
    13f8:	2100      	movs	r1, #0
    13fa:	4798      	blx	r3
			tcp_accept(conn->pcb.tcp, NULL);
    13fc:	6860      	ldr	r0, [r4, #4]
    13fe:	4b27      	ldr	r3, [pc, #156]	; (149c <do_close_internal+0xe4>)
    1400:	2100      	movs	r1, #0
    1402:	4798      	blx	r3
		if (shut_tx) {
    1404:	b11e      	cbz	r6, 140e <do_close_internal+0x56>
			tcp_sent(conn->pcb.tcp, NULL);
    1406:	6860      	ldr	r0, [r4, #4]
    1408:	4b27      	ldr	r3, [pc, #156]	; (14a8 <do_close_internal+0xf0>)
    140a:	2100      	movs	r1, #0
    140c:	4798      	blx	r3
		if (close) {
    140e:	2d03      	cmp	r5, #3
    1410:	d1ea      	bne.n	13e8 <do_close_internal+0x30>
			tcp_poll(conn->pcb.tcp, NULL, 4);
    1412:	6860      	ldr	r0, [r4, #4]
    1414:	4b25      	ldr	r3, [pc, #148]	; (14ac <do_close_internal+0xf4>)
    1416:	2100      	movs	r1, #0
    1418:	2204      	movs	r2, #4
    141a:	4798      	blx	r3
			tcp_err(conn->pcb.tcp, NULL);
    141c:	6860      	ldr	r0, [r4, #4]
    141e:	4b24      	ldr	r3, [pc, #144]	; (14b0 <do_close_internal+0xf8>)
    1420:	2100      	movs	r1, #0
    1422:	4798      	blx	r3
		err = tcp_close(conn->pcb.tcp);
    1424:	6860      	ldr	r0, [r4, #4]
    1426:	4b23      	ldr	r3, [pc, #140]	; (14b4 <do_close_internal+0xfc>)
    1428:	4798      	blx	r3
	}
	if (err == ERR_OK) {
    142a:	bb10      	cbnz	r0, 1472 <do_close_internal+0xba>
		/* Closing succeeded */
		conn->current_msg->err = ERR_OK;
    142c:	6a63      	ldr	r3, [r4, #36]	; 0x24
		conn->current_msg      = NULL;
		conn->state            = NETCONN_NONE;
		if (close) {
    142e:	2d03      	cmp	r5, #3
		conn->current_msg->err = ERR_OK;
    1430:	7118      	strb	r0, [r3, #4]
		conn->current_msg      = NULL;
    1432:	6260      	str	r0, [r4, #36]	; 0x24
		conn->state            = NETCONN_NONE;
    1434:	7060      	strb	r0, [r4, #1]
		if (close) {
    1436:	d10d      	bne.n	1454 <do_close_internal+0x9c>
			/* Set back some callback pointers as conn is going away */
			conn->pcb.tcp = NULL;
			/* Trigger select() in socket layer. Make sure everybody notices activity
			 on the connection, error first! */
			API_EVENT(conn, NETCONN_EVT_ERROR, 0);
    1438:	6aa3      	ldr	r3, [r4, #40]	; 0x28
			conn->pcb.tcp = NULL;
    143a:	6060      	str	r0, [r4, #4]
			API_EVENT(conn, NETCONN_EVT_ERROR, 0);
    143c:	b11b      	cbz	r3, 1446 <do_close_internal+0x8e>
    143e:	4602      	mov	r2, r0
    1440:	2104      	movs	r1, #4
    1442:	4620      	mov	r0, r4
    1444:	4798      	blx	r3
		}
		if (shut_rx) {
			API_EVENT(conn, NETCONN_EVT_RCVPLUS, 0);
    1446:	6aa3      	ldr	r3, [r4, #40]	; 0x28
    1448:	b133      	cbz	r3, 1458 <do_close_internal+0xa0>
    144a:	2200      	movs	r2, #0
    144c:	4611      	mov	r1, r2
    144e:	4620      	mov	r0, r4
    1450:	4798      	blx	r3
    1452:	e001      	b.n	1458 <do_close_internal+0xa0>
		if (shut_rx) {
    1454:	2f00      	cmp	r7, #0
    1456:	d1f6      	bne.n	1446 <do_close_internal+0x8e>
		}
		if (shut_tx) {
    1458:	b12e      	cbz	r6, 1466 <do_close_internal+0xae>
			API_EVENT(conn, NETCONN_EVT_SENDPLUS, 0);
    145a:	6aa3      	ldr	r3, [r4, #40]	; 0x28
    145c:	b11b      	cbz	r3, 1466 <do_close_internal+0xae>
    145e:	2200      	movs	r2, #0
    1460:	2102      	movs	r1, #2
    1462:	4620      	mov	r0, r4
    1464:	4798      	blx	r3
		}
		/* wake up the application task */
		sys_sem_signal(&conn->op_completed);
    1466:	f104 000c 	add.w	r0, r4, #12
    146a:	4b13      	ldr	r3, [pc, #76]	; (14b8 <do_close_internal+0x100>)
		tcp_arg(conn->pcb.tcp, conn);
		/* don't restore recv callback: we don't want to receive any more data */
	}
	/* If closing didn't succeed, we get called again either
	   from poll_tcp or from sent_tcp */
}
    146c:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
		sys_sem_signal(&conn->op_completed);
    1470:	4718      	bx	r3
		tcp_sent(conn->pcb.tcp, sent_tcp);
    1472:	6860      	ldr	r0, [r4, #4]
    1474:	4911      	ldr	r1, [pc, #68]	; (14bc <do_close_internal+0x104>)
    1476:	4b0c      	ldr	r3, [pc, #48]	; (14a8 <do_close_internal+0xf0>)
    1478:	4798      	blx	r3
		tcp_poll(conn->pcb.tcp, poll_tcp, 4);
    147a:	6860      	ldr	r0, [r4, #4]
    147c:	4910      	ldr	r1, [pc, #64]	; (14c0 <do_close_internal+0x108>)
    147e:	4b0b      	ldr	r3, [pc, #44]	; (14ac <do_close_internal+0xf4>)
    1480:	2204      	movs	r2, #4
    1482:	4798      	blx	r3
		tcp_err(conn->pcb.tcp, err_tcp);
    1484:	6860      	ldr	r0, [r4, #4]
    1486:	490f      	ldr	r1, [pc, #60]	; (14c4 <do_close_internal+0x10c>)
    1488:	4b09      	ldr	r3, [pc, #36]	; (14b0 <do_close_internal+0xf8>)
    148a:	4798      	blx	r3
		tcp_arg(conn->pcb.tcp, conn);
    148c:	6860      	ldr	r0, [r4, #4]
    148e:	4b02      	ldr	r3, [pc, #8]	; (1498 <do_close_internal+0xe0>)
    1490:	4621      	mov	r1, r4
}
    1492:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
		tcp_arg(conn->pcb.tcp, conn);
    1496:	4718      	bx	r3
    1498:	00005ba5 	.word	0x00005ba5
    149c:	00005bb9 	.word	0x00005bb9
    14a0:	000061e9 	.word	0x000061e9
    14a4:	00005ba9 	.word	0x00005ba9
    14a8:	00005baf 	.word	0x00005baf
    14ac:	00005bbd 	.word	0x00005bbd
    14b0:	00005bb3 	.word	0x00005bb3
    14b4:	000060a1 	.word	0x000060a1
    14b8:	00006aad 	.word	0x00006aad
    14bc:	00001649 	.word	0x00001649
    14c0:	00001699 	.word	0x00001699
    14c4:	00001245 	.word	0x00001245

000014c8 <recv_tcp>:
{
    14c8:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    14cc:	4688      	mov	r8, r1
    14ce:	4615      	mov	r5, r2
    14d0:	461f      	mov	r7, r3
	if (conn == NULL) {
    14d2:	4606      	mov	r6, r0
    14d4:	b350      	cbz	r0, 152c <recv_tcp+0x64>
	if (!sys_mbox_valid(&conn->recvmbox)) {
    14d6:	f100 0910 	add.w	r9, r0, #16
    14da:	4b17      	ldr	r3, [pc, #92]	; (1538 <recv_tcp+0x70>)
    14dc:	4648      	mov	r0, r9
    14de:	4798      	blx	r3
    14e0:	4604      	mov	r4, r0
    14e2:	b960      	cbnz	r0, 14fe <recv_tcp+0x36>
		if (p != NULL) {
    14e4:	b91d      	cbnz	r5, 14ee <recv_tcp+0x26>
		return ERR_OK;
    14e6:	2400      	movs	r4, #0
}
    14e8:	4620      	mov	r0, r4
    14ea:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
			tcp_recved(pcb, p->tot_len);
    14ee:	4640      	mov	r0, r8
    14f0:	8929      	ldrh	r1, [r5, #8]
    14f2:	4b12      	ldr	r3, [pc, #72]	; (153c <recv_tcp+0x74>)
    14f4:	4798      	blx	r3
			pbuf_free(p);
    14f6:	4b12      	ldr	r3, [pc, #72]	; (1540 <recv_tcp+0x78>)
    14f8:	4628      	mov	r0, r5
    14fa:	4798      	blx	r3
    14fc:	e7f4      	b.n	14e8 <recv_tcp+0x20>
	NETCONN_SET_SAFE_ERR(conn, err);
    14fe:	f996 3008 	ldrsb.w	r3, [r6, #8]
    1502:	3309      	adds	r3, #9
    1504:	bfa8      	it	ge
    1506:	7237      	strbge	r7, [r6, #8]
	if (p != NULL) {
    1508:	b175      	cbz	r5, 1528 <recv_tcp+0x60>
		len = p->tot_len;
    150a:	892f      	ldrh	r7, [r5, #8]
	if (sys_mbox_trypost(&conn->recvmbox, p) != ERR_OK) {
    150c:	4b0d      	ldr	r3, [pc, #52]	; (1544 <recv_tcp+0x7c>)
    150e:	4629      	mov	r1, r5
    1510:	4648      	mov	r0, r9
    1512:	4798      	blx	r3
    1514:	4604      	mov	r4, r0
    1516:	b960      	cbnz	r0, 1532 <recv_tcp+0x6a>
		API_EVENT(conn, NETCONN_EVT_RCVPLUS, len);
    1518:	6ab3      	ldr	r3, [r6, #40]	; 0x28
    151a:	2b00      	cmp	r3, #0
    151c:	d0e3      	beq.n	14e6 <recv_tcp+0x1e>
    151e:	4601      	mov	r1, r0
    1520:	463a      	mov	r2, r7
    1522:	4630      	mov	r0, r6
    1524:	4798      	blx	r3
    1526:	e7df      	b.n	14e8 <recv_tcp+0x20>
		len = 0;
    1528:	462f      	mov	r7, r5
    152a:	e7ef      	b.n	150c <recv_tcp+0x44>
		return ERR_VAL;
    152c:	f06f 0405 	mvn.w	r4, #5
    1530:	e7da      	b.n	14e8 <recv_tcp+0x20>
		return ERR_MEM;
    1532:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
    1536:	e7d7      	b.n	14e8 <recv_tcp+0x20>
    1538:	00006c71 	.word	0x00006c71
    153c:	00005af9 	.word	0x00005af9
    1540:	00003081 	.word	0x00003081
    1544:	00006b7d 	.word	0x00006b7d

00001548 <do_writemore.isra.0>:
 *
 * @param conn netconn (that is currently in state NETCONN_WRITE) to process
 * @return ERR_OK
 *         ERR_MEM if LWIP_TCPIP_CORE_LOCKING=1 and sending hasn't yet finished
 */
static err_t do_writemore(struct netconn *conn)
    1548:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    154c:	4604      	mov	r4, r0
	err_t  err;
	void * dataptr;
	u16_t  len, available;
	u8_t   write_finished = 0;
	size_t diff;
	u8_t   dontblock = netconn_is_nonblocking(conn) || (conn->current_msg->msg.w.apiflags & NETCONN_DONTBLOCK);
    154e:	6a40      	ldr	r0, [r0, #36]	; 0x24
    1550:	7f26      	ldrb	r6, [r4, #28]
    1552:	7c03      	ldrb	r3, [r0, #16]
			conn->current_msg->msg.w.len = conn->write_offset;
		}
	} else
#endif /* LWIP_SO_SNDTIMEO */
	{
		dataptr = (u8_t *)conn->current_msg->msg.w.dataptr + conn->write_offset;
    1554:	6a25      	ldr	r5, [r4, #32]
    1556:	6881      	ldr	r1, [r0, #8]
    1558:	f003 0204 	and.w	r2, r3, #4
    155c:	f006 0602 	and.w	r6, r6, #2
    1560:	4316      	orrs	r6, r2
		diff    = conn->current_msg->msg.w.len - conn->write_offset;
    1562:	68c2      	ldr	r2, [r0, #12]
#endif
			apiflags |= TCP_WRITE_FLAG_MORE;
		} else {
			len = (u16_t)diff;
		}
		available = tcp_sndbuf(conn->pcb.tcp);
    1564:	6860      	ldr	r0, [r4, #4]
		diff    = conn->current_msg->msg.w.len - conn->write_offset;
    1566:	1b52      	subs	r2, r2, r5
		if (diff > 0xffffUL) { /* max_u16_t */
    1568:	f5b2 3f80 	cmp.w	r2, #65536	; 0x10000
		dataptr = (u8_t *)conn->current_msg->msg.w.dataptr + conn->write_offset;
    156c:	4429      	add	r1, r5
		available = tcp_sndbuf(conn->pcb.tcp);
    156e:	f8b0 5066 	ldrh.w	r5, [r0, #102]	; 0x66
			len = 0xffff;
    1572:	bf2a      	itet	cs
    1574:	f64f 72ff 	movwcs	r2, #65535	; 0xffff
			len = (u16_t)diff;
    1578:	b292      	uxthcc	r2, r2
			apiflags |= TCP_WRITE_FLAG_MORE;
    157a:	f043 0302 	orrcs.w	r3, r3, #2
		if (available < len) {
    157e:	4295      	cmp	r5, r2
    1580:	d230      	bcs.n	15e4 <do_writemore.isra.0+0x9c>
			/* don't try to write more than sendbuf */
			len = available;
			if (dontblock) {
    1582:	b11e      	cbz	r6, 158c <do_writemore.isra.0+0x44>
				if (!len) {
    1584:	b925      	cbnz	r5, 1590 <do_writemore.isra.0+0x48>
					err = ERR_WOULDBLOCK;
    1586:	f06f 0706 	mvn.w	r7, #6
    158a:	e00a      	b.n	15a2 <do_writemore.isra.0+0x5a>
				}
			} else {
#if LWIP_TCPIP_CORE_LOCKING
				conn->flags |= NETCONN_FLAG_WRITE_DELAYED;
#endif
				apiflags |= TCP_WRITE_FLAG_MORE;
    158c:	f043 0302 	orr.w	r3, r3, #2
			}
		}
		LWIP_ASSERT("do_writemore: invalid length!", ((conn->write_offset + len) <= conn->current_msg->msg.w.len));
		err = tcp_write(conn->pcb.tcp, dataptr, len, apiflags);
    1590:	4f2a      	ldr	r7, [pc, #168]	; (163c <do_writemore.isra.0+0xf4>)
    1592:	462a      	mov	r2, r5
    1594:	47b8      	blx	r7
		/* if OK or memory error, check available space */
		if ((err == ERR_OK) || (err == ERR_MEM)) {
    1596:	1c43      	adds	r3, r0, #1
    1598:	b2db      	uxtb	r3, r3
    159a:	2b01      	cmp	r3, #1
		err = tcp_write(conn->pcb.tcp, dataptr, len, apiflags);
    159c:	4607      	mov	r7, r0
		if ((err == ERR_OK) || (err == ERR_MEM)) {
    159e:	d83e      	bhi.n	161e <do_writemore.isra.0+0xd6>
		err_mem:
			if (dontblock && (len < conn->current_msg->msg.w.len)) {
    15a0:	b316      	cbz	r6, 15e8 <do_writemore.isra.0+0xa0>
    15a2:	6a63      	ldr	r3, [r4, #36]	; 0x24
    15a4:	68db      	ldr	r3, [r3, #12]
    15a6:	429d      	cmp	r5, r3
    15a8:	d21e      	bcs.n	15e8 <do_writemore.isra.0+0xa0>
				/* non-blocking write did not write everything: mark the pcb non-writable
				   and let poll_tcp check writable space to mark the pcb writable again */
				API_EVENT(conn, NETCONN_EVT_SENDMINUS, len);
    15aa:	6aa3      	ldr	r3, [r4, #40]	; 0x28
    15ac:	b11b      	cbz	r3, 15b6 <do_writemore.isra.0+0x6e>
    15ae:	462a      	mov	r2, r5
    15b0:	2103      	movs	r1, #3
    15b2:	4620      	mov	r0, r4
    15b4:	4798      	blx	r3
				conn->flags |= NETCONN_FLAG_CHECK_WRITESPACE;
    15b6:	7f23      	ldrb	r3, [r4, #28]
    15b8:	f043 0310 	orr.w	r3, r3, #16
    15bc:	7723      	strb	r3, [r4, #28]
				   let select mark this pcb as non-writable. */
				API_EVENT(conn, NETCONN_EVT_SENDMINUS, len);
			}
		}

		if (err == ERR_OK) {
    15be:	bb37      	cbnz	r7, 160e <do_writemore.isra.0+0xc6>
			conn->write_offset += len;
    15c0:	6a22      	ldr	r2, [r4, #32]
			if ((conn->write_offset == conn->current_msg->msg.w.len) || dontblock) {
    15c2:	6a63      	ldr	r3, [r4, #36]	; 0x24
			conn->write_offset += len;
    15c4:	4415      	add	r5, r2
			if ((conn->write_offset == conn->current_msg->msg.w.len) || dontblock) {
    15c6:	68da      	ldr	r2, [r3, #12]
			conn->write_offset += len;
    15c8:	6225      	str	r5, [r4, #32]
			if ((conn->write_offset == conn->current_msg->msg.w.len) || dontblock) {
    15ca:	4295      	cmp	r5, r2
    15cc:	d000      	beq.n	15d0 <do_writemore.isra.0+0x88>
    15ce:	b11e      	cbz	r6, 15d8 <do_writemore.isra.0+0x90>
				/* return sent length */
				conn->current_msg->msg.w.len = conn->write_offset;
    15d0:	60dd      	str	r5, [r3, #12]
				/* everything was written */
				write_finished     = 1;
				conn->write_offset = 0;
    15d2:	2300      	movs	r3, #0
    15d4:	6223      	str	r3, [r4, #32]
				write_finished     = 1;
    15d6:	2601      	movs	r6, #1
			}
			tcp_output(conn->pcb.tcp);
    15d8:	6860      	ldr	r0, [r4, #4]
    15da:	4b19      	ldr	r3, [pc, #100]	; (1640 <do_writemore.isra.0+0xf8>)
    15dc:	4798      	blx	r3
			   the error to the application thread. */
			write_finished               = 1;
			conn->current_msg->msg.w.len = 0;
		}
	}
	if (write_finished) {
    15de:	bb0e      	cbnz	r6, 1624 <do_writemore.isra.0+0xdc>
#if LWIP_TCPIP_CORE_LOCKING
	else
		return ERR_MEM;
#endif
	return ERR_OK;
}
    15e0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    15e4:	4615      	mov	r5, r2
    15e6:	e7d3      	b.n	1590 <do_writemore.isra.0+0x48>
			} else if ((tcp_sndbuf(conn->pcb.tcp) <= TCP_SNDLOWAT)
    15e8:	6863      	ldr	r3, [r4, #4]
    15ea:	f8b3 1066 	ldrh.w	r1, [r3, #102]	; 0x66
    15ee:	f640 3267 	movw	r2, #2919	; 0xb67
    15f2:	4291      	cmp	r1, r2
    15f4:	d903      	bls.n	15fe <do_writemore.isra.0+0xb6>
			           || (tcp_sndqueuelen(conn->pcb.tcp) >= TCP_SNDQUEUELOWAT)) {
    15f6:	f8b3 3068 	ldrh.w	r3, [r3, #104]	; 0x68
    15fa:	2b04      	cmp	r3, #4
    15fc:	d9df      	bls.n	15be <do_writemore.isra.0+0x76>
				API_EVENT(conn, NETCONN_EVT_SENDMINUS, len);
    15fe:	6aa3      	ldr	r3, [r4, #40]	; 0x28
    1600:	2b00      	cmp	r3, #0
    1602:	d0dc      	beq.n	15be <do_writemore.isra.0+0x76>
    1604:	462a      	mov	r2, r5
    1606:	2103      	movs	r1, #3
    1608:	4620      	mov	r0, r4
    160a:	4798      	blx	r3
    160c:	e7d7      	b.n	15be <do_writemore.isra.0+0x76>
		} else if ((err == ERR_MEM) && !dontblock) {
    160e:	1c7b      	adds	r3, r7, #1
    1610:	d105      	bne.n	161e <do_writemore.isra.0+0xd6>
    1612:	b926      	cbnz	r6, 161e <do_writemore.isra.0+0xd6>
			tcp_output(conn->pcb.tcp);
    1614:	6860      	ldr	r0, [r4, #4]
    1616:	4b0a      	ldr	r3, [pc, #40]	; (1640 <do_writemore.isra.0+0xf8>)
}
    1618:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
			tcp_output(conn->pcb.tcp);
    161c:	4718      	bx	r3
			conn->current_msg->msg.w.len = 0;
    161e:	6a63      	ldr	r3, [r4, #36]	; 0x24
    1620:	2200      	movs	r2, #0
    1622:	60da      	str	r2, [r3, #12]
		conn->current_msg->err = err;
    1624:	6a63      	ldr	r3, [r4, #36]	; 0x24
    1626:	711f      	strb	r7, [r3, #4]
		conn->current_msg      = NULL;
    1628:	2300      	movs	r3, #0
    162a:	6263      	str	r3, [r4, #36]	; 0x24
		conn->state            = NETCONN_NONE;
    162c:	7063      	strb	r3, [r4, #1]
			sys_sem_signal(&conn->op_completed);
    162e:	f104 000c 	add.w	r0, r4, #12
    1632:	4b04      	ldr	r3, [pc, #16]	; (1644 <do_writemore.isra.0+0xfc>)
}
    1634:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
			sys_sem_signal(&conn->op_completed);
    1638:	4718      	bx	r3
    163a:	bf00      	nop
    163c:	00001f99 	.word	0x00001f99
    1640:	00002441 	.word	0x00002441
    1644:	00006aad 	.word	0x00006aad

00001648 <sent_tcp>:
{
    1648:	b538      	push	{r3, r4, r5, lr}
	if (conn->state == NETCONN_WRITE) {
    164a:	7843      	ldrb	r3, [r0, #1]
    164c:	2b01      	cmp	r3, #1
{
    164e:	4604      	mov	r4, r0
    1650:	4615      	mov	r5, r2
	if (conn->state == NETCONN_WRITE) {
    1652:	d119      	bne.n	1688 <sent_tcp+0x40>
		do_writemore(conn);
    1654:	4b0e      	ldr	r3, [pc, #56]	; (1690 <sent_tcp+0x48>)
		do_close_internal(conn);
    1656:	4798      	blx	r3
		if ((conn->pcb.tcp != NULL) && (tcp_sndbuf(conn->pcb.tcp) > TCP_SNDLOWAT)
    1658:	6863      	ldr	r3, [r4, #4]
    165a:	b19b      	cbz	r3, 1684 <sent_tcp+0x3c>
    165c:	f8b3 1066 	ldrh.w	r1, [r3, #102]	; 0x66
    1660:	f640 3267 	movw	r2, #2919	; 0xb67
    1664:	4291      	cmp	r1, r2
    1666:	d90d      	bls.n	1684 <sent_tcp+0x3c>
		    && (tcp_sndqueuelen(conn->pcb.tcp) < TCP_SNDQUEUELOWAT)) {
    1668:	f8b3 3068 	ldrh.w	r3, [r3, #104]	; 0x68
    166c:	2b04      	cmp	r3, #4
    166e:	d809      	bhi.n	1684 <sent_tcp+0x3c>
			conn->flags &= ~NETCONN_FLAG_CHECK_WRITESPACE;
    1670:	7f23      	ldrb	r3, [r4, #28]
    1672:	f023 0310 	bic.w	r3, r3, #16
    1676:	7723      	strb	r3, [r4, #28]
			API_EVENT(conn, NETCONN_EVT_SENDPLUS, len);
    1678:	6aa3      	ldr	r3, [r4, #40]	; 0x28
    167a:	b11b      	cbz	r3, 1684 <sent_tcp+0x3c>
    167c:	462a      	mov	r2, r5
    167e:	2102      	movs	r1, #2
    1680:	4620      	mov	r0, r4
    1682:	4798      	blx	r3
}
    1684:	2000      	movs	r0, #0
    1686:	bd38      	pop	{r3, r4, r5, pc}
	} else if (conn->state == NETCONN_CLOSE) {
    1688:	2b04      	cmp	r3, #4
    168a:	d1e5      	bne.n	1658 <sent_tcp+0x10>
		do_close_internal(conn);
    168c:	4b01      	ldr	r3, [pc, #4]	; (1694 <sent_tcp+0x4c>)
    168e:	e7e2      	b.n	1656 <sent_tcp+0xe>
    1690:	00001549 	.word	0x00001549
    1694:	000013b9 	.word	0x000013b9

00001698 <poll_tcp>:
{
    1698:	b510      	push	{r4, lr}
	if (conn->state == NETCONN_WRITE) {
    169a:	7843      	ldrb	r3, [r0, #1]
    169c:	2b01      	cmp	r3, #1
{
    169e:	4604      	mov	r4, r0
	if (conn->state == NETCONN_WRITE) {
    16a0:	d11b      	bne.n	16da <poll_tcp+0x42>
		do_writemore(conn);
    16a2:	4b10      	ldr	r3, [pc, #64]	; (16e4 <poll_tcp+0x4c>)
		do_close_internal(conn);
    16a4:	4798      	blx	r3
	if (conn->flags & NETCONN_FLAG_CHECK_WRITESPACE) {
    16a6:	7f23      	ldrb	r3, [r4, #28]
    16a8:	06da      	lsls	r2, r3, #27
    16aa:	d514      	bpl.n	16d6 <poll_tcp+0x3e>
		if ((conn->pcb.tcp != NULL) && (tcp_sndbuf(conn->pcb.tcp) > TCP_SNDLOWAT)
    16ac:	6862      	ldr	r2, [r4, #4]
    16ae:	b192      	cbz	r2, 16d6 <poll_tcp+0x3e>
    16b0:	f8b2 0066 	ldrh.w	r0, [r2, #102]	; 0x66
    16b4:	f640 3167 	movw	r1, #2919	; 0xb67
    16b8:	4288      	cmp	r0, r1
    16ba:	d90c      	bls.n	16d6 <poll_tcp+0x3e>
		    && (tcp_sndqueuelen(conn->pcb.tcp) < TCP_SNDQUEUELOWAT)) {
    16bc:	f8b2 2068 	ldrh.w	r2, [r2, #104]	; 0x68
    16c0:	2a04      	cmp	r2, #4
    16c2:	d808      	bhi.n	16d6 <poll_tcp+0x3e>
			conn->flags &= ~NETCONN_FLAG_CHECK_WRITESPACE;
    16c4:	f023 0310 	bic.w	r3, r3, #16
    16c8:	7723      	strb	r3, [r4, #28]
			API_EVENT(conn, NETCONN_EVT_SENDPLUS, 0);
    16ca:	6aa3      	ldr	r3, [r4, #40]	; 0x28
    16cc:	b11b      	cbz	r3, 16d6 <poll_tcp+0x3e>
    16ce:	2200      	movs	r2, #0
    16d0:	2102      	movs	r1, #2
    16d2:	4620      	mov	r0, r4
    16d4:	4798      	blx	r3
}
    16d6:	2000      	movs	r0, #0
    16d8:	bd10      	pop	{r4, pc}
	} else if (conn->state == NETCONN_CLOSE) {
    16da:	2b04      	cmp	r3, #4
    16dc:	d1e3      	bne.n	16a6 <poll_tcp+0xe>
		do_close_internal(conn);
    16de:	4b02      	ldr	r3, [pc, #8]	; (16e8 <poll_tcp+0x50>)
    16e0:	e7e0      	b.n	16a4 <poll_tcp+0xc>
    16e2:	bf00      	nop
    16e4:	00001549 	.word	0x00001549
    16e8:	000013b9 	.word	0x000013b9

000016ec <do_newconn>:
{
    16ec:	b570      	push	{r4, r5, r6, lr}
	msg->err = ERR_OK;
    16ee:	2300      	movs	r3, #0
	if (msg->conn->pcb.tcp == NULL) {
    16f0:	6805      	ldr	r5, [r0, #0]
	msg->err = ERR_OK;
    16f2:	7103      	strb	r3, [r0, #4]
	if (msg->conn->pcb.tcp == NULL) {
    16f4:	686b      	ldr	r3, [r5, #4]
{
    16f6:	4604      	mov	r4, r0
	if (msg->conn->pcb.tcp == NULL) {
    16f8:	b9bb      	cbnz	r3, 172a <do_newconn+0x3e>
	switch (NETCONNTYPE_GROUP(msg->conn->type)) {
    16fa:	782b      	ldrb	r3, [r5, #0]
    16fc:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
    1700:	2b10      	cmp	r3, #16
    1702:	d018      	beq.n	1736 <do_newconn+0x4a>
    1704:	2b20      	cmp	r3, #32
    1706:	d120      	bne.n	174a <do_newconn+0x5e>
		msg->conn->pcb.udp = udp_new();
    1708:	4b11      	ldr	r3, [pc, #68]	; (1750 <do_newconn+0x64>)
    170a:	4798      	blx	r3
		if (msg->conn->pcb.udp == NULL) {
    170c:	6822      	ldr	r2, [r4, #0]
		msg->conn->pcb.udp = udp_new();
    170e:	6068      	str	r0, [r5, #4]
		if (msg->conn->pcb.udp == NULL) {
    1710:	6850      	ldr	r0, [r2, #4]
    1712:	b910      	cbnz	r0, 171a <do_newconn+0x2e>
			msg->err = ERR_MEM;
    1714:	23ff      	movs	r3, #255	; 0xff
		msg->err = ERR_VAL;
    1716:	7123      	strb	r3, [r4, #4]
		break;
    1718:	e007      	b.n	172a <do_newconn+0x3e>
		if (msg->conn->type == NETCONN_UDPNOCHKSUM) {
    171a:	7813      	ldrb	r3, [r2, #0]
		udp_recv(msg->conn->pcb.udp, recv_udp, msg->conn);
    171c:	490d      	ldr	r1, [pc, #52]	; (1754 <do_newconn+0x68>)
		if (msg->conn->type == NETCONN_UDPNOCHKSUM) {
    171e:	2b22      	cmp	r3, #34	; 0x22
			udp_setflags(msg->conn->pcb.udp, UDP_FLAGS_NOCHKSUM);
    1720:	bf04      	itt	eq
    1722:	2301      	moveq	r3, #1
    1724:	7403      	strbeq	r3, [r0, #16]
		udp_recv(msg->conn->pcb.udp, recv_udp, msg->conn);
    1726:	4b0c      	ldr	r3, [pc, #48]	; (1758 <do_newconn+0x6c>)
    1728:	4798      	blx	r3
	TCPIP_APIMSG_ACK(msg);
    172a:	6820      	ldr	r0, [r4, #0]
    172c:	4b0b      	ldr	r3, [pc, #44]	; (175c <do_newconn+0x70>)
}
    172e:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	TCPIP_APIMSG_ACK(msg);
    1732:	300c      	adds	r0, #12
    1734:	4718      	bx	r3
		msg->conn->pcb.tcp = tcp_new();
    1736:	4b0a      	ldr	r3, [pc, #40]	; (1760 <do_newconn+0x74>)
    1738:	4798      	blx	r3
    173a:	6068      	str	r0, [r5, #4]
		if (msg->conn->pcb.tcp == NULL) {
    173c:	6820      	ldr	r0, [r4, #0]
    173e:	6843      	ldr	r3, [r0, #4]
    1740:	2b00      	cmp	r3, #0
    1742:	d0e7      	beq.n	1714 <do_newconn+0x28>
		setup_tcp(msg->conn);
    1744:	4b07      	ldr	r3, [pc, #28]	; (1764 <do_newconn+0x78>)
    1746:	4798      	blx	r3
		break;
    1748:	e7ef      	b.n	172a <do_newconn+0x3e>
		msg->err = ERR_VAL;
    174a:	23fa      	movs	r3, #250	; 0xfa
    174c:	e7e3      	b.n	1716 <do_newconn+0x2a>
    174e:	bf00      	nop
    1750:	000047a9 	.word	0x000047a9
    1754:	000012d9 	.word	0x000012d9
    1758:	00004771 	.word	0x00004771
    175c:	00006aad 	.word	0x00006aad
    1760:	00006409 	.word	0x00006409
    1764:	00001361 	.word	0x00001361

00001768 <netconn_alloc>:
{
    1768:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	conn = (struct netconn *)memp_malloc(MEMP_NETCONN);
    176a:	4b17      	ldr	r3, [pc, #92]	; (17c8 <netconn_alloc+0x60>)
{
    176c:	4605      	mov	r5, r0
	conn = (struct netconn *)memp_malloc(MEMP_NETCONN);
    176e:	2007      	movs	r0, #7
{
    1770:	460e      	mov	r6, r1
	conn = (struct netconn *)memp_malloc(MEMP_NETCONN);
    1772:	4798      	blx	r3
	if (conn == NULL) {
    1774:	4604      	mov	r4, r0
    1776:	b320      	cbz	r0, 17c2 <netconn_alloc+0x5a>
	conn->last_err = ERR_OK;
    1778:	2100      	movs	r1, #0
	if (sys_sem_new(&conn->op_completed, 0) != ERR_OK) {
    177a:	f100 070c 	add.w	r7, r0, #12
	conn->last_err = ERR_OK;
    177e:	7201      	strb	r1, [r0, #8]
	conn->type     = t;
    1780:	7005      	strb	r5, [r0, #0]
	conn->pcb.tcp  = NULL;
    1782:	6041      	str	r1, [r0, #4]
	if (sys_sem_new(&conn->op_completed, 0) != ERR_OK) {
    1784:	4b11      	ldr	r3, [pc, #68]	; (17cc <netconn_alloc+0x64>)
    1786:	4638      	mov	r0, r7
    1788:	4798      	blx	r3
    178a:	b940      	cbnz	r0, 179e <netconn_alloc+0x36>
	if (sys_mbox_new(&conn->recvmbox, size) != ERR_OK) {
    178c:	2110      	movs	r1, #16
    178e:	4b10      	ldr	r3, [pc, #64]	; (17d0 <netconn_alloc+0x68>)
    1790:	1860      	adds	r0, r4, r1
    1792:	4798      	blx	r3
    1794:	4605      	mov	r5, r0
    1796:	b140      	cbz	r0, 17aa <netconn_alloc+0x42>
		sys_sem_free(&conn->op_completed);
    1798:	4b0e      	ldr	r3, [pc, #56]	; (17d4 <netconn_alloc+0x6c>)
    179a:	4638      	mov	r0, r7
    179c:	4798      	blx	r3
	memp_free(MEMP_NETCONN, conn);
    179e:	4621      	mov	r1, r4
    17a0:	4b0d      	ldr	r3, [pc, #52]	; (17d8 <netconn_alloc+0x70>)
    17a2:	2007      	movs	r0, #7
    17a4:	4798      	blx	r3
	return NULL;
    17a6:	2400      	movs	r4, #0
    17a8:	e00b      	b.n	17c2 <netconn_alloc+0x5a>
	sys_mbox_set_invalid(&conn->acceptmbox);
    17aa:	4b0c      	ldr	r3, [pc, #48]	; (17dc <netconn_alloc+0x74>)
    17ac:	f104 0014 	add.w	r0, r4, #20
    17b0:	4798      	blx	r3
	conn->current_msg  = NULL;
    17b2:	e9c4 5609 	strd	r5, r6, [r4, #36]	; 0x24
	conn->socket = -1;
    17b6:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
	conn->state = NETCONN_NONE;
    17ba:	7065      	strb	r5, [r4, #1]
	conn->socket = -1;
    17bc:	61a3      	str	r3, [r4, #24]
	conn->write_offset = 0;
    17be:	6225      	str	r5, [r4, #32]
	conn->flags = 0;
    17c0:	7725      	strb	r5, [r4, #28]
}
    17c2:	4620      	mov	r0, r4
    17c4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    17c6:	bf00      	nop
    17c8:	00004b2d 	.word	0x00004b2d
    17cc:	00006a3d 	.word	0x00006a3d
    17d0:	00006b31 	.word	0x00006b31
    17d4:	00006a9d 	.word	0x00006a9d
    17d8:	00004b49 	.word	0x00004b49
    17dc:	00006c75 	.word	0x00006c75

000017e0 <netconn_free>:
{
    17e0:	b513      	push	{r0, r1, r4, lr}
	sys_sem_free(&conn->op_completed);
    17e2:	4b07      	ldr	r3, [pc, #28]	; (1800 <netconn_free+0x20>)
{
    17e4:	4604      	mov	r4, r0
	sys_sem_free(&conn->op_completed);
    17e6:	300c      	adds	r0, #12
    17e8:	9001      	str	r0, [sp, #4]
    17ea:	4798      	blx	r3
	sys_sem_set_invalid(&conn->op_completed);
    17ec:	9801      	ldr	r0, [sp, #4]
    17ee:	4b05      	ldr	r3, [pc, #20]	; (1804 <netconn_free+0x24>)
    17f0:	4798      	blx	r3
	memp_free(MEMP_NETCONN, conn);
    17f2:	4b05      	ldr	r3, [pc, #20]	; (1808 <netconn_free+0x28>)
    17f4:	4621      	mov	r1, r4
    17f6:	2007      	movs	r0, #7
}
    17f8:	b002      	add	sp, #8
    17fa:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	memp_free(MEMP_NETCONN, conn);
    17fe:	4718      	bx	r3
    1800:	00006a9d 	.word	0x00006a9d
    1804:	00006b29 	.word	0x00006b29
    1808:	00004b49 	.word	0x00004b49

0000180c <netconn_drain>:
{
    180c:	e92d 47f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, r9, sl, lr}
	if (sys_mbox_valid(&conn->recvmbox)) {
    1810:	f100 0510 	add.w	r5, r0, #16
{
    1814:	4604      	mov	r4, r0
	if (sys_mbox_valid(&conn->recvmbox)) {
    1816:	4f24      	ldr	r7, [pc, #144]	; (18a8 <netconn_drain+0x9c>)
    1818:	4628      	mov	r0, r5
    181a:	47b8      	blx	r7
    181c:	b180      	cbz	r0, 1840 <netconn_drain+0x34>
		while (sys_mbox_tryfetch(&conn->recvmbox, &mem) != SYS_MBOX_EMPTY) {
    181e:	f8df 8094 	ldr.w	r8, [pc, #148]	; 18b4 <netconn_drain+0xa8>
				netbuf_delete((struct netbuf *)mem);
    1822:	f8df 909c 	ldr.w	r9, [pc, #156]	; 18c0 <netconn_drain+0xb4>
					pbuf_free(p);
    1826:	f8df a09c 	ldr.w	sl, [pc, #156]	; 18c4 <netconn_drain+0xb8>
		while (sys_mbox_tryfetch(&conn->recvmbox, &mem) != SYS_MBOX_EMPTY) {
    182a:	a901      	add	r1, sp, #4
    182c:	4628      	mov	r0, r5
    182e:	47c0      	blx	r8
    1830:	3001      	adds	r0, #1
    1832:	d11b      	bne.n	186c <netconn_drain+0x60>
		sys_mbox_free(&conn->recvmbox);
    1834:	4b1d      	ldr	r3, [pc, #116]	; (18ac <netconn_drain+0xa0>)
    1836:	4628      	mov	r0, r5
    1838:	4798      	blx	r3
		sys_mbox_set_invalid(&conn->recvmbox);
    183a:	4b1d      	ldr	r3, [pc, #116]	; (18b0 <netconn_drain+0xa4>)
    183c:	4628      	mov	r0, r5
    183e:	4798      	blx	r3
	if (sys_mbox_valid(&conn->acceptmbox)) {
    1840:	3414      	adds	r4, #20
    1842:	4620      	mov	r0, r4
    1844:	47b8      	blx	r7
    1846:	b170      	cbz	r0, 1866 <netconn_drain+0x5a>
		while (sys_mbox_tryfetch(&conn->acceptmbox, &mem) != SYS_MBOX_EMPTY) {
    1848:	4e1a      	ldr	r6, [pc, #104]	; (18b4 <netconn_drain+0xa8>)
				tcp_abort(newconn->pcb.tcp);
    184a:	4f1b      	ldr	r7, [pc, #108]	; (18b8 <netconn_drain+0xac>)
			netconn_free(newconn);
    184c:	f8df 8078 	ldr.w	r8, [pc, #120]	; 18c8 <netconn_drain+0xbc>
		while (sys_mbox_tryfetch(&conn->acceptmbox, &mem) != SYS_MBOX_EMPTY) {
    1850:	a901      	add	r1, sp, #4
    1852:	4620      	mov	r0, r4
    1854:	47b0      	blx	r6
    1856:	3001      	adds	r0, #1
    1858:	d119      	bne.n	188e <netconn_drain+0x82>
		sys_mbox_free(&conn->acceptmbox);
    185a:	4b14      	ldr	r3, [pc, #80]	; (18ac <netconn_drain+0xa0>)
    185c:	4620      	mov	r0, r4
    185e:	4798      	blx	r3
		sys_mbox_set_invalid(&conn->acceptmbox);
    1860:	4b13      	ldr	r3, [pc, #76]	; (18b0 <netconn_drain+0xa4>)
    1862:	4620      	mov	r0, r4
    1864:	4798      	blx	r3
}
    1866:	b002      	add	sp, #8
    1868:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
			if (conn->type == NETCONN_TCP) {
    186c:	7823      	ldrb	r3, [r4, #0]
				if (mem != NULL) {
    186e:	9e01      	ldr	r6, [sp, #4]
			if (conn->type == NETCONN_TCP) {
    1870:	2b10      	cmp	r3, #16
    1872:	d109      	bne.n	1888 <netconn_drain+0x7c>
				if (mem != NULL) {
    1874:	2e00      	cmp	r6, #0
    1876:	d0d8      	beq.n	182a <netconn_drain+0x1e>
					if (conn->pcb.tcp != NULL) {
    1878:	6860      	ldr	r0, [r4, #4]
    187a:	b110      	cbz	r0, 1882 <netconn_drain+0x76>
						tcp_recved(conn->pcb.tcp, p->tot_len);
    187c:	8931      	ldrh	r1, [r6, #8]
    187e:	4b0f      	ldr	r3, [pc, #60]	; (18bc <netconn_drain+0xb0>)
    1880:	4798      	blx	r3
					pbuf_free(p);
    1882:	4630      	mov	r0, r6
    1884:	47d0      	blx	sl
    1886:	e7d0      	b.n	182a <netconn_drain+0x1e>
				netbuf_delete((struct netbuf *)mem);
    1888:	4630      	mov	r0, r6
    188a:	47c8      	blx	r9
    188c:	e7cd      	b.n	182a <netconn_drain+0x1e>
			struct netconn *newconn = (struct netconn *)mem;
    188e:	9d01      	ldr	r5, [sp, #4]
			netconn_drain(newconn);
    1890:	4628      	mov	r0, r5
    1892:	f7ff ffbb 	bl	180c <netconn_drain>
			if (newconn->pcb.tcp != NULL) {
    1896:	6868      	ldr	r0, [r5, #4]
    1898:	b110      	cbz	r0, 18a0 <netconn_drain+0x94>
				tcp_abort(newconn->pcb.tcp);
    189a:	47b8      	blx	r7
				newconn->pcb.tcp = NULL;
    189c:	2300      	movs	r3, #0
    189e:	606b      	str	r3, [r5, #4]
			netconn_free(newconn);
    18a0:	4628      	mov	r0, r5
    18a2:	47c0      	blx	r8
    18a4:	e7d4      	b.n	1850 <netconn_drain+0x44>
    18a6:	bf00      	nop
    18a8:	00006c71 	.word	0x00006c71
    18ac:	00006b51 	.word	0x00006b51
    18b0:	00006c75 	.word	0x00006c75
    18b4:	00006c49 	.word	0x00006c49
    18b8:	000062ed 	.word	0x000062ed
    18bc:	00005af9 	.word	0x00005af9
    18c0:	00000d7d 	.word	0x00000d7d
    18c4:	00003081 	.word	0x00003081
    18c8:	000017e1 	.word	0x000017e1

000018cc <accept_function>:
{
    18cc:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
	if (!sys_mbox_valid(&conn->acceptmbox)) {
    18d0:	f100 0814 	add.w	r8, r0, #20
{
    18d4:	4606      	mov	r6, r0
	if (!sys_mbox_valid(&conn->acceptmbox)) {
    18d6:	4b25      	ldr	r3, [pc, #148]	; (196c <accept_function+0xa0>)
    18d8:	4640      	mov	r0, r8
{
    18da:	460f      	mov	r7, r1
    18dc:	4615      	mov	r5, r2
	if (!sys_mbox_valid(&conn->acceptmbox)) {
    18de:	4798      	blx	r3
    18e0:	2800      	cmp	r0, #0
    18e2:	d040      	beq.n	1966 <accept_function+0x9a>
	newconn = netconn_alloc(conn->type, conn->callback);
    18e4:	6ab1      	ldr	r1, [r6, #40]	; 0x28
    18e6:	7830      	ldrb	r0, [r6, #0]
    18e8:	4b21      	ldr	r3, [pc, #132]	; (1970 <accept_function+0xa4>)
    18ea:	4798      	blx	r3
	if (newconn == NULL) {
    18ec:	4604      	mov	r4, r0
    18ee:	2800      	cmp	r0, #0
    18f0:	d02c      	beq.n	194c <accept_function+0x80>
	setup_tcp(newconn);
    18f2:	4b20      	ldr	r3, [pc, #128]	; (1974 <accept_function+0xa8>)
	newconn->pcb.tcp = newpcb;
    18f4:	6047      	str	r7, [r0, #4]
	setup_tcp(newconn);
    18f6:	4798      	blx	r3
	newconn->last_err = err;
    18f8:	7225      	strb	r5, [r4, #8]
	if (sys_mbox_trypost(&conn->acceptmbox, newconn) != ERR_OK) {
    18fa:	4b1f      	ldr	r3, [pc, #124]	; (1978 <accept_function+0xac>)
    18fc:	4621      	mov	r1, r4
    18fe:	4640      	mov	r0, r8
    1900:	4798      	blx	r3
    1902:	4605      	mov	r5, r0
    1904:	b328      	cbz	r0, 1952 <accept_function+0x86>
		struct tcp_pcb *pcb = newconn->pcb.tcp;
    1906:	6860      	ldr	r0, [r4, #4]
		tcp_arg(pcb, NULL);
    1908:	4b1c      	ldr	r3, [pc, #112]	; (197c <accept_function+0xb0>)
    190a:	9001      	str	r0, [sp, #4]
    190c:	2100      	movs	r1, #0
    190e:	4798      	blx	r3
		tcp_recv(pcb, NULL);
    1910:	9801      	ldr	r0, [sp, #4]
    1912:	4b1b      	ldr	r3, [pc, #108]	; (1980 <accept_function+0xb4>)
    1914:	2100      	movs	r1, #0
    1916:	4798      	blx	r3
		tcp_sent(pcb, NULL);
    1918:	9801      	ldr	r0, [sp, #4]
    191a:	4b1a      	ldr	r3, [pc, #104]	; (1984 <accept_function+0xb8>)
    191c:	2100      	movs	r1, #0
    191e:	4798      	blx	r3
		tcp_poll(pcb, NULL, 4);
    1920:	2204      	movs	r2, #4
    1922:	9801      	ldr	r0, [sp, #4]
    1924:	4b18      	ldr	r3, [pc, #96]	; (1988 <accept_function+0xbc>)
    1926:	2100      	movs	r1, #0
    1928:	4798      	blx	r3
		tcp_err(pcb, NULL);
    192a:	2100      	movs	r1, #0
    192c:	9801      	ldr	r0, [sp, #4]
    192e:	4b17      	ldr	r3, [pc, #92]	; (198c <accept_function+0xc0>)
    1930:	4798      	blx	r3
		newconn->pcb.tcp = NULL;
    1932:	2300      	movs	r3, #0
		sys_mbox_free(&newconn->recvmbox);
    1934:	f104 0010 	add.w	r0, r4, #16
		newconn->pcb.tcp = NULL;
    1938:	6063      	str	r3, [r4, #4]
		sys_mbox_free(&newconn->recvmbox);
    193a:	4b15      	ldr	r3, [pc, #84]	; (1990 <accept_function+0xc4>)
    193c:	9001      	str	r0, [sp, #4]
    193e:	4798      	blx	r3
		sys_mbox_set_invalid(&newconn->recvmbox);
    1940:	9801      	ldr	r0, [sp, #4]
    1942:	4b14      	ldr	r3, [pc, #80]	; (1994 <accept_function+0xc8>)
    1944:	4798      	blx	r3
		netconn_free(newconn);
    1946:	4b14      	ldr	r3, [pc, #80]	; (1998 <accept_function+0xcc>)
    1948:	4620      	mov	r0, r4
    194a:	4798      	blx	r3
		return ERR_MEM;
    194c:	f04f 35ff 	mov.w	r5, #4294967295	; 0xffffffff
    1950:	e005      	b.n	195e <accept_function+0x92>
		API_EVENT(conn, NETCONN_EVT_RCVPLUS, 0);
    1952:	6ab3      	ldr	r3, [r6, #40]	; 0x28
    1954:	b11b      	cbz	r3, 195e <accept_function+0x92>
    1956:	4602      	mov	r2, r0
    1958:	4601      	mov	r1, r0
    195a:	4630      	mov	r0, r6
    195c:	4798      	blx	r3
}
    195e:	4628      	mov	r0, r5
    1960:	b002      	add	sp, #8
    1962:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		return ERR_VAL;
    1966:	f06f 0505 	mvn.w	r5, #5
    196a:	e7f8      	b.n	195e <accept_function+0x92>
    196c:	00006c71 	.word	0x00006c71
    1970:	00001769 	.word	0x00001769
    1974:	00001361 	.word	0x00001361
    1978:	00006b7d 	.word	0x00006b7d
    197c:	00005ba5 	.word	0x00005ba5
    1980:	00005ba9 	.word	0x00005ba9
    1984:	00005baf 	.word	0x00005baf
    1988:	00005bbd 	.word	0x00005bbd
    198c:	00005bb3 	.word	0x00005bb3
    1990:	00006b51 	.word	0x00006b51
    1994:	00006c75 	.word	0x00006c75
    1998:	000017e1 	.word	0x000017e1

0000199c <do_delconn>:
{
    199c:	b510      	push	{r4, lr}
    199e:	4604      	mov	r4, r0
	if ((msg->conn->state != NETCONN_NONE) && (msg->conn->state != NETCONN_LISTEN)
    19a0:	6800      	ldr	r0, [r0, #0]
    19a2:	7843      	ldrb	r3, [r0, #1]
    19a4:	b183      	cbz	r3, 19c8 <do_delconn+0x2c>
    19a6:	3b02      	subs	r3, #2
    19a8:	2b01      	cmp	r3, #1
    19aa:	d90d      	bls.n	19c8 <do_delconn+0x2c>
		msg->err = ERR_INPROGRESS;
    19ac:	23fb      	movs	r3, #251	; 0xfb
    19ae:	7123      	strb	r3, [r4, #4]
	if (sys_sem_valid(&msg->conn->op_completed)) {
    19b0:	6820      	ldr	r0, [r4, #0]
    19b2:	4b1b      	ldr	r3, [pc, #108]	; (1a20 <do_delconn+0x84>)
    19b4:	300c      	adds	r0, #12
    19b6:	4798      	blx	r3
    19b8:	2800      	cmp	r0, #0
    19ba:	d030      	beq.n	1a1e <do_delconn+0x82>
		sys_sem_signal(&msg->conn->op_completed);
    19bc:	6820      	ldr	r0, [r4, #0]
    19be:	4b19      	ldr	r3, [pc, #100]	; (1a24 <do_delconn+0x88>)
}
    19c0:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		sys_sem_signal(&msg->conn->op_completed);
    19c4:	300c      	adds	r0, #12
    19c6:	4718      	bx	r3
		netconn_drain(msg->conn);
    19c8:	4b17      	ldr	r3, [pc, #92]	; (1a28 <do_delconn+0x8c>)
    19ca:	4798      	blx	r3
		if (msg->conn->pcb.tcp != NULL) {
    19cc:	6823      	ldr	r3, [r4, #0]
    19ce:	6858      	ldr	r0, [r3, #4]
    19d0:	b168      	cbz	r0, 19ee <do_delconn+0x52>
			switch (NETCONNTYPE_GROUP(msg->conn->type)) {
    19d2:	781a      	ldrb	r2, [r3, #0]
    19d4:	f002 02f0 	and.w	r2, r2, #240	; 0xf0
    19d8:	2a10      	cmp	r2, #16
    19da:	d016      	beq.n	1a0a <do_delconn+0x6e>
    19dc:	2a20      	cmp	r2, #32
    19de:	d103      	bne.n	19e8 <do_delconn+0x4c>
				msg->conn->pcb.udp->recv_arg = NULL;
    19e0:	2300      	movs	r3, #0
    19e2:	61c3      	str	r3, [r0, #28]
				udp_remove(msg->conn->pcb.udp);
    19e4:	4b11      	ldr	r3, [pc, #68]	; (1a2c <do_delconn+0x90>)
    19e6:	4798      	blx	r3
			msg->conn->pcb.tcp = NULL;
    19e8:	6823      	ldr	r3, [r4, #0]
    19ea:	2200      	movs	r2, #0
    19ec:	605a      	str	r2, [r3, #4]
		API_EVENT(msg->conn, NETCONN_EVT_RCVPLUS, 0);
    19ee:	6820      	ldr	r0, [r4, #0]
    19f0:	6a83      	ldr	r3, [r0, #40]	; 0x28
    19f2:	b113      	cbz	r3, 19fa <do_delconn+0x5e>
    19f4:	2200      	movs	r2, #0
    19f6:	4611      	mov	r1, r2
    19f8:	4798      	blx	r3
		API_EVENT(msg->conn, NETCONN_EVT_SENDPLUS, 0);
    19fa:	6820      	ldr	r0, [r4, #0]
    19fc:	6a83      	ldr	r3, [r0, #40]	; 0x28
    19fe:	2b00      	cmp	r3, #0
    1a00:	d0d6      	beq.n	19b0 <do_delconn+0x14>
    1a02:	2200      	movs	r2, #0
    1a04:	2102      	movs	r1, #2
    1a06:	4798      	blx	r3
    1a08:	e7d2      	b.n	19b0 <do_delconn+0x14>
				msg->conn->state       = NETCONN_CLOSE;
    1a0a:	2204      	movs	r2, #4
    1a0c:	705a      	strb	r2, [r3, #1]
				msg->msg.sd.shut       = NETCONN_SHUT_RDWR;
    1a0e:	2203      	movs	r2, #3
    1a10:	7222      	strb	r2, [r4, #8]
				do_close_internal(msg->conn);
    1a12:	4618      	mov	r0, r3
				msg->conn->current_msg = msg;
    1a14:	625c      	str	r4, [r3, #36]	; 0x24
}
    1a16:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
				do_close_internal(msg->conn);
    1a1a:	4b05      	ldr	r3, [pc, #20]	; (1a30 <do_delconn+0x94>)
    1a1c:	4718      	bx	r3
}
    1a1e:	bd10      	pop	{r4, pc}
    1a20:	00006b25 	.word	0x00006b25
    1a24:	00006aad 	.word	0x00006aad
    1a28:	0000180d 	.word	0x0000180d
    1a2c:	00004779 	.word	0x00004779
    1a30:	000013b9 	.word	0x000013b9

00001a34 <do_bind>:
{
    1a34:	b510      	push	{r4, lr}
	if (ERR_IS_FATAL(msg->conn->last_err)) {
    1a36:	6803      	ldr	r3, [r0, #0]
    1a38:	f993 2008 	ldrsb.w	r2, [r3, #8]
    1a3c:	f112 0f09 	cmn.w	r2, #9
{
    1a40:	4604      	mov	r4, r0
	if (ERR_IS_FATAL(msg->conn->last_err)) {
    1a42:	da06      	bge.n	1a52 <do_bind+0x1e>
		msg->err = msg->conn->last_err;
    1a44:	7102      	strb	r2, [r0, #4]
	TCPIP_APIMSG_ACK(msg);
    1a46:	6820      	ldr	r0, [r4, #0]
    1a48:	4b0d      	ldr	r3, [pc, #52]	; (1a80 <do_bind+0x4c>)
}
    1a4a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	TCPIP_APIMSG_ACK(msg);
    1a4e:	300c      	adds	r0, #12
    1a50:	4718      	bx	r3
		msg->err = ERR_VAL;
    1a52:	22fa      	movs	r2, #250	; 0xfa
    1a54:	7102      	strb	r2, [r0, #4]
		if (msg->conn->pcb.tcp != NULL) {
    1a56:	6858      	ldr	r0, [r3, #4]
    1a58:	2800      	cmp	r0, #0
    1a5a:	d0f4      	beq.n	1a46 <do_bind+0x12>
			switch (NETCONNTYPE_GROUP(msg->conn->type)) {
    1a5c:	781b      	ldrb	r3, [r3, #0]
    1a5e:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
    1a62:	2b10      	cmp	r3, #16
    1a64:	d007      	beq.n	1a76 <do_bind+0x42>
    1a66:	2b20      	cmp	r3, #32
    1a68:	d1ed      	bne.n	1a46 <do_bind+0x12>
				msg->err = udp_bind(msg->conn->pcb.udp, msg->msg.bc.ipaddr, msg->msg.bc.port);
    1a6a:	89a2      	ldrh	r2, [r4, #12]
    1a6c:	68a1      	ldr	r1, [r4, #8]
    1a6e:	4b05      	ldr	r3, [pc, #20]	; (1a84 <do_bind+0x50>)
				msg->err = tcp_bind(msg->conn->pcb.tcp, msg->msg.bc.ipaddr, msg->msg.bc.port);
    1a70:	4798      	blx	r3
    1a72:	7120      	strb	r0, [r4, #4]
				break;
    1a74:	e7e7      	b.n	1a46 <do_bind+0x12>
				msg->err = tcp_bind(msg->conn->pcb.tcp, msg->msg.bc.ipaddr, msg->msg.bc.port);
    1a76:	89a2      	ldrh	r2, [r4, #12]
    1a78:	68a1      	ldr	r1, [r4, #8]
    1a7a:	4b03      	ldr	r3, [pc, #12]	; (1a88 <do_bind+0x54>)
    1a7c:	e7f8      	b.n	1a70 <do_bind+0x3c>
    1a7e:	bf00      	nop
    1a80:	00006aad 	.word	0x00006aad
    1a84:	0000458d 	.word	0x0000458d
    1a88:	000059ad 	.word	0x000059ad

00001a8c <do_listen>:
{
    1a8c:	b570      	push	{r4, r5, r6, lr}
	if (ERR_IS_FATAL(msg->conn->last_err)) {
    1a8e:	6803      	ldr	r3, [r0, #0]
    1a90:	f993 2008 	ldrsb.w	r2, [r3, #8]
    1a94:	f112 0f09 	cmn.w	r2, #9
{
    1a98:	4604      	mov	r4, r0
	if (ERR_IS_FATAL(msg->conn->last_err)) {
    1a9a:	da06      	bge.n	1aaa <do_listen+0x1e>
		msg->err = msg->conn->last_err;
    1a9c:	7102      	strb	r2, [r0, #4]
	TCPIP_APIMSG_ACK(msg);
    1a9e:	6820      	ldr	r0, [r4, #0]
    1aa0:	4b24      	ldr	r3, [pc, #144]	; (1b34 <do_listen+0xa8>)
}
    1aa2:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	TCPIP_APIMSG_ACK(msg);
    1aa6:	300c      	adds	r0, #12
    1aa8:	4718      	bx	r3
		msg->err = ERR_CONN;
    1aaa:	22f3      	movs	r2, #243	; 0xf3
    1aac:	7102      	strb	r2, [r0, #4]
		if (msg->conn->pcb.tcp != NULL) {
    1aae:	6858      	ldr	r0, [r3, #4]
    1ab0:	2800      	cmp	r0, #0
    1ab2:	d0f4      	beq.n	1a9e <do_listen+0x12>
			if (msg->conn->type == NETCONN_TCP) {
    1ab4:	781a      	ldrb	r2, [r3, #0]
    1ab6:	2a10      	cmp	r2, #16
    1ab8:	d13a      	bne.n	1b30 <do_listen+0xa4>
				if (msg->conn->state == NETCONN_NONE) {
    1aba:	785b      	ldrb	r3, [r3, #1]
    1abc:	2b00      	cmp	r3, #0
    1abe:	d1ee      	bne.n	1a9e <do_listen+0x12>
					struct tcp_pcb *lpcb = tcp_listen(msg->conn->pcb.tcp);
    1ac0:	4b1d      	ldr	r3, [pc, #116]	; (1b38 <do_listen+0xac>)
    1ac2:	21ff      	movs	r1, #255	; 0xff
    1ac4:	4798      	blx	r3
					if (lpcb == NULL) {
    1ac6:	4605      	mov	r5, r0
    1ac8:	b910      	cbnz	r0, 1ad0 <do_listen+0x44>
						msg->err = ERR_MEM;
    1aca:	23ff      	movs	r3, #255	; 0xff
				msg->err = ERR_ARG;
    1acc:	7123      	strb	r3, [r4, #4]
    1ace:	e7e6      	b.n	1a9e <do_listen+0x12>
						if (sys_mbox_valid(&msg->conn->recvmbox)) {
    1ad0:	6820      	ldr	r0, [r4, #0]
    1ad2:	4e1a      	ldr	r6, [pc, #104]	; (1b3c <do_listen+0xb0>)
    1ad4:	3010      	adds	r0, #16
    1ad6:	47b0      	blx	r6
    1ad8:	b138      	cbz	r0, 1aea <do_listen+0x5e>
							sys_mbox_free(&msg->conn->recvmbox);
    1ada:	6820      	ldr	r0, [r4, #0]
    1adc:	4b18      	ldr	r3, [pc, #96]	; (1b40 <do_listen+0xb4>)
    1ade:	3010      	adds	r0, #16
    1ae0:	4798      	blx	r3
							sys_mbox_set_invalid(&msg->conn->recvmbox);
    1ae2:	6820      	ldr	r0, [r4, #0]
    1ae4:	4b17      	ldr	r3, [pc, #92]	; (1b44 <do_listen+0xb8>)
    1ae6:	3010      	adds	r0, #16
    1ae8:	4798      	blx	r3
						if (!sys_mbox_valid(&msg->conn->acceptmbox)) {
    1aea:	6820      	ldr	r0, [r4, #0]
						msg->err = ERR_OK;
    1aec:	2300      	movs	r3, #0
    1aee:	7123      	strb	r3, [r4, #4]
						if (!sys_mbox_valid(&msg->conn->acceptmbox)) {
    1af0:	3014      	adds	r0, #20
    1af2:	47b0      	blx	r6
    1af4:	b928      	cbnz	r0, 1b02 <do_listen+0x76>
							msg->err = sys_mbox_new(&msg->conn->acceptmbox, DEFAULT_ACCEPTMBOX_SIZE);
    1af6:	6820      	ldr	r0, [r4, #0]
    1af8:	4b13      	ldr	r3, [pc, #76]	; (1b48 <do_listen+0xbc>)
    1afa:	2110      	movs	r1, #16
    1afc:	3014      	adds	r0, #20
    1afe:	4798      	blx	r3
    1b00:	7120      	strb	r0, [r4, #4]
						if (msg->err == ERR_OK) {
    1b02:	f994 3004 	ldrsb.w	r3, [r4, #4]
    1b06:	b963      	cbnz	r3, 1b22 <do_listen+0x96>
							msg->conn->state   = NETCONN_LISTEN;
    1b08:	6821      	ldr	r1, [r4, #0]
    1b0a:	2302      	movs	r3, #2
    1b0c:	704b      	strb	r3, [r1, #1]
							msg->conn->pcb.tcp = lpcb;
    1b0e:	604d      	str	r5, [r1, #4]
							tcp_arg(msg->conn->pcb.tcp, msg->conn);
    1b10:	4628      	mov	r0, r5
    1b12:	4b0e      	ldr	r3, [pc, #56]	; (1b4c <do_listen+0xc0>)
    1b14:	4798      	blx	r3
							tcp_accept(msg->conn->pcb.tcp, accept_function);
    1b16:	6823      	ldr	r3, [r4, #0]
    1b18:	490d      	ldr	r1, [pc, #52]	; (1b50 <do_listen+0xc4>)
    1b1a:	6858      	ldr	r0, [r3, #4]
    1b1c:	4b0d      	ldr	r3, [pc, #52]	; (1b54 <do_listen+0xc8>)
    1b1e:	4798      	blx	r3
    1b20:	e7bd      	b.n	1a9e <do_listen+0x12>
							tcp_close(lpcb);
    1b22:	4b0d      	ldr	r3, [pc, #52]	; (1b58 <do_listen+0xcc>)
    1b24:	4628      	mov	r0, r5
    1b26:	4798      	blx	r3
							msg->conn->pcb.tcp = NULL;
    1b28:	6823      	ldr	r3, [r4, #0]
    1b2a:	2200      	movs	r2, #0
    1b2c:	605a      	str	r2, [r3, #4]
    1b2e:	e7b6      	b.n	1a9e <do_listen+0x12>
				msg->err = ERR_ARG;
    1b30:	23f2      	movs	r3, #242	; 0xf2
    1b32:	e7cb      	b.n	1acc <do_listen+0x40>
    1b34:	00006aad 	.word	0x00006aad
    1b38:	00005a25 	.word	0x00005a25
    1b3c:	00006c71 	.word	0x00006c71
    1b40:	00006b51 	.word	0x00006b51
    1b44:	00006c75 	.word	0x00006c75
    1b48:	00006b31 	.word	0x00006b31
    1b4c:	00005ba5 	.word	0x00005ba5
    1b50:	000018cd 	.word	0x000018cd
    1b54:	00005bb9 	.word	0x00005bb9
    1b58:	000060a1 	.word	0x000060a1

00001b5c <do_send>:
{
    1b5c:	b570      	push	{r4, r5, r6, lr}
	if (ERR_IS_FATAL(msg->conn->last_err)) {
    1b5e:	6803      	ldr	r3, [r0, #0]
    1b60:	f993 2008 	ldrsb.w	r2, [r3, #8]
    1b64:	f112 0f09 	cmn.w	r2, #9
{
    1b68:	4604      	mov	r4, r0
	if (ERR_IS_FATAL(msg->conn->last_err)) {
    1b6a:	da06      	bge.n	1b7a <do_send+0x1e>
		msg->err = msg->conn->last_err;
    1b6c:	7102      	strb	r2, [r0, #4]
	TCPIP_APIMSG_ACK(msg);
    1b6e:	6820      	ldr	r0, [r4, #0]
    1b70:	4b0d      	ldr	r3, [pc, #52]	; (1ba8 <do_send+0x4c>)
}
    1b72:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	TCPIP_APIMSG_ACK(msg);
    1b76:	300c      	adds	r0, #12
    1b78:	4718      	bx	r3
		msg->err = ERR_CONN;
    1b7a:	22f3      	movs	r2, #243	; 0xf3
    1b7c:	7102      	strb	r2, [r0, #4]
		if (msg->conn->pcb.tcp != NULL) {
    1b7e:	6858      	ldr	r0, [r3, #4]
    1b80:	2800      	cmp	r0, #0
    1b82:	d0f4      	beq.n	1b6e <do_send+0x12>
			switch (NETCONNTYPE_GROUP(msg->conn->type)) {
    1b84:	781b      	ldrb	r3, [r3, #0]
    1b86:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
    1b8a:	2b20      	cmp	r3, #32
    1b8c:	d1ef      	bne.n	1b6e <do_send+0x12>
				if (ip_addr_isany(&msg->msg.b->addr)) {
    1b8e:	68a2      	ldr	r2, [r4, #8]
    1b90:	6893      	ldr	r3, [r2, #8]
					msg->err = udp_send(msg->conn->pcb.udp, msg->msg.b->p);
    1b92:	6811      	ldr	r1, [r2, #0]
				if (ip_addr_isany(&msg->msg.b->addr)) {
    1b94:	b91b      	cbnz	r3, 1b9e <do_send+0x42>
					msg->err = udp_send(msg->conn->pcb.udp, msg->msg.b->p);
    1b96:	4b05      	ldr	r3, [pc, #20]	; (1bac <do_send+0x50>)
    1b98:	4798      	blx	r3
					msg->err = udp_sendto(msg->conn->pcb.udp, msg->msg.b->p, &msg->msg.b->addr, msg->msg.b->port);
    1b9a:	7120      	strb	r0, [r4, #4]
    1b9c:	e7e7      	b.n	1b6e <do_send+0x12>
    1b9e:	8993      	ldrh	r3, [r2, #12]
    1ba0:	4d03      	ldr	r5, [pc, #12]	; (1bb0 <do_send+0x54>)
    1ba2:	3208      	adds	r2, #8
    1ba4:	47a8      	blx	r5
    1ba6:	e7f8      	b.n	1b9a <do_send+0x3e>
    1ba8:	00006aad 	.word	0x00006aad
    1bac:	00004759 	.word	0x00004759
    1bb0:	00004725 	.word	0x00004725

00001bb4 <do_recv>:
	msg->err = ERR_OK;
    1bb4:	2300      	movs	r3, #0
{
    1bb6:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	msg->err = ERR_OK;
    1bba:	7103      	strb	r3, [r0, #4]
	if (msg->conn->pcb.tcp != NULL) {
    1bbc:	6803      	ldr	r3, [r0, #0]
    1bbe:	685a      	ldr	r2, [r3, #4]
{
    1bc0:	4604      	mov	r4, r0
	if (msg->conn->pcb.tcp != NULL) {
    1bc2:	b182      	cbz	r2, 1be6 <do_recv+0x32>
		if (msg->conn->type == NETCONN_TCP) {
    1bc4:	781b      	ldrb	r3, [r3, #0]
    1bc6:	2b10      	cmp	r3, #16
    1bc8:	d10d      	bne.n	1be6 <do_recv+0x32>
				u32_t remaining = msg->msg.r.len;
    1bca:	6885      	ldr	r5, [r0, #8]
					tcp_recved(msg->conn->pcb.tcp, recved);
    1bcc:	4f09      	ldr	r7, [pc, #36]	; (1bf4 <do_recv+0x40>)
    1bce:	f64f 78ff 	movw	r8, #65535	; 0xffff
					u16_t recved = (remaining > 0xffff) ? 0xffff : (u16_t)remaining;
    1bd2:	4545      	cmp	r5, r8
					tcp_recved(msg->conn->pcb.tcp, recved);
    1bd4:	6823      	ldr	r3, [r4, #0]
    1bd6:	462e      	mov	r6, r5
    1bd8:	bf28      	it	cs
    1bda:	4646      	movcs	r6, r8
    1bdc:	6858      	ldr	r0, [r3, #4]
    1bde:	b2b1      	uxth	r1, r6
    1be0:	47b8      	blx	r7
				} while (remaining != 0);
    1be2:	1bad      	subs	r5, r5, r6
    1be4:	d1f5      	bne.n	1bd2 <do_recv+0x1e>
	TCPIP_APIMSG_ACK(msg);
    1be6:	6820      	ldr	r0, [r4, #0]
    1be8:	4b03      	ldr	r3, [pc, #12]	; (1bf8 <do_recv+0x44>)
}
    1bea:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
	TCPIP_APIMSG_ACK(msg);
    1bee:	300c      	adds	r0, #12
    1bf0:	4718      	bx	r3
    1bf2:	bf00      	nop
    1bf4:	00005af9 	.word	0x00005af9
    1bf8:	00006aad 	.word	0x00006aad

00001bfc <do_write>:
 * Called from netconn_write
 *
 * @param msg the api_msg_msg pointing to the connection
 */
void do_write(struct api_msg_msg *msg)
{
    1bfc:	4603      	mov	r3, r0
	if (ERR_IS_FATAL(msg->conn->last_err)) {
    1bfe:	6800      	ldr	r0, [r0, #0]
    1c00:	f990 2008 	ldrsb.w	r2, [r0, #8]
    1c04:	f112 0f09 	cmn.w	r2, #9
    1c08:	da03      	bge.n	1c12 <do_write+0x16>
#else  /* LWIP_TCP */
			msg->err = ERR_VAL;
#endif /* LWIP_TCP */
#if (LWIP_UDP || LWIP_RAW)
		} else {
			msg->err = ERR_VAL;
    1c0a:	711a      	strb	r2, [r3, #4]
#endif /* (LWIP_UDP || LWIP_RAW) */
		}
	}
	TCPIP_APIMSG_ACK(msg);
    1c0c:	300c      	adds	r0, #12
    1c0e:	4b0a      	ldr	r3, [pc, #40]	; (1c38 <do_write+0x3c>)
    1c10:	4718      	bx	r3
		if (msg->conn->type == NETCONN_TCP) {
    1c12:	7802      	ldrb	r2, [r0, #0]
    1c14:	2a10      	cmp	r2, #16
    1c16:	d10d      	bne.n	1c34 <do_write+0x38>
			if (msg->conn->state != NETCONN_NONE) {
    1c18:	7842      	ldrb	r2, [r0, #1]
    1c1a:	b10a      	cbz	r2, 1c20 <do_write+0x24>
				msg->err = ERR_INPROGRESS;
    1c1c:	22fb      	movs	r2, #251	; 0xfb
    1c1e:	e7f4      	b.n	1c0a <do_write+0xe>
			} else if (msg->conn->pcb.tcp != NULL) {
    1c20:	6841      	ldr	r1, [r0, #4]
    1c22:	b129      	cbz	r1, 1c30 <do_write+0x34>
				msg->conn->state = NETCONN_WRITE;
    1c24:	2101      	movs	r1, #1
				msg->conn->write_offset = 0;
    1c26:	e9c0 2308 	strd	r2, r3, [r0, #32]
				msg->conn->state = NETCONN_WRITE;
    1c2a:	7041      	strb	r1, [r0, #1]
				do_writemore(msg->conn);
    1c2c:	4b03      	ldr	r3, [pc, #12]	; (1c3c <do_write+0x40>)
    1c2e:	4718      	bx	r3
				msg->err = ERR_CONN;
    1c30:	22f3      	movs	r2, #243	; 0xf3
    1c32:	e7ea      	b.n	1c0a <do_write+0xe>
			msg->err = ERR_VAL;
    1c34:	22fa      	movs	r2, #250	; 0xfa
    1c36:	e7e8      	b.n	1c0a <do_write+0xe>
    1c38:	00006aad 	.word	0x00006aad
    1c3c:	00001549 	.word	0x00001549

00001c40 <do_getaddr>:
 *
 * @param msg the api_msg_msg pointing to the connection
 */
void do_getaddr(struct api_msg_msg *msg)
{
	if (msg->conn->pcb.ip != NULL) {
    1c40:	6801      	ldr	r1, [r0, #0]
    1c42:	684b      	ldr	r3, [r1, #4]
{
    1c44:	b430      	push	{r4, r5}
	if (msg->conn->pcb.ip != NULL) {
    1c46:	b1bb      	cbz	r3, 1c78 <do_getaddr+0x38>
		*(msg->msg.ad.ipaddr) = (msg->msg.ad.local ? msg->conn->pcb.ip->local_ip : msg->conn->pcb.ip->remote_ip);
    1c48:	7c04      	ldrb	r4, [r0, #16]
    1c4a:	6882      	ldr	r2, [r0, #8]
    1c4c:	b17c      	cbz	r4, 1c6e <do_getaddr+0x2e>
    1c4e:	681d      	ldr	r5, [r3, #0]
    1c50:	6015      	str	r5, [r2, #0]

		msg->err = ERR_OK;
    1c52:	2200      	movs	r2, #0
    1c54:	7102      	strb	r2, [r0, #4]
		switch (NETCONNTYPE_GROUP(msg->conn->type)) {
    1c56:	780a      	ldrb	r2, [r1, #0]
    1c58:	f002 02f0 	and.w	r2, r2, #240	; 0xf0
    1c5c:	2a10      	cmp	r2, #16
    1c5e:	d015      	beq.n	1c8c <do_getaddr+0x4c>
    1c60:	2a20      	cmp	r2, #32
    1c62:	d10b      	bne.n	1c7c <do_getaddr+0x3c>
			}
			break;
#endif /* LWIP_RAW */
#if LWIP_UDP
		case NETCONN_UDP:
			if (msg->msg.ad.local) {
    1c64:	b12c      	cbz	r4, 1c72 <do_getaddr+0x32>
				*(msg->msg.ad.port) = msg->conn->pcb.udp->local_port;
    1c66:	68c2      	ldr	r2, [r0, #12]
    1c68:	8a5b      	ldrh	r3, [r3, #18]
			break;
#endif /* LWIP_UDP */
#if LWIP_TCP
		case NETCONN_TCP:
			*(msg->msg.ad.port)
			    = (msg->msg.ad.local ? msg->conn->pcb.tcp->local_port : msg->conn->pcb.tcp->remote_port);
    1c6a:	8013      	strh	r3, [r2, #0]
			break;
    1c6c:	e006      	b.n	1c7c <do_getaddr+0x3c>
		*(msg->msg.ad.ipaddr) = (msg->msg.ad.local ? msg->conn->pcb.ip->local_ip : msg->conn->pcb.ip->remote_ip);
    1c6e:	685d      	ldr	r5, [r3, #4]
    1c70:	e7ee      	b.n	1c50 <do_getaddr+0x10>
				if ((msg->conn->pcb.udp->flags & UDP_FLAGS_CONNECTED) == 0) {
    1c72:	7c1a      	ldrb	r2, [r3, #16]
    1c74:	0752      	lsls	r2, r2, #29
    1c76:	d406      	bmi.n	1c86 <do_getaddr+0x46>
					msg->err = ERR_CONN;
    1c78:	23f3      	movs	r3, #243	; 0xf3
    1c7a:	7103      	strb	r3, [r0, #4]
		}
	} else {
		msg->err = ERR_CONN;
	}
	TCPIP_APIMSG_ACK(msg);
}
    1c7c:	bc30      	pop	{r4, r5}
	TCPIP_APIMSG_ACK(msg);
    1c7e:	4b06      	ldr	r3, [pc, #24]	; (1c98 <do_getaddr+0x58>)
    1c80:	f101 000c 	add.w	r0, r1, #12
    1c84:	4718      	bx	r3
					*(msg->msg.ad.port) = msg->conn->pcb.udp->remote_port;
    1c86:	68c2      	ldr	r2, [r0, #12]
    1c88:	8a9b      	ldrh	r3, [r3, #20]
    1c8a:	e7ee      	b.n	1c6a <do_getaddr+0x2a>
			    = (msg->msg.ad.local ? msg->conn->pcb.tcp->local_port : msg->conn->pcb.tcp->remote_port);
    1c8c:	b114      	cbz	r4, 1c94 <do_getaddr+0x54>
    1c8e:	8b5b      	ldrh	r3, [r3, #26]
			*(msg->msg.ad.port)
    1c90:	68c2      	ldr	r2, [r0, #12]
    1c92:	e7ea      	b.n	1c6a <do_getaddr+0x2a>
			    = (msg->msg.ad.local ? msg->conn->pcb.tcp->local_port : msg->conn->pcb.tcp->remote_port);
    1c94:	8b9b      	ldrh	r3, [r3, #28]
    1c96:	e7fb      	b.n	1c90 <do_getaddr+0x50>
    1c98:	00006aad 	.word	0x00006aad

00001c9c <pvPortMalloc>:
		pxIterator->pxNextFreeBlock      = pxBlockToInsert;                                                            \
	}
/*-----------------------------------------------------------*/

void *pvPortMalloc(size_t xWantedSize)
{
    1c9c:	b570      	push	{r4, r5, r6, lr}
	BlockLink_t *     pxBlock, *pxPreviousBlock, *pxNewBlockLink;
	static BaseType_t xHeapHasBeenInitialised = pdFALSE;
	void *            pvReturn                = NULL;

	vTaskSuspendAll();
    1c9e:	4b26      	ldr	r3, [pc, #152]	; (1d38 <pvPortMalloc+0x9c>)
{
    1ca0:	4604      	mov	r4, r0
	vTaskSuspendAll();
    1ca2:	4798      	blx	r3
	{
		/* If this is the first call to malloc then the heap will require
		initialisation to setup the list of free blocks. */
		if (xHeapHasBeenInitialised == pdFALSE) {
    1ca4:	4b25      	ldr	r3, [pc, #148]	; (1d3c <pvPortMalloc+0xa0>)
    1ca6:	6898      	ldr	r0, [r3, #8]
    1ca8:	b970      	cbnz	r0, 1cc8 <pvPortMalloc+0x2c>
	xStart.pxNextFreeBlock = (void *)pucAlignedHeap;
	xStart.xBlockSize      = (size_t)0;

	/* xEnd is used to mark the end of the list of free blocks. */
	xEnd.xBlockSize      = configADJUSTED_HEAP_SIZE;
	xEnd.pxNextFreeBlock = NULL;
    1caa:	4619      	mov	r1, r3
	                             & (~((portPOINTER_SIZE_TYPE)portBYTE_ALIGNMENT_MASK)));
    1cac:	4a24      	ldr	r2, [pc, #144]	; (1d40 <pvPortMalloc+0xa4>)
	xEnd.pxNextFreeBlock = NULL;
    1cae:	f841 0f0c 	str.w	r0, [r1, #12]!
	                             & (~((portPOINTER_SIZE_TYPE)portBYTE_ALIGNMENT_MASK)));
    1cb2:	f022 0207 	bic.w	r2, r2, #7
	xEnd.xBlockSize      = configADJUSTED_HEAP_SIZE;
    1cb6:	f24a 4508 	movw	r5, #41992	; 0xa408
	xStart.xBlockSize      = (size_t)0;
    1cba:	e9c3 2000 	strd	r2, r0, [r3]

	/* To start with there is a single free block that is sized to take up the
	entire heap space. */
	pxFirstFreeBlock                  = (void *)pucAlignedHeap;
	pxFirstFreeBlock->xBlockSize      = configADJUSTED_HEAP_SIZE;
	pxFirstFreeBlock->pxNextFreeBlock = &xEnd;
    1cbe:	e9c2 1500 	strd	r1, r5, [r2]
			xHeapHasBeenInitialised = pdTRUE;
    1cc2:	2201      	movs	r2, #1
	xEnd.xBlockSize      = configADJUSTED_HEAP_SIZE;
    1cc4:	611d      	str	r5, [r3, #16]
			xHeapHasBeenInitialised = pdTRUE;
    1cc6:	609a      	str	r2, [r3, #8]
		if (xWantedSize > 0) {
    1cc8:	b12c      	cbz	r4, 1cd6 <pvPortMalloc+0x3a>
			xWantedSize += heapSTRUCT_SIZE;
    1cca:	3408      	adds	r4, #8
			if ((xWantedSize & portBYTE_ALIGNMENT_MASK) != 0) {
    1ccc:	0762      	lsls	r2, r4, #29
				xWantedSize += (portBYTE_ALIGNMENT - (xWantedSize & portBYTE_ALIGNMENT_MASK));
    1cce:	bf1c      	itt	ne
    1cd0:	f024 0407 	bicne.w	r4, r4, #7
    1cd4:	3408      	addne	r4, #8
		if ((xWantedSize > 0) && (xWantedSize < configADJUSTED_HEAP_SIZE)) {
    1cd6:	1e61      	subs	r1, r4, #1
    1cd8:	f24a 4206 	movw	r2, #41990	; 0xa406
    1cdc:	4291      	cmp	r1, r2
    1cde:	d829      	bhi.n	1d34 <pvPortMalloc+0x98>
			pxBlock         = xStart.pxNextFreeBlock;
    1ce0:	681b      	ldr	r3, [r3, #0]
			pxPreviousBlock = &xStart;
    1ce2:	4816      	ldr	r0, [pc, #88]	; (1d3c <pvPortMalloc+0xa0>)
			while ((pxBlock->xBlockSize < xWantedSize) && (pxBlock->pxNextFreeBlock != NULL)) {
    1ce4:	6859      	ldr	r1, [r3, #4]
    1ce6:	42a1      	cmp	r1, r4
    1ce8:	d201      	bcs.n	1cee <pvPortMalloc+0x52>
    1cea:	681a      	ldr	r2, [r3, #0]
    1cec:	b9fa      	cbnz	r2, 1d2e <pvPortMalloc+0x92>
			if (pxBlock != &xEnd) {
    1cee:	4a15      	ldr	r2, [pc, #84]	; (1d44 <pvPortMalloc+0xa8>)
    1cf0:	4293      	cmp	r3, r2
    1cf2:	d01f      	beq.n	1d34 <pvPortMalloc+0x98>
				pvReturn = (void *)(((uint8_t *)pxPreviousBlock->pxNextFreeBlock) + heapSTRUCT_SIZE);
    1cf4:	6805      	ldr	r5, [r0, #0]
				pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;
    1cf6:	681e      	ldr	r6, [r3, #0]
    1cf8:	6006      	str	r6, [r0, #0]
				if ((pxBlock->xBlockSize - xWantedSize) > heapMINIMUM_BLOCK_SIZE) {
    1cfa:	1b09      	subs	r1, r1, r4
    1cfc:	2910      	cmp	r1, #16
				pvReturn = (void *)(((uint8_t *)pxPreviousBlock->pxNextFreeBlock) + heapSTRUCT_SIZE);
    1cfe:	f105 0508 	add.w	r5, r5, #8
				if ((pxBlock->xBlockSize - xWantedSize) > heapMINIMUM_BLOCK_SIZE) {
    1d02:	d90b      	bls.n	1d1c <pvPortMalloc+0x80>
					pxNewBlockLink = (void *)(((uint8_t *)pxBlock) + xWantedSize);
    1d04:	1918      	adds	r0, r3, r4
					prvInsertBlockIntoFreeList((pxNewBlockLink));
    1d06:	3a0c      	subs	r2, #12
					pxNewBlockLink->xBlockSize = pxBlock->xBlockSize - xWantedSize;
    1d08:	6041      	str	r1, [r0, #4]
					pxBlock->xBlockSize        = xWantedSize;
    1d0a:	605c      	str	r4, [r3, #4]
					prvInsertBlockIntoFreeList((pxNewBlockLink));
    1d0c:	6844      	ldr	r4, [r0, #4]
    1d0e:	4611      	mov	r1, r2
    1d10:	6812      	ldr	r2, [r2, #0]
    1d12:	6856      	ldr	r6, [r2, #4]
    1d14:	42a6      	cmp	r6, r4
    1d16:	d3fa      	bcc.n	1d0e <pvPortMalloc+0x72>
    1d18:	6002      	str	r2, [r0, #0]
    1d1a:	6008      	str	r0, [r1, #0]
				xFreeBytesRemaining -= pxBlock->xBlockSize;
    1d1c:	490a      	ldr	r1, [pc, #40]	; (1d48 <pvPortMalloc+0xac>)
    1d1e:	685b      	ldr	r3, [r3, #4]
    1d20:	680a      	ldr	r2, [r1, #0]
    1d22:	1ad2      	subs	r2, r2, r3
    1d24:	600a      	str	r2, [r1, #0]
	(void)xTaskResumeAll();
    1d26:	4b09      	ldr	r3, [pc, #36]	; (1d4c <pvPortMalloc+0xb0>)
    1d28:	4798      	blx	r3
}
    1d2a:	4628      	mov	r0, r5
    1d2c:	bd70      	pop	{r4, r5, r6, pc}
    1d2e:	4618      	mov	r0, r3
    1d30:	4613      	mov	r3, r2
    1d32:	e7d7      	b.n	1ce4 <pvPortMalloc+0x48>
	void *            pvReturn                = NULL;
    1d34:	2500      	movs	r5, #0
    1d36:	e7f6      	b.n	1d26 <pvPortMalloc+0x8a>
    1d38:	00007f25 	.word	0x00007f25
    1d3c:	200000b4 	.word	0x200000b4
    1d40:	200000d0 	.word	0x200000d0
    1d44:	200000c0 	.word	0x200000c0
    1d48:	20000000 	.word	0x20000000
    1d4c:	00008039 	.word	0x00008039

00001d50 <vPortFree>:
{
    1d50:	b570      	push	{r4, r5, r6, lr}
	if (pv != NULL) {
    1d52:	4604      	mov	r4, r0
    1d54:	b1b0      	cbz	r0, 1d84 <vPortFree+0x34>
		vTaskSuspendAll();
    1d56:	4b0c      	ldr	r3, [pc, #48]	; (1d88 <vPortFree+0x38>)
		puc -= heapSTRUCT_SIZE;
    1d58:	f1a0 0508 	sub.w	r5, r0, #8
		vTaskSuspendAll();
    1d5c:	4798      	blx	r3
			prvInsertBlockIntoFreeList(((BlockLink_t *)pxLink));
    1d5e:	f854 1c04 	ldr.w	r1, [r4, #-4]
    1d62:	4b0a      	ldr	r3, [pc, #40]	; (1d8c <vPortFree+0x3c>)
    1d64:	461a      	mov	r2, r3
    1d66:	681b      	ldr	r3, [r3, #0]
    1d68:	6858      	ldr	r0, [r3, #4]
    1d6a:	4288      	cmp	r0, r1
    1d6c:	d3fa      	bcc.n	1d64 <vPortFree+0x14>
    1d6e:	f844 3c08 	str.w	r3, [r4, #-8]
    1d72:	6015      	str	r5, [r2, #0]
			xFreeBytesRemaining += pxLink->xBlockSize;
    1d74:	4a06      	ldr	r2, [pc, #24]	; (1d90 <vPortFree+0x40>)
    1d76:	6813      	ldr	r3, [r2, #0]
    1d78:	440b      	add	r3, r1
    1d7a:	6013      	str	r3, [r2, #0]
}
    1d7c:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		(void)xTaskResumeAll();
    1d80:	4b04      	ldr	r3, [pc, #16]	; (1d94 <vPortFree+0x44>)
    1d82:	4718      	bx	r3
}
    1d84:	bd70      	pop	{r4, r5, r6, pc}
    1d86:	bf00      	nop
    1d88:	00007f25 	.word	0x00007f25
    1d8c:	200000b4 	.word	0x200000b4
    1d90:	20000000 	.word	0x20000000
    1d94:	00008039 	.word	0x00008039

00001d98 <vListInitialise>:
void vListInitialise(List_t *const pxList)
{
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = (ListItem_t *)&(
    1d98:	f100 0308 	add.w	r3, r0, #8
	    pxList->xListEnd); /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is
	                          checked and valid. */

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
    1d9c:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = (ListItem_t *)&(pxList->xListEnd); /*lint !e826 !e740 The mini list structure is used as
    1da0:	e9c0 2302 	strd	r2, r3, [r0, #8]
	pxList->pxIndex = (ListItem_t *)&(
    1da4:	6043      	str	r3, [r0, #4]
	                                                                the list end to save RAM.  This is checked and
	                                                                valid. */
	pxList->xListEnd.pxPrevious = (ListItem_t *)&(
    1da6:	6103      	str	r3, [r0, #16]
	    pxList->xListEnd); /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is
	                          checked and valid. */

	pxList->uxNumberOfItems = (UBaseType_t)0U;
    1da8:	2300      	movs	r3, #0
    1daa:	6003      	str	r3, [r0, #0]

	/* Write known values into the list if
	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
	listSET_LIST_INTEGRITY_CHECK_1_VALUE(pxList);
	listSET_LIST_INTEGRITY_CHECK_2_VALUE(pxList);
}
    1dac:	4770      	bx	lr

00001dae <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem(ListItem_t *const pxItem)
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
    1dae:	2300      	movs	r3, #0
    1db0:	6103      	str	r3, [r0, #16]

	/* Write known values into the list item if
	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
	listSET_FIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE(pxItem);
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE(pxItem);
}
    1db2:	4770      	bx	lr

00001db4 <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd(List_t *const pxList, ListItem_t *const pxNewListItem)
{
	ListItem_t *const pxIndex = pxList->pxIndex;
    1db4:	6843      	ldr	r3, [r0, #4]
	listTEST_LIST_ITEM_INTEGRITY(pxNewListItem);

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext     = pxIndex;
    1db6:	604b      	str	r3, [r1, #4]
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
    1db8:	689a      	ldr	r2, [r3, #8]
    1dba:	608a      	str	r2, [r1, #8]

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
    1dbc:	689a      	ldr	r2, [r3, #8]
    1dbe:	6051      	str	r1, [r2, #4]
	pxIndex->pxPrevious         = pxNewListItem;
    1dc0:	6099      	str	r1, [r3, #8]

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = (void *)pxList;

	(pxList->uxNumberOfItems)++;
    1dc2:	6803      	ldr	r3, [r0, #0]
	pxNewListItem->pvContainer = (void *)pxList;
    1dc4:	6108      	str	r0, [r1, #16]
	(pxList->uxNumberOfItems)++;
    1dc6:	3301      	adds	r3, #1
    1dc8:	6003      	str	r3, [r0, #0]
}
    1dca:	4770      	bx	lr

00001dcc <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert(List_t *const pxList, ListItem_t *const pxNewListItem)
{
    1dcc:	b530      	push	{r4, r5, lr}
	ListItem_t *     pxIterator;
	const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
    1dce:	680c      	ldr	r4, [r1, #0]
	new list item should be placed after it.  This ensures that TCB's which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if (xValueOfInsertion == portMAX_DELAY) {
    1dd0:	1c63      	adds	r3, r4, #1
    1dd2:	d10a      	bne.n	1dea <vListInsert+0x1e>
		pxIterator = pxList->xListEnd.pxPrevious;
    1dd4:	6903      	ldr	r3, [r0, #16]
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext             = pxIterator->pxNext;
    1dd6:	685a      	ldr	r2, [r3, #4]
    1dd8:	604a      	str	r2, [r1, #4]
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
    1dda:	6091      	str	r1, [r2, #8]
	pxNewListItem->pxPrevious         = pxIterator;
    1ddc:	608b      	str	r3, [r1, #8]
	pxIterator->pxNext                = pxNewListItem;
    1dde:	6059      	str	r1, [r3, #4]

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = (void *)pxList;

	(pxList->uxNumberOfItems)++;
    1de0:	6803      	ldr	r3, [r0, #0]
	pxNewListItem->pvContainer = (void *)pxList;
    1de2:	6108      	str	r0, [r1, #16]
	(pxList->uxNumberOfItems)++;
    1de4:	3301      	adds	r3, #1
    1de6:	6003      	str	r3, [r0, #0]
}
    1de8:	bd30      	pop	{r4, r5, pc}
		for (pxIterator = (ListItem_t *)&(pxList->xListEnd); pxIterator->pxNext->xItemValue <= xValueOfInsertion;
    1dea:	f100 0208 	add.w	r2, r0, #8
    1dee:	4613      	mov	r3, r2
    1df0:	6852      	ldr	r2, [r2, #4]
    1df2:	6815      	ldr	r5, [r2, #0]
    1df4:	42a5      	cmp	r5, r4
    1df6:	d9fa      	bls.n	1dee <vListInsert+0x22>
    1df8:	e7ed      	b.n	1dd6 <vListInsert+0xa>

00001dfa <uxListRemove>:
{
	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	List_t *const pxList = (List_t *)pxItemToRemove->pvContainer;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    1dfa:	e9d0 1201 	ldrd	r1, r2, [r0, #4]
	List_t *const pxList = (List_t *)pxItemToRemove->pvContainer;
    1dfe:	6903      	ldr	r3, [r0, #16]
	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    1e00:	608a      	str	r2, [r1, #8]
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    1e02:	6051      	str	r1, [r2, #4]

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if (pxList->pxIndex == pxItemToRemove) {
    1e04:	6859      	ldr	r1, [r3, #4]
    1e06:	4281      	cmp	r1, r0
		pxList->pxIndex = pxItemToRemove->pxPrevious;
    1e08:	bf08      	it	eq
    1e0a:	605a      	streq	r2, [r3, #4]
	} else {
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
    1e0c:	2200      	movs	r2, #0
    1e0e:	6102      	str	r2, [r0, #16]
	(pxList->uxNumberOfItems)--;
    1e10:	6818      	ldr	r0, [r3, #0]
    1e12:	3801      	subs	r0, #1
    1e14:	6018      	str	r0, [r3, #0]

	return pxList->uxNumberOfItems;
}
    1e16:	4770      	bx	lr

00001e18 <tcp_pbuf_prealloc>:
 * @param
 */
#if TCP_OVERSIZE
static struct pbuf *tcp_pbuf_prealloc(pbuf_layer layer, u16_t length, u16_t max_length, u16_t *oversize,
                                      struct tcp_pcb *pcb, u8_t apiflags, u8_t first_seg)
{
    1e18:	b570      	push	{r4, r5, r6, lr}
    1e1a:	460c      	mov	r4, r1
	LWIP_UNUSED_ARG(apiflags);
	LWIP_UNUSED_ARG(first_seg);
	/* always create MSS-sized pbufs */
	alloc = max_length;
#else  /* LWIP_NETIF_TX_SINGLE_PBUF */
	if (length < max_length) {
    1e1c:	4294      	cmp	r4, r2
{
    1e1e:	461e      	mov	r6, r3
    1e20:	f89d 1018 	ldrb.w	r1, [sp, #24]
    1e24:	9b04      	ldr	r3, [sp, #16]
	if (length < max_length) {
    1e26:	d21d      	bcs.n	1e64 <tcp_pbuf_prealloc+0x4c>
		 *
		 * Did the user set TCP_WRITE_FLAG_MORE?
		 *
		 * Will the Nagle algorithm defer transmission of this segment?
		 */
		if ((apiflags & TCP_WRITE_FLAG_MORE)
    1e28:	f89d 5014 	ldrb.w	r5, [sp, #20]
    1e2c:	07ad      	lsls	r5, r5, #30
    1e2e:	d407      	bmi.n	1e40 <tcp_pbuf_prealloc+0x28>
		    || (!(pcb->flags & TF_NODELAY) && (!first_seg || pcb->unsent != NULL || pcb->unacked != NULL))) {
    1e30:	7f9d      	ldrb	r5, [r3, #30]
    1e32:	066d      	lsls	r5, r5, #25
    1e34:	d416      	bmi.n	1e64 <tcp_pbuf_prealloc+0x4c>
    1e36:	b119      	cbz	r1, 1e40 <tcp_pbuf_prealloc+0x28>
    1e38:	6ed9      	ldr	r1, [r3, #108]	; 0x6c
    1e3a:	b909      	cbnz	r1, 1e40 <tcp_pbuf_prealloc+0x28>
    1e3c:	6f1b      	ldr	r3, [r3, #112]	; 0x70
    1e3e:	b18b      	cbz	r3, 1e64 <tcp_pbuf_prealloc+0x4c>
			alloc = LWIP_MIN(max_length, LWIP_MEM_ALIGN_SIZE(length + TCP_OVERSIZE));
    1e40:	f204 55b7 	addw	r5, r4, #1463	; 0x5b7
    1e44:	f025 0103 	bic.w	r1, r5, #3
    1e48:	428a      	cmp	r2, r1
    1e4a:	bfa8      	it	ge
    1e4c:	460a      	movge	r2, r1
    1e4e:	b291      	uxth	r1, r2
		}
	}
#endif /* LWIP_NETIF_TX_SINGLE_PBUF */
	p = pbuf_alloc(layer, alloc, PBUF_RAM);
    1e50:	4b05      	ldr	r3, [pc, #20]	; (1e68 <tcp_pbuf_prealloc+0x50>)
    1e52:	2200      	movs	r2, #0
    1e54:	4798      	blx	r3
	if (p == NULL) {
    1e56:	b120      	cbz	r0, 1e62 <tcp_pbuf_prealloc+0x4a>
		return NULL;
	}
	LWIP_ASSERT("need unchained pbuf", p->next == NULL);
	*oversize = p->len - length;
    1e58:	8943      	ldrh	r3, [r0, #10]
    1e5a:	1b1b      	subs	r3, r3, r4
    1e5c:	8033      	strh	r3, [r6, #0]
	/* trim p->len to the currently used size */
	p->len = p->tot_len = length;
    1e5e:	8104      	strh	r4, [r0, #8]
    1e60:	8144      	strh	r4, [r0, #10]
	return p;
}
    1e62:	bd70      	pop	{r4, r5, r6, pc}
    1e64:	4621      	mov	r1, r4
    1e66:	e7f3      	b.n	1e50 <tcp_pbuf_prealloc+0x38>
    1e68:	000030d9 	.word	0x000030d9

00001e6c <tcp_create_segment>:
{
    1e6c:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    1e70:	4680      	mov	r8, r0
    1e72:	469a      	mov	sl, r3
	if ((seg = (struct tcp_seg *)memp_malloc(MEMP_TCP_SEG)) == NULL) {
    1e74:	2003      	movs	r0, #3
    1e76:	4b28      	ldr	r3, [pc, #160]	; (1f18 <tcp_create_segment+0xac>)
{
    1e78:	f89d 9028 	ldrb.w	r9, [sp, #40]	; 0x28
    1e7c:	460e      	mov	r6, r1
    1e7e:	4617      	mov	r7, r2
	if ((seg = (struct tcp_seg *)memp_malloc(MEMP_TCP_SEG)) == NULL) {
    1e80:	4798      	blx	r3
	u8_t            optlen = LWIP_TCP_OPT_LENGTH(optflags);
    1e82:	ea4f 0b89 	mov.w	fp, r9, lsl #2
    1e86:	fa5f f58b 	uxtb.w	r5, fp
	if ((seg = (struct tcp_seg *)memp_malloc(MEMP_TCP_SEG)) == NULL) {
    1e8a:	4604      	mov	r4, r0
    1e8c:	b928      	cbnz	r0, 1e9a <tcp_create_segment+0x2e>
		pbuf_free(p);
    1e8e:	4b23      	ldr	r3, [pc, #140]	; (1f1c <tcp_create_segment+0xb0>)
    1e90:	4630      	mov	r0, r6
    1e92:	4798      	blx	r3
}
    1e94:	4620      	mov	r0, r4
    1e96:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
	seg->flags = optflags;
    1e9a:	f880 900a 	strb.w	r9, [r0, #10]
	seg->len   = p->tot_len - optlen;
    1e9e:	8933      	ldrh	r3, [r6, #8]
	seg->next  = NULL;
    1ea0:	f04f 0900 	mov.w	r9, #0
	seg->len   = p->tot_len - optlen;
    1ea4:	eba3 030b 	sub.w	r3, r3, fp
	seg->p     = p;
    1ea8:	e9c0 9600 	strd	r9, r6, [r0]
	seg->len   = p->tot_len - optlen;
    1eac:	8103      	strh	r3, [r0, #8]
	if (pbuf_header(p, TCP_HLEN)) {
    1eae:	2114      	movs	r1, #20
    1eb0:	4630      	mov	r0, r6
    1eb2:	4b1b      	ldr	r3, [pc, #108]	; (1f20 <tcp_create_segment+0xb4>)
    1eb4:	4798      	blx	r3
    1eb6:	4606      	mov	r6, r0
    1eb8:	b120      	cbz	r0, 1ec4 <tcp_create_segment+0x58>
		tcp_seg_free(seg);
    1eba:	4620      	mov	r0, r4
    1ebc:	4b19      	ldr	r3, [pc, #100]	; (1f24 <tcp_create_segment+0xb8>)
    1ebe:	4798      	blx	r3
		return NULL;
    1ec0:	464c      	mov	r4, r9
    1ec2:	e7e7      	b.n	1e94 <tcp_create_segment+0x28>
	seg->tcphdr        = (struct tcp_hdr *)seg->p->payload;
    1ec4:	6863      	ldr	r3, [r4, #4]
	seg->tcphdr->src   = htons(pcb->local_port);
    1ec6:	f8df 9064 	ldr.w	r9, [pc, #100]	; 1f2c <tcp_create_segment+0xc0>
	seg->tcphdr        = (struct tcp_hdr *)seg->p->payload;
    1eca:	f8d3 b004 	ldr.w	fp, [r3, #4]
	seg->tcphdr->src   = htons(pcb->local_port);
    1ece:	f8b8 001a 	ldrh.w	r0, [r8, #26]
	seg->tcphdr        = (struct tcp_hdr *)seg->p->payload;
    1ed2:	f8c4 b00c 	str.w	fp, [r4, #12]
	seg->tcphdr->src   = htons(pcb->local_port);
    1ed6:	47c8      	blx	r9
    1ed8:	f8ab 0000 	strh.w	r0, [fp]
	seg->tcphdr->dest  = htons(pcb->remote_port);
    1edc:	f8b8 001c 	ldrh.w	r0, [r8, #28]
    1ee0:	f8d4 b00c 	ldr.w	fp, [r4, #12]
    1ee4:	47c8      	blx	r9
	seg->tcphdr->seqno = htonl(seqno);
    1ee6:	4b10      	ldr	r3, [pc, #64]	; (1f28 <tcp_create_segment+0xbc>)
	seg->tcphdr->dest  = htons(pcb->remote_port);
    1ee8:	f8ab 0002 	strh.w	r0, [fp, #2]
	seg->tcphdr->seqno = htonl(seqno);
    1eec:	4650      	mov	r0, sl
    1eee:	f8d4 800c 	ldr.w	r8, [r4, #12]
	TCPH_HDRLEN_FLAGS_SET(seg->tcphdr, (5 + optlen / 4), flags);
    1ef2:	02ad      	lsls	r5, r5, #10
	seg->tcphdr->seqno = htonl(seqno);
    1ef4:	4798      	blx	r3
	TCPH_HDRLEN_FLAGS_SET(seg->tcphdr, (5 + optlen / 4), flags);
    1ef6:	f505 45a0 	add.w	r5, r5, #20480	; 0x5000
    1efa:	f405 4570 	and.w	r5, r5, #61440	; 0xf000
	seg->tcphdr->seqno = htonl(seqno);
    1efe:	f8c8 0004 	str.w	r0, [r8, #4]
	TCPH_HDRLEN_FLAGS_SET(seg->tcphdr, (5 + optlen / 4), flags);
    1f02:	ea45 0007 	orr.w	r0, r5, r7
    1f06:	f8d4 800c 	ldr.w	r8, [r4, #12]
    1f0a:	47c8      	blx	r9
	seg->tcphdr->urgp = 0;
    1f0c:	68e3      	ldr	r3, [r4, #12]
	TCPH_HDRLEN_FLAGS_SET(seg->tcphdr, (5 + optlen / 4), flags);
    1f0e:	f8a8 000c 	strh.w	r0, [r8, #12]
	seg->tcphdr->urgp = 0;
    1f12:	749e      	strb	r6, [r3, #18]
    1f14:	74de      	strb	r6, [r3, #19]
	return seg;
    1f16:	e7bd      	b.n	1e94 <tcp_create_segment+0x28>
    1f18:	00004b2d 	.word	0x00004b2d
    1f1c:	00003081 	.word	0x00003081
    1f20:	00003029 	.word	0x00003029
    1f24:	00005b39 	.word	0x00005b39
    1f28:	00000d71 	.word	0x00000d71
    1f2c:	00000d65 	.word	0x00000d65

00001f30 <tcp_output_alloc_header.constprop.0>:
	struct pbuf *   p = pbuf_alloc(PBUF_IP, TCP_HLEN + optlen + datalen, PBUF_RAM);
    1f30:	3114      	adds	r1, #20
static struct pbuf *tcp_output_alloc_header(struct tcp_pcb *pcb, u16_t optlen, u16_t datalen,
    1f32:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	struct pbuf *   p = pbuf_alloc(PBUF_IP, TCP_HLEN + optlen + datalen, PBUF_RAM);
    1f36:	4b15      	ldr	r3, [pc, #84]	; (1f8c <tcp_output_alloc_header.constprop.0+0x5c>)
static struct pbuf *tcp_output_alloc_header(struct tcp_pcb *pcb, u16_t optlen, u16_t datalen,
    1f38:	4605      	mov	r5, r0
    1f3a:	4690      	mov	r8, r2
	struct pbuf *   p = pbuf_alloc(PBUF_IP, TCP_HLEN + optlen + datalen, PBUF_RAM);
    1f3c:	b289      	uxth	r1, r1
    1f3e:	2200      	movs	r2, #0
    1f40:	2001      	movs	r0, #1
    1f42:	4798      	blx	r3
	if (p != NULL) {
    1f44:	4606      	mov	r6, r0
    1f46:	b1e8      	cbz	r0, 1f84 <tcp_output_alloc_header.constprop.0+0x54>
		tcphdr        = (struct tcp_hdr *)p->payload;
    1f48:	6844      	ldr	r4, [r0, #4]
		tcphdr->src   = htons(pcb->local_port);
    1f4a:	4f11      	ldr	r7, [pc, #68]	; (1f90 <tcp_output_alloc_header.constprop.0+0x60>)
    1f4c:	8b68      	ldrh	r0, [r5, #26]
    1f4e:	47b8      	blx	r7
    1f50:	8020      	strh	r0, [r4, #0]
		tcphdr->dest  = htons(pcb->remote_port);
    1f52:	8ba8      	ldrh	r0, [r5, #28]
    1f54:	47b8      	blx	r7
		tcphdr->ackno = htonl(pcb->rcv_nxt);
    1f56:	4b0f      	ldr	r3, [pc, #60]	; (1f94 <tcp_output_alloc_header.constprop.0+0x64>)
		tcphdr->dest  = htons(pcb->remote_port);
    1f58:	8060      	strh	r0, [r4, #2]
		tcphdr->seqno = seqno_be;
    1f5a:	f8c4 8004 	str.w	r8, [r4, #4]
		tcphdr->ackno = htonl(pcb->rcv_nxt);
    1f5e:	6aa8      	ldr	r0, [r5, #40]	; 0x28
    1f60:	4798      	blx	r3
    1f62:	60a0      	str	r0, [r4, #8]
		TCPH_HDRLEN_FLAGS_SET(tcphdr, (5 + optlen / 4), TCP_ACK);
    1f64:	f245 0010 	movw	r0, #20496	; 0x5010
    1f68:	47b8      	blx	r7
    1f6a:	81a0      	strh	r0, [r4, #12]
		tcphdr->wnd    = htons(pcb->rcv_ann_wnd);
    1f6c:	8de8      	ldrh	r0, [r5, #46]	; 0x2e
    1f6e:	47b8      	blx	r7
		tcphdr->chksum = 0;
    1f70:	2300      	movs	r3, #0
    1f72:	7423      	strb	r3, [r4, #16]
    1f74:	7463      	strb	r3, [r4, #17]
		tcphdr->urgp   = 0;
    1f76:	74a3      	strb	r3, [r4, #18]
    1f78:	74e3      	strb	r3, [r4, #19]
		pcb->rcv_ann_right_edge = pcb->rcv_nxt + pcb->rcv_ann_wnd;
    1f7a:	8dea      	ldrh	r2, [r5, #46]	; 0x2e
    1f7c:	6aab      	ldr	r3, [r5, #40]	; 0x28
		tcphdr->wnd    = htons(pcb->rcv_ann_wnd);
    1f7e:	81e0      	strh	r0, [r4, #14]
		pcb->rcv_ann_right_edge = pcb->rcv_nxt + pcb->rcv_ann_wnd;
    1f80:	4413      	add	r3, r2
    1f82:	632b      	str	r3, [r5, #48]	; 0x30
}
    1f84:	4630      	mov	r0, r6
    1f86:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    1f8a:	bf00      	nop
    1f8c:	000030d9 	.word	0x000030d9
    1f90:	00000d65 	.word	0x00000d65
    1f94:	00000d71 	.word	0x00000d71

00001f98 <tcp_write>:
 * - TCP_WRITE_FLAG_COPY (0x01) data will be copied into memory belonging to the stack
 * - TCP_WRITE_FLAG_MORE (0x02) for TCP connection, PSH flag will be set on last segment sent,
 * @return ERR_OK if enqueued, another err_t on error
 */
err_t tcp_write(struct tcp_pcb *pcb, const void *arg, u16_t len, u8_t apiflags)
{
    1f98:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    1f9c:	ed2d 8b02 	vpush	{d8}
    1fa0:	b08d      	sub	sp, #52	; 0x34
    1fa2:	4604      	mov	r4, r0
    1fa4:	9306      	str	r3, [sp, #24]
	u16_t           pos = 0; /* position in 'arg' data */
	u16_t           queuelen;
	u8_t            optlen   = 0;
	u8_t            optflags = 0;
#if TCP_OVERSIZE
	u16_t oversize      = 0;
    1fa6:	2300      	movs	r3, #0
{
    1fa8:	4617      	mov	r7, r2
	u16_t oversize      = 0;
    1faa:	f8ad 302e 	strh.w	r3, [sp, #46]	; 0x2e
#endif /* LWIP_NETIF_TX_SINGLE_PBUF */

	LWIP_DEBUGF(
	    TCP_OUTPUT_DEBUG,
	    ("tcp_write(pcb=%p, data=%p, len=%" U16_F ", apiflags=%" U16_F ")\n", (void *)pcb, arg, len, (u16_t)apiflags));
	LWIP_ERROR("tcp_write: arg == NULL (programmer violates API)", arg != NULL, return ERR_ARG;);
    1fae:	9105      	str	r1, [sp, #20]
    1fb0:	b901      	cbnz	r1, 1fb4 <tcp_write+0x1c>
    1fb2:	e7fe      	b.n	1fb2 <tcp_write+0x1a>
	if ((pcb->state != ESTABLISHED) && (pcb->state != CLOSE_WAIT) && (pcb->state != SYN_SENT)
    1fb4:	7e03      	ldrb	r3, [r0, #24]
    1fb6:	2b07      	cmp	r3, #7
    1fb8:	d003      	beq.n	1fc2 <tcp_write+0x2a>
    1fba:	3b02      	subs	r3, #2
    1fbc:	2b02      	cmp	r3, #2
    1fbe:	f200 8172 	bhi.w	22a6 <tcp_write+0x30e>
	} else if (len == 0) {
    1fc2:	b177      	cbz	r7, 1fe2 <tcp_write+0x4a>
	if (len > pcb->snd_buf) {
    1fc4:	f8b4 3066 	ldrh.w	r3, [r4, #102]	; 0x66
    1fc8:	42bb      	cmp	r3, r7
    1fca:	d206      	bcs.n	1fda <tcp_write+0x42>
		pcb->flags |= TF_NAGLEMEMERR;
    1fcc:	7fa3      	ldrb	r3, [r4, #30]
    1fce:	f063 037f 	orn	r3, r3, #127	; 0x7f
    1fd2:	77a3      	strb	r3, [r4, #30]
	}
	if (pcb->snd_queuelen != 0) {
		LWIP_ASSERT("tcp_write: valid queue length", pcb->unacked != NULL || pcb->unsent != NULL);
	}
	LWIP_DEBUGF(TCP_QLEN_DEBUG | LWIP_DBG_STATE, ("tcp_write: %" S16_F " (with mem err)\n", pcb->snd_queuelen));
	return ERR_MEM;
    1fd4:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    1fd8:	e167      	b.n	22aa <tcp_write+0x312>
	if ((pcb->snd_queuelen >= TCP_SND_QUEUELEN) || (pcb->snd_queuelen > TCP_SNDQUEUELEN_OVERFLOW)) {
    1fda:	f8b4 3068 	ldrh.w	r3, [r4, #104]	; 0x68
    1fde:	2b07      	cmp	r3, #7
    1fe0:	d8f4      	bhi.n	1fcc <tcp_write+0x34>
	u16_t mss_local = LWIP_MIN(pcb->mss, pcb->snd_wnd_max / 2);
    1fe2:	f8b4 3062 	ldrh.w	r3, [r4, #98]	; 0x62
    1fe6:	8ee2      	ldrh	r2, [r4, #54]	; 0x36
	if (pcb->unsent != NULL) {
    1fe8:	f8d4 806c 	ldr.w	r8, [r4, #108]	; 0x6c
	u16_t mss_local = LWIP_MIN(pcb->mss, pcb->snd_wnd_max / 2);
    1fec:	085b      	lsrs	r3, r3, #1
    1fee:	4293      	cmp	r3, r2
    1ff0:	bf28      	it	cs
    1ff2:	4613      	movcs	r3, r2
    1ff4:	9307      	str	r3, [sp, #28]
	queuelen = pcb->snd_queuelen;
    1ff6:	f8b4 3068 	ldrh.w	r3, [r4, #104]	; 0x68
    1ffa:	9304      	str	r3, [sp, #16]
	if (pcb->unsent != NULL) {
    1ffc:	f1b8 0f00 	cmp.w	r8, #0
    2000:	d105      	bne.n	200e <tcp_write+0x76>
	struct tcp_seg *last_unsent = NULL, *seg = NULL, *prev_seg = NULL, *queue = NULL;
    2002:	46c2      	mov	sl, r8
	struct pbuf *   concat_p    = NULL;
    2004:	46c1      	mov	r9, r8
	u16_t oversize_used = 0;
    2006:	4645      	mov	r5, r8
	u16_t           pos = 0; /* position in 'arg' data */
    2008:	4646      	mov	r6, r8
    200a:	e05a      	b.n	20c2 <tcp_write+0x12a>
    200c:	46c8      	mov	r8, r9
		for (last_unsent = pcb->unsent; last_unsent->next != NULL; last_unsent = last_unsent->next)
    200e:	f8d8 9000 	ldr.w	r9, [r8]
    2012:	46c2      	mov	sl, r8
    2014:	f1b9 0f00 	cmp.w	r9, #0
    2018:	d1f8      	bne.n	200c <tcp_write+0x74>
		unsent_optlen = LWIP_TCP_OPT_LENGTH(last_unsent->flags);
    201a:	f898 300a 	ldrb.w	r3, [r8, #10]
		oversize = pcb->unsent_oversize;
    201e:	f8b4 506a 	ldrh.w	r5, [r4, #106]	; 0x6a
		unsent_optlen = LWIP_TCP_OPT_LENGTH(last_unsent->flags);
    2022:	009a      	lsls	r2, r3, #2
    2024:	f013 0f02 	tst.w	r3, #2
    2028:	f002 0104 	and.w	r1, r2, #4
		space         = mss_local - (last_unsent->len + unsent_optlen);
    202c:	f8b8 3008 	ldrh.w	r3, [r8, #8]
    2030:	9a07      	ldr	r2, [sp, #28]
    2032:	eba2 0203 	sub.w	r2, r2, r3
		unsent_optlen = LWIP_TCP_OPT_LENGTH(last_unsent->flags);
    2036:	bf14      	ite	ne
    2038:	200c      	movne	r0, #12
    203a:	2000      	moveq	r0, #0
		space         = mss_local - (last_unsent->len + unsent_optlen);
    203c:	1a52      	subs	r2, r2, r1
    203e:	1a12      	subs	r2, r2, r0
    2040:	b292      	uxth	r2, r2
		if (oversize > 0) {
    2042:	2d00      	cmp	r5, #0
    2044:	d047      	beq.n	20d6 <tcp_write+0x13e>
			oversize_used = oversize < len ? oversize : len;
    2046:	42bd      	cmp	r5, r7
    2048:	4629      	mov	r1, r5
    204a:	bf28      	it	cs
    204c:	4639      	movcs	r1, r7
			oversize -= oversize_used;
    204e:	1a6d      	subs	r5, r5, r1
			space -= oversize_used;
    2050:	1a52      	subs	r2, r2, r1
			oversize -= oversize_used;
    2052:	f8ad 502e 	strh.w	r5, [sp, #46]	; 0x2e
			space -= oversize_used;
    2056:	b292      	uxth	r2, r2
			pos += oversize_used;
    2058:	460d      	mov	r5, r1
		if ((pos < len) && (space > 0) && (last_unsent->len > 0)) {
    205a:	42bd      	cmp	r5, r7
    205c:	f080 80e7 	bcs.w	222e <tcp_write+0x296>
    2060:	2a00      	cmp	r2, #0
    2062:	f000 80e2 	beq.w	222a <tcp_write+0x292>
    2066:	2b00      	cmp	r3, #0
    2068:	f000 80df 	beq.w	222a <tcp_write+0x292>
			u16_t seglen = space < len - pos ? space : len - pos;
    206c:	eba7 0805 	sub.w	r8, r7, r5
			if (apiflags & TCP_WRITE_FLAG_COPY) {
    2070:	9b06      	ldr	r3, [sp, #24]
			u16_t seglen = space < len - pos ? space : len - pos;
    2072:	4590      	cmp	r8, r2
    2074:	bfa8      	it	ge
    2076:	4690      	movge	r8, r2
			if (apiflags & TCP_WRITE_FLAG_COPY) {
    2078:	07db      	lsls	r3, r3, #31
			u16_t seglen = space < len - pos ? space : len - pos;
    207a:	fa1f f688 	uxth.w	r6, r8
			if (apiflags & TCP_WRITE_FLAG_COPY) {
    207e:	d52c      	bpl.n	20da <tcp_write+0x142>
				if ((concat_p = tcp_pbuf_prealloc(PBUF_RAW, seglen, space, &oversize, pcb, apiflags, 1)) == NULL) {
    2080:	2301      	movs	r3, #1
    2082:	9302      	str	r3, [sp, #8]
    2084:	9b06      	ldr	r3, [sp, #24]
    2086:	f8df b248 	ldr.w	fp, [pc, #584]	; 22d0 <tcp_write+0x338>
    208a:	e9cd 4300 	strd	r4, r3, [sp]
    208e:	4631      	mov	r1, r6
    2090:	f10d 032e 	add.w	r3, sp, #46	; 0x2e
    2094:	2003      	movs	r0, #3
    2096:	47d8      	blx	fp
    2098:	4683      	mov	fp, r0
    209a:	2800      	cmp	r0, #0
    209c:	f000 8100 	beq.w	22a0 <tcp_write+0x308>
				TCP_DATA_COPY2(concat_p->payload, (u8_t *)arg + pos, seglen, &concat_chksum, &concat_chksum_swapped);
    20a0:	9b05      	ldr	r3, [sp, #20]
    20a2:	6840      	ldr	r0, [r0, #4]
    20a4:	1959      	adds	r1, r3, r5
    20a6:	4632      	mov	r2, r6
    20a8:	4b82      	ldr	r3, [pc, #520]	; (22b4 <tcp_write+0x31c>)
    20aa:	4798      	blx	r3
			queuelen += pbuf_clen(concat_p);
    20ac:	4b82      	ldr	r3, [pc, #520]	; (22b8 <tcp_write+0x320>)
    20ae:	4658      	mov	r0, fp
    20b0:	4798      	blx	r3
    20b2:	9b04      	ldr	r3, [sp, #16]
    20b4:	4403      	add	r3, r0
			pos += seglen;
    20b6:	442e      	add	r6, r5
			queuelen += pbuf_clen(concat_p);
    20b8:	b29b      	uxth	r3, r3
			pos += seglen;
    20ba:	b2b6      	uxth	r6, r6
			queuelen += pbuf_clen(concat_p);
    20bc:	9304      	str	r3, [sp, #16]
    20be:	46d0      	mov	r8, sl
    20c0:	46d9      	mov	r9, fp
		if (apiflags & TCP_WRITE_FLAG_COPY) {
    20c2:	9b06      	ldr	r3, [sp, #24]
    20c4:	f04f 0b00 	mov.w	fp, #0
    20c8:	f003 0301 	and.w	r3, r3, #1
    20cc:	ee08 3a10 	vmov	s16, r3
    20d0:	f8cd b020 	str.w	fp, [sp, #32]
    20d4:	e083      	b.n	21de <tcp_write+0x246>
	struct tcp_seg *last_unsent = NULL, *seg = NULL, *prev_seg = NULL, *queue = NULL;
    20d6:	46a8      	mov	r8, r5
    20d8:	e7bf      	b.n	205a <tcp_write+0xc2>
				if ((concat_p = pbuf_alloc(PBUF_RAW, seglen, PBUF_ROM)) == NULL) {
    20da:	4b78      	ldr	r3, [pc, #480]	; (22bc <tcp_write+0x324>)
    20dc:	2201      	movs	r2, #1
    20de:	4631      	mov	r1, r6
    20e0:	2003      	movs	r0, #3
    20e2:	4798      	blx	r3
    20e4:	4683      	mov	fp, r0
    20e6:	2800      	cmp	r0, #0
    20e8:	f000 80da 	beq.w	22a0 <tcp_write+0x308>
				concat_p->payload = (u8_t *)arg + pos;
    20ec:	9b05      	ldr	r3, [sp, #20]
    20ee:	442b      	add	r3, r5
    20f0:	6043      	str	r3, [r0, #4]
    20f2:	e7db      	b.n	20ac <tcp_write+0x114>
		u16_t        seglen  = left > max_len ? max_len : left;
    20f4:	9a07      	ldr	r2, [sp, #28]
		u16_t        left    = len - pos;
    20f6:	1bbb      	subs	r3, r7, r6
		u16_t        seglen  = left > max_len ? max_len : left;
    20f8:	b29b      	uxth	r3, r3
    20fa:	4293      	cmp	r3, r2
    20fc:	bf28      	it	cs
    20fe:	4613      	movcs	r3, r2
    2100:	ee08 3a90 	vmov	s17, r3
		if (apiflags & TCP_WRITE_FLAG_COPY) {
    2104:	ee18 3a10 	vmov	r3, s16
    2108:	b313      	cbz	r3, 2150 <tcp_write+0x1b8>
			if ((p = tcp_pbuf_prealloc(
    210a:	fabb f38b 	clz	r3, fp
    210e:	095b      	lsrs	r3, r3, #5
    2110:	9302      	str	r3, [sp, #8]
    2112:	9b06      	ldr	r3, [sp, #24]
    2114:	f8df 81b8 	ldr.w	r8, [pc, #440]	; 22d0 <tcp_write+0x338>
    2118:	e9cd 4300 	strd	r4, r3, [sp]
    211c:	ee18 1a90 	vmov	r1, s17
    2120:	f10d 032e 	add.w	r3, sp, #46	; 0x2e
    2124:	2000      	movs	r0, #0
    2126:	47c0      	blx	r8
    2128:	4680      	mov	r8, r0
    212a:	b358      	cbz	r0, 2184 <tcp_write+0x1ec>
			TCP_DATA_COPY2((char *)p->payload + optlen, (u8_t *)arg + pos, seglen, &chksum, &chksum_swapped);
    212c:	9b05      	ldr	r3, [sp, #20]
    212e:	6840      	ldr	r0, [r0, #4]
    2130:	1999      	adds	r1, r3, r6
    2132:	ee18 2a90 	vmov	r2, s17
    2136:	4b5f      	ldr	r3, [pc, #380]	; (22b4 <tcp_write+0x31c>)
    2138:	4798      	blx	r3
		queuelen += pbuf_clen(p);
    213a:	4b5f      	ldr	r3, [pc, #380]	; (22b8 <tcp_write+0x320>)
    213c:	4640      	mov	r0, r8
    213e:	4798      	blx	r3
    2140:	9b04      	ldr	r3, [sp, #16]
    2142:	4403      	add	r3, r0
    2144:	b29b      	uxth	r3, r3
		if ((queuelen > TCP_SND_QUEUELEN) || (queuelen > TCP_SNDQUEUELEN_OVERFLOW)) {
    2146:	2b08      	cmp	r3, #8
		queuelen += pbuf_clen(p);
    2148:	9304      	str	r3, [sp, #16]
		if ((queuelen > TCP_SND_QUEUELEN) || (queuelen > TCP_SNDQUEUELEN_OVERFLOW)) {
    214a:	d931      	bls.n	21b0 <tcp_write+0x218>
			pbuf_free(p);
    214c:	4640      	mov	r0, r8
    214e:	e017      	b.n	2180 <tcp_write+0x1e8>
			if ((p2 = pbuf_alloc(PBUF_TRANSPORT, seglen, PBUF_ROM)) == NULL) {
    2150:	ee18 1a90 	vmov	r1, s17
    2154:	ee18 0a10 	vmov	r0, s16
    2158:	4b58      	ldr	r3, [pc, #352]	; (22bc <tcp_write+0x324>)
    215a:	2201      	movs	r2, #1
    215c:	4798      	blx	r3
    215e:	b188      	cbz	r0, 2184 <tcp_write+0x1ec>
			p2->payload = (u8_t *)arg + pos;
    2160:	9a05      	ldr	r2, [sp, #20]
			if ((p = pbuf_alloc(PBUF_TRANSPORT, optlen, PBUF_RAM)) == NULL) {
    2162:	4b56      	ldr	r3, [pc, #344]	; (22bc <tcp_write+0x324>)
			p2->payload = (u8_t *)arg + pos;
    2164:	9009      	str	r0, [sp, #36]	; 0x24
    2166:	4432      	add	r2, r6
    2168:	6042      	str	r2, [r0, #4]
			if ((p = pbuf_alloc(PBUF_TRANSPORT, optlen, PBUF_RAM)) == NULL) {
    216a:	ee18 1a10 	vmov	r1, s16
    216e:	ee18 2a10 	vmov	r2, s16
    2172:	ee18 0a10 	vmov	r0, s16
    2176:	4798      	blx	r3
    2178:	9b09      	ldr	r3, [sp, #36]	; 0x24
    217a:	4680      	mov	r8, r0
    217c:	b9a0      	cbnz	r0, 21a8 <tcp_write+0x210>
				pbuf_free(p2);
    217e:	4618      	mov	r0, r3
			pbuf_free(p);
    2180:	4b4f      	ldr	r3, [pc, #316]	; (22c0 <tcp_write+0x328>)
    2182:	4798      	blx	r3
	pcb->flags |= TF_NAGLEMEMERR;
    2184:	7fa3      	ldrb	r3, [r4, #30]
    2186:	f063 037f 	orn	r3, r3, #127	; 0x7f
    218a:	77a3      	strb	r3, [r4, #30]
	if (concat_p != NULL) {
    218c:	f1b9 0f00 	cmp.w	r9, #0
    2190:	d002      	beq.n	2198 <tcp_write+0x200>
		pbuf_free(concat_p);
    2192:	4b4b      	ldr	r3, [pc, #300]	; (22c0 <tcp_write+0x328>)
    2194:	4648      	mov	r0, r9
    2196:	4798      	blx	r3
	if (queue != NULL) {
    2198:	f1bb 0f00 	cmp.w	fp, #0
    219c:	f43f af1a 	beq.w	1fd4 <tcp_write+0x3c>
		tcp_segs_free(queue);
    21a0:	4b48      	ldr	r3, [pc, #288]	; (22c4 <tcp_write+0x32c>)
    21a2:	4658      	mov	r0, fp
    21a4:	4798      	blx	r3
    21a6:	e715      	b.n	1fd4 <tcp_write+0x3c>
			pbuf_cat(p /*header*/, p2 /*data*/);
    21a8:	4619      	mov	r1, r3
    21aa:	4b47      	ldr	r3, [pc, #284]	; (22c8 <tcp_write+0x330>)
    21ac:	4798      	blx	r3
    21ae:	e7c4      	b.n	213a <tcp_write+0x1a2>
		if ((seg = tcp_create_segment(pcb, p, 0, pcb->snd_lbb + pos, optflags)) == NULL) {
    21b0:	6de3      	ldr	r3, [r4, #92]	; 0x5c
    21b2:	2200      	movs	r2, #0
    21b4:	4641      	mov	r1, r8
    21b6:	9200      	str	r2, [sp, #0]
    21b8:	f8df 8118 	ldr.w	r8, [pc, #280]	; 22d4 <tcp_write+0x33c>
    21bc:	4433      	add	r3, r6
    21be:	4620      	mov	r0, r4
    21c0:	47c0      	blx	r8
    21c2:	4680      	mov	r8, r0
    21c4:	2800      	cmp	r0, #0
    21c6:	d0dd      	beq.n	2184 <tcp_write+0x1ec>
		if (queue == NULL) {
    21c8:	f1bb 0f00 	cmp.w	fp, #0
    21cc:	d02b      	beq.n	2226 <tcp_write+0x28e>
			prev_seg->next = seg;
    21ce:	9b08      	ldr	r3, [sp, #32]
    21d0:	6018      	str	r0, [r3, #0]
		pos += seglen;
    21d2:	ee18 3a90 	vmov	r3, s17
    21d6:	441e      	add	r6, r3
    21d8:	b2b6      	uxth	r6, r6
    21da:	f8cd 8020 	str.w	r8, [sp, #32]
	while (pos < len) {
    21de:	42be      	cmp	r6, r7
    21e0:	d388      	bcc.n	20f4 <tcp_write+0x15c>
    21e2:	464b      	mov	r3, r9
    21e4:	46d9      	mov	r9, fp
	if (oversize_used > 0) {
    21e6:	b14d      	cbz	r5, 21fc <tcp_write+0x264>
		for (p = last_unsent->p; p; p = p->next) {
    21e8:	f8da 6004 	ldr.w	r6, [sl, #4]
				TCP_DATA_COPY((char *)p->payload + p->len, arg, oversize_used, last_unsent);
    21ec:	f8df b0c4 	ldr.w	fp, [pc, #196]	; 22b4 <tcp_write+0x31c>
		for (p = last_unsent->p; p; p = p->next) {
    21f0:	b9fe      	cbnz	r6, 2232 <tcp_write+0x29a>
		last_unsent->len += oversize_used;
    21f2:	f8ba 2008 	ldrh.w	r2, [sl, #8]
    21f6:	4415      	add	r5, r2
    21f8:	f8aa 5008 	strh.w	r5, [sl, #8]
	pcb->unsent_oversize = oversize;
    21fc:	f8bd 202e 	ldrh.w	r2, [sp, #46]	; 0x2e
    2200:	f8a4 206a 	strh.w	r2, [r4, #106]	; 0x6a
	if (concat_p != NULL) {
    2204:	b343      	cbz	r3, 2258 <tcp_write+0x2c0>
		pbuf_cat(last_unsent->p, concat_p);
    2206:	4a30      	ldr	r2, [pc, #192]	; (22c8 <tcp_write+0x330>)
    2208:	f8da 0004 	ldr.w	r0, [sl, #4]
    220c:	9305      	str	r3, [sp, #20]
    220e:	4619      	mov	r1, r3
    2210:	4790      	blx	r2
		last_unsent->len += concat_p->tot_len;
    2212:	9b05      	ldr	r3, [sp, #20]
    2214:	f8ba 2008 	ldrh.w	r2, [sl, #8]
    2218:	891b      	ldrh	r3, [r3, #8]
    221a:	4413      	add	r3, r2
    221c:	f8aa 3008 	strh.w	r3, [sl, #8]
		last_unsent->next = queue;
    2220:	f8ca 9000 	str.w	r9, [sl]
    2224:	e01d      	b.n	2262 <tcp_write+0x2ca>
    2226:	4683      	mov	fp, r0
    2228:	e7d3      	b.n	21d2 <tcp_write+0x23a>
    222a:	462e      	mov	r6, r5
    222c:	e749      	b.n	20c2 <tcp_write+0x12a>
	struct pbuf *   concat_p    = NULL;
    222e:	2300      	movs	r3, #0
    2230:	e7d9      	b.n	21e6 <tcp_write+0x24e>
			p->tot_len += oversize_used;
    2232:	8932      	ldrh	r2, [r6, #8]
    2234:	442a      	add	r2, r5
    2236:	8132      	strh	r2, [r6, #8]
			if (p->next == NULL) {
    2238:	6832      	ldr	r2, [r6, #0]
    223a:	b95a      	cbnz	r2, 2254 <tcp_write+0x2bc>
				TCP_DATA_COPY((char *)p->payload + p->len, arg, oversize_used, last_unsent);
    223c:	f8b6 c00a 	ldrh.w	ip, [r6, #10]
    2240:	6870      	ldr	r0, [r6, #4]
    2242:	9905      	ldr	r1, [sp, #20]
    2244:	9307      	str	r3, [sp, #28]
    2246:	462a      	mov	r2, r5
    2248:	4460      	add	r0, ip
    224a:	47d8      	blx	fp
				p->len += oversize_used;
    224c:	8972      	ldrh	r2, [r6, #10]
    224e:	9b07      	ldr	r3, [sp, #28]
    2250:	442a      	add	r2, r5
    2252:	8172      	strh	r2, [r6, #10]
		for (p = last_unsent->p; p; p = p->next) {
    2254:	6836      	ldr	r6, [r6, #0]
    2256:	e7cb      	b.n	21f0 <tcp_write+0x258>
	if (last_unsent == NULL) {
    2258:	f1ba 0f00 	cmp.w	sl, #0
    225c:	d1e0      	bne.n	2220 <tcp_write+0x288>
		pcb->unsent = queue;
    225e:	f8c4 906c 	str.w	r9, [r4, #108]	; 0x6c
	pcb->snd_lbb += len;
    2262:	6de3      	ldr	r3, [r4, #92]	; 0x5c
	pcb->snd_buf -= len;
    2264:	f8b4 2066 	ldrh.w	r2, [r4, #102]	; 0x66
	pcb->snd_lbb += len;
    2268:	443b      	add	r3, r7
    226a:	65e3      	str	r3, [r4, #92]	; 0x5c
	pcb->snd_buf -= len;
    226c:	1bd7      	subs	r7, r2, r7
	pcb->snd_queuelen = queuelen;
    226e:	9b04      	ldr	r3, [sp, #16]
	pcb->snd_buf -= len;
    2270:	f8a4 7066 	strh.w	r7, [r4, #102]	; 0x66
	pcb->snd_queuelen = queuelen;
    2274:	f8a4 3068 	strh.w	r3, [r4, #104]	; 0x68
	if (seg != NULL && seg->tcphdr != NULL && ((apiflags & TCP_WRITE_FLAG_MORE) == 0)) {
    2278:	f1b8 0f00 	cmp.w	r8, #0
    227c:	d00e      	beq.n	229c <tcp_write+0x304>
    227e:	f8d8 000c 	ldr.w	r0, [r8, #12]
    2282:	b190      	cbz	r0, 22aa <tcp_write+0x312>
    2284:	9b06      	ldr	r3, [sp, #24]
    2286:	f013 0402 	ands.w	r4, r3, #2
    228a:	d107      	bne.n	229c <tcp_write+0x304>
		TCPH_SET_FLAG(seg->tcphdr, TCP_PSH);
    228c:	8985      	ldrh	r5, [r0, #12]
    228e:	4b0f      	ldr	r3, [pc, #60]	; (22cc <tcp_write+0x334>)
    2290:	2008      	movs	r0, #8
    2292:	4798      	blx	r3
    2294:	f8d8 300c 	ldr.w	r3, [r8, #12]
    2298:	4328      	orrs	r0, r5
    229a:	8198      	strh	r0, [r3, #12]
	return ERR_OK;
    229c:	2000      	movs	r0, #0
    229e:	e004      	b.n	22aa <tcp_write+0x312>
	struct tcp_seg *last_unsent = NULL, *seg = NULL, *prev_seg = NULL, *queue = NULL;
    22a0:	f04f 0b00 	mov.w	fp, #0
    22a4:	e76e      	b.n	2184 <tcp_write+0x1ec>
		return ERR_CONN;
    22a6:	f06f 000c 	mvn.w	r0, #12
}
    22aa:	b00d      	add	sp, #52	; 0x34
    22ac:	ecbd 8b02 	vpop	{d8}
    22b0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    22b4:	000094a5 	.word	0x000094a5
    22b8:	0000323d 	.word	0x0000323d
    22bc:	000030d9 	.word	0x000030d9
    22c0:	00003081 	.word	0x00003081
    22c4:	00005b5d 	.word	0x00005b5d
    22c8:	00003257 	.word	0x00003257
    22cc:	00000d65 	.word	0x00000d65
    22d0:	00001e19 	.word	0x00001e19
    22d4:	00001e6d 	.word	0x00001e6d

000022d8 <tcp_enqueue_flags>:

	LWIP_ASSERT("tcp_enqueue_flags: need either TCP_SYN or TCP_FIN in flags (programmer violates API)",
	            (flags & (TCP_SYN | TCP_FIN)) != 0);

	/* check for configured max queuelen and possible overflow */
	if ((pcb->snd_queuelen >= TCP_SND_QUEUELEN) || (pcb->snd_queuelen > TCP_SNDQUEUELEN_OVERFLOW)) {
    22d8:	f8b0 3068 	ldrh.w	r3, [r0, #104]	; 0x68
    22dc:	2b07      	cmp	r3, #7
{
    22de:	b573      	push	{r0, r1, r4, r5, r6, lr}
    22e0:	4604      	mov	r4, r0
    22e2:	460d      	mov	r5, r1
	if ((pcb->snd_queuelen >= TCP_SND_QUEUELEN) || (pcb->snd_queuelen > TCP_SNDQUEUELEN_OVERFLOW)) {
    22e4:	d906      	bls.n	22f4 <tcp_enqueue_flags+0x1c>
	}
	LWIP_ASSERT("tcp_enqueue_flags: check that first pbuf can hold optlen", (p->len >= optlen));

	/* Allocate memory for tcp_seg, and fill in fields. */
	if ((seg = tcp_create_segment(pcb, p, flags, pcb->snd_lbb, optflags)) == NULL) {
		pcb->flags |= TF_NAGLEMEMERR;
    22e6:	7fa3      	ldrb	r3, [r4, #30]
    22e8:	f063 037f 	orn	r3, r3, #127	; 0x7f
    22ec:	77a3      	strb	r3, [r4, #30]
		return ERR_MEM;
    22ee:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    22f2:	e034      	b.n	235e <tcp_enqueue_flags+0x86>
	if (pcb->snd_buf == 0) {
    22f4:	f8b0 3066 	ldrh.w	r3, [r0, #102]	; 0x66
	if (flags & TCP_SYN) {
    22f8:	f3c1 0640 	ubfx	r6, r1, #1, #1
	optlen = LWIP_TCP_OPT_LENGTH(optflags);
    22fc:	00b1      	lsls	r1, r6, #2
	if (pcb->snd_buf == 0) {
    22fe:	2b00      	cmp	r3, #0
    2300:	d0f5      	beq.n	22ee <tcp_enqueue_flags+0x16>
	if ((p = pbuf_alloc(PBUF_TRANSPORT, optlen, PBUF_RAM)) == NULL) {
    2302:	2200      	movs	r2, #0
    2304:	4b1a      	ldr	r3, [pc, #104]	; (2370 <tcp_enqueue_flags+0x98>)
    2306:	4610      	mov	r0, r2
    2308:	4798      	blx	r3
    230a:	4601      	mov	r1, r0
    230c:	2800      	cmp	r0, #0
    230e:	d0ea      	beq.n	22e6 <tcp_enqueue_flags+0xe>
	if ((seg = tcp_create_segment(pcb, p, flags, pcb->snd_lbb, optflags)) == NULL) {
    2310:	9600      	str	r6, [sp, #0]
    2312:	6de3      	ldr	r3, [r4, #92]	; 0x5c
    2314:	4e17      	ldr	r6, [pc, #92]	; (2374 <tcp_enqueue_flags+0x9c>)
    2316:	462a      	mov	r2, r5
    2318:	4620      	mov	r0, r4
    231a:	47b0      	blx	r6
    231c:	2800      	cmp	r0, #0
    231e:	d0e2      	beq.n	22e6 <tcp_enqueue_flags+0xe>
	             ntohl(seg->tcphdr->seqno),
	             ntohl(seg->tcphdr->seqno) + TCP_TCPLEN(seg),
	             (u16_t)flags));

	/* Now append seg to pcb->unsent queue */
	if (pcb->unsent == NULL) {
    2320:	6ee3      	ldr	r3, [r4, #108]	; 0x6c
    2322:	b9f3      	cbnz	r3, 2362 <tcp_enqueue_flags+0x8a>
		pcb->unsent = seg;
    2324:	66e0      	str	r0, [r4, #108]	; 0x6c
			;
		useg->next = seg;
	}
#if TCP_OVERSIZE
	/* The new unsent tail has no space */
	pcb->unsent_oversize = 0;
    2326:	2300      	movs	r3, #0
#endif /* TCP_OVERSIZE */

	/* SYN and FIN bump the sequence number */
	if ((flags & TCP_SYN) || (flags & TCP_FIN)) {
    2328:	07aa      	lsls	r2, r5, #30
	pcb->unsent_oversize = 0;
    232a:	f8a4 306a 	strh.w	r3, [r4, #106]	; 0x6a
	if ((flags & TCP_SYN) || (flags & TCP_FIN)) {
    232e:	d007      	beq.n	2340 <tcp_enqueue_flags+0x68>
		pcb->snd_lbb++;
    2330:	6de3      	ldr	r3, [r4, #92]	; 0x5c
    2332:	3301      	adds	r3, #1
    2334:	65e3      	str	r3, [r4, #92]	; 0x5c
		/* optlen does not influence snd_buf */
		pcb->snd_buf--;
    2336:	f8b4 3066 	ldrh.w	r3, [r4, #102]	; 0x66
    233a:	3b01      	subs	r3, #1
    233c:	f8a4 3066 	strh.w	r3, [r4, #102]	; 0x66
	}
	if (flags & TCP_FIN) {
    2340:	07eb      	lsls	r3, r5, #31
		pcb->flags |= TF_FIN;
    2342:	bf42      	ittt	mi
    2344:	7fa3      	ldrbmi	r3, [r4, #30]
    2346:	f043 0320 	orrmi.w	r3, r3, #32
    234a:	77a3      	strbmi	r3, [r4, #30]
	}

	/* update number of segments on the queues */
	pcb->snd_queuelen += pbuf_clen(seg->p);
    234c:	6840      	ldr	r0, [r0, #4]
    234e:	4b0a      	ldr	r3, [pc, #40]	; (2378 <tcp_enqueue_flags+0xa0>)
    2350:	4798      	blx	r3
    2352:	f8b4 3068 	ldrh.w	r3, [r4, #104]	; 0x68
    2356:	4418      	add	r0, r3
    2358:	f8a4 0068 	strh.w	r0, [r4, #104]	; 0x68
	LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_enqueue_flags: %" S16_F " (after enqueued)\n", pcb->snd_queuelen));
	if (pcb->snd_queuelen != 0) {
		LWIP_ASSERT("tcp_enqueue_flags: invalid queue length", pcb->unacked != NULL || pcb->unsent != NULL);
	}

	return ERR_OK;
    235c:	2000      	movs	r0, #0
}
    235e:	b002      	add	sp, #8
    2360:	bd70      	pop	{r4, r5, r6, pc}
		for (useg = pcb->unsent; useg->next != NULL; useg = useg->next)
    2362:	461a      	mov	r2, r3
    2364:	681b      	ldr	r3, [r3, #0]
    2366:	2b00      	cmp	r3, #0
    2368:	d1fb      	bne.n	2362 <tcp_enqueue_flags+0x8a>
		useg->next = seg;
    236a:	6010      	str	r0, [r2, #0]
    236c:	e7db      	b.n	2326 <tcp_enqueue_flags+0x4e>
    236e:	bf00      	nop
    2370:	000030d9 	.word	0x000030d9
    2374:	00001e6d 	.word	0x00001e6d
    2378:	0000323d 	.word	0x0000323d

0000237c <tcp_send_fin>:
{
    237c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	if (pcb->unsent != NULL) {
    2380:	6ec4      	ldr	r4, [r0, #108]	; 0x6c
{
    2382:	4605      	mov	r5, r0
	if (pcb->unsent != NULL) {
    2384:	b14c      	cbz	r4, 239a <tcp_send_fin+0x1e>
		for (last_unsent = pcb->unsent; last_unsent->next != NULL; last_unsent = last_unsent->next)
    2386:	4627      	mov	r7, r4
    2388:	6824      	ldr	r4, [r4, #0]
    238a:	2c00      	cmp	r4, #0
    238c:	d1fb      	bne.n	2386 <tcp_send_fin+0xa>
		if ((TCPH_FLAGS(last_unsent->tcphdr) & (TCP_SYN | TCP_FIN | TCP_RST)) == 0) {
    238e:	68fb      	ldr	r3, [r7, #12]
    2390:	8998      	ldrh	r0, [r3, #12]
    2392:	4b0c      	ldr	r3, [pc, #48]	; (23c4 <tcp_send_fin+0x48>)
    2394:	4798      	blx	r3
    2396:	0743      	lsls	r3, r0, #29
    2398:	d005      	beq.n	23a6 <tcp_send_fin+0x2a>
	return tcp_enqueue_flags(pcb, TCP_FIN);
    239a:	4628      	mov	r0, r5
    239c:	4b0a      	ldr	r3, [pc, #40]	; (23c8 <tcp_send_fin+0x4c>)
}
    239e:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
	return tcp_enqueue_flags(pcb, TCP_FIN);
    23a2:	2101      	movs	r1, #1
    23a4:	4718      	bx	r3
			TCPH_SET_FLAG(last_unsent->tcphdr, TCP_FIN);
    23a6:	68fb      	ldr	r3, [r7, #12]
    23a8:	2001      	movs	r0, #1
    23aa:	899e      	ldrh	r6, [r3, #12]
    23ac:	4b07      	ldr	r3, [pc, #28]	; (23cc <tcp_send_fin+0x50>)
    23ae:	4798      	blx	r3
    23b0:	68fb      	ldr	r3, [r7, #12]
    23b2:	4330      	orrs	r0, r6
    23b4:	8198      	strh	r0, [r3, #12]
			pcb->flags |= TF_FIN;
    23b6:	7fab      	ldrb	r3, [r5, #30]
    23b8:	f043 0320 	orr.w	r3, r3, #32
    23bc:	77ab      	strb	r3, [r5, #30]
}
    23be:	4620      	mov	r0, r4
    23c0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    23c4:	00000d6b 	.word	0x00000d6b
    23c8:	000022d9 	.word	0x000022d9
    23cc:	00000d65 	.word	0x00000d65

000023d0 <tcp_send_empty_ack>:
/** Send an ACK without data.
 *
 * @param pcb Protocol control block for the TCP connection to send the ACK
 */
err_t tcp_send_empty_ack(struct tcp_pcb *pcb)
{
    23d0:	b5f0      	push	{r4, r5, r6, r7, lr}
	if (pcb->flags & TF_TIMESTAMP) {
		optlen = LWIP_TCP_OPT_LENGTH(TF_SEG_OPTS_TS);
	}
#endif

	p = tcp_output_alloc_header(pcb, optlen, 0, htonl(pcb->snd_nxt));
    23d2:	4b16      	ldr	r3, [pc, #88]	; (242c <tcp_send_empty_ack+0x5c>)
{
    23d4:	b085      	sub	sp, #20
    23d6:	4604      	mov	r4, r0
	p = tcp_output_alloc_header(pcb, optlen, 0, htonl(pcb->snd_nxt));
    23d8:	6d00      	ldr	r0, [r0, #80]	; 0x50
    23da:	4798      	blx	r3
    23dc:	4b14      	ldr	r3, [pc, #80]	; (2430 <tcp_send_empty_ack+0x60>)
    23de:	4602      	mov	r2, r0
    23e0:	2100      	movs	r1, #0
    23e2:	4620      	mov	r0, r4
    23e4:	4798      	blx	r3
	if (p == NULL) {
    23e6:	4605      	mov	r5, r0
    23e8:	b1e8      	cbz	r0, 2426 <tcp_send_empty_ack+0x56>
		return ERR_BUF;
	}
	tcphdr = (struct tcp_hdr *)p->payload;
	LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_output: sending ACK for %" U32_F "\n", pcb->rcv_nxt));
	/* remove ACK flags from the PCB, as we send an empty ACK now */
	pcb->flags &= ~(TF_ACK_DELAY | TF_ACK_NOW);
    23ea:	7fa3      	ldrb	r3, [r4, #30]
	tcphdr = (struct tcp_hdr *)p->payload;
    23ec:	6846      	ldr	r6, [r0, #4]
		tcp_build_timestamp_option(pcb, (u32_t *)(tcphdr + 1));
	}
#endif

#if CHECKSUM_GEN_TCP
	tcphdr->chksum = inet_chksum_pseudo(p, &(pcb->local_ip), &(pcb->remote_ip), IP_PROTO_TCP, p->tot_len);
    23ee:	4f11      	ldr	r7, [pc, #68]	; (2434 <tcp_send_empty_ack+0x64>)
	pcb->flags &= ~(TF_ACK_DELAY | TF_ACK_NOW);
    23f0:	f023 0303 	bic.w	r3, r3, #3
    23f4:	77a3      	strb	r3, [r4, #30]
	tcphdr->chksum = inet_chksum_pseudo(p, &(pcb->local_ip), &(pcb->remote_ip), IP_PROTO_TCP, p->tot_len);
    23f6:	8903      	ldrh	r3, [r0, #8]
    23f8:	9300      	str	r3, [sp, #0]
    23fa:	1d22      	adds	r2, r4, #4
    23fc:	4621      	mov	r1, r4
    23fe:	2306      	movs	r3, #6
    2400:	9203      	str	r2, [sp, #12]
    2402:	47b8      	blx	r7
#endif
#if LWIP_NETIF_HWADDRHINT
	ip_output_hinted(p, &(pcb->local_ip), &(pcb->remote_ip), pcb->ttl, pcb->tos, IP_PROTO_TCP, &(pcb->addr_hint));
#else  /* LWIP_NETIF_HWADDRHINT*/
	ip_output(p, &(pcb->local_ip), &(pcb->remote_ip), pcb->ttl, pcb->tos, IP_PROTO_TCP);
    2404:	2306      	movs	r3, #6
	tcphdr->chksum = inet_chksum_pseudo(p, &(pcb->local_ip), &(pcb->remote_ip), IP_PROTO_TCP, p->tot_len);
    2406:	8230      	strh	r0, [r6, #16]
	ip_output(p, &(pcb->local_ip), &(pcb->remote_ip), pcb->ttl, pcb->tos, IP_PROTO_TCP);
    2408:	9301      	str	r3, [sp, #4]
    240a:	7a63      	ldrb	r3, [r4, #9]
    240c:	9300      	str	r3, [sp, #0]
    240e:	7aa3      	ldrb	r3, [r4, #10]
    2410:	9a03      	ldr	r2, [sp, #12]
    2412:	4621      	mov	r1, r4
    2414:	4628      	mov	r0, r5
    2416:	4c08      	ldr	r4, [pc, #32]	; (2438 <tcp_send_empty_ack+0x68>)
    2418:	47a0      	blx	r4
#endif /* LWIP_NETIF_HWADDRHINT*/
	pbuf_free(p);
    241a:	4b08      	ldr	r3, [pc, #32]	; (243c <tcp_send_empty_ack+0x6c>)
    241c:	4628      	mov	r0, r5
    241e:	4798      	blx	r3

	return ERR_OK;
    2420:	2000      	movs	r0, #0
}
    2422:	b005      	add	sp, #20
    2424:	bdf0      	pop	{r4, r5, r6, r7, pc}
		return ERR_BUF;
    2426:	f06f 0001 	mvn.w	r0, #1
    242a:	e7fa      	b.n	2422 <tcp_send_empty_ack+0x52>
    242c:	00000d71 	.word	0x00000d71
    2430:	00001f31 	.word	0x00001f31
    2434:	00007419 	.word	0x00007419
    2438:	00005671 	.word	0x00005671
    243c:	00003081 	.word	0x00003081

00002440 <tcp_output>:
 * @param pcb Protocol control block for the TCP connection to send data
 * @return ERR_OK if data has been sent or nothing to send
 *         another err_t on error
 */
err_t tcp_output(struct tcp_pcb *pcb)
{
    2440:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}

	/* First, check if we are invoked by the TCP input processing
	   code. If so, we do not output anything. Instead, we rely on the
	   input processing code to call us when input processing is done
	   with. */
	if (tcp_input_pcb == pcb) {
    2444:	4b93      	ldr	r3, [pc, #588]	; (2694 <tcp_output+0x254>)
    2446:	681b      	ldr	r3, [r3, #0]
    2448:	4283      	cmp	r3, r0
{
    244a:	b085      	sub	sp, #20
    244c:	4604      	mov	r4, r0
	if (tcp_input_pcb == pcb) {
    244e:	d048      	beq.n	24e2 <tcp_output+0xa2>
		return ERR_OK;
	}

	wnd = LWIP_MIN(pcb->snd_wnd, pcb->cwnd);
    2450:	f8b0 3060 	ldrh.w	r3, [r0, #96]	; 0x60
    2454:	f8b0 804c 	ldrh.w	r8, [r0, #76]	; 0x4c

	seg = pcb->unsent;
    2458:	6ec5      	ldr	r5, [r0, #108]	; 0x6c
	wnd = LWIP_MIN(pcb->snd_wnd, pcb->cwnd);
    245a:	4598      	cmp	r8, r3
    245c:	bf28      	it	cs
    245e:	4698      	movcs	r8, r3
	 * because the ->unsent queue is empty or because the window does
	 * not allow it), construct an empty ACK segment and send it.
	 *
	 * If data is to be sent, we will just piggyback the ACK (see below).
	 */
	if (pcb->flags & TF_ACK_NOW && (seg == NULL || ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len > wnd)) {
    2460:	7f83      	ldrb	r3, [r0, #30]
    2462:	079a      	lsls	r2, r3, #30
    2464:	d510      	bpl.n	2488 <tcp_output+0x48>
    2466:	b92d      	cbnz	r5, 2474 <tcp_output+0x34>
		return tcp_send_empty_ack(pcb);
    2468:	4b8b      	ldr	r3, [pc, #556]	; (2698 <tcp_output+0x258>)
    246a:	4620      	mov	r0, r4
	}
#endif /* TCP_OVERSIZE */

	pcb->flags &= ~TF_NAGLEMEMERR;
	return ERR_OK;
}
    246c:	b005      	add	sp, #20
    246e:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
		return tcp_send_empty_ack(pcb);
    2472:	4718      	bx	r3
	if (pcb->flags & TF_ACK_NOW && (seg == NULL || ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len > wnd)) {
    2474:	68eb      	ldr	r3, [r5, #12]
    2476:	6858      	ldr	r0, [r3, #4]
    2478:	4b88      	ldr	r3, [pc, #544]	; (269c <tcp_output+0x25c>)
    247a:	4798      	blx	r3
    247c:	892b      	ldrh	r3, [r5, #8]
    247e:	6ca2      	ldr	r2, [r4, #72]	; 0x48
    2480:	1a9b      	subs	r3, r3, r2
    2482:	4418      	add	r0, r3
    2484:	4540      	cmp	r0, r8
    2486:	d8ef      	bhi.n	2468 <tcp_output+0x28>
	useg = pcb->unacked;
    2488:	6f27      	ldr	r7, [r4, #112]	; 0x70
	if (useg != NULL) {
    248a:	bb7f      	cbnz	r7, 24ec <tcp_output+0xac>
	while (seg != NULL && ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len <= wnd) {
    248c:	4e83      	ldr	r6, [pc, #524]	; (269c <tcp_output+0x25c>)
    248e:	b305      	cbz	r5, 24d2 <tcp_output+0x92>
    2490:	68eb      	ldr	r3, [r5, #12]
    2492:	6858      	ldr	r0, [r3, #4]
    2494:	47b0      	blx	r6
    2496:	892b      	ldrh	r3, [r5, #8]
    2498:	6ca2      	ldr	r2, [r4, #72]	; 0x48
    249a:	1a9b      	subs	r3, r3, r2
    249c:	4418      	add	r0, r3
    249e:	4540      	cmp	r0, r8
    24a0:	d817      	bhi.n	24d2 <tcp_output+0x92>
		if ((tcp_do_output_nagle(pcb) == 0) && ((pcb->flags & (TF_NAGLEMEMERR | TF_FIN)) == 0)) {
    24a2:	6f23      	ldr	r3, [r4, #112]	; 0x70
    24a4:	b333      	cbz	r3, 24f4 <tcp_output+0xb4>
    24a6:	7fa2      	ldrb	r2, [r4, #30]
    24a8:	f012 0f44 	tst.w	r2, #68	; 0x44
    24ac:	d122      	bne.n	24f4 <tcp_output+0xb4>
    24ae:	6ee3      	ldr	r3, [r4, #108]	; 0x6c
    24b0:	b12b      	cbz	r3, 24be <tcp_output+0x7e>
    24b2:	6819      	ldr	r1, [r3, #0]
    24b4:	b9f1      	cbnz	r1, 24f4 <tcp_output+0xb4>
    24b6:	8919      	ldrh	r1, [r3, #8]
    24b8:	8ee3      	ldrh	r3, [r4, #54]	; 0x36
    24ba:	4299      	cmp	r1, r3
    24bc:	d21a      	bcs.n	24f4 <tcp_output+0xb4>
    24be:	f8b4 3066 	ldrh.w	r3, [r4, #102]	; 0x66
    24c2:	b1bb      	cbz	r3, 24f4 <tcp_output+0xb4>
    24c4:	f8b4 3068 	ldrh.w	r3, [r4, #104]	; 0x68
    24c8:	2b07      	cmp	r3, #7
    24ca:	d813      	bhi.n	24f4 <tcp_output+0xb4>
    24cc:	f012 0fa0 	tst.w	r2, #160	; 0xa0
    24d0:	d110      	bne.n	24f4 <tcp_output+0xb4>
	if (pcb->unsent == NULL) {
    24d2:	6ee3      	ldr	r3, [r4, #108]	; 0x6c
    24d4:	b90b      	cbnz	r3, 24da <tcp_output+0x9a>
		pcb->unsent_oversize = 0;
    24d6:	f8a4 306a 	strh.w	r3, [r4, #106]	; 0x6a
	pcb->flags &= ~TF_NAGLEMEMERR;
    24da:	7fa3      	ldrb	r3, [r4, #30]
    24dc:	f003 037f 	and.w	r3, r3, #127	; 0x7f
    24e0:	77a3      	strb	r3, [r4, #30]
}
    24e2:	2000      	movs	r0, #0
    24e4:	b005      	add	sp, #20
    24e6:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    24ea:	461f      	mov	r7, r3
		for (; useg->next != NULL; useg = useg->next)
    24ec:	683b      	ldr	r3, [r7, #0]
    24ee:	2b00      	cmp	r3, #0
    24f0:	d1fb      	bne.n	24ea <tcp_output+0xaa>
    24f2:	e7cb      	b.n	248c <tcp_output+0x4c>
		pcb->unsent = seg->next;
    24f4:	682b      	ldr	r3, [r5, #0]
    24f6:	66e3      	str	r3, [r4, #108]	; 0x6c
		if (pcb->state != SYN_SENT) {
    24f8:	7e23      	ldrb	r3, [r4, #24]
    24fa:	2b02      	cmp	r3, #2
    24fc:	d00d      	beq.n	251a <tcp_output+0xda>
			TCPH_SET_FLAG(seg->tcphdr, TCP_ACK);
    24fe:	68eb      	ldr	r3, [r5, #12]
    2500:	2010      	movs	r0, #16
    2502:	f8b3 a00c 	ldrh.w	sl, [r3, #12]
    2506:	4b66      	ldr	r3, [pc, #408]	; (26a0 <tcp_output+0x260>)
    2508:	4798      	blx	r3
    250a:	68eb      	ldr	r3, [r5, #12]
    250c:	ea4a 0000 	orr.w	r0, sl, r0
    2510:	8198      	strh	r0, [r3, #12]
			pcb->flags &= ~(TF_ACK_DELAY | TF_ACK_NOW);
    2512:	7fa3      	ldrb	r3, [r4, #30]
    2514:	f023 0303 	bic.w	r3, r3, #3
    2518:	77a3      	strb	r3, [r4, #30]
	/** @bug Exclude retransmitted segments from this count. */
	snmp_inc_tcpoutsegs();

	/* The TCP header has already been constructed, but the ackno and
	 wnd fields remain. */
	seg->tcphdr->ackno = htonl(pcb->rcv_nxt);
    251a:	6aa0      	ldr	r0, [r4, #40]	; 0x28
    251c:	f8df a194 	ldr.w	sl, [pc, #404]	; 26b4 <tcp_output+0x274>
    2520:	f8d5 b00c 	ldr.w	fp, [r5, #12]
    2524:	47d0      	blx	sl

	/* advertise our receive window size in this TCP segment */
	seg->tcphdr->wnd = htons(pcb->rcv_ann_wnd);
    2526:	4b5e      	ldr	r3, [pc, #376]	; (26a0 <tcp_output+0x260>)
	seg->tcphdr->ackno = htonl(pcb->rcv_nxt);
    2528:	f8cb 0008 	str.w	r0, [fp, #8]
	seg->tcphdr->wnd = htons(pcb->rcv_ann_wnd);
    252c:	8de0      	ldrh	r0, [r4, #46]	; 0x2e
    252e:	f8d5 b00c 	ldr.w	fp, [r5, #12]
    2532:	4798      	blx	r3

	pcb->rcv_ann_right_edge = pcb->rcv_nxt + pcb->rcv_ann_wnd;
    2534:	8de2      	ldrh	r2, [r4, #46]	; 0x2e
    2536:	6aa3      	ldr	r3, [r4, #40]	; 0x28
	seg->tcphdr->wnd = htons(pcb->rcv_ann_wnd);
    2538:	f8ab 000e 	strh.w	r0, [fp, #14]
	pcb->rcv_ann_right_edge = pcb->rcv_nxt + pcb->rcv_ann_wnd;
    253c:	4413      	add	r3, r2
    253e:	6323      	str	r3, [r4, #48]	; 0x30

	/* Add any requested options.  NB MSS option is only set on SYN
	   packets, so ignore it here */
	opts = (u32_t *)(void *)(seg->tcphdr + 1);
	if (seg->flags & TF_SEG_OPTS_MSS) {
    2540:	7aab      	ldrb	r3, [r5, #10]
    2542:	07db      	lsls	r3, r3, #31
		u16_t mss;
#if TCP_CALCULATE_EFF_SEND_MSS
		mss = tcp_eff_send_mss(TCP_MSS, &pcb->remote_ip);
    2544:	f104 0904 	add.w	r9, r4, #4
	if (seg->flags & TF_SEG_OPTS_MSS) {
    2548:	d50b      	bpl.n	2562 <tcp_output+0x122>
		mss = tcp_eff_send_mss(TCP_MSS, &pcb->remote_ip);
    254a:	4b56      	ldr	r3, [pc, #344]	; (26a4 <tcp_output+0x264>)
	opts = (u32_t *)(void *)(seg->tcphdr + 1);
    254c:	f8d5 b00c 	ldr.w	fp, [r5, #12]
		mss = tcp_eff_send_mss(TCP_MSS, &pcb->remote_ip);
    2550:	4649      	mov	r1, r9
    2552:	f240 50b4 	movw	r0, #1460	; 0x5b4
    2556:	4798      	blx	r3
#else  /* TCP_CALCULATE_EFF_SEND_MSS */
		mss = TCP_MSS;
#endif /* TCP_CALCULATE_EFF_SEND_MSS */
		*opts = TCP_BUILD_MSS_OPTION(mss);
    2558:	f040 7001 	orr.w	r0, r0, #33816576	; 0x2040000
    255c:	47d0      	blx	sl
    255e:	f8cb 0014 	str.w	r0, [fp, #20]
	}
#endif

	/* Set retransmission timer running if it is not currently enabled
	   This must be set before checking the route. */
	if (pcb->rtime == -1) {
    2562:	f9b4 3034 	ldrsh.w	r3, [r4, #52]	; 0x34
    2566:	3301      	adds	r3, #1
		pcb->rtime = 0;
    2568:	bf04      	itt	eq
    256a:	2300      	moveq	r3, #0
    256c:	86a3      	strheq	r3, [r4, #52]	; 0x34
	}

	/* If we don't have a local IP address, we get one by
	   calling ip_route(). */
	if (ip_addr_isany(&(pcb->local_ip))) {
    256e:	6823      	ldr	r3, [r4, #0]
    2570:	b933      	cbnz	r3, 2580 <tcp_output+0x140>
		netif = ip_route(&(pcb->remote_ip));
    2572:	4b4d      	ldr	r3, [pc, #308]	; (26a8 <tcp_output+0x268>)
    2574:	4648      	mov	r0, r9
    2576:	4798      	blx	r3
		if (netif == NULL) {
    2578:	2800      	cmp	r0, #0
    257a:	d033      	beq.n	25e4 <tcp_output+0x1a4>
			return;
		}
		ip_addr_copy(pcb->local_ip, netif->ip_addr);
    257c:	6843      	ldr	r3, [r0, #4]
    257e:	6023      	str	r3, [r4, #0]
	}

	if (pcb->rttest == 0) {
    2580:	6ba3      	ldr	r3, [r4, #56]	; 0x38
    2582:	b933      	cbnz	r3, 2592 <tcp_output+0x152>
		pcb->rttest = tcp_ticks;
    2584:	4949      	ldr	r1, [pc, #292]	; (26ac <tcp_output+0x26c>)
		pcb->rtseq  = ntohl(seg->tcphdr->seqno);
    2586:	68eb      	ldr	r3, [r5, #12]
		pcb->rttest = tcp_ticks;
    2588:	6809      	ldr	r1, [r1, #0]
    258a:	63a1      	str	r1, [r4, #56]	; 0x38
		pcb->rtseq  = ntohl(seg->tcphdr->seqno);
    258c:	6858      	ldr	r0, [r3, #4]
    258e:	47b0      	blx	r6
    2590:	63e0      	str	r0, [r4, #60]	; 0x3c
	LWIP_DEBUGF(TCP_OUTPUT_DEBUG,
	            ("tcp_output_segment: %" U32_F ":%" U32_F "\n",
	             htonl(seg->tcphdr->seqno),
	             htonl(seg->tcphdr->seqno) + seg->len));

	len = (u16_t)((u8_t *)seg->tcphdr - (u8_t *)seg->p->payload);
    2592:	6868      	ldr	r0, [r5, #4]
    2594:	f8d5 a00c 	ldr.w	sl, [r5, #12]
    2598:	6843      	ldr	r3, [r0, #4]
		}
#endif /* TCP_CHECKSUM_ON_COPY_SANITY_CHECK */
	}
#else  /* TCP_CHECKSUM_ON_COPY */
	seg->tcphdr->chksum
	    = inet_chksum_pseudo(seg->p, &(pcb->local_ip), &(pcb->remote_ip), IP_PROTO_TCP, seg->p->tot_len);
    259a:	f8df b11c 	ldr.w	fp, [pc, #284]	; 26b8 <tcp_output+0x278>
	seg->p->payload = seg->tcphdr;
    259e:	f8c0 a004 	str.w	sl, [r0, #4]
	len = (u16_t)((u8_t *)seg->tcphdr - (u8_t *)seg->p->payload);
    25a2:	ebaa 0303 	sub.w	r3, sl, r3
    25a6:	b299      	uxth	r1, r3
	seg->p->len -= len;
    25a8:	8943      	ldrh	r3, [r0, #10]
    25aa:	1a5b      	subs	r3, r3, r1
    25ac:	8143      	strh	r3, [r0, #10]
	seg->p->tot_len -= len;
    25ae:	8903      	ldrh	r3, [r0, #8]
    25b0:	1a5b      	subs	r3, r3, r1
    25b2:	b29b      	uxth	r3, r3
	seg->tcphdr->chksum = 0;
    25b4:	2100      	movs	r1, #0
	seg->p->tot_len -= len;
    25b6:	8103      	strh	r3, [r0, #8]
	    = inet_chksum_pseudo(seg->p, &(pcb->local_ip), &(pcb->remote_ip), IP_PROTO_TCP, seg->p->tot_len);
    25b8:	464a      	mov	r2, r9
	seg->tcphdr->chksum = 0;
    25ba:	f88a 1010 	strb.w	r1, [sl, #16]
    25be:	f88a 1011 	strb.w	r1, [sl, #17]
	    = inet_chksum_pseudo(seg->p, &(pcb->local_ip), &(pcb->remote_ip), IP_PROTO_TCP, seg->p->tot_len);
    25c2:	9300      	str	r3, [sp, #0]
    25c4:	4621      	mov	r1, r4
    25c6:	2306      	movs	r3, #6
    25c8:	47d8      	blx	fp
	TCP_STATS_INC(tcp.xmit);

#if LWIP_NETIF_HWADDRHINT
	ip_output_hinted(seg->p, &(pcb->local_ip), &(pcb->remote_ip), pcb->ttl, pcb->tos, IP_PROTO_TCP, &(pcb->addr_hint));
#else  /* LWIP_NETIF_HWADDRHINT*/
	ip_output(seg->p, &(pcb->local_ip), &(pcb->remote_ip), pcb->ttl, pcb->tos, IP_PROTO_TCP);
    25ca:	2306      	movs	r3, #6
	    = inet_chksum_pseudo(seg->p, &(pcb->local_ip), &(pcb->remote_ip), IP_PROTO_TCP, seg->p->tot_len);
    25cc:	f8aa 0010 	strh.w	r0, [sl, #16]
	ip_output(seg->p, &(pcb->local_ip), &(pcb->remote_ip), pcb->ttl, pcb->tos, IP_PROTO_TCP);
    25d0:	9301      	str	r3, [sp, #4]
    25d2:	7a63      	ldrb	r3, [r4, #9]
    25d4:	9300      	str	r3, [sp, #0]
    25d6:	6868      	ldr	r0, [r5, #4]
    25d8:	7aa3      	ldrb	r3, [r4, #10]
    25da:	f8df a0e0 	ldr.w	sl, [pc, #224]	; 26bc <tcp_output+0x27c>
    25de:	464a      	mov	r2, r9
    25e0:	4621      	mov	r1, r4
    25e2:	47d0      	blx	sl
		snd_nxt = ntohl(seg->tcphdr->seqno) + TCP_TCPLEN(seg);
    25e4:	68eb      	ldr	r3, [r5, #12]
    25e6:	f8df a0d8 	ldr.w	sl, [pc, #216]	; 26c0 <tcp_output+0x280>
    25ea:	6858      	ldr	r0, [r3, #4]
    25ec:	47b0      	blx	r6
    25ee:	892a      	ldrh	r2, [r5, #8]
    25f0:	68eb      	ldr	r3, [r5, #12]
    25f2:	9203      	str	r2, [sp, #12]
    25f4:	4683      	mov	fp, r0
    25f6:	8998      	ldrh	r0, [r3, #12]
    25f8:	47d0      	blx	sl
    25fa:	9a03      	ldr	r2, [sp, #12]
    25fc:	f010 0303 	ands.w	r3, r0, #3
    2600:	bf18      	it	ne
    2602:	2301      	movne	r3, #1
    2604:	441a      	add	r2, r3
    2606:	eb02 030b 	add.w	r3, r2, fp
		if (TCP_SEQ_LT(pcb->snd_nxt, snd_nxt)) {
    260a:	6d22      	ldr	r2, [r4, #80]	; 0x50
    260c:	1ad2      	subs	r2, r2, r3
    260e:	2a00      	cmp	r2, #0
			pcb->snd_nxt = snd_nxt;
    2610:	bfb8      	it	lt
    2612:	6523      	strlt	r3, [r4, #80]	; 0x50
		if (TCP_TCPLEN(seg) > 0) {
    2614:	68eb      	ldr	r3, [r5, #12]
    2616:	4652      	mov	r2, sl
    2618:	8998      	ldrh	r0, [r3, #12]
    261a:	f8b5 a008 	ldrh.w	sl, [r5, #8]
    261e:	4790      	blx	r2
    2620:	f010 0003 	ands.w	r0, r0, #3
    2624:	bf18      	it	ne
    2626:	2001      	movne	r0, #1
    2628:	eb10 0f0a 	cmn.w	r0, sl
    262c:	d02d      	beq.n	268a <tcp_output+0x24a>
			seg->next = NULL;
    262e:	2300      	movs	r3, #0
    2630:	602b      	str	r3, [r5, #0]
			if (pcb->unacked == NULL) {
    2632:	6f23      	ldr	r3, [r4, #112]	; 0x70
    2634:	b913      	cbnz	r3, 263c <tcp_output+0x1fc>
				pcb->unacked = seg;
    2636:	6725      	str	r5, [r4, #112]	; 0x70
					useg->next = seg;
    2638:	462f      	mov	r7, r5
    263a:	e014      	b.n	2666 <tcp_output+0x226>
				if (TCP_SEQ_LT(ntohl(seg->tcphdr->seqno), ntohl(useg->tcphdr->seqno))) {
    263c:	68eb      	ldr	r3, [r5, #12]
    263e:	6858      	ldr	r0, [r3, #4]
    2640:	47b0      	blx	r6
    2642:	68fb      	ldr	r3, [r7, #12]
    2644:	4682      	mov	sl, r0
    2646:	6858      	ldr	r0, [r3, #4]
    2648:	47b0      	blx	r6
    264a:	ebaa 0000 	sub.w	r0, sl, r0
    264e:	2800      	cmp	r0, #0
    2650:	da19      	bge.n	2686 <tcp_output+0x246>
					struct tcp_seg **cur_seg = &(pcb->unacked);
    2652:	f104 0a70 	add.w	sl, r4, #112	; 0x70
					while (*cur_seg && TCP_SEQ_LT(ntohl((*cur_seg)->tcphdr->seqno), ntohl(seg->tcphdr->seqno))) {
    2656:	f8da 3000 	ldr.w	r3, [sl]
    265a:	b933      	cbnz	r3, 266a <tcp_output+0x22a>
					seg->next  = (*cur_seg);
    265c:	f8da 3000 	ldr.w	r3, [sl]
    2660:	602b      	str	r3, [r5, #0]
					(*cur_seg) = seg;
    2662:	f8ca 5000 	str.w	r5, [sl]
		seg = pcb->unsent;
    2666:	6ee5      	ldr	r5, [r4, #108]	; 0x6c
    2668:	e711      	b.n	248e <tcp_output+0x4e>
					while (*cur_seg && TCP_SEQ_LT(ntohl((*cur_seg)->tcphdr->seqno), ntohl(seg->tcphdr->seqno))) {
    266a:	68db      	ldr	r3, [r3, #12]
    266c:	6858      	ldr	r0, [r3, #4]
    266e:	47b0      	blx	r6
    2670:	68eb      	ldr	r3, [r5, #12]
    2672:	4683      	mov	fp, r0
    2674:	6858      	ldr	r0, [r3, #4]
    2676:	47b0      	blx	r6
    2678:	ebab 0000 	sub.w	r0, fp, r0
    267c:	2800      	cmp	r0, #0
    267e:	daed      	bge.n	265c <tcp_output+0x21c>
						cur_seg = &((*cur_seg)->next);
    2680:	f8da a000 	ldr.w	sl, [sl]
    2684:	e7e7      	b.n	2656 <tcp_output+0x216>
					useg->next = seg;
    2686:	603d      	str	r5, [r7, #0]
    2688:	e7d6      	b.n	2638 <tcp_output+0x1f8>
			tcp_seg_free(seg);
    268a:	4b09      	ldr	r3, [pc, #36]	; (26b0 <tcp_output+0x270>)
    268c:	4628      	mov	r0, r5
    268e:	4798      	blx	r3
    2690:	e7e9      	b.n	2666 <tcp_output+0x226>
    2692:	bf00      	nop
    2694:	2000a50c 	.word	0x2000a50c
    2698:	000023d1 	.word	0x000023d1
    269c:	00000d75 	.word	0x00000d75
    26a0:	00000d65 	.word	0x00000d65
    26a4:	00006415 	.word	0x00006415
    26a8:	000053ed 	.word	0x000053ed
    26ac:	200148f4 	.word	0x200148f4
    26b0:	00005b39 	.word	0x00005b39
    26b4:	00000d71 	.word	0x00000d71
    26b8:	00007419 	.word	0x00007419
    26bc:	00005671 	.word	0x00005671
    26c0:	00000d6b 	.word	0x00000d6b

000026c4 <tcp_rst>:
 * @param remote_ip the remote IP address to send the segment to
 * @param local_port the local TCP port to send the segment from
 * @param remote_port the remote TCP port to send the segment to
 */
void tcp_rst(u32_t seqno, u32_t ackno, ip_addr_t *local_ip, ip_addr_t *remote_ip, u16_t local_port, u16_t remote_port)
{
    26c4:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    26c8:	4682      	mov	sl, r0
    26ca:	4689      	mov	r9, r1
    26cc:	4617      	mov	r7, r2
    26ce:	4698      	mov	r8, r3
	struct pbuf *   p;
	struct tcp_hdr *tcphdr;
	p = pbuf_alloc(PBUF_IP, TCP_HLEN, PBUF_RAM);
    26d0:	2200      	movs	r2, #0
    26d2:	4b22      	ldr	r3, [pc, #136]	; (275c <tcp_rst+0x98>)
{
    26d4:	f8bd 6030 	ldrh.w	r6, [sp, #48]	; 0x30
    26d8:	f8bd b034 	ldrh.w	fp, [sp, #52]	; 0x34
	p = pbuf_alloc(PBUF_IP, TCP_HLEN, PBUF_RAM);
    26dc:	2114      	movs	r1, #20
    26de:	2001      	movs	r0, #1
    26e0:	4798      	blx	r3
	if (p == NULL) {
    26e2:	4605      	mov	r5, r0
    26e4:	2800      	cmp	r0, #0
    26e6:	d036      	beq.n	2756 <tcp_rst+0x92>
		LWIP_DEBUGF(TCP_DEBUG, ("tcp_rst: could not allocate memory for pbuf\n"));
		return;
	}
	LWIP_ASSERT("check that first pbuf can hold struct tcp_hdr", (p->len >= sizeof(struct tcp_hdr)));

	tcphdr        = (struct tcp_hdr *)p->payload;
    26e8:	6844      	ldr	r4, [r0, #4]
	tcphdr->src   = htons(local_port);
    26ea:	4630      	mov	r0, r6
    26ec:	4e1c      	ldr	r6, [pc, #112]	; (2760 <tcp_rst+0x9c>)
    26ee:	47b0      	blx	r6
    26f0:	8020      	strh	r0, [r4, #0]
	tcphdr->dest  = htons(remote_port);
    26f2:	4658      	mov	r0, fp
    26f4:	47b0      	blx	r6
    26f6:	8060      	strh	r0, [r4, #2]
	tcphdr->seqno = htonl(seqno);
    26f8:	4650      	mov	r0, sl
    26fa:	f8df a070 	ldr.w	sl, [pc, #112]	; 276c <tcp_rst+0xa8>
    26fe:	47d0      	blx	sl
    2700:	6060      	str	r0, [r4, #4]
	tcphdr->ackno = htonl(ackno);
    2702:	4648      	mov	r0, r9
    2704:	47d0      	blx	sl
    2706:	60a0      	str	r0, [r4, #8]
	TCPH_HDRLEN_FLAGS_SET(tcphdr, TCP_HLEN / 4, TCP_RST | TCP_ACK);
    2708:	f245 0014 	movw	r0, #20500	; 0x5014
    270c:	47b0      	blx	r6
	tcphdr->wnd    = PP_HTONS(TCP_WND);
    270e:	2316      	movs	r3, #22
    2710:	73a3      	strb	r3, [r4, #14]
    2712:	f06f 032f 	mvn.w	r3, #47	; 0x2f
    2716:	2600      	movs	r6, #0
    2718:	73e3      	strb	r3, [r4, #15]
	tcphdr->chksum = 0;
	tcphdr->urgp   = 0;

#if CHECKSUM_GEN_TCP
	tcphdr->chksum = inet_chksum_pseudo(p, local_ip, remote_ip, IP_PROTO_TCP, p->tot_len);
    271a:	892b      	ldrh	r3, [r5, #8]
	TCPH_HDRLEN_FLAGS_SET(tcphdr, TCP_HLEN / 4, TCP_RST | TCP_ACK);
    271c:	81a0      	strh	r0, [r4, #12]
	tcphdr->chksum = 0;
    271e:	7426      	strb	r6, [r4, #16]
    2720:	7466      	strb	r6, [r4, #17]
	tcphdr->urgp   = 0;
    2722:	74a6      	strb	r6, [r4, #18]
    2724:	74e6      	strb	r6, [r4, #19]
	tcphdr->chksum = inet_chksum_pseudo(p, local_ip, remote_ip, IP_PROTO_TCP, p->tot_len);
    2726:	4642      	mov	r2, r8
    2728:	9300      	str	r3, [sp, #0]
    272a:	4639      	mov	r1, r7
    272c:	f8df 9040 	ldr.w	r9, [pc, #64]	; 2770 <tcp_rst+0xac>
    2730:	2306      	movs	r3, #6
    2732:	4628      	mov	r0, r5
    2734:	47c8      	blx	r9
#endif
	TCP_STATS_INC(tcp.xmit);
	snmp_inc_tcpoutrsts();
	/* Send output with hardcoded TTL since we have no access to the pcb */
	ip_output(p, local_ip, remote_ip, TCP_TTL, 0, IP_PROTO_TCP);
    2736:	2306      	movs	r3, #6
	tcphdr->chksum = inet_chksum_pseudo(p, local_ip, remote_ip, IP_PROTO_TCP, p->tot_len);
    2738:	8220      	strh	r0, [r4, #16]
	ip_output(p, local_ip, remote_ip, TCP_TTL, 0, IP_PROTO_TCP);
    273a:	4642      	mov	r2, r8
    273c:	e9cd 6300 	strd	r6, r3, [sp]
    2740:	4c08      	ldr	r4, [pc, #32]	; (2764 <tcp_rst+0xa0>)
    2742:	23ff      	movs	r3, #255	; 0xff
    2744:	4639      	mov	r1, r7
    2746:	4628      	mov	r0, r5
    2748:	47a0      	blx	r4
	pbuf_free(p);
    274a:	4b07      	ldr	r3, [pc, #28]	; (2768 <tcp_rst+0xa4>)
    274c:	4628      	mov	r0, r5
	LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_rst: seqno %" U32_F " ackno %" U32_F ".\n", seqno, ackno));
}
    274e:	b003      	add	sp, #12
    2750:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	pbuf_free(p);
    2754:	4718      	bx	r3
}
    2756:	b003      	add	sp, #12
    2758:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    275c:	000030d9 	.word	0x000030d9
    2760:	00000d65 	.word	0x00000d65
    2764:	00005671 	.word	0x00005671
    2768:	00003081 	.word	0x00003081
    276c:	00000d71 	.word	0x00000d71
    2770:	00007419 	.word	0x00007419

00002774 <tcp_rexmit_rto>:
 */
void tcp_rexmit_rto(struct tcp_pcb *pcb)
{
	struct tcp_seg *seg;

	if (pcb->unacked == NULL) {
    2774:	6f02      	ldr	r2, [r0, #112]	; 0x70
{
    2776:	b410      	push	{r4}
	if (pcb->unacked == NULL) {
    2778:	b192      	cbz	r2, 27a0 <tcp_rexmit_rto+0x2c>
    277a:	4613      	mov	r3, r2
		return;
	}

	/* Move all unacked segments to the head of the unsent queue */
	for (seg = pcb->unacked; seg->next != NULL; seg = seg->next)
    277c:	4619      	mov	r1, r3
    277e:	681b      	ldr	r3, [r3, #0]
    2780:	2b00      	cmp	r3, #0
    2782:	d1fb      	bne.n	277c <tcp_rexmit_rto+0x8>
		;
	/* concatenate unsent queue after unacked queue */
	seg->next = pcb->unsent;
    2784:	6ec4      	ldr	r4, [r0, #108]	; 0x6c
    2786:	600c      	str	r4, [r1, #0]
	/* unsent queue is the concatenated queue (of unacked, unsent) */
	pcb->unsent = pcb->unacked;
	/* unacked queue is now empty */
	pcb->unacked = NULL;
    2788:	e9c0 231b 	strd	r2, r3, [r0, #108]	; 0x6c
	/* last unsent hasn't changed, no need to reset unsent_oversize */

	/* increment number of retransmissions */
	++pcb->nrtx;
    278c:	f890 2046 	ldrb.w	r2, [r0, #70]	; 0x46

	/* Don't take any RTT measurements after retransmitting. */
	pcb->rttest = 0;
    2790:	6383      	str	r3, [r0, #56]	; 0x38
	++pcb->nrtx;
    2792:	3201      	adds	r2, #1
    2794:	f880 2046 	strb.w	r2, [r0, #70]	; 0x46

	/* Do the actual retransmission */
	tcp_output(pcb);
    2798:	4b03      	ldr	r3, [pc, #12]	; (27a8 <tcp_rexmit_rto+0x34>)
}
    279a:	f85d 4b04 	ldr.w	r4, [sp], #4
	tcp_output(pcb);
    279e:	4718      	bx	r3
}
    27a0:	f85d 4b04 	ldr.w	r4, [sp], #4
    27a4:	4770      	bx	lr
    27a6:	bf00      	nop
    27a8:	00002441 	.word	0x00002441

000027ac <tcp_rexmit>:
 * Called by tcp_receive() for fast retramsmit.
 *
 * @param pcb the tcp_pcb for which to retransmit the first unacked segment
 */
void tcp_rexmit(struct tcp_pcb *pcb)
{
    27ac:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	struct tcp_seg * seg;
	struct tcp_seg **cur_seg;

	if (pcb->unacked == NULL) {
    27b0:	6f05      	ldr	r5, [r0, #112]	; 0x70
{
    27b2:	4604      	mov	r4, r0
	if (pcb->unacked == NULL) {
    27b4:	b1ad      	cbz	r5, 27e2 <tcp_rexmit+0x36>
	}

	/* Move the first unacked segment to the unsent queue */
	/* Keep the unsent queue sorted. */
	seg          = pcb->unacked;
	pcb->unacked = seg->next;
    27b6:	682b      	ldr	r3, [r5, #0]

	cur_seg = &(pcb->unsent);
	while (*cur_seg && TCP_SEQ_LT(ntohl((*cur_seg)->tcphdr->seqno), ntohl(seg->tcphdr->seqno))) {
    27b8:	f8df 8044 	ldr.w	r8, [pc, #68]	; 2800 <tcp_rexmit+0x54>
	pcb->unacked = seg->next;
    27bc:	6703      	str	r3, [r0, #112]	; 0x70
	cur_seg = &(pcb->unsent);
    27be:	f100 066c 	add.w	r6, r0, #108	; 0x6c
	while (*cur_seg && TCP_SEQ_LT(ntohl((*cur_seg)->tcphdr->seqno), ntohl(seg->tcphdr->seqno))) {
    27c2:	6833      	ldr	r3, [r6, #0]
    27c4:	b97b      	cbnz	r3, 27e6 <tcp_rexmit+0x3a>
		cur_seg = &((*cur_seg)->next);
	}
	seg->next = *cur_seg;
    27c6:	6833      	ldr	r3, [r6, #0]
    27c8:	602b      	str	r3, [r5, #0]
	*cur_seg  = seg;
    27ca:	6035      	str	r5, [r6, #0]
#if TCP_OVERSIZE
	if (seg->next == NULL) {
    27cc:	682b      	ldr	r3, [r5, #0]
    27ce:	b90b      	cbnz	r3, 27d4 <tcp_rexmit+0x28>
		/* the retransmitted segment is last in unsent, so reset unsent_oversize */
		pcb->unsent_oversize = 0;
    27d0:	f8a4 306a 	strh.w	r3, [r4, #106]	; 0x6a
	}
#endif /* TCP_OVERSIZE */

	++pcb->nrtx;
    27d4:	f894 3046 	ldrb.w	r3, [r4, #70]	; 0x46
    27d8:	3301      	adds	r3, #1
    27da:	f884 3046 	strb.w	r3, [r4, #70]	; 0x46

	/* Don't take any rtt measurements after retransmitting. */
	pcb->rttest = 0;
    27de:	2300      	movs	r3, #0
    27e0:	63a3      	str	r3, [r4, #56]	; 0x38

	/* Do the actual retransmission. */
	snmp_inc_tcpretranssegs();
	/* No need to call tcp_output: we are always called from tcp_input()
	   and thus tcp_output directly returns. */
}
    27e2:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	while (*cur_seg && TCP_SEQ_LT(ntohl((*cur_seg)->tcphdr->seqno), ntohl(seg->tcphdr->seqno))) {
    27e6:	68db      	ldr	r3, [r3, #12]
    27e8:	6858      	ldr	r0, [r3, #4]
    27ea:	47c0      	blx	r8
    27ec:	68eb      	ldr	r3, [r5, #12]
    27ee:	4607      	mov	r7, r0
    27f0:	6858      	ldr	r0, [r3, #4]
    27f2:	47c0      	blx	r8
    27f4:	1a38      	subs	r0, r7, r0
    27f6:	2800      	cmp	r0, #0
    27f8:	dae5      	bge.n	27c6 <tcp_rexmit+0x1a>
		cur_seg = &((*cur_seg)->next);
    27fa:	6836      	ldr	r6, [r6, #0]
    27fc:	e7e1      	b.n	27c2 <tcp_rexmit+0x16>
    27fe:	bf00      	nop
    2800:	00000d75 	.word	0x00000d75

00002804 <tcp_rexmit_fast>:
 *
 * @param pcb the tcp_pcb for which to retransmit the first unacked segment
 */
void tcp_rexmit_fast(struct tcp_pcb *pcb)
{
	if (pcb->unacked != NULL && !(pcb->flags & TF_INFR)) {
    2804:	6f03      	ldr	r3, [r0, #112]	; 0x70
{
    2806:	b510      	push	{r4, lr}
    2808:	4604      	mov	r4, r0
	if (pcb->unacked != NULL && !(pcb->flags & TF_INFR)) {
    280a:	b30b      	cbz	r3, 2850 <tcp_rexmit_fast+0x4c>
    280c:	7f83      	ldrb	r3, [r0, #30]
    280e:	075b      	lsls	r3, r3, #29
    2810:	d41e      	bmi.n	2850 <tcp_rexmit_fast+0x4c>
		LWIP_DEBUGF(TCP_FR_DEBUG,
		            ("tcp_receive: dupacks %" U16_F " (%" U32_F "), fast retransmit %" U32_F "\n",
		             (u16_t)pcb->dupacks,
		             pcb->lastack,
		             ntohl(pcb->unacked->tcphdr->seqno)));
		tcp_rexmit(pcb);
    2812:	4b10      	ldr	r3, [pc, #64]	; (2854 <tcp_rexmit_fast+0x50>)
    2814:	4798      	blx	r3

		/* Set ssthresh to half of the minimum of the current
		 * cwnd and the advertised window */
		if (pcb->cwnd > pcb->snd_wnd) {
    2816:	f8b4 204c 	ldrh.w	r2, [r4, #76]	; 0x4c
    281a:	f8b4 3060 	ldrh.w	r3, [r4, #96]	; 0x60
    281e:	429a      	cmp	r2, r3
			pcb->ssthresh = pcb->snd_wnd / 2;
    2820:	bf88      	it	hi
    2822:	085a      	lsrhi	r2, r3, #1
		} else {
			pcb->ssthresh = pcb->cwnd / 2;
		}

		/* The minimum value for ssthresh should be 2 MSS */
		if (pcb->ssthresh < 2 * pcb->mss) {
    2824:	8ee3      	ldrh	r3, [r4, #54]	; 0x36
			pcb->ssthresh = pcb->cwnd / 2;
    2826:	bf98      	it	ls
    2828:	0852      	lsrls	r2, r2, #1
		if (pcb->ssthresh < 2 * pcb->mss) {
    282a:	ebb2 0f43 	cmp.w	r2, r3, lsl #1
    282e:	ea4f 0143 	mov.w	r1, r3, lsl #1
    2832:	f8a4 204e 	strh.w	r2, [r4, #78]	; 0x4e
			LWIP_DEBUGF(TCP_FR_DEBUG,
			            ("tcp_receive: The minimum value for ssthresh %" U16_F " should be min 2 mss %" U16_F "...\n",
			             pcb->ssthresh,
			             2 * pcb->mss));
			pcb->ssthresh = 2 * pcb->mss;
    2836:	bfb8      	it	lt
    2838:	f8a4 104e 	strhlt.w	r1, [r4, #78]	; 0x4e
		}

		pcb->cwnd = pcb->ssthresh + 3 * pcb->mss;
    283c:	f8b4 204e 	ldrh.w	r2, [r4, #78]	; 0x4e
    2840:	440b      	add	r3, r1
    2842:	4413      	add	r3, r2
    2844:	f8a4 304c 	strh.w	r3, [r4, #76]	; 0x4c
		pcb->flags |= TF_INFR;
    2848:	7fa3      	ldrb	r3, [r4, #30]
    284a:	f043 0304 	orr.w	r3, r3, #4
    284e:	77a3      	strb	r3, [r4, #30]
	}
}
    2850:	bd10      	pop	{r4, pc}
    2852:	bf00      	nop
    2854:	000027ad 	.word	0x000027ad

00002858 <tcp_keepalive>:
 * Called by tcp_slowtmr()
 *
 * @param pcb the tcp_pcb for which to send a keepalive packet
 */
void tcp_keepalive(struct tcp_pcb *pcb)
{
    2858:	b5f0      	push	{r4, r5, r6, r7, lr}
    285a:	4604      	mov	r4, r0
	            ("tcp_keepalive: tcp_ticks %" U32_F "   pcb->tmr %" U32_F " pcb->keep_cnt_sent %" U16_F "\n",
	             tcp_ticks,
	             pcb->tmr,
	             pcb->keep_cnt_sent));

	p = tcp_output_alloc_header(pcb, 0, 0, htonl(pcb->snd_nxt - 1));
    285c:	6d00      	ldr	r0, [r0, #80]	; 0x50
    285e:	4b13      	ldr	r3, [pc, #76]	; (28ac <tcp_keepalive+0x54>)
{
    2860:	b085      	sub	sp, #20
	p = tcp_output_alloc_header(pcb, 0, 0, htonl(pcb->snd_nxt - 1));
    2862:	3801      	subs	r0, #1
    2864:	4798      	blx	r3
    2866:	4b12      	ldr	r3, [pc, #72]	; (28b0 <tcp_keepalive+0x58>)
    2868:	4602      	mov	r2, r0
    286a:	2100      	movs	r1, #0
    286c:	4620      	mov	r0, r4
    286e:	4798      	blx	r3
	if (p == NULL) {
    2870:	4605      	mov	r5, r0
    2872:	b1c8      	cbz	r0, 28a8 <tcp_keepalive+0x50>
		return;
	}
	tcphdr = (struct tcp_hdr *)p->payload;

#if CHECKSUM_GEN_TCP
	tcphdr->chksum = inet_chksum_pseudo(p, &pcb->local_ip, &pcb->remote_ip, IP_PROTO_TCP, p->tot_len);
    2874:	8903      	ldrh	r3, [r0, #8]
	tcphdr = (struct tcp_hdr *)p->payload;
    2876:	6846      	ldr	r6, [r0, #4]
	tcphdr->chksum = inet_chksum_pseudo(p, &pcb->local_ip, &pcb->remote_ip, IP_PROTO_TCP, p->tot_len);
    2878:	4f0e      	ldr	r7, [pc, #56]	; (28b4 <tcp_keepalive+0x5c>)
    287a:	9300      	str	r3, [sp, #0]
    287c:	1d22      	adds	r2, r4, #4
    287e:	4621      	mov	r1, r4
    2880:	2306      	movs	r3, #6
    2882:	9203      	str	r2, [sp, #12]
    2884:	47b8      	blx	r7

	/* Send output to IP */
#if LWIP_NETIF_HWADDRHINT
	ip_output_hinted(p, &pcb->local_ip, &pcb->remote_ip, pcb->ttl, 0, IP_PROTO_TCP, &(pcb->addr_hint));
#else  /* LWIP_NETIF_HWADDRHINT*/
	ip_output(p, &pcb->local_ip, &pcb->remote_ip, pcb->ttl, 0, IP_PROTO_TCP);
    2886:	2300      	movs	r3, #0
    2888:	2206      	movs	r2, #6
	tcphdr->chksum = inet_chksum_pseudo(p, &pcb->local_ip, &pcb->remote_ip, IP_PROTO_TCP, p->tot_len);
    288a:	8230      	strh	r0, [r6, #16]
	ip_output(p, &pcb->local_ip, &pcb->remote_ip, pcb->ttl, 0, IP_PROTO_TCP);
    288c:	e9cd 3200 	strd	r3, r2, [sp]
    2890:	4621      	mov	r1, r4
    2892:	7aa3      	ldrb	r3, [r4, #10]
    2894:	9a03      	ldr	r2, [sp, #12]
    2896:	4c08      	ldr	r4, [pc, #32]	; (28b8 <tcp_keepalive+0x60>)
    2898:	4628      	mov	r0, r5
    289a:	47a0      	blx	r4
#endif /* LWIP_NETIF_HWADDRHINT*/

	pbuf_free(p);
    289c:	4b07      	ldr	r3, [pc, #28]	; (28bc <tcp_keepalive+0x64>)
    289e:	4628      	mov	r0, r5

	LWIP_DEBUGF(TCP_DEBUG, ("tcp_keepalive: seqno %" U32_F " ackno %" U32_F ".\n", pcb->snd_nxt - 1, pcb->rcv_nxt));
}
    28a0:	b005      	add	sp, #20
    28a2:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
	pbuf_free(p);
    28a6:	4718      	bx	r3
}
    28a8:	b005      	add	sp, #20
    28aa:	bdf0      	pop	{r4, r5, r6, r7, pc}
    28ac:	00000d71 	.word	0x00000d71
    28b0:	00001f31 	.word	0x00001f31
    28b4:	00007419 	.word	0x00007419
    28b8:	00005671 	.word	0x00005671
    28bc:	00003081 	.word	0x00003081

000028c0 <tcp_zero_window_probe>:
 * Called by tcp_slowtmr()
 *
 * @param pcb the tcp_pcb for which to send a zero-window probe packet
 */
void tcp_zero_window_probe(struct tcp_pcb *pcb)
{
    28c0:	e92d 41ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, lr}
	            ("tcp_zero_window_probe: tcp_ticks %" U32_F "   pcb->tmr %" U32_F " pcb->keep_cnt_sent %" U16_F "\n",
	             tcp_ticks,
	             pcb->tmr,
	             pcb->keep_cnt_sent));

	seg = pcb->unacked;
    28c4:	6f07      	ldr	r7, [r0, #112]	; 0x70
{
    28c6:	4605      	mov	r5, r0

	if (seg == NULL) {
    28c8:	b917      	cbnz	r7, 28d0 <tcp_zero_window_probe+0x10>
		seg = pcb->unsent;
    28ca:	6ec7      	ldr	r7, [r0, #108]	; 0x6c
	}
	if (seg == NULL) {
    28cc:	2f00      	cmp	r7, #0
    28ce:	d048      	beq.n	2962 <tcp_zero_window_probe+0xa2>
		return;
	}

	is_fin = ((TCPH_FLAGS(seg->tcphdr) & TCP_FIN) != 0) && (seg->len == 0);
    28d0:	68fb      	ldr	r3, [r7, #12]
    28d2:	8998      	ldrh	r0, [r3, #12]
    28d4:	4b24      	ldr	r3, [pc, #144]	; (2968 <tcp_zero_window_probe+0xa8>)
    28d6:	4798      	blx	r3
    28d8:	f010 0401 	ands.w	r4, r0, #1
    28dc:	bf18      	it	ne
    28de:	893c      	ldrhne	r4, [r7, #8]
	/* we want to send one seqno: either FIN or data (no options) */
	len = is_fin ? 0 : 1;

	p = tcp_output_alloc_header(pcb, 0, len, seg->tcphdr->seqno);
    28e0:	68fb      	ldr	r3, [r7, #12]
	is_fin = ((TCPH_FLAGS(seg->tcphdr) & TCP_FIN) != 0) && (seg->len == 0);
    28e2:	bf1c      	itt	ne
    28e4:	fab4 f484 	clzne	r4, r4
    28e8:	0964      	lsrne	r4, r4, #5
	p = tcp_output_alloc_header(pcb, 0, len, seg->tcphdr->seqno);
    28ea:	685a      	ldr	r2, [r3, #4]
    28ec:	4b1f      	ldr	r3, [pc, #124]	; (296c <tcp_zero_window_probe+0xac>)
    28ee:	f084 0101 	eor.w	r1, r4, #1
    28f2:	4628      	mov	r0, r5
    28f4:	4798      	blx	r3
	if (p == NULL) {
    28f6:	4606      	mov	r6, r0
    28f8:	2800      	cmp	r0, #0
    28fa:	d032      	beq.n	2962 <tcp_zero_window_probe+0xa2>
		LWIP_DEBUGF(TCP_DEBUG, ("tcp_zero_window_probe: no memory for pbuf\n"));
		return;
	}
	tcphdr = (struct tcp_hdr *)p->payload;
    28fc:	f8d0 8004 	ldr.w	r8, [r0, #4]

	if (is_fin) {
    2900:	b324      	cbz	r4, 294c <tcp_zero_window_probe+0x8c>
		/* FIN segment, no data */
		TCPH_FLAGS_SET(tcphdr, TCP_ACK | TCP_FIN);
    2902:	4b1b      	ldr	r3, [pc, #108]	; (2970 <tcp_zero_window_probe+0xb0>)
    2904:	f9b8 400c 	ldrsh.w	r4, [r8, #12]
    2908:	2011      	movs	r0, #17
    290a:	4798      	blx	r3
    290c:	f424 547c 	bic.w	r4, r4, #16128	; 0x3f00
    2910:	4320      	orrs	r0, r4
    2912:	f8a8 000c 	strh.w	r0, [r8, #12]
		   Ensure we copy the first TCP data byte: */
		pbuf_copy_partial(seg->p, d, 1, seg->p->tot_len - seg->len);
	}

#if CHECKSUM_GEN_TCP
	tcphdr->chksum = inet_chksum_pseudo(p, &pcb->local_ip, &pcb->remote_ip, IP_PROTO_TCP, p->tot_len);
    2916:	8933      	ldrh	r3, [r6, #8]
    2918:	9300      	str	r3, [sp, #0]
    291a:	1d2a      	adds	r2, r5, #4
    291c:	4629      	mov	r1, r5
    291e:	4c15      	ldr	r4, [pc, #84]	; (2974 <tcp_zero_window_probe+0xb4>)
    2920:	9203      	str	r2, [sp, #12]
    2922:	2306      	movs	r3, #6
    2924:	4630      	mov	r0, r6
    2926:	47a0      	blx	r4

	/* Send output to IP */
#if LWIP_NETIF_HWADDRHINT
	ip_output_hinted(p, &pcb->local_ip, &pcb->remote_ip, pcb->ttl, 0, IP_PROTO_TCP, &(pcb->addr_hint));
#else  /* LWIP_NETIF_HWADDRHINT*/
	ip_output(p, &pcb->local_ip, &pcb->remote_ip, pcb->ttl, 0, IP_PROTO_TCP);
    2928:	2300      	movs	r3, #0
	tcphdr->chksum = inet_chksum_pseudo(p, &pcb->local_ip, &pcb->remote_ip, IP_PROTO_TCP, p->tot_len);
    292a:	f8a8 0010 	strh.w	r0, [r8, #16]
	ip_output(p, &pcb->local_ip, &pcb->remote_ip, pcb->ttl, 0, IP_PROTO_TCP);
    292e:	2206      	movs	r2, #6
    2930:	e9cd 3200 	strd	r3, r2, [sp]
    2934:	4c10      	ldr	r4, [pc, #64]	; (2978 <tcp_zero_window_probe+0xb8>)
    2936:	7aab      	ldrb	r3, [r5, #10]
    2938:	9a03      	ldr	r2, [sp, #12]
    293a:	4629      	mov	r1, r5
    293c:	4630      	mov	r0, r6
    293e:	47a0      	blx	r4
#endif /* LWIP_NETIF_HWADDRHINT*/

	pbuf_free(p);
    2940:	4b0e      	ldr	r3, [pc, #56]	; (297c <tcp_zero_window_probe+0xbc>)
    2942:	4630      	mov	r0, r6

	LWIP_DEBUGF(TCP_DEBUG,
	            ("tcp_zero_window_probe: seqno %" U32_F " ackno %" U32_F ".\n", pcb->snd_nxt - 1, pcb->rcv_nxt));
}
    2944:	b004      	add	sp, #16
    2946:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
	pbuf_free(p);
    294a:	4718      	bx	r3
		pbuf_copy_partial(seg->p, d, 1, seg->p->tot_len - seg->len);
    294c:	6878      	ldr	r0, [r7, #4]
    294e:	893a      	ldrh	r2, [r7, #8]
    2950:	8903      	ldrh	r3, [r0, #8]
    2952:	4c0b      	ldr	r4, [pc, #44]	; (2980 <tcp_zero_window_probe+0xc0>)
    2954:	1a9b      	subs	r3, r3, r2
    2956:	b29b      	uxth	r3, r3
    2958:	2201      	movs	r2, #1
    295a:	f108 0114 	add.w	r1, r8, #20
    295e:	47a0      	blx	r4
    2960:	e7d9      	b.n	2916 <tcp_zero_window_probe+0x56>
}
    2962:	b004      	add	sp, #16
    2964:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    2968:	00000d6b 	.word	0x00000d6b
    296c:	00001f31 	.word	0x00001f31
    2970:	00000d65 	.word	0x00000d65
    2974:	00007419 	.word	0x00007419
    2978:	00005671 	.word	0x00005671
    297c:	00003081 	.word	0x00003081
    2980:	00003321 	.word	0x00003321

00002984 <ip_reass_free_complete_datagram>:
 * @param ipr datagram to free
 * @param prev the previous datagram in the linked list
 * @return the number of pbufs freed
 */
static int ip_reass_free_complete_datagram(struct ip_reassdata *ipr, struct ip_reassdata *prev)
{
    2984:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
		LWIP_ASSERT("prev->next == ipr", prev->next == ipr);
	}

	snmp_inc_ipreasmfails();
#if LWIP_ICMP
	iprh = (struct ip_reass_helper *)ipr->p->payload;
    2988:	6846      	ldr	r6, [r0, #4]
    298a:	6873      	ldr	r3, [r6, #4]
	if (iprh->start == 0) {
    298c:	889a      	ldrh	r2, [r3, #4]
{
    298e:	4604      	mov	r4, r0
    2990:	460f      	mov	r7, r1
	if (iprh->start == 0) {
    2992:	2a00      	cmp	r2, #0
    2994:	d12d      	bne.n	29f2 <ip_reass_free_complete_datagram+0x6e>
		/* The first fragment was received, send ICMP time exceeded. */
		/* First, de-queue the first pbuf from r->p. */
		p      = ipr->p;
		ipr->p = iprh->next_pbuf;
    2996:	681a      	ldr	r2, [r3, #0]
    2998:	6042      	str	r2, [r0, #4]
		/* Then, copy the original header into it. */
		SMEMCPY(p->payload, &ipr->iphdr, IP_HLEN);
    299a:	f100 011c 	add.w	r1, r0, #28
    299e:	f100 0208 	add.w	r2, r0, #8
    29a2:	f852 0b04 	ldr.w	r0, [r2], #4
    29a6:	f843 0b04 	str.w	r0, [r3], #4
    29aa:	428a      	cmp	r2, r1
    29ac:	d1f9      	bne.n	29a2 <ip_reass_free_complete_datagram+0x1e>
		icmp_time_exceeded(p, ICMP_TE_FRAG);
    29ae:	4b17      	ldr	r3, [pc, #92]	; (2a0c <ip_reass_free_complete_datagram+0x88>)
    29b0:	2101      	movs	r1, #1
    29b2:	4630      	mov	r0, r6
    29b4:	4798      	blx	r3
		clen = pbuf_clen(p);
    29b6:	4b16      	ldr	r3, [pc, #88]	; (2a10 <ip_reass_free_complete_datagram+0x8c>)
    29b8:	4630      	mov	r0, r6
    29ba:	4798      	blx	r3
		LWIP_ASSERT("pbufs_freed + clen <= 0xffff", pbufs_freed + clen <= 0xffff);
		pbufs_freed += clen;
		pbuf_free(p);
    29bc:	4b15      	ldr	r3, [pc, #84]	; (2a14 <ip_reass_free_complete_datagram+0x90>)
		pbufs_freed += clen;
    29be:	b285      	uxth	r5, r0
		pbuf_free(p);
    29c0:	4630      	mov	r0, r6
    29c2:	4798      	blx	r3
	}
#endif /* LWIP_ICMP */

	/* First, free all received pbufs.  The individual pbufs need to be released
	   separately as they have not yet been chained */
	p = ipr->p;
    29c4:	6866      	ldr	r6, [r4, #4]
		struct pbuf *pcur;
		iprh = (struct ip_reass_helper *)p->payload;
		pcur = p;
		/* get the next pointer before freeing */
		p    = iprh->next_pbuf;
		clen = pbuf_clen(pcur);
    29c6:	f8df 8048 	ldr.w	r8, [pc, #72]	; 2a10 <ip_reass_free_complete_datagram+0x8c>
		LWIP_ASSERT("pbufs_freed + clen <= 0xffff", pbufs_freed + clen <= 0xffff);
		pbufs_freed += clen;
		pbuf_free(pcur);
    29ca:	f8df 9048 	ldr.w	r9, [pc, #72]	; 2a14 <ip_reass_free_complete_datagram+0x90>
	while (p != NULL) {
    29ce:	b996      	cbnz	r6, 29f6 <ip_reass_free_complete_datagram+0x72>
 */
static void ip_reass_dequeue_datagram(struct ip_reassdata *ipr, struct ip_reassdata *prev)
{

	/* dequeue the reass struct  */
	if (reassdatagrams == ipr) {
    29d0:	4e11      	ldr	r6, [pc, #68]	; (2a18 <ip_reass_free_complete_datagram+0x94>)
		/* it was the first in the list */
		reassdatagrams = ipr->next;
    29d2:	6823      	ldr	r3, [r4, #0]
	if (reassdatagrams == ipr) {
    29d4:	6832      	ldr	r2, [r6, #0]
    29d6:	4294      	cmp	r4, r2
		reassdatagrams = ipr->next;
    29d8:	bf0c      	ite	eq
    29da:	6033      	streq	r3, [r6, #0]
	} else {
		/* it wasn't the first, so it must have a valid 'prev' */
		LWIP_ASSERT("sanity check linked list", prev != NULL);
		prev->next = ipr->next;
    29dc:	603b      	strne	r3, [r7, #0]
	}

	/* now we can free the ip_reass struct */
	memp_free(MEMP_REASSDATA, ipr);
    29de:	4621      	mov	r1, r4
    29e0:	4b0e      	ldr	r3, [pc, #56]	; (2a1c <ip_reass_free_complete_datagram+0x98>)
    29e2:	2004      	movs	r0, #4
    29e4:	4798      	blx	r3
	ip_reass_pbufcount -= pbufs_freed;
    29e6:	88b3      	ldrh	r3, [r6, #4]
    29e8:	1b5b      	subs	r3, r3, r5
    29ea:	80b3      	strh	r3, [r6, #4]
}
    29ec:	4628      	mov	r0, r5
    29ee:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
	u16_t                   pbufs_freed = 0;
    29f2:	2500      	movs	r5, #0
    29f4:	e7e6      	b.n	29c4 <ip_reass_free_complete_datagram+0x40>
		iprh = (struct ip_reass_helper *)p->payload;
    29f6:	6873      	ldr	r3, [r6, #4]
		clen = pbuf_clen(pcur);
    29f8:	4630      	mov	r0, r6
		p    = iprh->next_pbuf;
    29fa:	f8d3 a000 	ldr.w	sl, [r3]
		clen = pbuf_clen(pcur);
    29fe:	47c0      	blx	r8
		pbufs_freed += clen;
    2a00:	4428      	add	r0, r5
    2a02:	b285      	uxth	r5, r0
		pbuf_free(pcur);
    2a04:	4630      	mov	r0, r6
    2a06:	47c8      	blx	r9
		p    = iprh->next_pbuf;
    2a08:	4656      	mov	r6, sl
    2a0a:	e7e0      	b.n	29ce <ip_reass_free_complete_datagram+0x4a>
    2a0c:	00000d59 	.word	0x00000d59
    2a10:	0000323d 	.word	0x0000323d
    2a14:	00003081 	.word	0x00003081
    2a18:	2000a4d8 	.word	0x2000a4d8
    2a1c:	00004b49 	.word	0x00004b49

00002a20 <ip_reass_remove_oldest_datagram>:
{
    2a20:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
		r               = reassdatagrams;
    2a24:	f8df 8068 	ldr.w	r8, [pc, #104]	; 2a90 <ip_reass_remove_oldest_datagram+0x70>
			pbufs_freed_current = ip_reass_free_complete_datagram(oldest, prev);
    2a28:	f8df 9068 	ldr.w	r9, [pc, #104]	; 2a94 <ip_reass_remove_oldest_datagram+0x74>
{
    2a2c:	4605      	mov	r5, r0
    2a2e:	460f      	mov	r7, r1
	int                  pbufs_freed = 0, pbufs_freed_current;
    2a30:	2600      	movs	r6, #0
		other_datagrams = 0;
    2a32:	2400      	movs	r4, #0
		r               = reassdatagrams;
    2a34:	f8d8 3000 	ldr.w	r3, [r8]
		prev            = NULL;
    2a38:	4621      	mov	r1, r4
		oldest          = NULL;
    2a3a:	4620      	mov	r0, r4
		while (r != NULL) {
    2a3c:	b94b      	cbnz	r3, 2a52 <ip_reass_remove_oldest_datagram+0x32>
		if (oldest != NULL) {
    2a3e:	b108      	cbz	r0, 2a44 <ip_reass_remove_oldest_datagram+0x24>
			pbufs_freed_current = ip_reass_free_complete_datagram(oldest, prev);
    2a40:	47c8      	blx	r9
			pbufs_freed += pbufs_freed_current;
    2a42:	4406      	add	r6, r0
	} while ((pbufs_freed < pbufs_needed) && (other_datagrams > 1));
    2a44:	42be      	cmp	r6, r7
    2a46:	da01      	bge.n	2a4c <ip_reass_remove_oldest_datagram+0x2c>
    2a48:	2c01      	cmp	r4, #1
    2a4a:	dcf2      	bgt.n	2a32 <ip_reass_remove_oldest_datagram+0x12>
}
    2a4c:	4630      	mov	r0, r6
    2a4e:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
			if (!IP_ADDRESSES_AND_ID_MATCH(&r->iphdr, fraghdr)) {
    2a52:	f8d5 c00c 	ldr.w	ip, [r5, #12]
    2a56:	695a      	ldr	r2, [r3, #20]
    2a58:	4562      	cmp	r2, ip
    2a5a:	d109      	bne.n	2a70 <ip_reass_remove_oldest_datagram+0x50>
    2a5c:	f8d5 c010 	ldr.w	ip, [r5, #16]
    2a60:	699a      	ldr	r2, [r3, #24]
    2a62:	4562      	cmp	r2, ip
    2a64:	d104      	bne.n	2a70 <ip_reass_remove_oldest_datagram+0x50>
    2a66:	f8b3 c00c 	ldrh.w	ip, [r3, #12]
    2a6a:	88aa      	ldrh	r2, [r5, #4]
    2a6c:	4594      	cmp	ip, r2
    2a6e:	d007      	beq.n	2a80 <ip_reass_remove_oldest_datagram+0x60>
				other_datagrams++;
    2a70:	3401      	adds	r4, #1
				if (oldest == NULL) {
    2a72:	b158      	cbz	r0, 2a8c <ip_reass_remove_oldest_datagram+0x6c>
				} else if (r->timer <= oldest->timer) {
    2a74:	f893 c01f 	ldrb.w	ip, [r3, #31]
    2a78:	7fc2      	ldrb	r2, [r0, #31]
    2a7a:	4594      	cmp	ip, r2
    2a7c:	bf98      	it	ls
    2a7e:	4618      	movls	r0, r3
			if (r->next != NULL) {
    2a80:	681a      	ldr	r2, [r3, #0]
    2a82:	2a00      	cmp	r2, #0
    2a84:	bf18      	it	ne
    2a86:	4619      	movne	r1, r3
    2a88:	4613      	mov	r3, r2
    2a8a:	e7d7      	b.n	2a3c <ip_reass_remove_oldest_datagram+0x1c>
    2a8c:	4618      	mov	r0, r3
    2a8e:	e7f7      	b.n	2a80 <ip_reass_remove_oldest_datagram+0x60>
    2a90:	2000a4d8 	.word	0x2000a4d8
    2a94:	00002985 	.word	0x00002985

00002a98 <ipfrag_free_pbuf_custom>:
}

/** Free-callback function to free a 'struct pbuf_custom_ref', called by
 * pbuf_free. */
static void ipfrag_free_pbuf_custom(struct pbuf *p)
{
    2a98:	b510      	push	{r4, lr}
    2a9a:	4604      	mov	r4, r0
	struct pbuf_custom_ref *pcr = (struct pbuf_custom_ref *)p;
	LWIP_ASSERT("pcr != NULL", pcr != NULL);
	LWIP_ASSERT("pcr == p", (void *)pcr == (void *)p);
	if (pcr->original != NULL) {
    2a9c:	6940      	ldr	r0, [r0, #20]
    2a9e:	b108      	cbz	r0, 2aa4 <ipfrag_free_pbuf_custom+0xc>
		pbuf_free(pcr->original);
    2aa0:	4b03      	ldr	r3, [pc, #12]	; (2ab0 <ipfrag_free_pbuf_custom+0x18>)
    2aa2:	4798      	blx	r3
	memp_free(MEMP_FRAG_PBUF, p);
    2aa4:	4621      	mov	r1, r4
    2aa6:	4b03      	ldr	r3, [pc, #12]	; (2ab4 <ipfrag_free_pbuf_custom+0x1c>)
	}
	ip_frag_free_pbuf_custom_ref(pcr);
}
    2aa8:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	memp_free(MEMP_FRAG_PBUF, p);
    2aac:	2005      	movs	r0, #5
    2aae:	4718      	bx	r3
    2ab0:	00003081 	.word	0x00003081
    2ab4:	00004b49 	.word	0x00004b49

00002ab8 <ip_reass_tmr>:
	r = reassdatagrams;
    2ab8:	4b09      	ldr	r3, [pc, #36]	; (2ae0 <ip_reass_tmr+0x28>)
{
    2aba:	b570      	push	{r4, r5, r6, lr}
	r = reassdatagrams;
    2abc:	6818      	ldr	r0, [r3, #0]
			ip_reass_free_complete_datagram(tmp, prev);
    2abe:	4d09      	ldr	r5, [pc, #36]	; (2ae4 <ip_reass_tmr+0x2c>)
	struct ip_reassdata *r, *prev = NULL;
    2ac0:	2400      	movs	r4, #0
	while (r != NULL) {
    2ac2:	b900      	cbnz	r0, 2ac6 <ip_reass_tmr+0xe>
}
    2ac4:	bd70      	pop	{r4, r5, r6, pc}
		if (r->timer > 0) {
    2ac6:	7fc3      	ldrb	r3, [r0, #31]
			r    = r->next;
    2ac8:	6806      	ldr	r6, [r0, #0]
		if (r->timer > 0) {
    2aca:	b123      	cbz	r3, 2ad6 <ip_reass_tmr+0x1e>
			r->timer--;
    2acc:	3b01      	subs	r3, #1
    2ace:	77c3      	strb	r3, [r0, #31]
			ip_reass_free_complete_datagram(tmp, prev);
    2ad0:	4604      	mov	r4, r0
    2ad2:	4630      	mov	r0, r6
    2ad4:	e7f5      	b.n	2ac2 <ip_reass_tmr+0xa>
    2ad6:	4621      	mov	r1, r4
    2ad8:	47a8      	blx	r5
    2ada:	4620      	mov	r0, r4
    2adc:	e7f8      	b.n	2ad0 <ip_reass_tmr+0x18>
    2ade:	bf00      	nop
    2ae0:	2000a4d8 	.word	0x2000a4d8
    2ae4:	00002985 	.word	0x00002985

00002ae8 <ip_reass>:
{
    2ae8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	fraghdr = (struct ip_hdr *)p->payload;
    2aec:	6844      	ldr	r4, [r0, #4]
	if ((IPH_HL(fraghdr) * 4) != IP_HLEN) {
    2aee:	7823      	ldrb	r3, [r4, #0]
    2af0:	f003 030f 	and.w	r3, r3, #15
    2af4:	2b05      	cmp	r3, #5
{
    2af6:	b085      	sub	sp, #20
    2af8:	4605      	mov	r5, r0
	if ((IPH_HL(fraghdr) * 4) != IP_HLEN) {
    2afa:	f040 808f 	bne.w	2c1c <ip_reass+0x134>
	offset = (ntohs(IPH_OFFSET(fraghdr)) & IP_OFFMASK) * 8;
    2afe:	4fa8      	ldr	r7, [pc, #672]	; (2da0 <ip_reass+0x2b8>)
    2b00:	88e0      	ldrh	r0, [r4, #6]
	clen = pbuf_clen(p);
    2b02:	f8df 92c4 	ldr.w	r9, [pc, #708]	; 2dc8 <ip_reass+0x2e0>
	if ((ip_reass_pbufcount + clen) > IP_REASS_MAX_PBUFS) {
    2b06:	f8df a2a4 	ldr.w	sl, [pc, #676]	; 2dac <ip_reass+0x2c4>
	offset = (ntohs(IPH_OFFSET(fraghdr)) & IP_OFFMASK) * 8;
    2b0a:	47b8      	blx	r7
    2b0c:	9002      	str	r0, [sp, #8]
	len    = ntohs(IPH_LEN(fraghdr)) - IPH_HL(fraghdr) * 4;
    2b0e:	8860      	ldrh	r0, [r4, #2]
    2b10:	47b8      	blx	r7
    2b12:	9003      	str	r0, [sp, #12]
	clen = pbuf_clen(p);
    2b14:	4628      	mov	r0, r5
	len    = ntohs(IPH_LEN(fraghdr)) - IPH_HL(fraghdr) * 4;
    2b16:	f894 8000 	ldrb.w	r8, [r4]
	clen = pbuf_clen(p);
    2b1a:	47c8      	blx	r9
	if ((ip_reass_pbufcount + clen) > IP_REASS_MAX_PBUFS) {
    2b1c:	f8ba 3004 	ldrh.w	r3, [sl, #4]
    2b20:	f8cd 9004 	str.w	r9, [sp, #4]
    2b24:	4403      	add	r3, r0
    2b26:	2b0a      	cmp	r3, #10
	clen = pbuf_clen(p);
    2b28:	4606      	mov	r6, r0
	if ((ip_reass_pbufcount + clen) > IP_REASS_MAX_PBUFS) {
    2b2a:	dc6d      	bgt.n	2c08 <ip_reass+0x120>
	for (ipr = reassdatagrams; ipr != NULL; ipr = ipr->next) {
    2b2c:	f8da 9000 	ldr.w	r9, [sl]
	struct ip_reassdata *   ipr_prev = NULL;
    2b30:	f04f 0a00 	mov.w	sl, #0
	for (ipr = reassdatagrams; ipr != NULL; ipr = ipr->next) {
    2b34:	f1b9 0f00 	cmp.w	r9, #0
    2b38:	d175      	bne.n	2c26 <ip_reass+0x13e>
	ipr = (struct ip_reassdata *)memp_malloc(MEMP_REASSDATA);
    2b3a:	f8df b290 	ldr.w	fp, [pc, #656]	; 2dcc <ip_reass+0x2e4>
    2b3e:	2004      	movs	r0, #4
    2b40:	47d8      	blx	fp
	if (ipr == NULL) {
    2b42:	4681      	mov	r9, r0
    2b44:	b950      	cbnz	r0, 2b5c <ip_reass+0x74>
		if (ip_reass_remove_oldest_datagram(fraghdr, clen) >= clen) {
    2b46:	4b97      	ldr	r3, [pc, #604]	; (2da4 <ip_reass+0x2bc>)
    2b48:	4631      	mov	r1, r6
    2b4a:	4620      	mov	r0, r4
    2b4c:	4798      	blx	r3
    2b4e:	4286      	cmp	r6, r0
    2b50:	dc64      	bgt.n	2c1c <ip_reass+0x134>
			ipr = (struct ip_reassdata *)memp_malloc(MEMP_REASSDATA);
    2b52:	2004      	movs	r0, #4
    2b54:	47d8      	blx	fp
		if (ipr == NULL)
    2b56:	4681      	mov	r9, r0
    2b58:	2800      	cmp	r0, #0
    2b5a:	d05f      	beq.n	2c1c <ip_reass+0x134>
	memset(ipr, 0, sizeof(struct ip_reassdata));
    2b5c:	221c      	movs	r2, #28
    2b5e:	2100      	movs	r1, #0
    2b60:	4b91      	ldr	r3, [pc, #580]	; (2da8 <ip_reass+0x2c0>)
    2b62:	f109 0004 	add.w	r0, r9, #4
    2b66:	4798      	blx	r3
	ipr->timer = IP_REASS_MAXAGE;
    2b68:	2203      	movs	r2, #3
    2b6a:	f889 201f 	strb.w	r2, [r9, #31]
	ipr->next      = reassdatagrams;
    2b6e:	4a8f      	ldr	r2, [pc, #572]	; (2dac <ip_reass+0x2c4>)
    2b70:	6811      	ldr	r1, [r2, #0]
    2b72:	f8c9 1000 	str.w	r1, [r9]
	reassdatagrams = ipr;
    2b76:	f8c2 9000 	str.w	r9, [r2]
	SMEMCPY(&(ipr->iphdr), fraghdr, IP_HLEN);
    2b7a:	f109 0108 	add.w	r1, r9, #8
    2b7e:	4622      	mov	r2, r4
    2b80:	f104 0014 	add.w	r0, r4, #20
    2b84:	f852 cb04 	ldr.w	ip, [r2], #4
    2b88:	f841 cb04 	str.w	ip, [r1], #4
    2b8c:	4282      	cmp	r2, r0
    2b8e:	d1f9      	bne.n	2b84 <ip_reass+0x9c>
	ip_reass_pbufcount += clen;
    2b90:	f8df b218 	ldr.w	fp, [pc, #536]	; 2dac <ip_reass+0x2c4>
    2b94:	f8bb 0004 	ldrh.w	r0, [fp, #4]
    2b98:	4406      	add	r6, r0
    2b9a:	f8ab 6004 	strh.w	r6, [fp, #4]
	if ((IPH_OFFSET(fraghdr) & PP_NTOHS(IP_MF)) == 0) {
    2b9e:	88e2      	ldrh	r2, [r4, #6]
    2ba0:	0693      	lsls	r3, r2, #26
    2ba2:	d40f      	bmi.n	2bc4 <ip_reass+0xdc>
	len    = ntohs(IPH_LEN(fraghdr)) - IPH_HL(fraghdr) * 4;
    2ba4:	9b03      	ldr	r3, [sp, #12]
		ipr->flags |= IP_REASS_FLAG_LASTFRAG;
    2ba6:	f899 201e 	ldrb.w	r2, [r9, #30]
	len    = ntohs(IPH_LEN(fraghdr)) - IPH_HL(fraghdr) * 4;
    2baa:	f008 000f 	and.w	r0, r8, #15
    2bae:	eba3 0080 	sub.w	r0, r3, r0, lsl #2
		ipr->datagram_len = offset + len;
    2bb2:	9b02      	ldr	r3, [sp, #8]
		ipr->flags |= IP_REASS_FLAG_LASTFRAG;
    2bb4:	f042 0201 	orr.w	r2, r2, #1
		ipr->datagram_len = offset + len;
    2bb8:	eb00 00c3 	add.w	r0, r0, r3, lsl #3
		ipr->flags |= IP_REASS_FLAG_LASTFRAG;
    2bbc:	f889 201e 	strb.w	r2, [r9, #30]
		ipr->datagram_len = offset + len;
    2bc0:	f8a9 001c 	strh.w	r0, [r9, #28]
	fraghdr = (struct ip_hdr *)new_p->payload;
    2bc4:	686e      	ldr	r6, [r5, #4]
	len     = ntohs(IPH_LEN(fraghdr)) - IPH_HL(fraghdr) * 4;
    2bc6:	8870      	ldrh	r0, [r6, #2]
    2bc8:	47b8      	blx	r7
    2bca:	7834      	ldrb	r4, [r6, #0]
    2bcc:	f004 040f 	and.w	r4, r4, #15
    2bd0:	eba0 0484 	sub.w	r4, r0, r4, lsl #2
	offset  = (ntohs(IPH_OFFSET(fraghdr)) & IP_OFFMASK) * 8;
    2bd4:	88f0      	ldrh	r0, [r6, #6]
    2bd6:	47b8      	blx	r7
    2bd8:	f3c0 000c 	ubfx	r0, r0, #0, #13
	iprh            = (struct ip_reass_helper *)new_p->payload;
    2bdc:	6869      	ldr	r1, [r5, #4]
	for (q = ipr->p; q != NULL;) {
    2bde:	f8d9 6004 	ldr.w	r6, [r9, #4]
	offset  = (ntohs(IPH_OFFSET(fraghdr)) & IP_OFFMASK) * 8;
    2be2:	00c0      	lsls	r0, r0, #3
	len     = ntohs(IPH_LEN(fraghdr)) - IPH_HL(fraghdr) * 4;
    2be4:	b2a4      	uxth	r4, r4
	iprh->next_pbuf = NULL;
    2be6:	2200      	movs	r2, #0
	iprh->end       = offset + len;
    2be8:	4404      	add	r4, r0
	iprh->next_pbuf = NULL;
    2bea:	700a      	strb	r2, [r1, #0]
    2bec:	704a      	strb	r2, [r1, #1]
    2bee:	708a      	strb	r2, [r1, #2]
    2bf0:	70ca      	strb	r2, [r1, #3]
	iprh->start     = offset;
    2bf2:	8088      	strh	r0, [r1, #4]
	iprh->end       = offset + len;
    2bf4:	fa1f fe84 	uxth.w	lr, r4
    2bf8:	80cc      	strh	r4, [r1, #6]
	int                     valid = 1;
    2bfa:	2301      	movs	r3, #1
	for (q = ipr->p; q != NULL;) {
    2bfc:	bb3e      	cbnz	r6, 2c4e <ip_reass+0x166>
		if (iprh_prev != NULL) {
    2bfe:	2a00      	cmp	r2, #0
    2c00:	d173      	bne.n	2cea <ip_reass+0x202>
			ipr->p = new_p;
    2c02:	f8c9 5004 	str.w	r5, [r9, #4]
    2c06:	e02f      	b.n	2c68 <ip_reass+0x180>
		if (!ip_reass_remove_oldest_datagram(fraghdr, clen) || ((ip_reass_pbufcount + clen) > IP_REASS_MAX_PBUFS))
    2c08:	4601      	mov	r1, r0
    2c0a:	4b66      	ldr	r3, [pc, #408]	; (2da4 <ip_reass+0x2bc>)
    2c0c:	4620      	mov	r0, r4
    2c0e:	4798      	blx	r3
    2c10:	b120      	cbz	r0, 2c1c <ip_reass+0x134>
    2c12:	f8ba 3004 	ldrh.w	r3, [sl, #4]
    2c16:	4433      	add	r3, r6
    2c18:	2b0a      	cmp	r3, #10
    2c1a:	dd87      	ble.n	2b2c <ip_reass+0x44>
	pbuf_free(p);
    2c1c:	4b64      	ldr	r3, [pc, #400]	; (2db0 <ip_reass+0x2c8>)
    2c1e:	4628      	mov	r0, r5
    2c20:	4798      	blx	r3
	return NULL;
    2c22:	2400      	movs	r4, #0
    2c24:	e09d      	b.n	2d62 <ip_reass+0x27a>
		if (IP_ADDRESSES_AND_ID_MATCH(&ipr->iphdr, fraghdr)) {
    2c26:	68e2      	ldr	r2, [r4, #12]
    2c28:	f8d9 1014 	ldr.w	r1, [r9, #20]
    2c2c:	4291      	cmp	r1, r2
    2c2e:	d10a      	bne.n	2c46 <ip_reass+0x15e>
    2c30:	6922      	ldr	r2, [r4, #16]
    2c32:	f8d9 1018 	ldr.w	r1, [r9, #24]
    2c36:	4291      	cmp	r1, r2
    2c38:	d105      	bne.n	2c46 <ip_reass+0x15e>
    2c3a:	f8b9 100c 	ldrh.w	r1, [r9, #12]
    2c3e:	88a2      	ldrh	r2, [r4, #4]
    2c40:	4291      	cmp	r1, r2
    2c42:	f000 8092 	beq.w	2d6a <ip_reass+0x282>
	for (ipr = reassdatagrams; ipr != NULL; ipr = ipr->next) {
    2c46:	46ca      	mov	sl, r9
    2c48:	f8d9 9000 	ldr.w	r9, [r9]
    2c4c:	e772      	b.n	2b34 <ip_reass+0x4c>
		iprh_tmp = (struct ip_reass_helper *)q->payload;
    2c4e:	6877      	ldr	r7, [r6, #4]
		if (iprh->start < iprh_tmp->start) {
    2c50:	88bc      	ldrh	r4, [r7, #4]
    2c52:	42a0      	cmp	r0, r4
    2c54:	d23d      	bcs.n	2cd2 <ip_reass+0x1ea>
			iprh->next_pbuf = q;
    2c56:	600e      	str	r6, [r1, #0]
			if (iprh_prev != NULL) {
    2c58:	2a00      	cmp	r2, #0
    2c5a:	d0d2      	beq.n	2c02 <ip_reass+0x11a>
				if ((iprh->start < iprh_prev->end) || (iprh->end > iprh_tmp->start)) {
    2c5c:	88d6      	ldrh	r6, [r2, #6]
    2c5e:	4286      	cmp	r6, r0
    2c60:	d851      	bhi.n	2d06 <ip_reass+0x21e>
    2c62:	45a6      	cmp	lr, r4
    2c64:	d84f      	bhi.n	2d06 <ip_reass+0x21e>
				iprh_prev->next_pbuf = new_p;
    2c66:	6015      	str	r5, [r2, #0]
	if ((ipr->flags & IP_REASS_FLAG_LASTFRAG) != 0) {
    2c68:	f899 201e 	ldrb.w	r2, [r9, #30]
    2c6c:	f012 0401 	ands.w	r4, r2, #1
    2c70:	d077      	beq.n	2d62 <ip_reass+0x27a>
		if (valid) {
    2c72:	2b00      	cmp	r3, #0
    2c74:	d0d5      	beq.n	2c22 <ip_reass+0x13a>
			if (((struct ip_reass_helper *)ipr->p->payload)->start != 0) {
    2c76:	f8d9 2004 	ldr.w	r2, [r9, #4]
    2c7a:	6854      	ldr	r4, [r2, #4]
    2c7c:	88a2      	ldrh	r2, [r4, #4]
    2c7e:	2a00      	cmp	r2, #0
    2c80:	d1cf      	bne.n	2c22 <ip_reass+0x13a>
				q         = iprh->next_pbuf;
    2c82:	680a      	ldr	r2, [r1, #0]
				while (q != NULL) {
    2c84:	2a00      	cmp	r2, #0
    2c86:	d136      	bne.n	2cf6 <ip_reass+0x20e>
		ipr->datagram_len += IP_HLEN;
    2c88:	f8b9 201c 	ldrh.w	r2, [r9, #28]
		r = ((struct ip_reass_helper *)ipr->p->payload)->next_pbuf;
    2c8c:	6825      	ldr	r5, [r4, #0]
		ipr->datagram_len += IP_HLEN;
    2c8e:	3214      	adds	r2, #20
    2c90:	f8a9 201c 	strh.w	r2, [r9, #28]
		SMEMCPY(fraghdr, &ipr->iphdr, IP_HLEN);
    2c94:	4621      	mov	r1, r4
    2c96:	f109 0208 	add.w	r2, r9, #8
    2c9a:	f109 001c 	add.w	r0, r9, #28
    2c9e:	f852 6b04 	ldr.w	r6, [r2], #4
    2ca2:	f841 6b04 	str.w	r6, [r1], #4
    2ca6:	4282      	cmp	r2, r0
    2ca8:	d1f9      	bne.n	2c9e <ip_reass+0x1b6>
		IPH_LEN_SET(fraghdr, htons(ipr->datagram_len));
    2caa:	4a42      	ldr	r2, [pc, #264]	; (2db4 <ip_reass+0x2cc>)
    2cac:	f8b9 001c 	ldrh.w	r0, [r9, #28]
			pbuf_header(r, -IP_HLEN);
    2cb0:	4f41      	ldr	r7, [pc, #260]	; (2db8 <ip_reass+0x2d0>)
			pbuf_cat(p, r);
    2cb2:	4e42      	ldr	r6, [pc, #264]	; (2dbc <ip_reass+0x2d4>)
		IPH_LEN_SET(fraghdr, htons(ipr->datagram_len));
    2cb4:	4790      	blx	r2
		IPH_OFFSET_SET(fraghdr, 0);
    2cb6:	2200      	movs	r2, #0
		IPH_LEN_SET(fraghdr, htons(ipr->datagram_len));
    2cb8:	8060      	strh	r0, [r4, #2]
		IPH_OFFSET_SET(fraghdr, 0);
    2cba:	71a2      	strb	r2, [r4, #6]
    2cbc:	71e2      	strb	r2, [r4, #7]
		IPH_CHKSUM_SET(fraghdr, 0);
    2cbe:	72a2      	strb	r2, [r4, #10]
    2cc0:	72e2      	strb	r2, [r4, #11]
		IPH_CHKSUM_SET(fraghdr, inet_chksum(fraghdr, IP_HLEN));
    2cc2:	4620      	mov	r0, r4
    2cc4:	4a3e      	ldr	r2, [pc, #248]	; (2dc0 <ip_reass+0x2d8>)
    2cc6:	2114      	movs	r1, #20
    2cc8:	4790      	blx	r2
    2cca:	8160      	strh	r0, [r4, #10]
		p = ipr->p;
    2ccc:	f8d9 4004 	ldr.w	r4, [r9, #4]
		while (r != NULL) {
    2cd0:	e02d      	b.n	2d2e <ip_reass+0x246>
		} else if (iprh->start == iprh_tmp->start) {
    2cd2:	d018      	beq.n	2d06 <ip_reass+0x21e>
		} else if (iprh->start < iprh_tmp->end) {
    2cd4:	88fe      	ldrh	r6, [r7, #6]
    2cd6:	4286      	cmp	r6, r0
    2cd8:	d815      	bhi.n	2d06 <ip_reass+0x21e>
			if (iprh_prev != NULL) {
    2cda:	b11a      	cbz	r2, 2ce4 <ip_reass+0x1fc>
				if (iprh_prev->end != iprh_tmp->start) {
    2cdc:	88d2      	ldrh	r2, [r2, #6]
					valid = 0;
    2cde:	42a2      	cmp	r2, r4
    2ce0:	bf18      	it	ne
    2ce2:	2300      	movne	r3, #0
		q         = iprh_tmp->next_pbuf;
    2ce4:	683e      	ldr	r6, [r7, #0]
    2ce6:	463a      	mov	r2, r7
    2ce8:	e788      	b.n	2bfc <ip_reass+0x114>
			iprh_prev->next_pbuf = new_p;
    2cea:	6015      	str	r5, [r2, #0]
			if (iprh_prev->end != iprh->start) {
    2cec:	88d2      	ldrh	r2, [r2, #6]
				valid = 0;
    2cee:	4282      	cmp	r2, r0
    2cf0:	bf18      	it	ne
    2cf2:	2300      	movne	r3, #0
    2cf4:	e7b8      	b.n	2c68 <ip_reass+0x180>
					iprh = (struct ip_reass_helper *)q->payload;
    2cf6:	6850      	ldr	r0, [r2, #4]
					if (iprh_prev->end != iprh->start) {
    2cf8:	88c9      	ldrh	r1, [r1, #6]
    2cfa:	8882      	ldrh	r2, [r0, #4]
    2cfc:	4291      	cmp	r1, r2
    2cfe:	d190      	bne.n	2c22 <ip_reass+0x13a>
					q         = iprh->next_pbuf;
    2d00:	6802      	ldr	r2, [r0, #0]
    2d02:	4601      	mov	r1, r0
    2d04:	e7be      	b.n	2c84 <ip_reass+0x19c>
	ip_reass_pbufcount -= pbuf_clen(new_p);
    2d06:	9b01      	ldr	r3, [sp, #4]
    2d08:	4628      	mov	r0, r5
    2d0a:	4798      	blx	r3
    2d0c:	f8bb 3004 	ldrh.w	r3, [fp, #4]
    2d10:	1a18      	subs	r0, r3, r0
    2d12:	f8ab 0004 	strh.w	r0, [fp, #4]
	pbuf_free(new_p);
    2d16:	e781      	b.n	2c1c <ip_reass+0x134>
			iprh = (struct ip_reass_helper *)r->payload;
    2d18:	f8d5 8004 	ldr.w	r8, [r5, #4]
			pbuf_header(r, -IP_HLEN);
    2d1c:	f06f 0113 	mvn.w	r1, #19
    2d20:	4628      	mov	r0, r5
    2d22:	47b8      	blx	r7
			pbuf_cat(p, r);
    2d24:	4629      	mov	r1, r5
    2d26:	4620      	mov	r0, r4
    2d28:	47b0      	blx	r6
			r = iprh->next_pbuf;
    2d2a:	f8d8 5000 	ldr.w	r5, [r8]
		while (r != NULL) {
    2d2e:	2d00      	cmp	r5, #0
    2d30:	d1f2      	bne.n	2d18 <ip_reass+0x230>
	if (reassdatagrams == ipr) {
    2d32:	f8db 1000 	ldr.w	r1, [fp]
		reassdatagrams = ipr->next;
    2d36:	f8d9 2000 	ldr.w	r2, [r9]
	memp_free(MEMP_REASSDATA, ipr);
    2d3a:	4b22      	ldr	r3, [pc, #136]	; (2dc4 <ip_reass+0x2dc>)
	if (reassdatagrams == ipr) {
    2d3c:	4589      	cmp	r9, r1
		prev->next = ipr->next;
    2d3e:	bf18      	it	ne
    2d40:	f8ca 2000 	strne.w	r2, [sl]
	memp_free(MEMP_REASSDATA, ipr);
    2d44:	4649      	mov	r1, r9
    2d46:	f04f 0004 	mov.w	r0, #4
		reassdatagrams = ipr->next;
    2d4a:	bf08      	it	eq
    2d4c:	f8cb 2000 	streq.w	r2, [fp]
	memp_free(MEMP_REASSDATA, ipr);
    2d50:	4798      	blx	r3
		ip_reass_pbufcount -= pbuf_clen(p);
    2d52:	9b01      	ldr	r3, [sp, #4]
    2d54:	4620      	mov	r0, r4
    2d56:	4798      	blx	r3
    2d58:	f8bb 3004 	ldrh.w	r3, [fp, #4]
    2d5c:	1a18      	subs	r0, r3, r0
    2d5e:	f8ab 0004 	strh.w	r0, [fp, #4]
}
    2d62:	4620      	mov	r0, r4
    2d64:	b005      	add	sp, #20
    2d66:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		if (((ntohs(IPH_OFFSET(fraghdr)) & IP_OFFMASK) == 0) && ((ntohs(IPH_OFFSET(&ipr->iphdr)) & IP_OFFMASK) != 0)) {
    2d6a:	88e0      	ldrh	r0, [r4, #6]
    2d6c:	47b8      	blx	r7
    2d6e:	f3c0 000c 	ubfx	r0, r0, #0, #13
    2d72:	2800      	cmp	r0, #0
    2d74:	f47f af0c 	bne.w	2b90 <ip_reass+0xa8>
    2d78:	f8b9 000e 	ldrh.w	r0, [r9, #14]
    2d7c:	47b8      	blx	r7
    2d7e:	f3c0 000c 	ubfx	r0, r0, #0, #13
    2d82:	2800      	cmp	r0, #0
    2d84:	f43f af04 	beq.w	2b90 <ip_reass+0xa8>
			SMEMCPY(&ipr->iphdr, fraghdr, IP_HLEN);
    2d88:	4622      	mov	r2, r4
    2d8a:	f109 0108 	add.w	r1, r9, #8
    2d8e:	f104 0014 	add.w	r0, r4, #20
    2d92:	f852 cb04 	ldr.w	ip, [r2], #4
    2d96:	f841 cb04 	str.w	ip, [r1], #4
    2d9a:	4282      	cmp	r2, r0
    2d9c:	d1f9      	bne.n	2d92 <ip_reass+0x2aa>
    2d9e:	e6f7      	b.n	2b90 <ip_reass+0xa8>
    2da0:	00000d6b 	.word	0x00000d6b
    2da4:	00002a21 	.word	0x00002a21
    2da8:	000094c1 	.word	0x000094c1
    2dac:	2000a4d8 	.word	0x2000a4d8
    2db0:	00003081 	.word	0x00003081
    2db4:	00000d65 	.word	0x00000d65
    2db8:	00003029 	.word	0x00003029
    2dbc:	00003257 	.word	0x00003257
    2dc0:	000074a9 	.word	0x000074a9
    2dc4:	00004b49 	.word	0x00004b49
    2dc8:	0000323d 	.word	0x0000323d
    2dcc:	00004b2d 	.word	0x00004b2d

00002dd0 <ip_frag>:
 * @param dest destination ip address to which to send
 *
 * @return ERR_OK if sent successfully, err_t otherwise
 */
err_t ip_frag(struct pbuf *p, struct netif *netif, ip_addr_t *dest)
{
    2dd0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    2dd4:	ed2d 8b02 	vpush	{d8}
    2dd8:	b08d      	sub	sp, #52	; 0x34
	struct ip_hdr *original_iphdr;
#endif
	struct ip_hdr *iphdr;
	u16_t          nfb;
	u16_t          left, cop;
	u16_t          mtu = netif->mtu;
    2dda:	8c8b      	ldrh	r3, [r1, #36]	; 0x24
    2ddc:	9305      	str	r3, [sp, #20]

	/* Copy the IP header in it */
	iphdr = (struct ip_hdr *)rambuf->payload;
	SMEMCPY(iphdr, p->payload, IP_HLEN);
#else  /* IP_FRAG_USES_STATIC_BUF */
	original_iphdr = (struct ip_hdr *)p->payload;
    2dde:	6843      	ldr	r3, [r0, #4]
    2de0:	9306      	str	r3, [sp, #24]
{
    2de2:	4604      	mov	r4, r0
	iphdr          = original_iphdr;
#endif /* IP_FRAG_USES_STATIC_BUF */

	/* Save original offset */
	tmp = ntohs(IPH_OFFSET(iphdr));
    2de4:	88d8      	ldrh	r0, [r3, #6]
    2de6:	4b5e      	ldr	r3, [pc, #376]	; (2f60 <ip_frag+0x190>)
{
    2de8:	ee08 2a10 	vmov	s16, r2
    2dec:	468a      	mov	sl, r1
	tmp = ntohs(IPH_OFFSET(iphdr));
    2dee:	4798      	blx	r3
	ofo = tmp & IP_OFFMASK;
	omf = tmp & IP_MF;

	left = p->tot_len - IP_HLEN;
    2df0:	8925      	ldrh	r5, [r4, #8]
	ofo = tmp & IP_OFFMASK;
    2df2:	f3c0 030c 	ubfx	r3, r0, #0, #13
    2df6:	9304      	str	r3, [sp, #16]
	left = p->tot_len - IP_HLEN;
    2df8:	3d14      	subs	r5, #20
	omf = tmp & IP_MF;
    2dfa:	f400 5300 	and.w	r3, r0, #8192	; 0x2000
    2dfe:	9308      	str	r3, [sp, #32]
	left = p->tot_len - IP_HLEN;
    2e00:	b2ab      	uxth	r3, r5
    2e02:	9302      	str	r3, [sp, #8]

	nfb = (mtu - IP_HLEN) / 8;
    2e04:	9b05      	ldr	r3, [sp, #20]
    2e06:	3b14      	subs	r3, #20
    2e08:	bf44      	itt	mi
    2e0a:	9b05      	ldrmi	r3, [sp, #20]
    2e0c:	3b0d      	submi	r3, #13
    2e0e:	f3c3 03cf 	ubfx	r3, r3, #3, #16
    2e12:	9307      	str	r3, [sp, #28]
		if (!last) {
			tmp = tmp | IP_MF;
		}

		/* Fill this fragment */
		cop = last ? left : nfb * 8;
    2e14:	00db      	lsls	r3, r3, #3
    2e16:	b29b      	uxth	r3, r3
    2e18:	9309      	str	r3, [sp, #36]	; 0x24
	u16_t          poff = IP_HLEN;
    2e1a:	2614      	movs	r6, #20
	u16_t newpbuflen = 0;
    2e1c:	2300      	movs	r3, #0
	while (left) {
    2e1e:	9a02      	ldr	r2, [sp, #8]
    2e20:	b92a      	cbnz	r2, 2e2e <ip_frag+0x5e>
	}
#if IP_FRAG_USES_STATIC_BUF
	pbuf_free(rambuf);
#endif /* IP_FRAG_USES_STATIC_BUF */
	snmp_inc_ipfragoks();
	return ERR_OK;
    2e22:	4610      	mov	r0, r2
}
    2e24:	b00d      	add	sp, #52	; 0x34
    2e26:	ecbd 8b02 	vpop	{d8}
    2e2a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		tmp = omf | (IP_OFFMASK & (ofo));
    2e2e:	9a04      	ldr	r2, [sp, #16]
		if (!last) {
    2e30:	9902      	ldr	r1, [sp, #8]
    2e32:	930a      	str	r3, [sp, #40]	; 0x28
		tmp = omf | (IP_OFFMASK & (ofo));
    2e34:	f3c2 0b0c 	ubfx	fp, r2, #0, #13
    2e38:	9a08      	ldr	r2, [sp, #32]
		rambuf = pbuf_alloc(PBUF_LINK, IP_HLEN, PBUF_RAM);
    2e3a:	4b4a      	ldr	r3, [pc, #296]	; (2f64 <ip_frag+0x194>)
		tmp = omf | (IP_OFFMASK & (ofo));
    2e3c:	ea42 0b0b 	orr.w	fp, r2, fp
		last = (left <= mtu - IP_HLEN);
    2e40:	9a05      	ldr	r2, [sp, #20]
    2e42:	3a13      	subs	r2, #19
		if (!last) {
    2e44:	428a      	cmp	r2, r1
		cop = last ? left : nfb * 8;
    2e46:	bfd4      	ite	le
    2e48:	9a09      	ldrle	r2, [sp, #36]	; 0x24
    2e4a:	9a02      	ldrgt	r2, [sp, #8]
    2e4c:	9203      	str	r2, [sp, #12]
		rambuf = pbuf_alloc(PBUF_LINK, IP_HLEN, PBUF_RAM);
    2e4e:	f04f 0114 	mov.w	r1, #20
    2e52:	f04f 0200 	mov.w	r2, #0
    2e56:	f04f 0002 	mov.w	r0, #2
			tmp = tmp | IP_MF;
    2e5a:	bfd8      	it	le
    2e5c:	f44b 5b00 	orrle.w	fp, fp, #8192	; 0x2000
		rambuf = pbuf_alloc(PBUF_LINK, IP_HLEN, PBUF_RAM);
    2e60:	4798      	blx	r3
		if (rambuf == NULL) {
    2e62:	4607      	mov	r7, r0
    2e64:	b340      	cbz	r0, 2eb8 <ip_frag+0xe8>
		SMEMCPY(rambuf->payload, original_iphdr, IP_HLEN);
    2e66:	9a06      	ldr	r2, [sp, #24]
    2e68:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    2e6a:	6841      	ldr	r1, [r0, #4]
    2e6c:	f102 0014 	add.w	r0, r2, #20
    2e70:	f852 cb04 	ldr.w	ip, [r2], #4
    2e74:	f841 cb04 	str.w	ip, [r1], #4
    2e78:	4282      	cmp	r2, r0
    2e7a:	d1f9      	bne.n	2e70 <ip_frag+0xa0>
		p->payload = (u8_t *)p->payload + poff;
    2e7c:	6862      	ldr	r2, [r4, #4]
		iphdr = (struct ip_hdr *)rambuf->payload;
    2e7e:	f8d7 9004 	ldr.w	r9, [r7, #4]
		left_to_copy = cop;
    2e82:	f8dd 800c 	ldr.w	r8, [sp, #12]
		p->payload = (u8_t *)p->payload + poff;
    2e86:	4432      	add	r2, r6
    2e88:	6062      	str	r2, [r4, #4]
		p->len -= poff;
    2e8a:	8962      	ldrh	r2, [r4, #10]
    2e8c:	1b96      	subs	r6, r2, r6
    2e8e:	8166      	strh	r6, [r4, #10]
		while (left_to_copy) {
    2e90:	461e      	mov	r6, r3
    2e92:	f1b8 0f00 	cmp.w	r8, #0
    2e96:	d036      	beq.n	2f06 <ip_frag+0x136>
			newpbuflen = (left_to_copy < p->len) ? left_to_copy : p->len;
    2e98:	8966      	ldrh	r6, [r4, #10]
    2e9a:	4546      	cmp	r6, r8
    2e9c:	bf28      	it	cs
    2e9e:	4646      	movcs	r6, r8
    2ea0:	b2b6      	uxth	r6, r6
			if (!newpbuflen) {
    2ea2:	b90e      	cbnz	r6, 2ea8 <ip_frag+0xd8>
				p = p->next;
    2ea4:	6824      	ldr	r4, [r4, #0]
    2ea6:	e7f4      	b.n	2e92 <ip_frag+0xc2>
	return (struct pbuf_custom_ref *)memp_malloc(MEMP_FRAG_PBUF);
    2ea8:	4b2f      	ldr	r3, [pc, #188]	; (2f68 <ip_frag+0x198>)
    2eaa:	2005      	movs	r0, #5
    2eac:	4798      	blx	r3
			if (pcr == NULL) {
    2eae:	4603      	mov	r3, r0
    2eb0:	b928      	cbnz	r0, 2ebe <ip_frag+0xee>
				pbuf_free(rambuf);
    2eb2:	4b2e      	ldr	r3, [pc, #184]	; (2f6c <ip_frag+0x19c>)
    2eb4:	4638      	mov	r0, r7
    2eb6:	4798      	blx	r3
			return ERR_MEM;
    2eb8:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    2ebc:	e7b2      	b.n	2e24 <ip_frag+0x54>
			newpbuf = pbuf_alloced_custom(PBUF_RAW, newpbuflen, PBUF_REF, &pcr->pc, p->payload, newpbuflen);
    2ebe:	9601      	str	r6, [sp, #4]
    2ec0:	6862      	ldr	r2, [r4, #4]
    2ec2:	9200      	str	r2, [sp, #0]
    2ec4:	900a      	str	r0, [sp, #40]	; 0x28
    2ec6:	4d2a      	ldr	r5, [pc, #168]	; (2f70 <ip_frag+0x1a0>)
    2ec8:	2202      	movs	r2, #2
    2eca:	4631      	mov	r1, r6
    2ecc:	2003      	movs	r0, #3
    2ece:	47a8      	blx	r5
			if (newpbuf == NULL) {
    2ed0:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    2ed2:	b920      	cbnz	r0, 2ede <ip_frag+0x10e>
	memp_free(MEMP_FRAG_PBUF, p);
    2ed4:	4619      	mov	r1, r3
    2ed6:	2005      	movs	r0, #5
    2ed8:	4b26      	ldr	r3, [pc, #152]	; (2f74 <ip_frag+0x1a4>)
    2eda:	4798      	blx	r3
    2edc:	e7e9      	b.n	2eb2 <ip_frag+0xe2>
    2ede:	e9cd 030a 	strd	r0, r3, [sp, #40]	; 0x28
			pbuf_ref(p);
    2ee2:	4b25      	ldr	r3, [pc, #148]	; (2f78 <ip_frag+0x1a8>)
    2ee4:	4620      	mov	r0, r4
    2ee6:	4798      	blx	r3
			pcr->original                = p;
    2ee8:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
			pcr->pc.custom_free_function = ipfrag_free_pbuf_custom;
    2eea:	4a24      	ldr	r2, [pc, #144]	; (2f7c <ip_frag+0x1ac>)
			pcr->original                = p;
    2eec:	615c      	str	r4, [r3, #20]
			left_to_copy -= newpbuflen;
    2eee:	eba8 0806 	sub.w	r8, r8, r6
			pcr->pc.custom_free_function = ipfrag_free_pbuf_custom;
    2ef2:	611a      	str	r2, [r3, #16]
			pbuf_cat(rambuf, newpbuf);
    2ef4:	990a      	ldr	r1, [sp, #40]	; 0x28
    2ef6:	4b22      	ldr	r3, [pc, #136]	; (2f80 <ip_frag+0x1b0>)
    2ef8:	4638      	mov	r0, r7
			left_to_copy -= newpbuflen;
    2efa:	fa1f f888 	uxth.w	r8, r8
			pbuf_cat(rambuf, newpbuf);
    2efe:	4798      	blx	r3
			if (left_to_copy) {
    2f00:	f1b8 0f00 	cmp.w	r8, #0
    2f04:	d1ce      	bne.n	2ea4 <ip_frag+0xd4>
		IPH_OFFSET_SET(iphdr, htons(tmp));
    2f06:	4658      	mov	r0, fp
    2f08:	f8df b07c 	ldr.w	fp, [pc, #124]	; 2f88 <ip_frag+0x1b8>
    2f0c:	47d8      	blx	fp
		IPH_LEN_SET(iphdr, htons(cop + IP_HLEN));
    2f0e:	9b03      	ldr	r3, [sp, #12]
		IPH_OFFSET_SET(iphdr, htons(tmp));
    2f10:	f8a9 0006 	strh.w	r0, [r9, #6]
		IPH_LEN_SET(iphdr, htons(cop + IP_HLEN));
    2f14:	f103 0014 	add.w	r0, r3, #20
    2f18:	b280      	uxth	r0, r0
    2f1a:	47d8      	blx	fp
		IPH_CHKSUM_SET(iphdr, inet_chksum(iphdr, IP_HLEN));
    2f1c:	4b19      	ldr	r3, [pc, #100]	; (2f84 <ip_frag+0x1b4>)
		IPH_LEN_SET(iphdr, htons(cop + IP_HLEN));
    2f1e:	f8a9 0002 	strh.w	r0, [r9, #2]
		IPH_CHKSUM_SET(iphdr, inet_chksum(iphdr, IP_HLEN));
    2f22:	2114      	movs	r1, #20
		IPH_CHKSUM_SET(iphdr, 0);
    2f24:	f889 800a 	strb.w	r8, [r9, #10]
    2f28:	f889 800b 	strb.w	r8, [r9, #11]
		IPH_CHKSUM_SET(iphdr, inet_chksum(iphdr, IP_HLEN));
    2f2c:	4648      	mov	r0, r9
    2f2e:	4798      	blx	r3
        netif->output(netif, rambuf, dest);
    2f30:	ee18 2a10 	vmov	r2, s16
    2f34:	f8da 3014 	ldr.w	r3, [sl, #20]
		IPH_CHKSUM_SET(iphdr, inet_chksum(iphdr, IP_HLEN));
    2f38:	f8a9 000a 	strh.w	r0, [r9, #10]
        netif->output(netif, rambuf, dest);
    2f3c:	4639      	mov	r1, r7
    2f3e:	4650      	mov	r0, sl
    2f40:	4798      	blx	r3
        pbuf_free(rambuf);
    2f42:	4b0a      	ldr	r3, [pc, #40]	; (2f6c <ip_frag+0x19c>)
    2f44:	4638      	mov	r0, r7
    2f46:	4798      	blx	r3
		left -= cop;
    2f48:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
    2f4c:	1ad5      	subs	r5, r2, r3
    2f4e:	b2ab      	uxth	r3, r5
		ofo += nfb;
    2f50:	9a07      	ldr	r2, [sp, #28]
		left -= cop;
    2f52:	9302      	str	r3, [sp, #8]
		ofo += nfb;
    2f54:	9b04      	ldr	r3, [sp, #16]
    2f56:	4413      	add	r3, r2
    2f58:	b29b      	uxth	r3, r3
    2f5a:	9304      	str	r3, [sp, #16]
    2f5c:	4633      	mov	r3, r6
    2f5e:	e75e      	b.n	2e1e <ip_frag+0x4e>
    2f60:	00000d6b 	.word	0x00000d6b
    2f64:	000030d9 	.word	0x000030d9
    2f68:	00004b2d 	.word	0x00004b2d
    2f6c:	00003081 	.word	0x00003081
    2f70:	00002fe5 	.word	0x00002fe5
    2f74:	00004b49 	.word	0x00004b49
    2f78:	0000324d 	.word	0x0000324d
    2f7c:	00002a99 	.word	0x00002a99
    2f80:	00003257 	.word	0x00003257
    2f84:	000074a9 	.word	0x000074a9
    2f88:	00000d65 	.word	0x00000d65

00002f8c <pbuf_free_ooseq_callback>:
{
	struct tcp_pcb *pcb;
	SYS_ARCH_DECL_PROTECT(old_level);

	SYS_ARCH_PROTECT(old_level);
	pbuf_free_ooseq_pending = 0;
    2f8c:	4b07      	ldr	r3, [pc, #28]	; (2fac <pbuf_free_ooseq_callback+0x20>)
    2f8e:	2200      	movs	r2, #0
#if !NO_SYS
/**
 * Just a callback function for tcpip_timeout() that calls pbuf_free_ooseq().
 */
static void pbuf_free_ooseq_callback(void *arg)
{
    2f90:	b510      	push	{r4, lr}
	pbuf_free_ooseq_pending = 0;
    2f92:	701a      	strb	r2, [r3, #0]
	for (pcb = tcp_active_pcbs; NULL != pcb; pcb = pcb->next) {
    2f94:	4b06      	ldr	r3, [pc, #24]	; (2fb0 <pbuf_free_ooseq_callback+0x24>)
    2f96:	681c      	ldr	r4, [r3, #0]
    2f98:	b12c      	cbz	r4, 2fa6 <pbuf_free_ooseq_callback+0x1a>
		if (NULL != pcb->ooseq) {
    2f9a:	6f60      	ldr	r0, [r4, #116]	; 0x74
    2f9c:	b120      	cbz	r0, 2fa8 <pbuf_free_ooseq_callback+0x1c>
			tcp_segs_free(pcb->ooseq);
    2f9e:	4b05      	ldr	r3, [pc, #20]	; (2fb4 <pbuf_free_ooseq_callback+0x28>)
    2fa0:	4798      	blx	r3
			pcb->ooseq = NULL;
    2fa2:	2300      	movs	r3, #0
    2fa4:	6763      	str	r3, [r4, #116]	; 0x74
	LWIP_UNUSED_ARG(arg);
	pbuf_free_ooseq();
}
    2fa6:	bd10      	pop	{r4, pc}
	for (pcb = tcp_active_pcbs; NULL != pcb; pcb = pcb->next) {
    2fa8:	68e4      	ldr	r4, [r4, #12]
    2faa:	e7f5      	b.n	2f98 <pbuf_free_ooseq_callback+0xc>
    2fac:	2000a4de 	.word	0x2000a4de
    2fb0:	200148fc 	.word	0x200148fc
    2fb4:	00005b5d 	.word	0x00005b5d

00002fb8 <pbuf_pool_is_empty>:
#endif /* !NO_SYS */

/** Queue a call to pbuf_free_ooseq if not already queued. */
static void pbuf_pool_is_empty(void)
{
    2fb8:	b538      	push	{r3, r4, r5, lr}
	SYS_ARCH_UNPROTECT(old_level);
#else  /* PBUF_POOL_FREE_OOSEQ_QUEUE_CALL */
	u8_t queued;
	SYS_ARCH_DECL_PROTECT(old_level);
	SYS_ARCH_PROTECT(old_level);
	queued                  = pbuf_free_ooseq_pending;
    2fba:	4c07      	ldr	r4, [pc, #28]	; (2fd8 <pbuf_pool_is_empty+0x20>)
    2fbc:	7823      	ldrb	r3, [r4, #0]
	pbuf_free_ooseq_pending = 1;
    2fbe:	2201      	movs	r2, #1
    2fc0:	7022      	strb	r2, [r4, #0]
	SYS_ARCH_UNPROTECT(old_level);

	if (!queued) {
    2fc2:	f003 05ff 	and.w	r5, r3, #255	; 0xff
    2fc6:	b933      	cbnz	r3, 2fd6 <pbuf_pool_is_empty+0x1e>
		/* queue a call to pbuf_free_ooseq if not already queued */
		PBUF_POOL_FREE_OOSEQ_QUEUE_CALL();
    2fc8:	4804      	ldr	r0, [pc, #16]	; (2fdc <pbuf_pool_is_empty+0x24>)
    2fca:	4b05      	ldr	r3, [pc, #20]	; (2fe0 <pbuf_pool_is_empty+0x28>)
    2fcc:	462a      	mov	r2, r5
    2fce:	4629      	mov	r1, r5
    2fd0:	4798      	blx	r3
    2fd2:	b100      	cbz	r0, 2fd6 <pbuf_pool_is_empty+0x1e>
    2fd4:	7025      	strb	r5, [r4, #0]
	}
#endif /* PBUF_POOL_FREE_OOSEQ_QUEUE_CALL */
}
    2fd6:	bd38      	pop	{r3, r4, r5, pc}
    2fd8:	2000a4de 	.word	0x2000a4de
    2fdc:	00002f8d 	.word	0x00002f8d
    2fe0:	00009349 	.word	0x00009349

00002fe4 <pbuf_alloced_custom>:
 * @param payload_mem_len the size of the 'payload_mem' buffer, must be at least
 *        big enough to hold 'length' plus the header size
 */
struct pbuf *pbuf_alloced_custom(pbuf_layer l, u16_t length, pbuf_type type, struct pbuf_custom *p, void *payload_mem,
                                 u16_t payload_mem_len)
{
    2fe4:	b570      	push	{r4, r5, r6, lr}
    2fe6:	2803      	cmp	r0, #3
    2fe8:	9d04      	ldr	r5, [sp, #16]
    2fea:	d818      	bhi.n	301e <pbuf_alloced_custom+0x3a>
	default:
		LWIP_ASSERT("pbuf_alloced_custom: bad pbuf layer", 0);
		return NULL;
	}

	if (LWIP_MEM_ALIGN_SIZE(offset) + length > payload_mem_len) {
    2fec:	4c0d      	ldr	r4, [pc, #52]	; (3024 <pbuf_alloced_custom+0x40>)
    2fee:	5c24      	ldrb	r4, [r4, r0]
    2ff0:	f8bd 0014 	ldrh.w	r0, [sp, #20]
    2ff4:	3403      	adds	r4, #3
    2ff6:	f024 0403 	bic.w	r4, r4, #3
    2ffa:	1866      	adds	r6, r4, r1
    2ffc:	4286      	cmp	r6, r0
    2ffe:	f04f 0000 	mov.w	r0, #0
    3002:	dc0b      	bgt.n	301c <pbuf_alloced_custom+0x38>
		LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_LEVEL_WARNING,
		            ("pbuf_alloced_custom(length=%" U16_F ") buffer too short\n", length));
		return NULL;
	}

	p->pbuf.next = NULL;
    3004:	6018      	str	r0, [r3, #0]
	if (payload_mem != NULL) {
    3006:	b105      	cbz	r5, 300a <pbuf_alloced_custom+0x26>
		p->pbuf.payload = (u8_t *)payload_mem + LWIP_MEM_ALIGN_SIZE(offset);
    3008:	4425      	add	r5, r4
	} else {
		p->pbuf.payload = NULL;
	}
	p->pbuf.flags = PBUF_FLAG_IS_CUSTOM;
    300a:	2002      	movs	r0, #2
	p->pbuf.len = p->pbuf.tot_len = length;
	p->pbuf.type                  = type;
    300c:	731a      	strb	r2, [r3, #12]
	p->pbuf.ref                   = 1;
    300e:	2201      	movs	r2, #1
	p->pbuf.flags = PBUF_FLAG_IS_CUSTOM;
    3010:	7358      	strb	r0, [r3, #13]
    3012:	605d      	str	r5, [r3, #4]
	p->pbuf.len = p->pbuf.tot_len = length;
    3014:	8119      	strh	r1, [r3, #8]
    3016:	8159      	strh	r1, [r3, #10]
	p->pbuf.ref                   = 1;
    3018:	81da      	strh	r2, [r3, #14]
	return &p->pbuf;
    301a:	4618      	mov	r0, r3
}
    301c:	bd70      	pop	{r4, r5, r6, pc}
		return NULL;
    301e:	2000      	movs	r0, #0
    3020:	e7fc      	b.n	301c <pbuf_alloced_custom+0x38>
    3022:	bf00      	nop
    3024:	0000a777 	.word	0x0000a777

00003028 <pbuf_header>:
 * not move the payload pointer in front of the start of the buffer.
 * @return non-zero on failure, zero on success.
 *
 */
u8_t pbuf_header(struct pbuf *p, s16_t header_size_increment)
{
    3028:	b530      	push	{r4, r5, lr}
	u16_t type;
	void *payload;
	u16_t increment_magnitude;

	LWIP_ASSERT("p != NULL", p != NULL);
	if ((header_size_increment == 0) || (p == NULL)) {
    302a:	b1d9      	cbz	r1, 3064 <pbuf_header+0x3c>
    302c:	b1d8      	cbz	r0, 3066 <pbuf_header+0x3e>
		return 0;
	}

	if (header_size_increment < 0) {
    302e:	2900      	cmp	r1, #0
		increment_magnitude = -header_size_increment;
    3030:	b28a      	uxth	r2, r1
	if (header_size_increment < 0) {
    3032:	da05      	bge.n	3040 <pbuf_header+0x18>
		/* Check that we aren't going to move off the end of the pbuf */
		LWIP_ERROR("increment_magnitude <= p->len", (increment_magnitude <= p->len), return 1;);
    3034:	8943      	ldrh	r3, [r0, #10]
		increment_magnitude = -header_size_increment;
    3036:	4254      	negs	r4, r2
    3038:	b2a4      	uxth	r4, r4
		LWIP_ERROR("increment_magnitude <= p->len", (increment_magnitude <= p->len), return 1;);
    303a:	42a3      	cmp	r3, r4
    303c:	d201      	bcs.n	3042 <pbuf_header+0x1a>
    303e:	e7fe      	b.n	303e <pbuf_header+0x16>
	} else {
		increment_magnitude = header_size_increment;
    3040:	4614      	mov	r4, r2
    LWIP_ASSERT("p->payload - increment_magnitude >= p + SIZEOF_STRUCT_PBUF",
                (u8_t *)p->payload - increment_magnitude >= (u8_t *)p + SIZEOF_STRUCT_PBUF);
#endif
	}

	type = p->type;
    3042:	7b05      	ldrb	r5, [r0, #12]
	/* remember current payload pointer */
	payload = p->payload;
    3044:	6843      	ldr	r3, [r0, #4]

	/* pbuf types containing payloads? */
	if (type == PBUF_RAM || type == PBUF_POOL) {
    3046:	b10d      	cbz	r5, 304c <pbuf_header+0x24>
    3048:	2d03      	cmp	r5, #3
    304a:	d10d      	bne.n	3068 <pbuf_header+0x40>
		/* set new payload pointer */
		p->payload = (u8_t *)p->payload - header_size_increment;
    304c:	1a59      	subs	r1, r3, r1
		/* boundary check fails? */
		if ((u8_t *)p->payload < (u8_t *)p + SIZEOF_STRUCT_PBUF) {
    304e:	f100 0310 	add.w	r3, r0, #16
    3052:	4299      	cmp	r1, r3
    3054:	d312      	bcc.n	307c <pbuf_header+0x54>
		/* Unknown type */
		LWIP_ASSERT("bad pbuf type", 0);
		return 1;
	}
	/* modify pbuf length fields */
	p->len += header_size_increment;
    3056:	8943      	ldrh	r3, [r0, #10]
			p->payload = (u8_t *)p->payload - header_size_increment;
    3058:	6041      	str	r1, [r0, #4]
	p->len += header_size_increment;
    305a:	4413      	add	r3, r2
    305c:	8143      	strh	r3, [r0, #10]
	p->tot_len += header_size_increment;
    305e:	8903      	ldrh	r3, [r0, #8]
    3060:	441a      	add	r2, r3
    3062:	8102      	strh	r2, [r0, #8]

	LWIP_DEBUGF(
	    PBUF_DEBUG | LWIP_DBG_TRACE,
	    ("pbuf_header: old %p new %p (%" S16_F ")\n", (void *)payload, (void *)p->payload, header_size_increment));

	return 0;
    3064:	2000      	movs	r0, #0
}
    3066:	bd30      	pop	{r4, r5, pc}
	} else if (type == PBUF_REF || type == PBUF_ROM) {
    3068:	3d01      	subs	r5, #1
    306a:	2d01      	cmp	r5, #1
    306c:	d806      	bhi.n	307c <pbuf_header+0x54>
		if ((header_size_increment < 0) && (increment_magnitude <= p->len)) {
    306e:	2900      	cmp	r1, #0
    3070:	da04      	bge.n	307c <pbuf_header+0x54>
    3072:	8945      	ldrh	r5, [r0, #10]
    3074:	42a5      	cmp	r5, r4
    3076:	d301      	bcc.n	307c <pbuf_header+0x54>
			p->payload = (u8_t *)p->payload - header_size_increment;
    3078:	1a59      	subs	r1, r3, r1
    307a:	e7ec      	b.n	3056 <pbuf_header+0x2e>
		return 1;
    307c:	2001      	movs	r0, #1
    307e:	e7f2      	b.n	3066 <pbuf_header+0x3e>

00003080 <pbuf_free>:
 * 2->1->1 becomes 1->1->1
 * 1->1->1 becomes .......
 *
 */
u8_t pbuf_free(struct pbuf *p)
{
    3080:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	u16_t        type;
	struct pbuf *q;
	u8_t         count;

	if (p == NULL) {
    3082:	b318      	cbz	r0, 30cc <pbuf_free+0x4c>
					/* is this a ROM or RAM referencing pbuf? */
				} else if (type == PBUF_ROM || type == PBUF_REF) {
					memp_free(MEMP_PBUF, p);
					/* type == PBUF_RAM */
				} else {
					mem_free(p);
    3084:	4e12      	ldr	r6, [pc, #72]	; (30d0 <pbuf_free+0x50>)
					memp_free(MEMP_PBUF, p);
    3086:	4d13      	ldr	r5, [pc, #76]	; (30d4 <pbuf_free+0x54>)
	count = 0;
    3088:	2400      	movs	r4, #0
		ref = --(p->ref);
    308a:	89c3      	ldrh	r3, [r0, #14]
    308c:	3b01      	subs	r3, #1
    308e:	b29b      	uxth	r3, r3
    3090:	81c3      	strh	r3, [r0, #14]
		if (ref == 0) {
    3092:	b943      	cbnz	r3, 30a6 <pbuf_free+0x26>
			if ((p->flags & PBUF_FLAG_IS_CUSTOM) != 0) {
    3094:	7b43      	ldrb	r3, [r0, #13]
			q = p->next;
    3096:	6807      	ldr	r7, [r0, #0]
			if ((p->flags & PBUF_FLAG_IS_CUSTOM) != 0) {
    3098:	079b      	lsls	r3, r3, #30
    309a:	d508      	bpl.n	30ae <pbuf_free+0x2e>
				pc->custom_free_function(p);
    309c:	6903      	ldr	r3, [r0, #16]
    309e:	4798      	blx	r3
				}
			}
			count++;
    30a0:	3401      	adds	r4, #1
    30a2:	b2e4      	uxtb	r4, r4
	while (p != NULL) {
    30a4:	b90f      	cbnz	r7, 30aa <pbuf_free+0x2a>
		}
	}
	PERF_STOP("pbuf_free");
	/* return number of de-allocated pbufs */
	return count;
}
    30a6:	4620      	mov	r0, r4
    30a8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    30aa:	4638      	mov	r0, r7
    30ac:	e7ed      	b.n	308a <pbuf_free+0xa>
			type = p->type;
    30ae:	7b03      	ldrb	r3, [r0, #12]
				if (type == PBUF_POOL) {
    30b0:	2b03      	cmp	r3, #3
    30b2:	d103      	bne.n	30bc <pbuf_free+0x3c>
					memp_free(MEMP_PBUF_POOL, p);
    30b4:	4601      	mov	r1, r0
    30b6:	200c      	movs	r0, #12
					memp_free(MEMP_PBUF, p);
    30b8:	47a8      	blx	r5
    30ba:	e7f1      	b.n	30a0 <pbuf_free+0x20>
				} else if (type == PBUF_ROM || type == PBUF_REF) {
    30bc:	3b01      	subs	r3, #1
    30be:	2b01      	cmp	r3, #1
    30c0:	d802      	bhi.n	30c8 <pbuf_free+0x48>
					memp_free(MEMP_PBUF, p);
    30c2:	4601      	mov	r1, r0
    30c4:	200b      	movs	r0, #11
    30c6:	e7f7      	b.n	30b8 <pbuf_free+0x38>
					mem_free(p);
    30c8:	47b0      	blx	r6
    30ca:	e7e9      	b.n	30a0 <pbuf_free+0x20>
		return 0;
    30cc:	4604      	mov	r4, r0
    30ce:	e7ea      	b.n	30a6 <pbuf_free+0x26>
    30d0:	000056f1 	.word	0x000056f1
    30d4:	00004b49 	.word	0x00004b49

000030d8 <pbuf_alloc>:
	switch (layer) {
    30d8:	2803      	cmp	r0, #3
{
    30da:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    30de:	460e      	mov	r6, r1
    30e0:	4617      	mov	r7, r2
    30e2:	d901      	bls.n	30e8 <pbuf_alloc+0x10>
	switch (type) {
    30e4:	2400      	movs	r4, #0
    30e6:	e01b      	b.n	3120 <pbuf_alloc+0x48>
    30e8:	4b3a      	ldr	r3, [pc, #232]	; (31d4 <pbuf_alloc+0xfc>)
    30ea:	2a02      	cmp	r2, #2
    30ec:	5c1d      	ldrb	r5, [r3, r0]
    30ee:	d80d      	bhi.n	310c <pbuf_alloc+0x34>
    30f0:	2a00      	cmp	r2, #0
    30f2:	d056      	beq.n	31a2 <pbuf_alloc+0xca>
		p = (struct pbuf *)memp_malloc(MEMP_PBUF);
    30f4:	4b38      	ldr	r3, [pc, #224]	; (31d8 <pbuf_alloc+0x100>)
    30f6:	200b      	movs	r0, #11
    30f8:	4798      	blx	r3
		if (p == NULL) {
    30fa:	4604      	mov	r4, r0
    30fc:	2800      	cmp	r0, #0
    30fe:	d0f1      	beq.n	30e4 <pbuf_alloc+0xc>
		p->payload = NULL;
    3100:	2300      	movs	r3, #0
    3102:	6043      	str	r3, [r0, #4]
		p->len = p->tot_len = length;
    3104:	8106      	strh	r6, [r0, #8]
    3106:	8146      	strh	r6, [r0, #10]
		p->next             = NULL;
    3108:	6003      	str	r3, [r0, #0]
    310a:	e060      	b.n	31ce <pbuf_alloc+0xf6>
	switch (type) {
    310c:	2a03      	cmp	r2, #3
    310e:	d1e9      	bne.n	30e4 <pbuf_alloc+0xc>
		p = (struct pbuf *)memp_malloc(MEMP_PBUF_POOL);
    3110:	f8df 80c4 	ldr.w	r8, [pc, #196]	; 31d8 <pbuf_alloc+0x100>
    3114:	200c      	movs	r0, #12
    3116:	47c0      	blx	r8
		if (p == NULL) {
    3118:	4604      	mov	r4, r0
    311a:	b920      	cbnz	r0, 3126 <pbuf_alloc+0x4e>
			PBUF_POOL_IS_EMPTY();
    311c:	4b2f      	ldr	r3, [pc, #188]	; (31dc <pbuf_alloc+0x104>)
    311e:	4798      	blx	r3
}
    3120:	4620      	mov	r0, r4
    3122:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
		p->payload = LWIP_MEM_ALIGN((void *)((u8_t *)p + (SIZEOF_STRUCT_PBUF + offset)));
    3126:	1943      	adds	r3, r0, r5
    3128:	3313      	adds	r3, #19
    312a:	f023 0303 	bic.w	r3, r3, #3
		p->len = LWIP_MIN(length, PBUF_POOL_BUFSIZE_ALIGNED - LWIP_MEM_ALIGN_SIZE(offset));
    312e:	3503      	adds	r5, #3
		p->payload = LWIP_MEM_ALIGN((void *)((u8_t *)p + (SIZEOF_STRUCT_PBUF + offset)));
    3130:	6043      	str	r3, [r0, #4]
		p->len = LWIP_MIN(length, PBUF_POOL_BUFSIZE_ALIGNED - LWIP_MEM_ALIGN_SIZE(offset));
    3132:	f025 0303 	bic.w	r3, r5, #3
    3136:	f5c3 65bd 	rsb	r5, r3, #1512	; 0x5e8
    313a:	3504      	adds	r5, #4
    313c:	42b5      	cmp	r5, r6
    313e:	bfa8      	it	ge
    3140:	4635      	movge	r5, r6
		p->next = NULL;
    3142:	f04f 0900 	mov.w	r9, #0
		p->ref = 1;
    3146:	2301      	movs	r3, #1
		p->len = LWIP_MIN(length, PBUF_POOL_BUFSIZE_ALIGNED - LWIP_MEM_ALIGN_SIZE(offset));
    3148:	8145      	strh	r5, [r0, #10]
		p->type = type;
    314a:	7307      	strb	r7, [r0, #12]
		p->next = NULL;
    314c:	f8c0 9000 	str.w	r9, [r0]
		p->tot_len = length;
    3150:	8106      	strh	r6, [r0, #8]
		p->ref = 1;
    3152:	81c3      	strh	r3, [r0, #14]
		rem_len = length - p->len;
    3154:	1b75      	subs	r5, r6, r5
		while (rem_len > 0) {
    3156:	4682      	mov	sl, r0
    3158:	2d00      	cmp	r5, #0
    315a:	dc04      	bgt.n	3166 <pbuf_alloc+0x8e>
	p->ref = 1;
    315c:	2301      	movs	r3, #1
    315e:	81e3      	strh	r3, [r4, #14]
	p->flags = 0;
    3160:	2300      	movs	r3, #0
    3162:	7363      	strb	r3, [r4, #13]
	return p;
    3164:	e7dc      	b.n	3120 <pbuf_alloc+0x48>
			q = (struct pbuf *)memp_malloc(MEMP_PBUF_POOL);
    3166:	200c      	movs	r0, #12
    3168:	47c0      	blx	r8
			if (q == NULL) {
    316a:	b928      	cbnz	r0, 3178 <pbuf_alloc+0xa0>
				PBUF_POOL_IS_EMPTY();
    316c:	4b1b      	ldr	r3, [pc, #108]	; (31dc <pbuf_alloc+0x104>)
    316e:	4798      	blx	r3
				pbuf_free(p);
    3170:	4b1b      	ldr	r3, [pc, #108]	; (31e0 <pbuf_alloc+0x108>)
    3172:	4620      	mov	r0, r4
    3174:	4798      	blx	r3
				return NULL;
    3176:	e7b5      	b.n	30e4 <pbuf_alloc+0xc>
			q->tot_len = (u16_t)rem_len;
    3178:	b2ab      	uxth	r3, r5
			q->len     = LWIP_MIN((u16_t)rem_len, PBUF_POOL_BUFSIZE_ALIGNED);
    317a:	f240 52ec 	movw	r2, #1516	; 0x5ec
    317e:	4293      	cmp	r3, r2
			q->type  = type;
    3180:	8187      	strh	r7, [r0, #12]
			q->next  = NULL;
    3182:	f8c0 9000 	str.w	r9, [r0]
			r->next = q;
    3186:	f8ca 0000 	str.w	r0, [sl]
			q->tot_len = (u16_t)rem_len;
    318a:	8103      	strh	r3, [r0, #8]
			q->len     = LWIP_MIN((u16_t)rem_len, PBUF_POOL_BUFSIZE_ALIGNED);
    318c:	bf28      	it	cs
    318e:	4613      	movcs	r3, r2
			q->payload = (void *)((u8_t *)q + SIZEOF_STRUCT_PBUF);
    3190:	f100 0210 	add.w	r2, r0, #16
    3194:	6042      	str	r2, [r0, #4]
			q->ref = 1;
    3196:	2201      	movs	r2, #1
			q->len     = LWIP_MIN((u16_t)rem_len, PBUF_POOL_BUFSIZE_ALIGNED);
    3198:	8143      	strh	r3, [r0, #10]
			q->ref = 1;
    319a:	81c2      	strh	r2, [r0, #14]
			rem_len -= q->len;
    319c:	1aed      	subs	r5, r5, r3
    319e:	4682      	mov	sl, r0
    31a0:	e7da      	b.n	3158 <pbuf_alloc+0x80>
		p = (struct pbuf *)mem_malloc(LWIP_MEM_ALIGN_SIZE(SIZEOF_STRUCT_PBUF + offset) + LWIP_MEM_ALIGN_SIZE(length));
    31a2:	1ccb      	adds	r3, r1, #3
    31a4:	f105 0013 	add.w	r0, r5, #19
    31a8:	f023 0303 	bic.w	r3, r3, #3
    31ac:	f020 0003 	bic.w	r0, r0, #3
    31b0:	4418      	add	r0, r3
    31b2:	b280      	uxth	r0, r0
    31b4:	4b0b      	ldr	r3, [pc, #44]	; (31e4 <pbuf_alloc+0x10c>)
    31b6:	4798      	blx	r3
		if (p == NULL) {
    31b8:	4604      	mov	r4, r0
    31ba:	2800      	cmp	r0, #0
    31bc:	d092      	beq.n	30e4 <pbuf_alloc+0xc>
		p->payload = LWIP_MEM_ALIGN((void *)((u8_t *)p + SIZEOF_STRUCT_PBUF + offset));
    31be:	1943      	adds	r3, r0, r5
    31c0:	3313      	adds	r3, #19
    31c2:	f023 0303 	bic.w	r3, r3, #3
    31c6:	6043      	str	r3, [r0, #4]
		p->len = p->tot_len = length;
    31c8:	8106      	strh	r6, [r0, #8]
    31ca:	8146      	strh	r6, [r0, #10]
		p->next             = NULL;
    31cc:	6007      	str	r7, [r0, #0]
		p->type             = type;
    31ce:	7327      	strb	r7, [r4, #12]
		break;
    31d0:	e7c4      	b.n	315c <pbuf_alloc+0x84>
    31d2:	bf00      	nop
    31d4:	0000a777 	.word	0x0000a777
    31d8:	00004b2d 	.word	0x00004b2d
    31dc:	00002fb9 	.word	0x00002fb9
    31e0:	00003081 	.word	0x00003081
    31e4:	0000587d 	.word	0x0000587d

000031e8 <pbuf_realloc>:
{
    31e8:	b538      	push	{r3, r4, r5, lr}
	if (new_len >= p->tot_len) {
    31ea:	8903      	ldrh	r3, [r0, #8]
    31ec:	428b      	cmp	r3, r1
{
    31ee:	4604      	mov	r4, r0
	if (new_len >= p->tot_len) {
    31f0:	d918      	bls.n	3224 <pbuf_realloc+0x3c>
    31f2:	460d      	mov	r5, r1
		q->tot_len += (u16_t)grow;
    31f4:	1aca      	subs	r2, r1, r3
	while (rem_len > q->len) {
    31f6:	8963      	ldrh	r3, [r4, #10]
    31f8:	42ab      	cmp	r3, r5
    31fa:	d314      	bcc.n	3226 <pbuf_realloc+0x3e>
	if ((q->type == PBUF_RAM) && (rem_len != q->len)) {
    31fc:	7b22      	ldrb	r2, [r4, #12]
    31fe:	b94a      	cbnz	r2, 3214 <pbuf_realloc+0x2c>
    3200:	42ab      	cmp	r3, r5
    3202:	d007      	beq.n	3214 <pbuf_realloc+0x2c>
		q = (struct pbuf *)mem_trim(q, (u16_t)((u8_t *)q->payload - (u8_t *)q) + rem_len);
    3204:	6861      	ldr	r1, [r4, #4]
    3206:	4b0b      	ldr	r3, [pc, #44]	; (3234 <pbuf_realloc+0x4c>)
    3208:	1b09      	subs	r1, r1, r4
    320a:	4429      	add	r1, r5
    320c:	4620      	mov	r0, r4
    320e:	b289      	uxth	r1, r1
    3210:	4798      	blx	r3
    3212:	4604      	mov	r4, r0
	if (q->next != NULL) {
    3214:	6820      	ldr	r0, [r4, #0]
	q->len     = rem_len;
    3216:	8165      	strh	r5, [r4, #10]
	q->tot_len = q->len;
    3218:	8125      	strh	r5, [r4, #8]
	if (q->next != NULL) {
    321a:	b108      	cbz	r0, 3220 <pbuf_realloc+0x38>
		pbuf_free(q->next);
    321c:	4b06      	ldr	r3, [pc, #24]	; (3238 <pbuf_realloc+0x50>)
    321e:	4798      	blx	r3
	q->next = NULL;
    3220:	2300      	movs	r3, #0
    3222:	6023      	str	r3, [r4, #0]
}
    3224:	bd38      	pop	{r3, r4, r5, pc}
		rem_len -= q->len;
    3226:	1aed      	subs	r5, r5, r3
		q->tot_len += (u16_t)grow;
    3228:	8923      	ldrh	r3, [r4, #8]
    322a:	4413      	add	r3, r2
    322c:	8123      	strh	r3, [r4, #8]
		rem_len -= q->len;
    322e:	b2ad      	uxth	r5, r5
		q = q->next;
    3230:	6824      	ldr	r4, [r4, #0]
    3232:	e7e0      	b.n	31f6 <pbuf_realloc+0xe>
    3234:	00005791 	.word	0x00005791
    3238:	00003081 	.word	0x00003081

0000323c <pbuf_clen>:
 * @param p first pbuf of chain
 * @return the number of pbufs in a chain
 */

u8_t pbuf_clen(struct pbuf *p)
{
    323c:	4603      	mov	r3, r0
	u8_t len;

	len = 0;
	while (p != NULL) {
    323e:	2200      	movs	r2, #0
    3240:	b2d0      	uxtb	r0, r2
    3242:	3201      	adds	r2, #1
    3244:	b903      	cbnz	r3, 3248 <pbuf_clen+0xc>
		++len;
		p = p->next;
	}
	return len;
}
    3246:	4770      	bx	lr
		p = p->next;
    3248:	681b      	ldr	r3, [r3, #0]
    324a:	e7f9      	b.n	3240 <pbuf_clen+0x4>

0000324c <pbuf_ref>:
 */
void pbuf_ref(struct pbuf *p)
{
	SYS_ARCH_DECL_PROTECT(old_level);
	/* pbuf given? */
	if (p != NULL) {
    324c:	b110      	cbz	r0, 3254 <pbuf_ref+0x8>
		SYS_ARCH_PROTECT(old_level);
		++(p->ref);
    324e:	89c3      	ldrh	r3, [r0, #14]
    3250:	3301      	adds	r3, #1
    3252:	81c3      	strh	r3, [r0, #14]
		SYS_ARCH_UNPROTECT(old_level);
	}
}
    3254:	4770      	bx	lr

00003256 <pbuf_cat>:
 *
 * @see pbuf_chain()
 */

void pbuf_cat(struct pbuf *h, struct pbuf *t)
{
    3256:	b510      	push	{r4, lr}
	struct pbuf *p;

	LWIP_ERROR("(h != NULL) && (t != NULL) (programmer violates API)", ((h != NULL) && (t != NULL)), return;);
    3258:	b100      	cbz	r0, 325c <pbuf_cat+0x6>
    325a:	b909      	cbnz	r1, 3260 <pbuf_cat+0xa>
    325c:	e7fe      	b.n	325c <pbuf_cat+0x6>

	/* proceed to last pbuf of chain */
	for (p = h; p->next != NULL; p = p->next) {
		/* add total length of second chain to all totals of first chain */
		p->tot_len += t->tot_len;
    325e:	4610      	mov	r0, r2
    3260:	890b      	ldrh	r3, [r1, #8]
    3262:	8904      	ldrh	r4, [r0, #8]
	for (p = h; p->next != NULL; p = p->next) {
    3264:	6802      	ldr	r2, [r0, #0]
		p->tot_len += t->tot_len;
    3266:	4423      	add	r3, r4
    3268:	b29b      	uxth	r3, r3
    326a:	8103      	strh	r3, [r0, #8]
	for (p = h; p->next != NULL; p = p->next) {
    326c:	2a00      	cmp	r2, #0
    326e:	d1f6      	bne.n	325e <pbuf_cat+0x8>
	LWIP_ASSERT("p->tot_len == p->len (of last pbuf in chain)", p->tot_len == p->len);
	LWIP_ASSERT("p->next == NULL", p->next == NULL);
	/* add total length of second chain to last pbuf total of first chain */
	p->tot_len += t->tot_len;
	/* chain last pbuf of head (p) with first of tail (t) */
	p->next = t;
    3270:	6001      	str	r1, [r0, #0]
	/* p->next now references t, but the caller will drop its reference to t,
	 * so netto there is no change to the reference count of t.
	 */
}
    3272:	bd10      	pop	{r4, pc}

00003274 <pbuf_chain>:
 * The ->next field of the last pbuf of the head chain is adjusted.
 * The ->ref field of the first pbuf of the tail chain is adjusted.
 *
 */
void pbuf_chain(struct pbuf *h, struct pbuf *t)
{
    3274:	b510      	push	{r4, lr}
	pbuf_cat(h, t);
    3276:	4b03      	ldr	r3, [pc, #12]	; (3284 <pbuf_chain+0x10>)
    3278:	4798      	blx	r3
	/* t is now referenced by h */
	pbuf_ref(t);
	LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_chain: %p references %p\n", (void *)h, (void *)t));
}
    327a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	pbuf_ref(t);
    327e:	4b02      	ldr	r3, [pc, #8]	; (3288 <pbuf_chain+0x14>)
    3280:	4608      	mov	r0, r1
    3282:	4718      	bx	r3
    3284:	00003257 	.word	0x00003257
    3288:	0000324d 	.word	0x0000324d

0000328c <pbuf_copy>:
 * @return ERR_OK if pbuf was copied
 *         ERR_ARG if one of the pbufs is NULL or p_to is not big
 *                 enough to hold p_from
 */
err_t pbuf_copy(struct pbuf *p_to, struct pbuf *p_from)
{
    328c:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    3290:	460c      	mov	r4, r1
	u16_t offset_to = 0, offset_from = 0, len;

	LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_copy(%p, %p)\n", (void *)p_to, (void *)p_from));

	/* is the target big enough to hold the source? */
	LWIP_ERROR("pbuf_copy: target not big enough to hold source",
    3292:	4605      	mov	r5, r0
    3294:	b120      	cbz	r0, 32a0 <pbuf_copy+0x14>
    3296:	b119      	cbz	r1, 32a0 <pbuf_copy+0x14>
    3298:	8902      	ldrh	r2, [r0, #8]
    329a:	890b      	ldrh	r3, [r1, #8]
    329c:	429a      	cmp	r2, r3
    329e:	d200      	bcs.n	32a2 <pbuf_copy+0x16>
    32a0:	e7fe      	b.n	32a0 <pbuf_copy+0x14>
	u16_t offset_to = 0, offset_from = 0, len;
    32a2:	f04f 0800 	mov.w	r8, #0
			len = p_from->len - offset_from;
		} else {
			/* current p_from does not fit into current p_to */
			len = p_to->len - offset_to;
		}
		MEMCPY((u8_t *)p_to->payload + offset_to, (u8_t *)p_from->payload + offset_from, len);
    32a6:	f8df 9074 	ldr.w	r9, [pc, #116]	; 331c <pbuf_copy+0x90>
	u16_t offset_to = 0, offset_from = 0, len;
    32aa:	4647      	mov	r7, r8
		if ((p_to->len - offset_to) >= (p_from->len - offset_from)) {
    32ac:	8962      	ldrh	r2, [r4, #10]
    32ae:	896e      	ldrh	r6, [r5, #10]
		MEMCPY((u8_t *)p_to->payload + offset_to, (u8_t *)p_from->payload + offset_from, len);
    32b0:	6861      	ldr	r1, [r4, #4]
    32b2:	6868      	ldr	r0, [r5, #4]
		if ((p_to->len - offset_to) >= (p_from->len - offset_from)) {
    32b4:	1bf6      	subs	r6, r6, r7
    32b6:	eba2 0208 	sub.w	r2, r2, r8
    32ba:	4296      	cmp	r6, r2
			len = p_from->len - offset_from;
    32bc:	bfac      	ite	ge
    32be:	b296      	uxthge	r6, r2
			len = p_to->len - offset_to;
    32c0:	b2b6      	uxthlt	r6, r6
		MEMCPY((u8_t *)p_to->payload + offset_to, (u8_t *)p_from->payload + offset_from, len);
    32c2:	4632      	mov	r2, r6
    32c4:	4441      	add	r1, r8
    32c6:	4438      	add	r0, r7
    32c8:	47c8      	blx	r9
		offset_to += len;
    32ca:	4437      	add	r7, r6
		offset_from += len;
		LWIP_ASSERT("offset_to <= p_to->len", offset_to <= p_to->len);
		LWIP_ASSERT("offset_from <= p_from->len", offset_from <= p_from->len);
		if (offset_from >= p_from->len) {
    32cc:	8963      	ldrh	r3, [r4, #10]
		offset_from += len;
    32ce:	4446      	add	r6, r8
    32d0:	fa1f f886 	uxth.w	r8, r6
		if (offset_from >= p_from->len) {
    32d4:	4543      	cmp	r3, r8
			/* on to next p_from (if any) */
			offset_from = 0;
			p_from      = p_from->next;
		}
		if (offset_to == p_to->len) {
    32d6:	896b      	ldrh	r3, [r5, #10]
			p_from      = p_from->next;
    32d8:	bf98      	it	ls
    32da:	6824      	ldrls	r4, [r4, #0]
		offset_to += len;
    32dc:	b2bf      	uxth	r7, r7
			offset_from = 0;
    32de:	bf98      	it	ls
    32e0:	f04f 0800 	movls.w	r8, #0
		if (offset_to == p_to->len) {
    32e4:	42bb      	cmp	r3, r7
    32e6:	d104      	bne.n	32f2 <pbuf_copy+0x66>
			/* on to next p_to (if any) */
			offset_to = 0;
			p_to      = p_to->next;
    32e8:	682d      	ldr	r5, [r5, #0]
			LWIP_ERROR("p_to != NULL", (p_to != NULL) || (p_from == NULL), return ERR_ARG;);
    32ea:	b90d      	cbnz	r5, 32f0 <pbuf_copy+0x64>
    32ec:	b194      	cbz	r4, 3314 <pbuf_copy+0x88>
    32ee:	e7fe      	b.n	32ee <pbuf_copy+0x62>
			offset_to = 0;
    32f0:	2700      	movs	r7, #0
		}

		if ((p_from != NULL) && (p_from->len == p_from->tot_len)) {
    32f2:	b134      	cbz	r4, 3302 <pbuf_copy+0x76>
    32f4:	8962      	ldrh	r2, [r4, #10]
    32f6:	8923      	ldrh	r3, [r4, #8]
    32f8:	429a      	cmp	r2, r3
    32fa:	d102      	bne.n	3302 <pbuf_copy+0x76>
			/* don't copy more than one packet! */
			LWIP_ERROR("pbuf_copy() does not allow packet queues!\n", (p_from->next == NULL), return ERR_VAL;);
    32fc:	6823      	ldr	r3, [r4, #0]
    32fe:	b103      	cbz	r3, 3302 <pbuf_copy+0x76>
    3300:	e7fe      	b.n	3300 <pbuf_copy+0x74>
		}
		if ((p_to != NULL) && (p_to->len == p_to->tot_len)) {
    3302:	896a      	ldrh	r2, [r5, #10]
    3304:	892b      	ldrh	r3, [r5, #8]
    3306:	429a      	cmp	r2, r3
    3308:	d102      	bne.n	3310 <pbuf_copy+0x84>
			/* don't copy more than one packet! */
			LWIP_ERROR("pbuf_copy() does not allow packet queues!\n", (p_to->next == NULL), return ERR_VAL;);
    330a:	682b      	ldr	r3, [r5, #0]
    330c:	b103      	cbz	r3, 3310 <pbuf_copy+0x84>
    330e:	e7fe      	b.n	330e <pbuf_copy+0x82>
		}
	} while (p_from);
    3310:	2c00      	cmp	r4, #0
    3312:	d1cb      	bne.n	32ac <pbuf_copy+0x20>
	LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_copy: end of chain reached.\n"));
	return ERR_OK;
}
    3314:	2000      	movs	r0, #0
    3316:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    331a:	bf00      	nop
    331c:	000094a5 	.word	0x000094a5

00003320 <pbuf_copy_partial>:
 * than buf->tot_len will be copied, irrespective of len
 * @param offset offset into the packet buffer from where to begin copying len bytes
 * @return the number of bytes copied, or 0 on failure
 */
u16_t pbuf_copy_partial(struct pbuf *buf, void *dataptr, u16_t len, u16_t offset)
{
    3320:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    3324:	4688      	mov	r8, r1
    3326:	4617      	mov	r7, r2
	struct pbuf *p;
	u16_t        left;
	u16_t        buf_copy_len;
	u16_t        copied_total = 0;

	LWIP_ERROR("pbuf_copy_partial: invalid buf", (buf != NULL), return 0;);
    3328:	4605      	mov	r5, r0
    332a:	b900      	cbnz	r0, 332e <pbuf_copy_partial+0xe>
    332c:	e7fe      	b.n	332c <pbuf_copy_partial+0xc>
	LWIP_ERROR("pbuf_copy_partial: invalid dataptr", (dataptr != NULL), return 0;);
    332e:	b9f1      	cbnz	r1, 336e <pbuf_copy_partial+0x4e>
    3330:	e7fe      	b.n	3330 <pbuf_copy_partial+0x10>
		return 0;
	}

	/* Note some systems use byte copy if dataptr or one of the pbuf payload pointers are unaligned. */
	for (p = buf; len != 0 && p != NULL; p = p->next) {
		if ((offset != 0) && (offset >= p->len)) {
    3332:	896c      	ldrh	r4, [r5, #10]
    3334:	b153      	cbz	r3, 334c <pbuf_copy_partial+0x2c>
    3336:	42a3      	cmp	r3, r4
    3338:	d308      	bcc.n	334c <pbuf_copy_partial+0x2c>
			/* don't copy from this buffer -> on to the next */
			offset -= p->len;
    333a:	1b1b      	subs	r3, r3, r4
    333c:	b29b      	uxth	r3, r3
	for (p = buf; len != 0 && p != NULL; p = p->next) {
    333e:	682d      	ldr	r5, [r5, #0]
    3340:	b10f      	cbz	r7, 3346 <pbuf_copy_partial+0x26>
    3342:	2d00      	cmp	r5, #0
    3344:	d1f5      	bne.n	3332 <pbuf_copy_partial+0x12>
			len -= buf_copy_len;
			offset = 0;
		}
	}
	return copied_total;
}
    3346:	4630      	mov	r0, r6
    3348:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
			buf_copy_len = p->len - offset;
    334c:	1ae4      	subs	r4, r4, r3
    334e:	b2a4      	uxth	r4, r4
			if (buf_copy_len > len)
    3350:	42bc      	cmp	r4, r7
			MEMCPY(&((char *)dataptr)[left], &((char *)p->payload)[offset], buf_copy_len);
    3352:	6869      	ldr	r1, [r5, #4]
    3354:	bf28      	it	cs
    3356:	463c      	movcs	r4, r7
    3358:	4419      	add	r1, r3
    335a:	eb08 0006 	add.w	r0, r8, r6
    335e:	4622      	mov	r2, r4
			copied_total += buf_copy_len;
    3360:	4426      	add	r6, r4
			len -= buf_copy_len;
    3362:	1b3f      	subs	r7, r7, r4
			MEMCPY(&((char *)dataptr)[left], &((char *)p->payload)[offset], buf_copy_len);
    3364:	47c8      	blx	r9
			copied_total += buf_copy_len;
    3366:	b2b6      	uxth	r6, r6
			len -= buf_copy_len;
    3368:	b2bf      	uxth	r7, r7
			offset = 0;
    336a:	2300      	movs	r3, #0
    336c:	e7e7      	b.n	333e <pbuf_copy_partial+0x1e>
			MEMCPY(&((char *)dataptr)[left], &((char *)p->payload)[offset], buf_copy_len);
    336e:	f8df 9008 	ldr.w	r9, [pc, #8]	; 3378 <pbuf_copy_partial+0x58>
	left = 0;
    3372:	2600      	movs	r6, #0
    3374:	e7e4      	b.n	3340 <pbuf_copy_partial+0x20>
    3376:	bf00      	nop
    3378:	000094a5 	.word	0x000094a5

0000337c <tcp_parseopt>:
 * Currently, only the MSS option is supported!
 *
 * @param pcb the tcp_pcb for which a segment arrived
 */
static void tcp_parseopt(struct tcp_pcb *pcb)
{
    337c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	u8_t *opts, opt;
#if LWIP_TCP_TIMESTAMPS
	u32_t tsval;
#endif

	opts = (u8_t *)tcphdr + TCP_HLEN;
    337e:	4f1f      	ldr	r7, [pc, #124]	; (33fc <tcp_parseopt+0x80>)

	/* Parse the TCP MSS option, if present. */
	if (TCPH_HDRLEN(tcphdr) > 0x5) {
    3380:	4e1f      	ldr	r6, [pc, #124]	; (3400 <tcp_parseopt+0x84>)
	opts = (u8_t *)tcphdr + TCP_HLEN;
    3382:	683c      	ldr	r4, [r7, #0]
{
    3384:	4605      	mov	r5, r0
	if (TCPH_HDRLEN(tcphdr) > 0x5) {
    3386:	89a0      	ldrh	r0, [r4, #12]
    3388:	47b0      	blx	r6
    338a:	f3c0 300f 	ubfx	r0, r0, #12, #16
    338e:	2805      	cmp	r0, #5
    3390:	d914      	bls.n	33bc <tcp_parseopt+0x40>
		max_c = (TCPH_HDRLEN(tcphdr) - 5) << 2;
    3392:	683b      	ldr	r3, [r7, #0]
    3394:	8998      	ldrh	r0, [r3, #12]
    3396:	47b0      	blx	r6
    3398:	0b02      	lsrs	r2, r0, #12
    339a:	3a05      	subs	r2, #5
    339c:	0092      	lsls	r2, r2, #2
	opts = (u8_t *)tcphdr + TCP_HLEN;
    339e:	3414      	adds	r4, #20
		max_c = (TCPH_HDRLEN(tcphdr) - 5) << 2;
    33a0:	b292      	uxth	r2, r2
		for (c = 0; c < max_c;) {
    33a2:	2300      	movs	r3, #0
					return;
				}
				/* An MSS option with the right option length. */
				mss = (opts[c + 2] << 8) | opts[c + 3];
				/* Limit the mss to the configured TCP_MSS and prevent division by zero */
				pcb->mss = ((mss > TCP_MSS) || (mss == 0)) ? TCP_MSS : mss;
    33a4:	f240 56b3 	movw	r6, #1459	; 0x5b3
    33a8:	f240 57b4 	movw	r7, #1460	; 0x5b4
		for (c = 0; c < max_c;) {
    33ac:	4293      	cmp	r3, r2
    33ae:	d205      	bcs.n	33bc <tcp_parseopt+0x40>
			opt = opts[c];
    33b0:	5ce1      	ldrb	r1, [r4, r3]
			switch (opt) {
    33b2:	2901      	cmp	r1, #1
    33b4:	d003      	beq.n	33be <tcp_parseopt+0x42>
    33b6:	2902      	cmp	r1, #2
    33b8:	d004      	beq.n	33c4 <tcp_parseopt+0x48>
    33ba:	b9c1      	cbnz	r1, 33ee <tcp_parseopt+0x72>
				   can skip past them. */
				c += opts[c + 1];
			}
		}
	}
}
    33bc:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
				++c;
    33be:	3301      	adds	r3, #1
				c += opts[c + 1];
    33c0:	b29b      	uxth	r3, r3
    33c2:	e7f3      	b.n	33ac <tcp_parseopt+0x30>
				if (opts[c + 1] != 0x04 || c + 0x04 > max_c) {
    33c4:	18e0      	adds	r0, r4, r3
    33c6:	7841      	ldrb	r1, [r0, #1]
    33c8:	2904      	cmp	r1, #4
    33ca:	d1f7      	bne.n	33bc <tcp_parseopt+0x40>
    33cc:	1cd9      	adds	r1, r3, #3
    33ce:	b289      	uxth	r1, r1
    33d0:	428a      	cmp	r2, r1
    33d2:	d9f3      	bls.n	33bc <tcp_parseopt+0x40>
				mss = (opts[c + 2] << 8) | opts[c + 3];
    33d4:	f890 c002 	ldrb.w	ip, [r0, #2]
    33d8:	78c1      	ldrb	r1, [r0, #3]
    33da:	ea41 210c 	orr.w	r1, r1, ip, lsl #8
				pcb->mss = ((mss > TCP_MSS) || (mss == 0)) ? TCP_MSS : mss;
    33de:	1e48      	subs	r0, r1, #1
    33e0:	b280      	uxth	r0, r0
    33e2:	42b0      	cmp	r0, r6
    33e4:	bf88      	it	hi
    33e6:	4639      	movhi	r1, r7
    33e8:	86e9      	strh	r1, [r5, #54]	; 0x36
				c += 0x04;
    33ea:	3304      	adds	r3, #4
    33ec:	e7e8      	b.n	33c0 <tcp_parseopt+0x44>
				if (opts[c + 1] == 0) {
    33ee:	18e1      	adds	r1, r4, r3
    33f0:	7849      	ldrb	r1, [r1, #1]
    33f2:	2900      	cmp	r1, #0
    33f4:	d0e2      	beq.n	33bc <tcp_parseopt+0x40>
				c += opts[c + 1];
    33f6:	440b      	add	r3, r1
    33f8:	e7e2      	b.n	33c0 <tcp_parseopt+0x44>
    33fa:	bf00      	nop
    33fc:	2000a4e0 	.word	0x2000a4e0
    3400:	00000d6b 	.word	0x00000d6b

00003404 <tcp_oos_insert_segment>:
{
    3404:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	if (TCPH_FLAGS(cseg->tcphdr) & TCP_FIN) {
    3408:	68c3      	ldr	r3, [r0, #12]
    340a:	4e20      	ldr	r6, [pc, #128]	; (348c <tcp_oos_insert_segment+0x88>)
{
    340c:	4605      	mov	r5, r0
	if (TCPH_FLAGS(cseg->tcphdr) & TCP_FIN) {
    340e:	8998      	ldrh	r0, [r3, #12]
{
    3410:	460c      	mov	r4, r1
	if (TCPH_FLAGS(cseg->tcphdr) & TCP_FIN) {
    3412:	47b0      	blx	r6
    3414:	07c2      	lsls	r2, r0, #31
    3416:	d41a      	bmi.n	344e <tcp_oos_insert_segment+0x4a>
		while (next && TCP_SEQ_GEQ((seqno + cseg->len), (next->tcphdr->seqno + next->len))) {
    3418:	4f1d      	ldr	r7, [pc, #116]	; (3490 <tcp_oos_insert_segment+0x8c>)
				TCPH_SET_FLAG(cseg->tcphdr, TCP_FIN);
    341a:	f8df 8080 	ldr.w	r8, [pc, #128]	; 349c <tcp_oos_insert_segment+0x98>
			tcp_seg_free(old_seg);
    341e:	f8df 9080 	ldr.w	r9, [pc, #128]	; 34a0 <tcp_oos_insert_segment+0x9c>
		while (next && TCP_SEQ_GEQ((seqno + cseg->len), (next->tcphdr->seqno + next->len))) {
    3422:	f8d4 c00c 	ldr.w	ip, [r4, #12]
    3426:	6878      	ldr	r0, [r7, #4]
    3428:	892b      	ldrh	r3, [r5, #8]
    342a:	f8dc 1004 	ldr.w	r1, [ip, #4]
    342e:	8922      	ldrh	r2, [r4, #8]
    3430:	4403      	add	r3, r0
    3432:	440a      	add	r2, r1
    3434:	1a9a      	subs	r2, r3, r2
    3436:	2a00      	cmp	r2, #0
    3438:	da10      	bge.n	345c <tcp_oos_insert_segment+0x58>
		if (next && TCP_SEQ_GT(seqno + cseg->len, next->tcphdr->seqno)) {
    343a:	1a5b      	subs	r3, r3, r1
    343c:	2b00      	cmp	r3, #0
    343e:	dd0a      	ble.n	3456 <tcp_oos_insert_segment+0x52>
			cseg->len = (u16_t)(next->tcphdr->seqno - seqno);
    3440:	1a09      	subs	r1, r1, r0
    3442:	b289      	uxth	r1, r1
			pbuf_realloc(cseg->p, cseg->len);
    3444:	6868      	ldr	r0, [r5, #4]
    3446:	4b13      	ldr	r3, [pc, #76]	; (3494 <tcp_oos_insert_segment+0x90>)
			cseg->len = (u16_t)(next->tcphdr->seqno - seqno);
    3448:	8129      	strh	r1, [r5, #8]
			pbuf_realloc(cseg->p, cseg->len);
    344a:	4798      	blx	r3
    344c:	e003      	b.n	3456 <tcp_oos_insert_segment+0x52>
		tcp_segs_free(next);
    344e:	4620      	mov	r0, r4
    3450:	4b11      	ldr	r3, [pc, #68]	; (3498 <tcp_oos_insert_segment+0x94>)
    3452:	4798      	blx	r3
		next = NULL;
    3454:	2400      	movs	r4, #0
	cseg->next = next;
    3456:	602c      	str	r4, [r5, #0]
}
    3458:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
			if (TCPH_FLAGS(next->tcphdr) & TCP_FIN) {
    345c:	f8bc 000c 	ldrh.w	r0, [ip, #12]
    3460:	47b0      	blx	r6
    3462:	07c3      	lsls	r3, r0, #31
    3464:	d508      	bpl.n	3478 <tcp_oos_insert_segment+0x74>
				TCPH_SET_FLAG(cseg->tcphdr, TCP_FIN);
    3466:	68eb      	ldr	r3, [r5, #12]
    3468:	2001      	movs	r0, #1
    346a:	f8b3 a00c 	ldrh.w	sl, [r3, #12]
    346e:	47c0      	blx	r8
    3470:	68eb      	ldr	r3, [r5, #12]
    3472:	ea4a 0000 	orr.w	r0, sl, r0
    3476:	8198      	strh	r0, [r3, #12]
			next    = next->next;
    3478:	f8d4 a000 	ldr.w	sl, [r4]
			tcp_seg_free(old_seg);
    347c:	4620      	mov	r0, r4
    347e:	47c8      	blx	r9
		while (next && TCP_SEQ_GEQ((seqno + cseg->len), (next->tcphdr->seqno + next->len))) {
    3480:	4654      	mov	r4, sl
    3482:	f1ba 0f00 	cmp.w	sl, #0
    3486:	d1cc      	bne.n	3422 <tcp_oos_insert_segment+0x1e>
    3488:	e7e5      	b.n	3456 <tcp_oos_insert_segment+0x52>
    348a:	bf00      	nop
    348c:	00000d6b 	.word	0x00000d6b
    3490:	2000a4e0 	.word	0x2000a4e0
    3494:	000031e9 	.word	0x000031e9
    3498:	00005b5d 	.word	0x00005b5d
    349c:	00000d65 	.word	0x00000d65
    34a0:	00005b39 	.word	0x00005b39

000034a4 <tcp_receive>:
{
    34a4:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
	if (flags & TCP_ACK) {
    34a8:	4d75      	ldr	r5, [pc, #468]	; (3680 <tcp_receive+0x1dc>)
    34aa:	7a2b      	ldrb	r3, [r5, #8]
    34ac:	06de      	lsls	r6, r3, #27
{
    34ae:	4604      	mov	r4, r0
	if (flags & TCP_ACK) {
    34b0:	f140 8132 	bpl.w	3718 <tcp_receive+0x274>
		right_wnd_edge = pcb->snd_wnd + pcb->snd_wl2;
    34b4:	f8b0 1060 	ldrh.w	r1, [r0, #96]	; 0x60
		if (TCP_SEQ_LT(pcb->snd_wl1, seqno) || (pcb->snd_wl1 == seqno && TCP_SEQ_LT(pcb->snd_wl2, ackno))
    34b8:	686a      	ldr	r2, [r5, #4]
    34ba:	68eb      	ldr	r3, [r5, #12]
    34bc:	e9d0 6015 	ldrd	r6, r0, [r0, #84]	; 0x54
    34c0:	1ab7      	subs	r7, r6, r2
    34c2:	2f00      	cmp	r7, #0
    34c4:	db0a      	blt.n	34dc <tcp_receive+0x38>
    34c6:	4296      	cmp	r6, r2
    34c8:	d102      	bne.n	34d0 <tcp_receive+0x2c>
    34ca:	1ac6      	subs	r6, r0, r3
    34cc:	2e00      	cmp	r6, #0
    34ce:	db05      	blt.n	34dc <tcp_receive+0x38>
		    || (pcb->snd_wl2 == ackno && tcphdr->wnd > pcb->snd_wnd)) {
    34d0:	4298      	cmp	r0, r3
    34d2:	d118      	bne.n	3506 <tcp_receive+0x62>
    34d4:	682e      	ldr	r6, [r5, #0]
    34d6:	89f6      	ldrh	r6, [r6, #14]
    34d8:	428e      	cmp	r6, r1
    34da:	d914      	bls.n	3506 <tcp_receive+0x62>
			pcb->snd_wnd = tcphdr->wnd;
    34dc:	682e      	ldr	r6, [r5, #0]
			if (pcb->snd_wnd_max < tcphdr->wnd) {
    34de:	f8b4 c062 	ldrh.w	ip, [r4, #98]	; 0x62
			pcb->snd_wnd = tcphdr->wnd;
    34e2:	89f6      	ldrh	r6, [r6, #14]
    34e4:	f8a4 6060 	strh.w	r6, [r4, #96]	; 0x60
    34e8:	b2b7      	uxth	r7, r6
			if (pcb->snd_wnd_max < tcphdr->wnd) {
    34ea:	45bc      	cmp	ip, r7
			pcb->snd_wl2 = ackno;
    34ec:	e9c4 2315 	strd	r2, r3, [r4, #84]	; 0x54
				pcb->snd_wnd_max = tcphdr->wnd;
    34f0:	bf38      	it	cc
    34f2:	f8a4 6062 	strhcc.w	r6, [r4, #98]	; 0x62
				if (pcb->persist_backoff == 0) {
    34f6:	f894 2095 	ldrb.w	r2, [r4, #149]	; 0x95
			if (pcb->snd_wnd == 0) {
    34fa:	bb97      	cbnz	r7, 3562 <tcp_receive+0xbe>
				if (pcb->persist_backoff == 0) {
    34fc:	b91a      	cbnz	r2, 3506 <tcp_receive+0x62>
					pcb->persist_cnt     = 0;
    34fe:	f44f 7280 	mov.w	r2, #256	; 0x100
    3502:	f8a4 2094 	strh.w	r2, [r4, #148]	; 0x94
		if (TCP_SEQ_LEQ(ackno, pcb->lastack)) {
    3506:	6ca6      	ldr	r6, [r4, #72]	; 0x48
    3508:	1b9a      	subs	r2, r3, r6
    350a:	2a00      	cmp	r2, #0
    350c:	dc38      	bgt.n	3580 <tcp_receive+0xdc>
			pcb->acked = 0;
    350e:	2200      	movs	r2, #0
    3510:	f8a4 2064 	strh.w	r2, [r4, #100]	; 0x64
			if (tcplen == 0) {
    3514:	8a2a      	ldrh	r2, [r5, #16]
    3516:	bb7a      	cbnz	r2, 3578 <tcp_receive+0xd4>
				if (pcb->snd_wl2 + pcb->snd_wnd == right_wnd_edge) {
    3518:	f8b4 2060 	ldrh.w	r2, [r4, #96]	; 0x60
    351c:	6da7      	ldr	r7, [r4, #88]	; 0x58
		right_wnd_edge = pcb->snd_wnd + pcb->snd_wl2;
    351e:	4401      	add	r1, r0
				if (pcb->snd_wl2 + pcb->snd_wnd == right_wnd_edge) {
    3520:	443a      	add	r2, r7
    3522:	428a      	cmp	r2, r1
    3524:	d128      	bne.n	3578 <tcp_receive+0xd4>
					if (pcb->rtime >= 0) {
    3526:	f9b4 2034 	ldrsh.w	r2, [r4, #52]	; 0x34
    352a:	2a00      	cmp	r2, #0
    352c:	db24      	blt.n	3578 <tcp_receive+0xd4>
						if (pcb->lastack == ackno) {
    352e:	429e      	cmp	r6, r3
    3530:	d122      	bne.n	3578 <tcp_receive+0xd4>
							if ((u8_t)(pcb->dupacks + 1) > pcb->dupacks) {
    3532:	f894 3047 	ldrb.w	r3, [r4, #71]	; 0x47
    3536:	2bff      	cmp	r3, #255	; 0xff
								++pcb->dupacks;
    3538:	bf1c      	itt	ne
    353a:	3301      	addne	r3, #1
    353c:	f884 3047 	strbne.w	r3, [r4, #71]	; 0x47
							if (pcb->dupacks > 3) {
    3540:	f894 3047 	ldrb.w	r3, [r4, #71]	; 0x47
    3544:	2b03      	cmp	r3, #3
    3546:	d912      	bls.n	356e <tcp_receive+0xca>
								if ((u16_t)(pcb->cwnd + pcb->mss) > pcb->cwnd) {
    3548:	f8b4 204c 	ldrh.w	r2, [r4, #76]	; 0x4c
    354c:	8ee3      	ldrh	r3, [r4, #54]	; 0x36
    354e:	4413      	add	r3, r2
    3550:	b29b      	uxth	r3, r3
    3552:	429a      	cmp	r2, r3
    3554:	d201      	bcs.n	355a <tcp_receive+0xb6>
									pcb->cwnd += pcb->mss;
    3556:	f8a4 304c 	strh.w	r3, [r4, #76]	; 0x4c
		       && TCP_SEQ_BETWEEN(ackno, ntohl(pcb->unsent->tcphdr->seqno) + TCP_TCPLEN(pcb->unsent), pcb->snd_nxt)) {
    355a:	f8df 8130 	ldr.w	r8, [pc, #304]	; 368c <tcp_receive+0x1e8>
    355e:	4f49      	ldr	r7, [pc, #292]	; (3684 <tcp_receive+0x1e0>)
    3560:	e0d3      	b.n	370a <tcp_receive+0x266>
			} else if (pcb->persist_backoff > 0) {
    3562:	2a00      	cmp	r2, #0
    3564:	d0cf      	beq.n	3506 <tcp_receive+0x62>
				pcb->persist_backoff = 0;
    3566:	2200      	movs	r2, #0
    3568:	f884 2095 	strb.w	r2, [r4, #149]	; 0x95
    356c:	e7cb      	b.n	3506 <tcp_receive+0x62>
							} else if (pcb->dupacks == 3) {
    356e:	d1f4      	bne.n	355a <tcp_receive+0xb6>
								tcp_rexmit_fast(pcb);
    3570:	4b45      	ldr	r3, [pc, #276]	; (3688 <tcp_receive+0x1e4>)
    3572:	4620      	mov	r0, r4
    3574:	4798      	blx	r3
			if (!found_dupack) {
    3576:	e7f0      	b.n	355a <tcp_receive+0xb6>
				pcb->dupacks = 0;
    3578:	2300      	movs	r3, #0
    357a:	f884 3047 	strb.w	r3, [r4, #71]	; 0x47
    357e:	e7ec      	b.n	355a <tcp_receive+0xb6>
		} else if (TCP_SEQ_BETWEEN(ackno, pcb->lastack + 1, pcb->snd_nxt)) {
    3580:	6d21      	ldr	r1, [r4, #80]	; 0x50
    3582:	1a59      	subs	r1, r3, r1
    3584:	2900      	cmp	r1, #0
    3586:	dc76      	bgt.n	3676 <tcp_receive+0x1d2>
			if (pcb->flags & TF_INFR) {
    3588:	7fa1      	ldrb	r1, [r4, #30]
			pcb->lastack = ackno;
    358a:	64a3      	str	r3, [r4, #72]	; 0x48
			if (pcb->flags & TF_INFR) {
    358c:	0748      	lsls	r0, r1, #29
				pcb->flags &= ~TF_INFR;
    358e:	bf41      	itttt	mi
    3590:	f021 0104 	bicmi.w	r1, r1, #4
    3594:	77a1      	strbmi	r1, [r4, #30]
				pcb->cwnd = pcb->ssthresh;
    3596:	f8b4 104e 	ldrhmi.w	r1, [r4, #78]	; 0x4e
    359a:	f8a4 104c 	strhmi.w	r1, [r4, #76]	; 0x4c
			pcb->rto = (pcb->sa >> 3) + pcb->sv;
    359e:	f9b4 0040 	ldrsh.w	r0, [r4, #64]	; 0x40
    35a2:	f8b4 1042 	ldrh.w	r1, [r4, #66]	; 0x42
			if (pcb->state >= ESTABLISHED) {
    35a6:	7e23      	ldrb	r3, [r4, #24]
			pcb->rto = (pcb->sa >> 3) + pcb->sv;
    35a8:	eb01 01e0 	add.w	r1, r1, r0, asr #3
    35ac:	f8a4 1044 	strh.w	r1, [r4, #68]	; 0x44
			pcb->snd_buf += pcb->acked;
    35b0:	f8b4 1066 	ldrh.w	r1, [r4, #102]	; 0x66
			pcb->acked = (u16_t)(ackno - pcb->lastack);
    35b4:	b292      	uxth	r2, r2
    35b6:	f8a4 2064 	strh.w	r2, [r4, #100]	; 0x64
			pcb->snd_buf += pcb->acked;
    35ba:	440a      	add	r2, r1
    35bc:	f8a4 2066 	strh.w	r2, [r4, #102]	; 0x66
			if (pcb->state >= ESTABLISHED) {
    35c0:	2b03      	cmp	r3, #3
			pcb->nrtx = 0;
    35c2:	f04f 0200 	mov.w	r2, #0
    35c6:	f8a4 2046 	strh.w	r2, [r4, #70]	; 0x46
			if (pcb->state >= ESTABLISHED) {
    35ca:	d90f      	bls.n	35ec <tcp_receive+0x148>
				if (pcb->cwnd < pcb->ssthresh) {
    35cc:	f8b4 204c 	ldrh.w	r2, [r4, #76]	; 0x4c
    35d0:	f8b4 104e 	ldrh.w	r1, [r4, #78]	; 0x4e
								if ((u16_t)(pcb->cwnd + pcb->mss) > pcb->cwnd) {
    35d4:	8ee3      	ldrh	r3, [r4, #54]	; 0x36
				if (pcb->cwnd < pcb->ssthresh) {
    35d6:	4291      	cmp	r1, r2
					u16_t new_cwnd = (pcb->cwnd + pcb->mss * pcb->mss / pcb->cwnd);
    35d8:	bf9c      	itt	ls
    35da:	435b      	mulls	r3, r3
    35dc:	fbb3 f3f2 	udivls	r3, r3, r2
    35e0:	4413      	add	r3, r2
    35e2:	b29b      	uxth	r3, r3
					if (new_cwnd > pcb->cwnd) {
    35e4:	429a      	cmp	r2, r3
    35e6:	d201      	bcs.n	35ec <tcp_receive+0x148>
						pcb->cwnd = new_cwnd;
    35e8:	f8a4 304c 	strh.w	r3, [r4, #76]	; 0x4c
			       && TCP_SEQ_LEQ(ntohl(pcb->unacked->tcphdr->seqno) + TCP_TCPLEN(pcb->unacked), ackno)) {
    35ec:	4f27      	ldr	r7, [pc, #156]	; (368c <tcp_receive+0x1e8>)
    35ee:	4e25      	ldr	r6, [pc, #148]	; (3684 <tcp_receive+0x1e0>)
				pcb->snd_queuelen -= pbuf_clen(next->p);
    35f0:	f8df 80a0 	ldr.w	r8, [pc, #160]	; 3694 <tcp_receive+0x1f0>
    35f4:	e033      	b.n	365e <tcp_receive+0x1ba>
			       && TCP_SEQ_LEQ(ntohl(pcb->unacked->tcphdr->seqno) + TCP_TCPLEN(pcb->unacked), ackno)) {
    35f6:	68db      	ldr	r3, [r3, #12]
    35f8:	6858      	ldr	r0, [r3, #4]
    35fa:	47b8      	blx	r7
    35fc:	6f22      	ldr	r2, [r4, #112]	; 0x70
    35fe:	68d3      	ldr	r3, [r2, #12]
    3600:	f8b2 a008 	ldrh.w	sl, [r2, #8]
    3604:	4681      	mov	r9, r0
    3606:	8998      	ldrh	r0, [r3, #12]
    3608:	47b0      	blx	r6
    360a:	f010 0303 	ands.w	r3, r0, #3
    360e:	68e8      	ldr	r0, [r5, #12]
    3610:	bf18      	it	ne
    3612:	2301      	movne	r3, #1
    3614:	4453      	add	r3, sl
    3616:	eba9 0900 	sub.w	r9, r9, r0
    361a:	444b      	add	r3, r9
    361c:	2b00      	cmp	r3, #0
    361e:	dc21      	bgt.n	3664 <tcp_receive+0x1c0>
				next         = pcb->unacked;
    3620:	f8d4 9070 	ldr.w	r9, [r4, #112]	; 0x70
				pcb->unacked = pcb->unacked->next;
    3624:	f8d9 3000 	ldr.w	r3, [r9]
    3628:	6723      	str	r3, [r4, #112]	; 0x70
				if ((pcb->acked != 0) && ((TCPH_FLAGS(next->tcphdr) & TCP_FIN) != 0)) {
    362a:	f8b4 3064 	ldrh.w	r3, [r4, #100]	; 0x64
    362e:	b15b      	cbz	r3, 3648 <tcp_receive+0x1a4>
    3630:	f8d9 300c 	ldr.w	r3, [r9, #12]
    3634:	8998      	ldrh	r0, [r3, #12]
    3636:	47b0      	blx	r6
    3638:	07c1      	lsls	r1, r0, #31
					pcb->acked--;
    363a:	bf42      	ittt	mi
    363c:	f8b4 3064 	ldrhmi.w	r3, [r4, #100]	; 0x64
    3640:	f103 33ff 	addmi.w	r3, r3, #4294967295	; 0xffffffff
    3644:	f8a4 3064 	strhmi.w	r3, [r4, #100]	; 0x64
				pcb->snd_queuelen -= pbuf_clen(next->p);
    3648:	f8d9 0004 	ldr.w	r0, [r9, #4]
    364c:	47c0      	blx	r8
    364e:	f8b4 3068 	ldrh.w	r3, [r4, #104]	; 0x68
    3652:	1a18      	subs	r0, r3, r0
    3654:	f8a4 0068 	strh.w	r0, [r4, #104]	; 0x68
				tcp_seg_free(next);
    3658:	4b0d      	ldr	r3, [pc, #52]	; (3690 <tcp_receive+0x1ec>)
    365a:	4648      	mov	r0, r9
    365c:	4798      	blx	r3
			while (pcb->unacked != NULL
    365e:	6f23      	ldr	r3, [r4, #112]	; 0x70
    3660:	2b00      	cmp	r3, #0
    3662:	d1c8      	bne.n	35f6 <tcp_receive+0x152>
			if (pcb->unacked == NULL)
    3664:	6f23      	ldr	r3, [r4, #112]	; 0x70
    3666:	fab3 f383 	clz	r3, r3
    366a:	095b      	lsrs	r3, r3, #5
    366c:	425b      	negs	r3, r3
    366e:	86a3      	strh	r3, [r4, #52]	; 0x34
			pcb->polltmr = 0;
    3670:	2300      	movs	r3, #0
    3672:	77e3      	strb	r3, [r4, #31]
    3674:	e771      	b.n	355a <tcp_receive+0xb6>
			pcb->acked = 0;
    3676:	2300      	movs	r3, #0
    3678:	f8a4 3064 	strh.w	r3, [r4, #100]	; 0x64
    367c:	e76d      	b.n	355a <tcp_receive+0xb6>
    367e:	bf00      	nop
    3680:	2000a4e0 	.word	0x2000a4e0
    3684:	00000d6b 	.word	0x00000d6b
    3688:	00002805 	.word	0x00002805
    368c:	00000d75 	.word	0x00000d75
    3690:	00005b39 	.word	0x00005b39
    3694:	0000323d 	.word	0x0000323d
		       && TCP_SEQ_BETWEEN(ackno, ntohl(pcb->unsent->tcphdr->seqno) + TCP_TCPLEN(pcb->unsent), pcb->snd_nxt)) {
    3698:	68db      	ldr	r3, [r3, #12]
    369a:	68ee      	ldr	r6, [r5, #12]
    369c:	6858      	ldr	r0, [r3, #4]
    369e:	47c0      	blx	r8
    36a0:	6ee3      	ldr	r3, [r4, #108]	; 0x6c
    36a2:	f8b3 a008 	ldrh.w	sl, [r3, #8]
    36a6:	68db      	ldr	r3, [r3, #12]
    36a8:	4681      	mov	r9, r0
    36aa:	8998      	ldrh	r0, [r3, #12]
    36ac:	47b8      	blx	r7
    36ae:	f010 0003 	ands.w	r0, r0, #3
    36b2:	bf18      	it	ne
    36b4:	2001      	movne	r0, #1
    36b6:	eba6 0609 	sub.w	r6, r6, r9
    36ba:	4450      	add	r0, sl
    36bc:	1a30      	subs	r0, r6, r0
    36be:	2800      	cmp	r0, #0
    36c0:	db26      	blt.n	3710 <tcp_receive+0x26c>
    36c2:	68eb      	ldr	r3, [r5, #12]
    36c4:	6d22      	ldr	r2, [r4, #80]	; 0x50
    36c6:	1a9b      	subs	r3, r3, r2
    36c8:	2b00      	cmp	r3, #0
    36ca:	dc21      	bgt.n	3710 <tcp_receive+0x26c>
			next        = pcb->unsent;
    36cc:	6ee6      	ldr	r6, [r4, #108]	; 0x6c
			pcb->unsent = pcb->unsent->next;
    36ce:	6833      	ldr	r3, [r6, #0]
    36d0:	66e3      	str	r3, [r4, #108]	; 0x6c
			if (pcb->unsent == NULL) {
    36d2:	b90b      	cbnz	r3, 36d8 <tcp_receive+0x234>
				pcb->unsent_oversize = 0;
    36d4:	f8a4 306a 	strh.w	r3, [r4, #106]	; 0x6a
			if ((pcb->acked != 0) && ((TCPH_FLAGS(next->tcphdr) & TCP_FIN) != 0)) {
    36d8:	f8b4 3064 	ldrh.w	r3, [r4, #100]	; 0x64
    36dc:	b153      	cbz	r3, 36f4 <tcp_receive+0x250>
    36de:	68f3      	ldr	r3, [r6, #12]
    36e0:	8998      	ldrh	r0, [r3, #12]
    36e2:	47b8      	blx	r7
    36e4:	07c2      	lsls	r2, r0, #31
				pcb->acked--;
    36e6:	bf42      	ittt	mi
    36e8:	f8b4 3064 	ldrhmi.w	r3, [r4, #100]	; 0x64
    36ec:	f103 33ff 	addmi.w	r3, r3, #4294967295	; 0xffffffff
    36f0:	f8a4 3064 	strhmi.w	r3, [r4, #100]	; 0x64
			pcb->snd_queuelen -= pbuf_clen(next->p);
    36f4:	4b95      	ldr	r3, [pc, #596]	; (394c <tcp_receive+0x4a8>)
    36f6:	6870      	ldr	r0, [r6, #4]
    36f8:	4798      	blx	r3
    36fa:	f8b4 3068 	ldrh.w	r3, [r4, #104]	; 0x68
    36fe:	1a18      	subs	r0, r3, r0
    3700:	f8a4 0068 	strh.w	r0, [r4, #104]	; 0x68
			tcp_seg_free(next);
    3704:	4b92      	ldr	r3, [pc, #584]	; (3950 <tcp_receive+0x4ac>)
    3706:	4630      	mov	r0, r6
    3708:	4798      	blx	r3
		while (pcb->unsent != NULL
    370a:	6ee3      	ldr	r3, [r4, #108]	; 0x6c
    370c:	2b00      	cmp	r3, #0
    370e:	d1c3      	bne.n	3698 <tcp_receive+0x1f4>
		if (pcb->rttest && TCP_SEQ_LT(pcb->rtseq, ackno)) {
    3710:	6ba1      	ldr	r1, [r4, #56]	; 0x38
    3712:	2900      	cmp	r1, #0
    3714:	f040 80a9 	bne.w	386a <tcp_receive+0x3c6>
	if ((tcplen > 0) && (pcb->state < CLOSE_WAIT)) {
    3718:	8a2e      	ldrh	r6, [r5, #16]
		if (TCP_SEQ_BETWEEN(pcb->rcv_nxt, seqno + 1, seqno + tcplen - 1)) {
    371a:	686b      	ldr	r3, [r5, #4]
    371c:	6aa2      	ldr	r2, [r4, #40]	; 0x28
	if ((tcplen > 0) && (pcb->state < CLOSE_WAIT)) {
    371e:	2e00      	cmp	r6, #0
    3720:	f000 824d 	beq.w	3bbe <tcp_receive+0x71a>
    3724:	7e21      	ldrb	r1, [r4, #24]
    3726:	2906      	cmp	r1, #6
    3728:	f200 8249 	bhi.w	3bbe <tcp_receive+0x71a>
		if (TCP_SEQ_BETWEEN(pcb->rcv_nxt, seqno + 1, seqno + tcplen - 1)) {
    372c:	1ad1      	subs	r1, r2, r3
    372e:	2901      	cmp	r1, #1
    3730:	f100 80cd 	bmi.w	38ce <tcp_receive+0x42a>
    3734:	f1c3 0001 	rsb	r0, r3, #1
    3738:	1b80      	subs	r0, r0, r6
    373a:	4410      	add	r0, r2
    373c:	2800      	cmp	r0, #0
    373e:	f300 80c6 	bgt.w	38ce <tcp_receive+0x42a>
			p   = inseg.p;
    3742:	69a8      	ldr	r0, [r5, #24]
			if (inseg.p->len < off) {
    3744:	8943      	ldrh	r3, [r0, #10]
    3746:	428b      	cmp	r3, r1
				new_tot_len = (u16_t)(inseg.p->tot_len - off);
    3748:	b28a      	uxth	r2, r1
			if (inseg.p->len < off) {
    374a:	f280 80bd 	bge.w	38c8 <tcp_receive+0x424>
				new_tot_len = (u16_t)(inseg.p->tot_len - off);
    374e:	8903      	ldrh	r3, [r0, #8]
    3750:	1a9b      	subs	r3, r3, r2
    3752:	b29b      	uxth	r3, r3
					p->len     = 0;
    3754:	2600      	movs	r6, #0
				while (p->len < off) {
    3756:	8942      	ldrh	r2, [r0, #10]
    3758:	428a      	cmp	r2, r1
    375a:	f2c0 80b0 	blt.w	38be <tcp_receive+0x41a>
				if (pbuf_header(p, (s16_t)-off)) {
    375e:	4249      	negs	r1, r1
    3760:	b209      	sxth	r1, r1
				if (pbuf_header(inseg.p, (s16_t)-off)) {
    3762:	4b7c      	ldr	r3, [pc, #496]	; (3954 <tcp_receive+0x4b0>)
    3764:	4798      	blx	r3
			inseg.len -= (u16_t)(pcb->rcv_nxt - seqno);
    3766:	8ba9      	ldrh	r1, [r5, #28]
    3768:	686b      	ldr	r3, [r5, #4]
    376a:	6aa2      	ldr	r2, [r4, #40]	; 0x28
			inseg.tcphdr->seqno = seqno = pcb->rcv_nxt;
    376c:	606a      	str	r2, [r5, #4]
			inseg.len -= (u16_t)(pcb->rcv_nxt - seqno);
    376e:	440b      	add	r3, r1
    3770:	1a9b      	subs	r3, r3, r2
    3772:	83ab      	strh	r3, [r5, #28]
			inseg.tcphdr->seqno = seqno = pcb->rcv_nxt;
    3774:	6a2b      	ldr	r3, [r5, #32]
    3776:	605a      	str	r2, [r3, #4]
		if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, pcb->rcv_nxt + pcb->rcv_wnd - 1)) {
    3778:	6869      	ldr	r1, [r5, #4]
    377a:	6aa2      	ldr	r2, [r4, #40]	; 0x28
    377c:	1a8b      	subs	r3, r1, r2
    377e:	2b00      	cmp	r3, #0
    3780:	f2c0 8217 	blt.w	3bb2 <tcp_receive+0x70e>
    3784:	8da0      	ldrh	r0, [r4, #44]	; 0x2c
    3786:	1c4b      	adds	r3, r1, #1
    3788:	1a9b      	subs	r3, r3, r2
    378a:	1a1b      	subs	r3, r3, r0
    378c:	2b00      	cmp	r3, #0
    378e:	f300 8210 	bgt.w	3bb2 <tcp_receive+0x70e>
			if (pcb->rcv_nxt == seqno) {
    3792:	4291      	cmp	r1, r2
    3794:	f040 815f 	bne.w	3a56 <tcp_receive+0x5b2>
				tcplen = TCP_TCPLEN(&inseg);
    3798:	6a2b      	ldr	r3, [r5, #32]
    379a:	4e6f      	ldr	r6, [pc, #444]	; (3958 <tcp_receive+0x4b4>)
    379c:	8998      	ldrh	r0, [r3, #12]
    379e:	8baf      	ldrh	r7, [r5, #28]
    37a0:	47b0      	blx	r6
    37a2:	f010 0003 	ands.w	r0, r0, #3
    37a6:	bf18      	it	ne
    37a8:	2001      	movne	r0, #1
				if (tcplen > pcb->rcv_wnd) {
    37aa:	8da3      	ldrh	r3, [r4, #44]	; 0x2c
				tcplen = TCP_TCPLEN(&inseg);
    37ac:	4438      	add	r0, r7
    37ae:	b280      	uxth	r0, r0
				if (tcplen > pcb->rcv_wnd) {
    37b0:	4283      	cmp	r3, r0
				tcplen = TCP_TCPLEN(&inseg);
    37b2:	8228      	strh	r0, [r5, #16]
				if (tcplen > pcb->rcv_wnd) {
    37b4:	d22b      	bcs.n	380e <tcp_receive+0x36a>
					if (TCPH_FLAGS(inseg.tcphdr) & TCP_FIN) {
    37b6:	6a2b      	ldr	r3, [r5, #32]
    37b8:	8998      	ldrh	r0, [r3, #12]
    37ba:	47b0      	blx	r6
    37bc:	07c3      	lsls	r3, r0, #31
    37be:	d50c      	bpl.n	37da <tcp_receive+0x336>
						TCPH_FLAGS_SET(inseg.tcphdr, TCPH_FLAGS(inseg.tcphdr) & ~TCP_FIN);
    37c0:	6a2b      	ldr	r3, [r5, #32]
    37c2:	899f      	ldrh	r7, [r3, #12]
    37c4:	4638      	mov	r0, r7
    37c6:	47b0      	blx	r6
    37c8:	4b64      	ldr	r3, [pc, #400]	; (395c <tcp_receive+0x4b8>)
    37ca:	f000 003e 	and.w	r0, r0, #62	; 0x3e
    37ce:	4798      	blx	r3
    37d0:	f427 577c 	bic.w	r7, r7, #16128	; 0x3f00
    37d4:	6a2b      	ldr	r3, [r5, #32]
    37d6:	4307      	orrs	r7, r0
    37d8:	819f      	strh	r7, [r3, #12]
					inseg.len = pcb->rcv_wnd;
    37da:	8da3      	ldrh	r3, [r4, #44]	; 0x2c
    37dc:	83ab      	strh	r3, [r5, #28]
					if (TCPH_FLAGS(inseg.tcphdr) & TCP_SYN) {
    37de:	6a2b      	ldr	r3, [r5, #32]
    37e0:	8998      	ldrh	r0, [r3, #12]
    37e2:	47b0      	blx	r6
    37e4:	0787      	lsls	r7, r0, #30
						inseg.len -= 1;
    37e6:	bf48      	it	mi
    37e8:	8bab      	ldrhmi	r3, [r5, #28]
					pbuf_realloc(inseg.p, inseg.len);
    37ea:	69a8      	ldr	r0, [r5, #24]
						inseg.len -= 1;
    37ec:	bf44      	itt	mi
    37ee:	f103 33ff 	addmi.w	r3, r3, #4294967295	; 0xffffffff
    37f2:	83ab      	strhmi	r3, [r5, #28]
					pbuf_realloc(inseg.p, inseg.len);
    37f4:	8ba9      	ldrh	r1, [r5, #28]
    37f6:	4b5a      	ldr	r3, [pc, #360]	; (3960 <tcp_receive+0x4bc>)
    37f8:	4798      	blx	r3
					tcplen = TCP_TCPLEN(&inseg);
    37fa:	6a2b      	ldr	r3, [r5, #32]
    37fc:	8baf      	ldrh	r7, [r5, #28]
    37fe:	8998      	ldrh	r0, [r3, #12]
    3800:	47b0      	blx	r6
    3802:	f010 0003 	ands.w	r0, r0, #3
    3806:	bf18      	it	ne
    3808:	2001      	movne	r0, #1
    380a:	4438      	add	r0, r7
    380c:	8228      	strh	r0, [r5, #16]
				if (pcb->ooseq != NULL) {
    380e:	6f63      	ldr	r3, [r4, #116]	; 0x74
    3810:	b143      	cbz	r3, 3824 <tcp_receive+0x380>
					if (TCPH_FLAGS(inseg.tcphdr) & TCP_FIN) {
    3812:	6a2b      	ldr	r3, [r5, #32]
    3814:	8998      	ldrh	r0, [r3, #12]
    3816:	47b0      	blx	r6
    3818:	07c0      	lsls	r0, r0, #31
    381a:	d564      	bpl.n	38e6 <tcp_receive+0x442>
							tcp_seg_free(old_ooseq);
    381c:	4f4c      	ldr	r7, [pc, #304]	; (3950 <tcp_receive+0x4ac>)
						while (pcb->ooseq != NULL) {
    381e:	6f60      	ldr	r0, [r4, #116]	; 0x74
    3820:	2800      	cmp	r0, #0
    3822:	d15c      	bne.n	38de <tcp_receive+0x43a>
				pcb->rcv_nxt = seqno + tcplen;
    3824:	8a29      	ldrh	r1, [r5, #16]
				pcb->rcv_wnd -= tcplen;
    3826:	8da3      	ldrh	r3, [r4, #44]	; 0x2c
				pcb->rcv_nxt = seqno + tcplen;
    3828:	686a      	ldr	r2, [r5, #4]
				tcp_update_rcv_ann_wnd(pcb);
    382a:	4f4e      	ldr	r7, [pc, #312]	; (3964 <tcp_receive+0x4c0>)
				pcb->rcv_nxt = seqno + tcplen;
    382c:	440a      	add	r2, r1
				pcb->rcv_wnd -= tcplen;
    382e:	1a5b      	subs	r3, r3, r1
				pcb->rcv_nxt = seqno + tcplen;
    3830:	62a2      	str	r2, [r4, #40]	; 0x28
				pcb->rcv_wnd -= tcplen;
    3832:	85a3      	strh	r3, [r4, #44]	; 0x2c
				tcp_update_rcv_ann_wnd(pcb);
    3834:	4620      	mov	r0, r4
    3836:	47b8      	blx	r7
				if (inseg.p->tot_len > 0) {
    3838:	69ab      	ldr	r3, [r5, #24]
    383a:	9701      	str	r7, [sp, #4]
    383c:	891a      	ldrh	r2, [r3, #8]
    383e:	b112      	cbz	r2, 3846 <tcp_receive+0x3a2>
					recv_data = inseg.p;
    3840:	626b      	str	r3, [r5, #36]	; 0x24
					inseg.p = NULL;
    3842:	2300      	movs	r3, #0
    3844:	61ab      	str	r3, [r5, #24]
				if (TCPH_FLAGS(inseg.tcphdr) & TCP_FIN) {
    3846:	6a2b      	ldr	r3, [r5, #32]
    3848:	8998      	ldrh	r0, [r3, #12]
    384a:	47b0      	blx	r6
    384c:	07c7      	lsls	r7, r0, #31
    384e:	d505      	bpl.n	385c <tcp_receive+0x3b8>
					recv_flags |= TF_GOT_FIN;
    3850:	f895 3028 	ldrb.w	r3, [r5, #40]	; 0x28
    3854:	f043 0320 	orr.w	r3, r3, #32
    3858:	f885 3028 	strb.w	r3, [r5, #40]	; 0x28
							pbuf_cat(recv_data, cseg->p);
    385c:	f8df a10c 	ldr.w	sl, [pc, #268]	; 396c <tcp_receive+0x4c8>
					tcp_seg_free(cseg);
    3860:	f8df b0ec 	ldr.w	fp, [pc, #236]	; 3950 <tcp_receive+0x4ac>
						cseg->p = NULL;
    3864:	f04f 0900 	mov.w	r9, #0
    3868:	e0de      	b.n	3a28 <tcp_receive+0x584>
		if (pcb->rttest && TCP_SEQ_LT(pcb->rtseq, ackno)) {
    386a:	6be3      	ldr	r3, [r4, #60]	; 0x3c
    386c:	68ea      	ldr	r2, [r5, #12]
    386e:	1a9b      	subs	r3, r3, r2
    3870:	2b00      	cmp	r3, #0
    3872:	f6bf af51 	bge.w	3718 <tcp_receive+0x274>
			m = (s16_t)(tcp_ticks - pcb->rttest);
    3876:	4b3c      	ldr	r3, [pc, #240]	; (3968 <tcp_receive+0x4c4>)
    3878:	881f      	ldrh	r7, [r3, #0]
			m = m - (pcb->sa >> 3);
    387a:	f9b4 3040 	ldrsh.w	r3, [r4, #64]	; 0x40
			m = (s16_t)(tcp_ticks - pcb->rttest);
    387e:	b289      	uxth	r1, r1
			m = m - (pcb->sa >> 3);
    3880:	f3c3 00cf 	ubfx	r0, r3, #3, #16
			m = (s16_t)(tcp_ticks - pcb->rttest);
    3884:	1a7a      	subs	r2, r7, r1
			m = m - (pcb->sa >> 3);
    3886:	1a12      	subs	r2, r2, r0
    3888:	b216      	sxth	r6, r2
			if (m < 0) {
    388a:	2e00      	cmp	r6, #0
			pcb->sa += m;
    388c:	fa13 f282 	uxtah	r2, r3, r2
				m = -m;
    3890:	bfb8      	it	lt
    3892:	1bc9      	sublt	r1, r1, r7
			m = m - (pcb->sv >> 2);
    3894:	f9b4 3042 	ldrsh.w	r3, [r4, #66]	; 0x42
				m = -m;
    3898:	bfbc      	itt	lt
    389a:	1809      	addlt	r1, r1, r0
    389c:	b20e      	sxthlt	r6, r1
			pcb->sv += m;
    389e:	eba3 03a3 	sub.w	r3, r3, r3, asr #2
    38a2:	4433      	add	r3, r6
			pcb->sa += m;
    38a4:	b212      	sxth	r2, r2
			pcb->sv += m;
    38a6:	b29b      	uxth	r3, r3
    38a8:	f8a4 3042 	strh.w	r3, [r4, #66]	; 0x42
			pcb->rto = (pcb->sa >> 3) + pcb->sv;
    38ac:	eb03 03e2 	add.w	r3, r3, r2, asr #3
    38b0:	f8a4 3044 	strh.w	r3, [r4, #68]	; 0x44
			pcb->rttest = 0;
    38b4:	2300      	movs	r3, #0
			pcb->sa += m;
    38b6:	f8a4 2040 	strh.w	r2, [r4, #64]	; 0x40
			pcb->rttest = 0;
    38ba:	63a3      	str	r3, [r4, #56]	; 0x38
    38bc:	e72c      	b.n	3718 <tcp_receive+0x274>
					p->tot_len = new_tot_len;
    38be:	8103      	strh	r3, [r0, #8]
					p->len     = 0;
    38c0:	8146      	strh	r6, [r0, #10]
					off -= p->len;
    38c2:	1a89      	subs	r1, r1, r2
					p          = p->next;
    38c4:	6800      	ldr	r0, [r0, #0]
    38c6:	e746      	b.n	3756 <tcp_receive+0x2b2>
				if (pbuf_header(inseg.p, (s16_t)-off)) {
    38c8:	4252      	negs	r2, r2
    38ca:	b211      	sxth	r1, r2
    38cc:	e749      	b.n	3762 <tcp_receive+0x2be>
			if (TCP_SEQ_LT(seqno, pcb->rcv_nxt)) {
    38ce:	1a9b      	subs	r3, r3, r2
    38d0:	2b00      	cmp	r3, #0
				tcp_ack_now(pcb);
    38d2:	bfbe      	ittt	lt
    38d4:	7fa3      	ldrblt	r3, [r4, #30]
    38d6:	f043 0302 	orrlt.w	r3, r3, #2
    38da:	77a3      	strblt	r3, [r4, #30]
    38dc:	e74c      	b.n	3778 <tcp_receive+0x2d4>
							pcb->ooseq                = pcb->ooseq->next;
    38de:	6803      	ldr	r3, [r0, #0]
    38e0:	6763      	str	r3, [r4, #116]	; 0x74
							tcp_seg_free(old_ooseq);
    38e2:	47b8      	blx	r7
    38e4:	e79b      	b.n	381e <tcp_receive+0x37a>
						next = pcb->ooseq;
    38e6:	6f67      	ldr	r7, [r4, #116]	; 0x74
								TCPH_SET_FLAG(inseg.tcphdr, TCP_FIN);
    38e8:	f8df 8070 	ldr.w	r8, [pc, #112]	; 395c <tcp_receive+0x4b8>
							tcp_seg_free(prev);
    38ec:	f8df 9060 	ldr.w	r9, [pc, #96]	; 3950 <tcp_receive+0x4ac>
						while (next && TCP_SEQ_GEQ(seqno + tcplen, next->tcphdr->seqno + next->len)) {
    38f0:	6868      	ldr	r0, [r5, #4]
    38f2:	8a2b      	ldrh	r3, [r5, #16]
    38f4:	4403      	add	r3, r0
    38f6:	b337      	cbz	r7, 3946 <tcp_receive+0x4a2>
    38f8:	f8d7 c00c 	ldr.w	ip, [r7, #12]
    38fc:	8939      	ldrh	r1, [r7, #8]
    38fe:	f8dc 2004 	ldr.w	r2, [ip, #4]
    3902:	4411      	add	r1, r2
    3904:	1a59      	subs	r1, r3, r1
    3906:	2900      	cmp	r1, #0
    3908:	da32      	bge.n	3970 <tcp_receive+0x4cc>
						if (next && TCP_SEQ_GT(seqno + tcplen, next->tcphdr->seqno)) {
    390a:	1a9b      	subs	r3, r3, r2
    390c:	2b00      	cmp	r3, #0
    390e:	dd1a      	ble.n	3946 <tcp_receive+0x4a2>
							if (TCPH_FLAGS(inseg.tcphdr) & TCP_SYN) {
    3910:	6a2b      	ldr	r3, [r5, #32]
							inseg.len = (u16_t)(next->tcphdr->seqno - seqno);
    3912:	1a12      	subs	r2, r2, r0
    3914:	83aa      	strh	r2, [r5, #28]
							if (TCPH_FLAGS(inseg.tcphdr) & TCP_SYN) {
    3916:	8998      	ldrh	r0, [r3, #12]
    3918:	47b0      	blx	r6
    391a:	0783      	lsls	r3, r0, #30
								inseg.len -= 1;
    391c:	bf48      	it	mi
    391e:	8bab      	ldrhmi	r3, [r5, #28]
							pbuf_realloc(inseg.p, inseg.len);
    3920:	69a8      	ldr	r0, [r5, #24]
								inseg.len -= 1;
    3922:	bf44      	itt	mi
    3924:	f103 33ff 	addmi.w	r3, r3, #4294967295	; 0xffffffff
    3928:	83ab      	strhmi	r3, [r5, #28]
							pbuf_realloc(inseg.p, inseg.len);
    392a:	8ba9      	ldrh	r1, [r5, #28]
    392c:	4b0c      	ldr	r3, [pc, #48]	; (3960 <tcp_receive+0x4bc>)
    392e:	4798      	blx	r3
							tcplen = TCP_TCPLEN(&inseg);
    3930:	6a2b      	ldr	r3, [r5, #32]
    3932:	f8b5 801c 	ldrh.w	r8, [r5, #28]
    3936:	8998      	ldrh	r0, [r3, #12]
    3938:	47b0      	blx	r6
    393a:	f010 0003 	ands.w	r0, r0, #3
    393e:	bf18      	it	ne
    3940:	2001      	movne	r0, #1
    3942:	4440      	add	r0, r8
    3944:	8228      	strh	r0, [r5, #16]
						pcb->ooseq = next;
    3946:	6767      	str	r7, [r4, #116]	; 0x74
    3948:	e76c      	b.n	3824 <tcp_receive+0x380>
    394a:	bf00      	nop
    394c:	0000323d 	.word	0x0000323d
    3950:	00005b39 	.word	0x00005b39
    3954:	00003029 	.word	0x00003029
    3958:	00000d6b 	.word	0x00000d6b
    395c:	00000d65 	.word	0x00000d65
    3960:	000031e9 	.word	0x000031e9
    3964:	00005ac1 	.word	0x00005ac1
    3968:	200148f4 	.word	0x200148f4
    396c:	00003257 	.word	0x00003257
							if (TCPH_FLAGS(next->tcphdr) & TCP_FIN && (TCPH_FLAGS(inseg.tcphdr) & TCP_SYN) == 0) {
    3970:	f8bc 000c 	ldrh.w	r0, [ip, #12]
    3974:	47b0      	blx	r6
    3976:	07c1      	lsls	r1, r0, #31
    3978:	d517      	bpl.n	39aa <tcp_receive+0x506>
    397a:	6a2b      	ldr	r3, [r5, #32]
    397c:	8998      	ldrh	r0, [r3, #12]
    397e:	47b0      	blx	r6
    3980:	0782      	lsls	r2, r0, #30
    3982:	d412      	bmi.n	39aa <tcp_receive+0x506>
								TCPH_SET_FLAG(inseg.tcphdr, TCP_FIN);
    3984:	6a2b      	ldr	r3, [r5, #32]
    3986:	2001      	movs	r0, #1
    3988:	f8b3 a00c 	ldrh.w	sl, [r3, #12]
    398c:	47c0      	blx	r8
    398e:	6a2b      	ldr	r3, [r5, #32]
    3990:	ea4a 0000 	orr.w	r0, sl, r0
    3994:	8198      	strh	r0, [r3, #12]
								tcplen = TCP_TCPLEN(&inseg);
    3996:	b280      	uxth	r0, r0
    3998:	f8b5 a01c 	ldrh.w	sl, [r5, #28]
    399c:	47b0      	blx	r6
    399e:	f010 0003 	ands.w	r0, r0, #3
    39a2:	bf18      	it	ne
    39a4:	2001      	movne	r0, #1
    39a6:	4450      	add	r0, sl
    39a8:	8228      	strh	r0, [r5, #16]
							next = next->next;
    39aa:	f8d7 a000 	ldr.w	sl, [r7]
							tcp_seg_free(prev);
    39ae:	4638      	mov	r0, r7
    39b0:	47c8      	blx	r9
							next = next->next;
    39b2:	4657      	mov	r7, sl
    39b4:	e79c      	b.n	38f0 <tcp_receive+0x44c>
					seqno = pcb->ooseq->tcphdr->seqno;
    39b6:	606b      	str	r3, [r5, #4]
					pcb->rcv_nxt += TCP_TCPLEN(cseg);
    39b8:	8988      	ldrh	r0, [r1, #12]
    39ba:	f8b7 8008 	ldrh.w	r8, [r7, #8]
    39be:	47b0      	blx	r6
    39c0:	f010 0003 	ands.w	r0, r0, #3
    39c4:	6aa3      	ldr	r3, [r4, #40]	; 0x28
					pcb->rcv_wnd -= TCP_TCPLEN(cseg);
    39c6:	68fa      	ldr	r2, [r7, #12]
					pcb->rcv_nxt += TCP_TCPLEN(cseg);
    39c8:	bf18      	it	ne
    39ca:	2001      	movne	r0, #1
    39cc:	4440      	add	r0, r8
    39ce:	4418      	add	r0, r3
    39d0:	62a0      	str	r0, [r4, #40]	; 0x28
					pcb->rcv_wnd -= TCP_TCPLEN(cseg);
    39d2:	8990      	ldrh	r0, [r2, #12]
    39d4:	f8b7 8008 	ldrh.w	r8, [r7, #8]
    39d8:	47b0      	blx	r6
    39da:	f010 0003 	ands.w	r0, r0, #3
    39de:	8da3      	ldrh	r3, [r4, #44]	; 0x2c
    39e0:	bf18      	it	ne
    39e2:	2001      	movne	r0, #1
    39e4:	4440      	add	r0, r8
    39e6:	1a18      	subs	r0, r3, r0
    39e8:	85a0      	strh	r0, [r4, #44]	; 0x2c
					tcp_update_rcv_ann_wnd(pcb);
    39ea:	9b01      	ldr	r3, [sp, #4]
    39ec:	4620      	mov	r0, r4
    39ee:	4798      	blx	r3
					if (cseg->p->tot_len > 0) {
    39f0:	6879      	ldr	r1, [r7, #4]
    39f2:	890b      	ldrh	r3, [r1, #8]
    39f4:	b123      	cbz	r3, 3a00 <tcp_receive+0x55c>
						if (recv_data) {
    39f6:	6a68      	ldr	r0, [r5, #36]	; 0x24
    39f8:	b328      	cbz	r0, 3a46 <tcp_receive+0x5a2>
							pbuf_cat(recv_data, cseg->p);
    39fa:	47d0      	blx	sl
						cseg->p = NULL;
    39fc:	f8c7 9004 	str.w	r9, [r7, #4]
					if (TCPH_FLAGS(cseg->tcphdr) & TCP_FIN) {
    3a00:	68fb      	ldr	r3, [r7, #12]
    3a02:	8998      	ldrh	r0, [r3, #12]
    3a04:	47b0      	blx	r6
    3a06:	07c0      	lsls	r0, r0, #31
    3a08:	d50a      	bpl.n	3a20 <tcp_receive+0x57c>
						recv_flags |= TF_GOT_FIN;
    3a0a:	f895 3028 	ldrb.w	r3, [r5, #40]	; 0x28
    3a0e:	f043 0320 	orr.w	r3, r3, #32
    3a12:	f885 3028 	strb.w	r3, [r5, #40]	; 0x28
						if (pcb->state == ESTABLISHED) { /* force passive close or we can move to active close */
    3a16:	7e23      	ldrb	r3, [r4, #24]
    3a18:	2b04      	cmp	r3, #4
							pcb->state = CLOSE_WAIT;
    3a1a:	bf04      	itt	eq
    3a1c:	2307      	moveq	r3, #7
    3a1e:	7623      	strbeq	r3, [r4, #24]
					pcb->ooseq = cseg->next;
    3a20:	683b      	ldr	r3, [r7, #0]
    3a22:	6763      	str	r3, [r4, #116]	; 0x74
					tcp_seg_free(cseg);
    3a24:	4638      	mov	r0, r7
    3a26:	47d8      	blx	fp
				while (pcb->ooseq != NULL && pcb->ooseq->tcphdr->seqno == pcb->rcv_nxt) {
    3a28:	6f67      	ldr	r7, [r4, #116]	; 0x74
    3a2a:	b127      	cbz	r7, 3a36 <tcp_receive+0x592>
    3a2c:	68f9      	ldr	r1, [r7, #12]
    3a2e:	6aa2      	ldr	r2, [r4, #40]	; 0x28
    3a30:	684b      	ldr	r3, [r1, #4]
    3a32:	4293      	cmp	r3, r2
    3a34:	d0bf      	beq.n	39b6 <tcp_receive+0x512>
				tcp_ack(pcb);
    3a36:	7fa3      	ldrb	r3, [r4, #30]
    3a38:	07d9      	lsls	r1, r3, #31
    3a3a:	d506      	bpl.n	3a4a <tcp_receive+0x5a6>
    3a3c:	f023 0301 	bic.w	r3, r3, #1
			tcp_ack_now(pcb);
    3a40:	f043 0302 	orr.w	r3, r3, #2
    3a44:	e003      	b.n	3a4e <tcp_receive+0x5aa>
							recv_data = cseg->p;
    3a46:	6269      	str	r1, [r5, #36]	; 0x24
    3a48:	e7d8      	b.n	39fc <tcp_receive+0x558>
				tcp_ack(pcb);
    3a4a:	f043 0301 	orr.w	r3, r3, #1
    3a4e:	77a3      	strb	r3, [r4, #30]
}
    3a50:	b003      	add	sp, #12
    3a52:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
				tcp_send_empty_ack(pcb);
    3a56:	4b60      	ldr	r3, [pc, #384]	; (3bd8 <tcp_receive+0x734>)
    3a58:	4620      	mov	r0, r4
    3a5a:	4798      	blx	r3
				if (pcb->ooseq == NULL) {
    3a5c:	6f66      	ldr	r6, [r4, #116]	; 0x74
    3a5e:	b926      	cbnz	r6, 3a6a <tcp_receive+0x5c6>
					pcb->ooseq = tcp_seg_copy(&inseg);
    3a60:	485e      	ldr	r0, [pc, #376]	; (3bdc <tcp_receive+0x738>)
    3a62:	4b5f      	ldr	r3, [pc, #380]	; (3be0 <tcp_receive+0x73c>)
    3a64:	4798      	blx	r3
    3a66:	6760      	str	r0, [r4, #116]	; 0x74
    3a68:	e7f2      	b.n	3a50 <tcp_receive+0x5ac>
						if (seqno == next->tcphdr->seqno) {
    3a6a:	686b      	ldr	r3, [r5, #4]
					prev = NULL;
    3a6c:	2700      	movs	r7, #0
    3a6e:	f103 3cff 	add.w	ip, r3, #4294967295	; 0xffffffff
    3a72:	f103 0e01 	add.w	lr, r3, #1
						if (seqno == next->tcphdr->seqno) {
    3a76:	68f0      	ldr	r0, [r6, #12]
    3a78:	6841      	ldr	r1, [r0, #4]
    3a7a:	4299      	cmp	r1, r3
    3a7c:	d114      	bne.n	3aa8 <tcp_receive+0x604>
							if (inseg.len > next->len) {
    3a7e:	8baa      	ldrh	r2, [r5, #28]
    3a80:	8933      	ldrh	r3, [r6, #8]
    3a82:	429a      	cmp	r2, r3
    3a84:	d9e4      	bls.n	3a50 <tcp_receive+0x5ac>
								cseg = tcp_seg_copy(&inseg);
    3a86:	4855      	ldr	r0, [pc, #340]	; (3bdc <tcp_receive+0x738>)
    3a88:	4b55      	ldr	r3, [pc, #340]	; (3be0 <tcp_receive+0x73c>)
    3a8a:	4798      	blx	r3
								if (cseg != NULL) {
    3a8c:	2800      	cmp	r0, #0
    3a8e:	d0df      	beq.n	3a50 <tcp_receive+0x5ac>
									if (prev != NULL) {
    3a90:	b147      	cbz	r7, 3aa4 <tcp_receive+0x600>
										prev->next = cseg;
    3a92:	6038      	str	r0, [r7, #0]
										tcp_oos_insert_segment(cseg, next);
    3a94:	4631      	mov	r1, r6
    3a96:	4b53      	ldr	r3, [pc, #332]	; (3be4 <tcp_receive+0x740>)
}
    3a98:	b003      	add	sp, #12
    3a9a:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
										tcp_oos_insert_segment(cseg, next);
    3a9e:	4718      	bx	r3
    3aa0:	4616      	mov	r6, r2
    3aa2:	e7e8      	b.n	3a76 <tcp_receive+0x5d2>
										pcb->ooseq = cseg;
    3aa4:	6760      	str	r0, [r4, #116]	; 0x74
									tcp_oos_insert_segment(cseg, next);
    3aa6:	e7f5      	b.n	3a94 <tcp_receive+0x5f0>
							if (prev == NULL) {
    3aa8:	b94f      	cbnz	r7, 3abe <tcp_receive+0x61a>
								if (TCP_SEQ_LT(seqno, next->tcphdr->seqno)) {
    3aaa:	1a5a      	subs	r2, r3, r1
    3aac:	2a00      	cmp	r2, #0
    3aae:	da28      	bge.n	3b02 <tcp_receive+0x65e>
									cseg = tcp_seg_copy(&inseg);
    3ab0:	484a      	ldr	r0, [pc, #296]	; (3bdc <tcp_receive+0x738>)
    3ab2:	4b4b      	ldr	r3, [pc, #300]	; (3be0 <tcp_receive+0x73c>)
    3ab4:	4798      	blx	r3
									if (cseg != NULL) {
    3ab6:	2800      	cmp	r0, #0
    3ab8:	d0ca      	beq.n	3a50 <tcp_receive+0x5ac>
										pcb->ooseq = cseg;
    3aba:	6760      	str	r0, [r4, #116]	; 0x74
    3abc:	e7ea      	b.n	3a94 <tcp_receive+0x5f0>
								if (TCP_SEQ_BETWEEN(seqno, prev->tcphdr->seqno + 1, next->tcphdr->seqno - 1)) {
    3abe:	68fa      	ldr	r2, [r7, #12]
    3ac0:	6852      	ldr	r2, [r2, #4]
    3ac2:	ebac 0202 	sub.w	r2, ip, r2
    3ac6:	2a00      	cmp	r2, #0
    3ac8:	db1b      	blt.n	3b02 <tcp_receive+0x65e>
    3aca:	ebae 0201 	sub.w	r2, lr, r1
    3ace:	2a00      	cmp	r2, #0
    3ad0:	dc17      	bgt.n	3b02 <tcp_receive+0x65e>
									cseg = tcp_seg_copy(&inseg);
    3ad2:	4842      	ldr	r0, [pc, #264]	; (3bdc <tcp_receive+0x738>)
    3ad4:	4b42      	ldr	r3, [pc, #264]	; (3be0 <tcp_receive+0x73c>)
    3ad6:	4798      	blx	r3
									if (cseg != NULL) {
    3ad8:	4604      	mov	r4, r0
    3ada:	2800      	cmp	r0, #0
    3adc:	d0b8      	beq.n	3a50 <tcp_receive+0x5ac>
										if (TCP_SEQ_GT(prev->tcphdr->seqno + prev->len, seqno)) {
    3ade:	68fb      	ldr	r3, [r7, #12]
    3ae0:	6869      	ldr	r1, [r5, #4]
    3ae2:	685a      	ldr	r2, [r3, #4]
    3ae4:	893b      	ldrh	r3, [r7, #8]
    3ae6:	4413      	add	r3, r2
    3ae8:	1a5b      	subs	r3, r3, r1
    3aea:	2b00      	cmp	r3, #0
    3aec:	dd05      	ble.n	3afa <tcp_receive+0x656>
											prev->len = (u16_t)(seqno - prev->tcphdr->seqno);
    3aee:	1a89      	subs	r1, r1, r2
    3af0:	b289      	uxth	r1, r1
											pbuf_realloc(prev->p, prev->len);
    3af2:	6878      	ldr	r0, [r7, #4]
    3af4:	4b3c      	ldr	r3, [pc, #240]	; (3be8 <tcp_receive+0x744>)
											prev->len = (u16_t)(seqno - prev->tcphdr->seqno);
    3af6:	8139      	strh	r1, [r7, #8]
											pbuf_realloc(prev->p, prev->len);
    3af8:	4798      	blx	r3
										prev->next = cseg;
    3afa:	603c      	str	r4, [r7, #0]
										tcp_oos_insert_segment(cseg, next);
    3afc:	4631      	mov	r1, r6
    3afe:	4620      	mov	r0, r4
    3b00:	e7c9      	b.n	3a96 <tcp_receive+0x5f2>
							if (next->next == NULL && TCP_SEQ_GT(seqno, next->tcphdr->seqno)) {
    3b02:	6832      	ldr	r2, [r6, #0]
    3b04:	4637      	mov	r7, r6
    3b06:	2a00      	cmp	r2, #0
    3b08:	d1ca      	bne.n	3aa0 <tcp_receive+0x5fc>
    3b0a:	1a5b      	subs	r3, r3, r1
    3b0c:	2b00      	cmp	r3, #0
    3b0e:	dd9f      	ble.n	3a50 <tcp_receive+0x5ac>
								if (TCPH_FLAGS(next->tcphdr) & TCP_FIN) {
    3b10:	8980      	ldrh	r0, [r0, #12]
    3b12:	4f36      	ldr	r7, [pc, #216]	; (3bec <tcp_receive+0x748>)
    3b14:	47b8      	blx	r7
    3b16:	07c2      	lsls	r2, r0, #31
    3b18:	d49a      	bmi.n	3a50 <tcp_receive+0x5ac>
								next->next = tcp_seg_copy(&inseg);
    3b1a:	4830      	ldr	r0, [pc, #192]	; (3bdc <tcp_receive+0x738>)
    3b1c:	4b30      	ldr	r3, [pc, #192]	; (3be0 <tcp_receive+0x73c>)
    3b1e:	4798      	blx	r3
    3b20:	6030      	str	r0, [r6, #0]
								if (next->next != NULL) {
    3b22:	2800      	cmp	r0, #0
    3b24:	d094      	beq.n	3a50 <tcp_receive+0x5ac>
									if (TCP_SEQ_GT(next->tcphdr->seqno + next->len, seqno)) {
    3b26:	68f3      	ldr	r3, [r6, #12]
    3b28:	6869      	ldr	r1, [r5, #4]
    3b2a:	685a      	ldr	r2, [r3, #4]
    3b2c:	8933      	ldrh	r3, [r6, #8]
    3b2e:	4413      	add	r3, r2
    3b30:	1a5b      	subs	r3, r3, r1
    3b32:	2b00      	cmp	r3, #0
    3b34:	dd05      	ble.n	3b42 <tcp_receive+0x69e>
										next->len = (u16_t)(seqno - next->tcphdr->seqno);
    3b36:	1a89      	subs	r1, r1, r2
    3b38:	b289      	uxth	r1, r1
										pbuf_realloc(next->p, next->len);
    3b3a:	6870      	ldr	r0, [r6, #4]
    3b3c:	4b2a      	ldr	r3, [pc, #168]	; (3be8 <tcp_receive+0x744>)
										next->len = (u16_t)(seqno - next->tcphdr->seqno);
    3b3e:	8131      	strh	r1, [r6, #8]
										pbuf_realloc(next->p, next->len);
    3b40:	4798      	blx	r3
									if ((u32_t)tcplen + seqno > pcb->rcv_nxt + (u32_t)pcb->rcv_wnd) {
    3b42:	686b      	ldr	r3, [r5, #4]
    3b44:	8a2a      	ldrh	r2, [r5, #16]
    3b46:	6aa1      	ldr	r1, [r4, #40]	; 0x28
    3b48:	441a      	add	r2, r3
    3b4a:	8da3      	ldrh	r3, [r4, #44]	; 0x2c
    3b4c:	440b      	add	r3, r1
    3b4e:	429a      	cmp	r2, r3
    3b50:	f67f af7e 	bls.w	3a50 <tcp_receive+0x5ac>
										if (TCPH_FLAGS(next->next->tcphdr) & TCP_FIN) {
    3b54:	6833      	ldr	r3, [r6, #0]
    3b56:	68db      	ldr	r3, [r3, #12]
    3b58:	8998      	ldrh	r0, [r3, #12]
    3b5a:	47b8      	blx	r7
    3b5c:	07c3      	lsls	r3, r0, #31
    3b5e:	d511      	bpl.n	3b84 <tcp_receive+0x6e0>
											TCPH_FLAGS_SET(next->next->tcphdr,
    3b60:	6833      	ldr	r3, [r6, #0]
    3b62:	68db      	ldr	r3, [r3, #12]
    3b64:	f8b3 800c 	ldrh.w	r8, [r3, #12]
    3b68:	4640      	mov	r0, r8
    3b6a:	47b8      	blx	r7
    3b6c:	4b20      	ldr	r3, [pc, #128]	; (3bf0 <tcp_receive+0x74c>)
    3b6e:	f000 003e 	and.w	r0, r0, #62	; 0x3e
    3b72:	4798      	blx	r3
    3b74:	6833      	ldr	r3, [r6, #0]
    3b76:	f428 587c 	bic.w	r8, r8, #16128	; 0x3f00
    3b7a:	68db      	ldr	r3, [r3, #12]
    3b7c:	ea48 0800 	orr.w	r8, r8, r0
    3b80:	f8a3 800c 	strh.w	r8, [r3, #12]
										next->next->len = pcb->rcv_nxt + pcb->rcv_wnd - seqno;
    3b84:	8da1      	ldrh	r1, [r4, #44]	; 0x2c
    3b86:	686a      	ldr	r2, [r5, #4]
    3b88:	6833      	ldr	r3, [r6, #0]
    3b8a:	1a89      	subs	r1, r1, r2
    3b8c:	6aa2      	ldr	r2, [r4, #40]	; 0x28
										pbuf_realloc(next->next->p, next->next->len);
    3b8e:	6858      	ldr	r0, [r3, #4]
										next->next->len = pcb->rcv_nxt + pcb->rcv_wnd - seqno;
    3b90:	4411      	add	r1, r2
    3b92:	b289      	uxth	r1, r1
    3b94:	8119      	strh	r1, [r3, #8]
										pbuf_realloc(next->next->p, next->next->len);
    3b96:	4b14      	ldr	r3, [pc, #80]	; (3be8 <tcp_receive+0x744>)
    3b98:	4798      	blx	r3
										tcplen = TCP_TCPLEN(next->next);
    3b9a:	6833      	ldr	r3, [r6, #0]
    3b9c:	891c      	ldrh	r4, [r3, #8]
    3b9e:	68db      	ldr	r3, [r3, #12]
    3ba0:	8998      	ldrh	r0, [r3, #12]
    3ba2:	47b8      	blx	r7
    3ba4:	f010 0003 	ands.w	r0, r0, #3
    3ba8:	bf18      	it	ne
    3baa:	2001      	movne	r0, #1
    3bac:	4420      	add	r0, r4
    3bae:	8228      	strh	r0, [r5, #16]
    3bb0:	e74e      	b.n	3a50 <tcp_receive+0x5ac>
			tcp_send_empty_ack(pcb);
    3bb2:	4b09      	ldr	r3, [pc, #36]	; (3bd8 <tcp_receive+0x734>)
    3bb4:	4620      	mov	r0, r4
}
    3bb6:	b003      	add	sp, #12
    3bb8:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
			tcp_send_empty_ack(pcb);
    3bbc:	4718      	bx	r3
		if (!TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, pcb->rcv_nxt + pcb->rcv_wnd - 1)) {
    3bbe:	1a99      	subs	r1, r3, r2
    3bc0:	2900      	cmp	r1, #0
    3bc2:	db06      	blt.n	3bd2 <tcp_receive+0x72e>
    3bc4:	3301      	adds	r3, #1
    3bc6:	1a9b      	subs	r3, r3, r2
    3bc8:	8da2      	ldrh	r2, [r4, #44]	; 0x2c
    3bca:	1a9b      	subs	r3, r3, r2
    3bcc:	2b00      	cmp	r3, #0
    3bce:	f77f af3f 	ble.w	3a50 <tcp_receive+0x5ac>
			tcp_ack_now(pcb);
    3bd2:	7fa3      	ldrb	r3, [r4, #30]
    3bd4:	e734      	b.n	3a40 <tcp_receive+0x59c>
    3bd6:	bf00      	nop
    3bd8:	000023d1 	.word	0x000023d1
    3bdc:	2000a4f4 	.word	0x2000a4f4
    3be0:	00005b71 	.word	0x00005b71
    3be4:	00003405 	.word	0x00003405
    3be8:	000031e9 	.word	0x000031e9
    3bec:	00000d6b 	.word	0x00000d6b
    3bf0:	00000d65 	.word	0x00000d65

00003bf4 <tcp_input>:
{
    3bf4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	iphdr  = (struct ip_hdr *)p->payload;
    3bf8:	6843      	ldr	r3, [r0, #4]
	tcphdr = (struct tcp_hdr *)((u8_t *)p->payload + IPH_HL(iphdr) * 4);
    3bfa:	4d97      	ldr	r5, [pc, #604]	; (3e58 <tcp_input+0x264>)
    3bfc:	781a      	ldrb	r2, [r3, #0]
	if (pbuf_header(p, -((s16_t)(IPH_HL(iphdr) * 4))) || (p->tot_len < sizeof(struct tcp_hdr))) {
    3bfe:	f8df 928c 	ldr.w	r9, [pc, #652]	; 3e8c <tcp_input+0x298>
{
    3c02:	460c      	mov	r4, r1
    3c04:	f002 010f 	and.w	r1, r2, #15
	tcphdr = (struct tcp_hdr *)((u8_t *)p->payload + IPH_HL(iphdr) * 4);
    3c08:	eb03 0381 	add.w	r3, r3, r1, lsl #2
	if (pbuf_header(p, -((s16_t)(IPH_HL(iphdr) * 4))) || (p->tot_len < sizeof(struct tcp_hdr))) {
    3c0c:	0089      	lsls	r1, r1, #2
{
    3c0e:	b085      	sub	sp, #20
	if (pbuf_header(p, -((s16_t)(IPH_HL(iphdr) * 4))) || (p->tot_len < sizeof(struct tcp_hdr))) {
    3c10:	4249      	negs	r1, r1
{
    3c12:	4606      	mov	r6, r0
	tcphdr = (struct tcp_hdr *)((u8_t *)p->payload + IPH_HL(iphdr) * 4);
    3c14:	602b      	str	r3, [r5, #0]
	if (pbuf_header(p, -((s16_t)(IPH_HL(iphdr) * 4))) || (p->tot_len < sizeof(struct tcp_hdr))) {
    3c16:	47c8      	blx	r9
    3c18:	2800      	cmp	r0, #0
    3c1a:	f040 80ec 	bne.w	3df6 <tcp_input+0x202>
    3c1e:	8933      	ldrh	r3, [r6, #8]
    3c20:	2b13      	cmp	r3, #19
    3c22:	f240 80e8 	bls.w	3df6 <tcp_input+0x202>
	if (ip_addr_isbroadcast(&current_iphdr_dest, inp) || ip_addr_ismulticast(&current_iphdr_dest)) {
    3c26:	4f8d      	ldr	r7, [pc, #564]	; (3e5c <tcp_input+0x268>)
    3c28:	4b8d      	ldr	r3, [pc, #564]	; (3e60 <tcp_input+0x26c>)
    3c2a:	6838      	ldr	r0, [r7, #0]
    3c2c:	4621      	mov	r1, r4
    3c2e:	4798      	blx	r3
    3c30:	2800      	cmp	r0, #0
    3c32:	f040 80e0 	bne.w	3df6 <tcp_input+0x202>
    3c36:	683b      	ldr	r3, [r7, #0]
    3c38:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
    3c3c:	2be0      	cmp	r3, #224	; 0xe0
    3c3e:	f000 80da 	beq.w	3df6 <tcp_input+0x202>
	if (inet_chksum_pseudo(p, ip_current_src_addr(), ip_current_dest_addr(), IP_PROTO_TCP, p->tot_len) != 0) {
    3c42:	f8df 8230 	ldr.w	r8, [pc, #560]	; 3e74 <tcp_input+0x280>
    3c46:	8933      	ldrh	r3, [r6, #8]
    3c48:	9300      	str	r3, [sp, #0]
    3c4a:	4c86      	ldr	r4, [pc, #536]	; (3e64 <tcp_input+0x270>)
    3c4c:	2306      	movs	r3, #6
    3c4e:	463a      	mov	r2, r7
    3c50:	4641      	mov	r1, r8
    3c52:	4630      	mov	r0, r6
    3c54:	47a0      	blx	r4
    3c56:	2800      	cmp	r0, #0
    3c58:	f040 80cd 	bne.w	3df6 <tcp_input+0x202>
	hdrlen = TCPH_HDRLEN(tcphdr);
    3c5c:	682b      	ldr	r3, [r5, #0]
    3c5e:	4c82      	ldr	r4, [pc, #520]	; (3e68 <tcp_input+0x274>)
    3c60:	8998      	ldrh	r0, [r3, #12]
    3c62:	47a0      	blx	r4
    3c64:	0b00      	lsrs	r0, r0, #12
	if (pbuf_header(p, -(hdrlen * 4))) {
    3c66:	ebc0 3080 	rsb	r0, r0, r0, lsl #14
    3c6a:	0081      	lsls	r1, r0, #2
    3c6c:	b209      	sxth	r1, r1
    3c6e:	4630      	mov	r0, r6
    3c70:	47c8      	blx	r9
    3c72:	4682      	mov	sl, r0
    3c74:	2800      	cmp	r0, #0
    3c76:	f040 80be 	bne.w	3df6 <tcp_input+0x202>
	tcphdr->src  = ntohs(tcphdr->src);
    3c7a:	f8d5 9000 	ldr.w	r9, [r5]
	seqno = tcphdr->seqno = ntohl(tcphdr->seqno);
    3c7e:	f8df b210 	ldr.w	fp, [pc, #528]	; 3e90 <tcp_input+0x29c>
	tcphdr->src  = ntohs(tcphdr->src);
    3c82:	f8b9 0000 	ldrh.w	r0, [r9]
    3c86:	47a0      	blx	r4
    3c88:	f8a9 0000 	strh.w	r0, [r9]
	tcphdr->dest = ntohs(tcphdr->dest);
    3c8c:	f8d5 9000 	ldr.w	r9, [r5]
    3c90:	f8b9 0002 	ldrh.w	r0, [r9, #2]
    3c94:	47a0      	blx	r4
    3c96:	f8a9 0002 	strh.w	r0, [r9, #2]
	seqno = tcphdr->seqno = ntohl(tcphdr->seqno);
    3c9a:	f8d5 9000 	ldr.w	r9, [r5]
    3c9e:	f8d9 0004 	ldr.w	r0, [r9, #4]
    3ca2:	47d8      	blx	fp
    3ca4:	f8c9 0004 	str.w	r0, [r9, #4]
	ackno = tcphdr->ackno = ntohl(tcphdr->ackno);
    3ca8:	f8d5 9000 	ldr.w	r9, [r5]
	seqno = tcphdr->seqno = ntohl(tcphdr->seqno);
    3cac:	6068      	str	r0, [r5, #4]
	ackno = tcphdr->ackno = ntohl(tcphdr->ackno);
    3cae:	f8d9 0008 	ldr.w	r0, [r9, #8]
    3cb2:	47d8      	blx	fp
    3cb4:	f8c9 0008 	str.w	r0, [r9, #8]
	tcphdr->wnd           = ntohs(tcphdr->wnd);
    3cb8:	f8d5 9000 	ldr.w	r9, [r5]
	ackno = tcphdr->ackno = ntohl(tcphdr->ackno);
    3cbc:	60e8      	str	r0, [r5, #12]
	tcphdr->wnd           = ntohs(tcphdr->wnd);
    3cbe:	f8b9 000e 	ldrh.w	r0, [r9, #14]
    3cc2:	47a0      	blx	r4
	flags  = TCPH_FLAGS(tcphdr);
    3cc4:	682b      	ldr	r3, [r5, #0]
	tcphdr->wnd           = ntohs(tcphdr->wnd);
    3cc6:	f8a9 000e 	strh.w	r0, [r9, #14]
	flags  = TCPH_FLAGS(tcphdr);
    3cca:	8998      	ldrh	r0, [r3, #12]
	for (pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
    3ccc:	f8df 91a0 	ldr.w	r9, [pc, #416]	; 3e70 <tcp_input+0x27c>
	flags  = TCPH_FLAGS(tcphdr);
    3cd0:	47a0      	blx	r4
    3cd2:	f000 023f 	and.w	r2, r0, #63	; 0x3f
    3cd6:	b2c3      	uxtb	r3, r0
    3cd8:	722a      	strb	r2, [r5, #8]
	tcplen = p->tot_len + ((flags & (TCP_FIN | TCP_SYN)) ? 1 : 0);
    3cda:	f010 0003 	ands.w	r0, r0, #3
    3cde:	8932      	ldrh	r2, [r6, #8]
    3ce0:	9203      	str	r2, [sp, #12]
    3ce2:	bf18      	it	ne
    3ce4:	2001      	movne	r0, #1
    3ce6:	4410      	add	r0, r2
    3ce8:	b282      	uxth	r2, r0
    3cea:	9202      	str	r2, [sp, #8]
	for (pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
    3cec:	f8d9 0000 	ldr.w	r0, [r9]
	tcplen = p->tot_len + ((flags & (TCP_FIN | TCP_SYN)) ? 1 : 0);
    3cf0:	822a      	strh	r2, [r5, #16]
		    && ip_addr_cmp(&(pcb->remote_ip), &current_iphdr_src)
    3cf2:	f8d8 2000 	ldr.w	r2, [r8]
		if (pcb->remote_port == tcphdr->src && pcb->local_port == tcphdr->dest
    3cf6:	f8d5 c000 	ldr.w	ip, [r5]
		    && ip_addr_cmp(&(pcb->local_ip), &current_iphdr_dest)) {
    3cfa:	f8d7 e000 	ldr.w	lr, [r7]
		    && ip_addr_cmp(&(pcb->remote_ip), &current_iphdr_src)
    3cfe:	4611      	mov	r1, r2
	for (pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
    3d00:	4604      	mov	r4, r0
    3d02:	b914      	cbnz	r4, 3d0a <tcp_input+0x116>
		for (pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
    3d04:	4a59      	ldr	r2, [pc, #356]	; (3e6c <tcp_input+0x278>)
    3d06:	6810      	ldr	r0, [r2, #0]
    3d08:	e07c      	b.n	3e04 <tcp_input+0x210>
		if (pcb->remote_port == tcphdr->src && pcb->local_port == tcphdr->dest
    3d0a:	f8b4 b01c 	ldrh.w	fp, [r4, #28]
    3d0e:	f8bc 2000 	ldrh.w	r2, [ip]
    3d12:	4593      	cmp	fp, r2
    3d14:	d138      	bne.n	3d88 <tcp_input+0x194>
    3d16:	f8b4 b01a 	ldrh.w	fp, [r4, #26]
    3d1a:	f8bc 2002 	ldrh.w	r2, [ip, #2]
    3d1e:	4593      	cmp	fp, r2
    3d20:	d132      	bne.n	3d88 <tcp_input+0x194>
		    && ip_addr_cmp(&(pcb->remote_ip), &current_iphdr_src)
    3d22:	6862      	ldr	r2, [r4, #4]
    3d24:	428a      	cmp	r2, r1
    3d26:	d12f      	bne.n	3d88 <tcp_input+0x194>
		    && ip_addr_cmp(&(pcb->local_ip), &current_iphdr_dest)) {
    3d28:	6822      	ldr	r2, [r4, #0]
    3d2a:	4572      	cmp	r2, lr
    3d2c:	d12c      	bne.n	3d88 <tcp_input+0x194>
			if (prev != NULL) {
    3d2e:	f1ba 0f00 	cmp.w	sl, #0
    3d32:	d005      	beq.n	3d40 <tcp_input+0x14c>
				prev->next      = pcb->next;
    3d34:	68e2      	ldr	r2, [r4, #12]
    3d36:	f8ca 200c 	str.w	r2, [sl, #12]
				tcp_active_pcbs = pcb;
    3d3a:	4a4d      	ldr	r2, [pc, #308]	; (3e70 <tcp_input+0x27c>)
				pcb->next       = tcp_active_pcbs;
    3d3c:	60e0      	str	r0, [r4, #12]
				tcp_active_pcbs = pcb;
    3d3e:	6014      	str	r4, [r2, #0]
		inseg.next   = NULL;
    3d40:	2200      	movs	r2, #0
		inseg.len    = p->tot_len;
    3d42:	9903      	ldr	r1, [sp, #12]
		inseg.next   = NULL;
    3d44:	616a      	str	r2, [r5, #20]
		if (flags & TCP_PSH) {
    3d46:	071b      	lsls	r3, r3, #28
		recv_data  = NULL;
    3d48:	e9c5 c208 	strd	ip, r2, [r5, #32]
		inseg.len    = p->tot_len;
    3d4c:	83a9      	strh	r1, [r5, #28]
		inseg.p      = p;
    3d4e:	61ae      	str	r6, [r5, #24]
		recv_flags = 0;
    3d50:	f885 2028 	strb.w	r2, [r5, #40]	; 0x28
		if (flags & TCP_PSH) {
    3d54:	d503      	bpl.n	3d5e <tcp_input+0x16a>
			p->flags |= PBUF_FLAG_PUSH;
    3d56:	7b73      	ldrb	r3, [r6, #13]
    3d58:	f043 0301 	orr.w	r3, r3, #1
    3d5c:	7373      	strb	r3, [r6, #13]
		if (pcb->refused_data != NULL) {
    3d5e:	6fa3      	ldr	r3, [r4, #120]	; 0x78
    3d60:	2b00      	cmp	r3, #0
    3d62:	f040 80e9 	bne.w	3f38 <tcp_input+0x344>
	if (flags & TCP_RST) {
    3d66:	7a2a      	ldrb	r2, [r5, #8]
		tcp_input_pcb = pcb;
    3d68:	62ec      	str	r4, [r5, #44]	; 0x2c
	if (flags & TCP_RST) {
    3d6a:	0757      	lsls	r7, r2, #29
    3d6c:	f100 80fc 	bmi.w	3f68 <tcp_input+0x374>
	if ((flags & TCP_SYN) && (pcb->state != SYN_SENT && pcb->state != SYN_RCVD)) {
    3d70:	0796      	lsls	r6, r2, #30
			pcb->flags &= ~TF_ACK_DELAY;
    3d72:	7fa3      	ldrb	r3, [r4, #30]
	if ((flags & TCP_SYN) && (pcb->state != SYN_SENT && pcb->state != SYN_RCVD)) {
    3d74:	f140 8127 	bpl.w	3fc6 <tcp_input+0x3d2>
    3d78:	7e22      	ldrb	r2, [r4, #24]
    3d7a:	3a02      	subs	r2, #2
    3d7c:	2a01      	cmp	r2, #1
    3d7e:	f240 8122 	bls.w	3fc6 <tcp_input+0x3d2>
			tcp_ack_now(pcb);
    3d82:	f043 0302 	orr.w	r3, r3, #2
    3d86:	e0ff      	b.n	3f88 <tcp_input+0x394>
	for (pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
    3d88:	46a2      	mov	sl, r4
    3d8a:	68e4      	ldr	r4, [r4, #12]
    3d8c:	e7b9      	b.n	3d02 <tcp_input+0x10e>
			if (pcb->remote_port == tcphdr->src && pcb->local_port == tcphdr->dest
    3d8e:	f8bc 2000 	ldrh.w	r2, [ip]
    3d92:	f8b0 a01c 	ldrh.w	sl, [r0, #28]
    3d96:	4592      	cmp	sl, r2
    3d98:	d133      	bne.n	3e02 <tcp_input+0x20e>
    3d9a:	f8bc 2002 	ldrh.w	r2, [ip, #2]
    3d9e:	8b44      	ldrh	r4, [r0, #26]
    3da0:	4294      	cmp	r4, r2
    3da2:	d12e      	bne.n	3e02 <tcp_input+0x20e>
			    && ip_addr_cmp(&(pcb->remote_ip), &current_iphdr_src)
    3da4:	6842      	ldr	r2, [r0, #4]
    3da6:	4291      	cmp	r1, r2
    3da8:	d12b      	bne.n	3e02 <tcp_input+0x20e>
			    && ip_addr_cmp(&(pcb->local_ip), &current_iphdr_dest)) {
    3daa:	6802      	ldr	r2, [r0, #0]
    3dac:	4596      	cmp	lr, r2
    3dae:	d128      	bne.n	3e02 <tcp_input+0x20e>
	if (flags & TCP_RST) {
    3db0:	075a      	lsls	r2, r3, #29
    3db2:	d420      	bmi.n	3df6 <tcp_input+0x202>
	if (flags & TCP_SYN) {
    3db4:	079f      	lsls	r7, r3, #30
    3db6:	d511      	bpl.n	3ddc <tcp_input+0x1e8>
		if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, pcb->rcv_nxt + pcb->rcv_wnd)) {
    3db8:	686f      	ldr	r7, [r5, #4]
    3dba:	6a83      	ldr	r3, [r0, #40]	; 0x28
    3dbc:	1afb      	subs	r3, r7, r3
    3dbe:	d412      	bmi.n	3de6 <tcp_input+0x1f2>
    3dc0:	8d82      	ldrh	r2, [r0, #44]	; 0x2c
    3dc2:	1a9b      	subs	r3, r3, r2
    3dc4:	2b00      	cmp	r3, #0
    3dc6:	dc0e      	bgt.n	3de6 <tcp_input+0x1f2>
			tcp_rst(ackno, seqno + tcplen, ip_current_dest_addr(), ip_current_src_addr(), tcphdr->dest, tcphdr->src);
    3dc8:	9902      	ldr	r1, [sp, #8]
    3dca:	4b2a      	ldr	r3, [pc, #168]	; (3e74 <tcp_input+0x280>)
    3dcc:	4a23      	ldr	r2, [pc, #140]	; (3e5c <tcp_input+0x268>)
    3dce:	e9cd 4a00 	strd	r4, sl, [sp]
    3dd2:	4439      	add	r1, r7
			tcp_rst(ackno, seqno + tcplen, ip_current_dest_addr(), ip_current_src_addr(), tcphdr->dest, tcphdr->src);
    3dd4:	68e8      	ldr	r0, [r5, #12]
    3dd6:	4c28      	ldr	r4, [pc, #160]	; (3e78 <tcp_input+0x284>)
    3dd8:	47a0      	blx	r4
    3dda:	e00c      	b.n	3df6 <tcp_input+0x202>
	} else if (flags & TCP_FIN) {
    3ddc:	07d9      	lsls	r1, r3, #31
		pcb->tmr = tcp_ticks;
    3dde:	bf42      	ittt	mi
    3de0:	4b26      	ldrmi	r3, [pc, #152]	; (3e7c <tcp_input+0x288>)
    3de2:	681b      	ldrmi	r3, [r3, #0]
    3de4:	6243      	strmi	r3, [r0, #36]	; 0x24
	if ((tcplen > 0)) {
    3de6:	9b02      	ldr	r3, [sp, #8]
    3de8:	b12b      	cbz	r3, 3df6 <tcp_input+0x202>
		pcb->flags |= TF_ACK_NOW;
    3dea:	7f83      	ldrb	r3, [r0, #30]
    3dec:	f043 0302 	orr.w	r3, r3, #2
    3df0:	7783      	strb	r3, [r0, #30]
		return tcp_output(pcb);
    3df2:	4b23      	ldr	r3, [pc, #140]	; (3e80 <tcp_input+0x28c>)
    3df4:	4798      	blx	r3
	pbuf_free(p);
    3df6:	4b23      	ldr	r3, [pc, #140]	; (3e84 <tcp_input+0x290>)
    3df8:	4630      	mov	r0, r6
}
    3dfa:	b005      	add	sp, #20
    3dfc:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	pbuf_free(p);
    3e00:	4718      	bx	r3
		for (pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
    3e02:	68c0      	ldr	r0, [r0, #12]
    3e04:	2800      	cmp	r0, #0
    3e06:	d1c2      	bne.n	3d8e <tcp_input+0x19a>
		for (lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
    3e08:	4a1f      	ldr	r2, [pc, #124]	; (3e88 <tcp_input+0x294>)
    3e0a:	6814      	ldr	r4, [r2, #0]
    3e0c:	46a2      	mov	sl, r4
    3e0e:	f1ba 0f00 	cmp.w	sl, #0
    3e12:	d10f      	bne.n	3e34 <tcp_input+0x240>
		if (!(TCPH_FLAGS(tcphdr) & TCP_RST)) {
    3e14:	f8bc 000c 	ldrh.w	r0, [ip, #12]
    3e18:	4b13      	ldr	r3, [pc, #76]	; (3e68 <tcp_input+0x274>)
    3e1a:	4798      	blx	r3
    3e1c:	0742      	lsls	r2, r0, #29
    3e1e:	d4ea      	bmi.n	3df6 <tcp_input+0x202>
			tcp_rst(ackno, seqno + tcplen, ip_current_dest_addr(), ip_current_src_addr(), tcphdr->dest, tcphdr->src);
    3e20:	682b      	ldr	r3, [r5, #0]
    3e22:	8a28      	ldrh	r0, [r5, #16]
    3e24:	881a      	ldrh	r2, [r3, #0]
    3e26:	9201      	str	r2, [sp, #4]
    3e28:	885b      	ldrh	r3, [r3, #2]
    3e2a:	9300      	str	r3, [sp, #0]
    3e2c:	6869      	ldr	r1, [r5, #4]
    3e2e:	4b11      	ldr	r3, [pc, #68]	; (3e74 <tcp_input+0x280>)
    3e30:	4a0a      	ldr	r2, [pc, #40]	; (3e5c <tcp_input+0x268>)
    3e32:	e2e9      	b.n	4408 <tcp_input+0x814>
			if (lpcb->local_port == tcphdr->dest) {
    3e34:	f8bc b002 	ldrh.w	fp, [ip, #2]
    3e38:	f8ba 201a 	ldrh.w	r2, [sl, #26]
    3e3c:	455a      	cmp	r2, fp
    3e3e:	d107      	bne.n	3e50 <tcp_input+0x25c>
				if (ip_addr_cmp(&(lpcb->local_ip), &current_iphdr_dest) || ip_addr_isany(&(lpcb->local_ip))) {
    3e40:	f8da 2000 	ldr.w	r2, [sl]
    3e44:	4596      	cmp	lr, r2
    3e46:	f000 82c7 	beq.w	43d8 <tcp_input+0x7e4>
    3e4a:	2a00      	cmp	r2, #0
    3e4c:	f000 82c4 	beq.w	43d8 <tcp_input+0x7e4>
		for (lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
    3e50:	4650      	mov	r0, sl
    3e52:	f8da a00c 	ldr.w	sl, [sl, #12]
    3e56:	e7da      	b.n	3e0e <tcp_input+0x21a>
    3e58:	2000a4e0 	.word	0x2000a4e0
    3e5c:	200110b0 	.word	0x200110b0
    3e60:	00007aaf 	.word	0x00007aaf
    3e64:	00007419 	.word	0x00007419
    3e68:	00000d6b 	.word	0x00000d6b
    3e6c:	20014904 	.word	0x20014904
    3e70:	200148fc 	.word	0x200148fc
    3e74:	200110b4 	.word	0x200110b4
    3e78:	000026c5 	.word	0x000026c5
    3e7c:	200148f4 	.word	0x200148f4
    3e80:	00002441 	.word	0x00002441
    3e84:	00003081 	.word	0x00003081
    3e88:	200148f0 	.word	0x200148f0
    3e8c:	00003029 	.word	0x00003029
    3e90:	00000d75 	.word	0x00000d75
	} else if (flags & TCP_SYN) {
    3e94:	079b      	lsls	r3, r3, #30
    3e96:	d5ae      	bpl.n	3df6 <tcp_input+0x202>
		npcb = tcp_alloc(pcb->prio);
    3e98:	f89a 0019 	ldrb.w	r0, [sl, #25]
    3e9c:	4b98      	ldr	r3, [pc, #608]	; (4100 <tcp_input+0x50c>)
    3e9e:	4798      	blx	r3
		if (npcb == NULL) {
    3ea0:	4683      	mov	fp, r0
    3ea2:	2800      	cmp	r0, #0
    3ea4:	d0a7      	beq.n	3df6 <tcp_input+0x202>
		ip_addr_copy(npcb->local_ip, current_iphdr_dest);
    3ea6:	683b      	ldr	r3, [r7, #0]
    3ea8:	6003      	str	r3, [r0, #0]
		npcb->remote_port        = tcphdr->src;
    3eaa:	682a      	ldr	r2, [r5, #0]
		npcb->local_port = pcb->local_port;
    3eac:	f8ba 301a 	ldrh.w	r3, [sl, #26]
    3eb0:	8343      	strh	r3, [r0, #26]
		ip_addr_copy(npcb->remote_ip, current_iphdr_src);
    3eb2:	f8d8 3000 	ldr.w	r3, [r8]
		npcb->remote_port        = tcphdr->src;
    3eb6:	7851      	ldrb	r1, [r2, #1]
		ip_addr_copy(npcb->remote_ip, current_iphdr_src);
    3eb8:	6043      	str	r3, [r0, #4]
		npcb->remote_port        = tcphdr->src;
    3eba:	7813      	ldrb	r3, [r2, #0]
    3ebc:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
    3ec0:	8383      	strh	r3, [r0, #28]
		npcb->state              = SYN_RCVD;
    3ec2:	2303      	movs	r3, #3
    3ec4:	7603      	strb	r3, [r0, #24]
		npcb->rcv_nxt            = seqno + 1;
    3ec6:	686b      	ldr	r3, [r5, #4]
    3ec8:	1c59      	adds	r1, r3, #1
    3eca:	6281      	str	r1, [r0, #40]	; 0x28
		npcb->rcv_ann_right_edge = npcb->rcv_nxt;
    3ecc:	6301      	str	r1, [r0, #48]	; 0x30
		npcb->snd_wl1            = seqno - 1; /* initialise to seqno-1 to force window update */
    3ece:	3b01      	subs	r3, #1
		npcb->snd_wnd            = tcphdr->wnd;
    3ed0:	89d2      	ldrh	r2, [r2, #14]
		npcb->snd_wl1            = seqno - 1; /* initialise to seqno-1 to force window update */
    3ed2:	6543      	str	r3, [r0, #84]	; 0x54
		npcb->callback_arg       = pcb->callback_arg;
    3ed4:	f8da 3010 	ldr.w	r3, [sl, #16]
    3ed8:	6103      	str	r3, [r0, #16]
		npcb->accept = pcb->accept;
    3eda:	f8da 3014 	ldr.w	r3, [sl, #20]
		npcb->snd_wnd            = tcphdr->wnd;
    3ede:	f8a0 2060 	strh.w	r2, [r0, #96]	; 0x60
		npcb->snd_wnd_max        = tcphdr->wnd;
    3ee2:	f8a0 2062 	strh.w	r2, [r0, #98]	; 0x62
		npcb->ssthresh           = npcb->snd_wnd;
    3ee6:	f8a0 204e 	strh.w	r2, [r0, #78]	; 0x4e
		npcb->accept = pcb->accept;
    3eea:	6143      	str	r3, [r0, #20]
		npcb->so_options = pcb->so_options & SOF_INHERITED;
    3eec:	f89a 3008 	ldrb.w	r3, [sl, #8]
    3ef0:	f023 0373 	bic.w	r3, r3, #115	; 0x73
    3ef4:	7203      	strb	r3, [r0, #8]
		TCP_REG_ACTIVE(npcb);
    3ef6:	f8d9 3000 	ldr.w	r3, [r9]
    3efa:	60c3      	str	r3, [r0, #12]
    3efc:	4b81      	ldr	r3, [pc, #516]	; (4104 <tcp_input+0x510>)
    3efe:	f8c9 0000 	str.w	r0, [r9]
    3f02:	4798      	blx	r3
    3f04:	4b80      	ldr	r3, [pc, #512]	; (4108 <tcp_input+0x514>)
    3f06:	2201      	movs	r2, #1
    3f08:	701a      	strb	r2, [r3, #0]
		tcp_parseopt(npcb);
    3f0a:	4658      	mov	r0, fp
    3f0c:	4b7f      	ldr	r3, [pc, #508]	; (410c <tcp_input+0x518>)
    3f0e:	4798      	blx	r3
		npcb->mss = tcp_eff_send_mss(npcb->mss, &(npcb->remote_ip));
    3f10:	4b7f      	ldr	r3, [pc, #508]	; (4110 <tcp_input+0x51c>)
    3f12:	f8bb 0036 	ldrh.w	r0, [fp, #54]	; 0x36
    3f16:	f10b 0104 	add.w	r1, fp, #4
    3f1a:	4798      	blx	r3
		rc = tcp_enqueue_flags(npcb, TCP_SYN | TCP_ACK);
    3f1c:	4b7d      	ldr	r3, [pc, #500]	; (4114 <tcp_input+0x520>)
		npcb->mss = tcp_eff_send_mss(npcb->mss, &(npcb->remote_ip));
    3f1e:	f8ab 0036 	strh.w	r0, [fp, #54]	; 0x36
		rc = tcp_enqueue_flags(npcb, TCP_SYN | TCP_ACK);
    3f22:	2112      	movs	r1, #18
    3f24:	4658      	mov	r0, fp
    3f26:	4798      	blx	r3
		if (rc != ERR_OK) {
    3f28:	b120      	cbz	r0, 3f34 <tcp_input+0x340>
			tcp_abandon(npcb, 0);
    3f2a:	4b7b      	ldr	r3, [pc, #492]	; (4118 <tcp_input+0x524>)
    3f2c:	4621      	mov	r1, r4
    3f2e:	4658      	mov	r0, fp
    3f30:	4798      	blx	r3
			return rc;
    3f32:	e760      	b.n	3df6 <tcp_input+0x202>
		return tcp_output(npcb);
    3f34:	4658      	mov	r0, fp
    3f36:	e75c      	b.n	3df2 <tcp_input+0x1fe>
			if ((tcp_process_refused_data(pcb) == ERR_ABRT) || ((pcb->refused_data != NULL) && (tcplen > 0))) {
    3f38:	4b78      	ldr	r3, [pc, #480]	; (411c <tcp_input+0x528>)
    3f3a:	4620      	mov	r0, r4
    3f3c:	4798      	blx	r3
    3f3e:	300a      	adds	r0, #10
    3f40:	d007      	beq.n	3f52 <tcp_input+0x35e>
    3f42:	6fa3      	ldr	r3, [r4, #120]	; 0x78
    3f44:	2b00      	cmp	r3, #0
    3f46:	f43f af0e 	beq.w	3d66 <tcp_input+0x172>
    3f4a:	8a2b      	ldrh	r3, [r5, #16]
    3f4c:	2b00      	cmp	r3, #0
    3f4e:	f43f af0a 	beq.w	3d66 <tcp_input+0x172>
		if (inseg.p != NULL) {
    3f52:	69a8      	ldr	r0, [r5, #24]
		tcp_input_pcb = NULL;
    3f54:	2400      	movs	r4, #0
    3f56:	62ec      	str	r4, [r5, #44]	; 0x2c
		recv_data     = NULL;
    3f58:	626c      	str	r4, [r5, #36]	; 0x24
		if (inseg.p != NULL) {
    3f5a:	b110      	cbz	r0, 3f62 <tcp_input+0x36e>
			pbuf_free(inseg.p);
    3f5c:	4b70      	ldr	r3, [pc, #448]	; (4120 <tcp_input+0x52c>)
    3f5e:	4798      	blx	r3
			inseg.p = NULL;
    3f60:	61ac      	str	r4, [r5, #24]
}
    3f62:	b005      	add	sp, #20
    3f64:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		if (pcb->state == SYN_SENT) {
    3f68:	7e23      	ldrb	r3, [r4, #24]
    3f6a:	2b02      	cmp	r3, #2
    3f6c:	d10e      	bne.n	3f8c <tcp_input+0x398>
			if (ackno == pcb->snd_nxt) {
    3f6e:	6d22      	ldr	r2, [r4, #80]	; 0x50
    3f70:	68eb      	ldr	r3, [r5, #12]
    3f72:	429a      	cmp	r2, r3
    3f74:	d112      	bne.n	3f9c <tcp_input+0x3a8>
			recv_flags |= TF_RESET;
    3f76:	f895 3028 	ldrb.w	r3, [r5, #40]	; 0x28
    3f7a:	f043 0308 	orr.w	r3, r3, #8
    3f7e:	f885 3028 	strb.w	r3, [r5, #40]	; 0x28
			pcb->flags &= ~TF_ACK_DELAY;
    3f82:	7fa3      	ldrb	r3, [r4, #30]
    3f84:	f023 0301 	bic.w	r3, r3, #1
			tcp_ack_now(pcb);
    3f88:	77a3      	strb	r3, [r4, #30]
		if (err != ERR_ABRT) {
    3f8a:	e007      	b.n	3f9c <tcp_input+0x3a8>
			if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, pcb->rcv_nxt + pcb->rcv_wnd)) {
    3f8c:	686b      	ldr	r3, [r5, #4]
    3f8e:	6aa2      	ldr	r2, [r4, #40]	; 0x28
    3f90:	1a9b      	subs	r3, r3, r2
    3f92:	d403      	bmi.n	3f9c <tcp_input+0x3a8>
    3f94:	8da2      	ldrh	r2, [r4, #44]	; 0x2c
    3f96:	1a9b      	subs	r3, r3, r2
    3f98:	2b00      	cmp	r3, #0
    3f9a:	ddec      	ble.n	3f76 <tcp_input+0x382>
			if (recv_flags & TF_RESET) {
    3f9c:	f895 3028 	ldrb.w	r3, [r5, #40]	; 0x28
    3fa0:	071f      	lsls	r7, r3, #28
    3fa2:	f140 81a3 	bpl.w	42ec <tcp_input+0x6f8>
				TCP_EVENT_ERR(pcb->errf, pcb->callback_arg, ERR_RST);
    3fa6:	f8d4 308c 	ldr.w	r3, [r4, #140]	; 0x8c
    3faa:	b11b      	cbz	r3, 3fb4 <tcp_input+0x3c0>
    3fac:	f06f 010a 	mvn.w	r1, #10
					TCP_EVENT_ERR(pcb->errf, pcb->callback_arg, ERR_CLSD);
    3fb0:	6920      	ldr	r0, [r4, #16]
    3fb2:	4798      	blx	r3
				tcp_pcb_remove(&tcp_active_pcbs, pcb);
    3fb4:	4621      	mov	r1, r4
    3fb6:	485b      	ldr	r0, [pc, #364]	; (4124 <tcp_input+0x530>)
    3fb8:	4b5b      	ldr	r3, [pc, #364]	; (4128 <tcp_input+0x534>)
    3fba:	4798      	blx	r3
				memp_free(MEMP_TCP_PCB, pcb);
    3fbc:	4b5b      	ldr	r3, [pc, #364]	; (412c <tcp_input+0x538>)
    3fbe:	4621      	mov	r1, r4
    3fc0:	2001      	movs	r0, #1
    3fc2:	4798      	blx	r3
    3fc4:	e7c5      	b.n	3f52 <tcp_input+0x35e>
	if ((pcb->flags & TF_RXCLOSED) == 0) {
    3fc6:	06d8      	lsls	r0, r3, #27
		pcb->tmr = tcp_ticks;
    3fc8:	bf5e      	ittt	pl
    3fca:	4b59      	ldrpl	r3, [pc, #356]	; (4130 <tcp_input+0x53c>)
    3fcc:	681b      	ldrpl	r3, [r3, #0]
    3fce:	6263      	strpl	r3, [r4, #36]	; 0x24
	pcb->keep_cnt_sent = 0;
    3fd0:	2300      	movs	r3, #0
    3fd2:	f884 3096 	strb.w	r3, [r4, #150]	; 0x96
	tcp_parseopt(pcb);
    3fd6:	4620      	mov	r0, r4
    3fd8:	4b4c      	ldr	r3, [pc, #304]	; (410c <tcp_input+0x518>)
    3fda:	4798      	blx	r3
	switch (pcb->state) {
    3fdc:	7e23      	ldrb	r3, [r4, #24]
    3fde:	3b02      	subs	r3, #2
    3fe0:	2b07      	cmp	r3, #7
    3fe2:	d8db      	bhi.n	3f9c <tcp_input+0x3a8>
    3fe4:	e8df f013 	tbh	[pc, r3, lsl #1]
    3fe8:	006f0008 	.word	0x006f0008
    3fec:	00ec00e8 	.word	0x00ec00e8
    3ff0:	00e80134 	.word	0x00e80134
    3ff4:	01700152 	.word	0x01700152
		if ((flags & TCP_ACK) && (flags & TCP_SYN) && ackno == ntohl(pcb->unacked->tcphdr->seqno) + 1) {
    3ff8:	7a2b      	ldrb	r3, [r5, #8]
    3ffa:	f003 0312 	and.w	r3, r3, #18
    3ffe:	2b12      	cmp	r3, #18
    4000:	d14f      	bne.n	40a2 <tcp_input+0x4ae>
    4002:	6f23      	ldr	r3, [r4, #112]	; 0x70
    4004:	68db      	ldr	r3, [r3, #12]
    4006:	6858      	ldr	r0, [r3, #4]
    4008:	4b4a      	ldr	r3, [pc, #296]	; (4134 <tcp_input+0x540>)
    400a:	4798      	blx	r3
    400c:	68eb      	ldr	r3, [r5, #12]
    400e:	3001      	adds	r0, #1
    4010:	4298      	cmp	r0, r3
    4012:	d146      	bne.n	40a2 <tcp_input+0x4ae>
			pcb->snd_buf++;
    4014:	f8b4 3066 	ldrh.w	r3, [r4, #102]	; 0x66
			pcb->lastack            = ackno;
    4018:	64a0      	str	r0, [r4, #72]	; 0x48
			pcb->snd_buf++;
    401a:	3301      	adds	r3, #1
    401c:	f8a4 3066 	strh.w	r3, [r4, #102]	; 0x66
			pcb->rcv_nxt            = seqno + 1;
    4020:	686b      	ldr	r3, [r5, #4]
			pcb->mss = tcp_eff_send_mss(pcb->mss, &(pcb->remote_ip));
    4022:	8ee0      	ldrh	r0, [r4, #54]	; 0x36
			pcb->rcv_nxt            = seqno + 1;
    4024:	1c5a      	adds	r2, r3, #1
    4026:	62a2      	str	r2, [r4, #40]	; 0x28
			pcb->rcv_ann_right_edge = pcb->rcv_nxt;
    4028:	6322      	str	r2, [r4, #48]	; 0x30
			pcb->snd_wnd            = tcphdr->wnd;
    402a:	682a      	ldr	r2, [r5, #0]
			pcb->snd_wl1            = seqno - 1; /* initialise to seqno - 1 to force window update */
    402c:	3b01      	subs	r3, #1
			pcb->snd_wnd            = tcphdr->wnd;
    402e:	89d2      	ldrh	r2, [r2, #14]
			pcb->snd_wl1            = seqno - 1; /* initialise to seqno - 1 to force window update */
    4030:	6563      	str	r3, [r4, #84]	; 0x54
			pcb->state              = ESTABLISHED;
    4032:	2304      	movs	r3, #4
			pcb->mss = tcp_eff_send_mss(pcb->mss, &(pcb->remote_ip));
    4034:	18e1      	adds	r1, r4, r3
			pcb->snd_wnd            = tcphdr->wnd;
    4036:	f8a4 2060 	strh.w	r2, [r4, #96]	; 0x60
			pcb->snd_wnd_max        = tcphdr->wnd;
    403a:	f8a4 2062 	strh.w	r2, [r4, #98]	; 0x62
			pcb->state              = ESTABLISHED;
    403e:	7623      	strb	r3, [r4, #24]
			pcb->mss = tcp_eff_send_mss(pcb->mss, &(pcb->remote_ip));
    4040:	4b33      	ldr	r3, [pc, #204]	; (4110 <tcp_input+0x51c>)
    4042:	4798      	blx	r3
			pcb->ssthresh = pcb->mss * 10;
    4044:	eb00 0380 	add.w	r3, r0, r0, lsl #2
    4048:	005b      	lsls	r3, r3, #1
    404a:	f8a4 304e 	strh.w	r3, [r4, #78]	; 0x4e
			pcb->cwnd = ((pcb->cwnd == 1) ? (pcb->mss * 2) : pcb->mss);
    404e:	f8b4 304c 	ldrh.w	r3, [r4, #76]	; 0x4c
			pcb->mss = tcp_eff_send_mss(pcb->mss, &(pcb->remote_ip));
    4052:	86e0      	strh	r0, [r4, #54]	; 0x36
			pcb->cwnd = ((pcb->cwnd == 1) ? (pcb->mss * 2) : pcb->mss);
    4054:	2b01      	cmp	r3, #1
    4056:	bf08      	it	eq
    4058:	0040      	lsleq	r0, r0, #1
			--pcb->snd_queuelen;
    405a:	f8b4 3068 	ldrh.w	r3, [r4, #104]	; 0x68
			pcb->cwnd = ((pcb->cwnd == 1) ? (pcb->mss * 2) : pcb->mss);
    405e:	bf08      	it	eq
    4060:	b280      	uxtheq	r0, r0
    4062:	f8a4 004c 	strh.w	r0, [r4, #76]	; 0x4c
			rseg         = pcb->unacked;
    4066:	6f20      	ldr	r0, [r4, #112]	; 0x70
			--pcb->snd_queuelen;
    4068:	3b01      	subs	r3, #1
    406a:	f8a4 3068 	strh.w	r3, [r4, #104]	; 0x68
			pcb->unacked = rseg->next;
    406e:	6803      	ldr	r3, [r0, #0]
    4070:	6723      	str	r3, [r4, #112]	; 0x70
			tcp_seg_free(rseg);
    4072:	4b31      	ldr	r3, [pc, #196]	; (4138 <tcp_input+0x544>)
    4074:	4798      	blx	r3
			if (pcb->unacked == NULL)
    4076:	6f23      	ldr	r3, [r4, #112]	; 0x70
    4078:	b93b      	cbnz	r3, 408a <tcp_input+0x496>
				pcb->rtime = -1;
    407a:	f64f 73ff 	movw	r3, #65535	; 0xffff
    407e:	86a3      	strh	r3, [r4, #52]	; 0x34
			TCP_EVENT_CONNECTED(pcb, ERR_OK, err);
    4080:	f8d4 3084 	ldr.w	r3, [r4, #132]	; 0x84
    4084:	b933      	cbnz	r3, 4094 <tcp_input+0x4a0>
			tcp_ack_now(pcb);
    4086:	7fa3      	ldrb	r3, [r4, #30]
    4088:	e67b      	b.n	3d82 <tcp_input+0x18e>
				pcb->rtime = 0;
    408a:	2300      	movs	r3, #0
    408c:	86a3      	strh	r3, [r4, #52]	; 0x34
				pcb->nrtx  = 0;
    408e:	f884 3046 	strb.w	r3, [r4, #70]	; 0x46
    4092:	e7f5      	b.n	4080 <tcp_input+0x48c>
			TCP_EVENT_CONNECTED(pcb, ERR_OK, err);
    4094:	6920      	ldr	r0, [r4, #16]
    4096:	2200      	movs	r2, #0
    4098:	4621      	mov	r1, r4
    409a:	4798      	blx	r3
			if (err == ERR_ABRT) {
    409c:	300a      	adds	r0, #10
    409e:	d1f2      	bne.n	4086 <tcp_input+0x492>
    40a0:	e757      	b.n	3f52 <tcp_input+0x35e>
		else if (flags & TCP_ACK) {
    40a2:	7a2b      	ldrb	r3, [r5, #8]
    40a4:	06d9      	lsls	r1, r3, #27
    40a6:	f57f af79 	bpl.w	3f9c <tcp_input+0x3a8>
			tcp_rst(ackno, seqno + tcplen, ip_current_dest_addr(), ip_current_src_addr(), tcphdr->dest, tcphdr->src);
    40aa:	682b      	ldr	r3, [r5, #0]
    40ac:	8a28      	ldrh	r0, [r5, #16]
    40ae:	881a      	ldrh	r2, [r3, #0]
    40b0:	9201      	str	r2, [sp, #4]
    40b2:	6869      	ldr	r1, [r5, #4]
    40b4:	885b      	ldrh	r3, [r3, #2]
    40b6:	9300      	str	r3, [sp, #0]
    40b8:	4401      	add	r1, r0
    40ba:	4b20      	ldr	r3, [pc, #128]	; (413c <tcp_input+0x548>)
    40bc:	4a20      	ldr	r2, [pc, #128]	; (4140 <tcp_input+0x54c>)
    40be:	68e8      	ldr	r0, [r5, #12]
				tcp_rst(
    40c0:	4e20      	ldr	r6, [pc, #128]	; (4144 <tcp_input+0x550>)
    40c2:	47b0      	blx	r6
		if (err != ERR_ABRT) {
    40c4:	e76a      	b.n	3f9c <tcp_input+0x3a8>
		if (flags & TCP_ACK) {
    40c6:	7a2b      	ldrb	r3, [r5, #8]
    40c8:	06da      	lsls	r2, r3, #27
    40ca:	d568      	bpl.n	419e <tcp_input+0x5aa>
			if (TCP_SEQ_BETWEEN(ackno, pcb->lastack + 1, pcb->snd_nxt)) {
    40cc:	6ca3      	ldr	r3, [r4, #72]	; 0x48
    40ce:	68e8      	ldr	r0, [r5, #12]
    40d0:	43db      	mvns	r3, r3
    40d2:	42c3      	cmn	r3, r0
    40d4:	d458      	bmi.n	4188 <tcp_input+0x594>
    40d6:	6d23      	ldr	r3, [r4, #80]	; 0x50
    40d8:	1ac3      	subs	r3, r0, r3
    40da:	2b00      	cmp	r3, #0
    40dc:	dc54      	bgt.n	4188 <tcp_input+0x594>
				pcb->state = ESTABLISHED;
    40de:	2304      	movs	r3, #4
    40e0:	7623      	strb	r3, [r4, #24]
				TCP_EVENT_ACCEPT(pcb, ERR_OK, err);
    40e2:	6963      	ldr	r3, [r4, #20]
    40e4:	b91b      	cbnz	r3, 40ee <tcp_input+0x4fa>
						tcp_abort(pcb);
    40e6:	4b18      	ldr	r3, [pc, #96]	; (4148 <tcp_input+0x554>)
    40e8:	4620      	mov	r0, r4
    40ea:	4798      	blx	r3
						goto aborted;
    40ec:	e731      	b.n	3f52 <tcp_input+0x35e>
				TCP_EVENT_ACCEPT(pcb, ERR_OK, err);
    40ee:	6920      	ldr	r0, [r4, #16]
    40f0:	2200      	movs	r2, #0
    40f2:	4621      	mov	r1, r4
    40f4:	4798      	blx	r3
				if (err != ERR_OK) {
    40f6:	b348      	cbz	r0, 414c <tcp_input+0x558>
					if (err != ERR_ABRT) {
    40f8:	300a      	adds	r0, #10
    40fa:	f43f af2a 	beq.w	3f52 <tcp_input+0x35e>
    40fe:	e7f2      	b.n	40e6 <tcp_input+0x4f2>
    4100:	00006311 	.word	0x00006311
    4104:	000010a5 	.word	0x000010a5
    4108:	20014900 	.word	0x20014900
    410c:	0000337d 	.word	0x0000337d
    4110:	00006415 	.word	0x00006415
    4114:	000022d9 	.word	0x000022d9
    4118:	00006241 	.word	0x00006241
    411c:	000060e9 	.word	0x000060e9
    4120:	00003081 	.word	0x00003081
    4124:	200148fc 	.word	0x200148fc
    4128:	00005ed1 	.word	0x00005ed1
    412c:	00004b49 	.word	0x00004b49
    4130:	200148f4 	.word	0x200148f4
    4134:	00000d75 	.word	0x00000d75
    4138:	00005b39 	.word	0x00005b39
    413c:	200110b4 	.word	0x200110b4
    4140:	200110b0 	.word	0x200110b0
    4144:	000026c5 	.word	0x000026c5
    4148:	000062ed 	.word	0x000062ed
				tcp_receive(pcb);
    414c:	4b95      	ldr	r3, [pc, #596]	; (43a4 <tcp_input+0x7b0>)
				old_cwnd = pcb->cwnd;
    414e:	f8b4 604c 	ldrh.w	r6, [r4, #76]	; 0x4c
				tcp_receive(pcb);
    4152:	4620      	mov	r0, r4
    4154:	4798      	blx	r3
				if (pcb->acked != 0) {
    4156:	f8b4 3064 	ldrh.w	r3, [r4, #100]	; 0x64
    415a:	b113      	cbz	r3, 4162 <tcp_input+0x56e>
					pcb->acked--;
    415c:	3b01      	subs	r3, #1
    415e:	f8a4 3064 	strh.w	r3, [r4, #100]	; 0x64
				pcb->cwnd = ((old_cwnd == 1) ? (pcb->mss * 2) : pcb->mss);
    4162:	8ee3      	ldrh	r3, [r4, #54]	; 0x36
    4164:	2e01      	cmp	r6, #1
    4166:	bf04      	itt	eq
    4168:	005b      	lsleq	r3, r3, #1
    416a:	b29b      	uxtheq	r3, r3
    416c:	f8a4 304c 	strh.w	r3, [r4, #76]	; 0x4c
		if (recv_flags & TF_GOT_FIN) { /* passive close */
    4170:	f895 3028 	ldrb.w	r3, [r5, #40]	; 0x28
    4174:	069e      	lsls	r6, r3, #26
    4176:	f57f af11 	bpl.w	3f9c <tcp_input+0x3a8>
			tcp_ack_now(pcb);
    417a:	7fa3      	ldrb	r3, [r4, #30]
    417c:	f043 0302 	orr.w	r3, r3, #2
    4180:	77a3      	strb	r3, [r4, #30]
			pcb->state = CLOSE_WAIT;
    4182:	2307      	movs	r3, #7
			pcb->state = FIN_WAIT_2;
    4184:	7623      	strb	r3, [r4, #24]
		if (err != ERR_ABRT) {
    4186:	e709      	b.n	3f9c <tcp_input+0x3a8>
				    ackno, seqno + tcplen, ip_current_dest_addr(), ip_current_src_addr(), tcphdr->dest, tcphdr->src);
    4188:	682b      	ldr	r3, [r5, #0]
				tcp_rst(
    418a:	8a2e      	ldrh	r6, [r5, #16]
    418c:	881a      	ldrh	r2, [r3, #0]
    418e:	9201      	str	r2, [sp, #4]
    4190:	6869      	ldr	r1, [r5, #4]
    4192:	885b      	ldrh	r3, [r3, #2]
    4194:	9300      	str	r3, [sp, #0]
    4196:	4a84      	ldr	r2, [pc, #528]	; (43a8 <tcp_input+0x7b4>)
    4198:	4b84      	ldr	r3, [pc, #528]	; (43ac <tcp_input+0x7b8>)
    419a:	4431      	add	r1, r6
    419c:	e790      	b.n	40c0 <tcp_input+0x4cc>
		} else if ((flags & TCP_SYN) && (seqno == pcb->rcv_nxt - 1)) {
    419e:	079f      	lsls	r7, r3, #30
    41a0:	f57f aefc 	bpl.w	3f9c <tcp_input+0x3a8>
    41a4:	6aa3      	ldr	r3, [r4, #40]	; 0x28
    41a6:	686a      	ldr	r2, [r5, #4]
    41a8:	3b01      	subs	r3, #1
    41aa:	4293      	cmp	r3, r2
    41ac:	f47f aef6 	bne.w	3f9c <tcp_input+0x3a8>
			tcp_rexmit(pcb);
    41b0:	4b7f      	ldr	r3, [pc, #508]	; (43b0 <tcp_input+0x7bc>)
    41b2:	4620      	mov	r0, r4
    41b4:	4798      	blx	r3
		if (err != ERR_ABRT) {
    41b6:	e6f1      	b.n	3f9c <tcp_input+0x3a8>
		tcp_receive(pcb);
    41b8:	4b7a      	ldr	r3, [pc, #488]	; (43a4 <tcp_input+0x7b0>)
    41ba:	4620      	mov	r0, r4
    41bc:	4798      	blx	r3
    41be:	e7d7      	b.n	4170 <tcp_input+0x57c>
		tcp_receive(pcb);
    41c0:	4b78      	ldr	r3, [pc, #480]	; (43a4 <tcp_input+0x7b0>)
    41c2:	4620      	mov	r0, r4
    41c4:	4798      	blx	r3
		if (recv_flags & TF_GOT_FIN) {
    41c6:	f895 3028 	ldrb.w	r3, [r5, #40]	; 0x28
    41ca:	f013 0f20 	tst.w	r3, #32
    41ce:	7a2b      	ldrb	r3, [r5, #8]
    41d0:	d034      	beq.n	423c <tcp_input+0x648>
			if ((flags & TCP_ACK) && (ackno == pcb->snd_nxt)) {
    41d2:	f013 0f10 	tst.w	r3, #16
    41d6:	7fa3      	ldrb	r3, [r4, #30]
				tcp_ack_now(pcb);
    41d8:	f043 0302 	orr.w	r3, r3, #2
			if ((flags & TCP_ACK) && (ackno == pcb->snd_nxt)) {
    41dc:	d02b      	beq.n	4236 <tcp_input+0x642>
    41de:	6d21      	ldr	r1, [r4, #80]	; 0x50
    41e0:	68ea      	ldr	r2, [r5, #12]
    41e2:	4291      	cmp	r1, r2
    41e4:	d127      	bne.n	4236 <tcp_input+0x642>
				tcp_ack_now(pcb);
    41e6:	77a3      	strb	r3, [r4, #30]
				tcp_pcb_purge(pcb);
    41e8:	4620      	mov	r0, r4
    41ea:	4b72      	ldr	r3, [pc, #456]	; (43b4 <tcp_input+0x7c0>)
    41ec:	4798      	blx	r3
				TCP_RMV_ACTIVE(pcb);
    41ee:	4a72      	ldr	r2, [pc, #456]	; (43b8 <tcp_input+0x7c4>)
    41f0:	6813      	ldr	r3, [r2, #0]
    41f2:	429c      	cmp	r4, r3
    41f4:	d102      	bne.n	41fc <tcp_input+0x608>
			TCP_RMV_ACTIVE(pcb);
    41f6:	68e3      	ldr	r3, [r4, #12]
    41f8:	6013      	str	r3, [r2, #0]
    41fa:	e00d      	b.n	4218 <tcp_input+0x624>
				TCP_RMV_ACTIVE(pcb);
    41fc:	4a6f      	ldr	r2, [pc, #444]	; (43bc <tcp_input+0x7c8>)
    41fe:	2100      	movs	r1, #0
    4200:	6013      	str	r3, [r2, #0]
    4202:	b913      	cbnz	r3, 420a <tcp_input+0x616>
    4204:	2900      	cmp	r1, #0
    4206:	d1f7      	bne.n	41f8 <tcp_input+0x604>
    4208:	e006      	b.n	4218 <tcp_input+0x624>
    420a:	68d8      	ldr	r0, [r3, #12]
    420c:	4284      	cmp	r4, r0
    420e:	d10f      	bne.n	4230 <tcp_input+0x63c>
    4210:	b101      	cbz	r1, 4214 <tcp_input+0x620>
    4212:	6013      	str	r3, [r2, #0]
			TCP_RMV_ACTIVE(pcb);
    4214:	68e2      	ldr	r2, [r4, #12]
    4216:	60da      	str	r2, [r3, #12]
    4218:	4b69      	ldr	r3, [pc, #420]	; (43c0 <tcp_input+0x7cc>)
    421a:	2201      	movs	r2, #1
    421c:	701a      	strb	r2, [r3, #0]
			pcb->state = TIME_WAIT;
    421e:	230a      	movs	r3, #10
    4220:	7623      	strb	r3, [r4, #24]
			TCP_REG(&tcp_tw_pcbs, pcb);
    4222:	4b68      	ldr	r3, [pc, #416]	; (43c4 <tcp_input+0x7d0>)
    4224:	681a      	ldr	r2, [r3, #0]
    4226:	60e2      	str	r2, [r4, #12]
    4228:	601c      	str	r4, [r3, #0]
    422a:	4b67      	ldr	r3, [pc, #412]	; (43c8 <tcp_input+0x7d4>)
    422c:	4798      	blx	r3
		if (err != ERR_ABRT) {
    422e:	e6b5      	b.n	3f9c <tcp_input+0x3a8>
    4230:	2101      	movs	r1, #1
    4232:	4603      	mov	r3, r0
    4234:	e7e5      	b.n	4202 <tcp_input+0x60e>
				tcp_ack_now(pcb);
    4236:	77a3      	strb	r3, [r4, #30]
				pcb->state = CLOSING;
    4238:	2308      	movs	r3, #8
    423a:	e7a3      	b.n	4184 <tcp_input+0x590>
		} else if ((flags & TCP_ACK) && (ackno == pcb->snd_nxt)) {
    423c:	06d8      	lsls	r0, r3, #27
    423e:	f57f aead 	bpl.w	3f9c <tcp_input+0x3a8>
    4242:	6d22      	ldr	r2, [r4, #80]	; 0x50
    4244:	68eb      	ldr	r3, [r5, #12]
    4246:	429a      	cmp	r2, r3
    4248:	f47f aea8 	bne.w	3f9c <tcp_input+0x3a8>
			pcb->state = FIN_WAIT_2;
    424c:	2306      	movs	r3, #6
    424e:	e799      	b.n	4184 <tcp_input+0x590>
		tcp_receive(pcb);
    4250:	4b54      	ldr	r3, [pc, #336]	; (43a4 <tcp_input+0x7b0>)
    4252:	4620      	mov	r0, r4
    4254:	4798      	blx	r3
		if (recv_flags & TF_GOT_FIN) {
    4256:	f895 3028 	ldrb.w	r3, [r5, #40]	; 0x28
    425a:	0699      	lsls	r1, r3, #26
    425c:	f57f ae9e 	bpl.w	3f9c <tcp_input+0x3a8>
			tcp_ack_now(pcb);
    4260:	7fa3      	ldrb	r3, [r4, #30]
    4262:	f043 0302 	orr.w	r3, r3, #2
    4266:	77a3      	strb	r3, [r4, #30]
			tcp_pcb_purge(pcb);
    4268:	4620      	mov	r0, r4
    426a:	4b52      	ldr	r3, [pc, #328]	; (43b4 <tcp_input+0x7c0>)
    426c:	4798      	blx	r3
			TCP_RMV_ACTIVE(pcb);
    426e:	4a52      	ldr	r2, [pc, #328]	; (43b8 <tcp_input+0x7c4>)
    4270:	6813      	ldr	r3, [r2, #0]
    4272:	429c      	cmp	r4, r3
    4274:	d0bf      	beq.n	41f6 <tcp_input+0x602>
    4276:	4a51      	ldr	r2, [pc, #324]	; (43bc <tcp_input+0x7c8>)
    4278:	2100      	movs	r1, #0
    427a:	6013      	str	r3, [r2, #0]
    427c:	2b00      	cmp	r3, #0
    427e:	d0c1      	beq.n	4204 <tcp_input+0x610>
    4280:	68d8      	ldr	r0, [r3, #12]
    4282:	4284      	cmp	r4, r0
    4284:	d0c4      	beq.n	4210 <tcp_input+0x61c>
    4286:	2101      	movs	r1, #1
    4288:	4603      	mov	r3, r0
    428a:	e7f7      	b.n	427c <tcp_input+0x688>
		tcp_receive(pcb);
    428c:	4b45      	ldr	r3, [pc, #276]	; (43a4 <tcp_input+0x7b0>)
    428e:	4620      	mov	r0, r4
    4290:	4798      	blx	r3
		if (flags & TCP_ACK && ackno == pcb->snd_nxt) {
    4292:	7a2b      	ldrb	r3, [r5, #8]
    4294:	06da      	lsls	r2, r3, #27
    4296:	f57f ae81 	bpl.w	3f9c <tcp_input+0x3a8>
    429a:	6d22      	ldr	r2, [r4, #80]	; 0x50
    429c:	68eb      	ldr	r3, [r5, #12]
    429e:	429a      	cmp	r2, r3
    42a0:	f47f ae7c 	bne.w	3f9c <tcp_input+0x3a8>
			tcp_pcb_purge(pcb);
    42a4:	4b43      	ldr	r3, [pc, #268]	; (43b4 <tcp_input+0x7c0>)
    42a6:	4620      	mov	r0, r4
    42a8:	4798      	blx	r3
			TCP_RMV_ACTIVE(pcb);
    42aa:	4a43      	ldr	r2, [pc, #268]	; (43b8 <tcp_input+0x7c4>)
    42ac:	6813      	ldr	r3, [r2, #0]
    42ae:	429c      	cmp	r4, r3
    42b0:	d0a1      	beq.n	41f6 <tcp_input+0x602>
    42b2:	4a42      	ldr	r2, [pc, #264]	; (43bc <tcp_input+0x7c8>)
    42b4:	2100      	movs	r1, #0
    42b6:	6013      	str	r3, [r2, #0]
    42b8:	2b00      	cmp	r3, #0
    42ba:	d0a3      	beq.n	4204 <tcp_input+0x610>
    42bc:	68d8      	ldr	r0, [r3, #12]
    42be:	4284      	cmp	r4, r0
    42c0:	d0a6      	beq.n	4210 <tcp_input+0x61c>
    42c2:	2101      	movs	r1, #1
    42c4:	4603      	mov	r3, r0
    42c6:	e7f7      	b.n	42b8 <tcp_input+0x6c4>
		tcp_receive(pcb);
    42c8:	4b36      	ldr	r3, [pc, #216]	; (43a4 <tcp_input+0x7b0>)
    42ca:	4620      	mov	r0, r4
    42cc:	4798      	blx	r3
		if (flags & TCP_ACK && ackno == pcb->snd_nxt) {
    42ce:	7a2b      	ldrb	r3, [r5, #8]
    42d0:	06db      	lsls	r3, r3, #27
    42d2:	f57f ae63 	bpl.w	3f9c <tcp_input+0x3a8>
    42d6:	68eb      	ldr	r3, [r5, #12]
    42d8:	6d22      	ldr	r2, [r4, #80]	; 0x50
    42da:	429a      	cmp	r2, r3
			recv_flags |= TF_CLOSED;
    42dc:	bf02      	ittt	eq
    42de:	f895 3028 	ldrbeq.w	r3, [r5, #40]	; 0x28
    42e2:	f043 0310 	orreq.w	r3, r3, #16
    42e6:	f885 3028 	strbeq.w	r3, [r5, #40]	; 0x28
		if (err != ERR_ABRT) {
    42ea:	e657      	b.n	3f9c <tcp_input+0x3a8>
			} else if (recv_flags & TF_CLOSED) {
    42ec:	06de      	lsls	r6, r3, #27
    42ee:	d50b      	bpl.n	4308 <tcp_input+0x714>
				if (!(pcb->flags & TF_RXCLOSED)) {
    42f0:	7fa3      	ldrb	r3, [r4, #30]
    42f2:	06d8      	lsls	r0, r3, #27
    42f4:	f53f ae5e 	bmi.w	3fb4 <tcp_input+0x3c0>
					TCP_EVENT_ERR(pcb->errf, pcb->callback_arg, ERR_CLSD);
    42f8:	f8d4 308c 	ldr.w	r3, [r4, #140]	; 0x8c
    42fc:	2b00      	cmp	r3, #0
    42fe:	f43f ae59 	beq.w	3fb4 <tcp_input+0x3c0>
    4302:	f06f 010b 	mvn.w	r1, #11
    4306:	e653      	b.n	3fb0 <tcp_input+0x3bc>
				if (pcb->acked > 0) {
    4308:	f8b4 2064 	ldrh.w	r2, [r4, #100]	; 0x64
    430c:	b992      	cbnz	r2, 4334 <tcp_input+0x740>
				if (recv_data != NULL) {
    430e:	6a6a      	ldr	r2, [r5, #36]	; 0x24
    4310:	b9ca      	cbnz	r2, 4346 <tcp_input+0x752>
				if (recv_flags & TF_GOT_FIN) {
    4312:	f895 3028 	ldrb.w	r3, [r5, #40]	; 0x28
    4316:	0699      	lsls	r1, r3, #26
    4318:	d506      	bpl.n	4328 <tcp_input+0x734>
					if (pcb->refused_data != NULL) {
    431a:	6fa3      	ldr	r3, [r4, #120]	; 0x78
    431c:	2b00      	cmp	r3, #0
    431e:	d02e      	beq.n	437e <tcp_input+0x78a>
						pcb->refused_data->flags |= PBUF_FLAG_TCP_FIN;
    4320:	7b5a      	ldrb	r2, [r3, #13]
    4322:	f042 0220 	orr.w	r2, r2, #32
    4326:	735a      	strb	r2, [r3, #13]
				tcp_input_pcb = NULL;
    4328:	2300      	movs	r3, #0
    432a:	62eb      	str	r3, [r5, #44]	; 0x2c
				tcp_output(pcb);
    432c:	4620      	mov	r0, r4
    432e:	4b27      	ldr	r3, [pc, #156]	; (43cc <tcp_input+0x7d8>)
    4330:	4798      	blx	r3
    4332:	e60e      	b.n	3f52 <tcp_input+0x35e>
					TCP_EVENT_SENT(pcb, pcb->acked, err);
    4334:	6fe3      	ldr	r3, [r4, #124]	; 0x7c
    4336:	2b00      	cmp	r3, #0
    4338:	d0e9      	beq.n	430e <tcp_input+0x71a>
    433a:	6920      	ldr	r0, [r4, #16]
    433c:	4621      	mov	r1, r4
    433e:	4798      	blx	r3
					if (err == ERR_ABRT) {
    4340:	300a      	adds	r0, #10
    4342:	d1e4      	bne.n	430e <tcp_input+0x71a>
    4344:	e605      	b.n	3f52 <tcp_input+0x35e>
					if (pcb->flags & TF_RXCLOSED) {
    4346:	7fa3      	ldrb	r3, [r4, #30]
    4348:	f013 0310 	ands.w	r3, r3, #16
    434c:	d003      	beq.n	4356 <tcp_input+0x762>
						pbuf_free(recv_data);
    434e:	4b20      	ldr	r3, [pc, #128]	; (43d0 <tcp_input+0x7dc>)
    4350:	4610      	mov	r0, r2
    4352:	4798      	blx	r3
    4354:	e6c7      	b.n	40e6 <tcp_input+0x4f2>
					TCP_EVENT_RECV(pcb, recv_data, ERR_OK, err);
    4356:	f8d4 6080 	ldr.w	r6, [r4, #128]	; 0x80
    435a:	b15e      	cbz	r6, 4374 <tcp_input+0x780>
    435c:	6920      	ldr	r0, [r4, #16]
    435e:	4621      	mov	r1, r4
    4360:	47b0      	blx	r6
					if (err == ERR_ABRT) {
    4362:	f110 0f0a 	cmn.w	r0, #10
    4366:	f43f adf4 	beq.w	3f52 <tcp_input+0x35e>
					if (err != ERR_OK) {
    436a:	2800      	cmp	r0, #0
    436c:	d0d1      	beq.n	4312 <tcp_input+0x71e>
						pcb->refused_data = recv_data;
    436e:	6a6b      	ldr	r3, [r5, #36]	; 0x24
    4370:	67a3      	str	r3, [r4, #120]	; 0x78
    4372:	e7ce      	b.n	4312 <tcp_input+0x71e>
					TCP_EVENT_RECV(pcb, recv_data, ERR_OK, err);
    4374:	4633      	mov	r3, r6
    4376:	4630      	mov	r0, r6
    4378:	4621      	mov	r1, r4
    437a:	4e16      	ldr	r6, [pc, #88]	; (43d4 <tcp_input+0x7e0>)
    437c:	e7f0      	b.n	4360 <tcp_input+0x76c>
						if (pcb->rcv_wnd != TCP_WND) {
    437e:	8da3      	ldrh	r3, [r4, #44]	; 0x2c
						TCP_EVENT_CLOSED(pcb, err);
    4380:	f8d4 6080 	ldr.w	r6, [r4, #128]	; 0x80
						if (pcb->rcv_wnd != TCP_WND) {
    4384:	f241 62d0 	movw	r2, #5840	; 0x16d0
    4388:	4293      	cmp	r3, r2
							pcb->rcv_wnd++;
    438a:	bf1c      	itt	ne
    438c:	3301      	addne	r3, #1
    438e:	85a3      	strhne	r3, [r4, #44]	; 0x2c
						TCP_EVENT_CLOSED(pcb, err);
    4390:	2e00      	cmp	r6, #0
    4392:	d0c9      	beq.n	4328 <tcp_input+0x734>
    4394:	2300      	movs	r3, #0
    4396:	6920      	ldr	r0, [r4, #16]
    4398:	461a      	mov	r2, r3
    439a:	4621      	mov	r1, r4
    439c:	47b0      	blx	r6
						if (err == ERR_ABRT) {
    439e:	300a      	adds	r0, #10
    43a0:	d1c2      	bne.n	4328 <tcp_input+0x734>
    43a2:	e5d6      	b.n	3f52 <tcp_input+0x35e>
    43a4:	000034a5 	.word	0x000034a5
    43a8:	200110b0 	.word	0x200110b0
    43ac:	200110b4 	.word	0x200110b4
    43b0:	000027ad 	.word	0x000027ad
    43b4:	00005bc9 	.word	0x00005bc9
    43b8:	200148fc 	.word	0x200148fc
    43bc:	200148ec 	.word	0x200148ec
    43c0:	20014900 	.word	0x20014900
    43c4:	20014904 	.word	0x20014904
    43c8:	000010a5 	.word	0x000010a5
    43cc:	00002441 	.word	0x00002441
    43d0:	00003081 	.word	0x00003081
    43d4:	000060b9 	.word	0x000060b9
			if (prev != NULL) {
    43d8:	b138      	cbz	r0, 43ea <tcp_input+0x7f6>
				((struct tcp_pcb_listen *)prev)->next = lpcb->next;
    43da:	f8da 200c 	ldr.w	r2, [sl, #12]
    43de:	60c2      	str	r2, [r0, #12]
				tcp_listen_pcbs.listen_pcbs = lpcb;
    43e0:	4a0a      	ldr	r2, [pc, #40]	; (440c <tcp_input+0x818>)
				lpcb->next = tcp_listen_pcbs.listen_pcbs;
    43e2:	f8ca 400c 	str.w	r4, [sl, #12]
				tcp_listen_pcbs.listen_pcbs = lpcb;
    43e6:	f8c2 a000 	str.w	sl, [r2]
	if (flags & TCP_RST) {
    43ea:	075a      	lsls	r2, r3, #29
    43ec:	f53f ad03 	bmi.w	3df6 <tcp_input+0x202>
	if (flags & TCP_ACK) {
    43f0:	f013 0410 	ands.w	r4, r3, #16
    43f4:	f43f ad4e 	beq.w	3e94 <tcp_input+0x2a0>
		tcp_rst(ackno, seqno + tcplen, ip_current_dest_addr(), ip_current_src_addr(), tcphdr->dest, tcphdr->src);
    43f8:	f8bc 3000 	ldrh.w	r3, [ip]
    43fc:	6868      	ldr	r0, [r5, #4]
    43fe:	4a04      	ldr	r2, [pc, #16]	; (4410 <tcp_input+0x81c>)
    4400:	9902      	ldr	r1, [sp, #8]
    4402:	e9cd b300 	strd	fp, r3, [sp]
    4406:	4b03      	ldr	r3, [pc, #12]	; (4414 <tcp_input+0x820>)
			tcp_rst(ackno, seqno + tcplen, ip_current_dest_addr(), ip_current_src_addr(), tcphdr->dest, tcphdr->src);
    4408:	4401      	add	r1, r0
    440a:	e4e3      	b.n	3dd4 <tcp_input+0x1e0>
    440c:	200148f0 	.word	0x200148f0
    4410:	200110b0 	.word	0x200110b0
    4414:	200110b4 	.word	0x200110b4

00004418 <udp_init>:
void udp_init(void)
{
#if LWIP_RANDOMIZE_INITIAL_LOCAL_PORTS && defined(LWIP_RAND)
	udp_port = UDP_ENSURE_LOCAL_PORT_RANGE(LWIP_RAND());
#endif /* LWIP_RANDOMIZE_INITIAL_LOCAL_PORTS && defined(LWIP_RAND) */
}
    4418:	4770      	bx	lr
	...

0000441c <udp_input>:
 * @param p pbuf to be demultiplexed to a UDP PCB.
 * @param inp network interface on which the datagram was received.
 *
 */
void udp_input(struct pbuf *p, struct netif *inp)
{
    441c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}

	PERF_START;

	UDP_STATS_INC(udp.recv);

	iphdr = (struct ip_hdr *)p->payload;
    4420:	f8d0 9004 	ldr.w	r9, [r0, #4]

	/* Check minimum length (IP header + UDP header)
	 * and move payload pointer to UDP header */
	if (p->tot_len < (IPH_HL(iphdr) * 4 + UDP_HLEN) || pbuf_header(p, -(s16_t)(IPH_HL(iphdr) * 4))) {
    4424:	8903      	ldrh	r3, [r0, #8]
{
    4426:	468a      	mov	sl, r1
    4428:	f899 1000 	ldrb.w	r1, [r9]
    442c:	f001 010f 	and.w	r1, r1, #15
	if (p->tot_len < (IPH_HL(iphdr) * 4 + UDP_HLEN) || pbuf_header(p, -(s16_t)(IPH_HL(iphdr) * 4))) {
    4430:	1c8a      	adds	r2, r1, #2
    4432:	ebb3 0f82 	cmp.w	r3, r2, lsl #2
{
    4436:	b085      	sub	sp, #20
    4438:	4605      	mov	r5, r0
	if (p->tot_len < (IPH_HL(iphdr) * 4 + UDP_HLEN) || pbuf_header(p, -(s16_t)(IPH_HL(iphdr) * 4))) {
    443a:	db05      	blt.n	4448 <udp_input+0x2c>
    443c:	0089      	lsls	r1, r1, #2
    443e:	4b4a      	ldr	r3, [pc, #296]	; (4568 <udp_input+0x14c>)
    4440:	4249      	negs	r1, r1
    4442:	4798      	blx	r3
    4444:	4604      	mov	r4, r0
    4446:	b128      	cbz	r0, 4454 <udp_input+0x38>
		/* drop short packets */
		LWIP_DEBUGF(UDP_DEBUG, ("udp_input: short UDP datagram (%" U16_F " bytes) discarded\n", p->tot_len));
		UDP_STATS_INC(udp.lenerr);
		UDP_STATS_INC(udp.drop);
		snmp_inc_udpinerrors();
		pbuf_free(p);
    4448:	4b48      	ldr	r3, [pc, #288]	; (456c <udp_input+0x150>)
    444a:	4628      	mov	r0, r5
	} else {
		pbuf_free(p);
	}
end:
	PERF_STOP("udp_input");
}
    444c:	b005      	add	sp, #20
    444e:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
		pbuf_free(p);
    4452:	4718      	bx	r3
	broadcast = ip_addr_isbroadcast(&current_iphdr_dest, inp);
    4454:	f8df b128 	ldr.w	fp, [pc, #296]	; 4580 <udp_input+0x164>
    4458:	4b45      	ldr	r3, [pc, #276]	; (4570 <udp_input+0x154>)
    445a:	f8db 0000 	ldr.w	r0, [fp]
	udphdr = (struct udp_hdr *)p->payload;
    445e:	f8d5 8004 	ldr.w	r8, [r5, #4]
	broadcast = ip_addr_isbroadcast(&current_iphdr_dest, inp);
    4462:	4651      	mov	r1, sl
    4464:	4798      	blx	r3
	src  = ntohs(udphdr->src);
    4466:	4b43      	ldr	r3, [pc, #268]	; (4574 <udp_input+0x158>)
	broadcast = ip_addr_isbroadcast(&current_iphdr_dest, inp);
    4468:	4606      	mov	r6, r0
	src  = ntohs(udphdr->src);
    446a:	f8b8 0000 	ldrh.w	r0, [r8]
    446e:	4798      	blx	r3
	dest = ntohs(udphdr->dest);
    4470:	4b40      	ldr	r3, [pc, #256]	; (4574 <udp_input+0x158>)
	src  = ntohs(udphdr->src);
    4472:	4607      	mov	r7, r0
	dest = ntohs(udphdr->dest);
    4474:	f8b8 0002 	ldrh.w	r0, [r8, #2]
    4478:	4798      	blx	r3
		for (pcb = udp_pcbs; pcb != NULL; pcb = pcb->next) {
    447a:	4b3f      	ldr	r3, [pc, #252]	; (4578 <udp_input+0x15c>)
				if ((!broadcast && ip_addr_isany(&pcb->local_ip)) || ip_addr_cmp(&(pcb->local_ip), &current_iphdr_dest)
    447c:	f8db 1000 	ldr.w	r1, [fp]
		for (pcb = udp_pcbs; pcb != NULL; pcb = pcb->next) {
    4480:	f8d3 e000 	ldr.w	lr, [r3]
			    && (ip_addr_isany(&pcb->remote_ip) || ip_addr_cmp(&(pcb->remote_ip), &current_iphdr_src))) {
    4484:	4b3d      	ldr	r3, [pc, #244]	; (457c <udp_input+0x160>)
	dest = ntohs(udphdr->dest);
    4486:	9003      	str	r0, [sp, #12]
			    && (ip_addr_isany(&pcb->remote_ip) || ip_addr_cmp(&(pcb->remote_ip), &current_iphdr_src))) {
    4488:	f8d3 c000 	ldr.w	ip, [r3]
		prev        = NULL;
    448c:	46a3      	mov	fp, r4
		for (pcb = udp_pcbs; pcb != NULL; pcb = pcb->next) {
    448e:	4673      	mov	r3, lr
    4490:	bb3b      	cbnz	r3, 44e2 <udp_input+0xc6>
	if (pcb != NULL || ip_addr_cmp(&inp->ip_addr, &current_iphdr_dest)) {
    4492:	b91c      	cbnz	r4, 449c <udp_input+0x80>
    4494:	f8da 3004 	ldr.w	r3, [sl, #4]
    4498:	4299      	cmp	r1, r3
    449a:	d1d5      	bne.n	4448 <udp_input+0x2c>
			if (udphdr->chksum != 0) {
    449c:	f8b8 3006 	ldrh.w	r3, [r8, #6]
    44a0:	b153      	cbz	r3, 44b8 <udp_input+0x9c>
				if (inet_chksum_pseudo(p, ip_current_src_addr(), ip_current_dest_addr(), IP_PROTO_UDP, p->tot_len)
    44a2:	892b      	ldrh	r3, [r5, #8]
    44a4:	9300      	str	r3, [sp, #0]
    44a6:	4a36      	ldr	r2, [pc, #216]	; (4580 <udp_input+0x164>)
    44a8:	4934      	ldr	r1, [pc, #208]	; (457c <udp_input+0x160>)
    44aa:	f8df 80dc 	ldr.w	r8, [pc, #220]	; 4588 <udp_input+0x16c>
    44ae:	2311      	movs	r3, #17
    44b0:	4628      	mov	r0, r5
    44b2:	47c0      	blx	r8
    44b4:	2800      	cmp	r0, #0
    44b6:	d1c7      	bne.n	4448 <udp_input+0x2c>
		if (pbuf_header(p, -UDP_HLEN)) {
    44b8:	f8df 80ac 	ldr.w	r8, [pc, #172]	; 4568 <udp_input+0x14c>
    44bc:	f06f 0107 	mvn.w	r1, #7
    44c0:	4628      	mov	r0, r5
    44c2:	47c0      	blx	r8
    44c4:	2800      	cmp	r0, #0
    44c6:	d1bf      	bne.n	4448 <udp_input+0x2c>
		if (pcb != NULL) {
    44c8:	b1bc      	cbz	r4, 44fa <udp_input+0xde>
			if (pcb->recv != NULL) {
    44ca:	69a6      	ldr	r6, [r4, #24]
    44cc:	2e00      	cmp	r6, #0
    44ce:	d0bb      	beq.n	4448 <udp_input+0x2c>
				pcb->recv(pcb->recv_arg, pcb, p, ip_current_src_addr(), src);
    44d0:	9700      	str	r7, [sp, #0]
    44d2:	4b2a      	ldr	r3, [pc, #168]	; (457c <udp_input+0x160>)
    44d4:	69e0      	ldr	r0, [r4, #28]
    44d6:	462a      	mov	r2, r5
    44d8:	4621      	mov	r1, r4
    44da:	47b0      	blx	r6
}
    44dc:	b005      	add	sp, #20
    44de:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
			if (pcb->local_port == dest) {
    44e2:	8a5a      	ldrh	r2, [r3, #18]
    44e4:	9803      	ldr	r0, [sp, #12]
    44e6:	4282      	cmp	r2, r0
    44e8:	d104      	bne.n	44f4 <udp_input+0xd8>
				if ((!broadcast && ip_addr_isany(&pcb->local_ip)) || ip_addr_cmp(&(pcb->local_ip), &current_iphdr_dest)
    44ea:	681a      	ldr	r2, [r3, #0]
    44ec:	b9d6      	cbnz	r6, 4524 <udp_input+0x108>
    44ee:	b30a      	cbz	r2, 4534 <udp_input+0x118>
    44f0:	4291      	cmp	r1, r2
    44f2:	d01f      	beq.n	4534 <udp_input+0x118>
		for (pcb = udp_pcbs; pcb != NULL; pcb = pcb->next) {
    44f4:	469b      	mov	fp, r3
    44f6:	68db      	ldr	r3, [r3, #12]
    44f8:	e7ca      	b.n	4490 <udp_input+0x74>
			if (!broadcast && !ip_addr_ismulticast(&current_iphdr_dest)) {
    44fa:	2e00      	cmp	r6, #0
    44fc:	d1a4      	bne.n	4448 <udp_input+0x2c>
    44fe:	4b20      	ldr	r3, [pc, #128]	; (4580 <udp_input+0x164>)
    4500:	681b      	ldr	r3, [r3, #0]
    4502:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
    4506:	2be0      	cmp	r3, #224	; 0xe0
    4508:	d09e      	beq.n	4448 <udp_input+0x2c>
				pbuf_header(p, (IPH_HL(iphdr) * 4) + UDP_HLEN);
    450a:	f899 1000 	ldrb.w	r1, [r9]
    450e:	f001 010f 	and.w	r1, r1, #15
    4512:	3102      	adds	r1, #2
    4514:	0089      	lsls	r1, r1, #2
    4516:	4628      	mov	r0, r5
    4518:	47c0      	blx	r8
				icmp_dest_unreach(p, ICMP_DUR_PORT);
    451a:	4b1a      	ldr	r3, [pc, #104]	; (4584 <udp_input+0x168>)
    451c:	2103      	movs	r1, #3
    451e:	4628      	mov	r0, r5
    4520:	4798      	blx	r3
    4522:	e791      	b.n	4448 <udp_input+0x2c>
				if ((!broadcast && ip_addr_isany(&pcb->local_ip)) || ip_addr_cmp(&(pcb->local_ip), &current_iphdr_dest)
    4524:	4291      	cmp	r1, r2
    4526:	d005      	beq.n	4534 <udp_input+0x118>
				     && (ip_addr_isany(&pcb->local_ip)
    4528:	b122      	cbz	r2, 4534 <udp_input+0x118>
				         || ip_addr_netcmp(&pcb->local_ip, ip_current_dest_addr(), &inp->netmask)))) {
    452a:	f8da 0008 	ldr.w	r0, [sl, #8]
    452e:	404a      	eors	r2, r1
    4530:	4202      	tst	r2, r0
    4532:	d1df      	bne.n	44f4 <udp_input+0xd8>
					if ((uncon_pcb == NULL) && ((pcb->flags & UDP_FLAGS_CONNECTED) == 0)) {
    4534:	b924      	cbnz	r4, 4540 <udp_input+0x124>
    4536:	7c1a      	ldrb	r2, [r3, #16]
    4538:	f012 0f04 	tst.w	r2, #4
    453c:	bf08      	it	eq
    453e:	461c      	moveq	r4, r3
			if ((local_match != 0) && (pcb->remote_port == src)
    4540:	8a9a      	ldrh	r2, [r3, #20]
    4542:	42ba      	cmp	r2, r7
    4544:	d1d6      	bne.n	44f4 <udp_input+0xd8>
			    && (ip_addr_isany(&pcb->remote_ip) || ip_addr_cmp(&(pcb->remote_ip), &current_iphdr_src))) {
    4546:	685a      	ldr	r2, [r3, #4]
    4548:	b10a      	cbz	r2, 454e <udp_input+0x132>
    454a:	4562      	cmp	r2, ip
    454c:	d1d2      	bne.n	44f4 <udp_input+0xd8>
				if (prev != NULL) {
    454e:	f1bb 0f00 	cmp.w	fp, #0
    4552:	d006      	beq.n	4562 <udp_input+0x146>
					prev->next = pcb->next;
    4554:	68da      	ldr	r2, [r3, #12]
    4556:	f8cb 200c 	str.w	r2, [fp, #12]
					udp_pcbs   = pcb;
    455a:	4a07      	ldr	r2, [pc, #28]	; (4578 <udp_input+0x15c>)
					pcb->next  = udp_pcbs;
    455c:	f8c3 e00c 	str.w	lr, [r3, #12]
					udp_pcbs   = pcb;
    4560:	6013      	str	r3, [r2, #0]
    4562:	461c      	mov	r4, r3
    4564:	e79a      	b.n	449c <udp_input+0x80>
    4566:	bf00      	nop
    4568:	00003029 	.word	0x00003029
    456c:	00003081 	.word	0x00003081
    4570:	00007aaf 	.word	0x00007aaf
    4574:	00000d6b 	.word	0x00000d6b
    4578:	2000a510 	.word	0x2000a510
    457c:	200110b4 	.word	0x200110b4
    4580:	200110b0 	.word	0x200110b0
    4584:	00000d4d 	.word	0x00000d4d
    4588:	00007419 	.word	0x00007419

0000458c <udp_bind>:
 * another UDP PCB.
 *
 * @see udp_disconnect()
 */
err_t udp_bind(struct udp_pcb *pcb, ip_addr_t *ipaddr, u16_t port)
{
    458c:	b5f0      	push	{r4, r5, r6, r7, lr}
	ip_addr_debug_print(UDP_DEBUG, ipaddr);
	LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE, (", port = %" U16_F ")\n", port));

	rebind = 0;
	/* Check for double bind and rebind of the same pcb */
	for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
    458e:	4f1f      	ldr	r7, [pc, #124]	; (460c <udp_bind+0x80>)
    4590:	683d      	ldr	r5, [r7, #0]
	rebind = 0;
    4592:	2300      	movs	r3, #0
	for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
    4594:	462c      	mov	r4, r5
    4596:	b9c4      	cbnz	r4, 45ca <udp_bind+0x3e>
				return ERR_USE;
			}
		}
	}

	ip_addr_set(&pcb->local_ip, ipaddr);
    4598:	b101      	cbz	r1, 459c <udp_bind+0x10>
    459a:	6809      	ldr	r1, [r1, #0]
    459c:	6001      	str	r1, [r0, #0]

	/* no port specified? */
	if (port == 0) {
    459e:	b972      	cbnz	r2, 45be <udp_bind+0x32>
    45a0:	4e1b      	ldr	r6, [pc, #108]	; (4610 <udp_bind+0x84>)
    45a2:	8832      	ldrh	r2, [r6, #0]
    45a4:	f44f 4180 	mov.w	r1, #16384	; 0x4000
	if (udp_port++ == UDP_LOCAL_PORT_RANGE_END) {
    45a8:	f64f 7cff 	movw	ip, #65535	; 0xffff
    45ac:	4562      	cmp	r2, ip
    45ae:	bf1a      	itte	ne
    45b0:	3201      	addne	r2, #1
    45b2:	b292      	uxthne	r2, r2
		udp_port = UDP_LOCAL_PORT_RANGE_START;
    45b4:	f44f 4240 	moveq.w	r2, #49152	; 0xc000
	for (pcb = udp_pcbs; pcb != NULL; pcb = pcb->next) {
    45b8:	462c      	mov	r4, r5
    45ba:	b9dc      	cbnz	r4, 45f4 <udp_bind+0x68>
    45bc:	8032      	strh	r2, [r6, #0]
			/* no more ports available in local range */
			LWIP_DEBUGF(UDP_DEBUG, ("udp_bind: out of free UDP ports\n"));
			return ERR_USE;
		}
	}
	pcb->local_port = port;
    45be:	8242      	strh	r2, [r0, #18]
	snmp_insert_udpidx_tree(pcb);
	/* pcb not active yet? */
	if (rebind == 0) {
    45c0:	b90b      	cbnz	r3, 45c6 <udp_bind+0x3a>
		/* place the PCB on the active list if not already there */
		pcb->next = udp_pcbs;
    45c2:	60c5      	str	r5, [r0, #12]
		udp_pcbs  = pcb;
    45c4:	6038      	str	r0, [r7, #0]
	             ip4_addr1_16(&pcb->local_ip),
	             ip4_addr2_16(&pcb->local_ip),
	             ip4_addr3_16(&pcb->local_ip),
	             ip4_addr4_16(&pcb->local_ip),
	             pcb->local_port));
	return ERR_OK;
    45c6:	2000      	movs	r0, #0
    45c8:	e010      	b.n	45ec <udp_bind+0x60>
		if (pcb == ipcb) {
    45ca:	4284      	cmp	r4, r0
    45cc:	d00f      	beq.n	45ee <udp_bind+0x62>
			if ((ipcb->local_port == port) &&
    45ce:	8a66      	ldrh	r6, [r4, #18]
    45d0:	4296      	cmp	r6, r2
    45d2:	d10d      	bne.n	45f0 <udp_bind+0x64>
			    (ip_addr_isany(&(ipcb->local_ip)) || ip_addr_isany(ipaddr) || ip_addr_cmp(&(ipcb->local_ip), ipaddr))) {
    45d4:	f8d4 c000 	ldr.w	ip, [r4]
    45d8:	f1bc 0f00 	cmp.w	ip, #0
    45dc:	d004      	beq.n	45e8 <udp_bind+0x5c>
    45de:	b119      	cbz	r1, 45e8 <udp_bind+0x5c>
    45e0:	680e      	ldr	r6, [r1, #0]
    45e2:	b10e      	cbz	r6, 45e8 <udp_bind+0x5c>
    45e4:	45b4      	cmp	ip, r6
    45e6:	d103      	bne.n	45f0 <udp_bind+0x64>
				return ERR_USE;
    45e8:	f06f 0007 	mvn.w	r0, #7
}
    45ec:	bdf0      	pop	{r4, r5, r6, r7, pc}
			rebind = 1;
    45ee:	2301      	movs	r3, #1
	for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
    45f0:	68e4      	ldr	r4, [r4, #12]
    45f2:	e7d0      	b.n	4596 <udp_bind+0xa>
		if (pcb->local_port == udp_port) {
    45f4:	f8b4 e012 	ldrh.w	lr, [r4, #18]
    45f8:	4596      	cmp	lr, r2
    45fa:	d105      	bne.n	4608 <udp_bind+0x7c>
			if (++n > (UDP_LOCAL_PORT_RANGE_END - UDP_LOCAL_PORT_RANGE_START)) {
    45fc:	3901      	subs	r1, #1
    45fe:	b289      	uxth	r1, r1
    4600:	2900      	cmp	r1, #0
    4602:	d1d3      	bne.n	45ac <udp_bind+0x20>
    4604:	8032      	strh	r2, [r6, #0]
    4606:	e7ef      	b.n	45e8 <udp_bind+0x5c>
	for (pcb = udp_pcbs; pcb != NULL; pcb = pcb->next) {
    4608:	68e4      	ldr	r4, [r4, #12]
    460a:	e7d6      	b.n	45ba <udp_bind+0x2e>
    460c:	2000a510 	.word	0x2000a510
    4610:	20000004 	.word	0x20000004

00004614 <udp_sendto_if>:
{
    4614:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    4618:	4690      	mov	r8, r2
    461a:	b087      	sub	sp, #28
	if (pcb->local_port == 0) {
    461c:	8a42      	ldrh	r2, [r0, #18]
{
    461e:	f8dd 9040 	ldr.w	r9, [sp, #64]	; 0x40
    4622:	4606      	mov	r6, r0
    4624:	460f      	mov	r7, r1
    4626:	469a      	mov	sl, r3
	if (pcb->local_port == 0) {
    4628:	2a00      	cmp	r2, #0
    462a:	d042      	beq.n	46b2 <udp_sendto_if+0x9e>
	if (pbuf_header(p, UDP_HLEN)) {
    462c:	4b35      	ldr	r3, [pc, #212]	; (4704 <udp_sendto_if+0xf0>)
    462e:	2108      	movs	r1, #8
    4630:	4638      	mov	r0, r7
    4632:	4798      	blx	r3
    4634:	2800      	cmp	r0, #0
    4636:	d146      	bne.n	46c6 <udp_sendto_if+0xb2>
    4638:	463c      	mov	r4, r7
	udphdr->src  = htons(pcb->local_port);
    463a:	f8df b0e0 	ldr.w	fp, [pc, #224]	; 471c <udp_sendto_if+0x108>
    463e:	8a70      	ldrh	r0, [r6, #18]
	udphdr       = (struct udp_hdr *)q->payload;
    4640:	6865      	ldr	r5, [r4, #4]
	udphdr->src  = htons(pcb->local_port);
    4642:	47d8      	blx	fp
    4644:	8028      	strh	r0, [r5, #0]
	udphdr->dest = htons(dst_port);
    4646:	4650      	mov	r0, sl
    4648:	47d8      	blx	fp
	if (ip_addr_isany(&pcb->local_ip)) {
    464a:	6832      	ldr	r2, [r6, #0]
	udphdr->dest = htons(dst_port);
    464c:	8068      	strh	r0, [r5, #2]
	udphdr->chksum = 0x0000;
    464e:	2300      	movs	r3, #0
    4650:	71ab      	strb	r3, [r5, #6]
    4652:	71eb      	strb	r3, [r5, #7]
	if (ip_addr_isany(&pcb->local_ip)) {
    4654:	465b      	mov	r3, fp
    4656:	2a00      	cmp	r2, #0
    4658:	d143      	bne.n	46e2 <udp_sendto_if+0xce>
		src_ip = &(netif->ip_addr);
    465a:	f109 0104 	add.w	r1, r9, #4
		udphdr->len = htons(q->tot_len);
    465e:	8920      	ldrh	r0, [r4, #8]
    4660:	9105      	str	r1, [sp, #20]
    4662:	4798      	blx	r3
    4664:	80a8      	strh	r0, [r5, #4]
		if ((pcb->flags & UDP_FLAGS_NOCHKSUM) == 0) {
    4666:	7c33      	ldrb	r3, [r6, #16]
    4668:	9905      	ldr	r1, [sp, #20]
    466a:	f013 0f01 	tst.w	r3, #1
    466e:	d10e      	bne.n	468e <udp_sendto_if+0x7a>
				udpchksum = inet_chksum_pseudo(q, src_ip, dst_ip, IP_PROTO_UDP, q->tot_len);
    4670:	8923      	ldrh	r3, [r4, #8]
    4672:	9300      	str	r3, [sp, #0]
    4674:	f8df a0a8 	ldr.w	sl, [pc, #168]	; 4720 <udp_sendto_if+0x10c>
    4678:	2311      	movs	r3, #17
    467a:	4642      	mov	r2, r8
    467c:	4620      	mov	r0, r4
    467e:	47d0      	blx	sl
				udpchksum = 0xffff;
    4680:	f64f 73ff 	movw	r3, #65535	; 0xffff
    4684:	2800      	cmp	r0, #0
    4686:	bf18      	it	ne
    4688:	4603      	movne	r3, r0
			udphdr->chksum = udpchksum;
    468a:	9905      	ldr	r1, [sp, #20]
    468c:	80eb      	strh	r3, [r5, #6]
		err = ip_output_if(q, src_ip, dst_ip, pcb->ttl, pcb->tos, IP_PROTO_UDP, netif);
    468e:	2311      	movs	r3, #17
    4690:	9301      	str	r3, [sp, #4]
    4692:	7a73      	ldrb	r3, [r6, #9]
    4694:	4d1c      	ldr	r5, [pc, #112]	; (4708 <udp_sendto_if+0xf4>)
    4696:	9300      	str	r3, [sp, #0]
    4698:	f8cd 9008 	str.w	r9, [sp, #8]
    469c:	7ab3      	ldrb	r3, [r6, #10]
    469e:	4642      	mov	r2, r8
    46a0:	4620      	mov	r0, r4
    46a2:	47a8      	blx	r5
	if (q != p) {
    46a4:	42bc      	cmp	r4, r7
		err = ip_output_if(q, src_ip, dst_ip, pcb->ttl, pcb->tos, IP_PROTO_UDP, netif);
    46a6:	4605      	mov	r5, r0
	if (q != p) {
    46a8:	d009      	beq.n	46be <udp_sendto_if+0xaa>
		pbuf_free(q);
    46aa:	4b18      	ldr	r3, [pc, #96]	; (470c <udp_sendto_if+0xf8>)
    46ac:	4620      	mov	r0, r4
    46ae:	4798      	blx	r3
		q = NULL;
    46b0:	e005      	b.n	46be <udp_sendto_if+0xaa>
		err = udp_bind(pcb, &pcb->local_ip, pcb->local_port);
    46b2:	4b17      	ldr	r3, [pc, #92]	; (4710 <udp_sendto_if+0xfc>)
    46b4:	4601      	mov	r1, r0
    46b6:	4798      	blx	r3
		if (err != ERR_OK) {
    46b8:	4605      	mov	r5, r0
    46ba:	2800      	cmp	r0, #0
    46bc:	d0b6      	beq.n	462c <udp_sendto_if+0x18>
}
    46be:	4628      	mov	r0, r5
    46c0:	b007      	add	sp, #28
    46c2:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		q = pbuf_alloc(PBUF_IP, UDP_HLEN, PBUF_RAM);
    46c6:	4b13      	ldr	r3, [pc, #76]	; (4714 <udp_sendto_if+0x100>)
    46c8:	2200      	movs	r2, #0
    46ca:	2108      	movs	r1, #8
    46cc:	2001      	movs	r0, #1
    46ce:	4798      	blx	r3
		if (q == NULL) {
    46d0:	4604      	mov	r4, r0
    46d2:	b1a0      	cbz	r0, 46fe <udp_sendto_if+0xea>
		if (p->tot_len != 0) {
    46d4:	893b      	ldrh	r3, [r7, #8]
    46d6:	2b00      	cmp	r3, #0
    46d8:	d0af      	beq.n	463a <udp_sendto_if+0x26>
			pbuf_chain(q, p);
    46da:	4b0f      	ldr	r3, [pc, #60]	; (4718 <udp_sendto_if+0x104>)
    46dc:	4639      	mov	r1, r7
    46de:	4798      	blx	r3
    46e0:	e7ab      	b.n	463a <udp_sendto_if+0x26>
		if (!ip_addr_cmp(&(pcb->local_ip), &(netif->ip_addr))) {
    46e2:	f8d9 1004 	ldr.w	r1, [r9, #4]
    46e6:	428a      	cmp	r2, r1
    46e8:	d007      	beq.n	46fa <udp_sendto_if+0xe6>
			if (q != p) {
    46ea:	42bc      	cmp	r4, r7
    46ec:	d002      	beq.n	46f4 <udp_sendto_if+0xe0>
				pbuf_free(q);
    46ee:	4b07      	ldr	r3, [pc, #28]	; (470c <udp_sendto_if+0xf8>)
    46f0:	4620      	mov	r0, r4
    46f2:	4798      	blx	r3
			return ERR_VAL;
    46f4:	f06f 0505 	mvn.w	r5, #5
    46f8:	e7e1      	b.n	46be <udp_sendto_if+0xaa>
	if (ip_addr_isany(&pcb->local_ip)) {
    46fa:	4631      	mov	r1, r6
    46fc:	e7af      	b.n	465e <udp_sendto_if+0x4a>
			return ERR_MEM;
    46fe:	f04f 35ff 	mov.w	r5, #4294967295	; 0xffffffff
    4702:	e7dc      	b.n	46be <udp_sendto_if+0xaa>
    4704:	00003029 	.word	0x00003029
    4708:	00005585 	.word	0x00005585
    470c:	00003081 	.word	0x00003081
    4710:	0000458d 	.word	0x0000458d
    4714:	000030d9 	.word	0x000030d9
    4718:	00003275 	.word	0x00003275
    471c:	00000d65 	.word	0x00000d65
    4720:	00007419 	.word	0x00007419

00004724 <udp_sendto>:
{
    4724:	b530      	push	{r4, r5, lr}
    4726:	b087      	sub	sp, #28
    4728:	4605      	mov	r5, r0
	netif = ip_route(dst_ip);
    472a:	4c09      	ldr	r4, [pc, #36]	; (4750 <udp_sendto+0x2c>)
    472c:	9203      	str	r2, [sp, #12]
    472e:	4610      	mov	r0, r2
{
    4730:	e9cd 3104 	strd	r3, r1, [sp, #16]
	netif = ip_route(dst_ip);
    4734:	47a0      	blx	r4
	if (netif == NULL) {
    4736:	b140      	cbz	r0, 474a <udp_sendto+0x26>
	return udp_sendto_if(pcb, p, dst_ip, dst_port, netif);
    4738:	9000      	str	r0, [sp, #0]
    473a:	e9dd 2303 	ldrd	r2, r3, [sp, #12]
    473e:	9905      	ldr	r1, [sp, #20]
    4740:	4c04      	ldr	r4, [pc, #16]	; (4754 <udp_sendto+0x30>)
    4742:	4628      	mov	r0, r5
    4744:	47a0      	blx	r4
}
    4746:	b007      	add	sp, #28
    4748:	bd30      	pop	{r4, r5, pc}
		return ERR_RTE;
    474a:	f06f 0003 	mvn.w	r0, #3
    474e:	e7fa      	b.n	4746 <udp_sendto+0x22>
    4750:	000053ed 	.word	0x000053ed
    4754:	00004615 	.word	0x00004615

00004758 <udp_send>:
{
    4758:	b410      	push	{r4}
	return udp_sendto(pcb, p, &pcb->remote_ip, pcb->remote_port);
    475a:	4c04      	ldr	r4, [pc, #16]	; (476c <udp_send+0x14>)
    475c:	8a83      	ldrh	r3, [r0, #20]
{
    475e:	4602      	mov	r2, r0
	return udp_sendto(pcb, p, &pcb->remote_ip, pcb->remote_port);
    4760:	46a4      	mov	ip, r4
    4762:	3204      	adds	r2, #4
}
    4764:	f85d 4b04 	ldr.w	r4, [sp], #4
	return udp_sendto(pcb, p, &pcb->remote_ip, pcb->remote_port);
    4768:	4760      	bx	ip
    476a:	bf00      	nop
    476c:	00004725 	.word	0x00004725

00004770 <udp_recv>:
 */
void udp_recv(struct udp_pcb *pcb, udp_recv_fn recv, void *recv_arg)
{
	/* remember recv() callback and user data */
	pcb->recv     = recv;
	pcb->recv_arg = recv_arg;
    4770:	e9c0 1206 	strd	r1, r2, [r0, #24]
}
    4774:	4770      	bx	lr
	...

00004778 <udp_remove>:
{
	struct udp_pcb *pcb2;

	snmp_delete_udpidx_tree(pcb);
	/* pcb to be removed is first in list? */
	if (udp_pcbs == pcb) {
    4778:	4a09      	ldr	r2, [pc, #36]	; (47a0 <udp_remove+0x28>)
    477a:	6813      	ldr	r3, [r2, #0]
    477c:	4283      	cmp	r3, r0
{
    477e:	4601      	mov	r1, r0
	if (udp_pcbs == pcb) {
    4780:	d10b      	bne.n	479a <udp_remove+0x22>
		/* make list start at 2nd pcb */
		udp_pcbs = udp_pcbs->next;
    4782:	68c3      	ldr	r3, [r0, #12]
    4784:	6013      	str	r3, [r2, #0]
				/* remove pcb from list */
				pcb2->next = pcb->next;
			}
		}
	}
	memp_free(MEMP_UDP_PCB, pcb);
    4786:	4b07      	ldr	r3, [pc, #28]	; (47a4 <udp_remove+0x2c>)
    4788:	2000      	movs	r0, #0
    478a:	4718      	bx	r3
			if (pcb2->next != NULL && pcb2->next == pcb) {
    478c:	68da      	ldr	r2, [r3, #12]
    478e:	b11a      	cbz	r2, 4798 <udp_remove+0x20>
    4790:	428a      	cmp	r2, r1
				pcb2->next = pcb->next;
    4792:	bf04      	itt	eq
    4794:	68ca      	ldreq	r2, [r1, #12]
    4796:	60da      	streq	r2, [r3, #12]
		for (pcb2 = udp_pcbs; pcb2 != NULL; pcb2 = pcb2->next) {
    4798:	68db      	ldr	r3, [r3, #12]
    479a:	2b00      	cmp	r3, #0
    479c:	d1f6      	bne.n	478c <udp_remove+0x14>
    479e:	e7f2      	b.n	4786 <udp_remove+0xe>
    47a0:	2000a510 	.word	0x2000a510
    47a4:	00004b49 	.word	0x00004b49

000047a8 <udp_new>:
 * could not be allocated.
 *
 * @see udp_remove()
 */
struct udp_pcb *udp_new(void)
{
    47a8:	b510      	push	{r4, lr}
	struct udp_pcb *pcb;
	pcb = (struct udp_pcb *)memp_malloc(MEMP_UDP_PCB);
    47aa:	4b06      	ldr	r3, [pc, #24]	; (47c4 <udp_new+0x1c>)
    47ac:	2000      	movs	r0, #0
    47ae:	4798      	blx	r3
	/* could allocate UDP PCB? */
	if (pcb != NULL) {
    47b0:	4604      	mov	r4, r0
    47b2:	b128      	cbz	r0, 47c0 <udp_new+0x18>
		/* UDP Lite: by initializing to all zeroes, chksum_len is set to 0
		 * which means checksum is generated over the whole datagram per default
		 * (recommended as default by RFC 3828). */
		/* initialize PCB to all zeroes */
		memset(pcb, 0, sizeof(struct udp_pcb));
    47b4:	4b04      	ldr	r3, [pc, #16]	; (47c8 <udp_new+0x20>)
    47b6:	2220      	movs	r2, #32
    47b8:	2100      	movs	r1, #0
    47ba:	4798      	blx	r3
		pcb->ttl = UDP_TTL;
    47bc:	23ff      	movs	r3, #255	; 0xff
    47be:	72a3      	strb	r3, [r4, #10]
	}
	return pcb;
}
    47c0:	4620      	mov	r0, r4
    47c2:	bd10      	pop	{r4, pc}
    47c4:	00004b2d 	.word	0x00004b2d
    47c8:	000094c1 	.word	0x000094c1

000047cc <_osc32kctrl_init_sources>:
}

static inline hri_osc32kctrl_osculp32k_reg_t hri_osc32kctrl_read_OSCULP32K_CALIB_bf(const void *const hw)
{
	uint32_t tmp;
	tmp = ((Osc32kctrl *)hw)->OSCULP32K.reg;
    47cc:	4b03      	ldr	r3, [pc, #12]	; (47dc <_osc32kctrl_init_sources+0x10>)
    47ce:	69da      	ldr	r2, [r3, #28]
	calib = hri_osc32kctrl_read_OSCULP32K_CALIB_bf(hw);
	hri_osc32kctrl_write_OSCULP32K_reg(hw,
#if CONF_OSCULP32K_CALIB_ENABLE == 1
	                                   OSC32KCTRL_OSCULP32K_CALIB(CONF_OSCULP32K_CALIB)
#else
	                                   OSC32KCTRL_OSCULP32K_CALIB(calib)
    47d0:	f402 527c 	and.w	r2, r2, #16128	; 0x3f00
}

static inline void hri_osc32kctrl_write_OSCULP32K_reg(const void *const hw, hri_osc32kctrl_osculp32k_reg_t data)
{
	OSC32KCTRL_CRITICAL_SECTION_ENTER();
	((Osc32kctrl *)hw)->OSCULP32K.reg = data;
    47d4:	61da      	str	r2, [r3, #28]
	((Osc32kctrl *)hw)->RTCCTRL.reg = data;
    47d6:	2201      	movs	r2, #1
    47d8:	741a      	strb	r2, [r3, #16]
#endif
#endif

	hri_osc32kctrl_write_RTCCTRL_reg(hw, OSC32KCTRL_RTCCTRL_RTCSEL(CONF_RTCCTRL));
	(void)calib;
}
    47da:	4770      	bx	lr
    47dc:	40001400 	.word	0x40001400

000047e0 <Dummy_Handler>:
/**
 * \brief Default interrupt handler for unused IRQs.
 */
void Dummy_Handler(void)
{
	while (1) {
    47e0:	e7fe      	b.n	47e0 <Dummy_Handler>
	...

000047e4 <Reset_Handler>:
	if (pSrc != pDest) {
    47e4:	4918      	ldr	r1, [pc, #96]	; (4848 <Reset_Handler+0x64>)
    47e6:	4819      	ldr	r0, [pc, #100]	; (484c <Reset_Handler+0x68>)
    47e8:	4281      	cmp	r1, r0
{
    47ea:	b510      	push	{r4, lr}
	if (pSrc != pDest) {
    47ec:	d00a      	beq.n	4804 <Reset_Handler+0x20>
			*pDest++ = *pSrc++;
    47ee:	4b18      	ldr	r3, [pc, #96]	; (4850 <Reset_Handler+0x6c>)
    47f0:	1cda      	adds	r2, r3, #3
    47f2:	1a12      	subs	r2, r2, r0
    47f4:	f022 0203 	bic.w	r2, r2, #3
    47f8:	1ec4      	subs	r4, r0, #3
    47fa:	42a3      	cmp	r3, r4
    47fc:	bf38      	it	cc
    47fe:	2200      	movcc	r2, #0
    4800:	4b14      	ldr	r3, [pc, #80]	; (4854 <Reset_Handler+0x70>)
    4802:	4798      	blx	r3
		*pDest++ = 0;
    4804:	4b14      	ldr	r3, [pc, #80]	; (4858 <Reset_Handler+0x74>)
    4806:	4815      	ldr	r0, [pc, #84]	; (485c <Reset_Handler+0x78>)
    4808:	1cda      	adds	r2, r3, #3
    480a:	1a12      	subs	r2, r2, r0
    480c:	1ec1      	subs	r1, r0, #3
    480e:	f022 0203 	bic.w	r2, r2, #3
    4812:	4299      	cmp	r1, r3
    4814:	bf88      	it	hi
    4816:	2200      	movhi	r2, #0
    4818:	4b11      	ldr	r3, [pc, #68]	; (4860 <Reset_Handler+0x7c>)
    481a:	2100      	movs	r1, #0
    481c:	4798      	blx	r3
	SCB->VTOR = ((uint32_t)pSrc & SCB_VTOR_TBLOFF_Msk);
    481e:	4a11      	ldr	r2, [pc, #68]	; (4864 <Reset_Handler+0x80>)
    4820:	4b11      	ldr	r3, [pc, #68]	; (4868 <Reset_Handler+0x84>)
    4822:	f022 027f 	bic.w	r2, r2, #127	; 0x7f
    4826:	609a      	str	r2, [r3, #8]
	SCB->CPACR |= (0xFu << 20);
    4828:	f8d3 2088 	ldr.w	r2, [r3, #136]	; 0x88
    482c:	f442 0270 	orr.w	r2, r2, #15728640	; 0xf00000
    4830:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88
  \details Acts as a special kind of Data Memory Barrier.
           It completes when all explicit memory accesses before this instruction complete.
 */
__STATIC_FORCEINLINE void __DSB(void)
{
  __ASM volatile ("dsb 0xF":::"memory");
    4834:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
    4838:	f3bf 8f6f 	isb	sy
	__libc_init_array();
    483c:	4b0b      	ldr	r3, [pc, #44]	; (486c <Reset_Handler+0x88>)
    483e:	4798      	blx	r3
	main();
    4840:	4b0b      	ldr	r3, [pc, #44]	; (4870 <Reset_Handler+0x8c>)
    4842:	4798      	blx	r3
	while (1)
    4844:	e7fe      	b.n	4844 <Reset_Handler+0x60>
    4846:	bf00      	nop
    4848:	0000abac 	.word	0x0000abac
    484c:	20000000 	.word	0x20000000
    4850:	2000007c 	.word	0x2000007c
    4854:	000094a5 	.word	0x000094a5
    4858:	200163ac 	.word	0x200163ac
    485c:	20000080 	.word	0x20000080
    4860:	000094c1 	.word	0x000094c1
    4864:	00000000 	.word	0x00000000
    4868:	e000ed00 	.word	0xe000ed00
    486c:	0000943d 	.word	0x0000943d
    4870:	00004ab9 	.word	0x00004ab9

00004874 <_gpio_set_pin_function>:

/**
 * \brief Set gpio pin function
 */
static inline void _gpio_set_pin_function(const uint32_t gpio, const uint32_t function)
{
    4874:	b530      	push	{r4, r5, lr}
	uint8_t port = GPIO_PORT(gpio);
	uint8_t pin  = GPIO_PIN(gpio);

	if (function == GPIO_PIN_FUNCTION_OFF) {
    4876:	1c4b      	adds	r3, r1, #1
	uint8_t pin  = GPIO_PIN(gpio);
    4878:	b2c5      	uxtb	r5, r0
    487a:	4b18      	ldr	r3, [pc, #96]	; (48dc <_gpio_set_pin_function+0x68>)
    487c:	f000 041f 	and.w	r4, r0, #31
	uint8_t port = GPIO_PORT(gpio);
    4880:	ea4f 1050 	mov.w	r0, r0, lsr #5
    4884:	ea4f 10c0 	mov.w	r0, r0, lsl #7
static inline void hri_port_write_PINCFG_PMUXEN_bit(const void *const hw, uint8_t submodule_index, uint8_t index,
                                                    bool value)
{
	uint8_t tmp;
	PORT_CRITICAL_SECTION_ENTER();
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
    4888:	4403      	add	r3, r0
	if (function == GPIO_PIN_FUNCTION_OFF) {
    488a:	d107      	bne.n	489c <_gpio_set_pin_function+0x28>
    488c:	4423      	add	r3, r4
    488e:	f893 2040 	ldrb.w	r2, [r3, #64]	; 0x40
	tmp &= ~PORT_PINCFG_PMUXEN;
    4892:	f002 02fe 	and.w	r2, r2, #254	; 0xfe
	tmp |= value << PORT_PINCFG_PMUXEN_Pos;
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
    4896:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
		} else {
			// Even numbered pin
			hri_port_write_PMUX_PMUXE_bf(PORT, port, pin >> 1, function & 0xffff);
		}
	}
}
    489a:	bd30      	pop	{r4, r5, pc}
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
    489c:	1918      	adds	r0, r3, r4
    489e:	eb03 0354 	add.w	r3, r3, r4, lsr #1
    48a2:	f890 2040 	ldrb.w	r2, [r0, #64]	; 0x40
	tmp &= ~PORT_PINCFG_PMUXEN;
    48a6:	f002 02fe 	and.w	r2, r2, #254	; 0xfe
	tmp |= value << PORT_PINCFG_PMUXEN_Pos;
    48aa:	f042 0201 	orr.w	r2, r2, #1
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
    48ae:	f880 2040 	strb.w	r2, [r0, #64]	; 0x40
	tmp = ((Port *)hw)->Group[submodule_index].PMUX[index].reg;
    48b2:	f893 2030 	ldrb.w	r2, [r3, #48]	; 0x30
		if (pin & 1) {
    48b6:	f015 0f01 	tst.w	r5, #1
			hri_port_write_PMUX_PMUXO_bf(PORT, port, pin >> 1, function & 0xffff);
    48ba:	b2c9      	uxtb	r1, r1
	tmp &= ~PORT_PMUX_PMUXO_Msk;
    48bc:	bf19      	ittee	ne
    48be:	f002 020f 	andne.w	r2, r2, #15
	tmp |= PORT_PMUX_PMUXO(data);
    48c2:	ea42 1101 	orrne.w	r1, r2, r1, lsl #4
	tmp |= PORT_PMUX_PMUXE(data);
    48c6:	f001 010f 	andeq.w	r1, r1, #15
	tmp &= ~PORT_PMUX_PMUXE_Msk;
    48ca:	f002 02f0 	andeq.w	r2, r2, #240	; 0xf0
	tmp |= PORT_PMUX_PMUXO(data);
    48ce:	bf14      	ite	ne
    48d0:	b2c9      	uxtbne	r1, r1
	tmp |= PORT_PMUX_PMUXE(data);
    48d2:	4311      	orreq	r1, r2
	((Port *)hw)->Group[submodule_index].PMUX[index].reg = tmp;
    48d4:	f883 1030 	strb.w	r1, [r3, #48]	; 0x30
}
    48d8:	e7df      	b.n	489a <_gpio_set_pin_function+0x26>
    48da:	bf00      	nop
    48dc:	41008000 	.word	0x41008000

000048e0 <TARGET_IO_PORT_init>:
struct usart_sync_descriptor TARGET_IO;

struct mac_async_descriptor COMMUNICATION_IO;

void TARGET_IO_PORT_init(void)
{
    48e0:	b510      	push	{r4, lr}
 *                      found in the header files for the device
 *
 */
static inline void gpio_set_pin_function(const uint32_t pin, uint32_t function)
{
	_gpio_set_pin_function(pin, function);
    48e2:	4c05      	ldr	r4, [pc, #20]	; (48f8 <TARGET_IO_PORT_init+0x18>)
    48e4:	4905      	ldr	r1, [pc, #20]	; (48fc <TARGET_IO_PORT_init+0x1c>)
    48e6:	2039      	movs	r0, #57	; 0x39
    48e8:	47a0      	blx	r4
    48ea:	4623      	mov	r3, r4
    48ec:	4904      	ldr	r1, [pc, #16]	; (4900 <TARGET_IO_PORT_init+0x20>)

	gpio_set_pin_function(PB25, PINMUX_PB25D_SERCOM2_PAD0);

	gpio_set_pin_function(PB24, PINMUX_PB24D_SERCOM2_PAD1);
}
    48ee:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    48f2:	2038      	movs	r0, #56	; 0x38
    48f4:	4718      	bx	r3
    48f6:	bf00      	nop
    48f8:	00004875 	.word	0x00004875
    48fc:	00390003 	.word	0x00390003
    4900:	00380003 	.word	0x00380003

00004904 <TARGET_IO_CLOCK_init>:
}

static inline void hri_gclk_write_PCHCTRL_reg(const void *const hw, uint8_t index, hri_gclk_pchctrl_reg_t data)
{
	GCLK_CRITICAL_SECTION_ENTER();
	((Gclk *)hw)->PCHCTRL[index].reg = data;
    4904:	4b06      	ldr	r3, [pc, #24]	; (4920 <TARGET_IO_CLOCK_init+0x1c>)
    4906:	2240      	movs	r2, #64	; 0x40
    4908:	f8c3 20dc 	str.w	r2, [r3, #220]	; 0xdc
    490c:	2243      	movs	r2, #67	; 0x43
    490e:	f8c3 208c 	str.w	r2, [r3, #140]	; 0x8c
}

static inline void hri_mclk_set_APBBMASK_SERCOM2_bit(const void *const hw)
{
	MCLK_CRITICAL_SECTION_ENTER();
	((Mclk *)hw)->APBBMASK.reg |= MCLK_APBBMASK_SERCOM2;
    4912:	4a04      	ldr	r2, [pc, #16]	; (4924 <TARGET_IO_CLOCK_init+0x20>)
    4914:	6993      	ldr	r3, [r2, #24]
    4916:	f443 7300 	orr.w	r3, r3, #512	; 0x200
    491a:	6193      	str	r3, [r2, #24]
{
	hri_gclk_write_PCHCTRL_reg(GCLK, SERCOM2_GCLK_ID_CORE, CONF_GCLK_SERCOM2_CORE_SRC | (1 << GCLK_PCHCTRL_CHEN_Pos));
	hri_gclk_write_PCHCTRL_reg(GCLK, SERCOM2_GCLK_ID_SLOW, CONF_GCLK_SERCOM2_SLOW_SRC | (1 << GCLK_PCHCTRL_CHEN_Pos));

	hri_mclk_set_APBBMASK_SERCOM2_bit(MCLK);
}
    491c:	4770      	bx	lr
    491e:	bf00      	nop
    4920:	40001c00 	.word	0x40001c00
    4924:	40000800 	.word	0x40000800

00004928 <TARGET_IO_init>:

void TARGET_IO_init(void)
{
    4928:	b510      	push	{r4, lr}
	TARGET_IO_CLOCK_init();
    492a:	4b05      	ldr	r3, [pc, #20]	; (4940 <TARGET_IO_init+0x18>)
	usart_sync_init(&TARGET_IO, SERCOM2, (void *)NULL);
    492c:	4905      	ldr	r1, [pc, #20]	; (4944 <TARGET_IO_init+0x1c>)
    492e:	4806      	ldr	r0, [pc, #24]	; (4948 <TARGET_IO_init+0x20>)
	TARGET_IO_CLOCK_init();
    4930:	4798      	blx	r3
	usart_sync_init(&TARGET_IO, SERCOM2, (void *)NULL);
    4932:	4b06      	ldr	r3, [pc, #24]	; (494c <TARGET_IO_init+0x24>)
    4934:	2200      	movs	r2, #0
    4936:	4798      	blx	r3
	TARGET_IO_PORT_init();
}
    4938:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	TARGET_IO_PORT_init();
    493c:	4b04      	ldr	r3, [pc, #16]	; (4950 <TARGET_IO_init+0x28>)
    493e:	4718      	bx	r3
    4940:	00004905 	.word	0x00004905
    4944:	41012000 	.word	0x41012000
    4948:	2000a514 	.word	0x2000a514
    494c:	00000f09 	.word	0x00000f09
    4950:	000048e1 	.word	0x000048e1

00004954 <COMMUNICATION_IO_PORT_init>:

void COMMUNICATION_IO_PORT_init(void)
{
    4954:	b510      	push	{r4, lr}
    4956:	4911      	ldr	r1, [pc, #68]	; (499c <COMMUNICATION_IO_PORT_init+0x48>)
    4958:	4c11      	ldr	r4, [pc, #68]	; (49a0 <COMMUNICATION_IO_PORT_init+0x4c>)
    495a:	204b      	movs	r0, #75	; 0x4b
    495c:	47a0      	blx	r4
    495e:	4911      	ldr	r1, [pc, #68]	; (49a4 <COMMUNICATION_IO_PORT_init+0x50>)
    4960:	204c      	movs	r0, #76	; 0x4c
    4962:	47a0      	blx	r4
    4964:	4910      	ldr	r1, [pc, #64]	; (49a8 <COMMUNICATION_IO_PORT_init+0x54>)
    4966:	200d      	movs	r0, #13
    4968:	47a0      	blx	r4
    496a:	4910      	ldr	r1, [pc, #64]	; (49ac <COMMUNICATION_IO_PORT_init+0x58>)
    496c:	200c      	movs	r0, #12
    496e:	47a0      	blx	r4
    4970:	490f      	ldr	r1, [pc, #60]	; (49b0 <COMMUNICATION_IO_PORT_init+0x5c>)
    4972:	2054      	movs	r0, #84	; 0x54
    4974:	47a0      	blx	r4
    4976:	490f      	ldr	r1, [pc, #60]	; (49b4 <COMMUNICATION_IO_PORT_init+0x60>)
    4978:	200f      	movs	r0, #15
    497a:	47a0      	blx	r4
    497c:	490e      	ldr	r1, [pc, #56]	; (49b8 <COMMUNICATION_IO_PORT_init+0x64>)
    497e:	2012      	movs	r0, #18
    4980:	47a0      	blx	r4
    4982:	490e      	ldr	r1, [pc, #56]	; (49bc <COMMUNICATION_IO_PORT_init+0x68>)
    4984:	2013      	movs	r0, #19
    4986:	47a0      	blx	r4
    4988:	490d      	ldr	r1, [pc, #52]	; (49c0 <COMMUNICATION_IO_PORT_init+0x6c>)
    498a:	200e      	movs	r0, #14
    498c:	47a0      	blx	r4
    498e:	4623      	mov	r3, r4
    4990:	490c      	ldr	r1, [pc, #48]	; (49c4 <COMMUNICATION_IO_PORT_init+0x70>)
	gpio_set_pin_function(PA19, PINMUX_PA19L_GMAC_GTX1);

	gpio_set_pin_function(PA14, PINMUX_PA14L_GMAC_GTXCK);

	gpio_set_pin_function(PA17, PINMUX_PA17L_GMAC_GTXEN);
}
    4992:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    4996:	2011      	movs	r0, #17
    4998:	4718      	bx	r3
    499a:	bf00      	nop
    499c:	004b000b 	.word	0x004b000b
    49a0:	00004875 	.word	0x00004875
    49a4:	004c000b 	.word	0x004c000b
    49a8:	000d000b 	.word	0x000d000b
    49ac:	000c000b 	.word	0x000c000b
    49b0:	0054000b 	.word	0x0054000b
    49b4:	000f000b 	.word	0x000f000b
    49b8:	0012000b 	.word	0x0012000b
    49bc:	0013000b 	.word	0x0013000b
    49c0:	000e000b 	.word	0x000e000b
    49c4:	0011000b 	.word	0x0011000b

000049c8 <COMMUNICATION_IO_CLOCK_init>:
	((Mclk *)hw)->AHBMASK.reg |= MCLK_AHBMASK_GMAC;
    49c8:	4b04      	ldr	r3, [pc, #16]	; (49dc <COMMUNICATION_IO_CLOCK_init+0x14>)
    49ca:	691a      	ldr	r2, [r3, #16]
    49cc:	f442 4280 	orr.w	r2, r2, #16384	; 0x4000
    49d0:	611a      	str	r2, [r3, #16]
}

static inline void hri_mclk_set_APBCMASK_GMAC_bit(const void *const hw)
{
	MCLK_CRITICAL_SECTION_ENTER();
	((Mclk *)hw)->APBCMASK.reg |= MCLK_APBCMASK_GMAC;
    49d2:	69da      	ldr	r2, [r3, #28]
    49d4:	f042 0204 	orr.w	r2, r2, #4
    49d8:	61da      	str	r2, [r3, #28]

void COMMUNICATION_IO_CLOCK_init(void)
{
	hri_mclk_set_AHBMASK_GMAC_bit(MCLK);
	hri_mclk_set_APBCMASK_GMAC_bit(MCLK);
}
    49da:	4770      	bx	lr
    49dc:	40000800 	.word	0x40000800

000049e0 <COMMUNICATION_IO_init>:

void COMMUNICATION_IO_init(void)
{
    49e0:	b510      	push	{r4, lr}
	COMMUNICATION_IO_CLOCK_init();
    49e2:	4b05      	ldr	r3, [pc, #20]	; (49f8 <COMMUNICATION_IO_init+0x18>)
	mac_async_init(&COMMUNICATION_IO, GMAC);
    49e4:	4905      	ldr	r1, [pc, #20]	; (49fc <COMMUNICATION_IO_init+0x1c>)
    49e6:	4806      	ldr	r0, [pc, #24]	; (4a00 <COMMUNICATION_IO_init+0x20>)
	COMMUNICATION_IO_CLOCK_init();
    49e8:	4798      	blx	r3
	mac_async_init(&COMMUNICATION_IO, GMAC);
    49ea:	4b06      	ldr	r3, [pc, #24]	; (4a04 <COMMUNICATION_IO_init+0x24>)
    49ec:	4798      	blx	r3
	COMMUNICATION_IO_PORT_init();
}
    49ee:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	COMMUNICATION_IO_PORT_init();
    49f2:	4b05      	ldr	r3, [pc, #20]	; (4a08 <COMMUNICATION_IO_init+0x28>)
    49f4:	4718      	bx	r3
    49f6:	bf00      	nop
    49f8:	000049c9 	.word	0x000049c9
    49fc:	42000800 	.word	0x42000800
    4a00:	2000a520 	.word	0x2000a520
    4a04:	00004b6d 	.word	0x00004b6d
    4a08:	00004955 	.word	0x00004955

00004a0c <system_init>:
	mac_async_enable(&COMMUNICATION_IO);
	mac_async_write(&COMMUNICATION_IO, (uint8_t *)"Hello World!", 12);
}

void system_init(void)
{
    4a0c:	b510      	push	{r4, lr}
 * Currently the following initialization functions are supported:
 *  - System clock initialization
 */
static inline void init_mcu(void)
{
	_init_chip();
    4a0e:	4b0d      	ldr	r3, [pc, #52]	; (4a44 <system_init+0x38>)
    4a10:	4798      	blx	r3
	((Port *)hw)->Group[submodule_index].OUTSET.reg = mask;
    4a12:	4b0d      	ldr	r3, [pc, #52]	; (4a48 <system_init+0x3c>)
    4a14:	f44f 2280 	mov.w	r2, #262144	; 0x40000
    4a18:	f8c3 2118 	str.w	r2, [r3, #280]	; 0x118
	((Port *)hw)->Group[submodule_index].DIRSET.reg = mask;
    4a1c:	f8c3 2108 	str.w	r2, [r3, #264]	; 0x108

static inline void hri_port_write_WRCONFIG_reg(const void *const hw, uint8_t submodule_index,
                                               hri_port_wrconfig_reg_t data)
{
	PORT_CRITICAL_SECTION_ENTER();
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
    4a20:	f04f 4280 	mov.w	r2, #1073741824	; 0x40000000
    4a24:	f8c3 2128 	str.w	r2, [r3, #296]	; 0x128
    4a28:	4a08      	ldr	r2, [pc, #32]	; (4a4c <system_init+0x40>)
    4a2a:	f8c3 2128 	str.w	r2, [r3, #296]	; 0x128
    4a2e:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
    4a32:	4b07      	ldr	r3, [pc, #28]	; (4a50 <system_init+0x44>)
    4a34:	2052      	movs	r0, #82	; 0x52
    4a36:	4798      	blx	r3
	// Set pin direction to output
	gpio_set_pin_direction(LED_0, GPIO_DIRECTION_OUT);

	gpio_set_pin_function(LED_0, GPIO_PIN_FUNCTION_OFF);

	TARGET_IO_init();
    4a38:	4b06      	ldr	r3, [pc, #24]	; (4a54 <system_init+0x48>)
    4a3a:	4798      	blx	r3

	COMMUNICATION_IO_init();
}
    4a3c:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	COMMUNICATION_IO_init();
    4a40:	4b05      	ldr	r3, [pc, #20]	; (4a58 <system_init+0x4c>)
    4a42:	4718      	bx	r3
    4a44:	000069d5 	.word	0x000069d5
    4a48:	41008000 	.word	0x41008000
    4a4c:	c0000004 	.word	0xc0000004
    4a50:	00004875 	.word	0x00004875
    4a54:	00004929 	.word	0x00004929
    4a58:	000049e1 	.word	0x000049e1

00004a5c <print_ipaddress>:

/* define to avoid compilation warning */
// #define LWIP_TIMEVAL_PRIVATE 0

void print_ipaddress(void)
{
    4a5c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	static char tmp_buff[16];
	printf("IP_ADDR    : %s\r\n",
    4a60:	4f0e      	ldr	r7, [pc, #56]	; (4a9c <print_ipaddress+0x40>)
    4a62:	4e0f      	ldr	r6, [pc, #60]	; (4aa0 <print_ipaddress+0x44>)
    4a64:	4d0f      	ldr	r5, [pc, #60]	; (4aa4 <print_ipaddress+0x48>)
    4a66:	4c10      	ldr	r4, [pc, #64]	; (4aa8 <print_ipaddress+0x4c>)
    4a68:	2210      	movs	r2, #16
    4a6a:	4639      	mov	r1, r7
    4a6c:	4630      	mov	r0, r6
    4a6e:	47a8      	blx	r5
    4a70:	4601      	mov	r1, r0
    4a72:	480e      	ldr	r0, [pc, #56]	; (4aac <print_ipaddress+0x50>)
    4a74:	47a0      	blx	r4
	       ipaddr_ntoa_r((const ip_addr_t *)&(TCPIP_STACK_INTERFACE_0_desc.ip_addr), tmp_buff, 16));
	printf("NET_MASK   : %s\r\n",
    4a76:	2210      	movs	r2, #16
    4a78:	4639      	mov	r1, r7
    4a7a:	1d30      	adds	r0, r6, #4
    4a7c:	47a8      	blx	r5
    4a7e:	4601      	mov	r1, r0
    4a80:	480b      	ldr	r0, [pc, #44]	; (4ab0 <print_ipaddress+0x54>)
    4a82:	47a0      	blx	r4
	       ipaddr_ntoa_r((const ip_addr_t *)&(TCPIP_STACK_INTERFACE_0_desc.netmask), tmp_buff, 16));
	printf("GATEWAY_IP : %s\r\n", ipaddr_ntoa_r((const ip_addr_t *)&(TCPIP_STACK_INTERFACE_0_desc.gw), tmp_buff, 16));
    4a84:	4639      	mov	r1, r7
    4a86:	f106 0008 	add.w	r0, r6, #8
    4a8a:	2210      	movs	r2, #16
    4a8c:	47a8      	blx	r5
    4a8e:	4623      	mov	r3, r4
    4a90:	4601      	mov	r1, r0
}
    4a92:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
	printf("GATEWAY_IP : %s\r\n", ipaddr_ntoa_r((const ip_addr_t *)&(TCPIP_STACK_INTERFACE_0_desc.gw), tmp_buff, 16));
    4a96:	4807      	ldr	r0, [pc, #28]	; (4ab4 <print_ipaddress+0x58>)
    4a98:	4718      	bx	r3
    4a9a:	bf00      	nop
    4a9c:	2000a53c 	.word	0x2000a53c
    4aa0:	20014910 	.word	0x20014910
    4aa4:	00007bf1 	.word	0x00007bf1
    4aa8:	000094d1 	.word	0x000094d1
    4aac:	0000a77b 	.word	0x0000a77b
    4ab0:	0000a78d 	.word	0x0000a78d
    4ab4:	0000a79f 	.word	0x0000a79f

00004ab8 <main>:
 * #define LWIP_TIMEVAL_PRIVATE		0
 *
 */

int main(void)
{
    4ab8:	b508      	push	{r3, lr}
	/* Initializes MCU, drivers and middleware */
	atmel_start_init();
    4aba:	4b04      	ldr	r3, [pc, #16]	; (4acc <main+0x14>)
    4abc:	4798      	blx	r3

	/*Handles Socket API */
	printf("\r\nSocket API implementation\r\n");
    4abe:	4b04      	ldr	r3, [pc, #16]	; (4ad0 <main+0x18>)
    4ac0:	4804      	ldr	r0, [pc, #16]	; (4ad4 <main+0x1c>)
    4ac2:	4798      	blx	r3
	basic_socket();
    4ac4:	4b04      	ldr	r3, [pc, #16]	; (4ad8 <main+0x20>)
    4ac6:	4798      	blx	r3

	while (1)
    4ac8:	e7fe      	b.n	4ac8 <main+0x10>
    4aca:	bf00      	nop
    4acc:	00004d1d 	.word	0x00004d1d
    4ad0:	000095dd 	.word	0x000095dd
    4ad4:	0000a7b1 	.word	0x0000a7b1
    4ad8:	0000761d 	.word	0x0000761d

00004adc <memp_init>:
 * Initialize this module.
 *
 * Carves out memp_memory into linked lists for each pool-type.
 */
void memp_init(void)
{
    4adc:	b5f0      	push	{r4, r5, r6, r7, lr}
		MEMP_STATS_AVAIL(err, i, 0);
		MEMP_STATS_AVAIL(avail, i, memp_num[i]);
	}

#if !MEMP_SEPARATE_POOLS
	memp = (struct memp *)LWIP_MEM_ALIGN(memp_memory);
    4ade:	4b10      	ldr	r3, [pc, #64]	; (4b20 <memp_init+0x44>)
    4ae0:	4c10      	ldr	r4, [pc, #64]	; (4b24 <memp_init+0x48>)
    4ae2:	4911      	ldr	r1, [pc, #68]	; (4b28 <memp_init+0x4c>)
    4ae4:	f023 0303 	bic.w	r3, r3, #3
#endif /* !MEMP_SEPARATE_POOLS */
	/* for every pool: */
	for (i = 0; i < MEMP_MAX; ++i) {
    4ae8:	f104 001a 	add.w	r0, r4, #26
	memp = (struct memp *)LWIP_MEM_ALIGN(memp_memory);
    4aec:	220d      	movs	r2, #13
		memp_tab[i] = NULL;
    4aee:	2600      	movs	r6, #0
    4af0:	f841 6b04 	str.w	r6, [r1], #4
#if MEMP_SEPARATE_POOLS
		memp = (struct memp *)memp_bases[i];
#endif /* MEMP_SEPARATE_POOLS */
		/* create a linked list of memp elements */
		for (j = 0; j < memp_num[i]; ++j) {
    4af4:	f834 cb02 	ldrh.w	ip, [r4], #2
    4af8:	2500      	movs	r5, #0
    4afa:	b2af      	uxth	r7, r5
    4afc:	45bc      	cmp	ip, r7
    4afe:	d805      	bhi.n	4b0c <memp_init+0x30>
	for (i = 0; i < MEMP_MAX; ++i) {
    4b00:	3a01      	subs	r2, #1
    4b02:	b292      	uxth	r2, r2
    4b04:	3002      	adds	r0, #2
    4b06:	2a00      	cmp	r2, #0
    4b08:	d1f2      	bne.n	4af0 <memp_init+0x14>
#if MEMP_OVERFLOW_CHECK
	memp_overflow_init();
	/* check everything a first time to see if it worked */
	memp_overflow_check_all();
#endif /* MEMP_OVERFLOW_CHECK */
}
    4b0a:	bdf0      	pop	{r4, r5, r6, r7, pc}
			memp->next  = memp_tab[i];
    4b0c:	f851 7c04 	ldr.w	r7, [r1, #-4]
    4b10:	601f      	str	r7, [r3, #0]
			memp        = (struct memp *)(void *)((u8_t *)memp + MEMP_SIZE + memp_sizes[i]
    4b12:	8807      	ldrh	r7, [r0, #0]
			memp_tab[i] = memp;
    4b14:	f841 3c04 	str.w	r3, [r1, #-4]
			memp        = (struct memp *)(void *)((u8_t *)memp + MEMP_SIZE + memp_sizes[i]
    4b18:	3501      	adds	r5, #1
    4b1a:	443b      	add	r3, r7
		for (j = 0; j < memp_num[i]; ++j) {
    4b1c:	e7ed      	b.n	4afa <memp_init+0x1e>
    4b1e:	bf00      	nop
    4b20:	2000a583 	.word	0x2000a583
    4b24:	0000a7ce 	.word	0x0000a7ce
    4b28:	2000a54c 	.word	0x2000a54c

00004b2c <memp_malloc>:
#endif
{
	struct memp *memp;
	SYS_ARCH_DECL_PROTECT(old_level);

	LWIP_ERROR("memp_malloc: type < MEMP_MAX", (type < MEMP_MAX), return NULL;);
    4b2c:	280c      	cmp	r0, #12
    4b2e:	d900      	bls.n	4b32 <memp_malloc+0x6>
    4b30:	e7fe      	b.n	4b30 <memp_malloc+0x4>
	SYS_ARCH_PROTECT(old_level);
#if MEMP_OVERFLOW_CHECK >= 2
	memp_overflow_check_all();
#endif /* MEMP_OVERFLOW_CHECK >= 2 */

	memp = memp_tab[type];
    4b32:	4a04      	ldr	r2, [pc, #16]	; (4b44 <memp_malloc+0x18>)
    4b34:	f852 3020 	ldr.w	r3, [r2, r0, lsl #2]

	if (memp != NULL) {
    4b38:	b113      	cbz	r3, 4b40 <memp_malloc+0x14>
		memp_tab[type] = memp->next;
    4b3a:	6819      	ldr	r1, [r3, #0]
    4b3c:	f842 1020 	str.w	r1, [r2, r0, lsl #2]
	}

	SYS_ARCH_UNPROTECT(old_level);

	return memp;
}
    4b40:	4618      	mov	r0, r3
    4b42:	4770      	bx	lr
    4b44:	2000a54c 	.word	0x2000a54c

00004b48 <memp_free>:
void memp_free(memp_t type, void *mem)
{
	struct memp *memp;
	SYS_ARCH_DECL_PROTECT(old_level);

	if (mem == NULL) {
    4b48:	b129      	cbz	r1, 4b56 <memp_free+0xe>
#endif /* MEMP_OVERFLOW_CHECK >= 2 */
#endif /* MEMP_OVERFLOW_CHECK */

	MEMP_STATS_DEC(used, type);

	memp->next     = memp_tab[type];
    4b4a:	4b03      	ldr	r3, [pc, #12]	; (4b58 <memp_free+0x10>)
    4b4c:	f853 2020 	ldr.w	r2, [r3, r0, lsl #2]
    4b50:	600a      	str	r2, [r1, #0]
	memp_tab[type] = memp;
    4b52:	f843 1020 	str.w	r1, [r3, r0, lsl #2]
#if MEMP_SANITY_CHECK
	LWIP_ASSERT("memp sanity", memp_sanity());
#endif /* MEMP_SANITY_CHECK */

	SYS_ARCH_UNPROTECT(old_level);
}
    4b56:	4770      	bx	lr
    4b58:	2000a54c 	.word	0x2000a54c

00004b5c <mac_read_cb>:
 */
static void mac_read_cb(struct _mac_async_device *dev)
{
	struct mac_async_descriptor *const descr = CONTAINER_OF(dev, struct mac_async_descriptor, dev);

	if (descr->cb.receive) {
    4b5c:	6943      	ldr	r3, [r0, #20]
    4b5e:	b103      	cbz	r3, 4b62 <mac_read_cb+0x6>
		descr->cb.receive(descr);
    4b60:	4718      	bx	r3
	}
}
    4b62:	4770      	bx	lr

00004b64 <mac_write_cb>:
 */
static void mac_write_cb(struct _mac_async_device *dev)
{
	struct mac_async_descriptor *const descr = CONTAINER_OF(dev, struct mac_async_descriptor, dev);

	if (descr->cb.transmit) {
    4b64:	6983      	ldr	r3, [r0, #24]
    4b66:	b103      	cbz	r3, 4b6a <mac_write_cb+0x6>
		descr->cb.transmit(descr);
    4b68:	4718      	bx	r3
	}
}
    4b6a:	4770      	bx	lr

00004b6c <mac_async_init>:
{
    4b6c:	b570      	push	{r4, r5, r6, lr}
    4b6e:	460d      	mov	r5, r1
	ASSERT(descr && hw);
    4b70:	4604      	mov	r4, r0
    4b72:	b110      	cbz	r0, 4b7a <mac_async_init+0xe>
    4b74:	1e08      	subs	r0, r1, #0
    4b76:	bf18      	it	ne
    4b78:	2001      	movne	r0, #1
    4b7a:	4905      	ldr	r1, [pc, #20]	; (4b90 <mac_async_init+0x24>)
    4b7c:	4b05      	ldr	r3, [pc, #20]	; (4b94 <mac_async_init+0x28>)
    4b7e:	2231      	movs	r2, #49	; 0x31
    4b80:	4798      	blx	r3
	return _mac_async_init(&descr->dev, hw);
    4b82:	4629      	mov	r1, r5
    4b84:	4620      	mov	r0, r4
    4b86:	4b04      	ldr	r3, [pc, #16]	; (4b98 <mac_async_init+0x2c>)
}
    4b88:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	return _mac_async_init(&descr->dev, hw);
    4b8c:	4718      	bx	r3
    4b8e:	bf00      	nop
    4b90:	0000a802 	.word	0x0000a802
    4b94:	00007aa9 	.word	0x00007aa9
    4b98:	000076b1 	.word	0x000076b1

00004b9c <mac_async_enable>:
{
    4b9c:	b510      	push	{r4, lr}
	ASSERT(descr);
    4b9e:	4604      	mov	r4, r0
    4ba0:	3800      	subs	r0, #0
    4ba2:	4b05      	ldr	r3, [pc, #20]	; (4bb8 <mac_async_enable+0x1c>)
    4ba4:	4905      	ldr	r1, [pc, #20]	; (4bbc <mac_async_enable+0x20>)
    4ba6:	bf18      	it	ne
    4ba8:	2001      	movne	r0, #1
    4baa:	2245      	movs	r2, #69	; 0x45
    4bac:	4798      	blx	r3
	return _mac_async_enable(&descr->dev);
    4bae:	4620      	mov	r0, r4
    4bb0:	4b03      	ldr	r3, [pc, #12]	; (4bc0 <mac_async_enable+0x24>)
}
    4bb2:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	return _mac_async_enable(&descr->dev);
    4bb6:	4718      	bx	r3
    4bb8:	00007aa9 	.word	0x00007aa9
    4bbc:	0000a802 	.word	0x0000a802
    4bc0:	00007761 	.word	0x00007761

00004bc4 <mac_async_write>:
{
    4bc4:	b570      	push	{r4, r5, r6, lr}
    4bc6:	460d      	mov	r5, r1
    4bc8:	4616      	mov	r6, r2
	ASSERT(descr && buf && len);
    4bca:	4604      	mov	r4, r0
    4bcc:	b118      	cbz	r0, 4bd6 <mac_async_write+0x12>
    4bce:	b169      	cbz	r1, 4bec <mac_async_write+0x28>
    4bd0:	1e10      	subs	r0, r2, #0
    4bd2:	bf18      	it	ne
    4bd4:	2001      	movne	r0, #1
    4bd6:	4906      	ldr	r1, [pc, #24]	; (4bf0 <mac_async_write+0x2c>)
    4bd8:	4b06      	ldr	r3, [pc, #24]	; (4bf4 <mac_async_write+0x30>)
    4bda:	2257      	movs	r2, #87	; 0x57
    4bdc:	4798      	blx	r3
	return _mac_async_write(&descr->dev, buf, len);
    4bde:	4632      	mov	r2, r6
    4be0:	4629      	mov	r1, r5
    4be2:	4620      	mov	r0, r4
    4be4:	4b04      	ldr	r3, [pc, #16]	; (4bf8 <mac_async_write+0x34>)
}
    4be6:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	return _mac_async_write(&descr->dev, buf, len);
    4bea:	4718      	bx	r3
	ASSERT(descr && buf && len);
    4bec:	4608      	mov	r0, r1
    4bee:	e7f2      	b.n	4bd6 <mac_async_write+0x12>
    4bf0:	0000a802 	.word	0x0000a802
    4bf4:	00007aa9 	.word	0x00007aa9
    4bf8:	00007771 	.word	0x00007771

00004bfc <mac_async_read>:
{
    4bfc:	b570      	push	{r4, r5, r6, lr}
	ASSERT(descr);
    4bfe:	4604      	mov	r4, r0
    4c00:	3800      	subs	r0, #0
{
    4c02:	460d      	mov	r5, r1
    4c04:	4616      	mov	r6, r2
	ASSERT(descr);
    4c06:	4907      	ldr	r1, [pc, #28]	; (4c24 <mac_async_read+0x28>)
    4c08:	4b07      	ldr	r3, [pc, #28]	; (4c28 <mac_async_read+0x2c>)
    4c0a:	f04f 0261 	mov.w	r2, #97	; 0x61
    4c0e:	bf18      	it	ne
    4c10:	2001      	movne	r0, #1
    4c12:	4798      	blx	r3
	return _mac_async_read(&descr->dev, buf, len);
    4c14:	4632      	mov	r2, r6
    4c16:	4629      	mov	r1, r5
    4c18:	4620      	mov	r0, r4
    4c1a:	4b04      	ldr	r3, [pc, #16]	; (4c2c <mac_async_read+0x30>)
}
    4c1c:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	return _mac_async_read(&descr->dev, buf, len);
    4c20:	4718      	bx	r3
    4c22:	bf00      	nop
    4c24:	0000a802 	.word	0x0000a802
    4c28:	00007aa9 	.word	0x00007aa9
    4c2c:	0000786d 	.word	0x0000786d

00004c30 <mac_async_read_len>:
{
    4c30:	b510      	push	{r4, lr}
	ASSERT(descr);
    4c32:	4604      	mov	r4, r0
    4c34:	3800      	subs	r0, #0
    4c36:	4b05      	ldr	r3, [pc, #20]	; (4c4c <mac_async_read_len+0x1c>)
    4c38:	4905      	ldr	r1, [pc, #20]	; (4c50 <mac_async_read_len+0x20>)
    4c3a:	bf18      	it	ne
    4c3c:	2001      	movne	r0, #1
    4c3e:	226b      	movs	r2, #107	; 0x6b
    4c40:	4798      	blx	r3
	return _mac_async_read_len(&descr->dev);
    4c42:	4620      	mov	r0, r4
    4c44:	4b03      	ldr	r3, [pc, #12]	; (4c54 <mac_async_read_len+0x24>)
}
    4c46:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	return _mac_async_read_len(&descr->dev);
    4c4a:	4718      	bx	r3
    4c4c:	00007aa9 	.word	0x00007aa9
    4c50:	0000a802 	.word	0x0000a802
    4c54:	00007955 	.word	0x00007955

00004c58 <mac_async_register_callback>:
{
    4c58:	b570      	push	{r4, r5, r6, lr}
	ASSERT(descr);
    4c5a:	4605      	mov	r5, r0
    4c5c:	3800      	subs	r0, #0
{
    4c5e:	460e      	mov	r6, r1
    4c60:	4614      	mov	r4, r2
	ASSERT(descr);
    4c62:	bf18      	it	ne
    4c64:	2001      	movne	r0, #1
    4c66:	490c      	ldr	r1, [pc, #48]	; (4c98 <mac_async_register_callback+0x40>)
    4c68:	4b0c      	ldr	r3, [pc, #48]	; (4c9c <mac_async_register_callback+0x44>)
    4c6a:	2289      	movs	r2, #137	; 0x89
    4c6c:	4798      	blx	r3
	switch (type) {
    4c6e:	b126      	cbz	r6, 4c7a <mac_async_register_callback+0x22>
    4c70:	2e01      	cmp	r6, #1
    4c72:	d00d      	beq.n	4c90 <mac_async_register_callback+0x38>
}
    4c74:	f06f 000c 	mvn.w	r0, #12
    4c78:	bd70      	pop	{r4, r5, r6, pc}
		return _mac_async_register_callback(&descr->dev, type, (func == NULL) ? NULL : (FUNC_PTR)mac_read_cb);
    4c7a:	4a09      	ldr	r2, [pc, #36]	; (4ca0 <mac_async_register_callback+0x48>)
		descr->cb.receive = (mac_async_cb_t)func;
    4c7c:	616c      	str	r4, [r5, #20]
		return _mac_async_register_callback(&descr->dev, type, (func == NULL) ? NULL : (FUNC_PTR)mac_read_cb);
    4c7e:	2c00      	cmp	r4, #0
		return _mac_async_register_callback(&descr->dev, type, (func == NULL) ? NULL : (FUNC_PTR)mac_write_cb);
    4c80:	bf08      	it	eq
    4c82:	4622      	moveq	r2, r4
    4c84:	4631      	mov	r1, r6
    4c86:	4628      	mov	r0, r5
    4c88:	4b06      	ldr	r3, [pc, #24]	; (4ca4 <mac_async_register_callback+0x4c>)
}
    4c8a:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		return _mac_async_register_callback(&descr->dev, type, (func == NULL) ? NULL : (FUNC_PTR)mac_write_cb);
    4c8e:	4718      	bx	r3
    4c90:	4a05      	ldr	r2, [pc, #20]	; (4ca8 <mac_async_register_callback+0x50>)
		descr->cb.transmit = (mac_async_cb_t)func;
    4c92:	61ac      	str	r4, [r5, #24]
		return _mac_async_register_callback(&descr->dev, type, (func == NULL) ? NULL : (FUNC_PTR)mac_write_cb);
    4c94:	2c00      	cmp	r4, #0
    4c96:	e7f3      	b.n	4c80 <mac_async_register_callback+0x28>
    4c98:	0000a802 	.word	0x0000a802
    4c9c:	00007aa9 	.word	0x00007aa9
    4ca0:	00004b5d 	.word	0x00004b5d
    4ca4:	000079a9 	.word	0x000079a9
    4ca8:	00004b65 	.word	0x00004b65

00004cac <mac_async_set_filter>:
{
    4cac:	b570      	push	{r4, r5, r6, lr}
    4cae:	460e      	mov	r6, r1
    4cb0:	4615      	mov	r5, r2
	ASSERT(descr && filter);
    4cb2:	4604      	mov	r4, r0
    4cb4:	b110      	cbz	r0, 4cbc <mac_async_set_filter+0x10>
    4cb6:	1e10      	subs	r0, r2, #0
    4cb8:	bf18      	it	ne
    4cba:	2001      	movne	r0, #1
    4cbc:	4905      	ldr	r1, [pc, #20]	; (4cd4 <mac_async_set_filter+0x28>)
    4cbe:	4b06      	ldr	r3, [pc, #24]	; (4cd8 <mac_async_set_filter+0x2c>)
    4cc0:	229b      	movs	r2, #155	; 0x9b
    4cc2:	4798      	blx	r3
	return _mac_async_set_filter(&descr->dev, index, filter);
    4cc4:	462a      	mov	r2, r5
    4cc6:	4631      	mov	r1, r6
    4cc8:	4620      	mov	r0, r4
    4cca:	4b04      	ldr	r3, [pc, #16]	; (4cdc <mac_async_set_filter+0x30>)
}
    4ccc:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	return _mac_async_set_filter(&descr->dev, index, filter);
    4cd0:	4718      	bx	r3
    4cd2:	bf00      	nop
    4cd4:	0000a802 	.word	0x0000a802
    4cd8:	00007aa9 	.word	0x00007aa9
    4cdc:	000079d1 	.word	0x000079d1

00004ce0 <mac_async_read_phy_reg>:
{
    4ce0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    4ce4:	460e      	mov	r6, r1
    4ce6:	4617      	mov	r7, r2
    4ce8:	461d      	mov	r5, r3
	ASSERT(descr && val);
    4cea:	4604      	mov	r4, r0
    4cec:	b110      	cbz	r0, 4cf4 <mac_async_read_phy_reg+0x14>
    4cee:	1e18      	subs	r0, r3, #0
    4cf0:	bf18      	it	ne
    4cf2:	2001      	movne	r0, #1
    4cf4:	4906      	ldr	r1, [pc, #24]	; (4d10 <mac_async_read_phy_reg+0x30>)
    4cf6:	4b07      	ldr	r3, [pc, #28]	; (4d14 <mac_async_read_phy_reg+0x34>)
    4cf8:	22b8      	movs	r2, #184	; 0xb8
    4cfa:	4798      	blx	r3
	return _mac_async_read_phy_reg(&descr->dev, addr, reg, val);
    4cfc:	4620      	mov	r0, r4
    4cfe:	4c06      	ldr	r4, [pc, #24]	; (4d18 <mac_async_read_phy_reg+0x38>)
    4d00:	462b      	mov	r3, r5
    4d02:	463a      	mov	r2, r7
    4d04:	4631      	mov	r1, r6
    4d06:	46a4      	mov	ip, r4
}
    4d08:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
	return _mac_async_read_phy_reg(&descr->dev, addr, reg, val);
    4d0c:	4760      	bx	ip
    4d0e:	bf00      	nop
    4d10:	0000a802 	.word	0x0000a802
    4d14:	00007aa9 	.word	0x00007aa9
    4d18:	00007a11 	.word	0x00007a11

00004d1c <atmel_start_init>:

/**
 * Initializes MCU, drivers and middleware in the project
 **/
void atmel_start_init(void)
{
    4d1c:	b510      	push	{r4, lr}
	system_init();
    4d1e:	4b04      	ldr	r3, [pc, #16]	; (4d30 <atmel_start_init+0x14>)
    4d20:	4798      	blx	r3
	ethernet_phys_init();
    4d22:	4b04      	ldr	r3, [pc, #16]	; (4d34 <atmel_start_init+0x18>)
    4d24:	4798      	blx	r3
	stdio_redirect_init();
}
    4d26:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	stdio_redirect_init();
    4d2a:	4b03      	ldr	r3, [pc, #12]	; (4d38 <atmel_start_init+0x1c>)
    4d2c:	4718      	bx	r3
    4d2e:	bf00      	nop
    4d30:	00004a0d 	.word	0x00004a0d
    4d34:	00000e2d 	.word	0x00000e2d
    4d38:	00000fb5 	.word	0x00000fb5

00004d3c <etharp_free_entry>:

#endif /* ARP_QUEUEING */

/** Clean up ARP table entries */
static void etharp_free_entry(int i)
{
    4d3c:	b570      	push	{r4, r5, r6, lr}
	/* remove from SNMP ARP index tree */
	snmp_delete_arpidx_tree(arp_table[i].netif, &arp_table[i].ipaddr);
	/* and empty packet queue */
	if (arp_table[i].q != NULL) {
    4d3e:	2614      	movs	r6, #20
    4d40:	4c07      	ldr	r4, [pc, #28]	; (4d60 <etharp_free_entry+0x24>)
    4d42:	4346      	muls	r6, r0
{
    4d44:	4605      	mov	r5, r0
	if (arp_table[i].q != NULL) {
    4d46:	59a0      	ldr	r0, [r4, r6]
    4d48:	b118      	cbz	r0, 4d52 <etharp_free_entry+0x16>
		/* remove all queued packets */
		LWIP_DEBUGF(
		    ETHARP_DEBUG,
		    ("etharp_free_entry: freeing entry %" U16_F ", packet queue %p.\n", (u16_t)i, (void *)(arp_table[i].q)));
		free_etharp_q(arp_table[i].q);
    4d4a:	4b06      	ldr	r3, [pc, #24]	; (4d64 <etharp_free_entry+0x28>)
    4d4c:	4798      	blx	r3
		arp_table[i].q = NULL;
    4d4e:	2300      	movs	r3, #0
    4d50:	51a3      	str	r3, [r4, r6]
	}
	/* recycle entry for re-use */
	arp_table[i].state = ETHARP_STATE_EMPTY;
    4d52:	2014      	movs	r0, #20
    4d54:	fb00 4405 	mla	r4, r0, r5, r4
    4d58:	2300      	movs	r3, #0
    4d5a:	74a3      	strb	r3, [r4, #18]
	arp_table[i].ctime = 0;
	arp_table[i].netif = NULL;
	ip_addr_set_zero(&arp_table[i].ipaddr);
	arp_table[i].ethaddr = ethzero;
#endif /* LWIP_DEBUG */
}
    4d5c:	bd70      	pop	{r4, r5, r6, pc}
    4d5e:	bf00      	nop
    4d60:	20010fe4 	.word	0x20010fe4
    4d64:	00003081 	.word	0x00003081

00004d68 <etharp_find_entry>:
 *
 * @return The ARP entry index that matched or is created, ERR_MEM if no
 * entry is found or could be recycled.
 */
static s8_t etharp_find_entry(ip_addr_t *ipaddr, u8_t flags)
{
    4d68:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    4d6c:	2200      	movs	r2, #0
	s8_t old_pending = ARP_TABLE_SIZE, old_stable = ARP_TABLE_SIZE;
	s8_t empty = ARP_TABLE_SIZE;
	u8_t i = 0, age_pending = 0, age_stable = 0;
	/* oldest entry with packets on queue */
	s8_t old_queue = ARP_TABLE_SIZE;
    4d6e:	230a      	movs	r3, #10
{
    4d70:	460e      	mov	r6, r1
    4d72:	4930      	ldr	r1, [pc, #192]	; (4e34 <etharp_find_entry+0xcc>)
    4d74:	4604      	mov	r4, r0
	/* its age */
	u8_t age_queue = 0;
    4d76:	4692      	mov	sl, r2
	u8_t i = 0, age_pending = 0, age_stable = 0;
    4d78:	4691      	mov	r9, r2
    4d7a:	4690      	mov	r8, r2
	s8_t empty = ARP_TABLE_SIZE;
    4d7c:	4618      	mov	r0, r3
	s8_t old_pending = ARP_TABLE_SIZE, old_stable = ARP_TABLE_SIZE;
    4d7e:	469e      	mov	lr, r3
    4d80:	469c      	mov	ip, r3
	 */

	for (i = 0; i < ARP_TABLE_SIZE; ++i) {
		u8_t state = arp_table[i].state;
		/* no empty entry found yet and now we do find one? */
		if ((empty == ARP_TABLE_SIZE) && (state == ETHARP_STATE_EMPTY)) {
    4d82:	280a      	cmp	r0, #10
		u8_t state = arp_table[i].state;
    4d84:	f891 b012 	ldrb.w	fp, [r1, #18]
		if ((empty == ARP_TABLE_SIZE) && (state == ETHARP_STATE_EMPTY)) {
    4d88:	d11c      	bne.n	4dc4 <etharp_find_entry+0x5c>
    4d8a:	f1bb 0f00 	cmp.w	fp, #0
    4d8e:	d11c      	bne.n	4dca <etharp_find_entry+0x62>
			LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_find_entry: found empty entry %" U16_F "\n", (u16_t)i));
			/* remember first empty entry */
			empty = i;
    4d90:	b250      	sxtb	r0, r2
	for (i = 0; i < ARP_TABLE_SIZE; ++i) {
    4d92:	3201      	adds	r2, #1
    4d94:	2a0a      	cmp	r2, #10
    4d96:	f101 0114 	add.w	r1, r1, #20
    4d9a:	d1f2      	bne.n	4d82 <etharp_find_entry+0x1a>
		}
	}
	/* { we have no match } => try to create a new entry */

	/* don't create new entry, only search? */
	if (((flags & ETHARP_FLAG_FIND_ONLY) != 0) ||
    4d9c:	2e01      	cmp	r6, #1
    4d9e:	d146      	bne.n	4e2e <etharp_find_entry+0xc6>
    4da0:	280a      	cmp	r0, #10
    4da2:	d031      	beq.n	4e08 <etharp_find_entry+0xa0>
	 * { ETHARP_FLAG_TRY_HARD is set at this point }
	 */

	/* 1) empty entry available? */
	if (empty < ARP_TABLE_SIZE) {
		i = empty;
    4da4:	b2c6      	uxtb	r6, r0

	LWIP_ASSERT("i < ARP_TABLE_SIZE", i < ARP_TABLE_SIZE);
	LWIP_ASSERT("arp_table[i].state == ETHARP_STATE_EMPTY", arp_table[i].state == ETHARP_STATE_EMPTY);

	/* IP address given? */
	if (ipaddr != NULL) {
    4da6:	b12c      	cbz	r4, 4db4 <etharp_find_entry+0x4c>
		/* set IP address */
		ip_addr_copy(arp_table[i].ipaddr, *ipaddr);
    4da8:	4922      	ldr	r1, [pc, #136]	; (4e34 <etharp_find_entry+0xcc>)
    4daa:	6822      	ldr	r2, [r4, #0]
    4dac:	2314      	movs	r3, #20
    4dae:	fb03 1306 	mla	r3, r3, r6, r1
    4db2:	605a      	str	r2, [r3, #4]
	}
	arp_table[i].ctime = 0;
    4db4:	4a1f      	ldr	r2, [pc, #124]	; (4e34 <etharp_find_entry+0xcc>)
    4db6:	2314      	movs	r3, #20
    4db8:	fb03 2506 	mla	r5, r3, r6, r2
    4dbc:	2300      	movs	r3, #0
    4dbe:	74eb      	strb	r3, [r5, #19]
	return (err_t)i;
    4dc0:	b270      	sxtb	r0, r6
    4dc2:	e008      	b.n	4dd6 <etharp_find_entry+0x6e>
		} else if (state != ETHARP_STATE_EMPTY) {
    4dc4:	f1bb 0f00 	cmp.w	fp, #0
    4dc8:	d0e3      	beq.n	4d92 <etharp_find_entry+0x2a>
			if (ipaddr && ip_addr_cmp(ipaddr, &arp_table[i].ipaddr)) {
    4dca:	b134      	cbz	r4, 4dda <etharp_find_entry+0x72>
    4dcc:	6827      	ldr	r7, [r4, #0]
    4dce:	684d      	ldr	r5, [r1, #4]
    4dd0:	42af      	cmp	r7, r5
    4dd2:	d102      	bne.n	4dda <etharp_find_entry+0x72>
				return i;
    4dd4:	b250      	sxtb	r0, r2
}
    4dd6:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
			if (state == ETHARP_STATE_PENDING) {
    4dda:	f1bb 0f01 	cmp.w	fp, #1
					if (arp_table[i].ctime >= age_queue) {
    4dde:	7ccf      	ldrb	r7, [r1, #19]
			if (state == ETHARP_STATE_PENDING) {
    4de0:	d10c      	bne.n	4dfc <etharp_find_entry+0x94>
				if (arp_table[i].q != NULL) {
    4de2:	680d      	ldr	r5, [r1, #0]
    4de4:	b125      	cbz	r5, 4df0 <etharp_find_entry+0x88>
					if (arp_table[i].ctime >= age_queue) {
    4de6:	4557      	cmp	r7, sl
    4de8:	d3d3      	bcc.n	4d92 <etharp_find_entry+0x2a>
						old_queue = i;
    4dea:	b253      	sxtb	r3, r2
    4dec:	46ba      	mov	sl, r7
    4dee:	e7d0      	b.n	4d92 <etharp_find_entry+0x2a>
					if (arp_table[i].ctime >= age_pending) {
    4df0:	4547      	cmp	r7, r8
    4df2:	d3ce      	bcc.n	4d92 <etharp_find_entry+0x2a>
						old_pending = i;
    4df4:	fa4f fc82 	sxtb.w	ip, r2
    4df8:	46b8      	mov	r8, r7
    4dfa:	e7ca      	b.n	4d92 <etharp_find_entry+0x2a>
					if (arp_table[i].ctime >= age_stable) {
    4dfc:	454f      	cmp	r7, r9
						old_stable = i;
    4dfe:	bf24      	itt	cs
    4e00:	fa4f fe82 	sxtbcs.w	lr, r2
    4e04:	46b9      	movcs	r9, r7
    4e06:	e7c4      	b.n	4d92 <etharp_find_entry+0x2a>
		if (old_stable < ARP_TABLE_SIZE) {
    4e08:	f1be 0f0a 	cmp.w	lr, #10
    4e0c:	d005      	beq.n	4e1a <etharp_find_entry+0xb2>
			i = old_stable;
    4e0e:	fa5f f68e 	uxtb.w	r6, lr
		etharp_free_entry(i);
    4e12:	4b09      	ldr	r3, [pc, #36]	; (4e38 <etharp_find_entry+0xd0>)
    4e14:	4630      	mov	r0, r6
    4e16:	4798      	blx	r3
    4e18:	e7c5      	b.n	4da6 <etharp_find_entry+0x3e>
		} else if (old_pending < ARP_TABLE_SIZE) {
    4e1a:	f1bc 0f0a 	cmp.w	ip, #10
    4e1e:	d002      	beq.n	4e26 <etharp_find_entry+0xbe>
			i = old_pending;
    4e20:	fa5f f68c 	uxtb.w	r6, ip
			            ("etharp_find_entry: selecting oldest pending entry %" U16_F " (without queue)\n", (u16_t)i));
    4e24:	e7f5      	b.n	4e12 <etharp_find_entry+0xaa>
		} else if (old_queue < ARP_TABLE_SIZE) {
    4e26:	2b0a      	cmp	r3, #10
    4e28:	d001      	beq.n	4e2e <etharp_find_entry+0xc6>
			i = old_queue;
    4e2a:	b2de      	uxtb	r6, r3
			             (void *)(arp_table[i].q)));
    4e2c:	e7f1      	b.n	4e12 <etharp_find_entry+0xaa>
		return (s8_t)ERR_MEM;
    4e2e:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    4e32:	e7d0      	b.n	4dd6 <etharp_find_entry+0x6e>
    4e34:	20010fe4 	.word	0x20010fe4
    4e38:	00004d3d 	.word	0x00004d3d

00004e3c <etharp_send_ip>:
 * @params src the source MAC address to be copied into the ethernet header
 * @params dst the destination MAC address to be copied into the ethernet header
 * @return ERR_OK if the packet was sent, any other err_t on failure
 */
static err_t etharp_send_ip(struct netif *netif, struct pbuf *p, struct eth_addr *src, struct eth_addr *dst)
{
    4e3c:	b430      	push	{r4, r5}
	struct eth_hdr *ethhdr = (struct eth_hdr *)p->payload;
    4e3e:	684c      	ldr	r4, [r1, #4]

	LWIP_ASSERT("netif->hwaddr_len must be the same as ETHARP_HWADDR_LEN for etharp!",
	            (netif->hwaddr_len == ETHARP_HWADDR_LEN));
	ETHADDR32_COPY(&ethhdr->dest, dst);
    4e40:	681d      	ldr	r5, [r3, #0]
    4e42:	f8c4 5002 	str.w	r5, [r4, #2]
    4e46:	889b      	ldrh	r3, [r3, #4]
    4e48:	80e3      	strh	r3, [r4, #6]
	ETHADDR16_COPY(&ethhdr->src, src);
    4e4a:	6813      	ldr	r3, [r2, #0]
    4e4c:	60a3      	str	r3, [r4, #8]
    4e4e:	8893      	ldrh	r3, [r2, #4]
    4e50:	81a3      	strh	r3, [r4, #12]
	ethhdr->type = PP_HTONS(ETHTYPE_IP);
    4e52:	2308      	movs	r3, #8
    4e54:	73a3      	strb	r3, [r4, #14]
    4e56:	2300      	movs	r3, #0
    4e58:	73e3      	strb	r3, [r4, #15]
	LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_send_ip: sending packet %p\n", (void *)p));
	/* send the packet */
	return netif->linkoutput(netif, p);
}
    4e5a:	bc30      	pop	{r4, r5}
	return netif->linkoutput(netif, p);
    4e5c:	6983      	ldr	r3, [r0, #24]
    4e5e:	4718      	bx	r3

00004e60 <etharp_tmr>:
{
    4e60:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    4e62:	4c0e      	ldr	r4, [pc, #56]	; (4e9c <etharp_tmr+0x3c>)
				etharp_free_entry(i);
    4e64:	4e0e      	ldr	r6, [pc, #56]	; (4ea0 <etharp_tmr+0x40>)
{
    4e66:	2500      	movs	r5, #0
				arp_table[i].state = ETHARP_STATE_STABLE;
    4e68:	2702      	movs	r7, #2
		u8_t state = arp_table[i].state;
    4e6a:	7ca2      	ldrb	r2, [r4, #18]
		if (state != ETHARP_STATE_EMPTY
    4e6c:	b15a      	cbz	r2, 4e86 <etharp_tmr+0x26>
			arp_table[i].ctime++;
    4e6e:	7ce3      	ldrb	r3, [r4, #19]
    4e70:	3301      	adds	r3, #1
    4e72:	b2db      	uxtb	r3, r3
			if ((arp_table[i].ctime >= ARP_MAXAGE)
    4e74:	2bef      	cmp	r3, #239	; 0xef
			arp_table[i].ctime++;
    4e76:	74e3      	strb	r3, [r4, #19]
			if ((arp_table[i].ctime >= ARP_MAXAGE)
    4e78:	d803      	bhi.n	4e82 <etharp_tmr+0x22>
			    || ((arp_table[i].state == ETHARP_STATE_PENDING) && (arp_table[i].ctime >= ARP_MAXPENDING))) {
    4e7a:	2a01      	cmp	r2, #1
    4e7c:	d109      	bne.n	4e92 <etharp_tmr+0x32>
    4e7e:	2b01      	cmp	r3, #1
    4e80:	d901      	bls.n	4e86 <etharp_tmr+0x26>
				etharp_free_entry(i);
    4e82:	4628      	mov	r0, r5
    4e84:	47b0      	blx	r6
	for (i = 0; i < ARP_TABLE_SIZE; ++i) {
    4e86:	3501      	adds	r5, #1
    4e88:	2d0a      	cmp	r5, #10
    4e8a:	f104 0414 	add.w	r4, r4, #20
    4e8e:	d1ec      	bne.n	4e6a <etharp_tmr+0xa>
}
    4e90:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
			} else if (arp_table[i].state == ETHARP_STATE_STABLE_REREQUESTING) {
    4e92:	2a03      	cmp	r2, #3
				arp_table[i].state = ETHARP_STATE_STABLE;
    4e94:	bf08      	it	eq
    4e96:	74a7      	strbeq	r7, [r4, #18]
    4e98:	e7f5      	b.n	4e86 <etharp_tmr+0x26>
    4e9a:	bf00      	nop
    4e9c:	20010fe4 	.word	0x20010fe4
    4ea0:	00004d3d 	.word	0x00004d3d

00004ea4 <etharp_request>:
 * @return ERR_OK if the request has been sent
 *         ERR_MEM if the ARP packet couldn't be allocated
 *         any other err_t on failure
 */
err_t etharp_request(struct netif *netif, ip_addr_t *ipaddr)
{
    4ea4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	p = pbuf_alloc(PBUF_RAW, SIZEOF_ETHARP_PACKET, PBUF_RAM);
    4ea8:	4b23      	ldr	r3, [pc, #140]	; (4f38 <etharp_request+0x94>)
{
    4eaa:	4605      	mov	r5, r0
    4eac:	460f      	mov	r7, r1
	p = pbuf_alloc(PBUF_RAW, SIZEOF_ETHARP_PACKET, PBUF_RAM);
    4eae:	2200      	movs	r2, #0
    4eb0:	212c      	movs	r1, #44	; 0x2c
    4eb2:	2003      	movs	r0, #3
    4eb4:	4798      	blx	r3
	if (p == NULL) {
    4eb6:	4606      	mov	r6, r0
    4eb8:	2800      	cmp	r0, #0
    4eba:	d039      	beq.n	4f30 <etharp_request+0x8c>
	ethhdr = (struct eth_hdr *)p->payload;
    4ebc:	6844      	ldr	r4, [r0, #4]
	hdr->opcode = htons(opcode);
    4ebe:	4b1f      	ldr	r3, [pc, #124]	; (4f3c <etharp_request+0x98>)
    4ec0:	2001      	movs	r0, #1
    4ec2:	4798      	blx	r3
    4ec4:	82e0      	strh	r0, [r4, #22]
	ETHADDR16_COPY(&hdr->shwaddr, hwsrc_addr);
    4ec6:	f8d5 3027 	ldr.w	r3, [r5, #39]	; 0x27
    4eca:	61a3      	str	r3, [r4, #24]
    4ecc:	f8b5 302b 	ldrh.w	r3, [r5, #43]	; 0x2b
    4ed0:	83a3      	strh	r3, [r4, #28]
	ETHADDR16_COPY(&hdr->dhwaddr, hwdst_addr);
    4ed2:	4b1b      	ldr	r3, [pc, #108]	; (4f40 <etharp_request+0x9c>)
    4ed4:	681a      	ldr	r2, [r3, #0]
    4ed6:	889b      	ldrh	r3, [r3, #4]
    4ed8:	84e3      	strh	r3, [r4, #38]	; 0x26
	ETHADDR16_COPY(&ethhdr->dest, ethdst_addr);
    4eda:	4b1a      	ldr	r3, [pc, #104]	; (4f44 <etharp_request+0xa0>)
	ETHADDR16_COPY(&hdr->dhwaddr, hwdst_addr);
    4edc:	f8c4 2022 	str.w	r2, [r4, #34]	; 0x22
	ETHADDR16_COPY(&ethhdr->dest, ethdst_addr);
    4ee0:	681a      	ldr	r2, [r3, #0]
    4ee2:	889b      	ldrh	r3, [r3, #4]
    4ee4:	f8c4 2002 	str.w	r2, [r4, #2]
    4ee8:	80e3      	strh	r3, [r4, #6]
	ETHADDR16_COPY(&ethhdr->src, ethsrc_addr);
    4eea:	f8d5 3027 	ldr.w	r3, [r5, #39]	; 0x27
    4eee:	60a3      	str	r3, [r4, #8]
    4ef0:	f8b5 302b 	ldrh.w	r3, [r5, #43]	; 0x2b
    4ef4:	81a3      	strh	r3, [r4, #12]
	IPADDR2_COPY(&hdr->sipaddr, ipsrc_addr);
    4ef6:	686b      	ldr	r3, [r5, #4]
    4ef8:	f8c4 301e 	str.w	r3, [r4, #30]
	IPADDR2_COPY(&hdr->dipaddr, ipdst_addr);
    4efc:	683b      	ldr	r3, [r7, #0]
    4efe:	62a3      	str	r3, [r4, #40]	; 0x28
	hdr->hwtype = PP_HTONS(HWTYPE_ETHERNET);
    4f00:	2300      	movs	r3, #0
    4f02:	7423      	strb	r3, [r4, #16]
	hdr->proto  = PP_HTONS(ETHTYPE_IP);
    4f04:	74e3      	strb	r3, [r4, #19]
	hdr->hwtype = PP_HTONS(HWTYPE_ETHERNET);
    4f06:	2201      	movs	r2, #1
	hdr->hwlen    = ETHARP_HWADDR_LEN;
    4f08:	2306      	movs	r3, #6
	hdr->protolen = sizeof(ip_addr_t);
    4f0a:	2104      	movs	r1, #4
    4f0c:	7561      	strb	r1, [r4, #21]
	hdr->hwtype = PP_HTONS(HWTYPE_ETHERNET);
    4f0e:	7462      	strb	r2, [r4, #17]
	hdr->hwlen    = ETHARP_HWADDR_LEN;
    4f10:	7523      	strb	r3, [r4, #20]
	hdr->proto  = PP_HTONS(ETHTYPE_IP);
    4f12:	2208      	movs	r2, #8
	ethhdr->type = PP_HTONS(ETHTYPE_ARP);
    4f14:	73e3      	strb	r3, [r4, #15]
	hdr->proto  = PP_HTONS(ETHTYPE_IP);
    4f16:	74a2      	strb	r2, [r4, #18]
	result = netif->linkoutput(netif, p);
    4f18:	69ab      	ldr	r3, [r5, #24]
	ethhdr->type = PP_HTONS(ETHTYPE_ARP);
    4f1a:	73a2      	strb	r2, [r4, #14]
	result = netif->linkoutput(netif, p);
    4f1c:	4631      	mov	r1, r6
    4f1e:	4628      	mov	r0, r5
    4f20:	4798      	blx	r3
	pbuf_free(p);
    4f22:	4b09      	ldr	r3, [pc, #36]	; (4f48 <etharp_request+0xa4>)
	result = netif->linkoutput(netif, p);
    4f24:	4604      	mov	r4, r0
	pbuf_free(p);
    4f26:	4630      	mov	r0, r6
    4f28:	4798      	blx	r3
	                  (struct eth_addr *)netif->hwaddr,
	                  &netif->ip_addr,
	                  &ethzero,
	                  ipaddr,
	                  ARP_REQUEST);
}
    4f2a:	4620      	mov	r0, r4
    4f2c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		return ERR_MEM;
    4f30:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
    4f34:	e7f9      	b.n	4f2a <etharp_request+0x86>
    4f36:	bf00      	nop
    4f38:	000030d9 	.word	0x000030d9
    4f3c:	00000d65 	.word	0x00000d65
    4f40:	0000a824 	.word	0x0000a824
    4f44:	0000a81d 	.word	0x0000a81d
    4f48:	00003081 	.word	0x00003081

00004f4c <etharp_output_to_arp_index>:
{
    4f4c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	if ((arp_table[arp_idx].state == ETHARP_STATE_STABLE) && (arp_table[arp_idx].ctime >= ARP_AGE_REREQUEST_USED)) {
    4f50:	f8df 804c 	ldr.w	r8, [pc, #76]	; 4fa0 <etharp_output_to_arp_index+0x54>
    4f54:	2414      	movs	r4, #20
    4f56:	fb04 8402 	mla	r4, r4, r2, r8
    4f5a:	eb02 0582 	add.w	r5, r2, r2, lsl #2
    4f5e:	7ca3      	ldrb	r3, [r4, #18]
    4f60:	2b02      	cmp	r3, #2
{
    4f62:	4606      	mov	r6, r0
    4f64:	460f      	mov	r7, r1
    4f66:	ea4f 0585 	mov.w	r5, r5, lsl #2
	if ((arp_table[arp_idx].state == ETHARP_STATE_STABLE) && (arp_table[arp_idx].ctime >= ARP_AGE_REREQUEST_USED)) {
    4f6a:	d109      	bne.n	4f80 <etharp_output_to_arp_index+0x34>
    4f6c:	7ce3      	ldrb	r3, [r4, #19]
    4f6e:	2be3      	cmp	r3, #227	; 0xe3
    4f70:	d906      	bls.n	4f80 <etharp_output_to_arp_index+0x34>
		if (etharp_request(netif, &arp_table[arp_idx].ipaddr) == ERR_OK) {
    4f72:	1d29      	adds	r1, r5, #4
    4f74:	4b08      	ldr	r3, [pc, #32]	; (4f98 <etharp_output_to_arp_index+0x4c>)
    4f76:	4441      	add	r1, r8
    4f78:	4798      	blx	r3
    4f7a:	b908      	cbnz	r0, 4f80 <etharp_output_to_arp_index+0x34>
			arp_table[arp_idx].state = ETHARP_STATE_STABLE_REREQUESTING;
    4f7c:	2303      	movs	r3, #3
    4f7e:	74a3      	strb	r3, [r4, #18]
	return etharp_send_ip(netif, q, (struct eth_addr *)(netif->hwaddr), &arp_table[arp_idx].ethaddr);
    4f80:	4c06      	ldr	r4, [pc, #24]	; (4f9c <etharp_output_to_arp_index+0x50>)
    4f82:	350c      	adds	r5, #12
    4f84:	eb08 0305 	add.w	r3, r8, r5
    4f88:	f106 0227 	add.w	r2, r6, #39	; 0x27
    4f8c:	4639      	mov	r1, r7
    4f8e:	4630      	mov	r0, r6
    4f90:	46a4      	mov	ip, r4
}
    4f92:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
	return etharp_send_ip(netif, q, (struct eth_addr *)(netif->hwaddr), &arp_table[arp_idx].ethaddr);
    4f96:	4760      	bx	ip
    4f98:	00004ea5 	.word	0x00004ea5
    4f9c:	00004e3d 	.word	0x00004e3d
    4fa0:	20010fe4 	.word	0x20010fe4

00004fa4 <etharp_query>:
{
    4fa4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    4fa8:	4688      	mov	r8, r1
    4faa:	4606      	mov	r6, r0
	if (ip_addr_isbroadcast(ipaddr, netif) || ip_addr_ismulticast(ipaddr) || ip_addr_isany(ipaddr)) {
    4fac:	4601      	mov	r1, r0
    4fae:	4b36      	ldr	r3, [pc, #216]	; (5088 <etharp_query+0xe4>)
    4fb0:	f8d8 0000 	ldr.w	r0, [r8]
{
    4fb4:	4615      	mov	r5, r2
	if (ip_addr_isbroadcast(ipaddr, netif) || ip_addr_ismulticast(ipaddr) || ip_addr_isany(ipaddr)) {
    4fb6:	4798      	blx	r3
    4fb8:	2800      	cmp	r0, #0
    4fba:	d14e      	bne.n	505a <etharp_query+0xb6>
    4fbc:	f8d8 3000 	ldr.w	r3, [r8]
    4fc0:	f003 02f0 	and.w	r2, r3, #240	; 0xf0
    4fc4:	2ae0      	cmp	r2, #224	; 0xe0
    4fc6:	d048      	beq.n	505a <etharp_query+0xb6>
    4fc8:	2b00      	cmp	r3, #0
    4fca:	d046      	beq.n	505a <etharp_query+0xb6>
	i = etharp_find_entry(ipaddr, ETHARP_FLAG_TRY_HARD);
    4fcc:	4b2f      	ldr	r3, [pc, #188]	; (508c <etharp_query+0xe8>)
    4fce:	2101      	movs	r1, #1
    4fd0:	4640      	mov	r0, r8
    4fd2:	4798      	blx	r3
	if (i < 0) {
    4fd4:	1e04      	subs	r4, r0, #0
    4fd6:	db43      	blt.n	5060 <etharp_query+0xbc>
	if (arp_table[i].state == ETHARP_STATE_EMPTY) {
    4fd8:	4f2d      	ldr	r7, [pc, #180]	; (5090 <etharp_query+0xec>)
    4fda:	2314      	movs	r3, #20
    4fdc:	fb03 7304 	mla	r3, r3, r4, r7
    4fe0:	7c9a      	ldrb	r2, [r3, #18]
    4fe2:	b942      	cbnz	r2, 4ff6 <etharp_query+0x52>
		arp_table[i].state = ETHARP_STATE_PENDING;
    4fe4:	2201      	movs	r2, #1
    4fe6:	749a      	strb	r2, [r3, #18]
		result = etharp_request(netif, ipaddr);
    4fe8:	4b2a      	ldr	r3, [pc, #168]	; (5094 <etharp_query+0xf0>)
    4fea:	4641      	mov	r1, r8
    4fec:	4630      	mov	r0, r6
    4fee:	4798      	blx	r3
		if (q == NULL) {
    4ff0:	b93d      	cbnz	r5, 5002 <etharp_query+0x5e>
}
    4ff2:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	if ((arp_table[i].state == ETHARP_STATE_PENDING) || (q == NULL)) {
    4ff6:	2a01      	cmp	r2, #1
    4ff8:	d0f6      	beq.n	4fe8 <etharp_query+0x44>
    4ffa:	2d00      	cmp	r5, #0
    4ffc:	d0f4      	beq.n	4fe8 <etharp_query+0x44>
	err_t            result  = ERR_MEM;
    4ffe:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
	if (arp_table[i].state >= ETHARP_STATE_STABLE) {
    5002:	2314      	movs	r3, #20
    5004:	fb03 7204 	mla	r2, r3, r4, r7
    5008:	7c92      	ldrb	r2, [r2, #18]
    500a:	2a01      	cmp	r2, #1
    500c:	d90e      	bls.n	502c <etharp_query+0x88>
		result = etharp_send_ip(netif, q, srcaddr, &(arp_table[i].ethaddr));
    500e:	200c      	movs	r0, #12
    5010:	fb13 0304 	smlabb	r3, r3, r4, r0
		ETHARP_SET_HINT(netif, i);
    5014:	f887 40c8 	strb.w	r4, [r7, #200]	; 0xc8
		result = etharp_send_ip(netif, q, srcaddr, &(arp_table[i].ethaddr));
    5018:	4c1f      	ldr	r4, [pc, #124]	; (5098 <etharp_query+0xf4>)
    501a:	443b      	add	r3, r7
    501c:	f106 0227 	add.w	r2, r6, #39	; 0x27
    5020:	4629      	mov	r1, r5
    5022:	4630      	mov	r0, r6
    5024:	46a4      	mov	ip, r4
}
    5026:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
		result = etharp_send_ip(netif, q, srcaddr, &(arp_table[i].ethaddr));
    502a:	4760      	bx	ip
	} else if (arp_table[i].state == ETHARP_STATE_PENDING) {
    502c:	d1e1      	bne.n	4ff2 <etharp_query+0x4e>
    502e:	462b      	mov	r3, r5
			if (p->type != PBUF_ROM) {
    5030:	7b1a      	ldrb	r2, [r3, #12]
    5032:	2a01      	cmp	r2, #1
    5034:	d116      	bne.n	5064 <etharp_query+0xc0>
			p = p->next;
    5036:	681b      	ldr	r3, [r3, #0]
		while (p) {
    5038:	2b00      	cmp	r3, #0
    503a:	d1f9      	bne.n	5030 <etharp_query+0x8c>
			pbuf_ref(p);
    503c:	4b17      	ldr	r3, [pc, #92]	; (509c <etharp_query+0xf8>)
    503e:	4628      	mov	r0, r5
    5040:	4798      	blx	r3
    5042:	462e      	mov	r6, r5
			if (arp_table[i].q != NULL) {
    5044:	2314      	movs	r3, #20
    5046:	4363      	muls	r3, r4
    5048:	58f8      	ldr	r0, [r7, r3]
    504a:	b108      	cbz	r0, 5050 <etharp_query+0xac>
				pbuf_free(arp_table[i].q);
    504c:	4b14      	ldr	r3, [pc, #80]	; (50a0 <etharp_query+0xfc>)
    504e:	4798      	blx	r3
			arp_table[i].q = p;
    5050:	2314      	movs	r3, #20
    5052:	435c      	muls	r4, r3
			result = ERR_OK;
    5054:	2000      	movs	r0, #0
			arp_table[i].q = p;
    5056:	513e      	str	r6, [r7, r4]
			            ("etharp_query: queued packet %p on ARP entry %" S16_F "\n", (void *)q, (s16_t)i));
    5058:	e7cb      	b.n	4ff2 <etharp_query+0x4e>
		return ERR_ARG;
    505a:	f06f 000d 	mvn.w	r0, #13
    505e:	e7c8      	b.n	4ff2 <etharp_query+0x4e>
    5060:	4620      	mov	r0, r4
    5062:	e7c6      	b.n	4ff2 <etharp_query+0x4e>
			p = pbuf_alloc(PBUF_RAW, p->tot_len, PBUF_RAM);
    5064:	8919      	ldrh	r1, [r3, #8]
    5066:	4b0f      	ldr	r3, [pc, #60]	; (50a4 <etharp_query+0x100>)
    5068:	2200      	movs	r2, #0
    506a:	2003      	movs	r0, #3
    506c:	4798      	blx	r3
			if (p != NULL) {
    506e:	4606      	mov	r6, r0
    5070:	b138      	cbz	r0, 5082 <etharp_query+0xde>
				if (pbuf_copy(p, q) != ERR_OK) {
    5072:	4b0d      	ldr	r3, [pc, #52]	; (50a8 <etharp_query+0x104>)
    5074:	4629      	mov	r1, r5
    5076:	4798      	blx	r3
    5078:	2800      	cmp	r0, #0
    507a:	d0e3      	beq.n	5044 <etharp_query+0xa0>
					pbuf_free(p);
    507c:	4b08      	ldr	r3, [pc, #32]	; (50a0 <etharp_query+0xfc>)
    507e:	4630      	mov	r0, r6
    5080:	4798      	blx	r3
			result = ERR_MEM;
    5082:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    5086:	e7b4      	b.n	4ff2 <etharp_query+0x4e>
    5088:	00007aaf 	.word	0x00007aaf
    508c:	00004d69 	.word	0x00004d69
    5090:	20010fe4 	.word	0x20010fe4
    5094:	00004ea5 	.word	0x00004ea5
    5098:	00004e3d 	.word	0x00004e3d
    509c:	0000324d 	.word	0x0000324d
    50a0:	00003081 	.word	0x00003081
    50a4:	000030d9 	.word	0x000030d9
    50a8:	0000328d 	.word	0x0000328d

000050ac <etharp_output>:
{
    50ac:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
    50ae:	460e      	mov	r6, r1
    50b0:	4604      	mov	r4, r0
	if (pbuf_header(q, sizeof(struct eth_hdr)) != 0) {
    50b2:	4b3a      	ldr	r3, [pc, #232]	; (519c <etharp_output+0xf0>)
    50b4:	2110      	movs	r1, #16
    50b6:	4630      	mov	r0, r6
{
    50b8:	4615      	mov	r5, r2
	if (pbuf_header(q, sizeof(struct eth_hdr)) != 0) {
    50ba:	4798      	blx	r3
    50bc:	2800      	cmp	r0, #0
    50be:	d167      	bne.n	5190 <etharp_output+0xe4>
	if (ip_addr_isbroadcast(ipaddr, netif)) {
    50c0:	6828      	ldr	r0, [r5, #0]
    50c2:	4b37      	ldr	r3, [pc, #220]	; (51a0 <etharp_output+0xf4>)
    50c4:	4621      	mov	r1, r4
    50c6:	4798      	blx	r3
    50c8:	2800      	cmp	r0, #0
    50ca:	d15f      	bne.n	518c <etharp_output+0xe0>
	} else if (ip_addr_ismulticast(ipaddr)) {
    50cc:	682b      	ldr	r3, [r5, #0]
    50ce:	f003 02f0 	and.w	r2, r3, #240	; 0xf0
    50d2:	2ae0      	cmp	r2, #224	; 0xe0
    50d4:	d11b      	bne.n	510e <etharp_output+0x62>
		mcastaddr.addr[0] = LL_MULTICAST_ADDR_0;
    50d6:	2301      	movs	r3, #1
    50d8:	f88d 3000 	strb.w	r3, [sp]
		mcastaddr.addr[2] = LL_MULTICAST_ADDR_2;
    50dc:	235e      	movs	r3, #94	; 0x5e
    50de:	f88d 3002 	strb.w	r3, [sp, #2]
		mcastaddr.addr[3] = ip4_addr2(ipaddr) & 0x7f;
    50e2:	786b      	ldrb	r3, [r5, #1]
		mcastaddr.addr[1] = LL_MULTICAST_ADDR_1;
    50e4:	f88d 0001 	strb.w	r0, [sp, #1]
		mcastaddr.addr[3] = ip4_addr2(ipaddr) & 0x7f;
    50e8:	f003 037f 	and.w	r3, r3, #127	; 0x7f
    50ec:	f88d 3003 	strb.w	r3, [sp, #3]
		mcastaddr.addr[4] = ip4_addr3(ipaddr);
    50f0:	78ab      	ldrb	r3, [r5, #2]
    50f2:	f88d 3004 	strb.w	r3, [sp, #4]
		mcastaddr.addr[5] = ip4_addr4(ipaddr);
    50f6:	78eb      	ldrb	r3, [r5, #3]
    50f8:	f88d 3005 	strb.w	r3, [sp, #5]
		dest = &mcastaddr;
    50fc:	466b      	mov	r3, sp
	return etharp_send_ip(netif, q, (struct eth_addr *)(netif->hwaddr), dest);
    50fe:	f104 0227 	add.w	r2, r4, #39	; 0x27
    5102:	4620      	mov	r0, r4
    5104:	4631      	mov	r1, r6
    5106:	4c27      	ldr	r4, [pc, #156]	; (51a4 <etharp_output+0xf8>)
    5108:	47a0      	blx	r4
}
    510a:	b003      	add	sp, #12
    510c:	bdf0      	pop	{r4, r5, r6, r7, pc}
		if (!ip_addr_netcmp(ipaddr, &(netif->ip_addr), &(netif->netmask)) && !ip_addr_islinklocal(ipaddr)) {
    510e:	6862      	ldr	r2, [r4, #4]
    5110:	68a1      	ldr	r1, [r4, #8]
    5112:	405a      	eors	r2, r3
    5114:	420a      	tst	r2, r1
    5116:	d009      	beq.n	512c <etharp_output+0x80>
    5118:	b29b      	uxth	r3, r3
    511a:	f64f 62a9 	movw	r2, #65193	; 0xfea9
    511e:	4293      	cmp	r3, r2
    5120:	d004      	beq.n	512c <etharp_output+0x80>
				if (!ip_addr_isany(&netif->gw)) {
    5122:	68e3      	ldr	r3, [r4, #12]
    5124:	f104 050c 	add.w	r5, r4, #12
    5128:	2b00      	cmp	r3, #0
    512a:	d034      	beq.n	5196 <etharp_output+0xea>
				if ((arp_table[etharp_cached_entry].state >= ETHARP_STATE_STABLE)
    512c:	481e      	ldr	r0, [pc, #120]	; (51a8 <etharp_output+0xfc>)
    512e:	f890 20c8 	ldrb.w	r2, [r0, #200]	; 0xc8
    5132:	2314      	movs	r3, #20
    5134:	fb03 0302 	mla	r3, r3, r2, r0
    5138:	7c99      	ldrb	r1, [r3, #18]
    513a:	2901      	cmp	r1, #1
    513c:	d90a      	bls.n	5154 <etharp_output+0xa8>
				    && (ip_addr_cmp(dst_addr, &arp_table[etharp_cached_entry].ipaddr))) {
    513e:	6829      	ldr	r1, [r5, #0]
    5140:	685b      	ldr	r3, [r3, #4]
    5142:	4299      	cmp	r1, r3
    5144:	d106      	bne.n	5154 <etharp_output+0xa8>
				return etharp_output_to_arp_index(netif, q, i);
    5146:	4b19      	ldr	r3, [pc, #100]	; (51ac <etharp_output+0x100>)
    5148:	4631      	mov	r1, r6
    514a:	4620      	mov	r0, r4
}
    514c:	b003      	add	sp, #12
    514e:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
				return etharp_output_to_arp_index(netif, q, i);
    5152:	4718      	bx	r3
    5154:	4914      	ldr	r1, [pc, #80]	; (51a8 <etharp_output+0xfc>)
{
    5156:	2300      	movs	r3, #0
			if ((arp_table[i].state >= ETHARP_STATE_STABLE) && (ip_addr_cmp(dst_addr, &arp_table[i].ipaddr))) {
    5158:	7c8f      	ldrb	r7, [r1, #18]
    515a:	2f01      	cmp	r7, #1
    515c:	fa5f fc83 	uxtb.w	ip, r3
    5160:	d907      	bls.n	5172 <etharp_output+0xc6>
    5162:	684f      	ldr	r7, [r1, #4]
    5164:	682a      	ldr	r2, [r5, #0]
    5166:	42ba      	cmp	r2, r7
    5168:	d103      	bne.n	5172 <etharp_output+0xc6>
				ETHARP_SET_HINT(netif, i);
    516a:	f880 c0c8 	strb.w	ip, [r0, #200]	; 0xc8
				return etharp_output_to_arp_index(netif, q, i);
    516e:	4662      	mov	r2, ip
    5170:	e7e9      	b.n	5146 <etharp_output+0x9a>
		for (i = 0; i < ARP_TABLE_SIZE; i++) {
    5172:	3301      	adds	r3, #1
    5174:	2b0a      	cmp	r3, #10
    5176:	f101 0114 	add.w	r1, r1, #20
    517a:	d1ed      	bne.n	5158 <etharp_output+0xac>
		return etharp_query(netif, dst_addr, q);
    517c:	4b0c      	ldr	r3, [pc, #48]	; (51b0 <etharp_output+0x104>)
    517e:	4632      	mov	r2, r6
    5180:	4629      	mov	r1, r5
    5182:	4620      	mov	r0, r4
}
    5184:	b003      	add	sp, #12
    5186:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
		return etharp_query(netif, dst_addr, q);
    518a:	4718      	bx	r3
		dest = (struct eth_addr *)&ethbroadcast;
    518c:	4b09      	ldr	r3, [pc, #36]	; (51b4 <etharp_output+0x108>)
    518e:	e7b6      	b.n	50fe <etharp_output+0x52>
		return ERR_BUF;
    5190:	f06f 0001 	mvn.w	r0, #1
    5194:	e7b9      	b.n	510a <etharp_output+0x5e>
					return ERR_RTE;
    5196:	f06f 0003 	mvn.w	r0, #3
    519a:	e7b6      	b.n	510a <etharp_output+0x5e>
    519c:	00003029 	.word	0x00003029
    51a0:	00007aaf 	.word	0x00007aaf
    51a4:	00004e3d 	.word	0x00004e3d
    51a8:	20010fe4 	.word	0x20010fe4
    51ac:	00004f4d 	.word	0x00004f4d
    51b0:	00004fa5 	.word	0x00004fa5
    51b4:	0000a82a 	.word	0x0000a82a

000051b8 <ethernet_input>:
 *
 * @param p the recevied packet, p->payload pointing to the ethernet header
 * @param netif the network interface on which the packet was received
 */
err_t ethernet_input(struct pbuf *p, struct netif *netif)
{
    51b8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	u16_t           type;
#if LWIP_ARP || ETHARP_SUPPORT_VLAN
	s16_t ip_hdr_offset = SIZEOF_ETH_HDR;
#endif /* LWIP_ARP || ETHARP_SUPPORT_VLAN */

	if (p->len <= SIZEOF_ETH_HDR) {
    51bc:	8947      	ldrh	r7, [r0, #10]
    51be:	2f10      	cmp	r7, #16
{
    51c0:	b085      	sub	sp, #20
    51c2:	4606      	mov	r6, r0
    51c4:	460d      	mov	r5, r1
	if (p->len <= SIZEOF_ETH_HDR) {
    51c6:	d916      	bls.n	51f6 <ethernet_input+0x3e>
		ETHARP_STATS_INC(etharp.drop);
		goto free_and_return;
	}

	/* points to packet payload, which starts with an Ethernet header */
	ethhdr = (struct eth_hdr *)p->payload;
    51c8:	6844      	ldr	r4, [r0, #4]

#if LWIP_ARP_FILTER_NETIF
	netif = LWIP_ARP_FILTER_NETIF_FN(p, netif, htons(type));
#endif /* LWIP_ARP_FILTER_NETIF*/

	if (ethhdr->dest.addr[0] & 1) {
    51ca:	78a3      	ldrb	r3, [r4, #2]
	type = ethhdr->type;
    51cc:	f8b4 800e 	ldrh.w	r8, [r4, #14]
	if (ethhdr->dest.addr[0] & 1) {
    51d0:	07d8      	lsls	r0, r3, #31
    51d2:	d50a      	bpl.n	51ea <ethernet_input+0x32>
		/* this might be a multicast or broadcast packet */
		if (ethhdr->dest.addr[0] == LL_MULTICAST_ADDR_0) {
    51d4:	2b01      	cmp	r3, #1
    51d6:	d112      	bne.n	51fe <ethernet_input+0x46>
			if ((ethhdr->dest.addr[1] == LL_MULTICAST_ADDR_1) && (ethhdr->dest.addr[2] == LL_MULTICAST_ADDR_2)) {
    51d8:	78e3      	ldrb	r3, [r4, #3]
    51da:	b933      	cbnz	r3, 51ea <ethernet_input+0x32>
    51dc:	7923      	ldrb	r3, [r4, #4]
    51de:	2b5e      	cmp	r3, #94	; 0x5e
    51e0:	d103      	bne.n	51ea <ethernet_input+0x32>
				/* mark the pbuf as link-layer multicast */
				p->flags |= PBUF_FLAG_LLMCAST;
    51e2:	7b73      	ldrb	r3, [r6, #13]
    51e4:	f043 0310 	orr.w	r3, r3, #16
			}
		} else if (eth_addr_cmp(&ethhdr->dest, &ethbroadcast)) {
			/* mark the pbuf as link-layer broadcast */
			p->flags |= PBUF_FLAG_LLBCAST;
    51e8:	7373      	strb	r3, [r6, #13]
		}
	}

	switch (type) {
    51ea:	f1b8 0f08 	cmp.w	r8, #8
    51ee:	d011      	beq.n	5214 <ethernet_input+0x5c>
    51f0:	f5b8 6fc1 	cmp.w	r8, #1544	; 0x608
    51f4:	d021      	beq.n	523a <ethernet_input+0x82>
	/* This means the pbuf is freed or consumed,
	   so the caller doesn't have to free it again */
	return ERR_OK;

free_and_return:
	pbuf_free(p);
    51f6:	4b5b      	ldr	r3, [pc, #364]	; (5364 <ethernet_input+0x1ac>)
    51f8:	4630      	mov	r0, r6
    51fa:	4798      	blx	r3
	return ERR_OK;
    51fc:	e019      	b.n	5232 <ethernet_input+0x7a>
		} else if (eth_addr_cmp(&ethhdr->dest, &ethbroadcast)) {
    51fe:	495a      	ldr	r1, [pc, #360]	; (5368 <ethernet_input+0x1b0>)
    5200:	4b5a      	ldr	r3, [pc, #360]	; (536c <ethernet_input+0x1b4>)
    5202:	2206      	movs	r2, #6
    5204:	1ca0      	adds	r0, r4, #2
    5206:	4798      	blx	r3
    5208:	2800      	cmp	r0, #0
    520a:	d1ee      	bne.n	51ea <ethernet_input+0x32>
			p->flags |= PBUF_FLAG_LLBCAST;
    520c:	7b73      	ldrb	r3, [r6, #13]
    520e:	f043 0308 	orr.w	r3, r3, #8
    5212:	e7e9      	b.n	51e8 <ethernet_input+0x30>
		if (!(netif->flags & NETIF_FLAG_ETHARP)) {
    5214:	f895 302d 	ldrb.w	r3, [r5, #45]	; 0x2d
    5218:	0699      	lsls	r1, r3, #26
    521a:	d5ec      	bpl.n	51f6 <ethernet_input+0x3e>
		if (pbuf_header(p, -ip_hdr_offset)) {
    521c:	4b54      	ldr	r3, [pc, #336]	; (5370 <ethernet_input+0x1b8>)
    521e:	f06f 010f 	mvn.w	r1, #15
    5222:	4630      	mov	r0, r6
    5224:	4798      	blx	r3
    5226:	2800      	cmp	r0, #0
    5228:	d1e5      	bne.n	51f6 <ethernet_input+0x3e>
			ip_input(p, netif);
    522a:	4b52      	ldr	r3, [pc, #328]	; (5374 <ethernet_input+0x1bc>)
    522c:	4629      	mov	r1, r5
    522e:	4630      	mov	r0, r6
    5230:	4798      	blx	r3
}
    5232:	2000      	movs	r0, #0
    5234:	b005      	add	sp, #20
    5236:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		if (!(netif->flags & NETIF_FLAG_ETHARP)) {
    523a:	f895 302d 	ldrb.w	r3, [r5, #45]	; 0x2d
    523e:	069a      	lsls	r2, r3, #26
    5240:	d5d9      	bpl.n	51f6 <ethernet_input+0x3e>
	if (p->len < SIZEOF_ETHARP_PACKET) {
    5242:	2f2b      	cmp	r7, #43	; 0x2b
    5244:	f8df 911c 	ldr.w	r9, [pc, #284]	; 5364 <ethernet_input+0x1ac>
    5248:	d802      	bhi.n	5250 <ethernet_input+0x98>
	pbuf_free(p);
    524a:	4630      	mov	r0, r6
    524c:	47c8      	blx	r9
    524e:	e7f0      	b.n	5232 <ethernet_input+0x7a>
	if ((hdr->hwtype != PP_HTONS(HWTYPE_ETHERNET)) || (hdr->hwlen != ETHARP_HWADDR_LEN)
    5250:	8a23      	ldrh	r3, [r4, #16]
    5252:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
    5256:	d1f8      	bne.n	524a <ethernet_input+0x92>
    5258:	7d23      	ldrb	r3, [r4, #20]
    525a:	2b06      	cmp	r3, #6
    525c:	d1f5      	bne.n	524a <ethernet_input+0x92>
	    || (hdr->protolen != sizeof(ip_addr_t)) || (hdr->proto != PP_HTONS(ETHTYPE_IP))) {
    525e:	7d63      	ldrb	r3, [r4, #21]
    5260:	2b04      	cmp	r3, #4
    5262:	d1f2      	bne.n	524a <ethernet_input+0x92>
    5264:	8a63      	ldrh	r3, [r4, #18]
    5266:	2b08      	cmp	r3, #8
    5268:	d1ef      	bne.n	524a <ethernet_input+0x92>
	if (ip_addr_isany(&netif->ip_addr)) {
    526a:	686f      	ldr	r7, [r5, #4]
    526c:	f8d4 001e 	ldr.w	r0, [r4, #30]
    5270:	6aa3      	ldr	r3, [r4, #40]	; 0x28
	IPADDR2_COPY(&sipaddr, &hdr->sipaddr);
    5272:	9003      	str	r0, [sp, #12]
	etharp_update_arp_entry(netif, &sipaddr, &(hdr->shwaddr), for_us ? ETHARP_FLAG_TRY_HARD : ETHARP_FLAG_FIND_ONLY);
    5274:	f104 0818 	add.w	r8, r4, #24
	if (ip_addr_isany(&netif->ip_addr)) {
    5278:	2f00      	cmp	r7, #0
    527a:	d071      	beq.n	5360 <ethernet_input+0x1a8>
		for_us = (u8_t)ip_addr_cmp(&dipaddr, &(netif->ip_addr));
    527c:	1bdb      	subs	r3, r3, r7
    527e:	425f      	negs	r7, r3
    5280:	415f      	adcs	r7, r3
	etharp_update_arp_entry(netif, &sipaddr, &(hdr->shwaddr), for_us ? ETHARP_FLAG_TRY_HARD : ETHARP_FLAG_FIND_ONLY);
    5282:	f1c7 0302 	rsb	r3, r7, #2
    5286:	b2db      	uxtb	r3, r3
    5288:	9301      	str	r3, [sp, #4]
		etharp_arp_input(netif, (struct eth_addr *)(netif->hwaddr), p);
    528a:	f105 0a27 	add.w	sl, r5, #39	; 0x27
	if (ip_addr_isany(ipaddr) || ip_addr_isbroadcast(ipaddr, netif) || ip_addr_ismulticast(ipaddr)) {
    528e:	2800      	cmp	r0, #0
    5290:	d038      	beq.n	5304 <ethernet_input+0x14c>
    5292:	4a39      	ldr	r2, [pc, #228]	; (5378 <ethernet_input+0x1c0>)
    5294:	4629      	mov	r1, r5
    5296:	4790      	blx	r2
    5298:	4683      	mov	fp, r0
    529a:	bb98      	cbnz	r0, 5304 <ethernet_input+0x14c>
    529c:	9a03      	ldr	r2, [sp, #12]
    529e:	f002 02f0 	and.w	r2, r2, #240	; 0xf0
    52a2:	2ae0      	cmp	r2, #224	; 0xe0
    52a4:	d02e      	beq.n	5304 <ethernet_input+0x14c>
	i = etharp_find_entry(ipaddr, flags);
    52a6:	9b01      	ldr	r3, [sp, #4]
    52a8:	a803      	add	r0, sp, #12
    52aa:	4619      	mov	r1, r3
    52ac:	4b33      	ldr	r3, [pc, #204]	; (537c <ethernet_input+0x1c4>)
    52ae:	4798      	blx	r3
	if (i < 0) {
    52b0:	2800      	cmp	r0, #0
    52b2:	db27      	blt.n	5304 <ethernet_input+0x14c>
		arp_table[i].state = ETHARP_STATE_STABLE;
    52b4:	4b32      	ldr	r3, [pc, #200]	; (5380 <ethernet_input+0x1c8>)
    52b6:	2214      	movs	r2, #20
    52b8:	fb02 fc00 	mul.w	ip, r2, r0
    52bc:	eb03 010c 	add.w	r1, r3, ip
    52c0:	f04f 0e02 	mov.w	lr, #2
    52c4:	f881 e012 	strb.w	lr, [r1, #18]
	ETHADDR32_COPY(&arp_table[i].ethaddr, ethaddr);
    52c8:	f04f 0e0c 	mov.w	lr, #12
	arp_table[i].netif = netif;
    52cc:	608d      	str	r5, [r1, #8]
	ETHADDR32_COPY(&arp_table[i].ethaddr, ethaddr);
    52ce:	fb12 e200 	smlabb	r2, r2, r0, lr
    52d2:	69a0      	ldr	r0, [r4, #24]
    52d4:	5098      	str	r0, [r3, r2]
    52d6:	eb03 0e02 	add.w	lr, r3, r2
    52da:	f8b8 2004 	ldrh.w	r2, [r8, #4]
    52de:	f8ae 2004 	strh.w	r2, [lr, #4]
	arp_table[i].ctime = 0;
    52e2:	f881 b013 	strb.w	fp, [r1, #19]
	if (arp_table[i].q != NULL) {
    52e6:	f853 100c 	ldr.w	r1, [r3, ip]
    52ea:	b159      	cbz	r1, 5304 <ethernet_input+0x14c>
		arp_table[i].q = NULL;
    52ec:	f843 b00c 	str.w	fp, [r3, ip]
		etharp_send_ip(netif, p, (struct eth_addr *)(netif->hwaddr), ethaddr);
    52f0:	4652      	mov	r2, sl
    52f2:	f8df b094 	ldr.w	fp, [pc, #148]	; 5388 <ethernet_input+0x1d0>
    52f6:	9101      	str	r1, [sp, #4]
    52f8:	4643      	mov	r3, r8
    52fa:	4628      	mov	r0, r5
    52fc:	47d8      	blx	fp
		pbuf_free(p);
    52fe:	9901      	ldr	r1, [sp, #4]
    5300:	4608      	mov	r0, r1
    5302:	47c8      	blx	r9
	switch (hdr->opcode) {
    5304:	8ae3      	ldrh	r3, [r4, #22]
    5306:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
    530a:	d19e      	bne.n	524a <ethernet_input+0x92>
		if (for_us) {
    530c:	2f00      	cmp	r7, #0
    530e:	d09c      	beq.n	524a <ethernet_input+0x92>
			hdr->opcode = htons(ARP_REPLY);
    5310:	4b1c      	ldr	r3, [pc, #112]	; (5384 <ethernet_input+0x1cc>)
    5312:	2002      	movs	r0, #2
    5314:	4798      	blx	r3
			IPADDR2_COPY(&hdr->dipaddr, &hdr->sipaddr);
    5316:	f8d4 301e 	ldr.w	r3, [r4, #30]
			hdr->opcode = htons(ARP_REPLY);
    531a:	82e0      	strh	r0, [r4, #22]
			IPADDR2_COPY(&hdr->dipaddr, &hdr->sipaddr);
    531c:	62a3      	str	r3, [r4, #40]	; 0x28
			IPADDR2_COPY(&hdr->sipaddr, &netif->ip_addr);
    531e:	686b      	ldr	r3, [r5, #4]
    5320:	f8c4 301e 	str.w	r3, [r4, #30]
			ETHADDR16_COPY(&hdr->dhwaddr, &hdr->shwaddr);
    5324:	69a3      	ldr	r3, [r4, #24]
    5326:	f8c4 3022 	str.w	r3, [r4, #34]	; 0x22
    532a:	f8b8 3004 	ldrh.w	r3, [r8, #4]
    532e:	84e3      	strh	r3, [r4, #38]	; 0x26
			ETHADDR16_COPY(&ethhdr->dest, &hdr->shwaddr);
    5330:	69a3      	ldr	r3, [r4, #24]
    5332:	f8c4 3002 	str.w	r3, [r4, #2]
    5336:	f8b8 3004 	ldrh.w	r3, [r8, #4]
    533a:	80e3      	strh	r3, [r4, #6]
			ETHADDR16_COPY(&hdr->shwaddr, ethaddr);
    533c:	f8d5 3027 	ldr.w	r3, [r5, #39]	; 0x27
    5340:	61a3      	str	r3, [r4, #24]
    5342:	f8ba 3004 	ldrh.w	r3, [sl, #4]
    5346:	f8a8 3004 	strh.w	r3, [r8, #4]
			ETHADDR16_COPY(&ethhdr->src, ethaddr);
    534a:	f8d5 3027 	ldr.w	r3, [r5, #39]	; 0x27
    534e:	60a3      	str	r3, [r4, #8]
    5350:	f8ba 3004 	ldrh.w	r3, [sl, #4]
    5354:	81a3      	strh	r3, [r4, #12]
			netif->linkoutput(netif, p);
    5356:	69ab      	ldr	r3, [r5, #24]
    5358:	4631      	mov	r1, r6
    535a:	4628      	mov	r0, r5
    535c:	4798      	blx	r3
    535e:	e774      	b.n	524a <ethernet_input+0x92>
	etharp_update_arp_entry(netif, &sipaddr, &(hdr->shwaddr), for_us ? ETHARP_FLAG_TRY_HARD : ETHARP_FLAG_FIND_ONLY);
    5360:	2302      	movs	r3, #2
    5362:	e791      	b.n	5288 <ethernet_input+0xd0>
    5364:	00003081 	.word	0x00003081
    5368:	0000a82a 	.word	0x0000a82a
    536c:	00009485 	.word	0x00009485
    5370:	00003029 	.word	0x00003029
    5374:	00005429 	.word	0x00005429
    5378:	00007aaf 	.word	0x00007aaf
    537c:	00004d69 	.word	0x00004d69
    5380:	20010fe4 	.word	0x20010fe4
    5384:	00000d65 	.word	0x00000d65
    5388:	00004e3d 	.word	0x00004e3d

0000538c <io_write>:

/**
 * \brief I/O write interface
 */
int32_t io_write(struct io_descriptor *const io_descr, const uint8_t *const buf, const uint16_t length)
{
    538c:	b570      	push	{r4, r5, r6, lr}
    538e:	460d      	mov	r5, r1
    5390:	4616      	mov	r6, r2
	ASSERT(io_descr && buf);
    5392:	4604      	mov	r4, r0
    5394:	b110      	cbz	r0, 539c <io_write+0x10>
    5396:	1e08      	subs	r0, r1, #0
    5398:	bf18      	it	ne
    539a:	2001      	movne	r0, #1
    539c:	4905      	ldr	r1, [pc, #20]	; (53b4 <io_write+0x28>)
    539e:	4b06      	ldr	r3, [pc, #24]	; (53b8 <io_write+0x2c>)
    53a0:	2234      	movs	r2, #52	; 0x34
    53a2:	4798      	blx	r3
	return io_descr->write(io_descr, buf, length);
    53a4:	6823      	ldr	r3, [r4, #0]
    53a6:	4632      	mov	r2, r6
    53a8:	4629      	mov	r1, r5
    53aa:	4620      	mov	r0, r4
}
    53ac:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	return io_descr->write(io_descr, buf, length);
    53b0:	4718      	bx	r3
    53b2:	bf00      	nop
    53b4:	0000a836 	.word	0x0000a836
    53b8:	00007aa9 	.word	0x00007aa9

000053bc <io_read>:

/**
 * \brief I/O read interface
 */
int32_t io_read(struct io_descriptor *const io_descr, uint8_t *const buf, const uint16_t length)
{
    53bc:	b570      	push	{r4, r5, r6, lr}
    53be:	460d      	mov	r5, r1
    53c0:	4616      	mov	r6, r2
	ASSERT(io_descr && buf);
    53c2:	4604      	mov	r4, r0
    53c4:	b110      	cbz	r0, 53cc <io_read+0x10>
    53c6:	1e08      	subs	r0, r1, #0
    53c8:	bf18      	it	ne
    53ca:	2001      	movne	r0, #1
    53cc:	4905      	ldr	r1, [pc, #20]	; (53e4 <io_read+0x28>)
    53ce:	4b06      	ldr	r3, [pc, #24]	; (53e8 <io_read+0x2c>)
    53d0:	223d      	movs	r2, #61	; 0x3d
    53d2:	4798      	blx	r3
	return io_descr->read(io_descr, buf, length);
    53d4:	6863      	ldr	r3, [r4, #4]
    53d6:	4632      	mov	r2, r6
    53d8:	4629      	mov	r1, r5
    53da:	4620      	mov	r0, r4
}
    53dc:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	return io_descr->read(io_descr, buf, length);
    53e0:	4718      	bx	r3
    53e2:	bf00      	nop
    53e4:	0000a836 	.word	0x0000a836
    53e8:	00007aa9 	.word	0x00007aa9

000053ec <ip_route>:
		return netif;
	}
#endif

	/* iterate through netifs */
	for (netif = netif_list; netif != NULL; netif = netif->next) {
    53ec:	4a0c      	ldr	r2, [pc, #48]	; (5420 <ip_route+0x34>)
{
    53ee:	4603      	mov	r3, r0
	for (netif = netif_list; netif != NULL; netif = netif->next) {
    53f0:	6810      	ldr	r0, [r2, #0]
    53f2:	b948      	cbnz	r0, 5408 <ip_route+0x1c>
				/* return netif on which to forward IP packet */
				return netif;
			}
		}
	}
	if ((netif_default == NULL) || (!netif_is_up(netif_default))) {
    53f4:	4b0b      	ldr	r3, [pc, #44]	; (5424 <ip_route+0x38>)
    53f6:	681b      	ldr	r3, [r3, #0]
    53f8:	b12b      	cbz	r3, 5406 <ip_route+0x1a>
    53fa:	f893 202d 	ldrb.w	r2, [r3, #45]	; 0x2d
    53fe:	f012 0f01 	tst.w	r2, #1
    5402:	bf18      	it	ne
    5404:	4618      	movne	r0, r3
		snmp_inc_ipoutnoroutes();
		return NULL;
	}
	/* no matching netif found, use default netif */
	return netif_default;
}
    5406:	4770      	bx	lr
		if (netif_is_up(netif)) {
    5408:	f890 202d 	ldrb.w	r2, [r0, #45]	; 0x2d
    540c:	07d2      	lsls	r2, r2, #31
    540e:	d505      	bpl.n	541c <ip_route+0x30>
			if (ip_addr_netcmp(dest, &(netif->ip_addr), &(netif->netmask))) {
    5410:	6841      	ldr	r1, [r0, #4]
    5412:	681a      	ldr	r2, [r3, #0]
    5414:	404a      	eors	r2, r1
    5416:	6881      	ldr	r1, [r0, #8]
    5418:	420a      	tst	r2, r1
    541a:	d0f4      	beq.n	5406 <ip_route+0x1a>
	for (netif = netif_list; netif != NULL; netif = netif->next) {
    541c:	6800      	ldr	r0, [r0, #0]
    541e:	e7e8      	b.n	53f2 <ip_route+0x6>
    5420:	20016384 	.word	0x20016384
    5424:	2001638c 	.word	0x2001638c

00005428 <ip_input>:
 * @param inp the netif on which this packet was received
 * @return ERR_OK if the packet was processed (could return ERR_* if it wasn't
 *         processed, but currently always returns ERR_OK)
 */
err_t ip_input(struct pbuf *p, struct netif *inp)
{
    5428:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}

	IP_STATS_INC(ip.recv);
	snmp_inc_ipinreceives();

	/* identify the IP header */
	iphdr = (struct ip_hdr *)p->payload;
    542c:	6847      	ldr	r7, [r0, #4]
	if (IPH_V(iphdr) != 4) {
    542e:	783d      	ldrb	r5, [r7, #0]
    5430:	092b      	lsrs	r3, r5, #4
    5432:	2b04      	cmp	r3, #4
{
    5434:	4604      	mov	r4, r0
    5436:	4688      	mov	r8, r1
	if (IPH_V(iphdr) != 4) {
    5438:	d005      	beq.n	5446 <ip_input+0x1e>
		LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_LEVEL_WARNING,
		            ("IP packet dropped due to bad version number %" U16_F "\n", IPH_V(iphdr)));
		ip_debug_print(p);
		pbuf_free(p);
    543a:	4b46      	ldr	r3, [pc, #280]	; (5554 <ip_input+0x12c>)
    543c:	4620      	mov	r0, r4
    543e:	4798      	blx	r3
	current_header = NULL;
	ip_addr_set_any(&current_iphdr_src);
	ip_addr_set_any(&current_iphdr_dest);

	return ERR_OK;
}
    5440:	2000      	movs	r0, #0
    5442:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
	iphdr_len = ntohs(IPH_LEN(iphdr));
    5446:	4b44      	ldr	r3, [pc, #272]	; (5558 <ip_input+0x130>)
    5448:	8878      	ldrh	r0, [r7, #2]
    544a:	4798      	blx	r3
	iphdr_hlen = IPH_HL(iphdr);
    544c:	f005 050f 	and.w	r5, r5, #15
	if ((iphdr_hlen > p->len) || (iphdr_len > p->tot_len)) {
    5450:	8963      	ldrh	r3, [r4, #10]
	iphdr_hlen *= 4;
    5452:	00ad      	lsls	r5, r5, #2
	if ((iphdr_hlen > p->len) || (iphdr_len > p->tot_len)) {
    5454:	42ab      	cmp	r3, r5
	iphdr_len = ntohs(IPH_LEN(iphdr));
    5456:	4606      	mov	r6, r0
	if ((iphdr_hlen > p->len) || (iphdr_len > p->tot_len)) {
    5458:	d3ef      	bcc.n	543a <ip_input+0x12>
    545a:	8923      	ldrh	r3, [r4, #8]
    545c:	4283      	cmp	r3, r0
    545e:	d3ec      	bcc.n	543a <ip_input+0x12>
	if (inet_chksum(iphdr, iphdr_hlen) != 0) {
    5460:	4b3e      	ldr	r3, [pc, #248]	; (555c <ip_input+0x134>)
    5462:	4629      	mov	r1, r5
    5464:	4638      	mov	r0, r7
    5466:	4798      	blx	r3
    5468:	2800      	cmp	r0, #0
    546a:	d1e6      	bne.n	543a <ip_input+0x12>
	pbuf_realloc(p, iphdr_len);
    546c:	4b3c      	ldr	r3, [pc, #240]	; (5560 <ip_input+0x138>)
	ip_addr_copy(current_iphdr_dest, iphdr->dest);
    546e:	4d3d      	ldr	r5, [pc, #244]	; (5564 <ip_input+0x13c>)
				    ip_addr_isbroadcast(&current_iphdr_dest, netif)) {
    5470:	f8df a108 	ldr.w	sl, [pc, #264]	; 557c <ip_input+0x154>
				netif = netif_list;
    5474:	f8df b108 	ldr.w	fp, [pc, #264]	; 5580 <ip_input+0x158>
	pbuf_realloc(p, iphdr_len);
    5478:	4631      	mov	r1, r6
    547a:	4620      	mov	r0, r4
    547c:	4798      	blx	r3
	ip_addr_copy(current_iphdr_dest, iphdr->dest);
    547e:	693b      	ldr	r3, [r7, #16]
    5480:	602b      	str	r3, [r5, #0]
	ip_addr_copy(current_iphdr_src, iphdr->src);
    5482:	68fb      	ldr	r3, [r7, #12]
    5484:	606b      	str	r3, [r5, #4]
    5486:	4646      	mov	r6, r8
		int first = 1;
    5488:	f04f 0901 	mov.w	r9, #1
			if ((netif_is_up(netif)) && (!ip_addr_isany(&(netif->ip_addr)))) {
    548c:	f896 302d 	ldrb.w	r3, [r6, #45]	; 0x2d
    5490:	07db      	lsls	r3, r3, #31
    5492:	d404      	bmi.n	549e <ip_input+0x76>
			if (first) {
    5494:	f1b9 0f00 	cmp.w	r9, #0
    5498:	d131      	bne.n	54fe <ip_input+0xd6>
				netif = netif->next;
    549a:	6836      	ldr	r6, [r6, #0]
    549c:	e031      	b.n	5502 <ip_input+0xda>
			if ((netif_is_up(netif)) && (!ip_addr_isany(&(netif->ip_addr)))) {
    549e:	6873      	ldr	r3, [r6, #4]
    54a0:	2b00      	cmp	r3, #0
    54a2:	d0f7      	beq.n	5494 <ip_input+0x6c>
				if (ip_addr_cmp(&current_iphdr_dest, &(netif->ip_addr)) ||
    54a4:	6828      	ldr	r0, [r5, #0]
    54a6:	4283      	cmp	r3, r0
    54a8:	d003      	beq.n	54b2 <ip_input+0x8a>
				    ip_addr_isbroadcast(&current_iphdr_dest, netif)) {
    54aa:	4631      	mov	r1, r6
    54ac:	47d0      	blx	sl
				if (ip_addr_cmp(&current_iphdr_dest, &(netif->ip_addr)) ||
    54ae:	2800      	cmp	r0, #0
    54b0:	d0f0      	beq.n	5494 <ip_input+0x6c>
		if ((ip_addr_isbroadcast(&current_iphdr_src, inp)) || (ip_addr_ismulticast(&current_iphdr_src))) {
    54b2:	6868      	ldr	r0, [r5, #4]
    54b4:	f8df 90c4 	ldr.w	r9, [pc, #196]	; 557c <ip_input+0x154>
    54b8:	4641      	mov	r1, r8
    54ba:	47c8      	blx	r9
    54bc:	2800      	cmp	r0, #0
    54be:	d1bc      	bne.n	543a <ip_input+0x12>
    54c0:	686b      	ldr	r3, [r5, #4]
    54c2:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
    54c6:	2be0      	cmp	r3, #224	; 0xe0
    54c8:	d0b7      	beq.n	543a <ip_input+0x12>
	if (netif == NULL) {
    54ca:	2e00      	cmp	r6, #0
    54cc:	d0b5      	beq.n	543a <ip_input+0x12>
	if ((IPH_OFFSET(iphdr) & PP_HTONS(IP_OFFMASK | IP_MF)) != 0) {
    54ce:	88fb      	ldrh	r3, [r7, #6]
    54d0:	f023 03c0 	bic.w	r3, r3, #192	; 0xc0
    54d4:	b133      	cbz	r3, 54e4 <ip_input+0xbc>
		p = ip_reass(p);
    54d6:	4620      	mov	r0, r4
    54d8:	4b23      	ldr	r3, [pc, #140]	; (5568 <ip_input+0x140>)
    54da:	4798      	blx	r3
		if (p == NULL) {
    54dc:	4604      	mov	r4, r0
    54de:	2800      	cmp	r0, #0
    54e0:	d0ae      	beq.n	5440 <ip_input+0x18>
		iphdr = (struct ip_hdr *)p->payload;
    54e2:	6847      	ldr	r7, [r0, #4]
		switch (IPH_PROTO(iphdr)) {
    54e4:	7a7b      	ldrb	r3, [r7, #9]
    54e6:	2b06      	cmp	r3, #6
	current_header = iphdr;
    54e8:	e9c5 8702 	strd	r8, r7, [r5, #8]
		switch (IPH_PROTO(iphdr)) {
    54ec:	d01b      	beq.n	5526 <ip_input+0xfe>
    54ee:	2b11      	cmp	r3, #17
    54f0:	d00f      	beq.n	5512 <ip_input+0xea>
    54f2:	2b01      	cmp	r3, #1
    54f4:	d11b      	bne.n	552e <ip_input+0x106>
			icmp_input(p, inp);
    54f6:	4b1d      	ldr	r3, [pc, #116]	; (556c <ip_input+0x144>)
    54f8:	4641      	mov	r1, r8
    54fa:	4620      	mov	r0, r4
    54fc:	e00c      	b.n	5518 <ip_input+0xf0>
				netif = netif_list;
    54fe:	f8db 6000 	ldr.w	r6, [fp]
			if (netif == inp) {
    5502:	4546      	cmp	r6, r8
				netif = netif->next;
    5504:	bf08      	it	eq
    5506:	6836      	ldreq	r6, [r6, #0]
		} while (netif != NULL);
    5508:	f04f 0900 	mov.w	r9, #0
    550c:	2e00      	cmp	r6, #0
    550e:	d1bd      	bne.n	548c <ip_input+0x64>
    5510:	e7cf      	b.n	54b2 <ip_input+0x8a>
			udp_input(p, inp);
    5512:	4b17      	ldr	r3, [pc, #92]	; (5570 <ip_input+0x148>)
    5514:	4641      	mov	r1, r8
    5516:	4620      	mov	r0, r4
			tcp_input(p, inp);
    5518:	4798      	blx	r3
	current_netif  = NULL;
    551a:	2300      	movs	r3, #0
	current_header = NULL;
    551c:	e9c5 3302 	strd	r3, r3, [r5, #8]
	ip_addr_set_any(&current_iphdr_dest);
    5520:	e9c5 3300 	strd	r3, r3, [r5]
	return ERR_OK;
    5524:	e78c      	b.n	5440 <ip_input+0x18>
			tcp_input(p, inp);
    5526:	4b13      	ldr	r3, [pc, #76]	; (5574 <ip_input+0x14c>)
    5528:	4641      	mov	r1, r8
    552a:	4620      	mov	r0, r4
    552c:	e7f4      	b.n	5518 <ip_input+0xf0>
			if (!ip_addr_isbroadcast(&current_iphdr_dest, inp) && !ip_addr_ismulticast(&current_iphdr_dest)) {
    552e:	6828      	ldr	r0, [r5, #0]
    5530:	4641      	mov	r1, r8
    5532:	47c8      	blx	r9
    5534:	b948      	cbnz	r0, 554a <ip_input+0x122>
    5536:	682b      	ldr	r3, [r5, #0]
    5538:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
    553c:	2be0      	cmp	r3, #224	; 0xe0
    553e:	d004      	beq.n	554a <ip_input+0x122>
				icmp_dest_unreach(p, ICMP_DUR_PROTO);
    5540:	4b0d      	ldr	r3, [pc, #52]	; (5578 <ip_input+0x150>)
				p->payload = iphdr;
    5542:	6067      	str	r7, [r4, #4]
				icmp_dest_unreach(p, ICMP_DUR_PROTO);
    5544:	2102      	movs	r1, #2
    5546:	4620      	mov	r0, r4
    5548:	4798      	blx	r3
			pbuf_free(p);
    554a:	4b02      	ldr	r3, [pc, #8]	; (5554 <ip_input+0x12c>)
    554c:	4620      	mov	r0, r4
    554e:	4798      	blx	r3
    5550:	e7e3      	b.n	551a <ip_input+0xf2>
    5552:	bf00      	nop
    5554:	00003081 	.word	0x00003081
    5558:	00000d6b 	.word	0x00000d6b
    555c:	000074a9 	.word	0x000074a9
    5560:	000031e9 	.word	0x000031e9
    5564:	200110b0 	.word	0x200110b0
    5568:	00002ae9 	.word	0x00002ae9
    556c:	00000c09 	.word	0x00000c09
    5570:	0000441d 	.word	0x0000441d
    5574:	00003bf5 	.word	0x00003bf5
    5578:	00000d4d 	.word	0x00000d4d
    557c:	00007aaf 	.word	0x00007aaf
    5580:	20016384 	.word	0x20016384

00005584 <ip_output_if>:
 *
 * @note ip_id: RFC791 "some host may be able to simply use
 *  unique identifiers independent of destination"
 */
err_t ip_output_if(struct pbuf *p, ip_addr_t *src, ip_addr_t *dest, u8_t ttl, u8_t tos, u8_t proto, struct netif *netif)
{
    5584:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    5588:	b085      	sub	sp, #20
    558a:	4606      	mov	r6, r0
    558c:	f89d b038 	ldrb.w	fp, [sp, #56]	; 0x38
    5590:	f89d 903c 	ldrb.w	r9, [sp, #60]	; 0x3c
    5594:	f8dd 8040 	ldr.w	r8, [sp, #64]	; 0x40
    5598:	9101      	str	r1, [sp, #4]
    559a:	461c      	mov	r4, r3
	LWIP_ASSERT("p->ref == 1", p->ref == 1);

	snmp_inc_ipoutrequests();

	/* Should the IP header be generated or is it already included in p? */
	if (dest != IP_HDRINCL) {
    559c:	4617      	mov	r7, r2
    559e:	2a00      	cmp	r2, #0
    55a0:	d050      	beq.n	5644 <ip_output_if+0xc0>
			}
#endif /* CHECKSUM_GEN_IP_INLINE */
		}
#endif /* IP_OPTIONS_SEND */
		/* generate IP header */
		if (pbuf_header(p, IP_HLEN)) {
    55a2:	4b2f      	ldr	r3, [pc, #188]	; (5660 <ip_output_if+0xdc>)
    55a4:	2114      	movs	r1, #20
    55a6:	4798      	blx	r3
    55a8:	4682      	mov	sl, r0
    55aa:	2800      	cmp	r0, #0
    55ac:	d155      	bne.n	565a <ip_output_if+0xd6>
			IP_STATS_INC(ip.err);
			snmp_inc_ipoutdiscards();
			return ERR_BUF;
		}

		iphdr = (struct ip_hdr *)p->payload;
    55ae:	6875      	ldr	r5, [r6, #4]
		LWIP_ASSERT("check that first pbuf can hold struct ip_hdr", (p->len >= sizeof(struct ip_hdr)));

		IPH_TTL_SET(iphdr, ttl);
    55b0:	722c      	strb	r4, [r5, #8]
		IPH_PROTO_SET(iphdr, proto);
    55b2:	f885 9009 	strb.w	r9, [r5, #9]
#if CHECKSUM_GEN_IP_INLINE
		chk_sum += LWIP_MAKE_U16(proto, ttl);
#endif /* CHECKSUM_GEN_IP_INLINE */

		/* dest cannot be NULL here */
		ip_addr_copy(iphdr->dest, *dest);
    55b6:	683b      	ldr	r3, [r7, #0]
		chk_sum += ip4_addr_get_u32(&iphdr->dest) & 0xFFFF;
		chk_sum += ip4_addr_get_u32(&iphdr->dest) >> 16;
#endif /* CHECKSUM_GEN_IP_INLINE */

		IPH_VHL_SET(iphdr, 4, ip_hlen / 4);
		IPH_TOS_SET(iphdr, tos);
    55b8:	f885 b001 	strb.w	fp, [r5, #1]
		IPH_VHL_SET(iphdr, 4, ip_hlen / 4);
    55bc:	2245      	movs	r2, #69	; 0x45
#if CHECKSUM_GEN_IP_INLINE
		chk_sum += LWIP_MAKE_U16(tos, iphdr->_v_hl);
    55be:	ea4f 2b0b 	mov.w	fp, fp, lsl #8
    55c2:	ea4b 0b02 	orr.w	fp, fp, r2
		chk_sum += LWIP_MAKE_U16(proto, ttl);
    55c6:	ea44 2409 	orr.w	r4, r4, r9, lsl #8
		IPH_VHL_SET(iphdr, 4, ip_hlen / 4);
    55ca:	702a      	strb	r2, [r5, #0]
		chk_sum += LWIP_MAKE_U16(tos, iphdr->_v_hl);
    55cc:	445c      	add	r4, fp
    55ce:	fa14 f483 	uxtah	r4, r4, r3
		ip_addr_copy(iphdr->dest, *dest);
    55d2:	612b      	str	r3, [r5, #16]
#endif /* CHECKSUM_GEN_IP_INLINE */
		IPH_LEN_SET(iphdr, htons(p->tot_len));
    55d4:	f8df b090 	ldr.w	fp, [pc, #144]	; 5668 <ip_output_if+0xe4>
    55d8:	8930      	ldrh	r0, [r6, #8]
		chk_sum += LWIP_MAKE_U16(tos, iphdr->_v_hl);
    55da:	eb04 4413 	add.w	r4, r4, r3, lsr #16
		IPH_LEN_SET(iphdr, htons(p->tot_len));
    55de:	47d8      	blx	fp
#if CHECKSUM_GEN_IP_INLINE
		chk_sum += iphdr->_len;
#endif /* CHECKSUM_GEN_IP_INLINE */
		IPH_OFFSET_SET(iphdr, 0);
    55e0:	f885 a006 	strb.w	sl, [r5, #6]
    55e4:	f885 a007 	strb.w	sl, [r5, #7]
		IPH_ID_SET(iphdr, htons(ip_id));
    55e8:	f8df a080 	ldr.w	sl, [pc, #128]	; 566c <ip_output_if+0xe8>
		IPH_LEN_SET(iphdr, htons(p->tot_len));
    55ec:	8068      	strh	r0, [r5, #2]
		chk_sum += iphdr->_len;
    55ee:	4404      	add	r4, r0
		IPH_ID_SET(iphdr, htons(ip_id));
    55f0:	f8ba 0010 	ldrh.w	r0, [sl, #16]
    55f4:	47d8      	blx	fp
#if CHECKSUM_GEN_IP_INLINE
		chk_sum += iphdr->_id;
#endif /* CHECKSUM_GEN_IP_INLINE */
		++ip_id;
    55f6:	f8ba 2010 	ldrh.w	r2, [sl, #16]
		IPH_ID_SET(iphdr, htons(ip_id));
    55fa:	80a8      	strh	r0, [r5, #4]
		++ip_id;
    55fc:	3201      	adds	r2, #1
    55fe:	f8aa 2010 	strh.w	r2, [sl, #16]

		if (ip_addr_isany(src)) {
    5602:	9a01      	ldr	r2, [sp, #4]
		chk_sum += iphdr->_id;
    5604:	1903      	adds	r3, r0, r4
		if (ip_addr_isany(src)) {
    5606:	b10a      	cbz	r2, 560c <ip_output_if+0x88>
    5608:	6812      	ldr	r2, [r2, #0]
    560a:	b90a      	cbnz	r2, 5610 <ip_output_if+0x8c>
			ip_addr_copy(iphdr->src, netif->ip_addr);
    560c:	f8d8 2004 	ldr.w	r2, [r8, #4]
    5610:	60ea      	str	r2, [r5, #12]
			/* src cannot be NULL here */
			ip_addr_copy(iphdr->src, *src);
		}

#if CHECKSUM_GEN_IP_INLINE
		chk_sum += ip4_addr_get_u32(&iphdr->src) & 0xFFFF;
    5612:	fa13 f382 	uxtah	r3, r3, r2
		chk_sum += ip4_addr_get_u32(&iphdr->src) >> 16;
    5616:	eb03 4312 	add.w	r3, r3, r2, lsr #16
		chk_sum        = (chk_sum >> 16) + (chk_sum & 0xFFFF);
    561a:	b29a      	uxth	r2, r3
    561c:	eb02 4313 	add.w	r3, r2, r3, lsr #16
		chk_sum        = (chk_sum >> 16) + chk_sum;
    5620:	eb03 4313 	add.w	r3, r3, r3, lsr #16
		chk_sum        = ~chk_sum;
    5624:	43db      	mvns	r3, r3
		iphdr->_chksum = chk_sum; /* network order */
    5626:	816b      	strh	r3, [r5, #10]
	}
#endif /* LWIP_IGMP */
#endif /* ENABLE_LOOPBACK */
#if IP_FRAG
	/* don't fragment if interface has mtu set to 0 [loopif] */
	if (netif->mtu && (p->tot_len > netif->mtu)) {
    5628:	f8b8 3024 	ldrh.w	r3, [r8, #36]	; 0x24
    562c:	b17b      	cbz	r3, 564e <ip_output_if+0xca>
    562e:	8932      	ldrh	r2, [r6, #8]
    5630:	429a      	cmp	r2, r3
    5632:	d90c      	bls.n	564e <ip_output_if+0xca>
		return ip_frag(p, netif, dest);
    5634:	4b0b      	ldr	r3, [pc, #44]	; (5664 <ip_output_if+0xe0>)
    5636:	463a      	mov	r2, r7
    5638:	4641      	mov	r1, r8
    563a:	4630      	mov	r0, r6
	}
#endif /* IP_FRAG */

	LWIP_DEBUGF(IP_DEBUG, ("netif->output()"));
	return netif->output(netif, p, dest);
    563c:	4798      	blx	r3
}
    563e:	b005      	add	sp, #20
    5640:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		ip_addr_copy(dest_addr, iphdr->dest);
    5644:	6843      	ldr	r3, [r0, #4]
    5646:	691b      	ldr	r3, [r3, #16]
    5648:	9303      	str	r3, [sp, #12]
		dest = &dest_addr;
    564a:	af03      	add	r7, sp, #12
    564c:	e7ec      	b.n	5628 <ip_output_if+0xa4>
	return netif->output(netif, p, dest);
    564e:	f8d8 3014 	ldr.w	r3, [r8, #20]
    5652:	463a      	mov	r2, r7
    5654:	4631      	mov	r1, r6
    5656:	4640      	mov	r0, r8
    5658:	e7f0      	b.n	563c <ip_output_if+0xb8>
			return ERR_BUF;
    565a:	f06f 0001 	mvn.w	r0, #1
    565e:	e7ee      	b.n	563e <ip_output_if+0xba>
    5660:	00003029 	.word	0x00003029
    5664:	00002dd1 	.word	0x00002dd1
    5668:	00000d65 	.word	0x00000d65
    566c:	200110b0 	.word	0x200110b0

00005670 <ip_output>:
 *
 * @return ERR_RTE if no route is found
 *         see ip_output_if() for more return values
 */
err_t ip_output(struct pbuf *p, ip_addr_t *src, ip_addr_t *dest, u8_t ttl, u8_t tos, u8_t proto)
{
    5670:	b530      	push	{r4, r5, lr}
    5672:	b089      	sub	sp, #36	; 0x24
    5674:	4605      	mov	r5, r0

	/* pbufs passed to IP must have a ref-count of 1 as their payload pointer
	   gets altered as the packet is passed down the stack */
	LWIP_ASSERT("p->ref == 1", p->ref == 1);

	if ((netif = ip_route(dest)) == NULL) {
    5676:	4c0c      	ldr	r4, [pc, #48]	; (56a8 <ip_output+0x38>)
    5678:	9205      	str	r2, [sp, #20]
    567a:	4610      	mov	r0, r2
{
    567c:	e9cd 3106 	strd	r3, r1, [sp, #24]
	if ((netif = ip_route(dest)) == NULL) {
    5680:	47a0      	blx	r4
    5682:	b170      	cbz	r0, 56a2 <ip_output+0x32>
		             ip4_addr4_16(dest)));
		IP_STATS_INC(ip.rterr);
		return ERR_RTE;
	}

	return ip_output_if(p, src, dest, ttl, tos, proto, netif);
    5684:	9002      	str	r0, [sp, #8]
    5686:	f89d 0034 	ldrb.w	r0, [sp, #52]	; 0x34
    568a:	9001      	str	r0, [sp, #4]
    568c:	f89d 0030 	ldrb.w	r0, [sp, #48]	; 0x30
    5690:	9000      	str	r0, [sp, #0]
    5692:	e9dd 2305 	ldrd	r2, r3, [sp, #20]
    5696:	9907      	ldr	r1, [sp, #28]
    5698:	4c04      	ldr	r4, [pc, #16]	; (56ac <ip_output+0x3c>)
    569a:	4628      	mov	r0, r5
    569c:	47a0      	blx	r4
}
    569e:	b009      	add	sp, #36	; 0x24
    56a0:	bd30      	pop	{r4, r5, pc}
		return ERR_RTE;
    56a2:	f06f 0003 	mvn.w	r0, #3
    56a6:	e7fa      	b.n	569e <ip_output+0x2e>
    56a8:	000053ed 	.word	0x000053ed
    56ac:	00005585 	.word	0x00005585

000056b0 <mem_init>:
	struct mem *mem;

	LWIP_ASSERT("Sanity check alignment", (SIZEOF_STRUCT_MEM & (MEM_ALIGNMENT - 1)) == 0);

	/* align the heap */
	ram = (u8_t *)LWIP_MEM_ALIGN(LWIP_RAM_HEAP_POINTER);
    56b0:	4b0c      	ldr	r3, [pc, #48]	; (56e4 <mem_init+0x34>)
    56b2:	480d      	ldr	r0, [pc, #52]	; (56e8 <mem_init+0x38>)
    56b4:	f023 0303 	bic.w	r3, r3, #3
	/* initialize the start of the heap */
	mem       = (struct mem *)(void *)ram;
	mem->next = MEM_SIZE_ALIGNED;
    56b8:	f44f 5260 	mov.w	r2, #14336	; 0x3800
    56bc:	601a      	str	r2, [r3, #0]
	mem->prev = 0;
	mem->used = 0;
    56be:	2200      	movs	r2, #0
    56c0:	711a      	strb	r2, [r3, #4]
	/* initialize the end of the heap */
	ram_end       = (struct mem *)(void *)&ram[MEM_SIZE_ALIGNED];
    56c2:	f503 5260 	add.w	r2, r3, #14336	; 0x3800
    56c6:	6042      	str	r2, [r0, #4]
	ram_end->used = 1;
	ram_end->next = MEM_SIZE_ALIGNED;
    56c8:	f503 5240 	add.w	r2, r3, #12288	; 0x3000
    56cc:	f04f 2138 	mov.w	r1, #939538432	; 0x38003800
    56d0:	f8c2 1800 	str.w	r1, [r2, #2048]	; 0x800
	ram_end->used = 1;
    56d4:	2101      	movs	r1, #1
	ram = (u8_t *)LWIP_MEM_ALIGN(LWIP_RAM_HEAP_POINTER);
    56d6:	6003      	str	r3, [r0, #0]
	ram_end->prev = MEM_SIZE_ALIGNED;

	/* initialize the lowest-free pointer to the start of the heap */
	lfree = (struct mem *)(void *)ram;
    56d8:	6083      	str	r3, [r0, #8]
	ram_end->used = 1;
    56da:	f882 1804 	strb.w	r1, [r2, #2052]	; 0x804

	MEM_STATS_AVAIL(avail, MEM_SIZE_ALIGNED);

	if (sys_mutex_new(&mem_mutex) != ERR_OK) {
    56de:	4b03      	ldr	r3, [pc, #12]	; (56ec <mem_init+0x3c>)
    56e0:	300c      	adds	r0, #12
    56e2:	4718      	bx	r3
    56e4:	200110d7 	.word	0x200110d7
    56e8:	200110c4 	.word	0x200110c4
    56ec:	00006a3d 	.word	0x00006a3d

000056f0 <mem_free>:
 *
 * @param rmem is the data portion of a struct mem as returned by a previous
 *             call to mem_malloc()
 */
void mem_free(void *rmem)
{
    56f0:	b570      	push	{r4, r5, r6, lr}
	struct mem *mem;
	LWIP_MEM_FREE_DECL_PROTECT();

	if (rmem == NULL) {
    56f2:	4604      	mov	r4, r0
    56f4:	2800      	cmp	r0, #0
    56f6:	d041      	beq.n	577c <mem_free+0x8c>
	}
	LWIP_ASSERT("mem_free: sanity check alignment", (((mem_ptr_t)rmem) & (MEM_ALIGNMENT - 1)) == 0);

	LWIP_ASSERT("mem_free: legal memory", (u8_t *)rmem >= (u8_t *)ram && (u8_t *)rmem < (u8_t *)ram_end);

	if ((u8_t *)rmem < (u8_t *)ram || (u8_t *)rmem >= (u8_t *)ram_end) {
    56f8:	4d21      	ldr	r5, [pc, #132]	; (5780 <mem_free+0x90>)
    56fa:	682b      	ldr	r3, [r5, #0]
    56fc:	4283      	cmp	r3, r0
    56fe:	d83d      	bhi.n	577c <mem_free+0x8c>
    5700:	686b      	ldr	r3, [r5, #4]
    5702:	4283      	cmp	r3, r0
    5704:	d93a      	bls.n	577c <mem_free+0x8c>
		MEM_STATS_INC(illegal);
		SYS_ARCH_UNPROTECT(lev);
		return;
	}
	/* protect the heap from concurrent access */
	LWIP_MEM_FREE_PROTECT();
    5706:	4b1f      	ldr	r3, [pc, #124]	; (5784 <mem_free+0x94>)
    5708:	2100      	movs	r1, #0
    570a:	f105 000c 	add.w	r0, r5, #12
    570e:	4798      	blx	r3
	/* Get the corresponding struct mem ... */
	mem = (struct mem *)(void *)((u8_t *)rmem - SIZEOF_STRUCT_MEM);
	/* ... which has to be in a used state ... */
	LWIP_ASSERT("mem_free: mem->used", mem->used);
	/* ... and is now unused. */
	mem->used = 0;
    5710:	2300      	movs	r3, #0
    5712:	f804 3c04 	strb.w	r3, [r4, #-4]

	if (mem < lfree) {
    5716:	68ab      	ldr	r3, [r5, #8]
	nmem = (struct mem *)(void *)&ram[mem->next];
    5718:	f834 0c08 	ldrh.w	r0, [r4, #-8]
	mem = (struct mem *)(void *)((u8_t *)rmem - SIZEOF_STRUCT_MEM);
    571c:	f1a4 0208 	sub.w	r2, r4, #8
	if (mem < lfree) {
    5720:	4293      	cmp	r3, r2
	nmem = (struct mem *)(void *)&ram[mem->next];
    5722:	682b      	ldr	r3, [r5, #0]
		/* the newly freed struct is now the lowest */
		lfree = mem;
    5724:	bf88      	it	hi
    5726:	60aa      	strhi	r2, [r5, #8]
	nmem = (struct mem *)(void *)&ram[mem->next];
    5728:	1819      	adds	r1, r3, r0
	if (mem != nmem && nmem->used == 0 && (u8_t *)nmem != (u8_t *)ram_end) {
    572a:	428a      	cmp	r2, r1
    572c:	d00f      	beq.n	574e <mem_free+0x5e>
    572e:	790e      	ldrb	r6, [r1, #4]
    5730:	b96e      	cbnz	r6, 574e <mem_free+0x5e>
    5732:	686e      	ldr	r6, [r5, #4]
    5734:	42b1      	cmp	r1, r6
    5736:	d00a      	beq.n	574e <mem_free+0x5e>
		if (lfree == nmem) {
    5738:	68ae      	ldr	r6, [r5, #8]
    573a:	42b1      	cmp	r1, r6
		mem->next                                      = nmem->next;
    573c:	5a19      	ldrh	r1, [r3, r0]
    573e:	f824 1c08 	strh.w	r1, [r4, #-8]
		((struct mem *)(void *)&ram[nmem->next])->prev = (mem_size_t)((u8_t *)mem - ram);
    5742:	5a19      	ldrh	r1, [r3, r0]
			lfree = mem;
    5744:	bf08      	it	eq
    5746:	60aa      	streq	r2, [r5, #8]
		((struct mem *)(void *)&ram[nmem->next])->prev = (mem_size_t)((u8_t *)mem - ram);
    5748:	4419      	add	r1, r3
    574a:	1ad0      	subs	r0, r2, r3
    574c:	8048      	strh	r0, [r1, #2]
	pmem = (struct mem *)(void *)&ram[mem->prev];
    574e:	f834 1c06 	ldrh.w	r1, [r4, #-6]
    5752:	1858      	adds	r0, r3, r1
	if (pmem != mem && pmem->used == 0) {
    5754:	4282      	cmp	r2, r0
    5756:	d00c      	beq.n	5772 <mem_free+0x82>
    5758:	7906      	ldrb	r6, [r0, #4]
    575a:	b956      	cbnz	r6, 5772 <mem_free+0x82>
		if (lfree == mem) {
    575c:	68ae      	ldr	r6, [r5, #8]
    575e:	42b2      	cmp	r2, r6
		pmem->next                                    = mem->next;
    5760:	f834 2c08 	ldrh.w	r2, [r4, #-8]
    5764:	525a      	strh	r2, [r3, r1]
		((struct mem *)(void *)&ram[mem->next])->prev = (mem_size_t)((u8_t *)pmem - ram);
    5766:	f834 2c08 	ldrh.w	r2, [r4, #-8]
			lfree = pmem;
    576a:	bf08      	it	eq
    576c:	60a8      	streq	r0, [r5, #8]
		((struct mem *)(void *)&ram[mem->next])->prev = (mem_size_t)((u8_t *)pmem - ram);
    576e:	4413      	add	r3, r2
    5770:	8059      	strh	r1, [r3, #2]
	plug_holes(mem);
#if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
	mem_free_count = 1;
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
	LWIP_MEM_FREE_UNPROTECT();
}
    5772:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	LWIP_MEM_FREE_UNPROTECT();
    5776:	4804      	ldr	r0, [pc, #16]	; (5788 <mem_free+0x98>)
    5778:	4b04      	ldr	r3, [pc, #16]	; (578c <mem_free+0x9c>)
    577a:	4718      	bx	r3
}
    577c:	bd70      	pop	{r4, r5, r6, pc}
    577e:	bf00      	nop
    5780:	200110c4 	.word	0x200110c4
    5784:	00006acd 	.word	0x00006acd
    5788:	200110d0 	.word	0x200110d0
    578c:	00006aad 	.word	0x00006aad

00005790 <mem_trim>:
 * @return for compatibility reasons: is always == rmem, at the moment
 *         or NULL if newsize is > old size, in which case rmem is NOT touched
 *         or freed!
 */
void *mem_trim(void *rmem, mem_size_t newsize)
{
    5790:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	/* use the FREE_PROTECT here: it protects with sem OR SYS_ARCH_PROTECT */
	LWIP_MEM_FREE_DECL_PROTECT();

	/* Expand the size of the allocated memory region so that we can
	   adjust for alignment. */
	newsize = LWIP_MEM_ALIGN_SIZE(newsize);
    5794:	3103      	adds	r1, #3
    5796:	f64f 74fc 	movw	r4, #65532	; 0xfffc
    579a:	400c      	ands	r4, r1

	if (newsize < MIN_SIZE_ALIGNED) {
    579c:	2c0b      	cmp	r4, #11
{
    579e:	4605      	mov	r5, r0
	if (newsize < MIN_SIZE_ALIGNED) {
    57a0:	d904      	bls.n	57ac <mem_trim+0x1c>
		/* every data block must be at least MIN_SIZE_ALIGNED long */
		newsize = MIN_SIZE_ALIGNED;
	}

	if (newsize > MEM_SIZE_ALIGNED) {
    57a2:	f5b4 5f60 	cmp.w	r4, #14336	; 0x3800
    57a6:	d902      	bls.n	57ae <mem_trim+0x1e>
		return NULL;
    57a8:	2500      	movs	r5, #0
    57aa:	e03e      	b.n	582a <mem_trim+0x9a>
		newsize = MIN_SIZE_ALIGNED;
    57ac:	240c      	movs	r4, #12
	}

	LWIP_ASSERT("mem_trim: legal memory", (u8_t *)rmem >= (u8_t *)ram && (u8_t *)rmem < (u8_t *)ram_end);

	if ((u8_t *)rmem < (u8_t *)ram || (u8_t *)rmem >= (u8_t *)ram_end) {
    57ae:	4f2f      	ldr	r7, [pc, #188]	; (586c <mem_trim+0xdc>)
    57b0:	683b      	ldr	r3, [r7, #0]
    57b2:	42ab      	cmp	r3, r5
    57b4:	d839      	bhi.n	582a <mem_trim+0x9a>
    57b6:	687a      	ldr	r2, [r7, #4]
    57b8:	42aa      	cmp	r2, r5
    57ba:	d936      	bls.n	582a <mem_trim+0x9a>
	/* Get the corresponding struct mem ... */
	mem = (struct mem *)(void *)((u8_t *)rmem - SIZEOF_STRUCT_MEM);
	/* ... and its offset pointer */
	ptr = (mem_size_t)((u8_t *)mem - ram);

	size = mem->next - ptr - SIZEOF_STRUCT_MEM;
    57bc:	f835 8c08 	ldrh.w	r8, [r5, #-8]
	mem = (struct mem *)(void *)((u8_t *)rmem - SIZEOF_STRUCT_MEM);
    57c0:	f1a5 0608 	sub.w	r6, r5, #8
	ptr = (mem_size_t)((u8_t *)mem - ram);
    57c4:	1af6      	subs	r6, r6, r3
    57c6:	b2b6      	uxth	r6, r6
	size = mem->next - ptr - SIZEOF_STRUCT_MEM;
    57c8:	f1a8 0808 	sub.w	r8, r8, #8
    57cc:	eba8 0806 	sub.w	r8, r8, r6
    57d0:	fa1f f888 	uxth.w	r8, r8
	LWIP_ASSERT("mem_trim can only shrink memory", newsize <= size);
	if (newsize > size) {
    57d4:	45a0      	cmp	r8, r4
    57d6:	d3e7      	bcc.n	57a8 <mem_trim+0x18>
		/* not supported */
		return NULL;
	}
	if (newsize == size) {
    57d8:	d027      	beq.n	582a <mem_trim+0x9a>
		/* No change in size, simply return */
		return rmem;
	}

	/* protect the heap from concurrent access */
	LWIP_MEM_FREE_PROTECT();
    57da:	4b25      	ldr	r3, [pc, #148]	; (5870 <mem_trim+0xe0>)
    57dc:	2100      	movs	r1, #0
    57de:	f107 000c 	add.w	r0, r7, #12
    57e2:	4798      	blx	r3

	mem2 = (struct mem *)(void *)&ram[mem->next];
    57e4:	683b      	ldr	r3, [r7, #0]
    57e6:	f835 1c08 	ldrh.w	r1, [r5, #-8]
    57ea:	1858      	adds	r0, r3, r1
	if (mem2->used == 0) {
    57ec:	7902      	ldrb	r2, [r0, #4]
    57ee:	b9fa      	cbnz	r2, 5830 <mem_trim+0xa0>
		/* The next struct is unused, we can simply move it at little */
		mem_size_t next;
		/* remember the old next pointer */
		next = mem2->next;
		/* create new struct mem which is moved directly after the shrinked mem */
		ptr2 = ptr + SIZEOF_STRUCT_MEM + newsize;
    57f0:	f106 0208 	add.w	r2, r6, #8
    57f4:	4414      	add	r4, r2
		if (lfree == mem2) {
    57f6:	68ba      	ldr	r2, [r7, #8]
		next = mem2->next;
    57f8:	f833 c001 	ldrh.w	ip, [r3, r1]
		ptr2 = ptr + SIZEOF_STRUCT_MEM + newsize;
    57fc:	b2a1      	uxth	r1, r4
			lfree = (struct mem *)(void *)&ram[ptr2];
    57fe:	fa13 f484 	uxtah	r4, r3, r4
		if (lfree == mem2) {
    5802:	4282      	cmp	r2, r0
		}
		mem2       = (struct mem *)(void *)&ram[ptr2];
		mem2->used = 0;
    5804:	f04f 0200 	mov.w	r2, #0
    5808:	7122      	strb	r2, [r4, #4]
		/* restore the next pointer */
		mem2->next = next;
    580a:	f823 c001 	strh.w	ip, [r3, r1]
		/* link it back to mem */
		mem2->prev = ptr;
    580e:	8066      	strh	r6, [r4, #2]
		/* link mem to it */
		mem->next = ptr2;
    5810:	f825 1c08 	strh.w	r1, [r5, #-8]
		/* last thing to restore linked list: as we have moved mem2,
		 * let 'mem2->next->prev' point to mem2 again. but only if mem2->next is not
		 * the end of the heap */
		if (mem2->next != MEM_SIZE_ALIGNED) {
    5814:	5a5a      	ldrh	r2, [r3, r1]
			lfree = (struct mem *)(void *)&ram[ptr2];
    5816:	bf08      	it	eq
    5818:	60bc      	streq	r4, [r7, #8]
		if (mem2->next != MEM_SIZE_ALIGNED) {
    581a:	f5b2 5f60 	cmp.w	r2, #14336	; 0x3800
    581e:	d001      	beq.n	5824 <mem_trim+0x94>
			((struct mem *)(void *)&ram[mem2->next])->prev = ptr2;
    5820:	4413      	add	r3, r2
    5822:	8059      	strh	r1, [r3, #2]
		  -> the remaining space stays unused since it is too small
		} */
#if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
	mem_free_count = 1;
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
	LWIP_MEM_FREE_UNPROTECT();
    5824:	4813      	ldr	r0, [pc, #76]	; (5874 <mem_trim+0xe4>)
    5826:	4b14      	ldr	r3, [pc, #80]	; (5878 <mem_trim+0xe8>)
    5828:	4798      	blx	r3
	return rmem;
}
    582a:	4628      	mov	r0, r5
    582c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	} else if (newsize + SIZEOF_STRUCT_MEM + MIN_SIZE_ALIGNED <= size) {
    5830:	f104 0214 	add.w	r2, r4, #20
    5834:	b292      	uxth	r2, r2
    5836:	4590      	cmp	r8, r2
    5838:	d3f4      	bcc.n	5824 <mem_trim+0x94>
		ptr2 = ptr + SIZEOF_STRUCT_MEM + newsize;
    583a:	f106 0208 	add.w	r2, r6, #8
		if (mem2 < lfree) {
    583e:	68b8      	ldr	r0, [r7, #8]
		ptr2 = ptr + SIZEOF_STRUCT_MEM + newsize;
    5840:	4414      	add	r4, r2
    5842:	b2a2      	uxth	r2, r4
		mem2 = (struct mem *)(void *)&ram[ptr2];
    5844:	fa13 f484 	uxtah	r4, r3, r4
		if (mem2 < lfree) {
    5848:	42a0      	cmp	r0, r4
		mem2->used = 0;
    584a:	f04f 0000 	mov.w	r0, #0
    584e:	7120      	strb	r0, [r4, #4]
		mem2->next = mem->next;
    5850:	5299      	strh	r1, [r3, r2]
		mem2->prev = ptr;
    5852:	8066      	strh	r6, [r4, #2]
		mem->next  = ptr2;
    5854:	f825 2c08 	strh.w	r2, [r5, #-8]
		if (mem2->next != MEM_SIZE_ALIGNED) {
    5858:	5a99      	ldrh	r1, [r3, r2]
			lfree = mem2;
    585a:	bf88      	it	hi
    585c:	60bc      	strhi	r4, [r7, #8]
		if (mem2->next != MEM_SIZE_ALIGNED) {
    585e:	f5b1 5f60 	cmp.w	r1, #14336	; 0x3800
			((struct mem *)(void *)&ram[mem2->next])->prev = ptr2;
    5862:	bf1c      	itt	ne
    5864:	185b      	addne	r3, r3, r1
    5866:	805a      	strhne	r2, [r3, #2]
    5868:	e7dc      	b.n	5824 <mem_trim+0x94>
    586a:	bf00      	nop
    586c:	200110c4 	.word	0x200110c4
    5870:	00006acd 	.word	0x00006acd
    5874:	200110d0 	.word	0x200110d0
    5878:	00006aad 	.word	0x00006aad

0000587c <mem_malloc>:
 * @return pointer to allocated memory or NULL if no free memory was found.
 *
 * Note that the returned value will always be aligned (as defined by MEM_ALIGNMENT).
 */
void *mem_malloc(mem_size_t size)
{
    587c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
#if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
	u8_t        local_mem_free_count = 0;
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
	LWIP_MEM_ALLOC_DECL_PROTECT();

	if (size == 0) {
    5880:	2800      	cmp	r0, #0
    5882:	d050      	beq.n	5926 <mem_malloc+0xaa>
		return NULL;
	}

	/* Expand the size of the allocated memory region so that we can
	   adjust for alignment. */
	size = LWIP_MEM_ALIGN_SIZE(size);
    5884:	3003      	adds	r0, #3
    5886:	f64f 75fc 	movw	r5, #65532	; 0xfffc
    588a:	4005      	ands	r5, r0

	if (size < MIN_SIZE_ALIGNED) {
    588c:	2d0b      	cmp	r5, #11
    588e:	d904      	bls.n	589a <mem_malloc+0x1e>
		/* every data block must be at least MIN_SIZE_ALIGNED long */
		size = MIN_SIZE_ALIGNED;
	}

	if (size > MEM_SIZE_ALIGNED) {
    5890:	f5b5 5f60 	cmp.w	r5, #14336	; 0x3800
    5894:	d902      	bls.n	589c <mem_malloc+0x20>
		return NULL;
    5896:	2000      	movs	r0, #0
    5898:	e045      	b.n	5926 <mem_malloc+0xaa>
		size = MIN_SIZE_ALIGNED;
    589a:	250c      	movs	r5, #12
		return NULL;
	}

	/* protect the heap from concurrent access */
	sys_mutex_lock(&mem_mutex);
    589c:	4e27      	ldr	r6, [pc, #156]	; (593c <mem_malloc+0xc0>)
    589e:	4b28      	ldr	r3, [pc, #160]	; (5940 <mem_malloc+0xc4>)
    58a0:	2100      	movs	r1, #0
    58a2:	f106 000c 	add.w	r0, r6, #12
    58a6:	4798      	blx	r3
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */

		/* Scan through the heap searching for a free block that is big enough,
		 * beginning with the lowest free block.
		 */
		for (ptr = (mem_size_t)((u8_t *)lfree - ram); ptr < MEM_SIZE_ALIGNED - size;
    58a8:	68b2      	ldr	r2, [r6, #8]
    58aa:	6831      	ldr	r1, [r6, #0]
    58ac:	1a53      	subs	r3, r2, r1
    58ae:	b29b      	uxth	r3, r3
    58b0:	f5c5 5e60 	rsb	lr, r5, #14336	; 0x3800
				local_mem_free_count = 1;
				break;
			}
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */

			if ((!mem->used) && (mem->next - (ptr + SIZEOF_STRUCT_MEM)) >= size) {
    58b4:	f06f 0807 	mvn.w	r8, #7
		for (ptr = (mem_size_t)((u8_t *)lfree - ram); ptr < MEM_SIZE_ALIGNED - size;
    58b8:	4573      	cmp	r3, lr
    58ba:	db03      	blt.n	58c4 <mem_malloc+0x48>
	} while (local_mem_free_count != 0);
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
	LWIP_DEBUGF(MEM_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("mem_malloc: could not allocate %" S16_F " bytes\n", (s16_t)size));
	MEM_STATS_INC(err);
	LWIP_MEM_ALLOC_UNPROTECT();
	sys_mutex_unlock(&mem_mutex);
    58bc:	4821      	ldr	r0, [pc, #132]	; (5944 <mem_malloc+0xc8>)
    58be:	4b22      	ldr	r3, [pc, #136]	; (5948 <mem_malloc+0xcc>)
    58c0:	4798      	blx	r3
	return NULL;
    58c2:	e7e8      	b.n	5896 <mem_malloc+0x1a>
			mem            = (struct mem *)(void *)&ram[ptr];
    58c4:	18cc      	adds	r4, r1, r3
			if ((!mem->used) && (mem->next - (ptr + SIZEOF_STRUCT_MEM)) >= size) {
    58c6:	5ac8      	ldrh	r0, [r1, r3]
    58c8:	f894 c004 	ldrb.w	ip, [r4, #4]
    58cc:	f1bc 0f00 	cmp.w	ip, #0
    58d0:	d131      	bne.n	5936 <mem_malloc+0xba>
    58d2:	eba8 0703 	sub.w	r7, r8, r3
    58d6:	4407      	add	r7, r0
    58d8:	42af      	cmp	r7, r5
    58da:	d32c      	bcc.n	5936 <mem_malloc+0xba>
				if (mem->next - (ptr + SIZEOF_STRUCT_MEM) >= (size + SIZEOF_STRUCT_MEM + MIN_SIZE_ALIGNED)) {
    58dc:	f105 0e14 	add.w	lr, r5, #20
    58e0:	fa1f fe8e 	uxth.w	lr, lr
    58e4:	4577      	cmp	r7, lr
    58e6:	d320      	bcc.n	592a <mem_malloc+0xae>
					ptr2 = ptr + SIZEOF_STRUCT_MEM + size;
    58e8:	3508      	adds	r5, #8
    58ea:	441d      	add	r5, r3
    58ec:	b2af      	uxth	r7, r5
					mem2       = (struct mem *)(void *)&ram[ptr2];
    58ee:	fa11 f585 	uxtah	r5, r1, r5
					mem2->used = 0;
    58f2:	f885 c004 	strb.w	ip, [r5, #4]
					mem2->next = mem->next;
    58f6:	53c8      	strh	r0, [r1, r7]
					mem2->prev = ptr;
    58f8:	806b      	strh	r3, [r5, #2]
					mem->used = 1;
    58fa:	2301      	movs	r3, #1
					mem->next = ptr2;
    58fc:	8027      	strh	r7, [r4, #0]
					mem->used = 1;
    58fe:	7123      	strb	r3, [r4, #4]
					if (mem2->next != MEM_SIZE_ALIGNED) {
    5900:	5bcb      	ldrh	r3, [r1, r7]
    5902:	f5b3 5f60 	cmp.w	r3, #14336	; 0x3800
    5906:	d001      	beq.n	590c <mem_malloc+0x90>
						((struct mem *)(void *)&ram[mem2->next])->prev = ptr2;
    5908:	440b      	add	r3, r1
    590a:	805f      	strh	r7, [r3, #2]
				if (mem == lfree) {
    590c:	42a2      	cmp	r2, r4
    590e:	d105      	bne.n	591c <mem_malloc+0xa0>
					while (cur->used && cur != ram_end) {
    5910:	6873      	ldr	r3, [r6, #4]
    5912:	7910      	ldrb	r0, [r2, #4]
    5914:	b108      	cbz	r0, 591a <mem_malloc+0x9e>
    5916:	4293      	cmp	r3, r2
    5918:	d10a      	bne.n	5930 <mem_malloc+0xb4>
					lfree = cur;
    591a:	60b2      	str	r2, [r6, #8]
				sys_mutex_unlock(&mem_mutex);
    591c:	4809      	ldr	r0, [pc, #36]	; (5944 <mem_malloc+0xc8>)
    591e:	4b0a      	ldr	r3, [pc, #40]	; (5948 <mem_malloc+0xcc>)
    5920:	4798      	blx	r3
				return (u8_t *)mem + SIZEOF_STRUCT_MEM;
    5922:	f104 0008 	add.w	r0, r4, #8
}
    5926:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
					mem->used = 1;
    592a:	2301      	movs	r3, #1
    592c:	7123      	strb	r3, [r4, #4]
    592e:	e7ed      	b.n	590c <mem_malloc+0x90>
						cur = (struct mem *)(void *)&ram[cur->next];
    5930:	8812      	ldrh	r2, [r2, #0]
    5932:	440a      	add	r2, r1
    5934:	e7ed      	b.n	5912 <mem_malloc+0x96>
    5936:	4603      	mov	r3, r0
    5938:	e7be      	b.n	58b8 <mem_malloc+0x3c>
    593a:	bf00      	nop
    593c:	200110c4 	.word	0x200110c4
    5940:	00006acd 	.word	0x00006acd
    5944:	200110d0 	.word	0x200110d0
    5948:	00006aad 	.word	0x00006aad

0000594c <tcp_accept_null>:
	LWIP_UNUSED_ARG(arg);
	LWIP_UNUSED_ARG(pcb);
	LWIP_UNUSED_ARG(err);

	return ERR_ABRT;
}
    594c:	f06f 0009 	mvn.w	r0, #9
    5950:	4770      	bx	lr
	...

00005954 <tcp_new_port>:
 * Allocate a new local TCP port.
 *
 * @return a new (free) local TCP port number
 */
static u16_t tcp_new_port(void)
{
    5954:	b5f0      	push	{r4, r5, r6, r7, lr}
    5956:	4c12      	ldr	r4, [pc, #72]	; (59a0 <tcp_new_port+0x4c>)
    5958:	8823      	ldrh	r3, [r4, #0]
    595a:	f44f 4080 	mov.w	r0, #16384	; 0x4000
	u8_t            i;
	u16_t           n = 0;
	struct tcp_pcb *pcb;

again:
	if (tcp_port++ == TCP_LOCAL_PORT_RANGE_END) {
    595e:	f64f 76ff 	movw	r6, #65535	; 0xffff
    5962:	42b3      	cmp	r3, r6
    5964:	bf18      	it	ne
    5966:	3301      	addne	r3, #1
    5968:	4d0e      	ldr	r5, [pc, #56]	; (59a4 <tcp_new_port+0x50>)
    596a:	bf14      	ite	ne
    596c:	b29b      	uxthne	r3, r3
		tcp_port = TCP_LOCAL_PORT_RANGE_START;
    596e:	f44f 4340 	moveq.w	r3, #49152	; 0xc000
    5972:	2204      	movs	r2, #4
	}
	/* Check all PCB lists. */
	for (i = 0; i < NUM_TCP_PCB_LISTS; i++) {
		for (pcb = *tcp_pcb_lists[i]; pcb != NULL; pcb = pcb->next) {
    5974:	f855 1b04 	ldr.w	r1, [r5], #4
    5978:	6809      	ldr	r1, [r1, #0]
    597a:	b931      	cbnz	r1, 598a <tcp_new_port+0x36>
	for (i = 0; i < NUM_TCP_PCB_LISTS; i++) {
    597c:	3a01      	subs	r2, #1
    597e:	f012 02ff 	ands.w	r2, r2, #255	; 0xff
    5982:	d1f7      	bne.n	5974 <tcp_new_port+0x20>
    5984:	8023      	strh	r3, [r4, #0]
				}
				goto again;
			}
		}
	}
	return tcp_port;
    5986:	4618      	mov	r0, r3
    5988:	e007      	b.n	599a <tcp_new_port+0x46>
			if (pcb->local_port == tcp_port) {
    598a:	8b4f      	ldrh	r7, [r1, #26]
    598c:	429f      	cmp	r7, r3
    598e:	d105      	bne.n	599c <tcp_new_port+0x48>
				if (++n > (TCP_LOCAL_PORT_RANGE_END - TCP_LOCAL_PORT_RANGE_START)) {
    5990:	3801      	subs	r0, #1
    5992:	b280      	uxth	r0, r0
    5994:	2800      	cmp	r0, #0
    5996:	d1e4      	bne.n	5962 <tcp_new_port+0xe>
    5998:	8023      	strh	r3, [r4, #0]
}
    599a:	bdf0      	pop	{r4, r5, r6, r7, pc}
		for (pcb = *tcp_pcb_lists[i]; pcb != NULL; pcb = pcb->next) {
    599c:	68c9      	ldr	r1, [r1, #12]
    599e:	e7ec      	b.n	597a <tcp_new_port+0x26>
    59a0:	20000008 	.word	0x20000008
    59a4:	0000a8b4 	.word	0x0000a8b4

000059a8 <tcp_init>:
}
    59a8:	4770      	bx	lr
	...

000059ac <tcp_bind>:
{
    59ac:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	LWIP_ERROR("tcp_bind: can only bind in state CLOSED", pcb->state == CLOSED, return ERR_VAL);
    59ae:	7e03      	ldrb	r3, [r0, #24]
{
    59b0:	4604      	mov	r4, r0
    59b2:	460d      	mov	r5, r1
	LWIP_ERROR("tcp_bind: can only bind in state CLOSED", pcb->state == CLOSED, return ERR_VAL);
    59b4:	b103      	cbz	r3, 59b8 <tcp_bind+0xc>
    59b6:	e7fe      	b.n	59b6 <tcp_bind+0xa>
	if (port == 0) {
    59b8:	b91a      	cbnz	r2, 59c2 <tcp_bind+0x16>
		port = tcp_new_port();
    59ba:	4b16      	ldr	r3, [pc, #88]	; (5a14 <tcp_bind+0x68>)
    59bc:	4798      	blx	r3
		if (port == 0) {
    59be:	4602      	mov	r2, r0
    59c0:	b308      	cbz	r0, 5a06 <tcp_bind+0x5a>
	for (i = 0; i < max_pcb_list; i++) {
    59c2:	4815      	ldr	r0, [pc, #84]	; (5a18 <tcp_bind+0x6c>)
    59c4:	2100      	movs	r1, #0
		for (cpcb = *tcp_pcb_lists[i]; cpcb != NULL; cpcb = cpcb->next) {
    59c6:	f850 3b04 	ldr.w	r3, [r0], #4
    59ca:	681b      	ldr	r3, [r3, #0]
    59cc:	b97b      	cbnz	r3, 59ee <tcp_bind+0x42>
	for (i = 0; i < max_pcb_list; i++) {
    59ce:	3101      	adds	r1, #1
    59d0:	2904      	cmp	r1, #4
    59d2:	d1f8      	bne.n	59c6 <tcp_bind+0x1a>
	if (!ip_addr_isany(ipaddr)) {
    59d4:	b115      	cbz	r5, 59dc <tcp_bind+0x30>
    59d6:	682b      	ldr	r3, [r5, #0]
    59d8:	b103      	cbz	r3, 59dc <tcp_bind+0x30>
		pcb->local_ip = *ipaddr;
    59da:	6023      	str	r3, [r4, #0]
	TCP_REG(&tcp_bound_pcbs, pcb);
    59dc:	4b0f      	ldr	r3, [pc, #60]	; (5a1c <tcp_bind+0x70>)
	pcb->local_port = port;
    59de:	8362      	strh	r2, [r4, #26]
	TCP_REG(&tcp_bound_pcbs, pcb);
    59e0:	681a      	ldr	r2, [r3, #0]
    59e2:	60e2      	str	r2, [r4, #12]
    59e4:	601c      	str	r4, [r3, #0]
    59e6:	4b0e      	ldr	r3, [pc, #56]	; (5a20 <tcp_bind+0x74>)
    59e8:	4798      	blx	r3
	return ERR_OK;
    59ea:	2000      	movs	r0, #0
}
    59ec:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
			if (cpcb->local_port == port) {
    59ee:	8b5e      	ldrh	r6, [r3, #26]
    59f0:	4296      	cmp	r6, r2
    59f2:	d106      	bne.n	5a02 <tcp_bind+0x56>
					if (ip_addr_isany(&(cpcb->local_ip)) || ip_addr_isany(ipaddr)
    59f4:	681f      	ldr	r7, [r3, #0]
    59f6:	b14f      	cbz	r7, 5a0c <tcp_bind+0x60>
    59f8:	b145      	cbz	r5, 5a0c <tcp_bind+0x60>
    59fa:	682e      	ldr	r6, [r5, #0]
    59fc:	b136      	cbz	r6, 5a0c <tcp_bind+0x60>
					    || ip_addr_cmp(&(cpcb->local_ip), ipaddr)) {
    59fe:	42b7      	cmp	r7, r6
    5a00:	d004      	beq.n	5a0c <tcp_bind+0x60>
		for (cpcb = *tcp_pcb_lists[i]; cpcb != NULL; cpcb = cpcb->next) {
    5a02:	68db      	ldr	r3, [r3, #12]
    5a04:	e7e2      	b.n	59cc <tcp_bind+0x20>
			return ERR_BUF;
    5a06:	f06f 0001 	mvn.w	r0, #1
    5a0a:	e7ef      	b.n	59ec <tcp_bind+0x40>
						return ERR_USE;
    5a0c:	f06f 0007 	mvn.w	r0, #7
    5a10:	e7ec      	b.n	59ec <tcp_bind+0x40>
    5a12:	bf00      	nop
    5a14:	00005955 	.word	0x00005955
    5a18:	0000a8b4 	.word	0x0000a8b4
    5a1c:	200148e8 	.word	0x200148e8
    5a20:	000010a5 	.word	0x000010a5

00005a24 <tcp_listen_with_backlog>:
{
    5a24:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	LWIP_ERROR("tcp_listen: pcb already connected", pcb->state == CLOSED, return NULL);
    5a26:	7e07      	ldrb	r7, [r0, #24]
{
    5a28:	4604      	mov	r4, r0
	LWIP_ERROR("tcp_listen: pcb already connected", pcb->state == CLOSED, return NULL);
    5a2a:	b107      	cbz	r7, 5a2e <tcp_listen_with_backlog+0xa>
    5a2c:	e7fe      	b.n	5a2c <tcp_listen_with_backlog+0x8>
	lpcb = (struct tcp_pcb_listen *)memp_malloc(MEMP_TCP_PCB_LISTEN);
    5a2e:	4b1f      	ldr	r3, [pc, #124]	; (5aac <tcp_listen_with_backlog+0x88>)
    5a30:	2002      	movs	r0, #2
    5a32:	4798      	blx	r3
	if (lpcb == NULL) {
    5a34:	4605      	mov	r5, r0
    5a36:	b328      	cbz	r0, 5a84 <tcp_listen_with_backlog+0x60>
	lpcb->callback_arg = pcb->callback_arg;
    5a38:	6923      	ldr	r3, [r4, #16]
	lpcb->local_port   = pcb->local_port;
    5a3a:	8b62      	ldrh	r2, [r4, #26]
	lpcb->callback_arg = pcb->callback_arg;
    5a3c:	6103      	str	r3, [r0, #16]
	lpcb->state        = LISTEN;
    5a3e:	2301      	movs	r3, #1
    5a40:	7603      	strb	r3, [r0, #24]
	lpcb->local_port   = pcb->local_port;
    5a42:	8342      	strh	r2, [r0, #26]
	lpcb->prio         = pcb->prio;
    5a44:	7e63      	ldrb	r3, [r4, #25]
    5a46:	7643      	strb	r3, [r0, #25]
	ip_set_option(lpcb, SOF_ACCEPTCONN);
    5a48:	7a23      	ldrb	r3, [r4, #8]
    5a4a:	4e19      	ldr	r6, [pc, #100]	; (5ab0 <tcp_listen_with_backlog+0x8c>)
    5a4c:	f043 0302 	orr.w	r3, r3, #2
    5a50:	7203      	strb	r3, [r0, #8]
	lpcb->ttl = pcb->ttl;
    5a52:	7aa3      	ldrb	r3, [r4, #10]
    5a54:	7283      	strb	r3, [r0, #10]
	lpcb->tos = pcb->tos;
    5a56:	7a63      	ldrb	r3, [r4, #9]
    5a58:	7243      	strb	r3, [r0, #9]
	ip_addr_copy(lpcb->local_ip, pcb->local_ip);
    5a5a:	6823      	ldr	r3, [r4, #0]
    5a5c:	6003      	str	r3, [r0, #0]
	if (pcb->local_port != 0) {
    5a5e:	b132      	cbz	r2, 5a6e <tcp_listen_with_backlog+0x4a>
		TCP_RMV(&tcp_bound_pcbs, pcb);
    5a60:	6833      	ldr	r3, [r6, #0]
    5a62:	42a3      	cmp	r3, r4
    5a64:	d110      	bne.n	5a88 <tcp_listen_with_backlog+0x64>
    5a66:	68e3      	ldr	r3, [r4, #12]
    5a68:	6033      	str	r3, [r6, #0]
    5a6a:	2300      	movs	r3, #0
    5a6c:	60e3      	str	r3, [r4, #12]
	memp_free(MEMP_TCP_PCB, pcb);
    5a6e:	4b11      	ldr	r3, [pc, #68]	; (5ab4 <tcp_listen_with_backlog+0x90>)
    5a70:	4621      	mov	r1, r4
    5a72:	2001      	movs	r0, #1
    5a74:	4798      	blx	r3
	lpcb->accept = tcp_accept_null;
    5a76:	4b10      	ldr	r3, [pc, #64]	; (5ab8 <tcp_listen_with_backlog+0x94>)
    5a78:	616b      	str	r3, [r5, #20]
	TCP_REG(&tcp_listen_pcbs.pcbs, (struct tcp_pcb *)lpcb);
    5a7a:	68b3      	ldr	r3, [r6, #8]
    5a7c:	60eb      	str	r3, [r5, #12]
    5a7e:	4b0f      	ldr	r3, [pc, #60]	; (5abc <tcp_listen_with_backlog+0x98>)
    5a80:	60b5      	str	r5, [r6, #8]
    5a82:	4798      	blx	r3
}
    5a84:	4628      	mov	r0, r5
    5a86:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		TCP_RMV(&tcp_bound_pcbs, pcb);
    5a88:	6073      	str	r3, [r6, #4]
    5a8a:	b91b      	cbnz	r3, 5a94 <tcp_listen_with_backlog+0x70>
    5a8c:	2f00      	cmp	r7, #0
    5a8e:	d0ec      	beq.n	5a6a <tcp_listen_with_backlog+0x46>
    5a90:	6073      	str	r3, [r6, #4]
    5a92:	e7ea      	b.n	5a6a <tcp_listen_with_backlog+0x46>
    5a94:	68d9      	ldr	r1, [r3, #12]
    5a96:	42a1      	cmp	r1, r4
    5a98:	d104      	bne.n	5aa4 <tcp_listen_with_backlog+0x80>
    5a9a:	b107      	cbz	r7, 5a9e <tcp_listen_with_backlog+0x7a>
    5a9c:	6073      	str	r3, [r6, #4]
    5a9e:	68e2      	ldr	r2, [r4, #12]
    5aa0:	60da      	str	r2, [r3, #12]
    5aa2:	e7e2      	b.n	5a6a <tcp_listen_with_backlog+0x46>
    5aa4:	2701      	movs	r7, #1
    5aa6:	460b      	mov	r3, r1
    5aa8:	e7ef      	b.n	5a8a <tcp_listen_with_backlog+0x66>
    5aaa:	bf00      	nop
    5aac:	00004b2d 	.word	0x00004b2d
    5ab0:	200148e8 	.word	0x200148e8
    5ab4:	00004b49 	.word	0x00004b49
    5ab8:	0000594d 	.word	0x0000594d
    5abc:	000010a5 	.word	0x000010a5

00005ac0 <tcp_update_rcv_ann_wnd>:
{
    5ac0:	4602      	mov	r2, r0
    5ac2:	b5f0      	push	{r4, r5, r6, r7, lr}
	if (TCP_SEQ_GEQ(new_right_edge, pcb->rcv_ann_right_edge + LWIP_MIN((TCP_WND / 2), pcb->mss))) {
    5ac4:	6b01      	ldr	r1, [r0, #48]	; 0x30
	u32_t new_right_edge = pcb->rcv_nxt + pcb->rcv_wnd;
    5ac6:	8d85      	ldrh	r5, [r0, #44]	; 0x2c
	if (TCP_SEQ_GEQ(new_right_edge, pcb->rcv_ann_right_edge + LWIP_MIN((TCP_WND / 2), pcb->mss))) {
    5ac8:	8ed7      	ldrh	r7, [r2, #54]	; 0x36
	u32_t new_right_edge = pcb->rcv_nxt + pcb->rcv_wnd;
    5aca:	6a84      	ldr	r4, [r0, #40]	; 0x28
	if (TCP_SEQ_GEQ(new_right_edge, pcb->rcv_ann_right_edge + LWIP_MIN((TCP_WND / 2), pcb->mss))) {
    5acc:	1a6b      	subs	r3, r5, r1
    5ace:	f640 3668 	movw	r6, #2920	; 0xb68
    5ad2:	42b7      	cmp	r7, r6
    5ad4:	eb03 0004 	add.w	r0, r3, r4
    5ad8:	bf94      	ite	ls
    5ada:	1bc3      	subls	r3, r0, r7
    5adc:	1b83      	subhi	r3, r0, r6
    5ade:	2b00      	cmp	r3, #0
    5ae0:	db01      	blt.n	5ae6 <tcp_update_rcv_ann_wnd+0x26>
		pcb->rcv_ann_wnd = pcb->rcv_wnd;
    5ae2:	85d5      	strh	r5, [r2, #46]	; 0x2e
}
    5ae4:	bdf0      	pop	{r4, r5, r6, r7, pc}
		if (TCP_SEQ_GT(pcb->rcv_nxt, pcb->rcv_ann_right_edge)) {
    5ae6:	1a63      	subs	r3, r4, r1
    5ae8:	2b00      	cmp	r3, #0
    5aea:	f04f 0000 	mov.w	r0, #0
			u32_t new_rcv_ann_wnd = pcb->rcv_ann_right_edge - pcb->rcv_nxt;
    5aee:	bfd6      	itet	le
    5af0:	1b09      	suble	r1, r1, r4
			pcb->rcv_ann_wnd = 0;
    5af2:	85d0      	strhgt	r0, [r2, #46]	; 0x2e
			pcb->rcv_ann_wnd = (u16_t)new_rcv_ann_wnd;
    5af4:	85d1      	strhle	r1, [r2, #46]	; 0x2e
    5af6:	e7f5      	b.n	5ae4 <tcp_update_rcv_ann_wnd+0x24>

00005af8 <tcp_recved>:
	pcb->rcv_wnd += len;
    5af8:	8d83      	ldrh	r3, [r0, #44]	; 0x2c
    5afa:	4419      	add	r1, r3
    5afc:	b289      	uxth	r1, r1
	if (pcb->rcv_wnd > TCP_WND) {
    5afe:	f241 63d0 	movw	r3, #5840	; 0x16d0
    5b02:	4299      	cmp	r1, r3
{
    5b04:	b510      	push	{r4, lr}
		pcb->rcv_wnd = TCP_WND;
    5b06:	bf8c      	ite	hi
    5b08:	8583      	strhhi	r3, [r0, #44]	; 0x2c
	pcb->rcv_wnd += len;
    5b0a:	8581      	strhls	r1, [r0, #44]	; 0x2c
	wnd_inflation = tcp_update_rcv_ann_wnd(pcb);
    5b0c:	4b08      	ldr	r3, [pc, #32]	; (5b30 <tcp_recved+0x38>)
{
    5b0e:	4604      	mov	r4, r0
	wnd_inflation = tcp_update_rcv_ann_wnd(pcb);
    5b10:	4798      	blx	r3
	if (wnd_inflation >= TCP_WND_UPDATE_THRESHOLD) {
    5b12:	f240 53b3 	movw	r3, #1459	; 0x5b3
    5b16:	4298      	cmp	r0, r3
    5b18:	dd08      	ble.n	5b2c <tcp_recved+0x34>
		tcp_ack_now(pcb);
    5b1a:	7fa3      	ldrb	r3, [r4, #30]
    5b1c:	f043 0302 	orr.w	r3, r3, #2
    5b20:	77a3      	strb	r3, [r4, #30]
		tcp_output(pcb);
    5b22:	4620      	mov	r0, r4
    5b24:	4b03      	ldr	r3, [pc, #12]	; (5b34 <tcp_recved+0x3c>)
}
    5b26:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		tcp_output(pcb);
    5b2a:	4718      	bx	r3
}
    5b2c:	bd10      	pop	{r4, pc}
    5b2e:	bf00      	nop
    5b30:	00005ac1 	.word	0x00005ac1
    5b34:	00002441 	.word	0x00002441

00005b38 <tcp_seg_free>:
 * Frees a TCP segment (tcp_seg structure).
 *
 * @param seg single tcp_seg to free
 */
void tcp_seg_free(struct tcp_seg *seg)
{
    5b38:	b510      	push	{r4, lr}
	if (seg != NULL) {
    5b3a:	4604      	mov	r4, r0
    5b3c:	b148      	cbz	r0, 5b52 <tcp_seg_free+0x1a>
		if (seg->p != NULL) {
    5b3e:	6840      	ldr	r0, [r0, #4]
    5b40:	b108      	cbz	r0, 5b46 <tcp_seg_free+0xe>
			pbuf_free(seg->p);
    5b42:	4b04      	ldr	r3, [pc, #16]	; (5b54 <tcp_seg_free+0x1c>)
    5b44:	4798      	blx	r3
#if TCP_DEBUG
			seg->p = NULL;
#endif /* TCP_DEBUG */
		}
		memp_free(MEMP_TCP_SEG, seg);
    5b46:	4621      	mov	r1, r4
    5b48:	4b03      	ldr	r3, [pc, #12]	; (5b58 <tcp_seg_free+0x20>)
	}
}
    5b4a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		memp_free(MEMP_TCP_SEG, seg);
    5b4e:	2003      	movs	r0, #3
    5b50:	4718      	bx	r3
}
    5b52:	bd10      	pop	{r4, pc}
    5b54:	00003081 	.word	0x00003081
    5b58:	00004b49 	.word	0x00004b49

00005b5c <tcp_segs_free>:
{
    5b5c:	b538      	push	{r3, r4, r5, lr}
		tcp_seg_free(seg);
    5b5e:	4c03      	ldr	r4, [pc, #12]	; (5b6c <tcp_segs_free+0x10>)
	while (seg != NULL) {
    5b60:	b900      	cbnz	r0, 5b64 <tcp_segs_free+0x8>
}
    5b62:	bd38      	pop	{r3, r4, r5, pc}
		struct tcp_seg *next = seg->next;
    5b64:	6805      	ldr	r5, [r0, #0]
		tcp_seg_free(seg);
    5b66:	47a0      	blx	r4
		seg = next;
    5b68:	4628      	mov	r0, r5
    5b6a:	e7f9      	b.n	5b60 <tcp_segs_free+0x4>
    5b6c:	00005b39 	.word	0x00005b39

00005b70 <tcp_seg_copy>:
 *
 * @param seg the old tcp_seg
 * @return a copy of seg
 */
struct tcp_seg *tcp_seg_copy(struct tcp_seg *seg)
{
    5b70:	b538      	push	{r3, r4, r5, lr}
	struct tcp_seg *cseg;

	cseg = (struct tcp_seg *)memp_malloc(MEMP_TCP_SEG);
    5b72:	4b0a      	ldr	r3, [pc, #40]	; (5b9c <tcp_seg_copy+0x2c>)
{
    5b74:	4604      	mov	r4, r0
	cseg = (struct tcp_seg *)memp_malloc(MEMP_TCP_SEG);
    5b76:	2003      	movs	r0, #3
    5b78:	4798      	blx	r3
	if (cseg == NULL) {
    5b7a:	4605      	mov	r5, r0
    5b7c:	b160      	cbz	r0, 5b98 <tcp_seg_copy+0x28>
		return NULL;
	}
	SMEMCPY((u8_t *)cseg, (const u8_t *)seg, sizeof(struct tcp_seg));
    5b7e:	4623      	mov	r3, r4
    5b80:	4602      	mov	r2, r0
    5b82:	f104 0110 	add.w	r1, r4, #16
    5b86:	f853 0b04 	ldr.w	r0, [r3], #4
    5b8a:	f842 0b04 	str.w	r0, [r2], #4
    5b8e:	428b      	cmp	r3, r1
    5b90:	d1f9      	bne.n	5b86 <tcp_seg_copy+0x16>
	pbuf_ref(cseg->p);
    5b92:	6868      	ldr	r0, [r5, #4]
    5b94:	4b02      	ldr	r3, [pc, #8]	; (5ba0 <tcp_seg_copy+0x30>)
    5b96:	4798      	blx	r3
	return cseg;
}
    5b98:	4628      	mov	r0, r5
    5b9a:	bd38      	pop	{r3, r4, r5, pc}
    5b9c:	00004b2d 	.word	0x00004b2d
    5ba0:	0000324d 	.word	0x0000324d

00005ba4 <tcp_arg>:
 */
void tcp_arg(struct tcp_pcb *pcb, void *arg)
{
	/* This function is allowed to be called for both listen pcbs and
	   connection pcbs. */
	pcb->callback_arg = arg;
    5ba4:	6101      	str	r1, [r0, #16]
}
    5ba6:	4770      	bx	lr

00005ba8 <tcp_recv>:
 * @param recv callback function to call for this pcb when data is received
 */
void tcp_recv(struct tcp_pcb *pcb, tcp_recv_fn recv)
{
	LWIP_ASSERT("invalid socket state for recv callback", pcb->state != LISTEN);
	pcb->recv = recv;
    5ba8:	f8c0 1080 	str.w	r1, [r0, #128]	; 0x80
}
    5bac:	4770      	bx	lr

00005bae <tcp_sent>:
 * @param sent callback function to call for this pcb when data is successfully sent
 */
void tcp_sent(struct tcp_pcb *pcb, tcp_sent_fn sent)
{
	LWIP_ASSERT("invalid socket state for sent callback", pcb->state != LISTEN);
	pcb->sent = sent;
    5bae:	67c1      	str	r1, [r0, #124]	; 0x7c
}
    5bb0:	4770      	bx	lr

00005bb2 <tcp_err>:
 *        has occured on the connection
 */
void tcp_err(struct tcp_pcb *pcb, tcp_err_fn err)
{
	LWIP_ASSERT("invalid socket state for err callback", pcb->state != LISTEN);
	pcb->errf = err;
    5bb2:	f8c0 108c 	str.w	r1, [r0, #140]	; 0x8c
}
    5bb6:	4770      	bx	lr

00005bb8 <tcp_accept>:
 */
void tcp_accept(struct tcp_pcb *pcb, tcp_accept_fn accept)
{
	/* This function is allowed to be called for both listen pcbs and
	   connection pcbs. */
	pcb->accept = accept;
    5bb8:	6141      	str	r1, [r0, #20]
}
    5bba:	4770      	bx	lr

00005bbc <tcp_poll>:
 */
void tcp_poll(struct tcp_pcb *pcb, tcp_poll_fn poll, u8_t interval)
{
	LWIP_ASSERT("invalid socket state for poll", pcb->state != LISTEN);
#if LWIP_CALLBACK_API
	pcb->poll = poll;
    5bbc:	f8c0 1088 	str.w	r1, [r0, #136]	; 0x88
#else  /* LWIP_CALLBACK_API */
	LWIP_UNUSED_ARG(poll);
#endif /* LWIP_CALLBACK_API */
	pcb->pollinterval = interval;
    5bc0:	f880 2020 	strb.w	r2, [r0, #32]
}
    5bc4:	4770      	bx	lr
	...

00005bc8 <tcp_pcb_purge>:
 * (pcb->ooseq, pcb->unsent and pcb->unacked are freed).
 *
 * @param pcb tcp_pcb to purge. The pcb itself is not deallocated!
 */
void tcp_pcb_purge(struct tcp_pcb *pcb)
{
    5bc8:	b570      	push	{r4, r5, r6, lr}
	if (pcb->state != CLOSED && pcb->state != TIME_WAIT && pcb->state != LISTEN) {
    5bca:	7e03      	ldrb	r3, [r0, #24]
    5bcc:	2b01      	cmp	r3, #1
{
    5bce:	4604      	mov	r4, r0
	if (pcb->state != CLOSED && pcb->state != TIME_WAIT && pcb->state != LISTEN) {
    5bd0:	d917      	bls.n	5c02 <tcp_pcb_purge+0x3a>
    5bd2:	2b0a      	cmp	r3, #10
    5bd4:	d015      	beq.n	5c02 <tcp_pcb_purge+0x3a>
				}
			}
		}
#endif /* TCP_LISTEN_BACKLOG */

		if (pcb->refused_data != NULL) {
    5bd6:	6f80      	ldr	r0, [r0, #120]	; 0x78
    5bd8:	b118      	cbz	r0, 5be2 <tcp_pcb_purge+0x1a>
			LWIP_DEBUGF(TCP_DEBUG, ("tcp_pcb_purge: data left on ->refused_data\n"));
			pbuf_free(pcb->refused_data);
    5bda:	4b0a      	ldr	r3, [pc, #40]	; (5c04 <tcp_pcb_purge+0x3c>)
    5bdc:	4798      	blx	r3
			pcb->refused_data = NULL;
    5bde:	2300      	movs	r3, #0
    5be0:	67a3      	str	r3, [r4, #120]	; 0x78
		}
#if TCP_QUEUE_OOSEQ
		if (pcb->ooseq != NULL) {
			LWIP_DEBUGF(TCP_DEBUG, ("tcp_pcb_purge: data left on ->ooseq\n"));
		}
		tcp_segs_free(pcb->ooseq);
    5be2:	4e09      	ldr	r6, [pc, #36]	; (5c08 <tcp_pcb_purge+0x40>)
    5be4:	6f60      	ldr	r0, [r4, #116]	; 0x74
    5be6:	47b0      	blx	r6
		pcb->ooseq = NULL;
    5be8:	2500      	movs	r5, #0
#endif /* TCP_QUEUE_OOSEQ */

		/* Stop the retransmission timer as it will expect data on unacked
		   queue if it fires */
		pcb->rtime = -1;
    5bea:	f64f 73ff 	movw	r3, #65535	; 0xffff

		tcp_segs_free(pcb->unsent);
    5bee:	6ee0      	ldr	r0, [r4, #108]	; 0x6c
		pcb->rtime = -1;
    5bf0:	86a3      	strh	r3, [r4, #52]	; 0x34
		pcb->ooseq = NULL;
    5bf2:	6765      	str	r5, [r4, #116]	; 0x74
		tcp_segs_free(pcb->unsent);
    5bf4:	47b0      	blx	r6
		tcp_segs_free(pcb->unacked);
    5bf6:	6f20      	ldr	r0, [r4, #112]	; 0x70
    5bf8:	47b0      	blx	r6
		pcb->unacked = pcb->unsent = NULL;
    5bfa:	e9c4 551b 	strd	r5, r5, [r4, #108]	; 0x6c
#if TCP_OVERSIZE
		pcb->unsent_oversize = 0;
    5bfe:	f8a4 506a 	strh.w	r5, [r4, #106]	; 0x6a
#endif /* TCP_OVERSIZE */
	}
}
    5c02:	bd70      	pop	{r4, r5, r6, pc}
    5c04:	00003081 	.word	0x00003081
    5c08:	00005b5d 	.word	0x00005b5d

00005c0c <tcp_slowtmr>:
{
    5c0c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	++tcp_ticks;
    5c10:	4ea4      	ldr	r6, [pc, #656]	; (5ea4 <tcp_slowtmr+0x298>)
			tcp_pcb_purge(pcb);
    5c12:	f8df b294 	ldr.w	fp, [pc, #660]	; 5ea8 <tcp_slowtmr+0x29c>
	++tcp_ticks;
    5c16:	68f3      	ldr	r3, [r6, #12]
			memp_free(MEMP_TCP_PCB, pcb2);
    5c18:	f8df a2ac 	ldr.w	sl, [pc, #684]	; 5ec8 <tcp_slowtmr+0x2bc>
	++tcp_ticks;
    5c1c:	3301      	adds	r3, #1
    5c1e:	60f3      	str	r3, [r6, #12]
	++tcp_timer_ctr;
    5c20:	7c33      	ldrb	r3, [r6, #16]
    5c22:	3301      	adds	r3, #1
{
    5c24:	b085      	sub	sp, #20
	++tcp_timer_ctr;
    5c26:	7433      	strb	r3, [r6, #16]
	pcb  = tcp_active_pcbs;
    5c28:	6974      	ldr	r4, [r6, #20]
				tcp_rst(pcb->snd_nxt, pcb->rcv_nxt, &pcb->local_ip, &pcb->remote_ip, pcb->local_port, pcb->remote_port);
    5c2a:	f8df 92a0 	ldr.w	r9, [pc, #672]	; 5ecc <tcp_slowtmr+0x2c0>
	prev = NULL;
    5c2e:	f04f 0800 	mov.w	r8, #0
	while (pcb != NULL) {
    5c32:	b94c      	cbnz	r4, 5c48 <tcp_slowtmr+0x3c>
	pcb  = tcp_tw_pcbs;
    5c34:	69f5      	ldr	r5, [r6, #28]
			tcp_pcb_purge(pcb);
    5c36:	4f9c      	ldr	r7, [pc, #624]	; (5ea8 <tcp_slowtmr+0x29c>)
			memp_free(MEMP_TCP_PCB, pcb2);
    5c38:	f8df 828c 	ldr.w	r8, [pc, #652]	; 5ec8 <tcp_slowtmr+0x2bc>
	while (pcb != NULL) {
    5c3c:	2d00      	cmp	r5, #0
    5c3e:	f040 811b 	bne.w	5e78 <tcp_slowtmr+0x26c>
}
    5c42:	b005      	add	sp, #20
    5c44:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		if (pcb->last_timer == tcp_timer_ctr) {
    5c48:	7c33      	ldrb	r3, [r6, #16]
    5c4a:	f894 2021 	ldrb.w	r2, [r4, #33]	; 0x21
    5c4e:	429a      	cmp	r2, r3
    5c50:	d102      	bne.n	5c58 <tcp_slowtmr+0x4c>
			pcb = pcb->next;
    5c52:	68e7      	ldr	r7, [r4, #12]
			continue;
    5c54:	463c      	mov	r4, r7
    5c56:	e7ec      	b.n	5c32 <tcp_slowtmr+0x26>
		if (pcb->state == SYN_SENT && pcb->nrtx == TCP_SYNMAXRTX) {
    5c58:	7e22      	ldrb	r2, [r4, #24]
    5c5a:	f894 1046 	ldrb.w	r1, [r4, #70]	; 0x46
		pcb->last_timer = tcp_timer_ctr;
    5c5e:	f884 3021 	strb.w	r3, [r4, #33]	; 0x21
		if (pcb->state == SYN_SENT && pcb->nrtx == TCP_SYNMAXRTX) {
    5c62:	2a02      	cmp	r2, #2
    5c64:	d102      	bne.n	5c6c <tcp_slowtmr+0x60>
    5c66:	2906      	cmp	r1, #6
    5c68:	f000 80ca 	beq.w	5e00 <tcp_slowtmr+0x1f4>
		} else if (pcb->nrtx == TCP_MAXRTX) {
    5c6c:	290c      	cmp	r1, #12
    5c6e:	f000 80c7 	beq.w	5e00 <tcp_slowtmr+0x1f4>
			if (pcb->persist_backoff > 0) {
    5c72:	f894 5095 	ldrb.w	r5, [r4, #149]	; 0x95
    5c76:	2d00      	cmp	r5, #0
    5c78:	f000 8089 	beq.w	5d8e <tcp_slowtmr+0x182>
				if (pcb->persist_cnt >= tcp_persist_backoff[pcb->persist_backoff - 1]) {
    5c7c:	4a8b      	ldr	r2, [pc, #556]	; (5eac <tcp_slowtmr+0x2a0>)
				pcb->persist_cnt++;
    5c7e:	f894 3094 	ldrb.w	r3, [r4, #148]	; 0x94
				if (pcb->persist_cnt >= tcp_persist_backoff[pcb->persist_backoff - 1]) {
    5c82:	442a      	add	r2, r5
				pcb->persist_cnt++;
    5c84:	3301      	adds	r3, #1
				if (pcb->persist_cnt >= tcp_persist_backoff[pcb->persist_backoff - 1]) {
    5c86:	7bd2      	ldrb	r2, [r2, #15]
				pcb->persist_cnt++;
    5c88:	b2db      	uxtb	r3, r3
				if (pcb->persist_cnt >= tcp_persist_backoff[pcb->persist_backoff - 1]) {
    5c8a:	429a      	cmp	r2, r3
				pcb->persist_cnt++;
    5c8c:	f884 3094 	strb.w	r3, [r4, #148]	; 0x94
				if (pcb->persist_cnt >= tcp_persist_backoff[pcb->persist_backoff - 1]) {
    5c90:	d96f      	bls.n	5d72 <tcp_slowtmr+0x166>
		pcb_remove = 0;
    5c92:	2500      	movs	r5, #0
		if (pcb->state == FIN_WAIT_2) {
    5c94:	7e21      	ldrb	r1, [r4, #24]
    5c96:	2906      	cmp	r1, #6
    5c98:	d109      	bne.n	5cae <tcp_slowtmr+0xa2>
			if (pcb->flags & TF_RXCLOSED) {
    5c9a:	7fa3      	ldrb	r3, [r4, #30]
    5c9c:	06db      	lsls	r3, r3, #27
    5c9e:	d506      	bpl.n	5cae <tcp_slowtmr+0xa2>
				if ((u32_t)(tcp_ticks - pcb->tmr) > TCP_FIN_WAIT_TIMEOUT / TCP_SLOW_INTERVAL) {
    5ca0:	68f3      	ldr	r3, [r6, #12]
    5ca2:	6a62      	ldr	r2, [r4, #36]	; 0x24
    5ca4:	1a9b      	subs	r3, r3, r2
    5ca6:	2b28      	cmp	r3, #40	; 0x28
					++pcb_remove;
    5ca8:	bf84      	itt	hi
    5caa:	3501      	addhi	r5, #1
    5cac:	b2ed      	uxtbhi	r5, r5
		if (ip_get_option(pcb, SOF_KEEPALIVE) && ((pcb->state == ESTABLISHED) || (pcb->state == CLOSE_WAIT))) {
    5cae:	7a27      	ldrb	r7, [r4, #8]
    5cb0:	f017 0708 	ands.w	r7, r7, #8
    5cb4:	d017      	beq.n	5ce6 <tcp_slowtmr+0xda>
    5cb6:	2904      	cmp	r1, #4
    5cb8:	d002      	beq.n	5cc0 <tcp_slowtmr+0xb4>
    5cba:	2907      	cmp	r1, #7
    5cbc:	f040 80b3 	bne.w	5e26 <tcp_slowtmr+0x21a>
			if ((u32_t)(tcp_ticks - pcb->tmr) > (pcb->keep_idle + TCP_KEEP_DUR(pcb)) / TCP_SLOW_INTERVAL) {
    5cc0:	6a63      	ldr	r3, [r4, #36]	; 0x24
    5cc2:	68f1      	ldr	r1, [r6, #12]
    5cc4:	1ac9      	subs	r1, r1, r3
    5cc6:	f8d4 3090 	ldr.w	r3, [r4, #144]	; 0x90
    5cca:	f503 2224 	add.w	r2, r3, #671744	; 0xa4000
    5cce:	f602 42b8 	addw	r2, r2, #3256	; 0xcb8
    5cd2:	f44f 70fa 	mov.w	r0, #500	; 0x1f4
    5cd6:	fbb2 f2f0 	udiv	r2, r2, r0
    5cda:	4291      	cmp	r1, r2
    5cdc:	f240 8092 	bls.w	5e04 <tcp_slowtmr+0x1f8>
				++pcb_remove;
    5ce0:	3501      	adds	r5, #1
    5ce2:	b2ed      	uxtb	r5, r5
				++pcb_reset;
    5ce4:	2701      	movs	r7, #1
		if (pcb->ooseq != NULL && (u32_t)tcp_ticks - pcb->tmr >= pcb->rto * TCP_OOSEQ_TIMEOUT) {
    5ce6:	6f60      	ldr	r0, [r4, #116]	; 0x74
    5ce8:	b168      	cbz	r0, 5d06 <tcp_slowtmr+0xfa>
    5cea:	68f3      	ldr	r3, [r6, #12]
    5cec:	6a62      	ldr	r2, [r4, #36]	; 0x24
    5cee:	f9b4 1044 	ldrsh.w	r1, [r4, #68]	; 0x44
    5cf2:	1a9b      	subs	r3, r3, r2
    5cf4:	eb01 0141 	add.w	r1, r1, r1, lsl #1
    5cf8:	ebb3 0f41 	cmp.w	r3, r1, lsl #1
    5cfc:	d303      	bcc.n	5d06 <tcp_slowtmr+0xfa>
			tcp_segs_free(pcb->ooseq);
    5cfe:	4b6c      	ldr	r3, [pc, #432]	; (5eb0 <tcp_slowtmr+0x2a4>)
    5d00:	4798      	blx	r3
			pcb->ooseq = NULL;
    5d02:	2300      	movs	r3, #0
    5d04:	6763      	str	r3, [r4, #116]	; 0x74
		if (pcb->state == SYN_RCVD) {
    5d06:	7e23      	ldrb	r3, [r4, #24]
    5d08:	2b03      	cmp	r3, #3
    5d0a:	f040 808e 	bne.w	5e2a <tcp_slowtmr+0x21e>
			if ((u32_t)(tcp_ticks - pcb->tmr) > TCP_SYN_RCVD_TIMEOUT / TCP_SLOW_INTERVAL) {
    5d0e:	68f3      	ldr	r3, [r6, #12]
    5d10:	6a62      	ldr	r2, [r4, #36]	; 0x24
    5d12:	1a9b      	subs	r3, r3, r2
    5d14:	2b28      	cmp	r3, #40	; 0x28
			if ((u32_t)(tcp_ticks - pcb->tmr) > 2 * TCP_MSL / TCP_SLOW_INTERVAL) {
    5d16:	d802      	bhi.n	5d1e <tcp_slowtmr+0x112>
		if (pcb_remove) {
    5d18:	2d00      	cmp	r5, #0
    5d1a:	f000 8090 	beq.w	5e3e <tcp_slowtmr+0x232>
			tcp_pcb_purge(pcb);
    5d1e:	4620      	mov	r0, r4
    5d20:	47d8      	blx	fp
			if (prev != NULL) {
    5d22:	68e3      	ldr	r3, [r4, #12]
    5d24:	f1b8 0f00 	cmp.w	r8, #0
    5d28:	f000 8087 	beq.w	5e3a <tcp_slowtmr+0x22e>
				prev->next = pcb->next;
    5d2c:	f8c8 300c 	str.w	r3, [r8, #12]
			if (pcb_reset) {
    5d30:	b147      	cbz	r7, 5d44 <tcp_slowtmr+0x138>
				tcp_rst(pcb->snd_nxt, pcb->rcv_nxt, &pcb->local_ip, &pcb->remote_ip, pcb->local_port, pcb->remote_port);
    5d32:	8ba3      	ldrh	r3, [r4, #28]
    5d34:	9301      	str	r3, [sp, #4]
    5d36:	8b63      	ldrh	r3, [r4, #26]
    5d38:	9300      	str	r3, [sp, #0]
    5d3a:	6aa1      	ldr	r1, [r4, #40]	; 0x28
    5d3c:	6d20      	ldr	r0, [r4, #80]	; 0x50
    5d3e:	1d23      	adds	r3, r4, #4
    5d40:	4622      	mov	r2, r4
    5d42:	47c8      	blx	r9
			err_arg = pcb->callback_arg;
    5d44:	6923      	ldr	r3, [r4, #16]
			err_fn  = pcb->errf;
    5d46:	f8d4 508c 	ldr.w	r5, [r4, #140]	; 0x8c
			pcb     = pcb->next;
    5d4a:	68e7      	ldr	r7, [r4, #12]
			err_arg = pcb->callback_arg;
    5d4c:	9303      	str	r3, [sp, #12]
			memp_free(MEMP_TCP_PCB, pcb2);
    5d4e:	4621      	mov	r1, r4
    5d50:	2001      	movs	r0, #1
    5d52:	47d0      	blx	sl
			tcp_active_pcbs_changed = 0;
    5d54:	2200      	movs	r2, #0
    5d56:	7632      	strb	r2, [r6, #24]
			TCP_EVENT_ERR(err_fn, err_arg, ERR_ABRT);
    5d58:	2d00      	cmp	r5, #0
    5d5a:	f43f af7b 	beq.w	5c54 <tcp_slowtmr+0x48>
    5d5e:	9b03      	ldr	r3, [sp, #12]
    5d60:	f06f 0109 	mvn.w	r1, #9
    5d64:	4618      	mov	r0, r3
    5d66:	47a8      	blx	r5
			if (tcp_active_pcbs_changed) {
    5d68:	7e33      	ldrb	r3, [r6, #24]
    5d6a:	2b00      	cmp	r3, #0
    5d6c:	f43f af72 	beq.w	5c54 <tcp_slowtmr+0x48>
    5d70:	e75a      	b.n	5c28 <tcp_slowtmr+0x1c>
					if (pcb->persist_backoff < sizeof(tcp_persist_backoff)) {
    5d72:	2d06      	cmp	r5, #6
					pcb->persist_cnt = 0;
    5d74:	f04f 0300 	mov.w	r3, #0
						pcb->persist_backoff++;
    5d78:	bf98      	it	ls
    5d7a:	3501      	addls	r5, #1
					pcb->persist_cnt = 0;
    5d7c:	f884 3094 	strb.w	r3, [r4, #148]	; 0x94
						pcb->persist_backoff++;
    5d80:	bf98      	it	ls
    5d82:	f884 5095 	strbls.w	r5, [r4, #149]	; 0x95
					tcp_zero_window_probe(pcb);
    5d86:	4b4b      	ldr	r3, [pc, #300]	; (5eb4 <tcp_slowtmr+0x2a8>)
    5d88:	4620      	mov	r0, r4
    5d8a:	4798      	blx	r3
    5d8c:	e781      	b.n	5c92 <tcp_slowtmr+0x86>
				if (pcb->rtime >= 0) {
    5d8e:	f9b4 3034 	ldrsh.w	r3, [r4, #52]	; 0x34
    5d92:	2b00      	cmp	r3, #0
					++pcb->rtime;
    5d94:	bfa4      	itt	ge
    5d96:	3301      	addge	r3, #1
    5d98:	86a3      	strhge	r3, [r4, #52]	; 0x34
				if (pcb->unacked != NULL && pcb->rtime >= pcb->rto) {
    5d9a:	6f23      	ldr	r3, [r4, #112]	; 0x70
    5d9c:	2b00      	cmp	r3, #0
    5d9e:	f43f af78 	beq.w	5c92 <tcp_slowtmr+0x86>
    5da2:	f9b4 0034 	ldrsh.w	r0, [r4, #52]	; 0x34
    5da6:	f9b4 3044 	ldrsh.w	r3, [r4, #68]	; 0x44
    5daa:	4298      	cmp	r0, r3
    5dac:	f6ff af71 	blt.w	5c92 <tcp_slowtmr+0x86>
					if (pcb->state != SYN_SENT) {
    5db0:	2a02      	cmp	r2, #2
    5db2:	d00b      	beq.n	5dcc <tcp_slowtmr+0x1c0>
						pcb->rto = ((pcb->sa >> 3) + pcb->sv) << tcp_backoff[pcb->nrtx];
    5db4:	f9b4 2040 	ldrsh.w	r2, [r4, #64]	; 0x40
    5db8:	f9b4 3042 	ldrsh.w	r3, [r4, #66]	; 0x42
    5dbc:	eb03 03e2 	add.w	r3, r3, r2, asr #3
    5dc0:	4a3a      	ldr	r2, [pc, #232]	; (5eac <tcp_slowtmr+0x2a0>)
    5dc2:	440a      	add	r2, r1
    5dc4:	7dd2      	ldrb	r2, [r2, #23]
    5dc6:	4093      	lsls	r3, r2
    5dc8:	f8a4 3044 	strh.w	r3, [r4, #68]	; 0x44
					pcb->rtime = 0;
    5dcc:	2300      	movs	r3, #0
					eff_wnd       = LWIP_MIN(pcb->cwnd, pcb->snd_wnd);
    5dce:	f8b4 204c 	ldrh.w	r2, [r4, #76]	; 0x4c
					pcb->rtime = 0;
    5dd2:	86a3      	strh	r3, [r4, #52]	; 0x34
					eff_wnd       = LWIP_MIN(pcb->cwnd, pcb->snd_wnd);
    5dd4:	f8b4 3060 	ldrh.w	r3, [r4, #96]	; 0x60
					pcb->ssthresh = eff_wnd >> 1;
    5dd8:	4293      	cmp	r3, r2
    5dda:	bf28      	it	cs
    5ddc:	4613      	movcs	r3, r2
					if (pcb->ssthresh < (pcb->mss << 1)) {
    5dde:	8ee2      	ldrh	r2, [r4, #54]	; 0x36
					pcb->cwnd = pcb->mss;
    5de0:	f8a4 204c 	strh.w	r2, [r4, #76]	; 0x4c
					pcb->ssthresh = eff_wnd >> 1;
    5de4:	085b      	lsrs	r3, r3, #1
					if (pcb->ssthresh < (pcb->mss << 1)) {
    5de6:	ebb3 0f42 	cmp.w	r3, r2, lsl #1
    5dea:	ea4f 0142 	mov.w	r1, r2, lsl #1
					pcb->ssthresh = eff_wnd >> 1;
    5dee:	f8a4 304e 	strh.w	r3, [r4, #78]	; 0x4e
					tcp_rexmit_rto(pcb);
    5df2:	4620      	mov	r0, r4
    5df4:	4b30      	ldr	r3, [pc, #192]	; (5eb8 <tcp_slowtmr+0x2ac>)
						pcb->ssthresh = (pcb->mss << 1);
    5df6:	bfb8      	it	lt
    5df8:	f8a4 104e 	strhlt.w	r1, [r4, #78]	; 0x4e
					tcp_rexmit_rto(pcb);
    5dfc:	4798      	blx	r3
    5dfe:	e749      	b.n	5c94 <tcp_slowtmr+0x88>
			++pcb_remove;
    5e00:	2501      	movs	r5, #1
    5e02:	e747      	b.n	5c94 <tcp_slowtmr+0x88>
			           > (pcb->keep_idle + pcb->keep_cnt_sent * TCP_KEEP_INTVL(pcb)) / TCP_SLOW_INTERVAL) {
    5e04:	f894 2096 	ldrb.w	r2, [r4, #150]	; 0x96
    5e08:	4f2c      	ldr	r7, [pc, #176]	; (5ebc <tcp_slowtmr+0x2b0>)
    5e0a:	fb07 3302 	mla	r3, r7, r2, r3
    5e0e:	fbb3 f3f0 	udiv	r3, r3, r0
			} else if ((u32_t)(tcp_ticks - pcb->tmr)
    5e12:	4299      	cmp	r1, r3
    5e14:	d907      	bls.n	5e26 <tcp_slowtmr+0x21a>
				tcp_keepalive(pcb);
    5e16:	4b2a      	ldr	r3, [pc, #168]	; (5ec0 <tcp_slowtmr+0x2b4>)
    5e18:	4620      	mov	r0, r4
    5e1a:	4798      	blx	r3
				pcb->keep_cnt_sent++;
    5e1c:	f894 3096 	ldrb.w	r3, [r4, #150]	; 0x96
    5e20:	3301      	adds	r3, #1
    5e22:	f884 3096 	strb.w	r3, [r4, #150]	; 0x96
		pcb_reset  = 0;
    5e26:	2700      	movs	r7, #0
    5e28:	e75d      	b.n	5ce6 <tcp_slowtmr+0xda>
		if (pcb->state == LAST_ACK) {
    5e2a:	2b09      	cmp	r3, #9
    5e2c:	f47f af74 	bne.w	5d18 <tcp_slowtmr+0x10c>
			if ((u32_t)(tcp_ticks - pcb->tmr) > 2 * TCP_MSL / TCP_SLOW_INTERVAL) {
    5e30:	68f3      	ldr	r3, [r6, #12]
    5e32:	6a62      	ldr	r2, [r4, #36]	; 0x24
    5e34:	1a9b      	subs	r3, r3, r2
    5e36:	2bf0      	cmp	r3, #240	; 0xf0
    5e38:	e76d      	b.n	5d16 <tcp_slowtmr+0x10a>
				tcp_active_pcbs = pcb->next;
    5e3a:	6173      	str	r3, [r6, #20]
    5e3c:	e778      	b.n	5d30 <tcp_slowtmr+0x124>
			++prev->polltmr;
    5e3e:	7fe3      	ldrb	r3, [r4, #31]
			if (prev->polltmr >= prev->pollinterval) {
    5e40:	f894 2020 	ldrb.w	r2, [r4, #32]
			pcb  = pcb->next;
    5e44:	68e7      	ldr	r7, [r4, #12]
			++prev->polltmr;
    5e46:	3301      	adds	r3, #1
    5e48:	b2db      	uxtb	r3, r3
			if (prev->polltmr >= prev->pollinterval) {
    5e4a:	429a      	cmp	r2, r3
			++prev->polltmr;
    5e4c:	77e3      	strb	r3, [r4, #31]
			if (prev->polltmr >= prev->pollinterval) {
    5e4e:	d807      	bhi.n	5e60 <tcp_slowtmr+0x254>
				TCP_EVENT_POLL(prev, err);
    5e50:	f8d4 3088 	ldr.w	r3, [r4, #136]	; 0x88
				prev->polltmr = 0;
    5e54:	77e5      	strb	r5, [r4, #31]
				tcp_active_pcbs_changed = 0;
    5e56:	7635      	strb	r5, [r6, #24]
				TCP_EVENT_POLL(prev, err);
    5e58:	b923      	cbnz	r3, 5e64 <tcp_slowtmr+0x258>
					tcp_output(prev);
    5e5a:	4b1a      	ldr	r3, [pc, #104]	; (5ec4 <tcp_slowtmr+0x2b8>)
    5e5c:	4620      	mov	r0, r4
    5e5e:	4798      	blx	r3
    5e60:	46a0      	mov	r8, r4
    5e62:	e6f7      	b.n	5c54 <tcp_slowtmr+0x48>
				TCP_EVENT_POLL(prev, err);
    5e64:	6920      	ldr	r0, [r4, #16]
    5e66:	4621      	mov	r1, r4
    5e68:	4798      	blx	r3
				if (tcp_active_pcbs_changed) {
    5e6a:	7e33      	ldrb	r3, [r6, #24]
    5e6c:	2b00      	cmp	r3, #0
    5e6e:	f47f aedb 	bne.w	5c28 <tcp_slowtmr+0x1c>
				if (err == ERR_OK) {
    5e72:	2800      	cmp	r0, #0
    5e74:	d1f4      	bne.n	5e60 <tcp_slowtmr+0x254>
    5e76:	e7f0      	b.n	5e5a <tcp_slowtmr+0x24e>
		if ((u32_t)(tcp_ticks - pcb->tmr) > 2 * TCP_MSL / TCP_SLOW_INTERVAL) {
    5e78:	68f3      	ldr	r3, [r6, #12]
    5e7a:	6a6a      	ldr	r2, [r5, #36]	; 0x24
    5e7c:	1a9b      	subs	r3, r3, r2
    5e7e:	2bf0      	cmp	r3, #240	; 0xf0
    5e80:	d802      	bhi.n	5e88 <tcp_slowtmr+0x27c>
			pcb  = pcb->next;
    5e82:	462c      	mov	r4, r5
    5e84:	68ed      	ldr	r5, [r5, #12]
    5e86:	e6d9      	b.n	5c3c <tcp_slowtmr+0x30>
			tcp_pcb_purge(pcb);
    5e88:	4628      	mov	r0, r5
    5e8a:	47b8      	blx	r7
			if (prev != NULL) {
    5e8c:	68eb      	ldr	r3, [r5, #12]
    5e8e:	b13c      	cbz	r4, 5ea0 <tcp_slowtmr+0x294>
				prev->next = pcb->next;
    5e90:	60e3      	str	r3, [r4, #12]
			pcb  = pcb->next;
    5e92:	f8d5 900c 	ldr.w	r9, [r5, #12]
			memp_free(MEMP_TCP_PCB, pcb2);
    5e96:	4629      	mov	r1, r5
    5e98:	2001      	movs	r0, #1
    5e9a:	47c0      	blx	r8
			pcb  = pcb->next;
    5e9c:	464d      	mov	r5, r9
    5e9e:	e6cd      	b.n	5c3c <tcp_slowtmr+0x30>
				tcp_tw_pcbs = pcb->next;
    5ea0:	61f3      	str	r3, [r6, #28]
    5ea2:	e7f6      	b.n	5e92 <tcp_slowtmr+0x286>
    5ea4:	200148e8 	.word	0x200148e8
    5ea8:	00005bc9 	.word	0x00005bc9
    5eac:	0000a8b4 	.word	0x0000a8b4
    5eb0:	00005b5d 	.word	0x00005b5d
    5eb4:	000028c1 	.word	0x000028c1
    5eb8:	00002775 	.word	0x00002775
    5ebc:	000124f8 	.word	0x000124f8
    5ec0:	00002859 	.word	0x00002859
    5ec4:	00002441 	.word	0x00002441
    5ec8:	00004b49 	.word	0x00004b49
    5ecc:	000026c5 	.word	0x000026c5

00005ed0 <tcp_pcb_remove>:
 * @param pcblist PCB list to purge.
 * @param pcb tcp_pcb to purge. The pcb itself is NOT deallocated!
 */
void tcp_pcb_remove(struct tcp_pcb **pcblist, struct tcp_pcb *pcb)
{
	TCP_RMV(pcblist, pcb);
    5ed0:	6803      	ldr	r3, [r0, #0]
    5ed2:	428b      	cmp	r3, r1
{
    5ed4:	b510      	push	{r4, lr}
    5ed6:	460c      	mov	r4, r1
	TCP_RMV(pcblist, pcb);
    5ed8:	d117      	bne.n	5f0a <tcp_pcb_remove+0x3a>
    5eda:	68cb      	ldr	r3, [r1, #12]
    5edc:	6003      	str	r3, [r0, #0]
    5ede:	2300      	movs	r3, #0
    5ee0:	60e3      	str	r3, [r4, #12]

	tcp_pcb_purge(pcb);
    5ee2:	4620      	mov	r0, r4
    5ee4:	4b12      	ldr	r3, [pc, #72]	; (5f30 <tcp_pcb_remove+0x60>)
    5ee6:	4798      	blx	r3

	/* if there is an outstanding delayed ACKs, send it */
	if (pcb->state != TIME_WAIT && pcb->state != LISTEN && pcb->flags & TF_ACK_DELAY) {
    5ee8:	7e23      	ldrb	r3, [r4, #24]
    5eea:	2b0a      	cmp	r3, #10
    5eec:	d00a      	beq.n	5f04 <tcp_pcb_remove+0x34>
    5eee:	2b01      	cmp	r3, #1
    5ef0:	d008      	beq.n	5f04 <tcp_pcb_remove+0x34>
    5ef2:	7fa3      	ldrb	r3, [r4, #30]
    5ef4:	07da      	lsls	r2, r3, #31
    5ef6:	d505      	bpl.n	5f04 <tcp_pcb_remove+0x34>
		pcb->flags |= TF_ACK_NOW;
    5ef8:	f043 0302 	orr.w	r3, r3, #2
    5efc:	77a3      	strb	r3, [r4, #30]
		tcp_output(pcb);
    5efe:	4620      	mov	r0, r4
    5f00:	4b0c      	ldr	r3, [pc, #48]	; (5f34 <tcp_pcb_remove+0x64>)
    5f02:	4798      	blx	r3
#if TCP_QUEUE_OOSEQ
		LWIP_ASSERT("ooseq segments leaking", pcb->ooseq == NULL);
#endif /* TCP_QUEUE_OOSEQ */
	}

	pcb->state = CLOSED;
    5f04:	2300      	movs	r3, #0
    5f06:	7623      	strb	r3, [r4, #24]

	LWIP_ASSERT("tcp_pcb_remove: tcp_pcbs_sane()", tcp_pcbs_sane());
}
    5f08:	bd10      	pop	{r4, pc}
	TCP_RMV(pcblist, pcb);
    5f0a:	4a0b      	ldr	r2, [pc, #44]	; (5f38 <tcp_pcb_remove+0x68>)
    5f0c:	2100      	movs	r1, #0
    5f0e:	6053      	str	r3, [r2, #4]
    5f10:	b91b      	cbnz	r3, 5f1a <tcp_pcb_remove+0x4a>
    5f12:	2900      	cmp	r1, #0
    5f14:	d0e3      	beq.n	5ede <tcp_pcb_remove+0xe>
    5f16:	6053      	str	r3, [r2, #4]
    5f18:	e7e1      	b.n	5ede <tcp_pcb_remove+0xe>
    5f1a:	68d8      	ldr	r0, [r3, #12]
    5f1c:	42a0      	cmp	r0, r4
    5f1e:	d104      	bne.n	5f2a <tcp_pcb_remove+0x5a>
    5f20:	b101      	cbz	r1, 5f24 <tcp_pcb_remove+0x54>
    5f22:	6053      	str	r3, [r2, #4]
    5f24:	68e2      	ldr	r2, [r4, #12]
    5f26:	60da      	str	r2, [r3, #12]
    5f28:	e7d9      	b.n	5ede <tcp_pcb_remove+0xe>
    5f2a:	2101      	movs	r1, #1
    5f2c:	4603      	mov	r3, r0
    5f2e:	e7ef      	b.n	5f10 <tcp_pcb_remove+0x40>
    5f30:	00005bc9 	.word	0x00005bc9
    5f34:	00002441 	.word	0x00002441
    5f38:	200148e8 	.word	0x200148e8

00005f3c <tcp_close_shutdown>:
{
    5f3c:	b537      	push	{r0, r1, r2, r4, r5, lr}
    5f3e:	4604      	mov	r4, r0
	if (rst_on_unacked_data && ((pcb->state == ESTABLISHED) || (pcb->state == CLOSE_WAIT))) {
    5f40:	7e03      	ldrb	r3, [r0, #24]
    5f42:	2900      	cmp	r1, #0
    5f44:	d040      	beq.n	5fc8 <tcp_close_shutdown+0x8c>
    5f46:	2b04      	cmp	r3, #4
    5f48:	d001      	beq.n	5f4e <tcp_close_shutdown+0x12>
    5f4a:	2b07      	cmp	r3, #7
    5f4c:	d13c      	bne.n	5fc8 <tcp_close_shutdown+0x8c>
		if ((pcb->refused_data != NULL) || (pcb->rcv_wnd != TCP_WND)) {
    5f4e:	6fa2      	ldr	r2, [r4, #120]	; 0x78
    5f50:	b922      	cbnz	r2, 5f5c <tcp_close_shutdown+0x20>
    5f52:	8da1      	ldrh	r1, [r4, #44]	; 0x2c
    5f54:	f241 62d0 	movw	r2, #5840	; 0x16d0
    5f58:	4291      	cmp	r1, r2
    5f5a:	d035      	beq.n	5fc8 <tcp_close_shutdown+0x8c>
			tcp_rst(pcb->snd_nxt, pcb->rcv_nxt, &pcb->local_ip, &pcb->remote_ip, pcb->local_port, pcb->remote_port);
    5f5c:	8ba3      	ldrh	r3, [r4, #28]
    5f5e:	9301      	str	r3, [sp, #4]
    5f60:	8b63      	ldrh	r3, [r4, #26]
    5f62:	6aa1      	ldr	r1, [r4, #40]	; 0x28
    5f64:	6d20      	ldr	r0, [r4, #80]	; 0x50
    5f66:	9300      	str	r3, [sp, #0]
    5f68:	4622      	mov	r2, r4
    5f6a:	1d23      	adds	r3, r4, #4
    5f6c:	4d43      	ldr	r5, [pc, #268]	; (607c <tcp_close_shutdown+0x140>)
    5f6e:	47a8      	blx	r5
			tcp_pcb_purge(pcb);
    5f70:	4b43      	ldr	r3, [pc, #268]	; (6080 <tcp_close_shutdown+0x144>)
    5f72:	4620      	mov	r0, r4
    5f74:	4798      	blx	r3
			TCP_RMV_ACTIVE(pcb);
    5f76:	4b43      	ldr	r3, [pc, #268]	; (6084 <tcp_close_shutdown+0x148>)
    5f78:	695a      	ldr	r2, [r3, #20]
    5f7a:	42a2      	cmp	r2, r4
    5f7c:	d112      	bne.n	5fa4 <tcp_close_shutdown+0x68>
    5f7e:	68e2      	ldr	r2, [r4, #12]
    5f80:	615a      	str	r2, [r3, #20]
    5f82:	2201      	movs	r2, #1
    5f84:	761a      	strb	r2, [r3, #24]
			if (pcb->state == ESTABLISHED) {
    5f86:	7e22      	ldrb	r2, [r4, #24]
			TCP_RMV_ACTIVE(pcb);
    5f88:	2500      	movs	r5, #0
			if (pcb->state == ESTABLISHED) {
    5f8a:	2a04      	cmp	r2, #4
			TCP_RMV_ACTIVE(pcb);
    5f8c:	60e5      	str	r5, [r4, #12]
			if (pcb->state == ESTABLISHED) {
    5f8e:	d13b      	bne.n	6008 <tcp_close_shutdown+0xcc>
				pcb->state = TIME_WAIT;
    5f90:	220a      	movs	r2, #10
    5f92:	7622      	strb	r2, [r4, #24]
				TCP_REG(&tcp_tw_pcbs, pcb);
    5f94:	69da      	ldr	r2, [r3, #28]
    5f96:	60e2      	str	r2, [r4, #12]
    5f98:	61dc      	str	r4, [r3, #28]
    5f9a:	4b3b      	ldr	r3, [pc, #236]	; (6088 <tcp_close_shutdown+0x14c>)
    5f9c:	4798      	blx	r3
	switch (pcb->state) {
    5f9e:	2000      	movs	r0, #0
}
    5fa0:	b003      	add	sp, #12
    5fa2:	bd30      	pop	{r4, r5, pc}
			TCP_RMV_ACTIVE(pcb);
    5fa4:	605a      	str	r2, [r3, #4]
    5fa6:	2100      	movs	r1, #0
    5fa8:	b91a      	cbnz	r2, 5fb2 <tcp_close_shutdown+0x76>
    5faa:	2900      	cmp	r1, #0
    5fac:	d0e9      	beq.n	5f82 <tcp_close_shutdown+0x46>
    5fae:	605a      	str	r2, [r3, #4]
    5fb0:	e7e7      	b.n	5f82 <tcp_close_shutdown+0x46>
    5fb2:	68d0      	ldr	r0, [r2, #12]
    5fb4:	42a0      	cmp	r0, r4
    5fb6:	d104      	bne.n	5fc2 <tcp_close_shutdown+0x86>
    5fb8:	b101      	cbz	r1, 5fbc <tcp_close_shutdown+0x80>
    5fba:	605a      	str	r2, [r3, #4]
    5fbc:	68e1      	ldr	r1, [r4, #12]
    5fbe:	60d1      	str	r1, [r2, #12]
    5fc0:	e7df      	b.n	5f82 <tcp_close_shutdown+0x46>
    5fc2:	2101      	movs	r1, #1
    5fc4:	4602      	mov	r2, r0
    5fc6:	e7ef      	b.n	5fa8 <tcp_close_shutdown+0x6c>
	switch (pcb->state) {
    5fc8:	2b07      	cmp	r3, #7
    5fca:	d8e8      	bhi.n	5f9e <tcp_close_shutdown+0x62>
    5fcc:	a201      	add	r2, pc, #4	; (adr r2, 5fd4 <tcp_close_shutdown+0x98>)
    5fce:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
    5fd2:	bf00      	nop
    5fd4:	00005ff5 	.word	0x00005ff5
    5fd8:	00006037 	.word	0x00006037
    5fdc:	00006045 	.word	0x00006045
    5fe0:	00006059 	.word	0x00006059
    5fe4:	00006059 	.word	0x00006059
    5fe8:	00005f9f 	.word	0x00005f9f
    5fec:	00005f9f 	.word	0x00005f9f
    5ff0:	0000606f 	.word	0x0000606f
		if (pcb->local_port != 0) {
    5ff4:	8b63      	ldrh	r3, [r4, #26]
    5ff6:	b13b      	cbz	r3, 6008 <tcp_close_shutdown+0xcc>
			TCP_RMV(&tcp_bound_pcbs, pcb);
    5ff8:	4a22      	ldr	r2, [pc, #136]	; (6084 <tcp_close_shutdown+0x148>)
    5ffa:	6813      	ldr	r3, [r2, #0]
    5ffc:	42a3      	cmp	r3, r4
    5ffe:	d108      	bne.n	6012 <tcp_close_shutdown+0xd6>
    6000:	68e3      	ldr	r3, [r4, #12]
    6002:	6013      	str	r3, [r2, #0]
    6004:	2300      	movs	r3, #0
    6006:	60e3      	str	r3, [r4, #12]
				memp_free(MEMP_TCP_PCB, pcb);
    6008:	4621      	mov	r1, r4
    600a:	2001      	movs	r0, #1
		memp_free(MEMP_TCP_PCB, pcb);
    600c:	4b1f      	ldr	r3, [pc, #124]	; (608c <tcp_close_shutdown+0x150>)
    600e:	4798      	blx	r3
	if (pcb != NULL && err == ERR_OK) {
    6010:	e7c5      	b.n	5f9e <tcp_close_shutdown+0x62>
			TCP_RMV(&tcp_bound_pcbs, pcb);
    6012:	6053      	str	r3, [r2, #4]
    6014:	2100      	movs	r1, #0
    6016:	b91b      	cbnz	r3, 6020 <tcp_close_shutdown+0xe4>
    6018:	2900      	cmp	r1, #0
    601a:	d0f3      	beq.n	6004 <tcp_close_shutdown+0xc8>
    601c:	6053      	str	r3, [r2, #4]
    601e:	e7f1      	b.n	6004 <tcp_close_shutdown+0xc8>
    6020:	68d8      	ldr	r0, [r3, #12]
    6022:	42a0      	cmp	r0, r4
    6024:	d104      	bne.n	6030 <tcp_close_shutdown+0xf4>
    6026:	b101      	cbz	r1, 602a <tcp_close_shutdown+0xee>
    6028:	6053      	str	r3, [r2, #4]
    602a:	68e2      	ldr	r2, [r4, #12]
    602c:	60da      	str	r2, [r3, #12]
    602e:	e7e9      	b.n	6004 <tcp_close_shutdown+0xc8>
    6030:	2101      	movs	r1, #1
    6032:	4603      	mov	r3, r0
    6034:	e7ef      	b.n	6016 <tcp_close_shutdown+0xda>
		tcp_pcb_remove(&tcp_listen_pcbs.pcbs, pcb);
    6036:	4816      	ldr	r0, [pc, #88]	; (6090 <tcp_close_shutdown+0x154>)
    6038:	4b16      	ldr	r3, [pc, #88]	; (6094 <tcp_close_shutdown+0x158>)
    603a:	4621      	mov	r1, r4
    603c:	4798      	blx	r3
		memp_free(MEMP_TCP_PCB_LISTEN, pcb);
    603e:	4621      	mov	r1, r4
    6040:	2002      	movs	r0, #2
    6042:	e7e3      	b.n	600c <tcp_close_shutdown+0xd0>
		TCP_PCB_REMOVE_ACTIVE(pcb);
    6044:	4d0f      	ldr	r5, [pc, #60]	; (6084 <tcp_close_shutdown+0x148>)
    6046:	4b13      	ldr	r3, [pc, #76]	; (6094 <tcp_close_shutdown+0x158>)
    6048:	4621      	mov	r1, r4
    604a:	f105 0014 	add.w	r0, r5, #20
    604e:	4798      	blx	r3
    6050:	2001      	movs	r0, #1
    6052:	7628      	strb	r0, [r5, #24]
		memp_free(MEMP_TCP_PCB, pcb);
    6054:	4621      	mov	r1, r4
    6056:	e7d9      	b.n	600c <tcp_close_shutdown+0xd0>
		err = tcp_send_fin(pcb);
    6058:	4b0f      	ldr	r3, [pc, #60]	; (6098 <tcp_close_shutdown+0x15c>)
    605a:	4620      	mov	r0, r4
    605c:	4798      	blx	r3
		if (err == ERR_OK) {
    605e:	2800      	cmp	r0, #0
    6060:	d19e      	bne.n	5fa0 <tcp_close_shutdown+0x64>
			pcb->state = FIN_WAIT_1;
    6062:	2305      	movs	r3, #5
			pcb->state = LAST_ACK;
    6064:	7623      	strb	r3, [r4, #24]
		tcp_output(pcb);
    6066:	4620      	mov	r0, r4
    6068:	4b0c      	ldr	r3, [pc, #48]	; (609c <tcp_close_shutdown+0x160>)
    606a:	4798      	blx	r3
    606c:	e797      	b.n	5f9e <tcp_close_shutdown+0x62>
		err = tcp_send_fin(pcb);
    606e:	4b0a      	ldr	r3, [pc, #40]	; (6098 <tcp_close_shutdown+0x15c>)
    6070:	4620      	mov	r0, r4
    6072:	4798      	blx	r3
		if (err == ERR_OK) {
    6074:	2800      	cmp	r0, #0
    6076:	d193      	bne.n	5fa0 <tcp_close_shutdown+0x64>
			pcb->state = LAST_ACK;
    6078:	2309      	movs	r3, #9
    607a:	e7f3      	b.n	6064 <tcp_close_shutdown+0x128>
    607c:	000026c5 	.word	0x000026c5
    6080:	00005bc9 	.word	0x00005bc9
    6084:	200148e8 	.word	0x200148e8
    6088:	000010a5 	.word	0x000010a5
    608c:	00004b49 	.word	0x00004b49
    6090:	200148f0 	.word	0x200148f0
    6094:	00005ed1 	.word	0x00005ed1
    6098:	0000237d 	.word	0x0000237d
    609c:	00002441 	.word	0x00002441

000060a0 <tcp_close>:
	if (pcb->state != LISTEN) {
    60a0:	7e03      	ldrb	r3, [r0, #24]
    60a2:	2b01      	cmp	r3, #1
		pcb->flags |= TF_RXCLOSED;
    60a4:	bf1e      	ittt	ne
    60a6:	7f83      	ldrbne	r3, [r0, #30]
    60a8:	f043 0310 	orrne.w	r3, r3, #16
    60ac:	7783      	strbne	r3, [r0, #30]
	return tcp_close_shutdown(pcb, 1);
    60ae:	2101      	movs	r1, #1
    60b0:	4b00      	ldr	r3, [pc, #0]	; (60b4 <tcp_close+0x14>)
    60b2:	4718      	bx	r3
    60b4:	00005f3d 	.word	0x00005f3d

000060b8 <tcp_recv_null>:
{
    60b8:	b510      	push	{r4, lr}
    60ba:	4608      	mov	r0, r1
	if (p != NULL) {
    60bc:	4614      	mov	r4, r2
    60be:	b13a      	cbz	r2, 60d0 <tcp_recv_null+0x18>
		tcp_recved(pcb, p->tot_len);
    60c0:	4b06      	ldr	r3, [pc, #24]	; (60dc <tcp_recv_null+0x24>)
    60c2:	8911      	ldrh	r1, [r2, #8]
    60c4:	4798      	blx	r3
		pbuf_free(p);
    60c6:	4b06      	ldr	r3, [pc, #24]	; (60e0 <tcp_recv_null+0x28>)
    60c8:	4620      	mov	r0, r4
    60ca:	4798      	blx	r3
}
    60cc:	2000      	movs	r0, #0
    60ce:	bd10      	pop	{r4, pc}
	} else if (err == ERR_OK) {
    60d0:	2b00      	cmp	r3, #0
    60d2:	d1fb      	bne.n	60cc <tcp_recv_null+0x14>
}
    60d4:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		return tcp_close(pcb);
    60d8:	4b02      	ldr	r3, [pc, #8]	; (60e4 <tcp_recv_null+0x2c>)
    60da:	4718      	bx	r3
    60dc:	00005af9 	.word	0x00005af9
    60e0:	00003081 	.word	0x00003081
    60e4:	000060a1 	.word	0x000060a1

000060e8 <tcp_process_refused_data>:
{
    60e8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	u8_t  refused_flags = pcb->refused_data->flags;
    60ea:	6f86      	ldr	r6, [r0, #120]	; 0x78
	TCP_EVENT_RECV(pcb, refused_data, ERR_OK, err);
    60ec:	f8d0 5080 	ldr.w	r5, [r0, #128]	; 0x80
	u8_t  refused_flags = pcb->refused_data->flags;
    60f0:	7b77      	ldrb	r7, [r6, #13]
	pcb->refused_data         = NULL;
    60f2:	2300      	movs	r3, #0
{
    60f4:	4604      	mov	r4, r0
	pcb->refused_data         = NULL;
    60f6:	6783      	str	r3, [r0, #120]	; 0x78
	TCP_EVENT_RECV(pcb, refused_data, ERR_OK, err);
    60f8:	b1e5      	cbz	r5, 6134 <tcp_process_refused_data+0x4c>
    60fa:	4601      	mov	r1, r0
    60fc:	4632      	mov	r2, r6
    60fe:	6900      	ldr	r0, [r0, #16]
    6100:	47a8      	blx	r5
    6102:	4605      	mov	r5, r0
	if (err == ERR_OK) {
    6104:	b9e8      	cbnz	r0, 6142 <tcp_process_refused_data+0x5a>
		if (refused_flags & PBUF_FLAG_TCP_FIN) {
    6106:	06bb      	lsls	r3, r7, #26
    6108:	d512      	bpl.n	6130 <tcp_process_refused_data+0x48>
			if (pcb->rcv_wnd != TCP_WND) {
    610a:	8da3      	ldrh	r3, [r4, #44]	; 0x2c
			TCP_EVENT_CLOSED(pcb, err);
    610c:	f8d4 6080 	ldr.w	r6, [r4, #128]	; 0x80
			if (pcb->rcv_wnd != TCP_WND) {
    6110:	f241 62d0 	movw	r2, #5840	; 0x16d0
    6114:	4293      	cmp	r3, r2
				pcb->rcv_wnd++;
    6116:	bf1c      	itt	ne
    6118:	3301      	addne	r3, #1
    611a:	85a3      	strhne	r3, [r4, #44]	; 0x2c
			TCP_EVENT_CLOSED(pcb, err);
    611c:	b146      	cbz	r6, 6130 <tcp_process_refused_data+0x48>
    611e:	2300      	movs	r3, #0
    6120:	6920      	ldr	r0, [r4, #16]
    6122:	461a      	mov	r2, r3
    6124:	4621      	mov	r1, r4
    6126:	47b0      	blx	r6
			if (err == ERR_ABRT) {
    6128:	300a      	adds	r0, #10
    612a:	d101      	bne.n	6130 <tcp_process_refused_data+0x48>
				return ERR_ABRT;
    612c:	f06f 0509 	mvn.w	r5, #9
}
    6130:	4628      	mov	r0, r5
    6132:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	TCP_EVENT_RECV(pcb, refused_data, ERR_OK, err);
    6134:	462b      	mov	r3, r5
    6136:	4601      	mov	r1, r0
    6138:	4632      	mov	r2, r6
    613a:	4628      	mov	r0, r5
    613c:	4d03      	ldr	r5, [pc, #12]	; (614c <tcp_process_refused_data+0x64>)
    613e:	47a8      	blx	r5
    6140:	e7df      	b.n	6102 <tcp_process_refused_data+0x1a>
	} else if (err == ERR_ABRT) {
    6142:	350a      	adds	r5, #10
    6144:	d0f2      	beq.n	612c <tcp_process_refused_data+0x44>
		pcb->refused_data = refused_data;
    6146:	67a6      	str	r6, [r4, #120]	; 0x78
	return ERR_OK;
    6148:	2500      	movs	r5, #0
    614a:	e7f1      	b.n	6130 <tcp_process_refused_data+0x48>
    614c:	000060b9 	.word	0x000060b9

00006150 <tcp_fasttmr>:
{
    6150:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	++tcp_timer_ctr;
    6154:	4d15      	ldr	r5, [pc, #84]	; (61ac <tcp_fasttmr+0x5c>)
				tcp_output(pcb);
    6156:	4e16      	ldr	r6, [pc, #88]	; (61b0 <tcp_fasttmr+0x60>)
	++tcp_timer_ctr;
    6158:	7c2b      	ldrb	r3, [r5, #16]
				tcp_process_refused_data(pcb);
    615a:	f8df 8058 	ldr.w	r8, [pc, #88]	; 61b4 <tcp_fasttmr+0x64>
	++tcp_timer_ctr;
    615e:	3301      	adds	r3, #1
    6160:	742b      	strb	r3, [r5, #16]
	pcb = tcp_active_pcbs;
    6162:	696c      	ldr	r4, [r5, #20]
				tcp_active_pcbs_changed = 0;
    6164:	2700      	movs	r7, #0
		if (pcb->last_timer != tcp_timer_ctr) {
    6166:	7c2b      	ldrb	r3, [r5, #16]
	while (pcb != NULL) {
    6168:	b90c      	cbnz	r4, 616e <tcp_fasttmr+0x1e>
}
    616a:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
		if (pcb->last_timer != tcp_timer_ctr) {
    616e:	f894 2021 	ldrb.w	r2, [r4, #33]	; 0x21
    6172:	429a      	cmp	r2, r3
    6174:	d0f8      	beq.n	6168 <tcp_fasttmr+0x18>
			pcb->last_timer = tcp_timer_ctr;
    6176:	f884 3021 	strb.w	r3, [r4, #33]	; 0x21
			if (pcb->flags & TF_ACK_DELAY) {
    617a:	7fa3      	ldrb	r3, [r4, #30]
    617c:	07da      	lsls	r2, r3, #31
    617e:	d508      	bpl.n	6192 <tcp_fasttmr+0x42>
				tcp_ack_now(pcb);
    6180:	f043 0302 	orr.w	r3, r3, #2
    6184:	77a3      	strb	r3, [r4, #30]
				tcp_output(pcb);
    6186:	4620      	mov	r0, r4
    6188:	47b0      	blx	r6
				pcb->flags &= ~(TF_ACK_DELAY | TF_ACK_NOW);
    618a:	7fa3      	ldrb	r3, [r4, #30]
    618c:	f023 0303 	bic.w	r3, r3, #3
    6190:	77a3      	strb	r3, [r4, #30]
			if (pcb->refused_data != NULL) {
    6192:	6fa3      	ldr	r3, [r4, #120]	; 0x78
			next = pcb->next;
    6194:	f8d4 900c 	ldr.w	r9, [r4, #12]
			if (pcb->refused_data != NULL) {
    6198:	b12b      	cbz	r3, 61a6 <tcp_fasttmr+0x56>
				tcp_process_refused_data(pcb);
    619a:	4620      	mov	r0, r4
				tcp_active_pcbs_changed = 0;
    619c:	762f      	strb	r7, [r5, #24]
				tcp_process_refused_data(pcb);
    619e:	47c0      	blx	r8
				if (tcp_active_pcbs_changed) {
    61a0:	7e2b      	ldrb	r3, [r5, #24]
    61a2:	2b00      	cmp	r3, #0
    61a4:	d1dd      	bne.n	6162 <tcp_fasttmr+0x12>
{
    61a6:	464c      	mov	r4, r9
    61a8:	e7dd      	b.n	6166 <tcp_fasttmr+0x16>
    61aa:	bf00      	nop
    61ac:	200148e8 	.word	0x200148e8
    61b0:	00002441 	.word	0x00002441
    61b4:	000060e9 	.word	0x000060e9

000061b8 <tcp_tmr>:
	tcp_fasttmr();
    61b8:	4b08      	ldr	r3, [pc, #32]	; (61dc <tcp_tmr+0x24>)
{
    61ba:	b510      	push	{r4, lr}
	tcp_fasttmr();
    61bc:	4798      	blx	r3
	if (++tcp_timer & 1) {
    61be:	4a08      	ldr	r2, [pc, #32]	; (61e0 <tcp_tmr+0x28>)
    61c0:	f892 3020 	ldrb.w	r3, [r2, #32]
    61c4:	3301      	adds	r3, #1
    61c6:	b2db      	uxtb	r3, r3
    61c8:	f882 3020 	strb.w	r3, [r2, #32]
    61cc:	07db      	lsls	r3, r3, #31
    61ce:	d503      	bpl.n	61d8 <tcp_tmr+0x20>
}
    61d0:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		tcp_slowtmr();
    61d4:	4b03      	ldr	r3, [pc, #12]	; (61e4 <tcp_tmr+0x2c>)
    61d6:	4718      	bx	r3
}
    61d8:	bd10      	pop	{r4, pc}
    61da:	bf00      	nop
    61dc:	00006151 	.word	0x00006151
    61e0:	200148e8 	.word	0x200148e8
    61e4:	00005c0d 	.word	0x00005c0d

000061e8 <tcp_shutdown>:
{
    61e8:	b570      	push	{r4, r5, r6, lr}
	if (pcb->state == LISTEN) {
    61ea:	7e03      	ldrb	r3, [r0, #24]
    61ec:	2b01      	cmp	r3, #1
{
    61ee:	4605      	mov	r5, r0
    61f0:	4614      	mov	r4, r2
	if (pcb->state == LISTEN) {
    61f2:	d018      	beq.n	6226 <tcp_shutdown+0x3e>
	if (shut_rx) {
    61f4:	b189      	cbz	r1, 621a <tcp_shutdown+0x32>
		pcb->flags |= TF_RXCLOSED;
    61f6:	7f83      	ldrb	r3, [r0, #30]
    61f8:	f043 0310 	orr.w	r3, r3, #16
    61fc:	7783      	strb	r3, [r0, #30]
		if (shut_tx) {
    61fe:	b122      	cbz	r2, 620a <tcp_shutdown+0x22>
			return tcp_close_shutdown(pcb, 1);
    6200:	2101      	movs	r1, #1
}
    6202:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
			return tcp_close_shutdown(pcb, shut_rx);
    6206:	4b0c      	ldr	r3, [pc, #48]	; (6238 <tcp_shutdown+0x50>)
    6208:	4718      	bx	r3
		if (pcb->refused_data != NULL) {
    620a:	6f80      	ldr	r0, [r0, #120]	; 0x78
    620c:	b908      	cbnz	r0, 6212 <tcp_shutdown+0x2a>
	return ERR_OK;
    620e:	2000      	movs	r0, #0
}
    6210:	bd70      	pop	{r4, r5, r6, pc}
			pbuf_free(pcb->refused_data);
    6212:	4b0a      	ldr	r3, [pc, #40]	; (623c <tcp_shutdown+0x54>)
    6214:	4798      	blx	r3
			pcb->refused_data = NULL;
    6216:	67ac      	str	r4, [r5, #120]	; 0x78
    6218:	e7f9      	b.n	620e <tcp_shutdown+0x26>
	if (shut_tx) {
    621a:	2a00      	cmp	r2, #0
    621c:	d0f7      	beq.n	620e <tcp_shutdown+0x26>
		switch (pcb->state) {
    621e:	2b04      	cmp	r3, #4
    6220:	d804      	bhi.n	622c <tcp_shutdown+0x44>
    6222:	2b02      	cmp	r3, #2
    6224:	d804      	bhi.n	6230 <tcp_shutdown+0x48>
    6226:	f06f 000c 	mvn.w	r0, #12
    622a:	e7f1      	b.n	6210 <tcp_shutdown+0x28>
    622c:	2b07      	cmp	r3, #7
    622e:	d1fa      	bne.n	6226 <tcp_shutdown+0x3e>
			return tcp_close_shutdown(pcb, shut_rx);
    6230:	2100      	movs	r1, #0
    6232:	4628      	mov	r0, r5
    6234:	e7e5      	b.n	6202 <tcp_shutdown+0x1a>
    6236:	bf00      	nop
    6238:	00005f3d 	.word	0x00005f3d
    623c:	00003081 	.word	0x00003081

00006240 <tcp_abandon>:
{
    6240:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
	if (pcb->state == TIME_WAIT) {
    6244:	7e03      	ldrb	r3, [r0, #24]
    6246:	4f23      	ldr	r7, [pc, #140]	; (62d4 <tcp_abandon+0x94>)
    6248:	2b0a      	cmp	r3, #10
{
    624a:	4604      	mov	r4, r0
    624c:	4b22      	ldr	r3, [pc, #136]	; (62d8 <tcp_abandon+0x98>)
    624e:	460d      	mov	r5, r1
	if (pcb->state == TIME_WAIT) {
    6250:	d109      	bne.n	6266 <tcp_abandon+0x26>
		tcp_pcb_remove(&tcp_tw_pcbs, pcb);
    6252:	4601      	mov	r1, r0
    6254:	4821      	ldr	r0, [pc, #132]	; (62dc <tcp_abandon+0x9c>)
    6256:	4798      	blx	r3
		memp_free(MEMP_TCP_PCB, pcb);
    6258:	4621      	mov	r1, r4
    625a:	2001      	movs	r0, #1
    625c:	463b      	mov	r3, r7
}
    625e:	b003      	add	sp, #12
    6260:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
		memp_free(MEMP_TCP_PCB, pcb);
    6264:	4718      	bx	r3
		TCP_PCB_REMOVE_ACTIVE(pcb);
    6266:	f8df b080 	ldr.w	fp, [pc, #128]	; 62e8 <tcp_abandon+0xa8>
		seqno = pcb->snd_nxt;
    626a:	f8d0 9050 	ldr.w	r9, [r0, #80]	; 0x50
		ackno = pcb->rcv_nxt;
    626e:	f8d0 a028 	ldr.w	sl, [r0, #40]	; 0x28
		errf = pcb->errf;
    6272:	f8d0 608c 	ldr.w	r6, [r0, #140]	; 0x8c
		errf_arg = pcb->callback_arg;
    6276:	f8d0 8010 	ldr.w	r8, [r0, #16]
		TCP_PCB_REMOVE_ACTIVE(pcb);
    627a:	4601      	mov	r1, r0
    627c:	f10b 0014 	add.w	r0, fp, #20
    6280:	4798      	blx	r3
		if (pcb->unacked != NULL) {
    6282:	6f20      	ldr	r0, [r4, #112]	; 0x70
		TCP_PCB_REMOVE_ACTIVE(pcb);
    6284:	2301      	movs	r3, #1
    6286:	f88b 3018 	strb.w	r3, [fp, #24]
		if (pcb->unacked != NULL) {
    628a:	b108      	cbz	r0, 6290 <tcp_abandon+0x50>
			tcp_segs_free(pcb->unacked);
    628c:	4b14      	ldr	r3, [pc, #80]	; (62e0 <tcp_abandon+0xa0>)
    628e:	4798      	blx	r3
		if (pcb->unsent != NULL) {
    6290:	6ee0      	ldr	r0, [r4, #108]	; 0x6c
    6292:	b108      	cbz	r0, 6298 <tcp_abandon+0x58>
			tcp_segs_free(pcb->unsent);
    6294:	4b12      	ldr	r3, [pc, #72]	; (62e0 <tcp_abandon+0xa0>)
    6296:	4798      	blx	r3
		if (pcb->ooseq != NULL) {
    6298:	6f60      	ldr	r0, [r4, #116]	; 0x74
    629a:	b108      	cbz	r0, 62a0 <tcp_abandon+0x60>
			tcp_segs_free(pcb->ooseq);
    629c:	4b10      	ldr	r3, [pc, #64]	; (62e0 <tcp_abandon+0xa0>)
    629e:	4798      	blx	r3
		if (reset) {
    62a0:	b14d      	cbz	r5, 62b6 <tcp_abandon+0x76>
			tcp_rst(seqno, ackno, &pcb->local_ip, &pcb->remote_ip, pcb->local_port, pcb->remote_port);
    62a2:	8ba3      	ldrh	r3, [r4, #28]
    62a4:	9301      	str	r3, [sp, #4]
    62a6:	8b63      	ldrh	r3, [r4, #26]
    62a8:	9300      	str	r3, [sp, #0]
    62aa:	4d0e      	ldr	r5, [pc, #56]	; (62e4 <tcp_abandon+0xa4>)
    62ac:	1d23      	adds	r3, r4, #4
    62ae:	4622      	mov	r2, r4
    62b0:	4651      	mov	r1, sl
    62b2:	4648      	mov	r0, r9
    62b4:	47a8      	blx	r5
		memp_free(MEMP_TCP_PCB, pcb);
    62b6:	4621      	mov	r1, r4
    62b8:	2001      	movs	r0, #1
    62ba:	47b8      	blx	r7
		TCP_EVENT_ERR(errf, errf_arg, ERR_ABRT);
    62bc:	b13e      	cbz	r6, 62ce <tcp_abandon+0x8e>
    62be:	f06f 0109 	mvn.w	r1, #9
    62c2:	4640      	mov	r0, r8
    62c4:	4633      	mov	r3, r6
}
    62c6:	b003      	add	sp, #12
    62c8:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
		TCP_EVENT_ERR(errf, errf_arg, ERR_ABRT);
    62cc:	4718      	bx	r3
}
    62ce:	b003      	add	sp, #12
    62d0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    62d4:	00004b49 	.word	0x00004b49
    62d8:	00005ed1 	.word	0x00005ed1
    62dc:	20014904 	.word	0x20014904
    62e0:	00005b5d 	.word	0x00005b5d
    62e4:	000026c5 	.word	0x000026c5
    62e8:	200148e8 	.word	0x200148e8

000062ec <tcp_abort>:
	tcp_abandon(pcb, 1);
    62ec:	4b01      	ldr	r3, [pc, #4]	; (62f4 <tcp_abort+0x8>)
    62ee:	2101      	movs	r1, #1
    62f0:	4718      	bx	r3
    62f2:	bf00      	nop
    62f4:	00006241 	.word	0x00006241

000062f8 <tcp_next_iss>:
 */
u32_t tcp_next_iss(void)
{
	static u32_t iss = 6510;

	iss += tcp_ticks; /* XXX */
    62f8:	4b03      	ldr	r3, [pc, #12]	; (6308 <tcp_next_iss+0x10>)
    62fa:	4a04      	ldr	r2, [pc, #16]	; (630c <tcp_next_iss+0x14>)
    62fc:	6858      	ldr	r0, [r3, #4]
    62fe:	68d2      	ldr	r2, [r2, #12]
    6300:	4410      	add	r0, r2
    6302:	6058      	str	r0, [r3, #4]
	return iss;
}
    6304:	4770      	bx	lr
    6306:	bf00      	nop
    6308:	20000008 	.word	0x20000008
    630c:	200148e8 	.word	0x200148e8

00006310 <tcp_alloc>:
{
    6310:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	pcb = (struct tcp_pcb *)memp_malloc(MEMP_TCP_PCB);
    6312:	4e34      	ldr	r6, [pc, #208]	; (63e4 <tcp_alloc+0xd4>)
    6314:	4d34      	ldr	r5, [pc, #208]	; (63e8 <tcp_alloc+0xd8>)
{
    6316:	4607      	mov	r7, r0
	pcb = (struct tcp_pcb *)memp_malloc(MEMP_TCP_PCB);
    6318:	2001      	movs	r0, #1
    631a:	47b0      	blx	r6
	if (pcb == NULL) {
    631c:	4604      	mov	r4, r0
    631e:	b9d8      	cbnz	r0, 6358 <tcp_alloc+0x48>
	for (pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
    6320:	69eb      	ldr	r3, [r5, #28]
		if ((u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {
    6322:	68e8      	ldr	r0, [r5, #12]
	inactivity = 0;
    6324:	4621      	mov	r1, r4
	for (pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
    6326:	2b00      	cmp	r3, #0
    6328:	d145      	bne.n	63b6 <tcp_alloc+0xa6>
	if (inactive != NULL) {
    632a:	b114      	cbz	r4, 6332 <tcp_alloc+0x22>
		tcp_abort(inactive);
    632c:	4b2f      	ldr	r3, [pc, #188]	; (63ec <tcp_alloc+0xdc>)
    632e:	4620      	mov	r0, r4
    6330:	4798      	blx	r3
		pcb = (struct tcp_pcb *)memp_malloc(MEMP_TCP_PCB);
    6332:	2001      	movs	r0, #1
    6334:	47b0      	blx	r6
		if (pcb == NULL) {
    6336:	4604      	mov	r4, r0
    6338:	b970      	cbnz	r0, 6358 <tcp_alloc+0x48>
	for (pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
    633a:	696b      	ldr	r3, [r5, #20]
		if (pcb->prio <= prio && pcb->prio <= mprio && (u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {
    633c:	f8d5 e00c 	ldr.w	lr, [r5, #12]
	mprio = TCP_PRIO_MAX;
    6340:	207f      	movs	r0, #127	; 0x7f
	inactivity = 0;
    6342:	46a4      	mov	ip, r4
	for (pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
    6344:	2b00      	cmp	r3, #0
    6346:	d13e      	bne.n	63c6 <tcp_alloc+0xb6>
	if (inactive != NULL) {
    6348:	b114      	cbz	r4, 6350 <tcp_alloc+0x40>
		tcp_abort(inactive);
    634a:	4b28      	ldr	r3, [pc, #160]	; (63ec <tcp_alloc+0xdc>)
    634c:	4620      	mov	r0, r4
    634e:	4798      	blx	r3
			pcb = (struct tcp_pcb *)memp_malloc(MEMP_TCP_PCB);
    6350:	2001      	movs	r0, #1
    6352:	47b0      	blx	r6
	if (pcb != NULL) {
    6354:	4604      	mov	r4, r0
    6356:	b360      	cbz	r0, 63b2 <tcp_alloc+0xa2>
		memset(pcb, 0, sizeof(struct tcp_pcb));
    6358:	2298      	movs	r2, #152	; 0x98
    635a:	4b25      	ldr	r3, [pc, #148]	; (63f0 <tcp_alloc+0xe0>)
    635c:	2100      	movs	r1, #0
    635e:	4620      	mov	r0, r4
    6360:	4798      	blx	r3
		pcb->snd_buf      = TCP_SND_BUF;
    6362:	f640 3368 	movw	r3, #2920	; 0xb68
    6366:	f8a4 3066 	strh.w	r3, [r4, #102]	; 0x66
		pcb->rcv_wnd      = TCP_WND;
    636a:	4b22      	ldr	r3, [pc, #136]	; (63f4 <tcp_alloc+0xe4>)
    636c:	62e3      	str	r3, [r4, #44]	; 0x2c
		pcb->ttl          = TCP_TTL;
    636e:	23ff      	movs	r3, #255	; 0xff
    6370:	72a3      	strb	r3, [r4, #10]
		pcb->rto        = 3000 / TCP_SLOW_INTERVAL;
    6372:	2306      	movs	r3, #6
    6374:	f8a4 3044 	strh.w	r3, [r4, #68]	; 0x44
		pcb->sv         = 3000 / TCP_SLOW_INTERVAL;
    6378:	f8a4 3042 	strh.w	r3, [r4, #66]	; 0x42
		pcb->rtime      = -1;
    637c:	4b1e      	ldr	r3, [pc, #120]	; (63f8 <tcp_alloc+0xe8>)
    637e:	6363      	str	r3, [r4, #52]	; 0x34
		pcb->cwnd       = 1;
    6380:	2301      	movs	r3, #1
    6382:	f8a4 304c 	strh.w	r3, [r4, #76]	; 0x4c
		pcb->prio         = prio;
    6386:	7667      	strb	r7, [r4, #25]
		iss             = tcp_next_iss();
    6388:	4b1c      	ldr	r3, [pc, #112]	; (63fc <tcp_alloc+0xec>)
    638a:	4798      	blx	r3
		pcb->tmr        = tcp_ticks;
    638c:	68eb      	ldr	r3, [r5, #12]
		pcb->recv = tcp_recv_null;
    638e:	4a1c      	ldr	r2, [pc, #112]	; (6400 <tcp_alloc+0xf0>)
		pcb->tmr        = tcp_ticks;
    6390:	6263      	str	r3, [r4, #36]	; 0x24
		pcb->last_timer = tcp_timer_ctr;
    6392:	7c2b      	ldrb	r3, [r5, #16]
    6394:	f884 3021 	strb.w	r3, [r4, #33]	; 0x21
		pcb->recv = tcp_recv_null;
    6398:	f8c4 2080 	str.w	r2, [r4, #128]	; 0x80
		pcb->polltmr = 0;
    639c:	2300      	movs	r3, #0
		pcb->keep_idle = TCP_KEEPIDLE_DEFAULT;
    639e:	4a19      	ldr	r2, [pc, #100]	; (6404 <tcp_alloc+0xf4>)
		pcb->snd_wl2    = iss;
    63a0:	65a0      	str	r0, [r4, #88]	; 0x58
		pcb->snd_nxt    = iss;
    63a2:	6520      	str	r0, [r4, #80]	; 0x50
		pcb->lastack    = iss;
    63a4:	64a0      	str	r0, [r4, #72]	; 0x48
		pcb->snd_lbb    = iss;
    63a6:	65e0      	str	r0, [r4, #92]	; 0x5c
		pcb->polltmr = 0;
    63a8:	77e3      	strb	r3, [r4, #31]
		pcb->keep_idle = TCP_KEEPIDLE_DEFAULT;
    63aa:	f8c4 2090 	str.w	r2, [r4, #144]	; 0x90
		pcb->keep_cnt_sent = 0;
    63ae:	f884 3096 	strb.w	r3, [r4, #150]	; 0x96
}
    63b2:	4620      	mov	r0, r4
    63b4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		if ((u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {
    63b6:	6a5a      	ldr	r2, [r3, #36]	; 0x24
    63b8:	1a82      	subs	r2, r0, r2
    63ba:	428a      	cmp	r2, r1
    63bc:	bf24      	itt	cs
    63be:	461c      	movcs	r4, r3
    63c0:	4611      	movcs	r1, r2
	for (pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
    63c2:	68db      	ldr	r3, [r3, #12]
    63c4:	e7af      	b.n	6326 <tcp_alloc+0x16>
		if (pcb->prio <= prio && pcb->prio <= mprio && (u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {
    63c6:	7e59      	ldrb	r1, [r3, #25]
    63c8:	428f      	cmp	r7, r1
    63ca:	d309      	bcc.n	63e0 <tcp_alloc+0xd0>
    63cc:	4281      	cmp	r1, r0
    63ce:	d807      	bhi.n	63e0 <tcp_alloc+0xd0>
    63d0:	6a5a      	ldr	r2, [r3, #36]	; 0x24
    63d2:	ebae 0202 	sub.w	r2, lr, r2
    63d6:	4562      	cmp	r2, ip
    63d8:	bf22      	ittt	cs
    63da:	4608      	movcs	r0, r1
    63dc:	4694      	movcs	ip, r2
    63de:	461c      	movcs	r4, r3
	for (pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
    63e0:	68db      	ldr	r3, [r3, #12]
    63e2:	e7af      	b.n	6344 <tcp_alloc+0x34>
    63e4:	00004b2d 	.word	0x00004b2d
    63e8:	200148e8 	.word	0x200148e8
    63ec:	000062ed 	.word	0x000062ed
    63f0:	000094c1 	.word	0x000094c1
    63f4:	16d016d0 	.word	0x16d016d0
    63f8:	0218ffff 	.word	0x0218ffff
    63fc:	000062f9 	.word	0x000062f9
    6400:	000060b9 	.word	0x000060b9
    6404:	006ddd00 	.word	0x006ddd00

00006408 <tcp_new>:
	return tcp_alloc(TCP_PRIO_NORMAL);
    6408:	4b01      	ldr	r3, [pc, #4]	; (6410 <tcp_new+0x8>)
    640a:	2040      	movs	r0, #64	; 0x40
    640c:	4718      	bx	r3
    640e:	bf00      	nop
    6410:	00006311 	.word	0x00006311

00006414 <tcp_eff_send_mss>:
 * Calcluates the effective send mss that can be used for a specific IP address
 * by using ip_route to determin the netif used to send to the address and
 * calculating the minimum of TCP_MSS and that netif's mtu (if set).
 */
u16_t tcp_eff_send_mss(u16_t sendmss, ip_addr_t *addr)
{
    6414:	b510      	push	{r4, lr}
	u16_t         mss_s;
	struct netif *outif;

	outif = ip_route(addr);
    6416:	4b07      	ldr	r3, [pc, #28]	; (6434 <tcp_eff_send_mss+0x20>)
{
    6418:	4604      	mov	r4, r0
	outif = ip_route(addr);
    641a:	4608      	mov	r0, r1
    641c:	4798      	blx	r3
	if ((outif != NULL) && (outif->mtu != 0)) {
    641e:	b130      	cbz	r0, 642e <tcp_eff_send_mss+0x1a>
    6420:	8c83      	ldrh	r3, [r0, #36]	; 0x24
    6422:	b123      	cbz	r3, 642e <tcp_eff_send_mss+0x1a>
		mss_s = outif->mtu - IP_HLEN - TCP_HLEN;
    6424:	3b28      	subs	r3, #40	; 0x28
		/* RFC 1122, chap 4.2.2.6:
		 * Eff.snd.MSS = min(SendMSS+20, MMS_S) - TCPhdrsize - IPoptionsize
		 * We correct for TCP options in tcp_write(), and don't support IP options.
		 */
		sendmss = LWIP_MIN(sendmss, mss_s);
    6426:	b29b      	uxth	r3, r3
    6428:	429c      	cmp	r4, r3
    642a:	bf28      	it	cs
    642c:	461c      	movcs	r4, r3
	}
	return sendmss;
}
    642e:	4620      	mov	r0, r4
    6430:	bd10      	pop	{r4, pc}
    6432:	bf00      	nop
    6434:	000053ed 	.word	0x000053ed

00006438 <mac_low_level_init>:

/**
 * \brief Initialize the MAC hardware
 */
void mac_low_level_init(struct netif *netif)
{
    6438:	b51f      	push	{r0, r1, r2, r3, r4, lr}
    643a:	4603      	mov	r3, r0
	struct mac_async_filter      filter;

	mac = (struct mac_async_descriptor *)(netif->state);

	/* set MAC hardware address */
	memcpy(filter.mac, netif->hwaddr, NETIF_MAX_HWADDR_LEN);
    643c:	f8d0 0027 	ldr.w	r0, [r0, #39]	; 0x27
    6440:	f8b3 202b 	ldrh.w	r2, [r3, #43]	; 0x2b
    6444:	9001      	str	r0, [sp, #4]
    6446:	f8ad 2008 	strh.w	r2, [sp, #8]
	filter.tid_enable = false;
    644a:	2100      	movs	r1, #0
	mac_async_set_filter(mac, 0, &filter);
    644c:	6a18      	ldr	r0, [r3, #32]
    644e:	4b04      	ldr	r3, [pc, #16]	; (6460 <mac_low_level_init+0x28>)
	filter.tid_enable = false;
    6450:	f88d 100c 	strb.w	r1, [sp, #12]
	mac_async_set_filter(mac, 0, &filter);
    6454:	aa01      	add	r2, sp, #4
    6456:	4798      	blx	r3
}
    6458:	b005      	add	sp, #20
    645a:	f85d fb04 	ldr.w	pc, [sp], #4
    645e:	bf00      	nop
    6460:	00004cad 	.word	0x00004cad

00006464 <mac_low_level_output>:

/**
 * \berif Transmission packet though the MAC hardware.
 */
err_t mac_low_level_output(struct netif *netif, struct pbuf *p)
{
    6464:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    6468:	460c      	mov	r4, r1
	struct mac_async_descriptor *mac;
	struct pbuf *                q;
	void *                       tbuf;
	uint8_t *                    pos;

	mac = (struct mac_async_descriptor *)(netif->state);
    646a:	6a07      	ldr	r7, [r0, #32]

#if ETH_PAD_SIZE
	pbuf_header(p, -ETH_PAD_SIZE); /* drop the padding word */
    646c:	4e1c      	ldr	r6, [pc, #112]	; (64e0 <mac_low_level_output+0x7c>)
    646e:	f06f 0101 	mvn.w	r1, #1
    6472:	4620      	mov	r0, r4
    6474:	47b0      	blx	r6
#endif

	if (p->tot_len == p->len) {
    6476:	8920      	ldrh	r0, [r4, #8]
    6478:	8962      	ldrh	r2, [r4, #10]
    647a:	4282      	cmp	r2, r0
    647c:	d109      	bne.n	6492 <mac_low_level_output+0x2e>
		mac_async_write(mac, p->payload, p->tot_len);
    647e:	6861      	ldr	r1, [r4, #4]
    6480:	4b18      	ldr	r3, [pc, #96]	; (64e4 <mac_low_level_output+0x80>)
    6482:	4638      	mov	r0, r7
    6484:	4798      	blx	r3
		mac_async_write(mac, tbuf, p->tot_len);
		mem_free(tbuf);
	}

#if ETH_PAD_SIZE
	pbuf_header(p, ETH_PAD_SIZE); /* reclaim the padding word */
    6486:	2102      	movs	r1, #2
    6488:	4620      	mov	r0, r4
    648a:	47b0      	blx	r6
#endif

	LINK_STATS_INC(link.xmit);

	return ERR_OK;
    648c:	2000      	movs	r0, #0
}
    648e:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
		tbuf = mem_malloc(LWIP_MEM_ALIGN_SIZE(p->tot_len));
    6492:	3003      	adds	r0, #3
    6494:	f020 0003 	bic.w	r0, r0, #3
    6498:	4b13      	ldr	r3, [pc, #76]	; (64e8 <mac_low_level_output+0x84>)
    649a:	b280      	uxth	r0, r0
    649c:	4798      	blx	r3
		if (tbuf == NULL) {
    649e:	4605      	mov	r5, r0
    64a0:	b1d8      	cbz	r0, 64da <mac_low_level_output+0x76>
			memcpy(pos, q->payload, q->len);
    64a2:	f8df 904c 	ldr.w	r9, [pc, #76]	; 64f0 <mac_low_level_output+0x8c>
    64a6:	4603      	mov	r3, r0
    64a8:	46a0      	mov	r8, r4
    64aa:	f8b8 200a 	ldrh.w	r2, [r8, #10]
    64ae:	f8d8 1004 	ldr.w	r1, [r8, #4]
    64b2:	4618      	mov	r0, r3
    64b4:	47c8      	blx	r9
			pos += q->len;
    64b6:	f8b8 200a 	ldrh.w	r2, [r8, #10]
		for (q = p; q != NULL; q = q->next) {
    64ba:	f8d8 8000 	ldr.w	r8, [r8]
			memcpy(pos, q->payload, q->len);
    64be:	4603      	mov	r3, r0
			pos += q->len;
    64c0:	4413      	add	r3, r2
		for (q = p; q != NULL; q = q->next) {
    64c2:	f1b8 0f00 	cmp.w	r8, #0
    64c6:	d1f0      	bne.n	64aa <mac_low_level_output+0x46>
		mac_async_write(mac, tbuf, p->tot_len);
    64c8:	8922      	ldrh	r2, [r4, #8]
    64ca:	4b06      	ldr	r3, [pc, #24]	; (64e4 <mac_low_level_output+0x80>)
    64cc:	4629      	mov	r1, r5
    64ce:	4638      	mov	r0, r7
    64d0:	4798      	blx	r3
		mem_free(tbuf);
    64d2:	4b06      	ldr	r3, [pc, #24]	; (64ec <mac_low_level_output+0x88>)
    64d4:	4628      	mov	r0, r5
    64d6:	4798      	blx	r3
    64d8:	e7d5      	b.n	6486 <mac_low_level_output+0x22>
			return ERR_MEM;
    64da:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    64de:	e7d6      	b.n	648e <mac_low_level_output+0x2a>
    64e0:	00003029 	.word	0x00003029
    64e4:	00004bc5 	.word	0x00004bc5
    64e8:	0000587d 	.word	0x0000587d
    64ec:	000056f1 	.word	0x000056f1
    64f0:	000094a5 	.word	0x000094a5

000064f4 <ethernetif_mac_input>:

/**
 * \brief Process incoming ethernet packet.
 */
void ethernetif_mac_input(struct netif *netif)
{
    64f4:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	len = mac_async_read_len(mac); /* Obtain the size of the packet */
    64f8:	4f1e      	ldr	r7, [pc, #120]	; (6574 <ethernetif_mac_input+0x80>)
	p = pbuf_alloc(PBUF_RAW, len, PBUF_RAM);
    64fa:	f8df 8088 	ldr.w	r8, [pc, #136]	; 6584 <ethernetif_mac_input+0x90>
    64fe:	4e1e      	ldr	r6, [pc, #120]	; (6578 <ethernetif_mac_input+0x84>)
{
    6500:	4605      	mov	r5, r0
	struct eth_hdr *ethhdr;
	struct pbuf *   p;

	/* move received packet into a new pbuf */
	do {
		p = low_level_input(netif);
    6502:	f8d5 9020 	ldr.w	r9, [r5, #32]
	len = mac_async_read_len(mac); /* Obtain the size of the packet */
    6506:	4648      	mov	r0, r9
    6508:	47b8      	blx	r7
    650a:	b281      	uxth	r1, r0
	if (len == 0) {
    650c:	2900      	cmp	r1, #0
    650e:	d02f      	beq.n	6570 <ethernetif_mac_input+0x7c>
	len += ETH_PAD_SIZE; /* allow room for Ethernet padding */
    6510:	3102      	adds	r1, #2
	p = pbuf_alloc(PBUF_RAW, len, PBUF_RAM);
    6512:	2200      	movs	r2, #0
    6514:	b289      	uxth	r1, r1
    6516:	2003      	movs	r0, #3
    6518:	47c0      	blx	r8
	if (p != NULL) {
    651a:	4604      	mov	r4, r0
    651c:	b1d0      	cbz	r0, 6554 <ethernetif_mac_input+0x60>
		pbuf_header(p, -ETH_PAD_SIZE); /* drop the padding word */
    651e:	f8df a068 	ldr.w	sl, [pc, #104]	; 6588 <ethernetif_mac_input+0x94>
    6522:	f06f 0101 	mvn.w	r1, #1
    6526:	47d0      	blx	sl
		mac_async_read(mac, p->payload, p->len);
    6528:	8962      	ldrh	r2, [r4, #10]
    652a:	6861      	ldr	r1, [r4, #4]
    652c:	4648      	mov	r0, r9
    652e:	47b0      	blx	r6
		pbuf_header(p, ETH_PAD_SIZE); /* reclaim the padding word */
    6530:	2102      	movs	r1, #2
    6532:	4620      	mov	r0, r4
    6534:	47d0      	blx	sl
			return;
		}
		/* points to packet payload, which starts with an Ethernet header */
		ethhdr = p->payload;

		switch (htons(ethhdr->type)) {
    6536:	6863      	ldr	r3, [r4, #4]
    6538:	89d8      	ldrh	r0, [r3, #14]
    653a:	4b10      	ldr	r3, [pc, #64]	; (657c <ethernetif_mac_input+0x88>)
    653c:	4798      	blx	r3
    653e:	f5b0 6f00 	cmp.w	r0, #2048	; 0x800
    6542:	d00e      	beq.n	6562 <ethernetif_mac_input+0x6e>
    6544:	f640 0306 	movw	r3, #2054	; 0x806
    6548:	4298      	cmp	r0, r3
    654a:	d00a      	beq.n	6562 <ethernetif_mac_input+0x6e>
				p = NULL;
			}
			break;

		default:
			pbuf_free(p);
    654c:	4b0c      	ldr	r3, [pc, #48]	; (6580 <ethernetif_mac_input+0x8c>)
    654e:	4620      	mov	r0, r4
    6550:	4798      	blx	r3
			p = NULL;
			break;
    6552:	e7d6      	b.n	6502 <ethernetif_mac_input+0xe>
		mac_async_read(mac, NULL, 0);
    6554:	4602      	mov	r2, r0
    6556:	4601      	mov	r1, r0
    6558:	4633      	mov	r3, r6
    655a:	4648      	mov	r0, r9
		}
	} while (true);
}
    655c:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
		mac_async_read(mac, NULL, 0);
    6560:	4718      	bx	r3
			if (netif->input(p, netif) != ERR_OK) {
    6562:	692b      	ldr	r3, [r5, #16]
    6564:	4629      	mov	r1, r5
    6566:	4620      	mov	r0, r4
    6568:	4798      	blx	r3
    656a:	2800      	cmp	r0, #0
    656c:	d0c9      	beq.n	6502 <ethernetif_mac_input+0xe>
    656e:	e7ed      	b.n	654c <ethernetif_mac_input+0x58>
}
    6570:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    6574:	00004c31 	.word	0x00004c31
    6578:	00004bfd 	.word	0x00004bfd
    657c:	00000d65 	.word	0x00000d65
    6580:	00003081 	.word	0x00003081
    6584:	000030d9 	.word	0x000030d9
    6588:	00003029 	.word	0x00003029

0000658c <netconn_recv_data>:
 * @param new_buf pointer where a new pbuf/netbuf is stored when received data
 * @return ERR_OK if data has been received, an error code otherwise (timeout,
 *                memory error or another error)
 */
static err_t netconn_recv_data(struct netconn *conn, void **new_buf)
{
    658c:	b5f0      	push	{r4, r5, r6, r7, lr}
    658e:	b089      	sub	sp, #36	; 0x24
	void *buf = NULL;
    6590:	2600      	movs	r6, #0
{
    6592:	4604      	mov	r4, r0
	void *buf = NULL;
    6594:	9601      	str	r6, [sp, #4]
	err_t err;
#if LWIP_TCP
	struct api_msg msg;
#endif /* LWIP_TCP */

	LWIP_ERROR("netconn_recv: invalid pointer", (new_buf != NULL), return ERR_ARG;);
    6596:	460d      	mov	r5, r1
    6598:	b901      	cbnz	r1, 659c <netconn_recv_data+0x10>
    659a:	e7fe      	b.n	659a <netconn_recv_data+0xe>
	*new_buf = NULL;
    659c:	600e      	str	r6, [r1, #0]
	LWIP_ERROR("netconn_recv: invalid conn", (conn != NULL), return ERR_ARG;);
    659e:	b900      	cbnz	r0, 65a2 <netconn_recv_data+0x16>
    65a0:	e7fe      	b.n	65a0 <netconn_recv_data+0x14>
	LWIP_ERROR("netconn_accept: invalid recvmbox", sys_mbox_valid(&conn->recvmbox), return ERR_CONN;);
    65a2:	f100 0710 	add.w	r7, r0, #16
    65a6:	4b20      	ldr	r3, [pc, #128]	; (6628 <netconn_recv_data+0x9c>)
    65a8:	4638      	mov	r0, r7
    65aa:	4798      	blx	r3
    65ac:	b900      	cbnz	r0, 65b0 <netconn_recv_data+0x24>
    65ae:	e7fe      	b.n	65ae <netconn_recv_data+0x22>

	err = conn->last_err;
    65b0:	f994 0008 	ldrsb.w	r0, [r4, #8]
	if (ERR_IS_FATAL(err)) {
    65b4:	f110 0f09 	cmn.w	r0, #9
    65b8:	db30      	blt.n	661c <netconn_recv_data+0x90>
	if (sys_arch_mbox_fetch(&conn->recvmbox, &buf, conn->recv_timeout) == SYS_ARCH_TIMEOUT) {
		NETCONN_SET_SAFE_ERR(conn, ERR_TIMEOUT);
		return ERR_TIMEOUT;
	}
#else
	sys_arch_mbox_fetch(&conn->recvmbox, &buf, 0);
    65ba:	4b1c      	ldr	r3, [pc, #112]	; (662c <netconn_recv_data+0xa0>)
    65bc:	4632      	mov	r2, r6
    65be:	a901      	add	r1, sp, #4
    65c0:	4638      	mov	r0, r7
    65c2:	4798      	blx	r3
#endif /* LWIP_SO_RCVTIMEO*/

#if LWIP_TCP
#if (LWIP_UDP || LWIP_RAW)
	if (conn->type == NETCONN_TCP)
    65c4:	7823      	ldrb	r3, [r4, #0]
    65c6:	2b10      	cmp	r3, #16
    65c8:	9b01      	ldr	r3, [sp, #4]
    65ca:	d129      	bne.n	6620 <netconn_recv_data+0x94>
#endif /* (LWIP_UDP || LWIP_RAW) */
	{
		if (!netconn_get_noautorecved(conn) || (buf == NULL)) {
    65cc:	7f22      	ldrb	r2, [r4, #28]
    65ce:	0712      	lsls	r2, r2, #28
    65d0:	d500      	bpl.n	65d4 <netconn_recv_data+0x48>
    65d2:	b943      	cbnz	r3, 65e6 <netconn_recv_data+0x5a>
			/* Let the stack know that we have taken the data. */
			/* TODO: Speedup: Don't block and wait for the answer here
			   (to prevent multiple thread-switches). */
			msg.function = do_recv;
    65d4:	4a16      	ldr	r2, [pc, #88]	; (6630 <netconn_recv_data+0xa4>)
			msg.msg.conn = conn;
    65d6:	e9cd 2402 	strd	r2, r4, [sp, #8]
			if (buf != NULL) {
    65da:	b1a3      	cbz	r3, 6606 <netconn_recv_data+0x7a>
				msg.msg.msg.r.len = ((struct pbuf *)buf)->tot_len;
    65dc:	891b      	ldrh	r3, [r3, #8]
    65de:	9305      	str	r3, [sp, #20]
			} else {
				msg.msg.msg.r.len = 1;
			}
			/* don't care for the return value of do_recv */
			TCPIP_APIMSG(&msg);
    65e0:	a802      	add	r0, sp, #8
    65e2:	4b14      	ldr	r3, [pc, #80]	; (6634 <netconn_recv_data+0xa8>)
    65e4:	4798      	blx	r3
		}

		/* If we are closed, we indicate that we no longer wish to use the socket */
		if (buf == NULL) {
    65e6:	9a01      	ldr	r2, [sp, #4]
    65e8:	b97a      	cbnz	r2, 660a <netconn_recv_data+0x7e>
			API_EVENT(conn, NETCONN_EVT_RCVMINUS, 0);
    65ea:	6aa3      	ldr	r3, [r4, #40]	; 0x28
    65ec:	b113      	cbz	r3, 65f4 <netconn_recv_data+0x68>
    65ee:	2101      	movs	r1, #1
    65f0:	4620      	mov	r0, r4
    65f2:	4798      	blx	r3
			/* Avoid to lose any previous error code */
			NETCONN_SET_SAFE_ERR(conn, ERR_CLSD);
    65f4:	f994 3008 	ldrsb.w	r3, [r4, #8]
    65f8:	3309      	adds	r3, #9
    65fa:	db01      	blt.n	6600 <netconn_recv_data+0x74>
    65fc:	23f4      	movs	r3, #244	; 0xf4
    65fe:	7223      	strb	r3, [r4, #8]
			return ERR_CLSD;
    6600:	f06f 000b 	mvn.w	r0, #11
    6604:	e00a      	b.n	661c <netconn_recv_data+0x90>
				msg.msg.msg.r.len = 1;
    6606:	2301      	movs	r3, #1
    6608:	e7e9      	b.n	65de <netconn_recv_data+0x52>
		}
		len = ((struct pbuf *)buf)->tot_len;
    660a:	8912      	ldrh	r2, [r2, #8]

#if LWIP_SO_RCVBUF
	SYS_ARCH_DEC(conn->recv_avail, len);
#endif /* LWIP_SO_RCVBUF */
	/* Register event with callback */
	API_EVENT(conn, NETCONN_EVT_RCVMINUS, len);
    660c:	6aa3      	ldr	r3, [r4, #40]	; 0x28
    660e:	b113      	cbz	r3, 6616 <netconn_recv_data+0x8a>
    6610:	2101      	movs	r1, #1
    6612:	4620      	mov	r0, r4
    6614:	4798      	blx	r3

	LWIP_DEBUGF(API_LIB_DEBUG, ("netconn_recv_data: received %p, len=%" U16_F "\n", buf, len));

	*new_buf = buf;
    6616:	9b01      	ldr	r3, [sp, #4]
    6618:	602b      	str	r3, [r5, #0]
	/* don't set conn->last_err: it's only ERR_OK, anyway */
	return ERR_OK;
    661a:	2000      	movs	r0, #0
}
    661c:	b009      	add	sp, #36	; 0x24
    661e:	bdf0      	pop	{r4, r5, r6, r7, pc}
		len = netbuf_len((struct netbuf *)buf);
    6620:	681b      	ldr	r3, [r3, #0]
    6622:	891a      	ldrh	r2, [r3, #8]
    6624:	e7f2      	b.n	660c <netconn_recv_data+0x80>
    6626:	bf00      	nop
    6628:	00006c71 	.word	0x00006c71
    662c:	00006be5 	.word	0x00006be5
    6630:	00001bb5 	.word	0x00001bb5
    6634:	000093ad 	.word	0x000093ad

00006638 <netconn_new_with_proto_and_callback>:
{
    6638:	b530      	push	{r4, r5, lr}
	conn = netconn_alloc(t, callback);
    663a:	4b10      	ldr	r3, [pc, #64]	; (667c <netconn_new_with_proto_and_callback+0x44>)
{
    663c:	b087      	sub	sp, #28
    663e:	460d      	mov	r5, r1
	conn = netconn_alloc(t, callback);
    6640:	4611      	mov	r1, r2
    6642:	4798      	blx	r3
	if (conn != NULL) {
    6644:	4604      	mov	r4, r0
    6646:	b1a8      	cbz	r0, 6674 <netconn_new_with_proto_and_callback+0x3c>
		msg.function        = do_newconn;
    6648:	4b0d      	ldr	r3, [pc, #52]	; (6680 <netconn_new_with_proto_and_callback+0x48>)
    664a:	9300      	str	r3, [sp, #0]
		msg.msg.conn        = conn;
    664c:	9001      	str	r0, [sp, #4]
		if (TCPIP_APIMSG(&msg) != ERR_OK) {
    664e:	4b0d      	ldr	r3, [pc, #52]	; (6684 <netconn_new_with_proto_and_callback+0x4c>)
		msg.msg.msg.n.proto = proto;
    6650:	f88d 500c 	strb.w	r5, [sp, #12]
		if (TCPIP_APIMSG(&msg) != ERR_OK) {
    6654:	4668      	mov	r0, sp
    6656:	4798      	blx	r3
    6658:	b160      	cbz	r0, 6674 <netconn_new_with_proto_and_callback+0x3c>
			sys_sem_free(&conn->op_completed);
    665a:	f104 000c 	add.w	r0, r4, #12
    665e:	4b0a      	ldr	r3, [pc, #40]	; (6688 <netconn_new_with_proto_and_callback+0x50>)
    6660:	4798      	blx	r3
			sys_mbox_free(&conn->recvmbox);
    6662:	f104 0010 	add.w	r0, r4, #16
    6666:	4b09      	ldr	r3, [pc, #36]	; (668c <netconn_new_with_proto_and_callback+0x54>)
    6668:	4798      	blx	r3
			memp_free(MEMP_NETCONN, conn);
    666a:	4621      	mov	r1, r4
    666c:	4b08      	ldr	r3, [pc, #32]	; (6690 <netconn_new_with_proto_and_callback+0x58>)
    666e:	2007      	movs	r0, #7
    6670:	4798      	blx	r3
			return NULL;
    6672:	2400      	movs	r4, #0
}
    6674:	4620      	mov	r0, r4
    6676:	b007      	add	sp, #28
    6678:	bd30      	pop	{r4, r5, pc}
    667a:	bf00      	nop
    667c:	00001769 	.word	0x00001769
    6680:	000016ed 	.word	0x000016ed
    6684:	000093ad 	.word	0x000093ad
    6688:	00006a9d 	.word	0x00006a9d
    668c:	00006b51 	.word	0x00006b51
    6690:	00004b49 	.word	0x00004b49

00006694 <netconn_delete>:
{
    6694:	b510      	push	{r4, lr}
	if (conn == NULL) {
    6696:	4604      	mov	r4, r0
{
    6698:	b086      	sub	sp, #24
	if (conn == NULL) {
    669a:	b140      	cbz	r0, 66ae <netconn_delete+0x1a>
	msg.function = do_delconn;
    669c:	4b05      	ldr	r3, [pc, #20]	; (66b4 <netconn_delete+0x20>)
	msg.msg.conn = conn;
    669e:	e9cd 3000 	strd	r3, r0, [sp]
	tcpip_apimsg(&msg);
    66a2:	4b05      	ldr	r3, [pc, #20]	; (66b8 <netconn_delete+0x24>)
    66a4:	4668      	mov	r0, sp
    66a6:	4798      	blx	r3
	netconn_free(conn);
    66a8:	4b04      	ldr	r3, [pc, #16]	; (66bc <netconn_delete+0x28>)
    66aa:	4620      	mov	r0, r4
    66ac:	4798      	blx	r3
}
    66ae:	2000      	movs	r0, #0
    66b0:	b006      	add	sp, #24
    66b2:	bd10      	pop	{r4, pc}
    66b4:	0000199d 	.word	0x0000199d
    66b8:	000093ad 	.word	0x000093ad
    66bc:	000017e1 	.word	0x000017e1

000066c0 <netconn_getaddr>:
{
    66c0:	b510      	push	{r4, lr}
	LWIP_ERROR("netconn_getaddr: invalid conn", (conn != NULL), return ERR_ARG;);
    66c2:	4604      	mov	r4, r0
{
    66c4:	b086      	sub	sp, #24
	LWIP_ERROR("netconn_getaddr: invalid conn", (conn != NULL), return ERR_ARG;);
    66c6:	b900      	cbnz	r0, 66ca <netconn_getaddr+0xa>
    66c8:	e7fe      	b.n	66c8 <netconn_getaddr+0x8>
	LWIP_ERROR("netconn_getaddr: invalid addr", (addr != NULL), return ERR_ARG;);
    66ca:	b901      	cbnz	r1, 66ce <netconn_getaddr+0xe>
    66cc:	e7fe      	b.n	66cc <netconn_getaddr+0xc>
	LWIP_ERROR("netconn_getaddr: invalid port", (port != NULL), return ERR_ARG;);
    66ce:	b902      	cbnz	r2, 66d2 <netconn_getaddr+0x12>
    66d0:	e7fe      	b.n	66d0 <netconn_getaddr+0x10>
	msg.function          = do_getaddr;
    66d2:	4808      	ldr	r0, [pc, #32]	; (66f4 <netconn_getaddr+0x34>)
	msg.msg.msg.ad.local  = local;
    66d4:	f88d 3014 	strb.w	r3, [sp, #20]
	msg.msg.conn          = conn;
    66d8:	e9cd 0400 	strd	r0, r4, [sp]
	err                   = TCPIP_APIMSG(&msg);
    66dc:	4b06      	ldr	r3, [pc, #24]	; (66f8 <netconn_getaddr+0x38>)
    66de:	4668      	mov	r0, sp
	msg.msg.msg.ad.port   = port;
    66e0:	e9cd 1203 	strd	r1, r2, [sp, #12]
	err                   = TCPIP_APIMSG(&msg);
    66e4:	4798      	blx	r3
	NETCONN_SET_SAFE_ERR(conn, err);
    66e6:	f994 3008 	ldrsb.w	r3, [r4, #8]
    66ea:	3309      	adds	r3, #9
    66ec:	bfa8      	it	ge
    66ee:	7220      	strbge	r0, [r4, #8]
}
    66f0:	b006      	add	sp, #24
    66f2:	bd10      	pop	{r4, pc}
    66f4:	00001c41 	.word	0x00001c41
    66f8:	000093ad 	.word	0x000093ad

000066fc <netconn_bind>:
{
    66fc:	b510      	push	{r4, lr}
	LWIP_ERROR("netconn_bind: invalid conn", (conn != NULL), return ERR_ARG;);
    66fe:	4604      	mov	r4, r0
{
    6700:	b086      	sub	sp, #24
	LWIP_ERROR("netconn_bind: invalid conn", (conn != NULL), return ERR_ARG;);
    6702:	b900      	cbnz	r0, 6706 <netconn_bind+0xa>
    6704:	e7fe      	b.n	6704 <netconn_bind+0x8>
	msg.function          = do_bind;
    6706:	4b08      	ldr	r3, [pc, #32]	; (6728 <netconn_bind+0x2c>)
	msg.msg.msg.bc.ipaddr = addr;
    6708:	9103      	str	r1, [sp, #12]
	msg.msg.conn          = conn;
    670a:	e9cd 3000 	strd	r3, r0, [sp]
	err                   = TCPIP_APIMSG(&msg);
    670e:	4b07      	ldr	r3, [pc, #28]	; (672c <netconn_bind+0x30>)
	msg.msg.msg.bc.port   = port;
    6710:	f8ad 2010 	strh.w	r2, [sp, #16]
	err                   = TCPIP_APIMSG(&msg);
    6714:	4668      	mov	r0, sp
    6716:	4798      	blx	r3
	NETCONN_SET_SAFE_ERR(conn, err);
    6718:	f994 3008 	ldrsb.w	r3, [r4, #8]
    671c:	3309      	adds	r3, #9
    671e:	bfa8      	it	ge
    6720:	7220      	strbge	r0, [r4, #8]
}
    6722:	b006      	add	sp, #24
    6724:	bd10      	pop	{r4, pc}
    6726:	bf00      	nop
    6728:	00001a35 	.word	0x00001a35
    672c:	000093ad 	.word	0x000093ad

00006730 <netconn_listen_with_backlog>:
{
    6730:	b510      	push	{r4, lr}
	LWIP_ERROR("netconn_listen: invalid conn", (conn != NULL), return ERR_ARG;);
    6732:	4604      	mov	r4, r0
{
    6734:	b086      	sub	sp, #24
	LWIP_ERROR("netconn_listen: invalid conn", (conn != NULL), return ERR_ARG;);
    6736:	b900      	cbnz	r0, 673a <netconn_listen_with_backlog+0xa>
    6738:	e7fe      	b.n	6738 <netconn_listen_with_backlog+0x8>
	msg.function = do_listen;
    673a:	4b06      	ldr	r3, [pc, #24]	; (6754 <netconn_listen_with_backlog+0x24>)
	msg.msg.conn = conn;
    673c:	e9cd 3000 	strd	r3, r0, [sp]
	err = TCPIP_APIMSG(&msg);
    6740:	4b05      	ldr	r3, [pc, #20]	; (6758 <netconn_listen_with_backlog+0x28>)
    6742:	4668      	mov	r0, sp
    6744:	4798      	blx	r3
	NETCONN_SET_SAFE_ERR(conn, err);
    6746:	f994 3008 	ldrsb.w	r3, [r4, #8]
    674a:	3309      	adds	r3, #9
    674c:	bfa8      	it	ge
    674e:	7220      	strbge	r0, [r4, #8]
}
    6750:	b006      	add	sp, #24
    6752:	bd10      	pop	{r4, pc}
    6754:	00001a8d 	.word	0x00001a8d
    6758:	000093ad 	.word	0x000093ad

0000675c <netconn_accept>:
{
    675c:	b573      	push	{r0, r1, r4, r5, r6, lr}
    675e:	4604      	mov	r4, r0
	LWIP_ERROR("netconn_accept: invalid pointer", (new_conn != NULL), return ERR_ARG;);
    6760:	460d      	mov	r5, r1
    6762:	b901      	cbnz	r1, 6766 <netconn_accept+0xa>
    6764:	e7fe      	b.n	6764 <netconn_accept+0x8>
	*new_conn = NULL;
    6766:	2200      	movs	r2, #0
    6768:	600a      	str	r2, [r1, #0]
	LWIP_ERROR("netconn_accept: invalid conn", (conn != NULL), return ERR_ARG;);
    676a:	b900      	cbnz	r0, 676e <netconn_accept+0x12>
    676c:	e7fe      	b.n	676c <netconn_accept+0x10>
	LWIP_ERROR("netconn_accept: invalid acceptmbox", sys_mbox_valid(&conn->acceptmbox), return ERR_ARG;);
    676e:	f100 0614 	add.w	r6, r0, #20
    6772:	4b12      	ldr	r3, [pc, #72]	; (67bc <netconn_accept+0x60>)
    6774:	4630      	mov	r0, r6
    6776:	4798      	blx	r3
    6778:	2200      	movs	r2, #0
    677a:	b900      	cbnz	r0, 677e <netconn_accept+0x22>
    677c:	e7fe      	b.n	677c <netconn_accept+0x20>
	err = conn->last_err;
    677e:	f994 0008 	ldrsb.w	r0, [r4, #8]
	if (ERR_IS_FATAL(err)) {
    6782:	f110 0f09 	cmn.w	r0, #9
    6786:	db16      	blt.n	67b6 <netconn_accept+0x5a>
	sys_arch_mbox_fetch(&conn->acceptmbox, (void **)&newconn, 0);
    6788:	4b0d      	ldr	r3, [pc, #52]	; (67c0 <netconn_accept+0x64>)
    678a:	a901      	add	r1, sp, #4
    678c:	4630      	mov	r0, r6
    678e:	4798      	blx	r3
	API_EVENT(conn, NETCONN_EVT_RCVMINUS, 0);
    6790:	6aa3      	ldr	r3, [r4, #40]	; 0x28
    6792:	b11b      	cbz	r3, 679c <netconn_accept+0x40>
    6794:	2200      	movs	r2, #0
    6796:	2101      	movs	r1, #1
    6798:	4620      	mov	r0, r4
    679a:	4798      	blx	r3
	if (newconn == NULL) {
    679c:	9b01      	ldr	r3, [sp, #4]
    679e:	b943      	cbnz	r3, 67b2 <netconn_accept+0x56>
		NETCONN_SET_SAFE_ERR(conn, ERR_ABRT);
    67a0:	f994 3008 	ldrsb.w	r3, [r4, #8]
    67a4:	3309      	adds	r3, #9
    67a6:	db01      	blt.n	67ac <netconn_accept+0x50>
    67a8:	23f6      	movs	r3, #246	; 0xf6
    67aa:	7223      	strb	r3, [r4, #8]
		return ERR_ABRT;
    67ac:	f06f 0009 	mvn.w	r0, #9
    67b0:	e001      	b.n	67b6 <netconn_accept+0x5a>
	*new_conn = newconn;
    67b2:	602b      	str	r3, [r5, #0]
	return ERR_OK;
    67b4:	2000      	movs	r0, #0
}
    67b6:	b002      	add	sp, #8
    67b8:	bd70      	pop	{r4, r5, r6, pc}
    67ba:	bf00      	nop
    67bc:	00006c71 	.word	0x00006c71
    67c0:	00006be5 	.word	0x00006be5

000067c4 <netconn_recv_tcp_pbuf>:
 *                memory error or another error)
 *         ERR_ARG if conn is not a TCP netconn
 */
err_t netconn_recv_tcp_pbuf(struct netconn *conn, struct pbuf **new_buf)
{
	LWIP_ERROR("netconn_recv: invalid conn", (conn != NULL) && netconn_type(conn) == NETCONN_TCP, return ERR_ARG;);
    67c4:	b110      	cbz	r0, 67cc <netconn_recv_tcp_pbuf+0x8>
    67c6:	7803      	ldrb	r3, [r0, #0]
    67c8:	2b10      	cmp	r3, #16
    67ca:	d000      	beq.n	67ce <netconn_recv_tcp_pbuf+0xa>
    67cc:	e7fe      	b.n	67cc <netconn_recv_tcp_pbuf+0x8>

	return netconn_recv_data(conn, (void **)new_buf);
    67ce:	4b01      	ldr	r3, [pc, #4]	; (67d4 <netconn_recv_tcp_pbuf+0x10>)
    67d0:	4718      	bx	r3
    67d2:	bf00      	nop
    67d4:	0000658d 	.word	0x0000658d

000067d8 <netconn_recv>:
 * @param new_buf pointer where a new netbuf is stored when received data
 * @return ERR_OK if data has been received, an error code otherwise (timeout,
 *                memory error or another error)
 */
err_t netconn_recv(struct netconn *conn, struct netbuf **new_buf)
{
    67d8:	b573      	push	{r0, r1, r4, r5, r6, lr}
    67da:	4604      	mov	r4, r0
#if LWIP_TCP
	struct netbuf *buf = NULL;
	err_t          err;
#endif /* LWIP_TCP */

	LWIP_ERROR("netconn_recv: invalid pointer", (new_buf != NULL), return ERR_ARG;);
    67dc:	460e      	mov	r6, r1
    67de:	b901      	cbnz	r1, 67e2 <netconn_recv+0xa>
    67e0:	e7fe      	b.n	67e0 <netconn_recv+0x8>
	*new_buf = NULL;
    67e2:	2500      	movs	r5, #0
    67e4:	600d      	str	r5, [r1, #0]
	LWIP_ERROR("netconn_recv: invalid conn", (conn != NULL), return ERR_ARG;);
    67e6:	b900      	cbnz	r0, 67ea <netconn_recv+0x12>
    67e8:	e7fe      	b.n	67e8 <netconn_recv+0x10>
	LWIP_ERROR("netconn_accept: invalid recvmbox", sys_mbox_valid(&conn->recvmbox), return ERR_CONN;);
    67ea:	4b19      	ldr	r3, [pc, #100]	; (6850 <netconn_recv+0x78>)
    67ec:	3010      	adds	r0, #16
    67ee:	4798      	blx	r3
    67f0:	b900      	cbnz	r0, 67f4 <netconn_recv+0x1c>
    67f2:	e7fe      	b.n	67f2 <netconn_recv+0x1a>

#if LWIP_TCP
#if (LWIP_UDP || LWIP_RAW)
	if (conn->type == NETCONN_TCP)
    67f4:	7823      	ldrb	r3, [r4, #0]
    67f6:	2b10      	cmp	r3, #16
    67f8:	d122      	bne.n	6840 <netconn_recv+0x68>
#endif /* (LWIP_UDP || LWIP_RAW) */
	{
		struct pbuf *p = NULL;
		/* This is not a listening netconn, since recvmbox is set */

		buf = (struct netbuf *)memp_malloc(MEMP_NETBUF);
    67fa:	4b16      	ldr	r3, [pc, #88]	; (6854 <netconn_recv+0x7c>)
		struct pbuf *p = NULL;
    67fc:	9501      	str	r5, [sp, #4]
		buf = (struct netbuf *)memp_malloc(MEMP_NETBUF);
    67fe:	2006      	movs	r0, #6
    6800:	4798      	blx	r3
		if (buf == NULL) {
    6802:	4605      	mov	r5, r0
    6804:	b940      	cbnz	r0, 6818 <netconn_recv+0x40>
			NETCONN_SET_SAFE_ERR(conn, ERR_MEM);
    6806:	f994 3008 	ldrsb.w	r3, [r4, #8]
    680a:	3309      	adds	r3, #9
    680c:	db01      	blt.n	6812 <netconn_recv+0x3a>
    680e:	23ff      	movs	r3, #255	; 0xff
    6810:	7223      	strb	r3, [r4, #8]
			return ERR_MEM;
    6812:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
    6816:	e009      	b.n	682c <netconn_recv+0x54>
		}

		err = netconn_recv_data(conn, (void **)&p);
    6818:	4620      	mov	r0, r4
    681a:	4b0f      	ldr	r3, [pc, #60]	; (6858 <netconn_recv+0x80>)
    681c:	a901      	add	r1, sp, #4
    681e:	4798      	blx	r3
		if (err != ERR_OK) {
    6820:	4604      	mov	r4, r0
    6822:	b130      	cbz	r0, 6832 <netconn_recv+0x5a>
			memp_free(MEMP_NETBUF, buf);
    6824:	4b0d      	ldr	r3, [pc, #52]	; (685c <netconn_recv+0x84>)
    6826:	4629      	mov	r1, r5
    6828:	2006      	movs	r0, #6
    682a:	4798      	blx	r3
	{
#if (LWIP_UDP || LWIP_RAW)
		return netconn_recv_data(conn, (void **)new_buf);
#endif /* (LWIP_UDP || LWIP_RAW) */
	}
}
    682c:	4620      	mov	r0, r4
    682e:	b002      	add	sp, #8
    6830:	bd70      	pop	{r4, r5, r6, pc}
		buf->p    = p;
    6832:	9b01      	ldr	r3, [sp, #4]
		buf->port = 0;
    6834:	81a8      	strh	r0, [r5, #12]
		buf->ptr  = p;
    6836:	e9c5 3300 	strd	r3, r3, [r5]
		ip_addr_set_any(&buf->addr);
    683a:	60a8      	str	r0, [r5, #8]
		*new_buf = buf;
    683c:	6035      	str	r5, [r6, #0]
		return ERR_OK;
    683e:	e7f5      	b.n	682c <netconn_recv+0x54>
		return netconn_recv_data(conn, (void **)new_buf);
    6840:	4b05      	ldr	r3, [pc, #20]	; (6858 <netconn_recv+0x80>)
    6842:	4631      	mov	r1, r6
    6844:	4620      	mov	r0, r4
}
    6846:	b002      	add	sp, #8
    6848:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		return netconn_recv_data(conn, (void **)new_buf);
    684c:	4718      	bx	r3
    684e:	bf00      	nop
    6850:	00006c71 	.word	0x00006c71
    6854:	00004b2d 	.word	0x00004b2d
    6858:	0000658d 	.word	0x0000658d
    685c:	00004b49 	.word	0x00004b49

00006860 <netconn_recved>:
 *
 * @param conn the netconn for which to update the receive window
 * @param length amount of data processed (ATTENTION: this must be accurate!)
 */
void netconn_recved(struct netconn *conn, u32_t length)
{
    6860:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
#if LWIP_TCP
	if ((conn != NULL) && (conn->type == NETCONN_TCP) && (netconn_get_noautorecved(conn))) {
    6862:	b160      	cbz	r0, 687e <netconn_recved+0x1e>
    6864:	7803      	ldrb	r3, [r0, #0]
    6866:	2b10      	cmp	r3, #16
    6868:	d109      	bne.n	687e <netconn_recved+0x1e>
    686a:	7f03      	ldrb	r3, [r0, #28]
    686c:	071b      	lsls	r3, r3, #28
    686e:	d506      	bpl.n	687e <netconn_recved+0x1e>
		struct api_msg msg;
		/* Let the stack know that we have taken the data. */
		/* TODO: Speedup: Don't block and wait for the answer here
		   (to prevent multiple thread-switches). */
		msg.function      = do_recv;
    6870:	4b04      	ldr	r3, [pc, #16]	; (6884 <netconn_recved+0x24>)
		msg.msg.conn      = conn;
		msg.msg.msg.r.len = length;
    6872:	9103      	str	r1, [sp, #12]
		msg.msg.conn      = conn;
    6874:	e9cd 3000 	strd	r3, r0, [sp]
		/* don't care for the return value of do_recv */
		TCPIP_APIMSG(&msg);
    6878:	4b03      	ldr	r3, [pc, #12]	; (6888 <netconn_recved+0x28>)
    687a:	4668      	mov	r0, sp
    687c:	4798      	blx	r3
	}
#else  /* LWIP_TCP */
	LWIP_UNUSED_ARG(conn);
	LWIP_UNUSED_ARG(length);
#endif /* LWIP_TCP */
}
    687e:	b007      	add	sp, #28
    6880:	f85d fb04 	ldr.w	pc, [sp], #4
    6884:	00001bb5 	.word	0x00001bb5
    6888:	000093ad 	.word	0x000093ad

0000688c <netconn_send>:
 * @param conn the UDP or RAW netconn over which to send data
 * @param buf a netbuf containing the data to send
 * @return ERR_OK if data was sent, any other err_t on error
 */
err_t netconn_send(struct netconn *conn, struct netbuf *buf)
{
    688c:	b510      	push	{r4, lr}
	struct api_msg msg;
	err_t          err;

	LWIP_ERROR("netconn_send: invalid conn", (conn != NULL), return ERR_ARG;);
    688e:	4604      	mov	r4, r0
{
    6890:	b086      	sub	sp, #24
	LWIP_ERROR("netconn_send: invalid conn", (conn != NULL), return ERR_ARG;);
    6892:	b900      	cbnz	r0, 6896 <netconn_send+0xa>
    6894:	e7fe      	b.n	6894 <netconn_send+0x8>

	LWIP_DEBUGF(API_LIB_DEBUG, ("netconn_send: sending %" U16_F " bytes\n", buf->p->tot_len));
	msg.function  = do_send;
    6896:	4b07      	ldr	r3, [pc, #28]	; (68b4 <netconn_send+0x28>)
	msg.msg.conn  = conn;
	msg.msg.msg.b = buf;
    6898:	9103      	str	r1, [sp, #12]
	msg.msg.conn  = conn;
    689a:	e9cd 3000 	strd	r3, r0, [sp]
	err           = TCPIP_APIMSG(&msg);
    689e:	4b06      	ldr	r3, [pc, #24]	; (68b8 <netconn_send+0x2c>)
    68a0:	4668      	mov	r0, sp
    68a2:	4798      	blx	r3

	NETCONN_SET_SAFE_ERR(conn, err);
    68a4:	f994 3008 	ldrsb.w	r3, [r4, #8]
    68a8:	3309      	adds	r3, #9
    68aa:	bfa8      	it	ge
    68ac:	7220      	strbge	r0, [r4, #8]
	return err;
}
    68ae:	b006      	add	sp, #24
    68b0:	bd10      	pop	{r4, pc}
    68b2:	bf00      	nop
    68b4:	00001b5d 	.word	0x00001b5d
    68b8:	000093ad 	.word	0x000093ad

000068bc <netconn_write_partly>:
 * - NETCONN_DONTBLOCK: only write the data if all dat can be written at once
 * @param bytes_written pointer to a location that receives the number of written bytes
 * @return ERR_OK if data was sent, any other err_t on error
 */
err_t netconn_write_partly(struct netconn *conn, const void *dataptr, size_t size, u8_t apiflags, size_t *bytes_written)
{
    68bc:	b5f0      	push	{r4, r5, r6, r7, lr}
    68be:	b087      	sub	sp, #28
    68c0:	4616      	mov	r6, r2
    68c2:	9f0c      	ldr	r7, [sp, #48]	; 0x30
	struct api_msg msg;
	err_t          err;
	u8_t           dontblock;

	LWIP_ERROR("netconn_write: invalid conn", (conn != NULL), return ERR_ARG;);
    68c4:	4605      	mov	r5, r0
    68c6:	b900      	cbnz	r0, 68ca <netconn_write_partly+0xe>
    68c8:	e7fe      	b.n	68c8 <netconn_write_partly+0xc>
	LWIP_ERROR("netconn_write: invalid conn->type", (conn->type == NETCONN_TCP), return ERR_VAL;);
    68ca:	7802      	ldrb	r2, [r0, #0]
    68cc:	2a10      	cmp	r2, #16
    68ce:	d000      	beq.n	68d2 <netconn_write_partly+0x16>
    68d0:	e7fe      	b.n	68d0 <netconn_write_partly+0x14>
	if (size == 0) {
    68d2:	b306      	cbz	r6, 6916 <netconn_write_partly+0x5a>
		return ERR_OK;
	}
	dontblock = netconn_is_nonblocking(conn) || (apiflags & NETCONN_DONTBLOCK);
	if (dontblock && !bytes_written) {
    68d4:	7f04      	ldrb	r4, [r0, #28]
    68d6:	f003 0204 	and.w	r2, r3, #4
    68da:	f004 0402 	and.w	r4, r4, #2
    68de:	4314      	orrs	r4, r2
    68e0:	d001      	beq.n	68e6 <netconn_write_partly+0x2a>
    68e2:	b1d7      	cbz	r7, 691a <netconn_write_partly+0x5e>
    68e4:	2401      	movs	r4, #1
		   it has no way to return the number of bytes written. */
		return ERR_VAL;
	}

	/* non-blocking write sends as much  */
	msg.function           = do_write;
    68e6:	4a0e      	ldr	r2, [pc, #56]	; (6920 <netconn_write_partly+0x64>)
	msg.msg.conn           = conn;
	msg.msg.msg.w.dataptr  = dataptr;
	msg.msg.msg.w.apiflags = apiflags;
    68e8:	f88d 3014 	strb.w	r3, [sp, #20]
#endif /* LWIP_SO_SNDTIMEO */

	/* For locking the core: this _can_ be delayed on low memory/low send buffer,
	   but if it is, this is done inside api_msg.c:do_write(), so we can use the
	   non-blocking version here. */
	err = TCPIP_APIMSG(&msg);
    68ec:	4668      	mov	r0, sp
    68ee:	4b0d      	ldr	r3, [pc, #52]	; (6924 <netconn_write_partly+0x68>)
	msg.msg.msg.w.dataptr  = dataptr;
    68f0:	9103      	str	r1, [sp, #12]
	msg.msg.conn           = conn;
    68f2:	e9cd 2500 	strd	r2, r5, [sp]
	msg.msg.msg.w.len      = size;
    68f6:	9604      	str	r6, [sp, #16]
	err = TCPIP_APIMSG(&msg);
    68f8:	4798      	blx	r3
	if ((err == ERR_OK) && (bytes_written != NULL)) {
    68fa:	b918      	cbnz	r0, 6904 <netconn_write_partly+0x48>
    68fc:	b117      	cbz	r7, 6904 <netconn_write_partly+0x48>
		if (dontblock
    68fe:	b144      	cbz	r4, 6912 <netconn_write_partly+0x56>
#if LWIP_SO_SNDTIMEO
		    || (conn->send_timeout != 0)
#endif /* LWIP_SO_SNDTIMEO */
		) {
			/* nonblocking write: maybe the data has been sent partly */
			*bytes_written = msg.msg.msg.w.len;
    6900:	9b04      	ldr	r3, [sp, #16]
    6902:	603b      	str	r3, [r7, #0]
			/* blocking call succeeded: all data has been sent if it */
			*bytes_written = size;
		}
	}

	NETCONN_SET_SAFE_ERR(conn, err);
    6904:	f995 3008 	ldrsb.w	r3, [r5, #8]
    6908:	3309      	adds	r3, #9
    690a:	db00      	blt.n	690e <netconn_write_partly+0x52>
    690c:	7228      	strb	r0, [r5, #8]
	return err;
}
    690e:	b007      	add	sp, #28
    6910:	bdf0      	pop	{r4, r5, r6, r7, pc}
			*bytes_written = size;
    6912:	603e      	str	r6, [r7, #0]
    6914:	e7f6      	b.n	6904 <netconn_write_partly+0x48>
		return ERR_OK;
    6916:	4630      	mov	r0, r6
    6918:	e7f9      	b.n	690e <netconn_write_partly+0x52>
		return ERR_VAL;
    691a:	f06f 0005 	mvn.w	r0, #5
    691e:	e7f6      	b.n	690e <netconn_write_partly+0x52>
    6920:	00001bfd 	.word	0x00001bfd
    6924:	000093ad 	.word	0x000093ad

00006928 <TCPIP_STACK_INTERFACE_0_stack_init>:
 *
 * @param netif the lwip network interface structure for this ethernetif
 * @return ERR_OK  if the loopif is initialized
 */
err_t TCPIP_STACK_INTERFACE_0_stack_init(struct netif *netif)
{
    6928:	b508      	push	{r3, lr}
	LWIP_ASSERT("netif != NULL", (netif != NULL));
	LWIP_ASSERT("netif->state != NULL", (netif->state != NULL));

	netif->output     = etharp_output;
    692a:	4a0d      	ldr	r2, [pc, #52]	; (6960 <TCPIP_STACK_INTERFACE_0_stack_init+0x38>)
	netif->linkoutput = mac_low_level_output;

	/* device capabilities */
	TCPIP_STACK_INTERFACE_0_desc.flags = CONF_TCPIP_STACK_INTERFACE_0_FLAG;
    692c:	4b0d      	ldr	r3, [pc, #52]	; (6964 <TCPIP_STACK_INTERFACE_0_stack_init+0x3c>)
	netif->output     = etharp_output;
    692e:	6142      	str	r2, [r0, #20]
	netif->linkoutput = mac_low_level_output;
    6930:	4a0d      	ldr	r2, [pc, #52]	; (6968 <TCPIP_STACK_INTERFACE_0_stack_init+0x40>)
    6932:	6182      	str	r2, [r0, #24]
	TCPIP_STACK_INTERFACE_0_desc.flags = CONF_TCPIP_STACK_INTERFACE_0_FLAG;
    6934:	2262      	movs	r2, #98	; 0x62
    6936:	f883 202d 	strb.w	r2, [r3, #45]	; 0x2d
	TCPIP_STACK_INTERFACE_0_desc.mtu   = CONF_TCPIP_STACK_INTERFACE_0_MTU;
    693a:	f44f 62c0 	mov.w	r2, #1536	; 0x600
    693e:	849a      	strh	r2, [r3, #36]	; 0x24

	/* set MAC hardware address length */
	memcpy(TCPIP_STACK_INTERFACE_0_desc.hwaddr, TCPIP_STACK_INTERFACE_0_hwaddr, NETIF_MAX_HWADDR_LEN);
    6940:	6b5a      	ldr	r2, [r3, #52]	; 0x34
    6942:	f8c3 2027 	str.w	r2, [r3, #39]	; 0x27
    6946:	8f1a      	ldrh	r2, [r3, #56]	; 0x38
    6948:	f8a3 202b 	strh.w	r2, [r3, #43]	; 0x2b
	TCPIP_STACK_INTERFACE_0_desc.hwaddr_len = ETHARP_HWADDR_LEN;
    694c:	2206      	movs	r2, #6
    694e:	f883 2026 	strb.w	r2, [r3, #38]	; 0x26

#if LWIP_NETIF_HOSTNAME
	/* Initialize interface hostname */
	LWIP_MACIF_desc.hostname = CONF_TCPIP_STACK_INTERFACE_0_HOSTNAME;
#endif
	memcpy(TCPIP_STACK_INTERFACE_0_desc.name, CONF_TCPIP_STACK_INTERFACE_0_HOSTNAME_ABBR, 2);
    6952:	f646 6265 	movw	r2, #28261	; 0x6e65
    6956:	85da      	strh	r2, [r3, #46]	; 0x2e

	/* initialize the mac hardware */
	mac_low_level_init(netif);
    6958:	4b04      	ldr	r3, [pc, #16]	; (696c <TCPIP_STACK_INTERFACE_0_stack_init+0x44>)
    695a:	4798      	blx	r3

	return ERR_OK;
}
    695c:	2000      	movs	r0, #0
    695e:	bd08      	pop	{r3, pc}
    6960:	000050ad 	.word	0x000050ad
    6964:	2001490c 	.word	0x2001490c
    6968:	00006465 	.word	0x00006465
    696c:	00006439 	.word	0x00006439

00006970 <TCPIP_STACK_INTERFACE_0_init>:
void TCPIP_STACK_INTERFACE_0_init(u8_t hwaddr[6])
{
    6970:	b530      	push	{r4, r5, lr}
    6972:	b089      	sub	sp, #36	; 0x24
#if CONF_TCPIP_STACK_INTERFACE_0_DHCP
	ip_addr_set_zero(&ip);
	ip_addr_set_zero(&nm);
	ip_addr_set_zero(&gw);
#else
	ipaddr_aton(CONF_TCPIP_STACK_INTERFACE_0_IP, &ip);
    6974:	4d0e      	ldr	r5, [pc, #56]	; (69b0 <TCPIP_STACK_INTERFACE_0_init+0x40>)
{
    6976:	4604      	mov	r4, r0
	ipaddr_aton(CONF_TCPIP_STACK_INTERFACE_0_IP, &ip);
    6978:	a905      	add	r1, sp, #20
    697a:	480e      	ldr	r0, [pc, #56]	; (69b4 <TCPIP_STACK_INTERFACE_0_init+0x44>)
    697c:	47a8      	blx	r5
	ipaddr_aton(CONF_TCPIP_STACK_INTERFACE_0_NETMASK, &nm);
    697e:	a906      	add	r1, sp, #24
    6980:	480d      	ldr	r0, [pc, #52]	; (69b8 <TCPIP_STACK_INTERFACE_0_init+0x48>)
    6982:	47a8      	blx	r5
	ipaddr_aton(CONF_TCPIP_STACK_INTERFACE_0_GATEWAY, &gw);
    6984:	a907      	add	r1, sp, #28
    6986:	480d      	ldr	r0, [pc, #52]	; (69bc <TCPIP_STACK_INTERFACE_0_init+0x4c>)
    6988:	47a8      	blx	r5
#endif
	memcpy(TCPIP_STACK_INTERFACE_0_hwaddr, hwaddr, 6);
    698a:	480d      	ldr	r0, [pc, #52]	; (69c0 <TCPIP_STACK_INTERFACE_0_init+0x50>)
    698c:	6823      	ldr	r3, [r4, #0]
    698e:	6343      	str	r3, [r0, #52]	; 0x34
    6990:	88a3      	ldrh	r3, [r4, #4]
    6992:	8703      	strh	r3, [r0, #56]	; 0x38

	netif_add(&TCPIP_STACK_INTERFACE_0_desc,
    6994:	4b0b      	ldr	r3, [pc, #44]	; (69c4 <TCPIP_STACK_INTERFACE_0_init+0x54>)
    6996:	9302      	str	r3, [sp, #8]
    6998:	4b0b      	ldr	r3, [pc, #44]	; (69c8 <TCPIP_STACK_INTERFACE_0_init+0x58>)
    699a:	9301      	str	r3, [sp, #4]
    699c:	4b0b      	ldr	r3, [pc, #44]	; (69cc <TCPIP_STACK_INTERFACE_0_init+0x5c>)
    699e:	9300      	str	r3, [sp, #0]
    69a0:	4c0b      	ldr	r4, [pc, #44]	; (69d0 <TCPIP_STACK_INTERFACE_0_init+0x60>)
    69a2:	ab07      	add	r3, sp, #28
    69a4:	aa06      	add	r2, sp, #24
    69a6:	a905      	add	r1, sp, #20
    69a8:	47a0      	blx	r4
	          &nm,
	          &gw,
	          (void *)&COMMUNICATION_IO,
	          TCPIP_STACK_INTERFACE_0_stack_init,
	          ethernet_input);
}
    69aa:	b009      	add	sp, #36	; 0x24
    69ac:	bd30      	pop	{r4, r5, pc}
    69ae:	bf00      	nop
    69b0:	00007ae5 	.word	0x00007ae5
    69b4:	0000a904 	.word	0x0000a904
    69b8:	0000a912 	.word	0x0000a912
    69bc:	0000a920 	.word	0x0000a920
    69c0:	2001490c 	.word	0x2001490c
    69c4:	000051b9 	.word	0x000051b9
    69c8:	00006929 	.word	0x00006929
    69cc:	2000a520 	.word	0x2000a520
    69d0:	000091c9 	.word	0x000091c9

000069d4 <_init_chip>:
}

static inline void hri_nvmctrl_set_CTRLA_RWS_bf(const void *const hw, hri_nvmctrl_ctrla_reg_t mask)
{
	NVMCTRL_CRITICAL_SECTION_ENTER();
	((Nvmctrl *)hw)->CTRLA.reg |= NVMCTRL_CTRLA_RWS(mask);
    69d4:	4a09      	ldr	r2, [pc, #36]	; (69fc <_init_chip+0x28>)
    69d6:	8813      	ldrh	r3, [r2, #0]

/**
 * \brief Initialize the hardware abstraction layer
 */
void _init_chip(void)
{
    69d8:	b510      	push	{r4, lr}
    69da:	b29b      	uxth	r3, r3
    69dc:	8013      	strh	r3, [r2, #0]
	hri_nvmctrl_set_CTRLA_RWS_bf(NVMCTRL, CONF_NVM_WAIT_STATE);

	_osc32kctrl_init_sources();
    69de:	4b08      	ldr	r3, [pc, #32]	; (6a00 <_init_chip+0x2c>)
    69e0:	4798      	blx	r3
	_oscctrl_init_sources();
    69e2:	4b08      	ldr	r3, [pc, #32]	; (6a04 <_init_chip+0x30>)
    69e4:	4798      	blx	r3
	_mclk_init();
    69e6:	4b08      	ldr	r3, [pc, #32]	; (6a08 <_init_chip+0x34>)
    69e8:	4798      	blx	r3
#if _GCLK_INIT_1ST
	_gclk_init_generators_by_fref(_GCLK_INIT_1ST);
#endif
	_oscctrl_init_referenced_generators();
    69ea:	4b08      	ldr	r3, [pc, #32]	; (6a0c <_init_chip+0x38>)
    69ec:	4798      	blx	r3
#endif

#if CONF_CMCC_ENABLE
	cache_init();
#endif
}
    69ee:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	_gclk_init_generators_by_fref(_GCLK_INIT_LAST);
    69f2:	4b07      	ldr	r3, [pc, #28]	; (6a10 <_init_chip+0x3c>)
    69f4:	f640 70ff 	movw	r0, #4095	; 0xfff
    69f8:	4718      	bx	r3
    69fa:	bf00      	nop
    69fc:	41004000 	.word	0x41004000
    6a00:	000047cd 	.word	0x000047cd
    6a04:	00006a15 	.word	0x00006a15
    6a08:	00007c81 	.word	0x00007c81
    6a0c:	00006a2d 	.word	0x00006a2d
    6a10:	00000f95 	.word	0x00000f95

00006a14 <_oscctrl_init_sources>:
}

static inline void hri_oscctrl_write_XOSCCTRL_reg(const void *const hw, uint8_t index, hri_oscctrl_xoscctrl_reg_t data)
{
	OSCCTRL_CRITICAL_SECTION_ENTER();
	((Oscctrl *)hw)->XOSCCTRL[index].reg = data;
    6a14:	4b03      	ldr	r3, [pc, #12]	; (6a24 <_oscctrl_init_sources+0x10>)
    6a16:	4a04      	ldr	r2, [pc, #16]	; (6a28 <_oscctrl_init_sources+0x14>)
    6a18:	619a      	str	r2, [r3, #24]
	return (((Oscctrl *)hw)->STATUS.reg & OSCCTRL_STATUS_XOSCRDY1) >> OSCCTRL_STATUS_XOSCRDY1_Pos;
    6a1a:	691a      	ldr	r2, [r3, #16]
	        | (CONF_XOSC1_XTALEN << OSCCTRL_XOSCCTRL_XTALEN_Pos) | (CONF_XOSC1_ENABLE << OSCCTRL_XOSCCTRL_ENABLE_Pos));
#endif

#if CONF_XOSC1_CONFIG == 1
#if CONF_XOSC1_ENABLE == 1
	while (!hri_oscctrl_get_STATUS_XOSCRDY1_bit(hw))
    6a1c:	0792      	lsls	r2, r2, #30
    6a1e:	d5fc      	bpl.n	6a1a <_oscctrl_init_sources+0x6>
	hri_oscctrl_set_XOSCCTRL_ONDEMAND_bit(hw, 1);
#endif
#endif

	(void)hw;
}
    6a20:	4770      	bx	lr
    6a22:	bf00      	nop
    6a24:	40001000 	.word	0x40001000
    6a28:	03002606 	.word	0x03002606

00006a2c <_oscctrl_init_referenced_generators>:
	hri_gclk_write_GENCTRL_SRC_bf(GCLK, 0, CONF_GCLK_GEN_0_SOURCE);
	while (hri_gclk_get_SYNCBUSY_GENCTRL0_bit(GCLK))
		;
#endif
	(void)hw;
}
    6a2c:	4770      	bx	lr
	...

00006a30 <sys_init>:
	/* Initialize the the per-thread sys_timeouts structures
	   make sure there are no valid pids in the list */
	for (i = 0; i < SYS_THREAD_MAX; i++) {
		Threads_TimeoutsList[i].pid = 0;
	}
	NbActiveThreads = 0;
    6a30:	4b01      	ldr	r3, [pc, #4]	; (6a38 <sys_init+0x8>)
    6a32:	2200      	movs	r2, #0
    6a34:	801a      	strh	r2, [r3, #0]
}
    6a36:	4770      	bx	lr
    6a38:	20014946 	.word	0x20014946

00006a3c <sys_sem_new>:
 * \param count Initial state of the semaphore.
 *
 * \return ERR_OK for OK, other value indicates error.
 */
err_t sys_sem_new(sys_sem_t *sem, u8_t count)
{
    6a3c:	b570      	push	{r4, r5, r6, lr}
    6a3e:	460c      	mov	r4, r1
	err_t err_sem = ERR_MEM;

	/* Sanity check */
	if (sem != NULL) {
    6a40:	4605      	mov	r5, r0
    6a42:	b1f0      	cbz	r0, 6a82 <sys_sem_new+0x46>
		portENTER_CRITICAL();
    6a44:	4b10      	ldr	r3, [pc, #64]	; (6a88 <sys_sem_new+0x4c>)
    6a46:	4798      	blx	r3

		vSemaphoreCreateBinary( *sem );
    6a48:	4b10      	ldr	r3, [pc, #64]	; (6a8c <sys_sem_new+0x50>)
    6a4a:	2203      	movs	r2, #3
    6a4c:	2100      	movs	r1, #0
    6a4e:	2001      	movs	r0, #1
    6a50:	4798      	blx	r3
    6a52:	6028      	str	r0, [r5, #0]
    6a54:	b120      	cbz	r0, 6a60 <sys_sem_new+0x24>
    6a56:	2300      	movs	r3, #0
    6a58:	4e0d      	ldr	r6, [pc, #52]	; (6a90 <sys_sem_new+0x54>)
    6a5a:	461a      	mov	r2, r3
    6a5c:	4619      	mov	r1, r3
    6a5e:	47b0      	blx	r6
		if (*sem != SYS_SEM_NULL) {
    6a60:	6828      	ldr	r0, [r5, #0]
    6a62:	b148      	cbz	r0, 6a78 <sys_sem_new+0x3c>
				lwip_stats.sys.sem.max = lwip_stats.sys.sem.used;
			}

  #endif /* SYS_STATS */

			if (0 == count) { /* Means we want the sem to be
    6a64:	b95c      	cbnz	r4, 6a7e <sys_sem_new+0x42>
			                     unavailable at init state. */
				xSemaphoreTake( *sem, 1);
    6a66:	4d0b      	ldr	r5, [pc, #44]	; (6a94 <sys_sem_new+0x58>)
    6a68:	4623      	mov	r3, r4
    6a6a:	2201      	movs	r2, #1
    6a6c:	4621      	mov	r1, r4
    6a6e:	47a8      	blx	r5
			}

			err_sem = ERR_OK;
		}

		portEXIT_CRITICAL();
    6a70:	4b09      	ldr	r3, [pc, #36]	; (6a98 <sys_sem_new+0x5c>)
    6a72:	4798      	blx	r3
	}

	return err_sem;
}
    6a74:	4620      	mov	r0, r4
    6a76:	bd70      	pop	{r4, r5, r6, pc}
	err_t err_sem = ERR_MEM;
    6a78:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
    6a7c:	e7f8      	b.n	6a70 <sys_sem_new+0x34>
			err_sem = ERR_OK;
    6a7e:	2400      	movs	r4, #0
    6a80:	e7f6      	b.n	6a70 <sys_sem_new+0x34>
	err_t err_sem = ERR_MEM;
    6a82:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
    6a86:	e7f5      	b.n	6a74 <sys_sem_new+0x38>
    6a88:	00008ef5 	.word	0x00008ef5
    6a8c:	0000054d 	.word	0x0000054d
    6a90:	00000611 	.word	0x00000611
    6a94:	00000951 	.word	0x00000951
    6a98:	00008f35 	.word	0x00008f35

00006a9c <sys_sem_free>:
 * \param sem Pointer to the semaphore.
 */
void sys_sem_free(sys_sem_t *sem)
{
	/* Sanity check */
	if (sem != NULL) {
    6a9c:	b118      	cbz	r0, 6aa6 <sys_sem_free+0xa>
		if (SYS_SEM_NULL != *sem) {
    6a9e:	6800      	ldr	r0, [r0, #0]
    6aa0:	b108      	cbz	r0, 6aa6 <sys_sem_free+0xa>
  #if SYS_STATS 
			lwip_stats.sys.sem.used--;
  #endif /* SYS_STATS */
			vQueueDelete( *sem );
    6aa2:	4b01      	ldr	r3, [pc, #4]	; (6aa8 <sys_sem_free+0xc>)
    6aa4:	4718      	bx	r3
		}
	}
}
    6aa6:	4770      	bx	lr
    6aa8:	00000ae5 	.word	0x00000ae5

00006aac <sys_sem_signal>:
 * \brief Signals (or releases) a semaphore.
 *
 * \param sem Pointer to the semaphore.
 */
void sys_sem_signal(sys_sem_t *sem)
{
    6aac:	b410      	push	{r4}
	/* Sanity check */
	if (sem != NULL) {
    6aae:	b140      	cbz	r0, 6ac2 <sys_sem_signal+0x16>
		xSemaphoreGive( *sem );
    6ab0:	4c05      	ldr	r4, [pc, #20]	; (6ac8 <sys_sem_signal+0x1c>)
    6ab2:	6800      	ldr	r0, [r0, #0]
    6ab4:	2300      	movs	r3, #0
    6ab6:	46a4      	mov	ip, r4
    6ab8:	461a      	mov	r2, r3
	}
}
    6aba:	f85d 4b04 	ldr.w	r4, [sp], #4
		xSemaphoreGive( *sem );
    6abe:	4619      	mov	r1, r3
    6ac0:	4760      	bx	ip
}
    6ac2:	f85d 4b04 	ldr.w	r4, [sp], #4
    6ac6:	4770      	bx	lr
    6ac8:	00000611 	.word	0x00000611

00006acc <sys_arch_sem_wait>:
 *
 * \return SYS_ARCH_TIMEOUT if times out, ERR_MEM for semaphore erro otherwise
 * return the milliseconds expired while waiting for the semaphore.
 */
u32_t sys_arch_sem_wait(sys_sem_t *sem, u32_t timeout)
{
    6acc:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    6ad0:	460e      	mov	r6, r1
	portTickType TickStop;
	/* Express the timeout in OS tick. */
	portTickType TickElapsed = (portTickType)(timeout / portTICK_RATE_MS);

	/* Sanity check */
	if (sem != NULL) {
    6ad2:	4605      	mov	r5, r0
    6ad4:	b918      	cbnz	r0, 6ade <sys_arch_sem_wait+0x12>
			TickElapsed = portMAX_DELAY - TickStart + TickStop;
		}

		return(TickElapsed * portTICK_RATE_MS);
	} else {
		return ERR_MEM;
    6ad6:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
	}
}
    6ada:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		if (0 == TickElapsed) {
    6ade:	4f0f      	ldr	r7, [pc, #60]	; (6b1c <sys_arch_sem_wait+0x50>)
    6ae0:	f8df 803c 	ldr.w	r8, [pc, #60]	; 6b20 <sys_arch_sem_wait+0x54>
    6ae4:	b981      	cbnz	r1, 6b08 <sys_arch_sem_wait+0x3c>
			TickStart = xTaskGetTickCount();
    6ae6:	47b8      	blx	r7
    6ae8:	4604      	mov	r4, r0
			while (pdFALSE == xSemaphoreTake( *sem,	SYS_ARCH_BLOCKING_TICKTIMEOUT )) {
    6aea:	2300      	movs	r3, #0
    6aec:	6828      	ldr	r0, [r5, #0]
    6aee:	f242 7210 	movw	r2, #10000	; 0x2710
    6af2:	4619      	mov	r1, r3
    6af4:	47c0      	blx	r8
    6af6:	2800      	cmp	r0, #0
    6af8:	d0f7      	beq.n	6aea <sys_arch_sem_wait+0x1e>
		TickStop = xTaskGetTickCount();
    6afa:	47b8      	blx	r7
		if (TickStop >= TickStart) {
    6afc:	4284      	cmp	r4, r0
			TickElapsed = portMAX_DELAY - TickStart + TickStop;
    6afe:	bf88      	it	hi
    6b00:	f100 30ff 	addhi.w	r0, r0, #4294967295	; 0xffffffff
    6b04:	1b00      	subs	r0, r0, r4
    6b06:	e7e8      	b.n	6ada <sys_arch_sem_wait+0xe>
			TickStart = xTaskGetTickCount();
    6b08:	47b8      	blx	r7
			if (pdFALSE == xSemaphoreTake( *sem, TickElapsed )) {
    6b0a:	2300      	movs	r3, #0
			TickStart = xTaskGetTickCount();
    6b0c:	4604      	mov	r4, r0
			if (pdFALSE == xSemaphoreTake( *sem, TickElapsed )) {
    6b0e:	4632      	mov	r2, r6
    6b10:	6828      	ldr	r0, [r5, #0]
    6b12:	4619      	mov	r1, r3
    6b14:	47c0      	blx	r8
    6b16:	2800      	cmp	r0, #0
    6b18:	d1ef      	bne.n	6afa <sys_arch_sem_wait+0x2e>
    6b1a:	e7dc      	b.n	6ad6 <sys_arch_sem_wait+0xa>
    6b1c:	00007f39 	.word	0x00007f39
    6b20:	00000951 	.word	0x00000951

00006b24 <sys_sem_valid>:
 * \return Semaphore number on valid, 0 for invalid.
 */
int sys_sem_valid(sys_sem_t *sem)
{
	return ((int)(*sem));
}
    6b24:	6800      	ldr	r0, [r0, #0]
    6b26:	4770      	bx	lr

00006b28 <sys_sem_set_invalid>:
 *
 * \param sem Pointer to the semaphore.
 */
void sys_sem_set_invalid(sys_sem_t *sem)
{
	*sem = NULL;
    6b28:	2300      	movs	r3, #0
    6b2a:	6003      	str	r3, [r0, #0]
}
    6b2c:	4770      	bx	lr
	...

00006b30 <sys_mbox_new>:
 * \param size Maximum "size" elements.
 *
 * \return ERR_OK if successfull or ERR_MEM on error.
 */
err_t sys_mbox_new(sys_mbox_t *mBoxNew, int size )
{
    6b30:	b510      	push	{r4, lr}
    6b32:	4604      	mov	r4, r0
    6b34:	4608      	mov	r0, r1
	err_t err_mbox = ERR_MEM;

	/* Sanity check */
	if (mBoxNew != NULL) {
    6b36:	b134      	cbz	r4, 6b46 <sys_mbox_new+0x16>
		*mBoxNew = xQueueCreate( size, sizeof(void *));
    6b38:	4b04      	ldr	r3, [pc, #16]	; (6b4c <sys_mbox_new+0x1c>)
    6b3a:	2200      	movs	r2, #0
    6b3c:	2104      	movs	r1, #4
    6b3e:	4798      	blx	r3
    6b40:	6020      	str	r0, [r4, #0]
				lwip_stats.sys.mbox.max	= lwip_stats.sys.mbox.used;
			}
		}

  #endif /* SYS_STATS */
		err_mbox = ERR_OK;
    6b42:	2000      	movs	r0, #0
	}

	return(err_mbox);
}
    6b44:	bd10      	pop	{r4, pc}
	err_t err_mbox = ERR_MEM;
    6b46:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    6b4a:	e7fb      	b.n	6b44 <sys_mbox_new+0x14>
    6b4c:	0000054d 	.word	0x0000054d

00006b50 <sys_mbox_free>:
    6b50:	4b00      	ldr	r3, [pc, #0]	; (6b54 <sys_mbox_free+0x4>)
    6b52:	4718      	bx	r3
    6b54:	00006a9d 	.word	0x00006a9d

00006b58 <sys_mbox_post>:
 *
 * \param mbox Pointer to the mailbox.
 * \param msg Pointer to the message to be post.
 */
void sys_mbox_post(sys_mbox_t *mbox, void *msg)
{
    6b58:	b537      	push	{r0, r1, r2, r4, r5, lr}
	/* Sanit check */
	if (mbox != NULL) {
    6b5a:	4604      	mov	r4, r0
{
    6b5c:	9101      	str	r1, [sp, #4]
	if (mbox != NULL) {
    6b5e:	b140      	cbz	r0, 6b72 <sys_mbox_post+0x1a>
		while (pdTRUE != xQueueSend( *mbox, &msg, SYS_ARCH_BLOCKING_TICKTIMEOUT )) {
    6b60:	4d05      	ldr	r5, [pc, #20]	; (6b78 <sys_mbox_post+0x20>)
    6b62:	6820      	ldr	r0, [r4, #0]
    6b64:	2300      	movs	r3, #0
    6b66:	f242 7210 	movw	r2, #10000	; 0x2710
    6b6a:	a901      	add	r1, sp, #4
    6b6c:	47a8      	blx	r5
    6b6e:	2801      	cmp	r0, #1
    6b70:	d1f7      	bne.n	6b62 <sys_mbox_post+0xa>
		}
	}
}
    6b72:	b003      	add	sp, #12
    6b74:	bd30      	pop	{r4, r5, pc}
    6b76:	bf00      	nop
    6b78:	00000611 	.word	0x00000611

00006b7c <sys_mbox_trypost>:
 * \param msg Pointer to the message to be post.
 *
 * \return ERR_MEM if the mailbox is full otherwise ERR_OK if the "msg" is posted.
 */
err_t sys_mbox_trypost(sys_mbox_t *mbox, void *msg)
{
    6b7c:	b51f      	push	{r0, r1, r2, r3, r4, lr}
    6b7e:	9101      	str	r1, [sp, #4]
	err_t err_mbox = ERR_MEM;

	/* Sanity check */
	if (mbox != NULL) {
    6b80:	b330      	cbz	r0, 6bd0 <sys_mbox_trypost+0x54>
		if (SCB->ICSR & SCB_ICSR_VECTACTIVE_Msk) {
    6b82:	4b15      	ldr	r3, [pc, #84]	; (6bd8 <sys_mbox_trypost+0x5c>)
			portBASE_TYPE task_woken = 0;
			if (errQUEUE_FULL != xQueueSendFromISR( *mbox, &msg, &task_woken )) {
    6b84:	6800      	ldr	r0, [r0, #0]
		if (SCB->ICSR & SCB_ICSR_VECTACTIVE_Msk) {
    6b86:	685b      	ldr	r3, [r3, #4]
    6b88:	f3c3 0308 	ubfx	r3, r3, #0, #9
    6b8c:	b1bb      	cbz	r3, 6bbe <sys_mbox_trypost+0x42>
			portBASE_TYPE task_woken = 0;
    6b8e:	2300      	movs	r3, #0
			if (errQUEUE_FULL != xQueueSendFromISR( *mbox, &msg, &task_woken )) {
    6b90:	4c12      	ldr	r4, [pc, #72]	; (6bdc <sys_mbox_trypost+0x60>)
			portBASE_TYPE task_woken = 0;
    6b92:	9303      	str	r3, [sp, #12]
			if (errQUEUE_FULL != xQueueSendFromISR( *mbox, &msg, &task_woken )) {
    6b94:	aa03      	add	r2, sp, #12
    6b96:	a901      	add	r1, sp, #4
    6b98:	47a0      	blx	r4
				err_mbox = ERR_OK;
			}
			portEND_SWITCHING_ISR(task_woken);
    6b9a:	9b03      	ldr	r3, [sp, #12]
			if (errQUEUE_FULL != xQueueSendFromISR( *mbox, &msg, &task_woken )) {
    6b9c:	fab0 f080 	clz	r0, r0
    6ba0:	0940      	lsrs	r0, r0, #5
    6ba2:	4240      	negs	r0, r0
			portEND_SWITCHING_ISR(task_woken);
    6ba4:	b14b      	cbz	r3, 6bba <sys_mbox_trypost+0x3e>
    6ba6:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
    6baa:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
    6bae:	f8c3 2d04 	str.w	r2, [r3, #3332]	; 0xd04
    6bb2:	f3bf 8f4f 	dsb	sy
    6bb6:	f3bf 8f6f 	isb	sy
				err_mbox = ERR_OK;
			}
		}
	}
	return (err_mbox);
}
    6bba:	b004      	add	sp, #16
    6bbc:	bd10      	pop	{r4, pc}
			if (errQUEUE_FULL != xQueueSend( *mbox, &msg, 0 )) {
    6bbe:	4c08      	ldr	r4, [pc, #32]	; (6be0 <sys_mbox_trypost+0x64>)
    6bc0:	461a      	mov	r2, r3
    6bc2:	a901      	add	r1, sp, #4
    6bc4:	47a0      	blx	r4
    6bc6:	fab0 f080 	clz	r0, r0
    6bca:	0940      	lsrs	r0, r0, #5
    6bcc:	4240      	negs	r0, r0
    6bce:	e7f4      	b.n	6bba <sys_mbox_trypost+0x3e>
	err_t err_mbox = ERR_MEM;
    6bd0:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    6bd4:	e7f1      	b.n	6bba <sys_mbox_trypost+0x3e>
    6bd6:	bf00      	nop
    6bd8:	e000ed00 	.word	0xe000ed00
    6bdc:	000007b1 	.word	0x000007b1
    6be0:	00000611 	.word	0x00000611

00006be4 <sys_arch_mbox_fetch>:
 *
 * \return Number of milliseconds spent waiting or SYS_ARCH_TIMEOUT if there was
 * a timeout. Or ERR_MEM if invalid pointer to message box.
 */
u32_t sys_arch_mbox_fetch(sys_mbox_t *mbox, void **msg, u32_t timeout)
{
    6be4:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
    6be8:	460d      	mov	r5, r1
    6bea:	4617      	mov	r7, r2
	void *tempoptr;
	/* Express the timeout in OS tick. */
	portTickType TickElapsed = (portTickType)(timeout / portTICK_RATE_MS);

	/* Sanity check */
	if (mbox != NULL) {
    6bec:	4606      	mov	r6, r0
    6bee:	b318      	cbz	r0, 6c38 <sys_arch_mbox_fetch+0x54>
		if (timeout && !TickElapsed) {
			TickElapsed = 1; /* Wait at least one tick */
		}

		if (msg == NULL) {
    6bf0:	b901      	cbnz	r1, 6bf4 <sys_arch_mbox_fetch+0x10>
			msg = &tempoptr;
    6bf2:	ad01      	add	r5, sp, #4
		}

		/* NOTE: INCLUDE_xTaskGetSchedulerState must be set to 1 in
		 * FreeRTOSConfig.h for xTaskGetTickCount() to be available */
		if (0 == TickElapsed) {
    6bf4:	f8df 8048 	ldr.w	r8, [pc, #72]	; 6c40 <sys_arch_mbox_fetch+0x5c>
    6bf8:	f8df 9048 	ldr.w	r9, [pc, #72]	; 6c44 <sys_arch_mbox_fetch+0x60>
    6bfc:	b997      	cbnz	r7, 6c24 <sys_arch_mbox_fetch+0x40>
			TickStart = xTaskGetTickCount();
    6bfe:	47c0      	blx	r8
    6c00:	4604      	mov	r4, r0
			/* If "timeout" is 0, the thread should be blocked until
			 * a message arrives */
			while (pdFALSE == xQueueReceive( *mbox, &(*msg),
    6c02:	6830      	ldr	r0, [r6, #0]
    6c04:	2300      	movs	r3, #0
    6c06:	f242 7210 	movw	r2, #10000	; 0x2710
    6c0a:	4629      	mov	r1, r5
    6c0c:	47c8      	blx	r9
    6c0e:	2800      	cmp	r0, #0
    6c10:	d0f7      	beq.n	6c02 <sys_arch_mbox_fetch+0x1e>
			}
		}

		/* If the function gets a msg, it should return the number of ms
		 * spent waiting. */
		TickStop = xTaskGetTickCount();
    6c12:	47c0      	blx	r8
		/* Take care of wrap-around. */
		if (TickStop >= TickStart) {
    6c14:	4284      	cmp	r4, r0
			TickElapsed = TickStop - TickStart;
		} else {
			TickElapsed = portMAX_DELAY - TickStart + TickStop;
    6c16:	bf88      	it	hi
    6c18:	f100 30ff 	addhi.w	r0, r0, #4294967295	; 0xffffffff
    6c1c:	1b00      	subs	r0, r0, r4

		return(TickElapsed * portTICK_RATE_MS);
	} else {
		return ERR_MEM;
	}
}
    6c1e:	b003      	add	sp, #12
    6c20:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
			TickStart = xTaskGetTickCount();
    6c24:	47c0      	blx	r8
			if (pdFALSE == xQueueReceive( *mbox, &(*msg), TickElapsed )) {
    6c26:	2300      	movs	r3, #0
			TickStart = xTaskGetTickCount();
    6c28:	4604      	mov	r4, r0
			if (pdFALSE == xQueueReceive( *mbox, &(*msg), TickElapsed )) {
    6c2a:	463a      	mov	r2, r7
    6c2c:	6830      	ldr	r0, [r6, #0]
    6c2e:	4629      	mov	r1, r5
    6c30:	47c8      	blx	r9
    6c32:	2800      	cmp	r0, #0
    6c34:	d1ed      	bne.n	6c12 <sys_arch_mbox_fetch+0x2e>
				*msg = NULL;
    6c36:	6028      	str	r0, [r5, #0]
		return ERR_MEM;
    6c38:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    6c3c:	e7ef      	b.n	6c1e <sys_arch_mbox_fetch+0x3a>
    6c3e:	bf00      	nop
    6c40:	00007f39 	.word	0x00007f39
    6c44:	00000951 	.word	0x00000951

00006c48 <sys_arch_mbox_tryfetch>:
 *
 * \return Number of milliseconds spent waiting or SYS_ARCH_TIMEOUT if there was
 * a timeout. Or ERR_MEM if invalid pointer to message box.
 */
u32_t sys_arch_mbox_tryfetch(sys_mbox_t *mbox, void **msg)
{
    6c48:	b513      	push	{r0, r1, r4, lr}
	void *tempoptr;

	/* Sanity check */
	if (mbox != NULL) {
    6c4a:	b160      	cbz	r0, 6c66 <sys_arch_mbox_tryfetch+0x1e>
		if (msg == NULL) {
    6c4c:	b901      	cbnz	r1, 6c50 <sys_arch_mbox_tryfetch+0x8>
			msg = &tempoptr;
    6c4e:	a901      	add	r1, sp, #4
		}

		if (pdFALSE == xQueueReceive( *mbox, &(*msg), 0 )) {
    6c50:	2300      	movs	r3, #0
    6c52:	6800      	ldr	r0, [r0, #0]
    6c54:	4c05      	ldr	r4, [pc, #20]	; (6c6c <sys_arch_mbox_tryfetch+0x24>)
    6c56:	461a      	mov	r2, r3
    6c58:	47a0      	blx	r4
    6c5a:	fab0 f080 	clz	r0, r0
    6c5e:	0940      	lsrs	r0, r0, #5
    6c60:	4240      	negs	r0, r0
		/* On success 0 is returned. */
		return(0);
	} else {
		return(SYS_MBOX_EMPTY);
	}
}
    6c62:	b002      	add	sp, #8
    6c64:	bd10      	pop	{r4, pc}
		return(SYS_MBOX_EMPTY);
    6c66:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    6c6a:	e7fa      	b.n	6c62 <sys_arch_mbox_tryfetch+0x1a>
    6c6c:	00000951 	.word	0x00000951

00006c70 <sys_mbox_valid>:
    6c70:	6800      	ldr	r0, [r0, #0]
    6c72:	4770      	bx	lr

00006c74 <sys_mbox_set_invalid>:
    6c74:	2300      	movs	r3, #0
    6c76:	6003      	str	r3, [r0, #0]
    6c78:	4770      	bx	lr
	...

00006c7c <sys_thread_new>:
 *
 * \return The id of the new thread.
 */
sys_thread_t sys_thread_new(const char *name, lwip_thread_fn thread, void *arg,
		int stacksize, int prio)
{
    6c7c:	b530      	push	{r4, r5, lr}
    6c7e:	b087      	sub	sp, #28
    6c80:	4605      	mov	r5, r0
    6c82:	4608      	mov	r0, r1
    6c84:	4619      	mov	r1, r3
	sys_thread_t newthread;
	portBASE_TYPE result;
	SYS_ARCH_DECL_PROTECT(protectionLevel);

	result = xTaskCreate( thread, (signed portCHAR *)name, stacksize, arg,
    6c86:	ab05      	add	r3, sp, #20
    6c88:	2400      	movs	r4, #0
    6c8a:	9301      	str	r3, [sp, #4]
    6c8c:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    6c8e:	9300      	str	r3, [sp, #0]
    6c90:	e9cd 4402 	strd	r4, r4, [sp, #8]
    6c94:	4613      	mov	r3, r2
    6c96:	b28a      	uxth	r2, r1
    6c98:	4629      	mov	r1, r5
    6c9a:	4d06      	ldr	r5, [pc, #24]	; (6cb4 <sys_thread_new+0x38>)
    6c9c:	47a8      	blx	r5
			prio, &newthread );

	/* Need to protect this -- preemption here could be a problem! */
	SYS_ARCH_PROTECT(protectionLevel);
	if (pdPASS == result) {
    6c9e:	2801      	cmp	r0, #1
		Threads_TimeoutsList[NbActiveThreads++].pid = newthread;
    6ca0:	bf0a      	itet	eq
    6ca2:	4a05      	ldreq	r2, [pc, #20]	; (6cb8 <sys_thread_new+0x3c>)
	} else {
		newthread = NULL;
    6ca4:	9405      	strne	r4, [sp, #20]
		Threads_TimeoutsList[NbActiveThreads++].pid = newthread;
    6ca6:	8813      	ldrheq	r3, [r2, #0]
	}

	SYS_ARCH_UNPROTECT(protectionLevel);

	return(newthread);
}
    6ca8:	9805      	ldr	r0, [sp, #20]
		Threads_TimeoutsList[NbActiveThreads++].pid = newthread;
    6caa:	bf04      	itt	eq
    6cac:	3301      	addeq	r3, #1
    6cae:	8013      	strheq	r3, [r2, #0]
}
    6cb0:	b007      	add	sp, #28
    6cb2:	bd30      	pop	{r4, r5, pc}
    6cb4:	00007ce5 	.word	0x00007ce5
    6cb8:	20014946 	.word	0x20014946

00006cbc <hri_sercomusart_wait_for_sync>:
	return ((Sercom *)hw)->SPI.SYNCBUSY.reg & reg;
}

static inline void hri_sercomusart_wait_for_sync(const void *const hw, hri_sercomusart_syncbusy_reg_t reg)
{
	while (((Sercom *)hw)->USART.SYNCBUSY.reg & reg) {
    6cbc:	69c3      	ldr	r3, [r0, #28]
    6cbe:	420b      	tst	r3, r1
    6cc0:	d1fc      	bne.n	6cbc <hri_sercomusart_wait_for_sync>
	};
}
    6cc2:	4770      	bx	lr

00006cc4 <hri_sercomusart_clear_CTRLA_ENABLE_bit>:
}

static inline void hri_sercomusart_clear_CTRLA_ENABLE_bit(const void *const hw)
{
	SERCOM_CRITICAL_SECTION_ENTER();
	((Sercom *)hw)->USART.CTRLA.reg &= ~SERCOM_USART_CTRLA_ENABLE;
    6cc4:	6802      	ldr	r2, [r0, #0]
	hri_sercomusart_wait_for_sync(hw, SERCOM_USART_SYNCBUSY_SWRST | SERCOM_USART_SYNCBUSY_ENABLE);
    6cc6:	4b03      	ldr	r3, [pc, #12]	; (6cd4 <hri_sercomusart_clear_CTRLA_ENABLE_bit+0x10>)
	((Sercom *)hw)->USART.CTRLA.reg &= ~SERCOM_USART_CTRLA_ENABLE;
    6cc8:	f022 0202 	bic.w	r2, r2, #2
    6ccc:	6002      	str	r2, [r0, #0]
	hri_sercomusart_wait_for_sync(hw, SERCOM_USART_SYNCBUSY_SWRST | SERCOM_USART_SYNCBUSY_ENABLE);
    6cce:	2103      	movs	r1, #3
    6cd0:	4718      	bx	r3
    6cd2:	bf00      	nop
    6cd4:	00006cbd 	.word	0x00006cbd

00006cd8 <_sercom_get_hardware_index>:

/**
 * \brief Retrieve ordinal number of the given sercom hardware instance
 */
static uint8_t _sercom_get_hardware_index(const void *const hw)
{
    6cd8:	b570      	push	{r4, r5, r6, lr}
	Sercom *const sercom_modules[] = SERCOM_INSTS;
    6cda:	4d0c      	ldr	r5, [pc, #48]	; (6d0c <_sercom_get_hardware_index+0x34>)
{
    6cdc:	4606      	mov	r6, r0
	Sercom *const sercom_modules[] = SERCOM_INSTS;
    6cde:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
{
    6ce0:	b088      	sub	sp, #32
	Sercom *const sercom_modules[] = SERCOM_INSTS;
    6ce2:	466c      	mov	r4, sp
    6ce4:	c40f      	stmia	r4!, {r0, r1, r2, r3}
    6ce6:	e895 000f 	ldmia.w	r5, {r0, r1, r2, r3}
    6cea:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
	/* Find index for SERCOM instance. */
	for (uint32_t i = 0; i < SERCOM_INST_NUM; i++) {
    6cee:	466a      	mov	r2, sp
    6cf0:	2300      	movs	r3, #0
		if ((uint32_t)hw == (uint32_t)sercom_modules[i]) {
    6cf2:	f852 1b04 	ldr.w	r1, [r2], #4
    6cf6:	42b1      	cmp	r1, r6
    6cf8:	d102      	bne.n	6d00 <_sercom_get_hardware_index+0x28>
			return i;
    6cfa:	b2d8      	uxtb	r0, r3
		}
	}
	return 0;
}
    6cfc:	b008      	add	sp, #32
    6cfe:	bd70      	pop	{r4, r5, r6, pc}
	for (uint32_t i = 0; i < SERCOM_INST_NUM; i++) {
    6d00:	3301      	adds	r3, #1
    6d02:	2b08      	cmp	r3, #8
    6d04:	d1f5      	bne.n	6cf2 <_sercom_get_hardware_index+0x1a>
	return 0;
    6d06:	2000      	movs	r0, #0
    6d08:	e7f8      	b.n	6cfc <_sercom_get_hardware_index+0x24>
    6d0a:	bf00      	nop
    6d0c:	0000a948 	.word	0x0000a948

00006d10 <_usart_init>:
 * \param[in] hw The pointer to hardware instance
 *
 * \return The status of initialization
 */
static int32_t _usart_init(void *const hw)
{
    6d10:	b538      	push	{r3, r4, r5, lr}
	uint8_t sercom_offset = _sercom_get_hardware_index(hw);
    6d12:	4b1b      	ldr	r3, [pc, #108]	; (6d80 <_usart_init+0x70>)
{
    6d14:	4604      	mov	r4, r0
	uint8_t sercom_offset = _sercom_get_hardware_index(hw);
    6d16:	4798      	blx	r3
		if (_usarts[i].number == sercom_offset) {
    6d18:	2802      	cmp	r0, #2
    6d1a:	d005      	beq.n	6d28 <_usart_init+0x18>
	ASSERT(false);
    6d1c:	4919      	ldr	r1, [pc, #100]	; (6d84 <_usart_init+0x74>)
    6d1e:	4b1a      	ldr	r3, [pc, #104]	; (6d88 <_usart_init+0x78>)
    6d20:	f240 2247 	movw	r2, #583	; 0x247
    6d24:	2000      	movs	r0, #0
    6d26:	4798      	blx	r3
	return ((Sercom *)hw)->USART.SYNCBUSY.reg & reg;
    6d28:	69e3      	ldr	r3, [r4, #28]
    6d2a:	4d18      	ldr	r5, [pc, #96]	; (6d8c <_usart_init+0x7c>)
	uint8_t i = _get_sercom_index(hw);

	if (!hri_sercomusart_is_syncing(hw, SERCOM_USART_SYNCBUSY_SWRST)) {
    6d2c:	f013 0f01 	tst.w	r3, #1
    6d30:	d10e      	bne.n	6d50 <_usart_init+0x40>

static inline hri_sercomusart_ctrla_reg_t hri_sercomusart_get_CTRLA_reg(const void *const           hw,
                                                                        hri_sercomusart_ctrla_reg_t mask)
{
	uint32_t tmp;
	hri_sercomusart_wait_for_sync(hw, SERCOM_USART_SYNCBUSY_SWRST | SERCOM_USART_SYNCBUSY_ENABLE);
    6d32:	2103      	movs	r1, #3
    6d34:	4620      	mov	r0, r4
    6d36:	47a8      	blx	r5
	tmp = ((Sercom *)hw)->USART.CTRLA.reg;
    6d38:	6823      	ldr	r3, [r4, #0]
		uint32_t mode = _usarts[i].ctrl_a & SERCOM_USART_CTRLA_MODE_Msk;
		if (hri_sercomusart_get_CTRLA_reg(hw, SERCOM_USART_CTRLA_ENABLE)) {
    6d3a:	079b      	lsls	r3, r3, #30
    6d3c:	d503      	bpl.n	6d46 <_usart_init+0x36>
			hri_sercomusart_clear_CTRLA_ENABLE_bit(hw);
    6d3e:	4b14      	ldr	r3, [pc, #80]	; (6d90 <_usart_init+0x80>)
    6d40:	4798      	blx	r3
			hri_sercomusart_wait_for_sync(hw, SERCOM_USART_SYNCBUSY_ENABLE);
    6d42:	2102      	movs	r1, #2
    6d44:	47a8      	blx	r5
}

static inline void hri_sercomusart_write_CTRLA_reg(const void *const hw, hri_sercomusart_ctrla_reg_t data)
{
	SERCOM_CRITICAL_SECTION_ENTER();
	((Sercom *)hw)->USART.CTRLA.reg = data;
    6d46:	2305      	movs	r3, #5
    6d48:	6023      	str	r3, [r4, #0]
	hri_sercomusart_wait_for_sync(hw, SERCOM_USART_SYNCBUSY_SWRST | SERCOM_USART_SYNCBUSY_ENABLE);
    6d4a:	2103      	movs	r1, #3
    6d4c:	4620      	mov	r0, r4
    6d4e:	47a8      	blx	r5
		}
		hri_sercomusart_write_CTRLA_reg(hw, SERCOM_USART_CTRLA_SWRST | mode);
	}
	hri_sercomusart_wait_for_sync(hw, SERCOM_USART_SYNCBUSY_SWRST);
    6d50:	4620      	mov	r0, r4
    6d52:	2101      	movs	r1, #1
    6d54:	47a8      	blx	r5
	((Sercom *)hw)->USART.CTRLA.reg = data;
    6d56:	4b0f      	ldr	r3, [pc, #60]	; (6d94 <_usart_init+0x84>)
    6d58:	6023      	str	r3, [r4, #0]
	hri_sercomusart_wait_for_sync(hw, SERCOM_USART_SYNCBUSY_SWRST | SERCOM_USART_SYNCBUSY_ENABLE);
    6d5a:	2103      	movs	r1, #3
    6d5c:	47a8      	blx	r5
}

static inline void hri_sercomusart_write_CTRLB_reg(const void *const hw, hri_sercomusart_ctrlb_reg_t data)
{
	SERCOM_CRITICAL_SECTION_ENTER();
	((Sercom *)hw)->USART.CTRLB.reg = data;
    6d5e:	f44f 3340 	mov.w	r3, #196608	; 0x30000
    6d62:	6063      	str	r3, [r4, #4]
	hri_sercomusart_wait_for_sync(hw, SERCOM_USART_SYNCBUSY_MASK);
    6d64:	211f      	movs	r1, #31
    6d66:	47a8      	blx	r5
}

static inline void hri_sercomusart_write_CTRLC_reg(const void *const hw, hri_sercomusart_ctrlc_reg_t data)
{
	SERCOM_CRITICAL_SECTION_ENTER();
	((Sercom *)hw)->USART.CTRLC.reg = data;
    6d68:	4b0b      	ldr	r3, [pc, #44]	; (6d98 <_usart_init+0x88>)
    6d6a:	60a3      	str	r3, [r4, #8]
}

static inline void hri_sercomusart_write_BAUD_reg(const void *const hw, hri_sercomusart_baud_reg_t data)
{
	SERCOM_CRITICAL_SECTION_ENTER();
	((Sercom *)hw)->USART.BAUD.reg = data;
    6d6c:	f64f 43b9 	movw	r3, #64697	; 0xfcb9
    6d70:	81a3      	strh	r3, [r4, #12]
}

static inline void hri_sercomusart_write_RXPL_reg(const void *const hw, hri_sercomusart_rxpl_reg_t data)
{
	SERCOM_CRITICAL_SECTION_ENTER();
	((Sercom *)hw)->USART.RXPL.reg = data;
    6d72:	2300      	movs	r3, #0
    6d74:	73a3      	strb	r3, [r4, #14]

	hri_sercomusart_write_RXPL_reg(hw, _usarts[i].rxpl);
	hri_sercomusart_write_DBGCTRL_reg(hw, _usarts[i].debug_ctrl);

	return ERR_NONE;
}
    6d76:	4618      	mov	r0, r3
}

static inline void hri_sercomusart_write_DBGCTRL_reg(const void *const hw, hri_sercomusart_dbgctrl_reg_t data)
{
	SERCOM_CRITICAL_SECTION_ENTER();
	((Sercom *)hw)->USART.DBGCTRL.reg = data;
    6d78:	f884 3030 	strb.w	r3, [r4, #48]	; 0x30
    6d7c:	bd38      	pop	{r3, r4, r5, pc}
    6d7e:	bf00      	nop
    6d80:	00006cd9 	.word	0x00006cd9
    6d84:	0000a92c 	.word	0x0000a92c
    6d88:	00007aa9 	.word	0x00007aa9
    6d8c:	00006cbd 	.word	0x00006cbd
    6d90:	00006cc5 	.word	0x00006cc5
    6d94:	40100004 	.word	0x40100004
    6d98:	00700002 	.word	0x00700002

00006d9c <_usart_sync_init>:
{
    6d9c:	b570      	push	{r4, r5, r6, lr}
	ASSERT(device);
    6d9e:	4605      	mov	r5, r0
    6da0:	3800      	subs	r0, #0
{
    6da2:	460c      	mov	r4, r1
	ASSERT(device);
    6da4:	4b05      	ldr	r3, [pc, #20]	; (6dbc <_usart_sync_init+0x20>)
    6da6:	4906      	ldr	r1, [pc, #24]	; (6dc0 <_usart_sync_init+0x24>)
    6da8:	bf18      	it	ne
    6daa:	2001      	movne	r0, #1
    6dac:	22bb      	movs	r2, #187	; 0xbb
    6dae:	4798      	blx	r3
	device->hw = hw;
    6db0:	602c      	str	r4, [r5, #0]
	return _usart_init(hw);
    6db2:	4620      	mov	r0, r4
    6db4:	4b03      	ldr	r3, [pc, #12]	; (6dc4 <_usart_sync_init+0x28>)
}
    6db6:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	return _usart_init(hw);
    6dba:	4718      	bx	r3
    6dbc:	00007aa9 	.word	0x00007aa9
    6dc0:	0000a92c 	.word	0x0000a92c
    6dc4:	00006d11 	.word	0x00006d11

00006dc8 <_usart_sync_enable>:
	hri_sercomusart_set_CTRLA_ENABLE_bit(device->hw);
    6dc8:	6800      	ldr	r0, [r0, #0]
	((Sercom *)hw)->USART.CTRLA.reg |= SERCOM_USART_CTRLA_ENABLE;
    6dca:	6803      	ldr	r3, [r0, #0]
    6dcc:	f043 0302 	orr.w	r3, r3, #2
    6dd0:	6003      	str	r3, [r0, #0]
	hri_sercomusart_wait_for_sync(hw, SERCOM_USART_SYNCBUSY_SWRST | SERCOM_USART_SYNCBUSY_ENABLE);
    6dd2:	2103      	movs	r1, #3
    6dd4:	4b00      	ldr	r3, [pc, #0]	; (6dd8 <_usart_sync_enable+0x10>)
    6dd6:	4718      	bx	r3
    6dd8:	00006cbd 	.word	0x00006cbd

00006ddc <_usart_sync_write_byte>:
	hri_sercomusart_write_DATA_reg(device->hw, data);
    6ddc:	6803      	ldr	r3, [r0, #0]
	((Sercom *)hw)->USART.DATA.reg = data;
    6dde:	6299      	str	r1, [r3, #40]	; 0x28
}
    6de0:	4770      	bx	lr

00006de2 <_usart_sync_read_byte>:
	return hri_sercomusart_read_DATA_reg(device->hw);
    6de2:	6803      	ldr	r3, [r0, #0]
	return ((Sercom *)hw)->USART.DATA.reg;
    6de4:	6a98      	ldr	r0, [r3, #40]	; 0x28
}
    6de6:	b2c0      	uxtb	r0, r0
    6de8:	4770      	bx	lr

00006dea <_usart_sync_is_ready_to_send>:
	return hri_sercomusart_get_interrupt_DRE_bit(device->hw);
    6dea:	6803      	ldr	r3, [r0, #0]
	return (((Sercom *)hw)->USART.INTFLAG.reg & SERCOM_USART_INTFLAG_DRE) >> SERCOM_USART_INTFLAG_DRE_Pos;
    6dec:	7e18      	ldrb	r0, [r3, #24]
}
    6dee:	f000 0001 	and.w	r0, r0, #1
    6df2:	4770      	bx	lr

00006df4 <_usart_sync_is_transmit_done>:
	return hri_sercomusart_get_interrupt_TXC_bit(device->hw);
    6df4:	6803      	ldr	r3, [r0, #0]
	return (((Sercom *)hw)->USART.INTFLAG.reg & SERCOM_USART_INTFLAG_TXC) >> SERCOM_USART_INTFLAG_TXC_Pos;
    6df6:	7e18      	ldrb	r0, [r3, #24]
}
    6df8:	f3c0 0040 	ubfx	r0, r0, #1, #1
    6dfc:	4770      	bx	lr

00006dfe <_usart_sync_is_byte_received>:
	return hri_sercomusart_get_interrupt_RXC_bit(device->hw);
    6dfe:	6803      	ldr	r3, [r0, #0]
	return (((Sercom *)hw)->USART.INTFLAG.reg & SERCOM_USART_INTFLAG_RXC) >> SERCOM_USART_INTFLAG_RXC_Pos;
    6e00:	7e18      	ldrb	r0, [r3, #24]
}
    6e02:	f3c0 0080 	ubfx	r0, r0, #2, #1
    6e06:	4770      	bx	lr

00006e08 <led_task>:
	((Port *)hw)->Group[submodule_index].OUTTGL.reg = mask;
    6e08:	4e05      	ldr	r6, [pc, #20]	; (6e20 <led_task+0x18>)
static void led_task(void *p)
{
	(void)p;
	for (;;) {
		gpio_toggle_pin_level(LED_0);
		os_sleep(led_blink_rate);
    6e0a:	4d06      	ldr	r5, [pc, #24]	; (6e24 <led_task+0x1c>)
    6e0c:	4c06      	ldr	r4, [pc, #24]	; (6e28 <led_task+0x20>)
{
    6e0e:	b580      	push	{r7, lr}
    6e10:	f44f 2780 	mov.w	r7, #262144	; 0x40000
		os_sleep(led_blink_rate);
    6e14:	8828      	ldrh	r0, [r5, #0]
    6e16:	f8c6 711c 	str.w	r7, [r6, #284]	; 0x11c
    6e1a:	47a0      	blx	r4
	for (;;) {
    6e1c:	e7fa      	b.n	6e14 <led_task+0xc>
    6e1e:	bf00      	nop
    6e20:	41008000 	.word	0x41008000
    6e24:	20000010 	.word	0x20000010
    6e28:	00008125 	.word	0x00008125

00006e2c <gmac_task>:
/**
 * \brief Task for GMAC.
 * Waits for GMAC interrupt and begins processing of received packets
 */
void gmac_task(void *pvParameters)
{
    6e2c:	b570      	push	{r4, r5, r6, lr}
	gmac_device *ps_gmac_dev = pvParameters;

	while (1) {
		/* Wait for the counting RX notification semaphore. */
		xSemaphoreTake(ps_gmac_dev->rx_sem, portMAX_DELAY);
    6e2e:	4e06      	ldr	r6, [pc, #24]	; (6e48 <gmac_task+0x1c>)

		/* Process the incoming packet. */
		ethernetif_mac_input(ps_gmac_dev->netif);
    6e30:	4d06      	ldr	r5, [pc, #24]	; (6e4c <gmac_task+0x20>)
{
    6e32:	4604      	mov	r4, r0
		xSemaphoreTake(ps_gmac_dev->rx_sem, portMAX_DELAY);
    6e34:	2300      	movs	r3, #0
    6e36:	6860      	ldr	r0, [r4, #4]
    6e38:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
    6e3c:	4619      	mov	r1, r3
    6e3e:	47b0      	blx	r6
		ethernetif_mac_input(ps_gmac_dev->netif);
    6e40:	6820      	ldr	r0, [r4, #0]
    6e42:	47a8      	blx	r5
	while (1) {
    6e44:	e7f6      	b.n	6e34 <gmac_task+0x8>
    6e46:	bf00      	nop
    6e48:	00000951 	.word	0x00000951
    6e4c:	000064f5 	.word	0x000064f5

00006e50 <gmac_handler_cb>:
{
    6e50:	b507      	push	{r0, r1, r2, lr}
	portBASE_TYPE xGMACTaskWoken = pdFALSE;
    6e52:	2300      	movs	r3, #0
    6e54:	9301      	str	r3, [sp, #4]
	xSemaphoreGiveFromISR(gs_gmac_dev.rx_sem, &xGMACTaskWoken);
    6e56:	4b0a      	ldr	r3, [pc, #40]	; (6e80 <gmac_handler_cb+0x30>)
    6e58:	a901      	add	r1, sp, #4
    6e5a:	6858      	ldr	r0, [r3, #4]
    6e5c:	4b09      	ldr	r3, [pc, #36]	; (6e84 <gmac_handler_cb+0x34>)
    6e5e:	4798      	blx	r3
	portEND_SWITCHING_ISR(xGMACTaskWoken);
    6e60:	9b01      	ldr	r3, [sp, #4]
    6e62:	b14b      	cbz	r3, 6e78 <gmac_handler_cb+0x28>
    6e64:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
    6e68:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
    6e6c:	f8c3 2d04 	str.w	r2, [r3, #3332]	; 0xd04
    6e70:	f3bf 8f4f 	dsb	sy
    6e74:	f3bf 8f6f 	isb	sy
}
    6e78:	b003      	add	sp, #12
    6e7a:	f85d fb04 	ldr.w	pc, [sp], #4
    6e7e:	bf00      	nop
    6e80:	20014948 	.word	0x20014948
    6e84:	0000088d 	.word	0x0000088d

00006e88 <tcpip_init_done>:
{
    6e88:	b5f0      	push	{r4, r5, r6, r7, lr}
	u8_t mac[6] = {0x00, 0x00, 0x00, 0x00, 0x20, 0x76};
    6e8a:	4b27      	ldr	r3, [pc, #156]	; (6f28 <tcpip_init_done+0xa0>)
	mac_async_register_callback(&COMMUNICATION_IO, MAC_ASYNC_RECEIVE_CB, gmac_handler_cb);
    6e8c:	4c27      	ldr	r4, [pc, #156]	; (6f2c <tcpip_init_done+0xa4>)
    6e8e:	4a28      	ldr	r2, [pc, #160]	; (6f30 <tcpip_init_done+0xa8>)
	while ((ethernet_phy_get_link_status(&ETHERNET_PHY_0_desc, &link_up)) != ERR_NONE && !(link_up)) {
    6e90:	4d28      	ldr	r5, [pc, #160]	; (6f34 <tcpip_init_done+0xac>)
    6e92:	4f29      	ldr	r7, [pc, #164]	; (6f38 <tcpip_init_done+0xb0>)
{
    6e94:	b085      	sub	sp, #20
    6e96:	4606      	mov	r6, r0
	u8_t mac[6] = {0x00, 0x00, 0x00, 0x00, 0x20, 0x76};
    6e98:	6818      	ldr	r0, [r3, #0]
    6e9a:	889b      	ldrh	r3, [r3, #4]
    6e9c:	9002      	str	r0, [sp, #8]
    6e9e:	f8ad 300c 	strh.w	r3, [sp, #12]
	mac_async_register_callback(&COMMUNICATION_IO, MAC_ASYNC_RECEIVE_CB, gmac_handler_cb);
    6ea2:	4620      	mov	r0, r4
    6ea4:	4b25      	ldr	r3, [pc, #148]	; (6f3c <tcpip_init_done+0xb4>)
    6ea6:	2100      	movs	r1, #0
    6ea8:	4798      	blx	r3
	hri_gmac_set_IMR_RCOMP_bit(COMMUNICATION_IO.dev.hw);
    6eaa:	6823      	ldr	r3, [r4, #0]
	((Gmac *)hw)->IDR.reg = GMAC_IMR_MFS;
}

static inline void hri_gmac_set_IMR_RCOMP_bit(const void *const hw)
{
	((Gmac *)hw)->IER.reg = GMAC_IMR_RCOMP;
    6eac:	2202      	movs	r2, #2
    6eae:	629a      	str	r2, [r3, #40]	; 0x28
	while ((ethernet_phy_get_link_status(&ETHERNET_PHY_0_desc, &link_up)) != ERR_NONE && !(link_up)) {
    6eb0:	f105 0409 	add.w	r4, r5, #9
    6eb4:	4b22      	ldr	r3, [pc, #136]	; (6f40 <tcpip_init_done+0xb8>)
    6eb6:	4621      	mov	r1, r4
    6eb8:	4638      	mov	r0, r7
    6eba:	4798      	blx	r3
    6ebc:	b110      	cbz	r0, 6ec4 <tcpip_init_done+0x3c>
    6ebe:	7a6b      	ldrb	r3, [r5, #9]
    6ec0:	2b00      	cmp	r3, #0
    6ec2:	d02c      	beq.n	6f1e <tcpip_init_done+0x96>
	printf("\r\nEthernet link up\r\n\r\n");
    6ec4:	4b1f      	ldr	r3, [pc, #124]	; (6f44 <tcpip_init_done+0xbc>)
    6ec6:	4820      	ldr	r0, [pc, #128]	; (6f48 <tcpip_init_done+0xc0>)
	TCPIP_STACK_INTERFACE_0_desc.input = tcpip_input;
    6ec8:	4c20      	ldr	r4, [pc, #128]	; (6f4c <tcpip_init_done+0xc4>)
	printf("\r\nEthernet link up\r\n\r\n");
    6eca:	4798      	blx	r3
 */
__STATIC_INLINE void __NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if ((int32_t)(IRQn) >= 0)
  {
    NVIC->IP[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
    6ecc:	4b20      	ldr	r3, [pc, #128]	; (6f50 <tcpip_init_done+0xc8>)
	mac_async_enable(&COMMUNICATION_IO);
    6ece:	4817      	ldr	r0, [pc, #92]	; (6f2c <tcpip_init_done+0xa4>)
    6ed0:	2280      	movs	r2, #128	; 0x80
    6ed2:	f883 2354 	strb.w	r2, [r3, #852]	; 0x354
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
    6ed6:	f44f 1280 	mov.w	r2, #1048576	; 0x100000
    6eda:	609a      	str	r2, [r3, #8]
    6edc:	4b1d      	ldr	r3, [pc, #116]	; (6f54 <tcpip_init_done+0xcc>)
    6ede:	4798      	blx	r3
	TCPIP_STACK_INTERFACE_0_init(mac);
    6ee0:	a802      	add	r0, sp, #8
    6ee2:	4b1d      	ldr	r3, [pc, #116]	; (6f58 <tcpip_init_done+0xd0>)
    6ee4:	4798      	blx	r3
	TCPIP_STACK_INTERFACE_0_desc.input = tcpip_input;
    6ee6:	4b1d      	ldr	r3, [pc, #116]	; (6f5c <tcpip_init_done+0xd4>)
    6ee8:	6123      	str	r3, [r4, #16]
	gs_gmac_dev.rx_sem = xSemaphoreCreateCounting(CONF_GMAC_RXDESCR_NUM, 0);
    6eea:	2100      	movs	r1, #0
    6eec:	4b1c      	ldr	r3, [pc, #112]	; (6f60 <tcpip_init_done+0xd8>)
	gs_gmac_dev.netif = &TCPIP_STACK_INTERFACE_0_desc;
    6eee:	602c      	str	r4, [r5, #0]
	gs_gmac_dev.rx_sem = xSemaphoreCreateCounting(CONF_GMAC_RXDESCR_NUM, 0);
    6ef0:	2010      	movs	r0, #16
    6ef2:	4798      	blx	r3
	id = sys_thread_new("GMAC", gmac_task, &gs_gmac_dev, netifINTERFACE_TASK_STACK_SIZE, netifINTERFACE_TASK_PRIORITY);
    6ef4:	2302      	movs	r3, #2
    6ef6:	4a0f      	ldr	r2, [pc, #60]	; (6f34 <tcpip_init_done+0xac>)
    6ef8:	491a      	ldr	r1, [pc, #104]	; (6f64 <tcpip_init_done+0xdc>)
	gs_gmac_dev.rx_sem = xSemaphoreCreateCounting(CONF_GMAC_RXDESCR_NUM, 0);
    6efa:	6068      	str	r0, [r5, #4]
	id = sys_thread_new("GMAC", gmac_task, &gs_gmac_dev, netifINTERFACE_TASK_STACK_SIZE, netifINTERFACE_TASK_PRIORITY);
    6efc:	9300      	str	r3, [sp, #0]
    6efe:	4d1a      	ldr	r5, [pc, #104]	; (6f68 <tcpip_init_done+0xe0>)
    6f00:	481a      	ldr	r0, [pc, #104]	; (6f6c <tcpip_init_done+0xe4>)
    6f02:	f44f 7300 	mov.w	r3, #512	; 0x200
    6f06:	47a8      	blx	r5
	netif_set_default(&TCPIP_STACK_INTERFACE_0_desc);
    6f08:	4620      	mov	r0, r4
    6f0a:	4b19      	ldr	r3, [pc, #100]	; (6f70 <tcpip_init_done+0xe8>)
    6f0c:	4798      	blx	r3
	netif_set_up(&TCPIP_STACK_INTERFACE_0_desc);
    6f0e:	4620      	mov	r0, r4
    6f10:	4b18      	ldr	r3, [pc, #96]	; (6f74 <tcpip_init_done+0xec>)
    6f12:	4798      	blx	r3
	sys_sem_signal(sem); /* Signal the waiting thread that the TCP/IP init is done. */
    6f14:	4b18      	ldr	r3, [pc, #96]	; (6f78 <tcpip_init_done+0xf0>)
    6f16:	4630      	mov	r0, r6
    6f18:	4798      	blx	r3
}
    6f1a:	b005      	add	sp, #20
    6f1c:	bdf0      	pop	{r4, r5, r6, r7, pc}
		os_sleep(20);
    6f1e:	4b17      	ldr	r3, [pc, #92]	; (6f7c <tcpip_init_done+0xf4>)
    6f20:	2014      	movs	r0, #20
    6f22:	4798      	blx	r3
    6f24:	e7c6      	b.n	6eb4 <tcpip_init_done+0x2c>
    6f26:	bf00      	nop
    6f28:	0000a9b0 	.word	0x0000a9b0
    6f2c:	2000a520 	.word	0x2000a520
    6f30:	00006e51 	.word	0x00006e51
    6f34:	20014948 	.word	0x20014948
    6f38:	200000a4 	.word	0x200000a4
    6f3c:	00004c59 	.word	0x00004c59
    6f40:	00001005 	.word	0x00001005
    6f44:	000095dd 	.word	0x000095dd
    6f48:	0000a991 	.word	0x0000a991
    6f4c:	2001490c 	.word	0x2001490c
    6f50:	e000e100 	.word	0xe000e100
    6f54:	00004b9d 	.word	0x00004b9d
    6f58:	00006971 	.word	0x00006971
    6f5c:	000092f5 	.word	0x000092f5
    6f60:	000005bd 	.word	0x000005bd
    6f64:	00006e2d 	.word	0x00006e2d
    6f68:	00006c7d 	.word	0x00006c7d
    6f6c:	0000a9a7 	.word	0x0000a9a7
    6f70:	00009215 	.word	0x00009215
    6f74:	00009221 	.word	0x00009221
    6f78:	00006aad 	.word	0x00006aad
    6f7c:	00008125 	.word	0x00008125

00006f80 <task_led_create>:

/**
 * \brief Create OS task for LED blinking
 */
void task_led_create(void)
{
    6f80:	b51f      	push	{r0, r1, r2, r3, r4, lr}

	/* Create task to make led blink */
	if (xTaskCreate(led_task, "Led", TASK_LED_STACK_SIZE, NULL, TASK_LED_TASK_PRIORITY, &xLed_Task) != pdPASS) {
    6f82:	4a08      	ldr	r2, [pc, #32]	; (6fa4 <task_led_create+0x24>)
    6f84:	9201      	str	r2, [sp, #4]
    6f86:	2300      	movs	r3, #0
    6f88:	2201      	movs	r2, #1
    6f8a:	9200      	str	r2, [sp, #0]
    6f8c:	e9cd 3302 	strd	r3, r3, [sp, #8]
    6f90:	4905      	ldr	r1, [pc, #20]	; (6fa8 <task_led_create+0x28>)
    6f92:	4806      	ldr	r0, [pc, #24]	; (6fac <task_led_create+0x2c>)
    6f94:	4c06      	ldr	r4, [pc, #24]	; (6fb0 <task_led_create+0x30>)
    6f96:	2280      	movs	r2, #128	; 0x80
    6f98:	47a0      	blx	r4
    6f9a:	2801      	cmp	r0, #1
    6f9c:	d000      	beq.n	6fa0 <task_led_create+0x20>
		while (1) {
    6f9e:	e7fe      	b.n	6f9e <task_led_create+0x1e>
			;
		}
	}
}
    6fa0:	b004      	add	sp, #16
    6fa2:	bd10      	pop	{r4, pc}
    6fa4:	20014954 	.word	0x20014954
    6fa8:	0000a9ac 	.word	0x0000a9ac
    6fac:	00006e09 	.word	0x00006e09
    6fb0:	00007ce5 	.word	0x00007ce5

00006fb4 <lwip_init>:

/**
 * Perform Sanity check of user-configurable values, and initialize all modules.
 */
void lwip_init(void)
{
    6fb4:	b510      	push	{r4, lr}
	/* Modules initialization */
	stats_init();
#if !NO_SYS
	sys_init();
    6fb6:	4b09      	ldr	r3, [pc, #36]	; (6fdc <lwip_init+0x28>)
    6fb8:	4798      	blx	r3
#endif /* !NO_SYS */
	mem_init();
    6fba:	4b09      	ldr	r3, [pc, #36]	; (6fe0 <lwip_init+0x2c>)
    6fbc:	4798      	blx	r3
	memp_init();
    6fbe:	4b09      	ldr	r3, [pc, #36]	; (6fe4 <lwip_init+0x30>)
    6fc0:	4798      	blx	r3
	pbuf_init();
	netif_init();
    6fc2:	4b09      	ldr	r3, [pc, #36]	; (6fe8 <lwip_init+0x34>)
    6fc4:	4798      	blx	r3
#if LWIP_SOCKET
	lwip_socket_init();
    6fc6:	4b09      	ldr	r3, [pc, #36]	; (6fec <lwip_init+0x38>)
    6fc8:	4798      	blx	r3
#endif /* LWIP_ARP */
#if LWIP_RAW
	raw_init();
#endif /* LWIP_RAW */
#if LWIP_UDP
	udp_init();
    6fca:	4b09      	ldr	r3, [pc, #36]	; (6ff0 <lwip_init+0x3c>)
    6fcc:	4798      	blx	r3
#endif /* LWIP_UDP */
#if LWIP_TCP
	tcp_init();
    6fce:	4b09      	ldr	r3, [pc, #36]	; (6ff4 <lwip_init+0x40>)
    6fd0:	4798      	blx	r3
#endif /* LWIP_DNS */

#if LWIP_TIMERS
	sys_timeouts_init();
#endif /* LWIP_TIMERS */
}
    6fd2:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	sys_timeouts_init();
    6fd6:	4b08      	ldr	r3, [pc, #32]	; (6ff8 <lwip_init+0x44>)
    6fd8:	4718      	bx	r3
    6fda:	bf00      	nop
    6fdc:	00006a31 	.word	0x00006a31
    6fe0:	000056b1 	.word	0x000056b1
    6fe4:	00004add 	.word	0x00004add
    6fe8:	00009151 	.word	0x00009151
    6fec:	00008799 	.word	0x00008799
    6ff0:	00004419 	.word	0x00004419
    6ff4:	000059a9 	.word	0x000059a9
    6ff8:	0000111d 	.word	0x0000111d

00006ffc <prvInsertTimerInActiveList>:
	BaseType_t xProcessTimerNow = pdFALSE;

	listSET_LIST_ITEM_VALUE(&(pxTimer->xTimerListItem), xNextExpiryTime);
	listSET_LIST_ITEM_OWNER(&(pxTimer->xTimerListItem), pxTimer);

	if (xNextExpiryTime <= xTimeNow) {
    6ffc:	4291      	cmp	r1, r2
{
    6ffe:	b508      	push	{r3, lr}
	listSET_LIST_ITEM_VALUE(&(pxTimer->xTimerListItem), xNextExpiryTime);
    7000:	6041      	str	r1, [r0, #4]
	listSET_LIST_ITEM_OWNER(&(pxTimer->xTimerListItem), pxTimer);
    7002:	6100      	str	r0, [r0, #16]
	if (xNextExpiryTime <= xTimeNow) {
    7004:	d80a      	bhi.n	701c <prvInsertTimerInActiveList+0x20>
		/* Has the expiry time elapsed between the command to start/reset a
		timer was issued, and the time the command was processed? */
		if ((xTimeNow - xCommandTime) >= pxTimer->xTimerPeriodInTicks) {
    7006:	1ad2      	subs	r2, r2, r3
    7008:	6983      	ldr	r3, [r0, #24]
    700a:	429a      	cmp	r2, r3
    700c:	d20e      	bcs.n	702c <prvInsertTimerInActiveList+0x30>
			/* The time between a command being issued and the command being
			processed actually exceeds the timers period.  */
			xProcessTimerNow = pdTRUE;
		} else {
			vListInsert(pxOverflowTimerList, &(pxTimer->xTimerListItem));
    700e:	4b08      	ldr	r3, [pc, #32]	; (7030 <prvInsertTimerInActiveList+0x34>)
    7010:	1d01      	adds	r1, r0, #4
    7012:	6818      	ldr	r0, [r3, #0]
			/* If, since the command was issued, the tick count has overflowed
			but the expiry time has not, then the timer must have already passed
			its expiry time and should be processed immediately. */
			xProcessTimerNow = pdTRUE;
		} else {
			vListInsert(pxCurrentTimerList, &(pxTimer->xTimerListItem));
    7014:	4b07      	ldr	r3, [pc, #28]	; (7034 <prvInsertTimerInActiveList+0x38>)
    7016:	4798      	blx	r3
	BaseType_t xProcessTimerNow = pdFALSE;
    7018:	2000      	movs	r0, #0
		}
	}

	return xProcessTimerNow;
}
    701a:	bd08      	pop	{r3, pc}
		if ((xTimeNow < xCommandTime) && (xNextExpiryTime >= xCommandTime)) {
    701c:	429a      	cmp	r2, r3
    701e:	d201      	bcs.n	7024 <prvInsertTimerInActiveList+0x28>
    7020:	4299      	cmp	r1, r3
    7022:	d203      	bcs.n	702c <prvInsertTimerInActiveList+0x30>
			vListInsert(pxCurrentTimerList, &(pxTimer->xTimerListItem));
    7024:	4b02      	ldr	r3, [pc, #8]	; (7030 <prvInsertTimerInActiveList+0x34>)
    7026:	1d01      	adds	r1, r0, #4
    7028:	6858      	ldr	r0, [r3, #4]
    702a:	e7f3      	b.n	7014 <prvInsertTimerInActiveList+0x18>
			xProcessTimerNow = pdTRUE;
    702c:	2001      	movs	r0, #1
	return xProcessTimerNow;
    702e:	e7f4      	b.n	701a <prvInsertTimerInActiveList+0x1e>
    7030:	20014958 	.word	0x20014958
    7034:	00001dcd 	.word	0x00001dcd

00007038 <prvCheckForValidListAndQueue>:
	pxOverflowTimerList = pxTemp;
}
/*-----------------------------------------------------------*/

static void prvCheckForValidListAndQueue(void)
{
    7038:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	/* Check that the list from which active timers are referenced, and the
	queue used to communicate with the timer service, have been
	initialised. */
	taskENTER_CRITICAL();
	{
		if (xTimerQueue == NULL) {
    703c:	4c12      	ldr	r4, [pc, #72]	; (7088 <prvCheckForValidListAndQueue+0x50>)
	taskENTER_CRITICAL();
    703e:	4b13      	ldr	r3, [pc, #76]	; (708c <prvCheckForValidListAndQueue+0x54>)
    7040:	4798      	blx	r3
		if (xTimerQueue == NULL) {
    7042:	68a5      	ldr	r5, [r4, #8]
    7044:	b995      	cbnz	r5, 706c <prvCheckForValidListAndQueue+0x34>
			vListInitialise(&xActiveTimerList1);
    7046:	f104 070c 	add.w	r7, r4, #12
    704a:	f8df 804c 	ldr.w	r8, [pc, #76]	; 7098 <prvCheckForValidListAndQueue+0x60>
    704e:	4638      	mov	r0, r7
			vListInitialise(&xActiveTimerList2);
    7050:	f104 0620 	add.w	r6, r4, #32
			vListInitialise(&xActiveTimerList1);
    7054:	47c0      	blx	r8
			vListInitialise(&xActiveTimerList2);
    7056:	4630      	mov	r0, r6
    7058:	47c0      	blx	r8
			pxCurrentTimerList  = &xActiveTimerList1;
			pxOverflowTimerList = &xActiveTimerList2;
			xTimerQueue         = xQueueCreate((UBaseType_t)configTIMER_QUEUE_LENGTH, sizeof(DaemonTaskMessage_t));
    705a:	4b0d      	ldr	r3, [pc, #52]	; (7090 <prvCheckForValidListAndQueue+0x58>)
    705c:	462a      	mov	r2, r5
    705e:	210c      	movs	r1, #12
    7060:	2002      	movs	r0, #2
			pxOverflowTimerList = &xActiveTimerList2;
    7062:	e9c4 6700 	strd	r6, r7, [r4]
			xTimerQueue         = xQueueCreate((UBaseType_t)configTIMER_QUEUE_LENGTH, sizeof(DaemonTaskMessage_t));
    7066:	4798      	blx	r3
			configASSERT(xTimerQueue);
    7068:	b120      	cbz	r0, 7074 <prvCheckForValidListAndQueue+0x3c>
			xTimerQueue         = xQueueCreate((UBaseType_t)configTIMER_QUEUE_LENGTH, sizeof(DaemonTaskMessage_t));
    706a:	60a0      	str	r0, [r4, #8]
		} else {
			mtCOVERAGE_TEST_MARKER();
		}
	}
	taskEXIT_CRITICAL();
}
    706c:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
	taskEXIT_CRITICAL();
    7070:	4b08      	ldr	r3, [pc, #32]	; (7094 <prvCheckForValidListAndQueue+0x5c>)
    7072:	4718      	bx	r3
    7074:	f04f 0380 	mov.w	r3, #128	; 0x80
    7078:	f383 8811 	msr	BASEPRI, r3
    707c:	f3bf 8f6f 	isb	sy
    7080:	f3bf 8f4f 	dsb	sy
			configASSERT(xTimerQueue);
    7084:	e7fe      	b.n	7084 <prvCheckForValidListAndQueue+0x4c>
    7086:	bf00      	nop
    7088:	20014958 	.word	0x20014958
    708c:	00008ef5 	.word	0x00008ef5
    7090:	0000054d 	.word	0x0000054d
    7094:	00008f35 	.word	0x00008f35
    7098:	00001d99 	.word	0x00001d99

0000709c <xTimerCreateTimerTask>:
{
    709c:	b51f      	push	{r0, r1, r2, r3, r4, lr}
	prvCheckForValidListAndQueue();
    709e:	4b0e      	ldr	r3, [pc, #56]	; (70d8 <xTimerCreateTimerTask+0x3c>)
    70a0:	4798      	blx	r3
	if (xTimerQueue != NULL) {
    70a2:	4b0e      	ldr	r3, [pc, #56]	; (70dc <xTimerCreateTimerTask+0x40>)
    70a4:	689b      	ldr	r3, [r3, #8]
    70a6:	b163      	cbz	r3, 70c2 <xTimerCreateTimerTask+0x26>
			xReturn = xTaskCreate(prvTimerTask,
    70a8:	2300      	movs	r3, #0
    70aa:	2202      	movs	r2, #2
    70ac:	9200      	str	r2, [sp, #0]
    70ae:	e9cd 3302 	strd	r3, r3, [sp, #8]
    70b2:	490b      	ldr	r1, [pc, #44]	; (70e0 <xTimerCreateTimerTask+0x44>)
    70b4:	480b      	ldr	r0, [pc, #44]	; (70e4 <xTimerCreateTimerTask+0x48>)
    70b6:	4c0c      	ldr	r4, [pc, #48]	; (70e8 <xTimerCreateTimerTask+0x4c>)
    70b8:	9301      	str	r3, [sp, #4]
    70ba:	f44f 7280 	mov.w	r2, #256	; 0x100
    70be:	47a0      	blx	r4
	configASSERT(xReturn);
    70c0:	b940      	cbnz	r0, 70d4 <xTimerCreateTimerTask+0x38>
    70c2:	f04f 0380 	mov.w	r3, #128	; 0x80
    70c6:	f383 8811 	msr	BASEPRI, r3
    70ca:	f3bf 8f6f 	isb	sy
    70ce:	f3bf 8f4f 	dsb	sy
    70d2:	e7fe      	b.n	70d2 <xTimerCreateTimerTask+0x36>
}
    70d4:	b004      	add	sp, #16
    70d6:	bd10      	pop	{r4, pc}
    70d8:	00007039 	.word	0x00007039
    70dc:	20014958 	.word	0x20014958
    70e0:	0000a9b6 	.word	0x0000a9b6
    70e4:	000071f5 	.word	0x000071f5
    70e8:	00007ce5 	.word	0x00007ce5

000070ec <xTimerGenericCommand>:
{
    70ec:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
    70ee:	4616      	mov	r6, r2
	configASSERT(xTimer);
    70f0:	4604      	mov	r4, r0
{
    70f2:	461a      	mov	r2, r3
	configASSERT(xTimer);
    70f4:	b940      	cbnz	r0, 7108 <xTimerGenericCommand+0x1c>
    70f6:	f04f 0380 	mov.w	r3, #128	; 0x80
    70fa:	f383 8811 	msr	BASEPRI, r3
    70fe:	f3bf 8f6f 	isb	sy
    7102:	f3bf 8f4f 	dsb	sy
    7106:	e7fe      	b.n	7106 <xTimerGenericCommand+0x1a>
	if (xTimerQueue != NULL) {
    7108:	4d0d      	ldr	r5, [pc, #52]	; (7140 <xTimerGenericCommand+0x54>)
    710a:	68a8      	ldr	r0, [r5, #8]
    710c:	b188      	cbz	r0, 7132 <xTimerGenericCommand+0x46>
		if (xCommandID < tmrFIRST_FROM_ISR_COMMAND) {
    710e:	2905      	cmp	r1, #5
		xMessage.u.xTimerParameters.xMessageValue = xOptionalValue;
    7110:	e9cd 1601 	strd	r1, r6, [sp, #4]
		xMessage.u.xTimerParameters.pxTimer       = (Timer_t *)xTimer;
    7114:	9403      	str	r4, [sp, #12]
		if (xCommandID < tmrFIRST_FROM_ISR_COMMAND) {
    7116:	dc0e      	bgt.n	7136 <xTimerGenericCommand+0x4a>
			if (xTaskGetSchedulerState() == taskSCHEDULER_RUNNING) {
    7118:	4b0a      	ldr	r3, [pc, #40]	; (7144 <xTimerGenericCommand+0x58>)
    711a:	4c0b      	ldr	r4, [pc, #44]	; (7148 <xTimerGenericCommand+0x5c>)
    711c:	4798      	blx	r3
    711e:	2802      	cmp	r0, #2
				xReturn = xQueueSendToBack(xTimerQueue, &xMessage, xTicksToWait);
    7120:	f04f 0300 	mov.w	r3, #0
    7124:	bf08      	it	eq
    7126:	9a08      	ldreq	r2, [sp, #32]
				xReturn = xQueueSendToBack(xTimerQueue, &xMessage, tmrNO_DELAY);
    7128:	68a8      	ldr	r0, [r5, #8]
    712a:	bf18      	it	ne
    712c:	461a      	movne	r2, r3
    712e:	a901      	add	r1, sp, #4
			xReturn = xQueueSendToBackFromISR(xTimerQueue, &xMessage, pxHigherPriorityTaskWoken);
    7130:	47a0      	blx	r4
}
    7132:	b004      	add	sp, #16
    7134:	bd70      	pop	{r4, r5, r6, pc}
			xReturn = xQueueSendToBackFromISR(xTimerQueue, &xMessage, pxHigherPriorityTaskWoken);
    7136:	4c05      	ldr	r4, [pc, #20]	; (714c <xTimerGenericCommand+0x60>)
    7138:	2300      	movs	r3, #0
    713a:	a901      	add	r1, sp, #4
    713c:	e7f8      	b.n	7130 <xTimerGenericCommand+0x44>
    713e:	bf00      	nop
    7140:	20014958 	.word	0x20014958
    7144:	00008475 	.word	0x00008475
    7148:	00000611 	.word	0x00000611
    714c:	000007b1 	.word	0x000007b1

00007150 <prvSampleTimeNow>:
{
    7150:	e92d 47ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, lr}
	xTimeNow = xTaskGetTickCount();
    7154:	4b22      	ldr	r3, [pc, #136]	; (71e0 <prvSampleTimeNow+0x90>)
	if (xTimeNow < xLastTime) {
    7156:	4d23      	ldr	r5, [pc, #140]	; (71e4 <prvSampleTimeNow+0x94>)
{
    7158:	4607      	mov	r7, r0
	xTimeNow = xTaskGetTickCount();
    715a:	4798      	blx	r3
	if (xTimeNow < xLastTime) {
    715c:	6b6b      	ldr	r3, [r5, #52]	; 0x34
    715e:	4283      	cmp	r3, r0
	xTimeNow = xTaskGetTickCount();
    7160:	4606      	mov	r6, r0
	if (xTimeNow < xLastTime) {
    7162:	d93a      	bls.n	71da <prvSampleTimeNow+0x8a>
		(void)uxListRemove(&(pxTimer->xTimerListItem));
    7164:	f8df 8084 	ldr.w	r8, [pc, #132]	; 71ec <prvSampleTimeNow+0x9c>
				    = xTimerGenericCommand(pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY);
    7168:	f8df 9084 	ldr.w	r9, [pc, #132]	; 71f0 <prvSampleTimeNow+0xa0>
	while (listLIST_IS_EMPTY(pxCurrentTimerList) == pdFALSE) {
    716c:	686b      	ldr	r3, [r5, #4]
    716e:	681a      	ldr	r2, [r3, #0]
    7170:	b94a      	cbnz	r2, 7186 <prvSampleTimeNow+0x36>
	pxCurrentTimerList  = pxOverflowTimerList;
    7172:	682a      	ldr	r2, [r5, #0]
	pxOverflowTimerList = pxTemp;
    7174:	e9c5 3200 	strd	r3, r2, [r5]
		*pxTimerListsWereSwitched = pdTRUE;
    7178:	2301      	movs	r3, #1
}
    717a:	4630      	mov	r0, r6
		*pxTimerListsWereSwitched = pdFALSE;
    717c:	603b      	str	r3, [r7, #0]
	xLastTime = xTimeNow;
    717e:	636e      	str	r6, [r5, #52]	; 0x34
}
    7180:	b004      	add	sp, #16
    7182:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY(pxCurrentTimerList);
    7186:	68db      	ldr	r3, [r3, #12]
		pxTimer = (Timer_t *)listGET_OWNER_OF_HEAD_ENTRY(pxCurrentTimerList);
    7188:	68dc      	ldr	r4, [r3, #12]
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY(pxCurrentTimerList);
    718a:	f8d3 a000 	ldr.w	sl, [r3]
		(void)uxListRemove(&(pxTimer->xTimerListItem));
    718e:	1d21      	adds	r1, r4, #4
    7190:	4608      	mov	r0, r1
    7192:	9103      	str	r1, [sp, #12]
    7194:	47c0      	blx	r8
		pxTimer->pxCallbackFunction((TimerHandle_t)pxTimer);
    7196:	6a63      	ldr	r3, [r4, #36]	; 0x24
    7198:	4620      	mov	r0, r4
    719a:	4798      	blx	r3
		if (pxTimer->uxAutoReload == (UBaseType_t)pdTRUE) {
    719c:	69e3      	ldr	r3, [r4, #28]
    719e:	9903      	ldr	r1, [sp, #12]
    71a0:	2b01      	cmp	r3, #1
    71a2:	d1e3      	bne.n	716c <prvSampleTimeNow+0x1c>
			xReloadTime = (xNextExpireTime + pxTimer->xTimerPeriodInTicks);
    71a4:	69a3      	ldr	r3, [r4, #24]
    71a6:	4453      	add	r3, sl
			if (xReloadTime > xNextExpireTime) {
    71a8:	459a      	cmp	sl, r3
    71aa:	d205      	bcs.n	71b8 <prvSampleTimeNow+0x68>
				listSET_LIST_ITEM_VALUE(&(pxTimer->xTimerListItem), xReloadTime);
    71ac:	6063      	str	r3, [r4, #4]
				vListInsert(pxCurrentTimerList, &(pxTimer->xTimerListItem));
    71ae:	6868      	ldr	r0, [r5, #4]
    71b0:	4b0d      	ldr	r3, [pc, #52]	; (71e8 <prvSampleTimeNow+0x98>)
				listSET_LIST_ITEM_OWNER(&(pxTimer->xTimerListItem), pxTimer);
    71b2:	6124      	str	r4, [r4, #16]
				vListInsert(pxCurrentTimerList, &(pxTimer->xTimerListItem));
    71b4:	4798      	blx	r3
    71b6:	e7d9      	b.n	716c <prvSampleTimeNow+0x1c>
				    = xTimerGenericCommand(pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY);
    71b8:	2300      	movs	r3, #0
    71ba:	9300      	str	r3, [sp, #0]
    71bc:	4652      	mov	r2, sl
    71be:	4619      	mov	r1, r3
    71c0:	4620      	mov	r0, r4
    71c2:	47c8      	blx	r9
				configASSERT(xResult);
    71c4:	2800      	cmp	r0, #0
    71c6:	d1d1      	bne.n	716c <prvSampleTimeNow+0x1c>
    71c8:	f04f 0380 	mov.w	r3, #128	; 0x80
    71cc:	f383 8811 	msr	BASEPRI, r3
    71d0:	f3bf 8f6f 	isb	sy
    71d4:	f3bf 8f4f 	dsb	sy
    71d8:	e7fe      	b.n	71d8 <prvSampleTimeNow+0x88>
		*pxTimerListsWereSwitched = pdFALSE;
    71da:	2300      	movs	r3, #0
    71dc:	e7cd      	b.n	717a <prvSampleTimeNow+0x2a>
    71de:	bf00      	nop
    71e0:	00007f39 	.word	0x00007f39
    71e4:	20014958 	.word	0x20014958
    71e8:	00001dcd 	.word	0x00001dcd
    71ec:	00001dfb 	.word	0x00001dfb
    71f0:	000070ed 	.word	0x000070ed

000071f4 <prvTimerTask>:
{
    71f4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	(void)uxListRemove(&(pxTimer->xTimerListItem));
    71f8:	f8df a1ac 	ldr.w	sl, [pc, #428]	; 73a8 <prvTimerTask+0x1b4>
{
    71fc:	b087      	sub	sp, #28
	*pxListWasEmpty = listLIST_IS_EMPTY(pxCurrentTimerList);
    71fe:	4f61      	ldr	r7, [pc, #388]	; (7384 <prvTimerTask+0x190>)
    7200:	687b      	ldr	r3, [r7, #4]
    7202:	f8d3 b000 	ldr.w	fp, [r3]
	if (*pxListWasEmpty == pdFALSE) {
    7206:	f1bb 0f00 	cmp.w	fp, #0
    720a:	d035      	beq.n	7278 <prvTimerTask+0x84>
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY(pxCurrentTimerList);
    720c:	68db      	ldr	r3, [r3, #12]
    720e:	681e      	ldr	r6, [r3, #0]
	vTaskSuspendAll();
    7210:	4b5d      	ldr	r3, [pc, #372]	; (7388 <prvTimerTask+0x194>)
		xTimeNow = prvSampleTimeNow(&xTimerListsWereSwitched);
    7212:	4d5e      	ldr	r5, [pc, #376]	; (738c <prvTimerTask+0x198>)
	vTaskSuspendAll();
    7214:	4798      	blx	r3
		xTimeNow = prvSampleTimeNow(&xTimerListsWereSwitched);
    7216:	a803      	add	r0, sp, #12
    7218:	47a8      	blx	r5
		if (xTimerListsWereSwitched == pdFALSE) {
    721a:	9c03      	ldr	r4, [sp, #12]
    721c:	46a9      	mov	r9, r5
		xTimeNow = prvSampleTimeNow(&xTimerListsWereSwitched);
    721e:	4680      	mov	r8, r0
		if (xTimerListsWereSwitched == pdFALSE) {
    7220:	4d5b      	ldr	r5, [pc, #364]	; (7390 <prvTimerTask+0x19c>)
    7222:	2c00      	cmp	r4, #0
    7224:	d173      	bne.n	730e <prvTimerTask+0x11a>
			if ((xListWasEmpty == pdFALSE) && (xNextExpireTime <= xTimeNow)) {
    7226:	f1bb 0f00 	cmp.w	fp, #0
    722a:	d057      	beq.n	72dc <prvTimerTask+0xe8>
    722c:	42b0      	cmp	r0, r6
    722e:	d35a      	bcc.n	72e6 <prvTimerTask+0xf2>
				(void)xTaskResumeAll();
    7230:	47a8      	blx	r5
	Timer_t *const pxTimer = (Timer_t *)listGET_OWNER_OF_HEAD_ENTRY(pxCurrentTimerList);
    7232:	687b      	ldr	r3, [r7, #4]
    7234:	68db      	ldr	r3, [r3, #12]
    7236:	68dd      	ldr	r5, [r3, #12]
	(void)uxListRemove(&(pxTimer->xTimerListItem));
    7238:	1d28      	adds	r0, r5, #4
    723a:	47d0      	blx	sl
	if (pxTimer->uxAutoReload == (UBaseType_t)pdTRUE) {
    723c:	69eb      	ldr	r3, [r5, #28]
    723e:	2b01      	cmp	r3, #1
    7240:	d11c      	bne.n	727c <prvTimerTask+0x88>
		if (prvInsertTimerInActiveList(
    7242:	69a9      	ldr	r1, [r5, #24]
    7244:	4642      	mov	r2, r8
    7246:	4633      	mov	r3, r6
    7248:	f8df 8154 	ldr.w	r8, [pc, #340]	; 73a0 <prvTimerTask+0x1ac>
    724c:	4431      	add	r1, r6
    724e:	4628      	mov	r0, r5
    7250:	47c0      	blx	r8
    7252:	2801      	cmp	r0, #1
    7254:	d112      	bne.n	727c <prvTimerTask+0x88>
			xResult = xTimerGenericCommand(pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY);
    7256:	9400      	str	r4, [sp, #0]
    7258:	4623      	mov	r3, r4
    725a:	4621      	mov	r1, r4
    725c:	4632      	mov	r2, r6
    725e:	4c4d      	ldr	r4, [pc, #308]	; (7394 <prvTimerTask+0x1a0>)
    7260:	4628      	mov	r0, r5
    7262:	47a0      	blx	r4
			configASSERT(xResult);
    7264:	b950      	cbnz	r0, 727c <prvTimerTask+0x88>
    7266:	f04f 0380 	mov.w	r3, #128	; 0x80
    726a:	f383 8811 	msr	BASEPRI, r3
    726e:	f3bf 8f6f 	isb	sy
    7272:	f3bf 8f4f 	dsb	sy
    7276:	e7fe      	b.n	7276 <prvTimerTask+0x82>
		xNextExpireTime = (TickType_t)0U;
    7278:	465e      	mov	r6, fp
    727a:	e7c9      	b.n	7210 <prvTimerTask+0x1c>
	pxTimer->pxCallbackFunction((TimerHandle_t)pxTimer);
    727c:	6a6b      	ldr	r3, [r5, #36]	; 0x24
    727e:	4628      	mov	r0, r5
    7280:	4798      	blx	r3
	while (xQueueReceive(xTimerQueue, &xMessage, tmrNO_DELAY)
    7282:	4d45      	ldr	r5, [pc, #276]	; (7398 <prvTimerTask+0x1a4>)
    7284:	68b8      	ldr	r0, [r7, #8]
    7286:	2300      	movs	r3, #0
    7288:	461a      	mov	r2, r3
    728a:	a903      	add	r1, sp, #12
    728c:	47a8      	blx	r5
    728e:	2800      	cmp	r0, #0
    7290:	d0b5      	beq.n	71fe <prvTimerTask+0xa>
		if (xMessage.xMessageID >= (BaseType_t)0) {
    7292:	9b03      	ldr	r3, [sp, #12]
    7294:	2b00      	cmp	r3, #0
    7296:	dbf5      	blt.n	7284 <prvTimerTask+0x90>
			pxTimer = xMessage.u.xTimerParameters.pxTimer;
    7298:	9c05      	ldr	r4, [sp, #20]
			if (listIS_CONTAINED_WITHIN(NULL, &(pxTimer->xTimerListItem)) == pdFALSE) {
    729a:	6963      	ldr	r3, [r4, #20]
    729c:	b10b      	cbz	r3, 72a2 <prvTimerTask+0xae>
				(void)uxListRemove(&(pxTimer->xTimerListItem));
    729e:	1d20      	adds	r0, r4, #4
    72a0:	47d0      	blx	sl
			xTimeNow = prvSampleTimeNow(&xTimerListsWereSwitched);
    72a2:	a802      	add	r0, sp, #8
    72a4:	47c8      	blx	r9
			switch (xMessage.xMessageID) {
    72a6:	9b03      	ldr	r3, [sp, #12]
			xTimeNow = prvSampleTimeNow(&xTimerListsWereSwitched);
    72a8:	4602      	mov	r2, r0
			switch (xMessage.xMessageID) {
    72aa:	2b09      	cmp	r3, #9
    72ac:	d8ea      	bhi.n	7284 <prvTimerTask+0x90>
    72ae:	a101      	add	r1, pc, #4	; (adr r1, 72b4 <prvTimerTask+0xc0>)
    72b0:	f851 f023 	ldr.w	pc, [r1, r3, lsl #2]
    72b4:	00007313 	.word	0x00007313
    72b8:	00007313 	.word	0x00007313
    72bc:	00007313 	.word	0x00007313
    72c0:	00007285 	.word	0x00007285
    72c4:	00007357 	.word	0x00007357
    72c8:	0000737b 	.word	0x0000737b
    72cc:	00007313 	.word	0x00007313
    72d0:	00007313 	.word	0x00007313
    72d4:	00007285 	.word	0x00007285
    72d8:	00007357 	.word	0x00007357
					xListWasEmpty = listLIST_IS_EMPTY(pxOverflowTimerList);
    72dc:	683b      	ldr	r3, [r7, #0]
    72de:	681c      	ldr	r4, [r3, #0]
    72e0:	fab4 f484 	clz	r4, r4
    72e4:	0964      	lsrs	r4, r4, #5
				vQueueWaitForMessageRestricted(xTimerQueue, (xNextExpireTime - xTimeNow), xListWasEmpty);
    72e6:	68b8      	ldr	r0, [r7, #8]
    72e8:	4b2c      	ldr	r3, [pc, #176]	; (739c <prvTimerTask+0x1a8>)
    72ea:	4622      	mov	r2, r4
    72ec:	eba6 0108 	sub.w	r1, r6, r8
    72f0:	4798      	blx	r3
				if (xTaskResumeAll() == pdFALSE) {
    72f2:	47a8      	blx	r5
    72f4:	2800      	cmp	r0, #0
    72f6:	d1c4      	bne.n	7282 <prvTimerTask+0x8e>
					portYIELD_WITHIN_API();
    72f8:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
    72fc:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
    7300:	f8c3 2d04 	str.w	r2, [r3, #3332]	; 0xd04
    7304:	f3bf 8f4f 	dsb	sy
    7308:	f3bf 8f6f 	isb	sy
    730c:	e7b9      	b.n	7282 <prvTimerTask+0x8e>
			(void)xTaskResumeAll();
    730e:	47a8      	blx	r5
    7310:	e7b7      	b.n	7282 <prvTimerTask+0x8e>
				if (prvInsertTimerInActiveList(pxTimer,
    7312:	69a1      	ldr	r1, [r4, #24]
    7314:	9b04      	ldr	r3, [sp, #16]
    7316:	4e22      	ldr	r6, [pc, #136]	; (73a0 <prvTimerTask+0x1ac>)
    7318:	4419      	add	r1, r3
    731a:	4620      	mov	r0, r4
    731c:	47b0      	blx	r6
    731e:	2801      	cmp	r0, #1
    7320:	d1b0      	bne.n	7284 <prvTimerTask+0x90>
					pxTimer->pxCallbackFunction((TimerHandle_t)pxTimer);
    7322:	6a63      	ldr	r3, [r4, #36]	; 0x24
    7324:	4620      	mov	r0, r4
    7326:	4798      	blx	r3
					if (pxTimer->uxAutoReload == (UBaseType_t)pdTRUE) {
    7328:	69e3      	ldr	r3, [r4, #28]
    732a:	2b01      	cmp	r3, #1
    732c:	d1aa      	bne.n	7284 <prvTimerTask+0x90>
						xResult = xTimerGenericCommand(pxTimer,
    732e:	69a2      	ldr	r2, [r4, #24]
    7330:	9904      	ldr	r1, [sp, #16]
    7332:	2300      	movs	r3, #0
    7334:	440a      	add	r2, r1
    7336:	4620      	mov	r0, r4
    7338:	9300      	str	r3, [sp, #0]
    733a:	4c16      	ldr	r4, [pc, #88]	; (7394 <prvTimerTask+0x1a0>)
    733c:	4619      	mov	r1, r3
    733e:	47a0      	blx	r4
						configASSERT(xResult);
    7340:	2800      	cmp	r0, #0
    7342:	d19f      	bne.n	7284 <prvTimerTask+0x90>
    7344:	f04f 0380 	mov.w	r3, #128	; 0x80
    7348:	f383 8811 	msr	BASEPRI, r3
    734c:	f3bf 8f6f 	isb	sy
    7350:	f3bf 8f4f 	dsb	sy
    7354:	e7fe      	b.n	7354 <prvTimerTask+0x160>
				pxTimer->xTimerPeriodInTicks = xMessage.u.xTimerParameters.xMessageValue;
    7356:	9904      	ldr	r1, [sp, #16]
    7358:	61a1      	str	r1, [r4, #24]
				configASSERT((pxTimer->xTimerPeriodInTicks > 0));
    735a:	b941      	cbnz	r1, 736e <prvTimerTask+0x17a>
    735c:	f04f 0380 	mov.w	r3, #128	; 0x80
    7360:	f383 8811 	msr	BASEPRI, r3
    7364:	f3bf 8f6f 	isb	sy
    7368:	f3bf 8f4f 	dsb	sy
    736c:	e7fe      	b.n	736c <prvTimerTask+0x178>
				(void)prvInsertTimerInActiveList(
    736e:	4603      	mov	r3, r0
    7370:	4401      	add	r1, r0
    7372:	4620      	mov	r0, r4
    7374:	4c0a      	ldr	r4, [pc, #40]	; (73a0 <prvTimerTask+0x1ac>)
    7376:	47a0      	blx	r4
				break;
    7378:	e784      	b.n	7284 <prvTimerTask+0x90>
				vPortFree(pxTimer);
    737a:	4b0a      	ldr	r3, [pc, #40]	; (73a4 <prvTimerTask+0x1b0>)
    737c:	4620      	mov	r0, r4
    737e:	4798      	blx	r3
				break;
    7380:	e780      	b.n	7284 <prvTimerTask+0x90>
    7382:	bf00      	nop
    7384:	20014958 	.word	0x20014958
    7388:	00007f25 	.word	0x00007f25
    738c:	00007151 	.word	0x00007151
    7390:	00008039 	.word	0x00008039
    7394:	000070ed 	.word	0x000070ed
    7398:	00000951 	.word	0x00000951
    739c:	00000b01 	.word	0x00000b01
    73a0:	00006ffd 	.word	0x00006ffd
    73a4:	00001d51 	.word	0x00001d51
    73a8:	00001dfb 	.word	0x00001dfb

000073ac <lwip_standard_chksum>:
 * @param len length of data to be summed
 * @return host order (!) lwip checksum (non-inverted Internet sum)
 */

static u16_t lwip_standard_chksum(void *dataptr, int len)
{
    73ac:	b573      	push	{r0, r1, r4, r5, r6, lr}
	u8_t * pb = (u8_t *)dataptr;
	u16_t *ps, t = 0;
    73ae:	2300      	movs	r3, #0
	u32_t  sum = 0;
	int    odd = ((mem_ptr_t)pb & 1);

	/* Get aligned to u16_t */
	if (odd && len > 0) {
    73b0:	f010 0401 	ands.w	r4, r0, #1
	u16_t *ps, t = 0;
    73b4:	f8ad 3006 	strh.w	r3, [sp, #6]
	if (odd && len > 0) {
    73b8:	d005      	beq.n	73c6 <lwip_standard_chksum+0x1a>
    73ba:	b351      	cbz	r1, 7412 <lwip_standard_chksum+0x66>
		((u8_t *)&t)[1] = *pb++;
    73bc:	f810 3b01 	ldrb.w	r3, [r0], #1
    73c0:	f88d 3007 	strb.w	r3, [sp, #7]
		len--;
    73c4:	3901      	subs	r1, #1
	}

	/* Add the bulk of the data */
	ps = (u16_t *)(void *)pb;
	while (len > 1) {
    73c6:	f021 0301 	bic.w	r3, r1, #1
    73ca:	084d      	lsrs	r5, r1, #1
    73cc:	4403      	add	r3, r0
	u32_t  sum = 0;
    73ce:	2200      	movs	r2, #0
	while (len > 1) {
    73d0:	4298      	cmp	r0, r3
    73d2:	d11a      	bne.n	740a <lwip_standard_chksum+0x5e>
		sum += *ps++;
		len -= 2;
	}

	/* Consume left-over byte, if any */
	if (len > 0) {
    73d4:	f06f 0301 	mvn.w	r3, #1
    73d8:	fb03 1105 	mla	r1, r3, r5, r1
    73dc:	2901      	cmp	r1, #1
    73de:	d102      	bne.n	73e6 <lwip_standard_chksum+0x3a>
		((u8_t *)&t)[0] = *(u8_t *)ps;
    73e0:	7803      	ldrb	r3, [r0, #0]
    73e2:	f88d 3006 	strb.w	r3, [sp, #6]
	}

	/* Add end bytes */
	sum += t;
    73e6:	f8bd 3006 	ldrh.w	r3, [sp, #6]
    73ea:	4413      	add	r3, r2

	/* Fold 32-bit sum to 16 bits
	   calling this twice is propably faster than if statements... */
	sum = FOLD_U32T(sum);
    73ec:	b298      	uxth	r0, r3
    73ee:	eb00 4313 	add.w	r3, r0, r3, lsr #16
	sum = FOLD_U32T(sum);
    73f2:	b298      	uxth	r0, r3
    73f4:	eb00 4013 	add.w	r0, r0, r3, lsr #16

	/* Swap if alignment was odd */
	if (odd) {
    73f8:	b124      	cbz	r4, 7404 <lwip_standard_chksum+0x58>
		sum = SWAP_BYTES_IN_WORD(sum);
    73fa:	0203      	lsls	r3, r0, #8
    73fc:	b29b      	uxth	r3, r3
    73fe:	f3c0 2007 	ubfx	r0, r0, #8, #8
    7402:	4318      	orrs	r0, r3
	}

	return (u16_t)sum;
}
    7404:	b280      	uxth	r0, r0
    7406:	b002      	add	sp, #8
    7408:	bd70      	pop	{r4, r5, r6, pc}
		sum += *ps++;
    740a:	f830 6b02 	ldrh.w	r6, [r0], #2
    740e:	4432      	add	r2, r6
		len -= 2;
    7410:	e7de      	b.n	73d0 <lwip_standard_chksum+0x24>
	u32_t  sum = 0;
    7412:	460a      	mov	r2, r1
    7414:	e7e7      	b.n	73e6 <lwip_standard_chksum+0x3a>
	...

00007418 <inet_chksum_pseudo>:
 * @param proto ip protocol (used for checksum of pseudo header)
 * @param proto_len length of the ip data part (used for checksum of pseudo header)
 * @return checksum (as u16_t) to be saved directly in the protocol header
 */
u16_t inet_chksum_pseudo(struct pbuf *p, ip_addr_t *src, ip_addr_t *dest, u8_t proto, u16_t proto_len)
{
    7418:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	u32_t        addr;
	struct pbuf *q;
	u8_t         swapped;

	acc     = 0;
	swapped = 0;
    741c:	2600      	movs	r6, #0
	/* iterate through all pbuf in chain */
	for (q = p; q != NULL; q = q->next) {
		LWIP_DEBUGF(INET_DEBUG,
		            ("inet_chksum_pseudo(): checksumming pbuf %p (has next %p) \n", (void *)q, (void *)q->next));
		acc += LWIP_CHKSUM(q->payload, q->len);
    741e:	f8df a084 	ldr.w	sl, [pc, #132]	; 74a4 <inet_chksum_pseudo+0x8c>
{
    7422:	4605      	mov	r5, r0
    7424:	4689      	mov	r9, r1
    7426:	4690      	mov	r8, r2
    7428:	461f      	mov	r7, r3
	acc     = 0;
    742a:	4634      	mov	r4, r6
	for (q = p; q != NULL; q = q->next) {
    742c:	bb1d      	cbnz	r5, 7476 <inet_chksum_pseudo+0x5e>
			acc     = SWAP_BYTES_IN_WORD(acc);
		}
		/*LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): wrapped lwip_chksum()=%"X32_F" \n", acc));*/
	}

	if (swapped) {
    742e:	b126      	cbz	r6, 743a <inet_chksum_pseudo+0x22>
		acc = SWAP_BYTES_IN_WORD(acc);
    7430:	0223      	lsls	r3, r4, #8
    7432:	b29b      	uxth	r3, r3
    7434:	f3c4 2407 	ubfx	r4, r4, #8, #8
    7438:	431c      	orrs	r4, r3
	}
	addr = ip4_addr_get_u32(src);
	acc += (addr & 0xffffUL);
	acc += ((addr >> 16) & 0xffffUL);
	addr = ip4_addr_get_u32(dest);
    743a:	f8d8 2000 	ldr.w	r2, [r8]
	addr = ip4_addr_get_u32(src);
    743e:	f8d9 3000 	ldr.w	r3, [r9]
	acc += (addr & 0xffffUL);
	acc += ((addr >> 16) & 0xffffUL);
	acc += (u32_t)htons((u16_t)proto);
    7442:	4d17      	ldr	r5, [pc, #92]	; (74a0 <inet_chksum_pseudo+0x88>)
	acc += ((addr >> 16) & 0xffffUL);
    7444:	0c11      	lsrs	r1, r2, #16
    7446:	fa11 f282 	uxtah	r2, r1, r2
    744a:	fa12 f283 	uxtah	r2, r2, r3
    744e:	eb02 4213 	add.w	r2, r2, r3, lsr #16
	acc += (u32_t)htons((u16_t)proto);
    7452:	4638      	mov	r0, r7
	acc += ((addr >> 16) & 0xffffUL);
    7454:	4414      	add	r4, r2
	acc += (u32_t)htons((u16_t)proto);
    7456:	47a8      	blx	r5
    7458:	4404      	add	r4, r0
	acc += (u32_t)htons(proto_len);
    745a:	f8bd 0020 	ldrh.w	r0, [sp, #32]
    745e:	47a8      	blx	r5
    7460:	4420      	add	r0, r4

	/* Fold 32-bit sum to 16 bits
	   calling this twice is propably faster than if statements... */
	acc = FOLD_U32T(acc);
    7462:	b284      	uxth	r4, r0
    7464:	eb04 4410 	add.w	r4, r4, r0, lsr #16
	acc = FOLD_U32T(acc);
    7468:	b2a0      	uxth	r0, r4
    746a:	eb00 4014 	add.w	r0, r0, r4, lsr #16
	LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): pbuf chain lwip_chksum()=%" X32_F "\n", acc));
	return (u16_t) ~(acc & 0xffffUL);
    746e:	43c0      	mvns	r0, r0
}
    7470:	b280      	uxth	r0, r0
    7472:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
		acc += LWIP_CHKSUM(q->payload, q->len);
    7476:	8969      	ldrh	r1, [r5, #10]
    7478:	6868      	ldr	r0, [r5, #4]
    747a:	47d0      	blx	sl
    747c:	4404      	add	r4, r0
		acc = FOLD_U32T(acc);
    747e:	b2a3      	uxth	r3, r4
    7480:	eb03 4414 	add.w	r4, r3, r4, lsr #16
		if (q->len % 2 != 0) {
    7484:	896b      	ldrh	r3, [r5, #10]
    7486:	07db      	lsls	r3, r3, #31
    7488:	d507      	bpl.n	749a <inet_chksum_pseudo+0x82>
			acc     = SWAP_BYTES_IN_WORD(acc);
    748a:	0223      	lsls	r3, r4, #8
			swapped = 1 - swapped;
    748c:	f1c6 0601 	rsb	r6, r6, #1
			acc     = SWAP_BYTES_IN_WORD(acc);
    7490:	b29b      	uxth	r3, r3
    7492:	f3c4 2407 	ubfx	r4, r4, #8, #8
			swapped = 1 - swapped;
    7496:	b2f6      	uxtb	r6, r6
			acc     = SWAP_BYTES_IN_WORD(acc);
    7498:	431c      	orrs	r4, r3
	for (q = p; q != NULL; q = q->next) {
    749a:	682d      	ldr	r5, [r5, #0]
    749c:	e7c6      	b.n	742c <inet_chksum_pseudo+0x14>
    749e:	bf00      	nop
    74a0:	00000d65 	.word	0x00000d65
    74a4:	000073ad 	.word	0x000073ad

000074a8 <inet_chksum>:
 * @param len length of the buffer to calculate the checksum
 * @return checksum (as u16_t) to be saved directly in the protocol header
 */

u16_t inet_chksum(void *dataptr, u16_t len)
{
    74a8:	b508      	push	{r3, lr}
	return ~LWIP_CHKSUM(dataptr, len);
    74aa:	4b02      	ldr	r3, [pc, #8]	; (74b4 <inet_chksum+0xc>)
    74ac:	4798      	blx	r3
    74ae:	43c0      	mvns	r0, r0
}
    74b0:	b280      	uxth	r0, r0
    74b2:	bd08      	pop	{r3, pc}
    74b4:	000073ad 	.word	0x000073ad

000074b8 <inet_chksum_pbuf>:
 *
 * @param p pbuf chain over that the checksum should be calculated
 * @return checksum (as u16_t) to be saved directly in the protocol header
 */
u16_t inet_chksum_pbuf(struct pbuf *p)
{
    74b8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	u32_t        acc;
	struct pbuf *q;
	u8_t         swapped;

	acc     = 0;
	swapped = 0;
    74ba:	2500      	movs	r5, #0
	for (q = p; q != NULL; q = q->next) {
		acc += LWIP_CHKSUM(q->payload, q->len);
    74bc:	4f10      	ldr	r7, [pc, #64]	; (7500 <inet_chksum_pbuf+0x48>)
{
    74be:	4606      	mov	r6, r0
	acc     = 0;
    74c0:	462c      	mov	r4, r5
	for (q = p; q != NULL; q = q->next) {
    74c2:	b946      	cbnz	r6, 74d6 <inet_chksum_pbuf+0x1e>
			swapped = 1 - swapped;
			acc     = SWAP_BYTES_IN_WORD(acc);
		}
	}

	if (swapped) {
    74c4:	b125      	cbz	r5, 74d0 <inet_chksum_pbuf+0x18>
		acc = SWAP_BYTES_IN_WORD(acc);
    74c6:	0223      	lsls	r3, r4, #8
    74c8:	b29b      	uxth	r3, r3
    74ca:	f3c4 2407 	ubfx	r4, r4, #8, #8
    74ce:	431c      	orrs	r4, r3
	}
	return (u16_t) ~(acc & 0xffffUL);
    74d0:	43e0      	mvns	r0, r4
}
    74d2:	b280      	uxth	r0, r0
    74d4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		acc += LWIP_CHKSUM(q->payload, q->len);
    74d6:	8971      	ldrh	r1, [r6, #10]
    74d8:	6870      	ldr	r0, [r6, #4]
    74da:	47b8      	blx	r7
		if (q->len % 2 != 0) {
    74dc:	8973      	ldrh	r3, [r6, #10]
		acc += LWIP_CHKSUM(q->payload, q->len);
    74de:	4404      	add	r4, r0
		acc = FOLD_U32T(acc);
    74e0:	b2a0      	uxth	r0, r4
		if (q->len % 2 != 0) {
    74e2:	07db      	lsls	r3, r3, #31
		acc = FOLD_U32T(acc);
    74e4:	eb00 4414 	add.w	r4, r0, r4, lsr #16
		if (q->len % 2 != 0) {
    74e8:	d507      	bpl.n	74fa <inet_chksum_pbuf+0x42>
			acc     = SWAP_BYTES_IN_WORD(acc);
    74ea:	0223      	lsls	r3, r4, #8
			swapped = 1 - swapped;
    74ec:	f1c5 0501 	rsb	r5, r5, #1
			acc     = SWAP_BYTES_IN_WORD(acc);
    74f0:	b29b      	uxth	r3, r3
    74f2:	f3c4 2407 	ubfx	r4, r4, #8, #8
			swapped = 1 - swapped;
    74f6:	b2ed      	uxtb	r5, r5
			acc     = SWAP_BYTES_IN_WORD(acc);
    74f8:	431c      	orrs	r4, r3
	for (q = p; q != NULL; q = q->next) {
    74fa:	6836      	ldr	r6, [r6, #0]
    74fc:	e7e1      	b.n	74c2 <inet_chksum_pbuf+0xa>
    74fe:	bf00      	nop
    7500:	000073ad 	.word	0x000073ad

00007504 <socket_basic_ethernet>:
	/* Start FreeRTOS scheduler */
	vTaskStartScheduler();
}

void socket_basic_ethernet(void *p)
{
    7504:	b5f0      	push	{r4, r5, r6, r7, lr}
    7506:	b08b      	sub	sp, #44	; 0x2c

	struct sockaddr_in address;
	int                s_create, new_socket;
	int                addrlen = sizeof(address);
	int                opt     = 1;
    7508:	2510      	movs	r5, #16
    750a:	2601      	movs	r6, #1
	int                socket_check;

	sys_sem_t sem;
	err_t     err_sem;
	err_sem = sys_sem_new(&sem, 0); /* Create a new semaphore. */
    750c:	4b2e      	ldr	r3, [pc, #184]	; (75c8 <socket_basic_ethernet+0xc4>)
	print_ipaddress();

	/*Create a socket*/
	s_create = socket(AF_INET, 1, 0);

	setsockopt(s_create, SOL_SOCKET, SO_REUSEADDR | SO_REUSEPORT, &opt, sizeof(opt));
    750e:	4f2f      	ldr	r7, [pc, #188]	; (75cc <socket_basic_ethernet+0xc8>)
	err_sem = sys_sem_new(&sem, 0); /* Create a new semaphore. */
    7510:	2100      	movs	r1, #0
    7512:	a805      	add	r0, sp, #20
	int                opt     = 1;
    7514:	e9cd 5603 	strd	r5, r6, [sp, #12]
	err_sem = sys_sem_new(&sem, 0); /* Create a new semaphore. */
    7518:	4798      	blx	r3
	tcpip_init(tcpip_init_done, &sem);
    751a:	482d      	ldr	r0, [pc, #180]	; (75d0 <socket_basic_ethernet+0xcc>)
    751c:	4b2d      	ldr	r3, [pc, #180]	; (75d4 <socket_basic_ethernet+0xd0>)
    751e:	a905      	add	r1, sp, #20
    7520:	4798      	blx	r3
	sys_sem_wait(&sem); /* Block until the lwIP stack is initialized. */
    7522:	2100      	movs	r1, #0
    7524:	4b2c      	ldr	r3, [pc, #176]	; (75d8 <socket_basic_ethernet+0xd4>)
    7526:	a805      	add	r0, sp, #20
    7528:	4798      	blx	r3
	sys_sem_free(&sem); /* Free the semaphore. */
    752a:	a805      	add	r0, sp, #20
    752c:	4b2b      	ldr	r3, [pc, #172]	; (75dc <socket_basic_ethernet+0xd8>)
    752e:	4798      	blx	r3
	print_ipaddress();
    7530:	4b2b      	ldr	r3, [pc, #172]	; (75e0 <socket_basic_ethernet+0xdc>)
    7532:	4798      	blx	r3
	s_create = socket(AF_INET, 1, 0);
    7534:	4631      	mov	r1, r6
    7536:	4b2b      	ldr	r3, [pc, #172]	; (75e4 <socket_basic_ethernet+0xe0>)
    7538:	2200      	movs	r2, #0
    753a:	2002      	movs	r0, #2
    753c:	4798      	blx	r3
	setsockopt(s_create, SOL_SOCKET, SO_REUSEADDR | SO_REUSEPORT, &opt, sizeof(opt));
    753e:	2304      	movs	r3, #4
    7540:	f44f 7201 	mov.w	r2, #516	; 0x204
    7544:	f640 71ff 	movw	r1, #4095	; 0xfff
    7548:	9300      	str	r3, [sp, #0]
    754a:	eb0d 0305 	add.w	r3, sp, r5
	s_create = socket(AF_INET, 1, 0);
    754e:	4606      	mov	r6, r0
	setsockopt(s_create, SOL_SOCKET, SO_REUSEADDR | SO_REUSEPORT, &opt, sizeof(opt));
    7550:	47b8      	blx	r7

	address.sin_family      = AF_INET;
    7552:	2302      	movs	r3, #2
    7554:	f88d 3019 	strb.w	r3, [sp, #25]
	address.sin_addr.s_addr = htonl(IPADDR_ANY);
    7558:	2000      	movs	r0, #0
    755a:	4b23      	ldr	r3, [pc, #140]	; (75e8 <socket_basic_ethernet+0xe4>)
    755c:	4798      	blx	r3
	address.sin_port        = htons(HTTP_PORT);
    755e:	4b23      	ldr	r3, [pc, #140]	; (75ec <socket_basic_ethernet+0xe8>)
	address.sin_addr.s_addr = htonl(IPADDR_ANY);
    7560:	9007      	str	r0, [sp, #28]
	address.sin_port        = htons(HTTP_PORT);
    7562:	2050      	movs	r0, #80	; 0x50
    7564:	4798      	blx	r3
	/* bind the connection to port */
	socket_check = bind(s_create, (struct sockaddr *)&address, sizeof(address));
    7566:	4b22      	ldr	r3, [pc, #136]	; (75f0 <socket_basic_ethernet+0xec>)
	address.sin_port        = htons(HTTP_PORT);
    7568:	f8ad 001a 	strh.w	r0, [sp, #26]
	socket_check = bind(s_create, (struct sockaddr *)&address, sizeof(address));
    756c:	462a      	mov	r2, r5
    756e:	a906      	add	r1, sp, #24
    7570:	4630      	mov	r0, r6
    7572:	4798      	blx	r3
	if (socket_check < 0) {
    7574:	2800      	cmp	r0, #0
    7576:	db22      	blt.n	75be <socket_basic_ethernet+0xba>
		LWIP_DEBUGF(LWIP_DBG_ON, ("Bind error=%d\n", socket_check));
		goto socket_close;
	}
	/* tell the connection to listen for incoming connection requests */
	listen(s_create, 3);
    7578:	4b1e      	ldr	r3, [pc, #120]	; (75f4 <socket_basic_ethernet+0xf0>)
    757a:	2103      	movs	r1, #3
    757c:	4630      	mov	r0, r6
    757e:	4798      	blx	r3

	for (;;) {
		new_socket = accept(s_create, (struct sockaddr *)&address, (socklen_t *)&addrlen);
    7580:	4b1d      	ldr	r3, [pc, #116]	; (75f8 <socket_basic_ethernet+0xf4>)
    7582:	aa03      	add	r2, sp, #12
    7584:	a906      	add	r1, sp, #24
    7586:	4630      	mov	r0, r6
    7588:	4798      	blx	r3

		if (new_socket <= 0) {
    758a:	1e04      	subs	r4, r0, #0
    758c:	dd17      	ble.n	75be <socket_basic_ethernet+0xba>
			LWIP_DEBUGF(LWIP_DBG_ON, ("Connection error=%d\n", new_socket));
			goto socket_close;
		}
		socket_check = read(new_socket, buffer, 1024);
    758e:	491b      	ldr	r1, [pc, #108]	; (75fc <socket_basic_ethernet+0xf8>)
    7590:	4b1b      	ldr	r3, [pc, #108]	; (7600 <socket_basic_ethernet+0xfc>)
    7592:	f44f 6280 	mov.w	r2, #1024	; 0x400
    7596:	4798      	blx	r3
		if (socket_check <= 0) {
    7598:	2800      	cmp	r0, #0
    759a:	dd10      	ble.n	75be <socket_basic_ethernet+0xba>
			LWIP_DEBUGF(LWIP_DBG_ON, ("Read error=%d\n", socket_check));
			goto socket_close;
		}
		/* Check if the request was an HTTP "GET /\r\n". */
		if (!strncmp(buffer, "GET", 3)) {
    759c:	4919      	ldr	r1, [pc, #100]	; (7604 <socket_basic_ethernet+0x100>)
    759e:	4817      	ldr	r0, [pc, #92]	; (75fc <socket_basic_ethernet+0xf8>)
    75a0:	4b19      	ldr	r3, [pc, #100]	; (7608 <socket_basic_ethernet+0x104>)
    75a2:	2203      	movs	r2, #3
    75a4:	4798      	blx	r3
    75a6:	b950      	cbnz	r0, 75be <socket_basic_ethernet+0xba>
			socket_check = write(new_socket, http_html_hdr, strlen(http_html_hdr));
    75a8:	4918      	ldr	r1, [pc, #96]	; (760c <socket_basic_ethernet+0x108>)
    75aa:	4d19      	ldr	r5, [pc, #100]	; (7610 <socket_basic_ethernet+0x10c>)
    75ac:	222c      	movs	r2, #44	; 0x2c
    75ae:	4620      	mov	r0, r4
    75b0:	47a8      	blx	r5
			if (socket_check <= 0) {
    75b2:	2800      	cmp	r0, #0
    75b4:	dd03      	ble.n	75be <socket_basic_ethernet+0xba>
				LWIP_DEBUGF(LWIP_DBG_ON, ("Write error=%d\n", socket_check));
				goto socket_close;
			}

			/*Send the actual webpage*/
			socket_check = write(new_socket, socket_webpage, strlen(socket_webpage));
    75b6:	4917      	ldr	r1, [pc, #92]	; (7614 <socket_basic_ethernet+0x110>)
    75b8:	2277      	movs	r2, #119	; 0x77
    75ba:	4620      	mov	r0, r4
    75bc:	47a8      	blx	r5
				goto socket_close;
			}
		}
	/*Close connection*/
	socket_close:
		close(new_socket);
    75be:	4b16      	ldr	r3, [pc, #88]	; (7618 <socket_basic_ethernet+0x114>)
    75c0:	4620      	mov	r0, r4
    75c2:	4798      	blx	r3
		new_socket = accept(s_create, (struct sockaddr *)&address, (socklen_t *)&addrlen);
    75c4:	e7dc      	b.n	7580 <socket_basic_ethernet+0x7c>
    75c6:	bf00      	nop
    75c8:	00006a3d 	.word	0x00006a3d
    75cc:	00008d75 	.word	0x00008d75
    75d0:	00006e89 	.word	0x00006e89
    75d4:	000093f5 	.word	0x000093f5
    75d8:	00006acd 	.word	0x00006acd
    75dc:	00006a9d 	.word	0x00006a9d
    75e0:	00004a5d 	.word	0x00004a5d
    75e4:	00008ce5 	.word	0x00008ce5
    75e8:	00000d71 	.word	0x00000d71
    75ec:	00000d65 	.word	0x00000d65
    75f0:	000088ad 	.word	0x000088ad
    75f4:	00008969 	.word	0x00008969
    75f8:	0000879d 	.word	0x0000879d
    75fc:	20014990 	.word	0x20014990
    7600:	00008b8d 	.word	0x00008b8d
    7604:	0000a9be 	.word	0x0000a9be
    7608:	00009789 	.word	0x00009789
    760c:	0000a9d1 	.word	0x0000a9d1
    7610:	00008d61 	.word	0x00008d61
    7614:	0000a9fe 	.word	0x0000a9fe
    7618:	0000890d 	.word	0x0000890d

0000761c <basic_socket>:
{
    761c:	b51f      	push	{r0, r1, r2, r3, r4, lr}
	task_led_create();
    761e:	4b0b      	ldr	r3, [pc, #44]	; (764c <basic_socket+0x30>)
	if (xTaskCreate(socket_basic_ethernet,
    7620:	4c0b      	ldr	r4, [pc, #44]	; (7650 <basic_socket+0x34>)
	task_led_create();
    7622:	4798      	blx	r3
	if (xTaskCreate(socket_basic_ethernet,
    7624:	4a0b      	ldr	r2, [pc, #44]	; (7654 <basic_socket+0x38>)
    7626:	9201      	str	r2, [sp, #4]
    7628:	2300      	movs	r3, #0
    762a:	2201      	movs	r2, #1
    762c:	9200      	str	r2, [sp, #0]
    762e:	e9cd 3302 	strd	r3, r3, [sp, #8]
    7632:	4909      	ldr	r1, [pc, #36]	; (7658 <basic_socket+0x3c>)
    7634:	4809      	ldr	r0, [pc, #36]	; (765c <basic_socket+0x40>)
    7636:	f44f 7280 	mov.w	r2, #256	; 0x100
    763a:	47a0      	blx	r4
    763c:	2801      	cmp	r0, #1
    763e:	d000      	beq.n	7642 <basic_socket+0x26>
		while (1)
    7640:	e7fe      	b.n	7640 <basic_socket+0x24>
	vTaskStartScheduler();
    7642:	4b07      	ldr	r3, [pc, #28]	; (7660 <basic_socket+0x44>)
}
    7644:	b004      	add	sp, #16
    7646:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	vTaskStartScheduler();
    764a:	4718      	bx	r3
    764c:	00006f81 	.word	0x00006f81
    7650:	00007ce5 	.word	0x00007ce5
    7654:	20014d90 	.word	0x20014d90
    7658:	0000a9c2 	.word	0x0000a9c2
    765c:	00007505 	.word	0x00007505
    7660:	00007ea5 	.word	0x00007ea5

00007664 <GMAC_Handler>:

/*
 * \internal GMAC interrupt handler
 */
void GMAC_Handler(void)
{
    7664:	b513      	push	{r0, r1, r4, lr}
	volatile uint32_t tsr;
	volatile uint32_t rsr;

	tsr = hri_gmac_read_TSR_reg(_gmac_dev->hw);
    7666:	4c11      	ldr	r4, [pc, #68]	; (76ac <GMAC_Handler+0x48>)
    7668:	6820      	ldr	r0, [r4, #0]
    766a:	6803      	ldr	r3, [r0, #0]
	GMAC_CRITICAL_SECTION_LEAVE();
}

static inline hri_gmac_tsr_reg_t hri_gmac_read_TSR_reg(const void *const hw)
{
	return ((Gmac *)hw)->TSR.reg;
    766c:	695a      	ldr	r2, [r3, #20]
    766e:	9200      	str	r2, [sp, #0]
	GMAC_CRITICAL_SECTION_LEAVE();
}

static inline hri_gmac_rsr_reg_t hri_gmac_read_RSR_reg(const void *const hw)
{
	return ((Gmac *)hw)->RSR.reg;
    7670:	6a1a      	ldr	r2, [r3, #32]
	rsr = hri_gmac_read_RSR_reg(_gmac_dev->hw);
    7672:	9201      	str	r2, [sp, #4]
	GMAC_CRITICAL_SECTION_LEAVE();
}

static inline hri_gmac_isr_reg_t hri_gmac_read_ISR_reg(const void *const hw)
{
	return ((Gmac *)hw)->ISR.reg;
    7674:	6a5a      	ldr	r2, [r3, #36]	; 0x24
	/* Must be Clear ISR (Clear on read) */
	hri_gmac_read_ISR_reg(_gmac_dev->hw);

	/* Frame transmited */
	if (tsr & GMAC_TSR_TXCOMP) {
    7676:	9a00      	ldr	r2, [sp, #0]
    7678:	0692      	lsls	r2, r2, #26
    767a:	d50a      	bpl.n	7692 <GMAC_Handler+0x2e>
		hri_gmac_write_TSR_reg(_gmac_dev->hw, tsr);
    767c:	9a00      	ldr	r2, [sp, #0]
	((Gmac *)hw)->TSR.reg = data;
    767e:	615a      	str	r2, [r3, #20]
		if ((_txbuf_descrs[_txbuf_index].status.bm.used) && (_gmac_dev->cb.transmited != NULL)) {
    7680:	6863      	ldr	r3, [r4, #4]
    7682:	eb04 03c3 	add.w	r3, r4, r3, lsl #3
    7686:	7bdb      	ldrb	r3, [r3, #15]
    7688:	09db      	lsrs	r3, r3, #7
    768a:	d002      	beq.n	7692 <GMAC_Handler+0x2e>
    768c:	6843      	ldr	r3, [r0, #4]
    768e:	b103      	cbz	r3, 7692 <GMAC_Handler+0x2e>
			_gmac_dev->cb.transmited(_gmac_dev);
    7690:	4798      	blx	r3
		}
	}

	/* Frame received */
	if (rsr & GMAC_RSR_REC) {
    7692:	9b01      	ldr	r3, [sp, #4]
    7694:	079b      	lsls	r3, r3, #30
    7696:	d503      	bpl.n	76a0 <GMAC_Handler+0x3c>
		if (_gmac_dev->cb.received != NULL) {
    7698:	6820      	ldr	r0, [r4, #0]
    769a:	6883      	ldr	r3, [r0, #8]
    769c:	b103      	cbz	r3, 76a0 <GMAC_Handler+0x3c>
			_gmac_dev->cb.received(_gmac_dev);
    769e:	4798      	blx	r3
		}
	}
	hri_gmac_write_RSR_reg(_gmac_dev->hw, rsr);
    76a0:	6823      	ldr	r3, [r4, #0]
    76a2:	9a01      	ldr	r2, [sp, #4]
    76a4:	681b      	ldr	r3, [r3, #0]
	((Gmac *)hw)->RSR.reg = data;
    76a6:	621a      	str	r2, [r3, #32]
}
    76a8:	b002      	add	sp, #8
    76aa:	bd10      	pop	{r4, pc}
    76ac:	20014da0 	.word	0x20014da0

000076b0 <_mac_async_init>:
	((Gmac *)hw)->NCR.reg = data;
    76b0:	2310      	movs	r3, #16

int32_t _mac_async_init(struct _mac_async_device *const dev, void *const hw)
{
    76b2:	b5f0      	push	{r4, r5, r6, r7, lr}
	dev->hw = hw;
    76b4:	6001      	str	r1, [r0, #0]
    76b6:	600b      	str	r3, [r1, #0]
	((Gmac *)hw)->NCFGR.reg = data;
    76b8:	4b22      	ldr	r3, [pc, #136]	; (7744 <_mac_async_init+0x94>)
    76ba:	604b      	str	r3, [r1, #4]
	((Gmac *)hw)->UR.reg = data;
    76bc:	2200      	movs	r2, #0
	((Gmac *)hw)->DCFGR.reg = data;
    76be:	4b22      	ldr	r3, [pc, #136]	; (7748 <_mac_async_init+0x98>)
	((Gmac *)hw)->UR.reg = data;
    76c0:	60ca      	str	r2, [r1, #12]
	((Gmac *)hw)->DCFGR.reg = data;
    76c2:	610b      	str	r3, [r1, #16]
}

static inline void hri_gmac_write_IPGS_reg(const void *const hw, hri_gmac_ipgs_reg_t data)
{
	GMAC_CRITICAL_SECTION_ENTER();
	((Gmac *)hw)->IPGS.reg = data;
    76c4:	f240 1301 	movw	r3, #257	; 0x101
	((Gmac *)hw)->WOL.reg = data;
    76c8:	f8c1 20b8 	str.w	r2, [r1, #184]	; 0xb8
	((Gmac *)hw)->IPGS.reg = data;
    76cc:	f8c1 30bc 	str.w	r3, [r1, #188]	; 0xbc
		_txbuf_descrs[i].address        = (uint32_t)_txbuf[i];
    76d0:	4b1e      	ldr	r3, [pc, #120]	; (774c <_mac_async_init+0x9c>)
    76d2:	4e1f      	ldr	r6, [pc, #124]	; (7750 <_mac_async_init+0xa0>)
	_txbuf_index                                            = 0;
    76d4:	605a      	str	r2, [r3, #4]
		_txbuf_descrs[i].address        = (uint32_t)_txbuf[i];
    76d6:	f103 0420 	add.w	r4, r3, #32
    76da:	609c      	str	r4, [r3, #8]
		_txbuf_descrs[i].status.val     = 0;
    76dc:	f04f 4400 	mov.w	r4, #2147483648	; 0x80000000
    76e0:	60dc      	str	r4, [r3, #12]
		_txbuf_descrs[i].address        = (uint32_t)_txbuf[i];
    76e2:	f203 54fc 	addw	r4, r3, #1532	; 0x5fc
    76e6:	611c      	str	r4, [r3, #16]
		_txbuf_descrs[i].status.val     = 0;
    76e8:	f04f 4440 	mov.w	r4, #3221225472	; 0xc0000000
    76ec:	615c      	str	r4, [r3, #20]
	_last_txbuf_index                                       = 0;
    76ee:	f8c3 2bd8 	str.w	r2, [r3, #3032]	; 0xbd8
	for (i = 0; i < CONF_GMAC_RXDESCR_NUM; i++) {
    76f2:	f503 653e 	add.w	r5, r3, #3040	; 0xbe0
	_last_txbuf_index                                       = 0;
    76f6:	4634      	mov	r4, r6
		_rxbuf_descrs[i].status.val  = 0;
    76f8:	4617      	mov	r7, r2
	for (i = 0; i < CONF_GMAC_RXDESCR_NUM; i++) {
    76fa:	3201      	adds	r2, #1
    76fc:	2a10      	cmp	r2, #16
		_rxbuf_descrs[i].status.val  = 0;
    76fe:	e9c4 5700 	strd	r5, r7, [r4]
	for (i = 0; i < CONF_GMAC_RXDESCR_NUM; i++) {
    7702:	f105 0580 	add.w	r5, r5, #128	; 0x80
    7706:	f104 0408 	add.w	r4, r4, #8
    770a:	d1f6      	bne.n	76fa <_mac_async_init+0x4a>
	_rxbuf_descrs[CONF_GMAC_RXDESCR_NUM - 1].address.bm.wrap = 1;
    770c:	4a11      	ldr	r2, [pc, #68]	; (7754 <_mac_async_init+0xa4>)
	        | GMAC_DCFGR_DRBS(CONF_GMAC_DCFGR_DRBS) | (CONF_GMAC_DCFGR_DDRP ? GMAC_DCFGR_DDRP : 0));
	hri_gmac_write_WOL_reg(dev->hw, 0);
	hri_gmac_write_IPGS_reg(dev->hw, GMAC_IPGS_FL((CONF_GMAC_IPGS_FL_MUL << 8) | CONF_GMAC_IPGS_FL_DIV));
	_mac_init_bufdescr(dev);

	_gmac_dev = dev;
    770e:	6018      	str	r0, [r3, #0]
	_rxbuf_descrs[CONF_GMAC_RXDESCR_NUM - 1].address.bm.wrap = 1;
    7710:	f892 4360 	ldrb.w	r4, [r2, #864]	; 0x360
	_rxbuf_index                                             = 0;
    7714:	f8c2 7368 	str.w	r7, [r2, #872]	; 0x368
	_rxbuf_descrs[CONF_GMAC_RXDESCR_NUM - 1].address.bm.wrap = 1;
    7718:	f044 0402 	orr.w	r4, r4, #2
    771c:	f882 4360 	strb.w	r4, [r2, #864]	; 0x360
    NVIC->ICER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
    7720:	4b0d      	ldr	r3, [pc, #52]	; (7758 <_mac_async_init+0xa8>)
	hri_gmac_write_TBQB_reg(dev->hw, (uint32_t)_txbuf_descrs);
    7722:	4a0e      	ldr	r2, [pc, #56]	; (775c <_mac_async_init+0xac>)
	((Gmac *)hw)->TBQB.reg = data;
    7724:	61ca      	str	r2, [r1, #28]
    7726:	f44f 1280 	mov.w	r2, #1048576	; 0x100000
	((Gmac *)hw)->RBQB.reg = data;
    772a:	618e      	str	r6, [r1, #24]
    772c:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88
  __ASM volatile ("dsb 0xF":::"memory");
    7730:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
    7734:	f3bf 8f6f 	isb	sy
	NVIC_DisableIRQ(GMAC_IRQn);
	NVIC_ClearPendingIRQ(GMAC_IRQn);
	NVIC_EnableIRQ(GMAC_IRQn);

	return ERR_NONE;
}
    7738:	2000      	movs	r0, #0
    NVIC->ICPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
    773a:	f8c3 2188 	str.w	r2, [r3, #392]	; 0x188
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
    773e:	609a      	str	r2, [r3, #8]
    7740:	bdf0      	pop	{r4, r5, r6, r7, pc}
    7742:	bf00      	nop
    7744:	00100103 	.word	0x00100103
    7748:	00020704 	.word	0x00020704
    774c:	20014da0 	.word	0x20014da0
    7750:	20016180 	.word	0x20016180
    7754:	20015e98 	.word	0x20015e98
    7758:	e000e100 	.word	0xe000e100
    775c:	20014da8 	.word	0x20014da8

00007760 <_mac_async_enable>:
	return ERR_NONE;
}

int32_t _mac_async_enable(struct _mac_async_device *const dev)
{
	hri_gmac_set_NCR_reg(dev->hw, GMAC_NCR_RXEN | GMAC_NCR_TXEN);
    7760:	6802      	ldr	r2, [r0, #0]
	((Gmac *)hw)->NCR.reg |= mask;
    7762:	6813      	ldr	r3, [r2, #0]
    7764:	f043 030c 	orr.w	r3, r3, #12
    7768:	6013      	str	r3, [r2, #0]
	return ERR_NONE;
}
    776a:	2000      	movs	r0, #0
    776c:	4770      	bx	lr
	...

00007770 <_mac_async_write>:
	hri_gmac_clear_NCR_reg(dev->hw, GMAC_NCR_RXEN | GMAC_NCR_TXEN);
	return ERR_NONE;
}

int32_t _mac_async_write(struct _mac_async_device *const dev, uint8_t *buf, uint32_t len)
{
    7770:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
	uint32_t pos;
	uint32_t blen;
	uint32_t i;

	if (_txbuf_descrs[_last_txbuf_index].status.bm.used && !_txbuf_descrs[_last_txbuf_index].status.bm.last_buf) {
    7774:	4c3a      	ldr	r4, [pc, #232]	; (7860 <_mac_async_write+0xf0>)
    7776:	f8d4 3bd8 	ldr.w	r3, [r4, #3032]	; 0xbd8
    777a:	eb04 03c3 	add.w	r3, r4, r3, lsl #3
{
    777e:	4680      	mov	r8, r0
	if (_txbuf_descrs[_last_txbuf_index].status.bm.used && !_txbuf_descrs[_last_txbuf_index].status.bm.last_buf) {
    7780:	7bdb      	ldrb	r3, [r3, #15]
    7782:	09db      	lsrs	r3, r3, #7
{
    7784:	4616      	mov	r6, r2
	if (_txbuf_descrs[_last_txbuf_index].status.bm.used && !_txbuf_descrs[_last_txbuf_index].status.bm.last_buf) {
    7786:	d012      	beq.n	77ae <_mac_async_write+0x3e>
    7788:	f8d4 3bd8 	ldr.w	r3, [r4, #3032]	; 0xbd8
    778c:	eb04 03c3 	add.w	r3, r4, r3, lsl #3
    7790:	7b5b      	ldrb	r3, [r3, #13]
    7792:	09db      	lsrs	r3, r3, #7
    7794:	d10b      	bne.n	77ae <_mac_async_write+0x3e>
		/* Set used flag from first descriptor to last descriptor,
		 * as DMA olny set the first used flag */
		for (i = 1; i < CONF_GMAC_TXDESCR_NUM; i++) {
			pos = _last_txbuf_index + i;
    7796:	f8d4 2bd8 	ldr.w	r2, [r4, #3032]	; 0xbd8
    779a:	1c53      	adds	r3, r2, #1
			if (pos >= CONF_GMAC_TXDESCR_NUM) {
    779c:	2b01      	cmp	r3, #1
    779e:	d900      	bls.n	77a2 <_mac_async_write+0x32>
				pos -= CONF_GMAC_TXDESCR_NUM;
    77a0:	1e53      	subs	r3, r2, #1
			}
			_txbuf_descrs[pos].status.bm.used = 1;
    77a2:	eb04 03c3 	add.w	r3, r4, r3, lsl #3
    77a6:	7bda      	ldrb	r2, [r3, #15]
    77a8:	f042 0280 	orr.w	r2, r2, #128	; 0x80
    77ac:	73da      	strb	r2, [r3, #15]
				break;
			}
		}
	}

	if (!_txbuf_descrs[_txbuf_index].status.bm.used) {
    77ae:	6863      	ldr	r3, [r4, #4]
    77b0:	eb04 03c3 	add.w	r3, r4, r3, lsl #3
    77b4:	7bdb      	ldrb	r3, [r3, #15]
    77b6:	09db      	lsrs	r3, r3, #7
    77b8:	d04e      	beq.n	7858 <_mac_async_write+0xe8>
		return ERR_NO_RESOURCE;
	}

	/* Check if have enough buffers, the first buffer already checked */
	if (len > CONF_GMAC_TXBUF_SIZE) {
    77ba:	f240 53dc 	movw	r3, #1500	; 0x5dc
    77be:	429e      	cmp	r6, r3
    77c0:	d90a      	bls.n	77d8 <_mac_async_write+0x68>
		for (i = 1; i < CONF_GMAC_TXDESCR_NUM; i++) {
			pos = _txbuf_index + i;
    77c2:	6862      	ldr	r2, [r4, #4]
    77c4:	1c53      	adds	r3, r2, #1
			if (pos >= CONF_GMAC_TXDESCR_NUM) {
    77c6:	2b01      	cmp	r3, #1
				pos -= CONF_GMAC_TXDESCR_NUM;
    77c8:	bf88      	it	hi
    77ca:	f102 33ff 	addhi.w	r3, r2, #4294967295	; 0xffffffff
			}

			if (!_txbuf_descrs[pos].status.bm.used) {
    77ce:	eb04 03c3 	add.w	r3, r4, r3, lsl #3
    77d2:	7bdb      	ldrb	r3, [r3, #15]
    77d4:	09db      	lsrs	r3, r3, #7
    77d6:	d03f      	beq.n	7858 <_mac_async_write+0xe8>
			if ((len - (CONF_GMAC_TXBUF_SIZE * i)) < CONF_GMAC_TXBUF_SIZE) {
				break;
			}
		}
	}
	_last_txbuf_index = _txbuf_index;
    77d8:	6863      	ldr	r3, [r4, #4]
    77da:	f8c4 3bd8 	str.w	r3, [r4, #3032]	; 0xbd8

	/* Write data to transmit buffer */
	for (i = 0; i < CONF_GMAC_TXDESCR_NUM; i++) {
		blen = min(len, CONF_GMAC_TXBUF_SIZE);
		memcpy(_txbuf[_txbuf_index], buf + (i * CONF_GMAC_TXBUF_SIZE), blen);
    77de:	f8df b088 	ldr.w	fp, [pc, #136]	; 7868 <_mac_async_write+0xf8>
    77e2:	4b20      	ldr	r3, [pc, #128]	; (7864 <_mac_async_write+0xf4>)
    77e4:	460d      	mov	r5, r1
    77e6:	f601 3ab8 	addw	sl, r1, #3000	; 0xbb8
		blen = min(len, CONF_GMAC_TXBUF_SIZE);
    77ea:	f240 59dc 	movw	r9, #1500	; 0x5dc
    77ee:	454e      	cmp	r6, r9
		memcpy(_txbuf[_txbuf_index], buf + (i * CONF_GMAC_TXBUF_SIZE), blen);
    77f0:	6860      	ldr	r0, [r4, #4]
		blen = min(len, CONF_GMAC_TXBUF_SIZE);
    77f2:	4637      	mov	r7, r6
    77f4:	bf28      	it	cs
    77f6:	464f      	movcs	r7, r9
		memcpy(_txbuf[_txbuf_index], buf + (i * CONF_GMAC_TXBUF_SIZE), blen);
    77f8:	4629      	mov	r1, r5
    77fa:	463a      	mov	r2, r7
    77fc:	fb09 b000 	mla	r0, r9, r0, fp
    7800:	4798      	blx	r3
		len -= blen;

		if (len > 0) {
			/* Here the Used flag be set to zero */
			_txbuf_descrs[_txbuf_index].status.val = blen;
    7802:	6862      	ldr	r2, [r4, #4]
		if (len > 0) {
    7804:	4b17      	ldr	r3, [pc, #92]	; (7864 <_mac_async_write+0xf4>)
			_txbuf_descrs[_txbuf_index].status.val = blen;
    7806:	eb04 02c2 	add.w	r2, r4, r2, lsl #3
		if (len > 0) {
    780a:	1bf6      	subs	r6, r6, r7
			_txbuf_descrs[_txbuf_index].status.val = blen;
    780c:	60d7      	str	r7, [r2, #12]
		} else {
			_txbuf_descrs[_txbuf_index].status.val         = blen;
			_txbuf_descrs[_txbuf_index].status.bm.last_buf = 1;
    780e:	bf01      	itttt	eq
    7810:	6862      	ldreq	r2, [r4, #4]
    7812:	eb04 02c2 	addeq.w	r2, r4, r2, lsl #3
    7816:	7b51      	ldrbeq	r1, [r2, #13]
    7818:	f041 0180 	orreq.w	r1, r1, #128	; 0x80
    781c:	bf08      	it	eq
    781e:	7351      	strbeq	r1, [r2, #13]
		}
		_txbuf_index++;
    7820:	6862      	ldr	r2, [r4, #4]
    7822:	3201      	adds	r2, #1
    7824:	6062      	str	r2, [r4, #4]
		if (_txbuf_index == CONF_GMAC_TXDESCR_NUM) {
    7826:	6862      	ldr	r2, [r4, #4]
    7828:	2a02      	cmp	r2, #2
    782a:	d105      	bne.n	7838 <_mac_async_write+0xc8>
			_txbuf_index                                            = 0;
    782c:	2200      	movs	r2, #0
    782e:	6062      	str	r2, [r4, #4]
			_txbuf_descrs[CONF_GMAC_TXDESCR_NUM - 1].status.bm.wrap = 1;
    7830:	7de2      	ldrb	r2, [r4, #23]
    7832:	f042 0240 	orr.w	r2, r2, #64	; 0x40
    7836:	75e2      	strb	r2, [r4, #23]
		}
		if (len == 0) {
    7838:	b11e      	cbz	r6, 7842 <_mac_async_write+0xd2>
	for (i = 0; i < CONF_GMAC_TXDESCR_NUM; i++) {
    783a:	f205 55dc 	addw	r5, r5, #1500	; 0x5dc
    783e:	45aa      	cmp	sl, r5
    7840:	d1d5      	bne.n	77ee <_mac_async_write+0x7e>
  __ASM volatile ("dsb 0xF":::"memory");
    7842:	f3bf 8f4f 	dsb	sy

	/* Data synchronization barrier */
	__DSB();

	/* Active Transmit */
	hri_gmac_set_NCR_reg(dev->hw, GMAC_NCR_TSTART);
    7846:	f8d8 2000 	ldr.w	r2, [r8]
    784a:	6813      	ldr	r3, [r2, #0]
    784c:	f443 7300 	orr.w	r3, r3, #512	; 0x200
    7850:	6013      	str	r3, [r2, #0]

	return ERR_NONE;
    7852:	2000      	movs	r0, #0
}
    7854:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
		return ERR_NO_RESOURCE;
    7858:	f06f 001b 	mvn.w	r0, #27
    785c:	e7fa      	b.n	7854 <_mac_async_write+0xe4>
    785e:	bf00      	nop
    7860:	20014da0 	.word	0x20014da0
    7864:	000094a5 	.word	0x000094a5
    7868:	20014dc0 	.word	0x20014dc0

0000786c <_mac_async_read>:

uint32_t _mac_async_read(struct _mac_async_device *const dev, uint8_t *buf, uint32_t len)
{
    786c:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
	uint32_t eof       = 0xFFFFFFFF; /* End of Frame index */
	uint32_t total_len = 0;          /* Total length of received package */

	(void)dev;
	for (i = 0; i < CONF_GMAC_RXDESCR_NUM; i++) {
		pos = _rxbuf_index + i;
    7870:	4d35      	ldr	r5, [pc, #212]	; (7948 <_mac_async_read+0xdc>)
{
    7872:	460b      	mov	r3, r1
    7874:	4616      	mov	r6, r2
	uint32_t sof       = 0xFFFFFFFF; /* Start of Frame index */
    7876:	f04f 37ff 	mov.w	r7, #4294967295	; 0xffffffff
	for (i = 0; i < CONF_GMAC_RXDESCR_NUM; i++) {
    787a:	2400      	movs	r4, #0
		pos = _rxbuf_index + i;
    787c:	f8d5 2368 	ldr.w	r2, [r5, #872]	; 0x368
    7880:	4422      	add	r2, r4

		if (pos >= CONF_GMAC_RXDESCR_NUM) {
    7882:	2a0f      	cmp	r2, #15
			pos -= CONF_GMAC_RXDESCR_NUM;
    7884:	bf88      	it	hi
    7886:	3a10      	subhi	r2, #16
		}

		/* No more data for Ethernet package */
		if (!_rxbuf_descrs[pos].address.bm.ownership) {
    7888:	eb05 02c2 	add.w	r2, r5, r2, lsl #3
    788c:	f892 12e8 	ldrb.w	r1, [r2, #744]	; 0x2e8
    7890:	07c9      	lsls	r1, r1, #31
    7892:	d51f      	bpl.n	78d4 <_mac_async_read+0x68>
			break;
		}

		if (_rxbuf_descrs[pos].status.bm.sof) {
    7894:	f892 12ed 	ldrb.w	r1, [r2, #749]	; 0x2ed
    7898:	f011 0f40 	tst.w	r1, #64	; 0x40
    789c:	bf18      	it	ne
    789e:	4627      	movne	r7, r4
			sof = i;
		}

		if ((_rxbuf_descrs[pos].status.bm.eof) && (sof != 0xFFFFFFFF)) {
    78a0:	09c9      	lsrs	r1, r1, #7
    78a2:	f104 0801 	add.w	r8, r4, #1
    78a6:	d012      	beq.n	78ce <_mac_async_read+0x62>
    78a8:	1c78      	adds	r0, r7, #1
    78aa:	d010      	beq.n	78ce <_mac_async_read+0x62>
			/* eof now indicate the number of bufs the frame used */
			eof = i;
			n   = _rxbuf_descrs[pos].status.bm.len;
    78ac:	f8b2 22ec 	ldrh.w	r2, [r2, #748]	; 0x2ec
    78b0:	f3c2 020c 	ubfx	r2, r2, #0, #13
			len = min(n, len);
    78b4:	4296      	cmp	r6, r2
    78b6:	bf28      	it	cs
    78b8:	4616      	movcs	r6, r2
	uint32_t total_len = 0;          /* Total length of received package */
    78ba:	f04f 0900 	mov.w	r9, #0
	} else {
		j = i;
	}

	/* Copy data to user buffer */
	for (i = 0; i < j; i++) {
    78be:	46ca      	mov	sl, r9

		_rxbuf_descrs[_rxbuf_index].address.bm.ownership = 0;
		_rxbuf_index++;

		if (_rxbuf_index == CONF_GMAC_RXDESCR_NUM) {
			_rxbuf_index = 0;
    78c0:	46cb      	mov	fp, r9
	for (i = 0; i < j; i++) {
    78c2:	45c2      	cmp	sl, r8
    78c4:	d10e      	bne.n	78e4 <_mac_async_read+0x78>
		}
	}

	return total_len;
}
    78c6:	4648      	mov	r0, r9
    78c8:	b003      	add	sp, #12
    78ca:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	for (i = 0; i < CONF_GMAC_RXDESCR_NUM; i++) {
    78ce:	4644      	mov	r4, r8
    78d0:	2c10      	cmp	r4, #16
    78d2:	d1d3      	bne.n	787c <_mac_async_read+0x10>
	} else if (sof != 0xFFFFFFFF) {
    78d4:	1c7a      	adds	r2, r7, #1
    78d6:	d101      	bne.n	78dc <_mac_async_read+0x70>
    78d8:	46a0      	mov	r8, r4
    78da:	e000      	b.n	78de <_mac_async_read+0x72>
    78dc:	46b8      	mov	r8, r7
    78de:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
    78e2:	e7ea      	b.n	78ba <_mac_async_read+0x4e>
		if (eof != 0xFFFFFFFF && i >= sof && i <= eof && len > 0) {
    78e4:	1c61      	adds	r1, r4, #1
    78e6:	d016      	beq.n	7916 <_mac_async_read+0xaa>
    78e8:	45ba      	cmp	sl, r7
    78ea:	d314      	bcc.n	7916 <_mac_async_read+0xaa>
    78ec:	45a2      	cmp	sl, r4
    78ee:	d812      	bhi.n	7916 <_mac_async_read+0xaa>
    78f0:	b18e      	cbz	r6, 7916 <_mac_async_read+0xaa>
			memcpy(buf, _rxbuf[_rxbuf_index], n);
    78f2:	f8d5 1368 	ldr.w	r1, [r5, #872]	; 0x368
    78f6:	4815      	ldr	r0, [pc, #84]	; (794c <_mac_async_read+0xe0>)
			n = min(len, CONF_GMAC_RXBUF_SIZE);
    78f8:	2e80      	cmp	r6, #128	; 0x80
    78fa:	4632      	mov	r2, r6
			memcpy(buf, _rxbuf[_rxbuf_index], n);
    78fc:	eb00 11c1 	add.w	r1, r0, r1, lsl #7
			n = min(len, CONF_GMAC_RXBUF_SIZE);
    7900:	bf28      	it	cs
    7902:	2280      	movcs	r2, #128	; 0x80
			memcpy(buf, _rxbuf[_rxbuf_index], n);
    7904:	4618      	mov	r0, r3
    7906:	4b12      	ldr	r3, [pc, #72]	; (7950 <_mac_async_read+0xe4>)
    7908:	9201      	str	r2, [sp, #4]
    790a:	4798      	blx	r3
			buf += n;
    790c:	9a01      	ldr	r2, [sp, #4]
			memcpy(buf, _rxbuf[_rxbuf_index], n);
    790e:	4603      	mov	r3, r0
			buf += n;
    7910:	4413      	add	r3, r2
			total_len += n;
    7912:	4491      	add	r9, r2
			len -= n;
    7914:	1ab6      	subs	r6, r6, r2
		_rxbuf_descrs[_rxbuf_index].address.bm.ownership = 0;
    7916:	f8d5 2368 	ldr.w	r2, [r5, #872]	; 0x368
    791a:	eb05 02c2 	add.w	r2, r5, r2, lsl #3
	for (i = 0; i < j; i++) {
    791e:	f10a 0a01 	add.w	sl, sl, #1
		_rxbuf_descrs[_rxbuf_index].address.bm.ownership = 0;
    7922:	f892 12e8 	ldrb.w	r1, [r2, #744]	; 0x2e8
    7926:	f36f 0100 	bfc	r1, #0, #1
    792a:	f882 12e8 	strb.w	r1, [r2, #744]	; 0x2e8
		_rxbuf_index++;
    792e:	f8d5 2368 	ldr.w	r2, [r5, #872]	; 0x368
    7932:	3201      	adds	r2, #1
    7934:	f8c5 2368 	str.w	r2, [r5, #872]	; 0x368
		if (_rxbuf_index == CONF_GMAC_RXDESCR_NUM) {
    7938:	f8d5 2368 	ldr.w	r2, [r5, #872]	; 0x368
    793c:	2a10      	cmp	r2, #16
			_rxbuf_index = 0;
    793e:	bf08      	it	eq
    7940:	f8c5 b368 	streq.w	fp, [r5, #872]	; 0x368
	for (i = 0; i < j; i++) {
    7944:	e7bd      	b.n	78c2 <_mac_async_read+0x56>
    7946:	bf00      	nop
    7948:	20015e98 	.word	0x20015e98
    794c:	20015980 	.word	0x20015980
    7950:	000094a5 	.word	0x000094a5

00007954 <_mac_async_read_len>:
uint32_t _mac_async_read_len(struct _mac_async_device *const dev)
{
	uint32_t i;
	uint32_t pos;
	bool     sof       = false; /* Start of Frame */
	uint32_t total_len = 0;     /* Total length of received package */
    7954:	2000      	movs	r0, #0

	(void)dev;

	for (i = 0; i < CONF_GMAC_RXDESCR_NUM; i++) {
		pos = _rxbuf_index + i;
    7956:	4913      	ldr	r1, [pc, #76]	; (79a4 <_mac_async_read_len+0x50>)
{
    7958:	b570      	push	{r4, r5, r6, lr}
	for (i = 0; i < CONF_GMAC_RXDESCR_NUM; i++) {
    795a:	4602      	mov	r2, r0
	bool     sof       = false; /* Start of Frame */
    795c:	4606      	mov	r6, r0
		pos = _rxbuf_index + i;
    795e:	f8d1 3368 	ldr.w	r3, [r1, #872]	; 0x368
    7962:	4413      	add	r3, r2

		if (pos >= CONF_GMAC_RXDESCR_NUM) {
    7964:	2b0f      	cmp	r3, #15
			pos -= CONF_GMAC_RXDESCR_NUM;
    7966:	bf88      	it	hi
    7968:	3b10      	subhi	r3, #16
		}

		/* No more data for Ethernet package */
		if (!(_rxbuf_descrs[pos].address.bm.ownership)) {
    796a:	00dc      	lsls	r4, r3, #3
    796c:	eb01 03c3 	add.w	r3, r1, r3, lsl #3
    7970:	f893 52e8 	ldrb.w	r5, [r3, #744]	; 0x2e8
    7974:	f015 0501 	ands.w	r5, r5, #1
    7978:	d013      	beq.n	79a2 <_mac_async_read_len+0x4e>
			break;
		}

		if (_rxbuf_descrs[pos].status.bm.sof) {
    797a:	f893 32ed 	ldrb.w	r3, [r3, #749]	; 0x2ed
    797e:	065b      	lsls	r3, r3, #25
    7980:	d400      	bmi.n	7984 <_mac_async_read_len+0x30>
			sof = true;
		}
		if (sof == true) {
    7982:	b136      	cbz	r6, 7992 <_mac_async_read_len+0x3e>
			total_len += _rxbuf_descrs[pos].status.bm.len;
    7984:	190b      	adds	r3, r1, r4
    7986:	462e      	mov	r6, r5
    7988:	f8b3 32ec 	ldrh.w	r3, [r3, #748]	; 0x2ec
    798c:	f3c3 030c 	ubfx	r3, r3, #0, #13
    7990:	4418      	add	r0, r3
		}

		if (_rxbuf_descrs[pos].status.bm.eof) {
    7992:	440c      	add	r4, r1
    7994:	f894 32ed 	ldrb.w	r3, [r4, #749]	; 0x2ed
    7998:	09db      	lsrs	r3, r3, #7
    799a:	d102      	bne.n	79a2 <_mac_async_read_len+0x4e>
	for (i = 0; i < CONF_GMAC_RXDESCR_NUM; i++) {
    799c:	3201      	adds	r2, #1
    799e:	2a10      	cmp	r2, #16
    79a0:	d1dd      	bne.n	795e <_mac_async_read_len+0xa>
			break;
		}
	}

	return total_len;
}
    79a2:	bd70      	pop	{r4, r5, r6, pc}
    79a4:	20015e98 	.word	0x20015e98

000079a8 <_mac_async_register_callback>:
}

int32_t _mac_async_register_callback(struct _mac_async_device *const dev, const enum mac_async_cb_type type,
                                     const FUNC_PTR func)
{
	switch (type) {
    79a8:	b151      	cbz	r1, 79c0 <_mac_async_register_callback+0x18>
    79aa:	2901      	cmp	r1, #1
    79ac:	d10d      	bne.n	79ca <_mac_async_register_callback+0x22>
	case MAC_ASYNC_TRANSMIT_CB:
		dev->cb.transmited = (_mac_async_cb_t)func;
		if (func) {
			hri_gmac_set_IMR_TCOMP_bit(dev->hw);
    79ae:	6803      	ldr	r3, [r0, #0]
		dev->cb.transmited = (_mac_async_cb_t)func;
    79b0:	6042      	str	r2, [r0, #4]
		if (func) {
    79b2:	2180      	movs	r1, #128	; 0x80
    79b4:	b112      	cbz	r2, 79bc <_mac_async_register_callback+0x14>
	((Gmac *)hw)->IER.reg = GMAC_IMR_TCOMP;
    79b6:	6299      	str	r1, [r3, #40]	; 0x28
		}
		break;
	default:
		return ERR_INVALID_ARG;
	}
	return ERR_NONE;
    79b8:	2000      	movs	r0, #0
}
    79ba:	4770      	bx	lr
	((Gmac *)hw)->IDR.reg = GMAC_IMR_TCOMP;
    79bc:	62d9      	str	r1, [r3, #44]	; 0x2c
    79be:	e7fb      	b.n	79b8 <_mac_async_register_callback+0x10>
			hri_gmac_set_IMR_TCOMP_bit(dev->hw);
    79c0:	6803      	ldr	r3, [r0, #0]
		dev->cb.received = (_mac_async_cb_t)func;
    79c2:	6082      	str	r2, [r0, #8]
		if (func) {
    79c4:	2002      	movs	r0, #2
	((Gmac *)hw)->IER.reg = GMAC_IMR_RCOMP;
    79c6:	6298      	str	r0, [r3, #40]	; 0x28
    79c8:	e7f6      	b.n	79b8 <_mac_async_register_callback+0x10>
	switch (type) {
    79ca:	f06f 000c 	mvn.w	r0, #12
}
    79ce:	4770      	bx	lr

000079d0 <_mac_async_set_filter>:

int32_t _mac_async_set_filter(struct _mac_async_device *const dev, uint8_t index, struct mac_async_filter *filter)
{
    79d0:	b570      	push	{r4, r5, r6, lr}
    79d2:	460c      	mov	r4, r1
    79d4:	4606      	mov	r6, r0
	ASSERT(index < 4);
    79d6:	2c03      	cmp	r4, #3
{
    79d8:	4615      	mov	r5, r2
	ASSERT(index < 4);
    79da:	bf8c      	ite	hi
    79dc:	2000      	movhi	r0, #0
    79de:	2001      	movls	r0, #1
    79e0:	4909      	ldr	r1, [pc, #36]	; (7a08 <_mac_async_set_filter+0x38>)
    79e2:	4b0a      	ldr	r3, [pc, #40]	; (7a0c <_mac_async_set_filter+0x3c>)
    79e4:	f240 12cf 	movw	r2, #463	; 0x1cf
    79e8:	4798      	blx	r3

	hri_gmac_write_SAB_reg(dev->hw, index, *((uint32_t *)(filter->mac)));
    79ea:	6833      	ldr	r3, [r6, #0]
    79ec:	6829      	ldr	r1, [r5, #0]
	((Gmac *)hw)->Sa[submodule_index].SAB.reg = data;
    79ee:	eb03 02c4 	add.w	r2, r3, r4, lsl #3
	((Gmac *)hw)->TIDM[index].reg = data;
    79f2:	342a      	adds	r4, #42	; 0x2a
	((Gmac *)hw)->Sa[submodule_index].SAB.reg = data;
    79f4:	f8c2 1088 	str.w	r1, [r2, #136]	; 0x88
	hri_gmac_write_SAT_reg(dev->hw, index, *((uint16_t *)(filter->mac + 4)));
    79f8:	88a9      	ldrh	r1, [r5, #4]
	((Gmac *)hw)->Sa[submodule_index].SAT.reg = data;
    79fa:	f8c2 108c 	str.w	r1, [r2, #140]	; 0x8c

	hri_gmac_write_TIDM_reg(dev->hw, index, GMAC_TIDM_TID(*((uint16_t *)(filter->tid)) | filter->tid_enable << 31));
    79fe:	88ea      	ldrh	r2, [r5, #6]
	((Gmac *)hw)->TIDM[index].reg = data;
    7a00:	f843 2024 	str.w	r2, [r3, r4, lsl #2]
	return ERR_NONE;
}
    7a04:	2000      	movs	r0, #0
    7a06:	bd70      	pop	{r4, r5, r6, pc}
    7a08:	0000aa76 	.word	0x0000aa76
    7a0c:	00007aa9 	.word	0x00007aa9

00007a10 <_mac_async_read_phy_reg>:
	return ERR_NONE;
}

int32_t _mac_async_read_phy_reg(struct _mac_async_device *const dev, uint16_t addr, uint16_t reg, uint16_t *data)
{
	hri_gmac_set_NCR_reg(dev->hw, GMAC_NCR_MPE);
    7a10:	6800      	ldr	r0, [r0, #0]
	hri_gmac_write_MAN_reg(dev->hw,
	                       GMAC_MAN_OP(2) |            /* 0x02 read operation */
	                           CONF_GMAC_CLTTO << 30 | /* Clause 22/45 operation */
	                           GMAC_MAN_WTN(0x2) |     /* Must be written to 0x2 */
	                           GMAC_MAN_PHYA(addr) | GMAC_MAN_REGA(reg));
    7a12:	05c9      	lsls	r1, r1, #23
    7a14:	0492      	lsls	r2, r2, #18
    7a16:	f001 6178 	and.w	r1, r1, #260046848	; 0xf800000
    7a1a:	f402 02f8 	and.w	r2, r2, #8126464	; 0x7c0000
{
    7a1e:	b510      	push	{r4, lr}
	                           GMAC_MAN_PHYA(addr) | GMAC_MAN_REGA(reg));
    7a20:	4311      	orrs	r1, r2
	((Gmac *)hw)->NCR.reg |= mask;
    7a22:	6804      	ldr	r4, [r0, #0]
    7a24:	f041 41c0 	orr.w	r1, r1, #1610612736	; 0x60000000
    7a28:	f044 0410 	orr.w	r4, r4, #16
    7a2c:	f441 3100 	orr.w	r1, r1, #131072	; 0x20000
    7a30:	6004      	str	r4, [r0, #0]
	((Gmac *)hw)->MAN.reg = data;
    7a32:	6341      	str	r1, [r0, #52]	; 0x34
	return (((Gmac *)hw)->NSR.reg & GMAC_NSR_IDLE) >> GMAC_NSR_IDLE_Pos;
    7a34:	6882      	ldr	r2, [r0, #8]

	/* Wait for the read operation complete */
	while (!hri_gmac_get_NSR_IDLE_bit(dev->hw)) {
    7a36:	0752      	lsls	r2, r2, #29
    7a38:	d5fc      	bpl.n	7a34 <_mac_async_read_phy_reg+0x24>
	return ((Gmac *)hw)->MAN.reg;
    7a3a:	6b42      	ldr	r2, [r0, #52]	; 0x34
	}

	*data = GMAC_MAN_DATA(hri_gmac_read_MAN_reg(dev->hw));
    7a3c:	801a      	strh	r2, [r3, #0]
	((Gmac *)hw)->NCR.reg &= ~mask;
    7a3e:	6803      	ldr	r3, [r0, #0]
    7a40:	f023 0310 	bic.w	r3, r3, #16
    7a44:	6003      	str	r3, [r0, #0]
	hri_gmac_clear_NCR_reg(dev->hw, GMAC_NCR_MPE);

	return ERR_NONE;
}
    7a46:	2000      	movs	r0, #0
    7a48:	bd10      	pop	{r4, pc}
	...

00007a4c <_write>:
#include <stdio.h>

int __attribute__((weak)) _write(int file, char *ptr, int len); /* Remove GCC compiler warning */

int __attribute__((weak)) _write(int file, char *ptr, int len)
{
    7a4c:	b508      	push	{r3, lr}
    7a4e:	4603      	mov	r3, r0
	int n = 0;

	if ((file != 1) && (file != 2) && (file != 3)) {
    7a50:	3b01      	subs	r3, #1
    7a52:	2b02      	cmp	r3, #2
{
    7a54:	4608      	mov	r0, r1
    7a56:	4611      	mov	r1, r2
	if ((file != 1) && (file != 2) && (file != 3)) {
    7a58:	d804      	bhi.n	7a64 <_write+0x18>
		return -1;
	}

	n = stdio_io_write((const uint8_t *)ptr, len);
    7a5a:	4b04      	ldr	r3, [pc, #16]	; (7a6c <_write+0x20>)
    7a5c:	4798      	blx	r3
	if (n < 0) {
    7a5e:	ea40 70e0 	orr.w	r0, r0, r0, asr #31
		return -1;
	}

	return n;
}
    7a62:	bd08      	pop	{r3, pc}
		return -1;
    7a64:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    7a68:	e7fb      	b.n	7a62 <_write+0x16>
    7a6a:	bf00      	nop
    7a6c:	000002ed 	.word	0x000002ed

00007a70 <RAMECC_Handler>:
	return tmp;
}

static inline hri_ramecc_intflag_reg_t hri_ramecc_read_INTFLAG_reg(const void *const hw)
{
	return ((Ramecc *)hw)->INTFLAG.reg;
    7a70:	4a0b      	ldr	r2, [pc, #44]	; (7aa0 <RAMECC_Handler+0x30>)
    7a72:	7893      	ldrb	r3, [r2, #2]

/**
 * \internal RAMECC interrupt handler
 */
void RAMECC_Handler(void)
{
    7a74:	b082      	sub	sp, #8
    7a76:	b2db      	uxtb	r3, r3
	struct _ramecc_device *dev      = (struct _ramecc_device *)&device;
	volatile uint32_t      int_mask = hri_ramecc_read_INTFLAG_reg(RAMECC);
    7a78:	9301      	str	r3, [sp, #4]

	if (int_mask & RAMECC_INTFLAG_DUALE && dev->ramecc_cb.dual_bit_err) {
    7a7a:	9b01      	ldr	r3, [sp, #4]
    7a7c:	0799      	lsls	r1, r3, #30
    7a7e:	d505      	bpl.n	7a8c <RAMECC_Handler+0x1c>
    7a80:	4b08      	ldr	r3, [pc, #32]	; (7aa4 <RAMECC_Handler+0x34>)
    7a82:	681b      	ldr	r3, [r3, #0]
    7a84:	b113      	cbz	r3, 7a8c <RAMECC_Handler+0x1c>
	return tmp;
}

static inline hri_ramecc_erraddr_reg_t hri_ramecc_read_ERRADDR_reg(const void *const hw)
{
	return ((Ramecc *)hw)->ERRADDR.reg;
    7a86:	6850      	ldr	r0, [r2, #4]
	} else if (int_mask & RAMECC_INTFLAG_SINGLEE && dev->ramecc_cb.single_bit_err) {
		dev->ramecc_cb.single_bit_err((uint32_t)hri_ramecc_read_ERRADDR_reg(RAMECC));
	} else {
		return;
	}
}
    7a88:	b002      	add	sp, #8
		dev->ramecc_cb.single_bit_err((uint32_t)hri_ramecc_read_ERRADDR_reg(RAMECC));
    7a8a:	4718      	bx	r3
	} else if (int_mask & RAMECC_INTFLAG_SINGLEE && dev->ramecc_cb.single_bit_err) {
    7a8c:	9b01      	ldr	r3, [sp, #4]
    7a8e:	07db      	lsls	r3, r3, #31
    7a90:	d504      	bpl.n	7a9c <RAMECC_Handler+0x2c>
    7a92:	4b04      	ldr	r3, [pc, #16]	; (7aa4 <RAMECC_Handler+0x34>)
    7a94:	685b      	ldr	r3, [r3, #4]
    7a96:	b10b      	cbz	r3, 7a9c <RAMECC_Handler+0x2c>
    7a98:	4a01      	ldr	r2, [pc, #4]	; (7aa0 <RAMECC_Handler+0x30>)
    7a9a:	e7f4      	b.n	7a86 <RAMECC_Handler+0x16>
}
    7a9c:	b002      	add	sp, #8
    7a9e:	4770      	bx	lr
    7aa0:	41020000 	.word	0x41020000
    7aa4:	20016204 	.word	0x20016204

00007aa8 <assert>:
/**
 * \brief Assert function
 */
void assert(const bool condition, const char *const file, const int line)
{
	if (!(condition)) {
    7aa8:	b900      	cbnz	r0, 7aac <assert+0x4>
		__asm("BKPT #0");
    7aaa:	be00      	bkpt	0x0000
	}
	(void)file;
	(void)line;
}
    7aac:	4770      	bx	lr

00007aae <ip4_addr_isbroadcast>:
{
	ip_addr_t ipaddr;
	ip4_addr_set_u32(&ipaddr, addr);

	/* all ones (broadcast) or all zeroes (old skool broadcast) */
	if ((~addr == IPADDR_ANY) || (addr == IPADDR_ANY)) {
    7aae:	1e43      	subs	r3, r0, #1
    7ab0:	3303      	adds	r3, #3
{
    7ab2:	4602      	mov	r2, r0
	if ((~addr == IPADDR_ANY) || (addr == IPADDR_ANY)) {
    7ab4:	d812      	bhi.n	7adc <ip4_addr_isbroadcast+0x2e>
		return 1;
		/* no broadcast support on this network interface? */
	} else if ((netif->flags & NETIF_FLAG_BROADCAST) == 0) {
    7ab6:	f891 302d 	ldrb.w	r3, [r1, #45]	; 0x2d
    7aba:	f013 0002 	ands.w	r0, r3, #2
    7abe:	d010      	beq.n	7ae2 <ip4_addr_isbroadcast+0x34>
		/* the given address cannot be a broadcast address
		 * nor can we check against any broadcast addresses */
		return 0;
		/* address matches network interface address exactly? => no broadcast */
	} else if (addr == ip4_addr_get_u32(&netif->ip_addr)) {
    7ac0:	684b      	ldr	r3, [r1, #4]
    7ac2:	4293      	cmp	r3, r2
    7ac4:	d00c      	beq.n	7ae0 <ip4_addr_isbroadcast+0x32>
		return 0;
		/*  on the same (sub) network... */
	} else if (ip_addr_netcmp(&ipaddr, &(netif->ip_addr), &(netif->netmask))
    7ac6:	6888      	ldr	r0, [r1, #8]
    7ac8:	4053      	eors	r3, r2
    7aca:	4203      	tst	r3, r0
    7acc:	d108      	bne.n	7ae0 <ip4_addr_isbroadcast+0x32>
	           /* ...and host identifier bits are all ones? =>... */
	           && ((addr & ~ip4_addr_get_u32(&netif->netmask))
    7ace:	43c3      	mvns	r3, r0
    7ad0:	ea22 0000 	bic.w	r0, r2, r0
	               == (IPADDR_BROADCAST & ~ip4_addr_get_u32(&netif->netmask)))) {
		/* => network broadcast address */
		return 1;
	} else {
		return 0;
    7ad4:	1ac3      	subs	r3, r0, r3
    7ad6:	4258      	negs	r0, r3
    7ad8:	4158      	adcs	r0, r3
    7ada:	4770      	bx	lr
		return 1;
    7adc:	2001      	movs	r0, #1
    7ade:	4770      	bx	lr
		return 0;
    7ae0:	2000      	movs	r0, #0
	}
}
    7ae2:	4770      	bx	lr

00007ae4 <ipaddr_aton>:
 * @param cp IP address in ascii represenation (e.g. "127.0.0.1")
 * @param addr pointer to which to save the ip address in network order
 * @return 1 if cp could be converted to addr, 0 on failure
 */
int ipaddr_aton(const char *cp, ip_addr_t *addr)
{
    7ae4:	e92d 41ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, lr}
	u32_t  val;
	u8_t   base;
	char   c;
	u32_t  parts[4];
	u32_t *pp = parts;
    7ae8:	466e      	mov	r6, sp

	c = *cp;
    7aea:	7803      	ldrb	r3, [r0, #0]
{
    7aec:	460c      	mov	r4, r1
	c = *cp;
    7aee:	2204      	movs	r2, #4
    7af0:	4637      	mov	r7, r6
		/*
		 * Collect number up to ``.''.
		 * Values are specified as for C:
		 * 0x=hex, 0=octal, 1-9=decimal.
		 */
		if (!isdigit(c))
    7af2:	f1a3 0130 	sub.w	r1, r3, #48	; 0x30
    7af6:	2909      	cmp	r1, #9
    7af8:	d873      	bhi.n	7be2 <ipaddr_aton+0xfe>
			return (0);
		val  = 0;
		base = 10;
		if (c == '0') {
    7afa:	2b30      	cmp	r3, #48	; 0x30
    7afc:	d11a      	bne.n	7b34 <ipaddr_aton+0x50>
			c = *++cp;
    7afe:	7843      	ldrb	r3, [r0, #1]
			if (c == 'x' || c == 'X') {
    7b00:	f003 01df 	and.w	r1, r3, #223	; 0xdf
    7b04:	2958      	cmp	r1, #88	; 0x58
				base = 16;
				c    = *++cp;
    7b06:	bf0d      	iteet	eq
    7b08:	7883      	ldrbeq	r3, [r0, #2]
			c = *++cp;
    7b0a:	3001      	addne	r0, #1
			} else
				base = 8;
    7b0c:	f04f 0c08 	movne.w	ip, #8
				c    = *++cp;
    7b10:	3002      	addeq	r0, #2
				base = 16;
    7b12:	bf08      	it	eq
    7b14:	f04f 0c10 	moveq.w	ip, #16
    7b18:	1c45      	adds	r5, r0, #1
		base = 10;
    7b1a:	2000      	movs	r0, #0
		}
		for (;;) {
			if (isdigit(c)) {
    7b1c:	f1a3 0130 	sub.w	r1, r3, #48	; 0x30
    7b20:	2909      	cmp	r1, #9
    7b22:	f105 38ff 	add.w	r8, r5, #4294967295	; 0xffffffff
    7b26:	d808      	bhi.n	7b3a <ipaddr_aton+0x56>
				val = (val * base) + (int)(c - '0');
    7b28:	fb00 300c 	mla	r0, r0, ip, r3
    7b2c:	3830      	subs	r0, #48	; 0x30
				c   = *++cp;
			} else if (base == 16 && isxdigit(c)) {
				val = (val << 4) | (int)(c + 10 - (islower(c) ? 'a' : 'A'));
				c   = *++cp;
    7b2e:	782b      	ldrb	r3, [r5, #0]
    7b30:	3501      	adds	r5, #1
    7b32:	e7f3      	b.n	7b1c <ipaddr_aton+0x38>
		base = 10;
    7b34:	f04f 0c0a 	mov.w	ip, #10
    7b38:	e7ee      	b.n	7b18 <ipaddr_aton+0x34>
			} else if (base == 16 && isxdigit(c)) {
    7b3a:	f1bc 0f10 	cmp.w	ip, #16
    7b3e:	d114      	bne.n	7b6a <ipaddr_aton+0x86>
    7b40:	f023 0120 	bic.w	r1, r3, #32
    7b44:	3941      	subs	r1, #65	; 0x41
    7b46:	b2c9      	uxtb	r1, r1
    7b48:	f1a3 0e61 	sub.w	lr, r3, #97	; 0x61
    7b4c:	2905      	cmp	r1, #5
    7b4e:	fa5f fe8e 	uxtb.w	lr, lr
    7b52:	d80a      	bhi.n	7b6a <ipaddr_aton+0x86>
				val = (val << 4) | (int)(c + 10 - (islower(c) ? 'a' : 'A'));
    7b54:	f1be 0f1a 	cmp.w	lr, #26
    7b58:	f103 030a 	add.w	r3, r3, #10
    7b5c:	bf34      	ite	cc
    7b5e:	2161      	movcc	r1, #97	; 0x61
    7b60:	2141      	movcs	r1, #65	; 0x41
    7b62:	1a5b      	subs	r3, r3, r1
    7b64:	ea43 1000 	orr.w	r0, r3, r0, lsl #4
    7b68:	e7e1      	b.n	7b2e <ipaddr_aton+0x4a>
			} else
				break;
		}
		if (c == '.') {
    7b6a:	2b2e      	cmp	r3, #46	; 0x2e
    7b6c:	d108      	bne.n	7b80 <ipaddr_aton+0x9c>
			 * Internet format:
			 *  a.b.c.d
			 *  a.b.c   (with c treated as 16 bits)
			 *  a.b (with b treated as 24 bits)
			 */
			if (pp >= parts + 3) {
    7b6e:	3a01      	subs	r2, #1
    7b70:	d038      	beq.n	7be4 <ipaddr_aton+0x100>
				return (0);
			}
			*pp++ = val;
    7b72:	f846 0b04 	str.w	r0, [r6], #4
			c     = *++cp;
    7b76:	f898 3001 	ldrb.w	r3, [r8, #1]
    7b7a:	f108 0001 	add.w	r0, r8, #1
		if (!isdigit(c))
    7b7e:	e7b8      	b.n	7af2 <ipaddr_aton+0xe>
			break;
	}
	/*
	 * Check for trailing characters.
	 */
	if (c != '\0' && !isspace(c)) {
    7b80:	f013 0fdf 	tst.w	r3, #223	; 0xdf
    7b84:	d002      	beq.n	7b8c <ipaddr_aton+0xa8>
    7b86:	3b09      	subs	r3, #9
    7b88:	2b04      	cmp	r3, #4
    7b8a:	d82a      	bhi.n	7be2 <ipaddr_aton+0xfe>
	}
	/*
	 * Concoct the address according to
	 * the number of parts specified.
	 */
	switch (pp - parts + 1) {
    7b8c:	1bf2      	subs	r2, r6, r7
    7b8e:	1092      	asrs	r2, r2, #2
    7b90:	3201      	adds	r2, #1
    7b92:	2a04      	cmp	r2, #4
    7b94:	d80a      	bhi.n	7bac <ipaddr_aton+0xc8>
    7b96:	e8df f002 	tbb	[pc, r2]
    7b9a:	0925      	.short	0x0925
    7b9c:	0f03      	.short	0x0f03
    7b9e:	19          	.byte	0x19
    7b9f:	00          	.byte	0x00

	case 1: /* a -- 32 bits */
		break;

	case 2: /* a.b -- 8.24 bits */
		if (val > 0xffffffUL) {
    7ba0:	f1b0 7f80 	cmp.w	r0, #16777216	; 0x1000000
    7ba4:	d21d      	bcs.n	7be2 <ipaddr_aton+0xfe>
			return (0);
		}
		val |= parts[0] << 24;
    7ba6:	9b00      	ldr	r3, [sp, #0]
    7ba8:	ea40 6003 	orr.w	r0, r0, r3, lsl #24
		break;
	default:
		LWIP_ASSERT("unhandled", 0);
		break;
	}
	if (addr) {
    7bac:	b114      	cbz	r4, 7bb4 <ipaddr_aton+0xd0>
		ip4_addr_set_u32(addr, htonl(val));
    7bae:	4b0f      	ldr	r3, [pc, #60]	; (7bec <ipaddr_aton+0x108>)
    7bb0:	4798      	blx	r3
    7bb2:	6020      	str	r0, [r4, #0]
	}
	return (1);
    7bb4:	2201      	movs	r2, #1
    7bb6:	e015      	b.n	7be4 <ipaddr_aton+0x100>
		if (val > 0xffff) {
    7bb8:	f5b0 3f80 	cmp.w	r0, #65536	; 0x10000
    7bbc:	d211      	bcs.n	7be2 <ipaddr_aton+0xfe>
		val |= (parts[0] << 24) | (parts[1] << 16);
    7bbe:	9b01      	ldr	r3, [sp, #4]
    7bc0:	9a00      	ldr	r2, [sp, #0]
    7bc2:	041b      	lsls	r3, r3, #16
    7bc4:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
		val |= (parts[0] << 24) | (parts[1] << 16) | (parts[2] << 8);
    7bc8:	4318      	orrs	r0, r3
		break;
    7bca:	e7ef      	b.n	7bac <ipaddr_aton+0xc8>
		if (val > 0xff) {
    7bcc:	28ff      	cmp	r0, #255	; 0xff
    7bce:	d808      	bhi.n	7be2 <ipaddr_aton+0xfe>
		val |= (parts[0] << 24) | (parts[1] << 16) | (parts[2] << 8);
    7bd0:	9b01      	ldr	r3, [sp, #4]
    7bd2:	9a00      	ldr	r2, [sp, #0]
    7bd4:	041b      	lsls	r3, r3, #16
    7bd6:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
    7bda:	9a02      	ldr	r2, [sp, #8]
    7bdc:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
    7be0:	e7f2      	b.n	7bc8 <ipaddr_aton+0xe4>
			return (0);
    7be2:	2200      	movs	r2, #0
}
    7be4:	4610      	mov	r0, r2
    7be6:	b004      	add	sp, #16
    7be8:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    7bec:	00000d71 	.word	0x00000d71

00007bf0 <ipaddr_ntoa_r>:
 * @param buflen length of buf
 * @return either pointer to buf which now holds the ASCII
 *         representation of addr or NULL if buf was too small
 */
char *ipaddr_ntoa_r(const ip_addr_t *addr, char *buf, int buflen)
{
    7bf0:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
	u8_t  rem;
	u8_t  n;
	u8_t  i;
	int   len = 0;

	s_addr = ip4_addr_get_u32(addr);
    7bf4:	6803      	ldr	r3, [r0, #0]
    7bf6:	9301      	str	r3, [sp, #4]

	rp = buf;
	ap = (u8_t *)&s_addr;
	for (n = 0; n < 4; n++) {
    7bf8:	f10d 0c04 	add.w	ip, sp, #4
	rp = buf;
    7bfc:	460d      	mov	r5, r1
	s_addr = ip4_addr_get_u32(addr);
    7bfe:	2004      	movs	r0, #4
	int   len = 0;
    7c00:	2600      	movs	r6, #0
		i = 0;
		do {
			rem = *ap % (u8_t)10;
    7c02:	f04f 0e0a 	mov.w	lr, #10
			*rp++ = inv[i];
		}
		if (len++ >= buflen) {
			return NULL;
		}
		*rp++ = '.';
    7c06:	f04f 082e 	mov.w	r8, #46	; 0x2e
    7c0a:	f81c 4b01 	ldrb.w	r4, [ip], #1
		i = 0;
    7c0e:	2700      	movs	r7, #0
			rem = *ap % (u8_t)10;
    7c10:	fbb4 f3fe 	udiv	r3, r4, lr
    7c14:	46a2      	mov	sl, r4
    7c16:	fb0e 4913 	mls	r9, lr, r3, r4
			*ap /= (u8_t)10;
    7c1a:	b2dc      	uxtb	r4, r3
			inv[i++] = '0' + rem;
    7c1c:	463b      	mov	r3, r7
    7c1e:	f103 0b08 	add.w	fp, r3, #8
    7c22:	44eb      	add	fp, sp
    7c24:	3701      	adds	r7, #1
    7c26:	f109 0930 	add.w	r9, r9, #48	; 0x30
		} while (*ap);
    7c2a:	f1ba 0f09 	cmp.w	sl, #9
			inv[i++] = '0' + rem;
    7c2e:	b2ff      	uxtb	r7, r7
    7c30:	f80b 9c08 	strb.w	r9, [fp, #-8]
		} while (*ap);
    7c34:	d8ec      	bhi.n	7c10 <ipaddr_ntoa_r+0x20>
    7c36:	f80c 4c01 	strb.w	r4, [ip, #-1]
    7c3a:	4637      	mov	r7, r6
    7c3c:	462c      	mov	r4, r5
		while (i--) {
    7c3e:	2bff      	cmp	r3, #255	; 0xff
			if (len++ >= buflen) {
    7c40:	f106 0601 	add.w	r6, r6, #1
		while (i--) {
    7c44:	d10d      	bne.n	7c62 <ipaddr_ntoa_r+0x72>
		if (len++ >= buflen) {
    7c46:	4297      	cmp	r7, r2
    7c48:	da18      	bge.n	7c7c <ipaddr_ntoa_r+0x8c>
		*rp++ = '.';
    7c4a:	4625      	mov	r5, r4
	for (n = 0; n < 4; n++) {
    7c4c:	3801      	subs	r0, #1
    7c4e:	f010 00ff 	ands.w	r0, r0, #255	; 0xff
		*rp++ = '.';
    7c52:	f805 8b01 	strb.w	r8, [r5], #1
	for (n = 0; n < 4; n++) {
    7c56:	d1d8      	bne.n	7c0a <ipaddr_ntoa_r+0x1a>
		ap++;
	}
	*--rp = 0;
    7c58:	7020      	strb	r0, [r4, #0]
	return buf;
    7c5a:	4608      	mov	r0, r1
}
    7c5c:	b003      	add	sp, #12
    7c5e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
			if (len++ >= buflen) {
    7c62:	1e5d      	subs	r5, r3, #1
    7c64:	4297      	cmp	r7, r2
    7c66:	b2ed      	uxtb	r5, r5
    7c68:	da08      	bge.n	7c7c <ipaddr_ntoa_r+0x8c>
			*rp++ = inv[i];
    7c6a:	3308      	adds	r3, #8
    7c6c:	446b      	add	r3, sp
			if (len++ >= buflen) {
    7c6e:	4637      	mov	r7, r6
			*rp++ = inv[i];
    7c70:	f813 3c08 	ldrb.w	r3, [r3, #-8]
    7c74:	f804 3b01 	strb.w	r3, [r4], #1
    7c78:	462b      	mov	r3, r5
    7c7a:	e7e0      	b.n	7c3e <ipaddr_ntoa_r+0x4e>
				return NULL;
    7c7c:	2000      	movs	r0, #0
    7c7e:	e7ed      	b.n	7c5c <ipaddr_ntoa_r+0x6c>

00007c80 <_mclk_init>:
	((Mclk *)hw)->CPUDIV.reg = data;
    7c80:	4b01      	ldr	r3, [pc, #4]	; (7c88 <_mclk_init+0x8>)
    7c82:	2201      	movs	r2, #1
    7c84:	715a      	strb	r2, [r3, #5]
 */
void _mclk_init(void)
{
	void *hw = (void *)MCLK;
	hri_mclk_write_CPUDIV_reg(hw, MCLK_CPUDIV_DIV(CONF_MCLK_CPUDIV));
}
    7c86:	4770      	bx	lr
    7c88:	40000800 	.word	0x40000800

00007c8c <prvResetNextTaskUnblockTime>:

static void prvResetNextTaskUnblockTime(void)
{
	TCB_t *pxTCB;

	if (listLIST_IS_EMPTY(pxDelayedTaskList) != pdFALSE) {
    7c8c:	4b06      	ldr	r3, [pc, #24]	; (7ca8 <prvResetNextTaskUnblockTime+0x1c>)
    7c8e:	6a9a      	ldr	r2, [r3, #40]	; 0x28
    7c90:	6812      	ldr	r2, [r2, #0]
    7c92:	b91a      	cbnz	r2, 7c9c <prvResetNextTaskUnblockTime+0x10>
		/* The new current delayed list is empty.  Set xNextTaskUnblockTime to
		the maximum possible value so it is	extremely unlikely that the
		if( xTickCount >= xNextTaskUnblockTime ) test will pass until
		there is an item in the delayed list. */
		xNextTaskUnblockTime = portMAX_DELAY;
    7c94:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
		/* The new current delayed list is not empty, get the value of
		the item at the head of the delayed list.  This is the time at
		which the task at the head of the delayed list should be removed
		from the Blocked state. */
		(pxTCB)              = (TCB_t *)listGET_OWNER_OF_HEAD_ENTRY(pxDelayedTaskList);
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE(&((pxTCB)->xGenericListItem));
    7c98:	62da      	str	r2, [r3, #44]	; 0x2c
	}
}
    7c9a:	4770      	bx	lr
		(pxTCB)              = (TCB_t *)listGET_OWNER_OF_HEAD_ENTRY(pxDelayedTaskList);
    7c9c:	6a9a      	ldr	r2, [r3, #40]	; 0x28
    7c9e:	68d2      	ldr	r2, [r2, #12]
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE(&((pxTCB)->xGenericListItem));
    7ca0:	68d2      	ldr	r2, [r2, #12]
    7ca2:	6852      	ldr	r2, [r2, #4]
    7ca4:	e7f8      	b.n	7c98 <prvResetNextTaskUnblockTime+0xc>
    7ca6:	bf00      	nop
    7ca8:	20016214 	.word	0x20016214

00007cac <prvAddCurrentTaskToDelayedList>:
{
    7cac:	b570      	push	{r4, r5, r6, lr}
	listSET_LIST_ITEM_VALUE(&(pxCurrentTCB->xGenericListItem), xTimeToWake);
    7cae:	4c0b      	ldr	r4, [pc, #44]	; (7cdc <prvAddCurrentTaskToDelayedList+0x30>)
    7cb0:	6b23      	ldr	r3, [r4, #48]	; 0x30
    7cb2:	6058      	str	r0, [r3, #4]
	if (xTimeToWake < xTickCount) {
    7cb4:	6b63      	ldr	r3, [r4, #52]	; 0x34
    7cb6:	4283      	cmp	r3, r0
{
    7cb8:	4605      	mov	r5, r0
    7cba:	4b09      	ldr	r3, [pc, #36]	; (7ce0 <prvAddCurrentTaskToDelayedList+0x34>)
	if (xTimeToWake < xTickCount) {
    7cbc:	d905      	bls.n	7cca <prvAddCurrentTaskToDelayedList+0x1e>
		vListInsert(pxOverflowDelayedTaskList, &(pxCurrentTCB->xGenericListItem));
    7cbe:	6ba0      	ldr	r0, [r4, #56]	; 0x38
    7cc0:	6b21      	ldr	r1, [r4, #48]	; 0x30
}
    7cc2:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		vListInsert(pxOverflowDelayedTaskList, &(pxCurrentTCB->xGenericListItem));
    7cc6:	3104      	adds	r1, #4
    7cc8:	4718      	bx	r3
		vListInsert(pxDelayedTaskList, &(pxCurrentTCB->xGenericListItem));
    7cca:	6aa0      	ldr	r0, [r4, #40]	; 0x28
    7ccc:	6b21      	ldr	r1, [r4, #48]	; 0x30
    7cce:	3104      	adds	r1, #4
    7cd0:	4798      	blx	r3
		if (xTimeToWake < xNextTaskUnblockTime) {
    7cd2:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
    7cd4:	429d      	cmp	r5, r3
			xNextTaskUnblockTime = xTimeToWake;
    7cd6:	bf38      	it	cc
    7cd8:	62e5      	strcc	r5, [r4, #44]	; 0x2c
}
    7cda:	bd70      	pop	{r4, r5, r6, pc}
    7cdc:	20016214 	.word	0x20016214
    7ce0:	00001dcd 	.word	0x00001dcd

00007ce4 <xTaskGenericCreate>:
{
    7ce4:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    7ce8:	9f0a      	ldr	r7, [sp, #40]	; 0x28
    7cea:	9e0c      	ldr	r6, [sp, #48]	; 0x30
    7cec:	4688      	mov	r8, r1
    7cee:	4615      	mov	r5, r2
    7cf0:	469a      	mov	sl, r3
	configASSERT(pxTaskCode);
    7cf2:	4681      	mov	r9, r0
    7cf4:	b940      	cbnz	r0, 7d08 <xTaskGenericCreate+0x24>
    7cf6:	f04f 0380 	mov.w	r3, #128	; 0x80
    7cfa:	f383 8811 	msr	BASEPRI, r3
    7cfe:	f3bf 8f6f 	isb	sy
    7d02:	f3bf 8f4f 	dsb	sy
    7d06:	e7fe      	b.n	7d06 <xTaskGenericCreate+0x22>
	configASSERT(((uxPriority & (UBaseType_t)(~portPRIVILEGE_BIT)) < (UBaseType_t)configMAX_PRIORITIES));
    7d08:	2f04      	cmp	r7, #4
    7d0a:	d908      	bls.n	7d1e <xTaskGenericCreate+0x3a>
    7d0c:	f04f 0380 	mov.w	r3, #128	; 0x80
    7d10:	f383 8811 	msr	BASEPRI, r3
    7d14:	f3bf 8f6f 	isb	sy
    7d18:	f3bf 8f4f 	dsb	sy
    7d1c:	e7fe      	b.n	7d1c <xTaskGenericCreate+0x38>
		pxStack = (StackType_t *)pvPortMallocAligned(
    7d1e:	4c56      	ldr	r4, [pc, #344]	; (7e78 <xTaskGenericCreate+0x194>)
    7d20:	b92e      	cbnz	r6, 7d2e <xTaskGenericCreate+0x4a>
    7d22:	0090      	lsls	r0, r2, #2
    7d24:	47a0      	blx	r4
		if (pxStack != NULL) {
    7d26:	4606      	mov	r6, r0
    7d28:	2800      	cmp	r0, #0
    7d2a:	f000 8096 	beq.w	7e5a <xTaskGenericCreate+0x176>
			pxNewTCB = (TCB_t *)pvPortMalloc(sizeof(TCB_t));
    7d2e:	2054      	movs	r0, #84	; 0x54
    7d30:	47a0      	blx	r4
			if (pxNewTCB != NULL) {
    7d32:	4604      	mov	r4, r0
    7d34:	2800      	cmp	r0, #0
    7d36:	f000 808d 	beq.w	7e54 <xTaskGenericCreate+0x170>
			(void)memset(pxNewTCB->pxStack, (int)tskSTACK_FILL_BYTE, (size_t)usStackDepth * sizeof(StackType_t));
    7d3a:	00ad      	lsls	r5, r5, #2
    7d3c:	462a      	mov	r2, r5
    7d3e:	4b4f      	ldr	r3, [pc, #316]	; (7e7c <xTaskGenericCreate+0x198>)
				pxNewTCB->pxStack = pxStack;
    7d40:	6306      	str	r6, [r0, #48]	; 0x30
			(void)memset(pxNewTCB->pxStack, (int)tskSTACK_FILL_BYTE, (size_t)usStackDepth * sizeof(StackType_t));
    7d42:	21a5      	movs	r1, #165	; 0xa5
    7d44:	4630      	mov	r0, r6
    7d46:	4798      	blx	r3
			pxTopOfStack = pxNewTCB->pxStack + (usStackDepth - (uint16_t)1);
    7d48:	6b22      	ldr	r2, [r4, #48]	; 0x30
    7d4a:	3d04      	subs	r5, #4
    7d4c:	4415      	add	r5, r2
    7d4e:	f108 33ff 	add.w	r3, r8, #4294967295	; 0xffffffff
			                      & (~((portPOINTER_SIZE_TYPE)
    7d52:	f025 0507 	bic.w	r5, r5, #7
	for (x = (UBaseType_t)0; x < (UBaseType_t)configMAX_TASK_NAME_LEN; x++) {
    7d56:	f104 0234 	add.w	r2, r4, #52	; 0x34
    7d5a:	f108 0807 	add.w	r8, r8, #7
		pxTCB->pcTaskName[x] = pcName[x];
    7d5e:	f813 1f01 	ldrb.w	r1, [r3, #1]!
    7d62:	f802 1b01 	strb.w	r1, [r2], #1
		if (pcName[x] == 0x00) {
    7d66:	b109      	cbz	r1, 7d6c <xTaskGenericCreate+0x88>
	for (x = (UBaseType_t)0; x < (UBaseType_t)configMAX_TASK_NAME_LEN; x++) {
    7d68:	4598      	cmp	r8, r3
    7d6a:	d1f8      	bne.n	7d5e <xTaskGenericCreate+0x7a>
	pxTCB->pcTaskName[configMAX_TASK_NAME_LEN - 1] = '\0';
    7d6c:	2600      	movs	r6, #0
	vListInitialiseItem(&(pxTCB->xGenericListItem));
    7d6e:	f104 0804 	add.w	r8, r4, #4
    7d72:	f8df b128 	ldr.w	fp, [pc, #296]	; 7e9c <xTaskGenericCreate+0x1b8>
	pxTCB->pcTaskName[configMAX_TASK_NAME_LEN - 1] = '\0';
    7d76:	f884 603b 	strb.w	r6, [r4, #59]	; 0x3b
	vListInitialiseItem(&(pxTCB->xGenericListItem));
    7d7a:	4640      	mov	r0, r8
		pxTCB->uxMutexesHeld  = 0;
    7d7c:	e9c4 7611 	strd	r7, r6, [r4, #68]	; 0x44
	pxTCB->uxPriority = uxPriority;
    7d80:	62e7      	str	r7, [r4, #44]	; 0x2c
	vListInitialiseItem(&(pxTCB->xGenericListItem));
    7d82:	47d8      	blx	fp
	vListInitialiseItem(&(pxTCB->xEventListItem));
    7d84:	f104 0018 	add.w	r0, r4, #24
    7d88:	47d8      	blx	fp
	listSET_LIST_ITEM_VALUE(
    7d8a:	f1c7 0305 	rsb	r3, r7, #5
    7d8e:	61a3      	str	r3, [r4, #24]
		pxTCB->ulNotifiedValue = 0;
    7d90:	64e6      	str	r6, [r4, #76]	; 0x4c
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack(pxTopOfStack, pxTaskCode, pvParameters);
    7d92:	4b3b      	ldr	r3, [pc, #236]	; (7e80 <xTaskGenericCreate+0x19c>)
	listSET_LIST_ITEM_OWNER(&(pxTCB->xGenericListItem), pxTCB);
    7d94:	6124      	str	r4, [r4, #16]
	listSET_LIST_ITEM_OWNER(&(pxTCB->xEventListItem), pxTCB);
    7d96:	6264      	str	r4, [r4, #36]	; 0x24
		pxTCB->eNotifyState    = eNotWaitingNotification;
    7d98:	f884 6050 	strb.w	r6, [r4, #80]	; 0x50
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack(pxTopOfStack, pxTaskCode, pvParameters);
    7d9c:	4652      	mov	r2, sl
    7d9e:	4649      	mov	r1, r9
    7da0:	4628      	mov	r0, r5
    7da2:	4798      	blx	r3
		if ((void *)pxCreatedTask != NULL) {
    7da4:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack(pxTopOfStack, pxTaskCode, pvParameters);
    7da6:	6020      	str	r0, [r4, #0]
		if ((void *)pxCreatedTask != NULL) {
    7da8:	b103      	cbz	r3, 7dac <xTaskGenericCreate+0xc8>
			*pxCreatedTask = (TaskHandle_t)pxNewTCB;
    7daa:	601c      	str	r4, [r3, #0]
			uxCurrentNumberOfTasks++;
    7dac:	4d35      	ldr	r5, [pc, #212]	; (7e84 <xTaskGenericCreate+0x1a0>)
		taskENTER_CRITICAL();
    7dae:	4b36      	ldr	r3, [pc, #216]	; (7e88 <xTaskGenericCreate+0x1a4>)
    7db0:	4798      	blx	r3
			uxCurrentNumberOfTasks++;
    7db2:	6beb      	ldr	r3, [r5, #60]	; 0x3c
    7db4:	3301      	adds	r3, #1
    7db6:	63eb      	str	r3, [r5, #60]	; 0x3c
			if (pxCurrentTCB == NULL) {
    7db8:	6b2e      	ldr	r6, [r5, #48]	; 0x30
    7dba:	f105 0a40 	add.w	sl, r5, #64	; 0x40
    7dbe:	2e00      	cmp	r6, #0
    7dc0:	d14f      	bne.n	7e62 <xTaskGenericCreate+0x17e>
				pxCurrentTCB = pxNewTCB;
    7dc2:	632c      	str	r4, [r5, #48]	; 0x30
				if (uxCurrentNumberOfTasks == (UBaseType_t)1) {
    7dc4:	6beb      	ldr	r3, [r5, #60]	; 0x3c
    7dc6:	2b01      	cmp	r3, #1
    7dc8:	d11c      	bne.n	7e04 <xTaskGenericCreate+0x120>
		vListInitialise(&(pxReadyTasksLists[uxPriority]));
    7dca:	f8df 90d4 	ldr.w	r9, [pc, #212]	; 7ea0 <xTaskGenericCreate+0x1bc>
    7dce:	46d3      	mov	fp, sl
    7dd0:	4658      	mov	r0, fp
	for (uxPriority = (UBaseType_t)0U; uxPriority < (UBaseType_t)configMAX_PRIORITIES; uxPriority++) {
    7dd2:	3601      	adds	r6, #1
		vListInitialise(&(pxReadyTasksLists[uxPriority]));
    7dd4:	47c8      	blx	r9
	for (uxPriority = (UBaseType_t)0U; uxPriority < (UBaseType_t)configMAX_PRIORITIES; uxPriority++) {
    7dd6:	2e05      	cmp	r6, #5
    7dd8:	f10b 0b14 	add.w	fp, fp, #20
    7ddc:	d1f8      	bne.n	7dd0 <xTaskGenericCreate+0xec>
	vListInitialise(&xDelayedTaskList1);
    7dde:	4e2b      	ldr	r6, [pc, #172]	; (7e8c <xTaskGenericCreate+0x1a8>)
    7de0:	4630      	mov	r0, r6
	vListInitialise(&xDelayedTaskList2);
    7de2:	f106 0b14 	add.w	fp, r6, #20
	vListInitialise(&xDelayedTaskList1);
    7de6:	47c8      	blx	r9
	vListInitialise(&xDelayedTaskList2);
    7de8:	4658      	mov	r0, fp
    7dea:	47c8      	blx	r9
	vListInitialise(&xPendingReadyList);
    7dec:	f1a6 0090 	sub.w	r0, r6, #144	; 0x90
    7df0:	47c8      	blx	r9
		vListInitialise(&xTasksWaitingTermination);
    7df2:	f106 0028 	add.w	r0, r6, #40	; 0x28
    7df6:	47c8      	blx	r9
		vListInitialise(&xSuspendedTaskList);
    7df8:	f1a6 00a4 	sub.w	r0, r6, #164	; 0xa4
    7dfc:	47c8      	blx	r9
	pxDelayedTaskList         = &xDelayedTaskList1;
    7dfe:	62ae      	str	r6, [r5, #40]	; 0x28
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
    7e00:	f8c5 b038 	str.w	fp, [r5, #56]	; 0x38
			uxTaskNumber++;
    7e04:	f8d5 30e4 	ldr.w	r3, [r5, #228]	; 0xe4
			prvAddTaskToReadyList(pxNewTCB);
    7e08:	f8d5 20e8 	ldr.w	r2, [r5, #232]	; 0xe8
			uxTaskNumber++;
    7e0c:	3301      	adds	r3, #1
    7e0e:	f8c5 30e4 	str.w	r3, [r5, #228]	; 0xe4
				pxNewTCB->uxTCBNumber = uxTaskNumber;
    7e12:	63e3      	str	r3, [r4, #60]	; 0x3c
			prvAddTaskToReadyList(pxNewTCB);
    7e14:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
    7e16:	2014      	movs	r0, #20
    7e18:	4293      	cmp	r3, r2
    7e1a:	bf88      	it	hi
    7e1c:	f8c5 30e8 	strhi.w	r3, [r5, #232]	; 0xe8
    7e20:	fb00 a003 	mla	r0, r0, r3, sl
    7e24:	4641      	mov	r1, r8
    7e26:	4b1a      	ldr	r3, [pc, #104]	; (7e90 <xTaskGenericCreate+0x1ac>)
    7e28:	4798      	blx	r3
		taskEXIT_CRITICAL();
    7e2a:	4b1a      	ldr	r3, [pc, #104]	; (7e94 <xTaskGenericCreate+0x1b0>)
    7e2c:	4798      	blx	r3
		if (xSchedulerRunning != pdFALSE) {
    7e2e:	f8d5 30e0 	ldr.w	r3, [r5, #224]	; 0xe0
    7e32:	b16b      	cbz	r3, 7e50 <xTaskGenericCreate+0x16c>
			if (pxCurrentTCB->uxPriority < uxPriority) {
    7e34:	6b2b      	ldr	r3, [r5, #48]	; 0x30
    7e36:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    7e38:	42bb      	cmp	r3, r7
    7e3a:	d209      	bcs.n	7e50 <xTaskGenericCreate+0x16c>
				taskYIELD_IF_USING_PREEMPTION();
    7e3c:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
    7e40:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
    7e44:	f8c3 2d04 	str.w	r2, [r3, #3332]	; 0xd04
    7e48:	f3bf 8f4f 	dsb	sy
    7e4c:	f3bf 8f6f 	isb	sy
			xReturn = pdPASS;
    7e50:	2001      	movs	r0, #1
	return xReturn;
    7e52:	e004      	b.n	7e5e <xTaskGenericCreate+0x17a>
				vPortFree(pxStack);
    7e54:	4b10      	ldr	r3, [pc, #64]	; (7e98 <xTaskGenericCreate+0x1b4>)
    7e56:	4630      	mov	r0, r6
    7e58:	4798      	blx	r3
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    7e5a:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
}
    7e5e:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
				if (xSchedulerRunning == pdFALSE) {
    7e62:	f8d5 30e0 	ldr.w	r3, [r5, #224]	; 0xe0
    7e66:	2b00      	cmp	r3, #0
    7e68:	d1cc      	bne.n	7e04 <xTaskGenericCreate+0x120>
					if (pxCurrentTCB->uxPriority <= uxPriority) {
    7e6a:	6b2b      	ldr	r3, [r5, #48]	; 0x30
    7e6c:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    7e6e:	42bb      	cmp	r3, r7
						pxCurrentTCB = pxNewTCB;
    7e70:	bf98      	it	ls
    7e72:	632c      	strls	r4, [r5, #48]	; 0x30
    7e74:	e7c6      	b.n	7e04 <xTaskGenericCreate+0x120>
    7e76:	bf00      	nop
    7e78:	00001c9d 	.word	0x00001c9d
    7e7c:	000094c1 	.word	0x000094c1
    7e80:	00008eb1 	.word	0x00008eb1
    7e84:	20016214 	.word	0x20016214
    7e88:	00008ef5 	.word	0x00008ef5
    7e8c:	200162b8 	.word	0x200162b8
    7e90:	00001db5 	.word	0x00001db5
    7e94:	00008f35 	.word	0x00008f35
    7e98:	00001d51 	.word	0x00001d51
    7e9c:	00001daf 	.word	0x00001daf
    7ea0:	00001d99 	.word	0x00001d99

00007ea4 <vTaskStartScheduler>:
{
    7ea4:	b530      	push	{r4, r5, lr}
		xReturn = xTaskCreate(prvIdleTask,
    7ea6:	2400      	movs	r4, #0
{
    7ea8:	b085      	sub	sp, #20
		xReturn = xTaskCreate(prvIdleTask,
    7eaa:	e9cd 4402 	strd	r4, r4, [sp, #8]
    7eae:	e9cd 4400 	strd	r4, r4, [sp]
    7eb2:	4916      	ldr	r1, [pc, #88]	; (7f0c <vTaskStartScheduler+0x68>)
    7eb4:	4816      	ldr	r0, [pc, #88]	; (7f10 <vTaskStartScheduler+0x6c>)
    7eb6:	4d17      	ldr	r5, [pc, #92]	; (7f14 <vTaskStartScheduler+0x70>)
    7eb8:	4623      	mov	r3, r4
    7eba:	2240      	movs	r2, #64	; 0x40
    7ebc:	47a8      	blx	r5
		if (xReturn == pdPASS) {
    7ebe:	2801      	cmp	r0, #1
    7ec0:	d117      	bne.n	7ef2 <vTaskStartScheduler+0x4e>
			xReturn = xTimerCreateTimerTask();
    7ec2:	4b15      	ldr	r3, [pc, #84]	; (7f18 <vTaskStartScheduler+0x74>)
    7ec4:	4798      	blx	r3
	if (xReturn == pdPASS) {
    7ec6:	2801      	cmp	r0, #1
    7ec8:	d113      	bne.n	7ef2 <vTaskStartScheduler+0x4e>
    7eca:	f04f 0380 	mov.w	r3, #128	; 0x80
    7ece:	f383 8811 	msr	BASEPRI, r3
    7ed2:	f3bf 8f6f 	isb	sy
    7ed6:	f3bf 8f4f 	dsb	sy
		xNextTaskUnblockTime = portMAX_DELAY;
    7eda:	4b10      	ldr	r3, [pc, #64]	; (7f1c <vTaskStartScheduler+0x78>)
    7edc:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
    7ee0:	62da      	str	r2, [r3, #44]	; 0x2c
		xSchedulerRunning    = pdTRUE;
    7ee2:	f8c3 00e0 	str.w	r0, [r3, #224]	; 0xe0
		xTickCount           = (TickType_t)0U;
    7ee6:	635c      	str	r4, [r3, #52]	; 0x34
		if (xPortStartScheduler() != pdFALSE) {
    7ee8:	4b0d      	ldr	r3, [pc, #52]	; (7f20 <vTaskStartScheduler+0x7c>)
}
    7eea:	b005      	add	sp, #20
    7eec:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
		if (xPortStartScheduler() != pdFALSE) {
    7ef0:	4718      	bx	r3
		configASSERT(xReturn);
    7ef2:	b940      	cbnz	r0, 7f06 <vTaskStartScheduler+0x62>
    7ef4:	f04f 0380 	mov.w	r3, #128	; 0x80
    7ef8:	f383 8811 	msr	BASEPRI, r3
    7efc:	f3bf 8f6f 	isb	sy
    7f00:	f3bf 8f4f 	dsb	sy
    7f04:	e7fe      	b.n	7f04 <vTaskStartScheduler+0x60>
}
    7f06:	b005      	add	sp, #20
    7f08:	bd30      	pop	{r4, r5, pc}
    7f0a:	bf00      	nop
    7f0c:	0000aa8d 	.word	0x0000aa8d
    7f10:	0000818d 	.word	0x0000818d
    7f14:	00007ce5 	.word	0x00007ce5
    7f18:	0000709d 	.word	0x0000709d
    7f1c:	20016214 	.word	0x20016214
    7f20:	00009001 	.word	0x00009001

00007f24 <vTaskSuspendAll>:
	++uxSchedulerSuspended;
    7f24:	4a03      	ldr	r2, [pc, #12]	; (7f34 <vTaskSuspendAll+0x10>)
    7f26:	f8d2 30f0 	ldr.w	r3, [r2, #240]	; 0xf0
    7f2a:	3301      	adds	r3, #1
    7f2c:	f8c2 30f0 	str.w	r3, [r2, #240]	; 0xf0
}
    7f30:	4770      	bx	lr
    7f32:	bf00      	nop
    7f34:	20016214 	.word	0x20016214

00007f38 <xTaskGetTickCount>:
		xTicks = xTickCount;
    7f38:	4b01      	ldr	r3, [pc, #4]	; (7f40 <xTaskGetTickCount+0x8>)
    7f3a:	6b58      	ldr	r0, [r3, #52]	; 0x34
}
    7f3c:	4770      	bx	lr
    7f3e:	bf00      	nop
    7f40:	20016214 	.word	0x20016214

00007f44 <xTaskIncrementTick>:
{
    7f44:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
	if (uxSchedulerSuspended == (UBaseType_t)pdFALSE) {
    7f48:	4c36      	ldr	r4, [pc, #216]	; (8024 <xTaskIncrementTick+0xe0>)
    7f4a:	f8d4 30f0 	ldr.w	r3, [r4, #240]	; 0xf0
    7f4e:	2b00      	cmp	r3, #0
    7f50:	d160      	bne.n	8014 <xTaskIncrementTick+0xd0>
		++xTickCount;
    7f52:	6b63      	ldr	r3, [r4, #52]	; 0x34
    7f54:	3301      	adds	r3, #1
    7f56:	6363      	str	r3, [r4, #52]	; 0x34
			const TickType_t xConstTickCount = xTickCount;
    7f58:	6b67      	ldr	r7, [r4, #52]	; 0x34
			if (xConstTickCount == (TickType_t)0U) {
    7f5a:	b9b7      	cbnz	r7, 7f8a <xTaskIncrementTick+0x46>
				taskSWITCH_DELAYED_LISTS();
    7f5c:	6aa3      	ldr	r3, [r4, #40]	; 0x28
    7f5e:	681b      	ldr	r3, [r3, #0]
    7f60:	b143      	cbz	r3, 7f74 <xTaskIncrementTick+0x30>
    7f62:	f04f 0380 	mov.w	r3, #128	; 0x80
    7f66:	f383 8811 	msr	BASEPRI, r3
    7f6a:	f3bf 8f6f 	isb	sy
    7f6e:	f3bf 8f4f 	dsb	sy
    7f72:	e7fe      	b.n	7f72 <xTaskIncrementTick+0x2e>
    7f74:	6aa3      	ldr	r3, [r4, #40]	; 0x28
    7f76:	6ba2      	ldr	r2, [r4, #56]	; 0x38
    7f78:	62a2      	str	r2, [r4, #40]	; 0x28
    7f7a:	63a3      	str	r3, [r4, #56]	; 0x38
    7f7c:	f8d4 30f4 	ldr.w	r3, [r4, #244]	; 0xf4
    7f80:	3301      	adds	r3, #1
    7f82:	f8c4 30f4 	str.w	r3, [r4, #244]	; 0xf4
    7f86:	4b28      	ldr	r3, [pc, #160]	; (8028 <xTaskIncrementTick+0xe4>)
    7f88:	4798      	blx	r3
			if (xConstTickCount >= xNextTaskUnblockTime) {
    7f8a:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
    7f8c:	42bb      	cmp	r3, r7
	BaseType_t xSwitchRequired = pdFALSE;
    7f8e:	f04f 0500 	mov.w	r5, #0
			if (xConstTickCount >= xNextTaskUnblockTime) {
    7f92:	d910      	bls.n	7fb6 <xTaskIncrementTick+0x72>
			if (listCURRENT_LIST_LENGTH(&(pxReadyTasksLists[pxCurrentTCB->uxPriority])) > (UBaseType_t)1) {
    7f94:	6b23      	ldr	r3, [r4, #48]	; 0x30
    7f96:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    7f98:	2214      	movs	r2, #20
    7f9a:	fb02 4303 	mla	r3, r2, r3, r4
    7f9e:	6c1b      	ldr	r3, [r3, #64]	; 0x40
				xSwitchRequired = pdTRUE;
    7fa0:	2b02      	cmp	r3, #2
    7fa2:	bf28      	it	cs
    7fa4:	2501      	movcs	r5, #1
		if (xYieldPending != pdFALSE) {
    7fa6:	f8d4 30fc 	ldr.w	r3, [r4, #252]	; 0xfc
			xSwitchRequired = pdTRUE;
    7faa:	2b00      	cmp	r3, #0
}
    7fac:	bf0c      	ite	eq
    7fae:	4628      	moveq	r0, r5
    7fb0:	2001      	movne	r0, #1
    7fb2:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
						(void)uxListRemove(&(pxTCB->xGenericListItem));
    7fb6:	f8df 8074 	ldr.w	r8, [pc, #116]	; 802c <xTaskIncrementTick+0xe8>
						prvAddTaskToReadyList(pxTCB);
    7fba:	f8df a074 	ldr.w	sl, [pc, #116]	; 8030 <xTaskIncrementTick+0xec>
    7fbe:	f8df 9074 	ldr.w	r9, [pc, #116]	; 8034 <xTaskIncrementTick+0xf0>
					if (listLIST_IS_EMPTY(pxDelayedTaskList) != pdFALSE) {
    7fc2:	6aa3      	ldr	r3, [r4, #40]	; 0x28
    7fc4:	681b      	ldr	r3, [r3, #0]
    7fc6:	b91b      	cbnz	r3, 7fd0 <xTaskIncrementTick+0x8c>
						xNextTaskUnblockTime = portMAX_DELAY;
    7fc8:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
							xNextTaskUnblockTime = xItemValue;
    7fcc:	62e3      	str	r3, [r4, #44]	; 0x2c
							break;
    7fce:	e7e1      	b.n	7f94 <xTaskIncrementTick+0x50>
						pxTCB      = (TCB_t *)listGET_OWNER_OF_HEAD_ENTRY(pxDelayedTaskList);
    7fd0:	6aa3      	ldr	r3, [r4, #40]	; 0x28
    7fd2:	68db      	ldr	r3, [r3, #12]
    7fd4:	68de      	ldr	r6, [r3, #12]
						xItemValue = listGET_LIST_ITEM_VALUE(&(pxTCB->xGenericListItem));
    7fd6:	6873      	ldr	r3, [r6, #4]
						if (xConstTickCount < xItemValue) {
    7fd8:	429f      	cmp	r7, r3
    7fda:	d3f7      	bcc.n	7fcc <xTaskIncrementTick+0x88>
						(void)uxListRemove(&(pxTCB->xGenericListItem));
    7fdc:	f106 0b04 	add.w	fp, r6, #4
    7fe0:	4658      	mov	r0, fp
    7fe2:	47c0      	blx	r8
						if (listLIST_ITEM_CONTAINER(&(pxTCB->xEventListItem)) != NULL) {
    7fe4:	6ab3      	ldr	r3, [r6, #40]	; 0x28
    7fe6:	b113      	cbz	r3, 7fee <xTaskIncrementTick+0xaa>
							(void)uxListRemove(&(pxTCB->xEventListItem));
    7fe8:	f106 0018 	add.w	r0, r6, #24
    7fec:	47c0      	blx	r8
						prvAddTaskToReadyList(pxTCB);
    7fee:	6af3      	ldr	r3, [r6, #44]	; 0x2c
    7ff0:	f8d4 20e8 	ldr.w	r2, [r4, #232]	; 0xe8
    7ff4:	2014      	movs	r0, #20
    7ff6:	4293      	cmp	r3, r2
    7ff8:	fb00 a003 	mla	r0, r0, r3, sl
    7ffc:	4659      	mov	r1, fp
    7ffe:	bf88      	it	hi
    8000:	f8c4 30e8 	strhi.w	r3, [r4, #232]	; 0xe8
    8004:	47c8      	blx	r9
							if (pxTCB->uxPriority >= pxCurrentTCB->uxPriority) {
    8006:	6b23      	ldr	r3, [r4, #48]	; 0x30
    8008:	6af2      	ldr	r2, [r6, #44]	; 0x2c
    800a:	6adb      	ldr	r3, [r3, #44]	; 0x2c
								xSwitchRequired = pdTRUE;
    800c:	429a      	cmp	r2, r3
    800e:	bf28      	it	cs
    8010:	2501      	movcs	r5, #1
    8012:	e7d6      	b.n	7fc2 <xTaskIncrementTick+0x7e>
		++uxPendedTicks;
    8014:	f8d4 30f8 	ldr.w	r3, [r4, #248]	; 0xf8
    8018:	3301      	adds	r3, #1
    801a:	f8c4 30f8 	str.w	r3, [r4, #248]	; 0xf8
	BaseType_t xSwitchRequired = pdFALSE;
    801e:	2500      	movs	r5, #0
    8020:	e7c1      	b.n	7fa6 <xTaskIncrementTick+0x62>
    8022:	bf00      	nop
    8024:	20016214 	.word	0x20016214
    8028:	00007c8d 	.word	0x00007c8d
    802c:	00001dfb 	.word	0x00001dfb
    8030:	20016254 	.word	0x20016254
    8034:	00001db5 	.word	0x00001db5

00008038 <xTaskResumeAll>:
{
    8038:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
	configASSERT(uxSchedulerSuspended);
    803c:	4c33      	ldr	r4, [pc, #204]	; (810c <xTaskResumeAll+0xd4>)
    803e:	f8d4 30f0 	ldr.w	r3, [r4, #240]	; 0xf0
    8042:	b943      	cbnz	r3, 8056 <xTaskResumeAll+0x1e>
    8044:	f04f 0380 	mov.w	r3, #128	; 0x80
    8048:	f383 8811 	msr	BASEPRI, r3
    804c:	f3bf 8f6f 	isb	sy
    8050:	f3bf 8f4f 	dsb	sy
    8054:	e7fe      	b.n	8054 <xTaskResumeAll+0x1c>
	taskENTER_CRITICAL();
    8056:	4b2e      	ldr	r3, [pc, #184]	; (8110 <xTaskResumeAll+0xd8>)
    8058:	4798      	blx	r3
		--uxSchedulerSuspended;
    805a:	f8d4 30f0 	ldr.w	r3, [r4, #240]	; 0xf0
    805e:	3b01      	subs	r3, #1
    8060:	f8c4 30f0 	str.w	r3, [r4, #240]	; 0xf0
		if (uxSchedulerSuspended == (UBaseType_t)pdFALSE) {
    8064:	f8d4 30f0 	ldr.w	r3, [r4, #240]	; 0xf0
    8068:	b133      	cbz	r3, 8078 <xTaskResumeAll+0x40>
	BaseType_t xAlreadyYielded = pdFALSE;
    806a:	2400      	movs	r4, #0
	taskEXIT_CRITICAL();
    806c:	4b29      	ldr	r3, [pc, #164]	; (8114 <xTaskResumeAll+0xdc>)
    806e:	4798      	blx	r3
}
    8070:	4620      	mov	r0, r4
    8072:	b002      	add	sp, #8
    8074:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
			if (uxCurrentNumberOfTasks > (UBaseType_t)0U) {
    8078:	6be3      	ldr	r3, [r4, #60]	; 0x3c
    807a:	2b00      	cmp	r3, #0
    807c:	d0f5      	beq.n	806a <xTaskResumeAll+0x32>
					(void)uxListRemove(&(pxTCB->xEventListItem));
    807e:	4e26      	ldr	r6, [pc, #152]	; (8118 <xTaskResumeAll+0xe0>)
					prvAddTaskToReadyList(pxTCB);
    8080:	f104 0740 	add.w	r7, r4, #64	; 0x40
    8084:	f8df 8098 	ldr.w	r8, [pc, #152]	; 8120 <xTaskResumeAll+0xe8>
				while (listLIST_IS_EMPTY(&xPendingReadyList) == pdFALSE) {
    8088:	6963      	ldr	r3, [r4, #20]
    808a:	b9b3      	cbnz	r3, 80ba <xTaskResumeAll+0x82>
				if (uxPendedTicks > (UBaseType_t)0U) {
    808c:	f8d4 30f8 	ldr.w	r3, [r4, #248]	; 0xf8
    8090:	b123      	cbz	r3, 809c <xTaskResumeAll+0x64>
						if (xTaskIncrementTick() != pdFALSE) {
    8092:	4d22      	ldr	r5, [pc, #136]	; (811c <xTaskResumeAll+0xe4>)
							xYieldPending = pdTRUE;
    8094:	2601      	movs	r6, #1
					while (uxPendedTicks > (UBaseType_t)0U) {
    8096:	f8d4 30f8 	ldr.w	r3, [r4, #248]	; 0xf8
    809a:	bb63      	cbnz	r3, 80f6 <xTaskResumeAll+0xbe>
				if (xYieldPending == pdTRUE) {
    809c:	f8d4 40fc 	ldr.w	r4, [r4, #252]	; 0xfc
    80a0:	2c01      	cmp	r4, #1
    80a2:	d1e2      	bne.n	806a <xTaskResumeAll+0x32>
					taskYIELD_IF_USING_PREEMPTION();
    80a4:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
    80a8:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
    80ac:	f8c3 2d04 	str.w	r2, [r3, #3332]	; 0xd04
    80b0:	f3bf 8f4f 	dsb	sy
    80b4:	f3bf 8f6f 	isb	sy
    80b8:	e7d8      	b.n	806c <xTaskResumeAll+0x34>
					pxTCB = (TCB_t *)listGET_OWNER_OF_HEAD_ENTRY((&xPendingReadyList));
    80ba:	6a23      	ldr	r3, [r4, #32]
    80bc:	68dd      	ldr	r5, [r3, #12]
					(void)uxListRemove(&(pxTCB->xEventListItem));
    80be:	f105 0018 	add.w	r0, r5, #24
    80c2:	47b0      	blx	r6
					(void)uxListRemove(&(pxTCB->xGenericListItem));
    80c4:	1d29      	adds	r1, r5, #4
    80c6:	4608      	mov	r0, r1
    80c8:	9101      	str	r1, [sp, #4]
    80ca:	47b0      	blx	r6
					prvAddTaskToReadyList(pxTCB);
    80cc:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
    80ce:	f8d4 20e8 	ldr.w	r2, [r4, #232]	; 0xe8
    80d2:	9901      	ldr	r1, [sp, #4]
    80d4:	2014      	movs	r0, #20
    80d6:	4293      	cmp	r3, r2
    80d8:	fb00 7003 	mla	r0, r0, r3, r7
    80dc:	bf88      	it	hi
    80de:	f8c4 30e8 	strhi.w	r3, [r4, #232]	; 0xe8
    80e2:	47c0      	blx	r8
					if (pxTCB->uxPriority >= pxCurrentTCB->uxPriority) {
    80e4:	6b23      	ldr	r3, [r4, #48]	; 0x30
    80e6:	6aea      	ldr	r2, [r5, #44]	; 0x2c
    80e8:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    80ea:	429a      	cmp	r2, r3
    80ec:	d3cc      	bcc.n	8088 <xTaskResumeAll+0x50>
						xYieldPending = pdTRUE;
    80ee:	2301      	movs	r3, #1
    80f0:	f8c4 30fc 	str.w	r3, [r4, #252]	; 0xfc
    80f4:	e7c6      	b.n	8084 <xTaskResumeAll+0x4c>
						if (xTaskIncrementTick() != pdFALSE) {
    80f6:	47a8      	blx	r5
    80f8:	b108      	cbz	r0, 80fe <xTaskResumeAll+0xc6>
							xYieldPending = pdTRUE;
    80fa:	f8c4 60fc 	str.w	r6, [r4, #252]	; 0xfc
						--uxPendedTicks;
    80fe:	f8d4 30f8 	ldr.w	r3, [r4, #248]	; 0xf8
    8102:	3b01      	subs	r3, #1
    8104:	f8c4 30f8 	str.w	r3, [r4, #248]	; 0xf8
    8108:	e7c5      	b.n	8096 <xTaskResumeAll+0x5e>
    810a:	bf00      	nop
    810c:	20016214 	.word	0x20016214
    8110:	00008ef5 	.word	0x00008ef5
    8114:	00008f35 	.word	0x00008f35
    8118:	00001dfb 	.word	0x00001dfb
    811c:	00007f45 	.word	0x00007f45
    8120:	00001db5 	.word	0x00001db5

00008124 <vTaskDelay>:
{
    8124:	b510      	push	{r4, lr}
	if (xTicksToDelay > (TickType_t)0U) {
    8126:	b950      	cbnz	r0, 813e <vTaskDelay+0x1a>
		portYIELD_WITHIN_API();
    8128:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
    812c:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
    8130:	f8c3 2d04 	str.w	r2, [r3, #3332]	; 0xd04
    8134:	f3bf 8f4f 	dsb	sy
    8138:	f3bf 8f6f 	isb	sy
}
    813c:	bd10      	pop	{r4, pc}
		configASSERT(uxSchedulerSuspended == 0);
    813e:	490e      	ldr	r1, [pc, #56]	; (8178 <vTaskDelay+0x54>)
    8140:	f8d1 30f0 	ldr.w	r3, [r1, #240]	; 0xf0
    8144:	b143      	cbz	r3, 8158 <vTaskDelay+0x34>
    8146:	f04f 0380 	mov.w	r3, #128	; 0x80
    814a:	f383 8811 	msr	BASEPRI, r3
    814e:	f3bf 8f6f 	isb	sy
    8152:	f3bf 8f4f 	dsb	sy
    8156:	e7fe      	b.n	8156 <vTaskDelay+0x32>
		vTaskSuspendAll();
    8158:	4b08      	ldr	r3, [pc, #32]	; (817c <vTaskDelay+0x58>)
    815a:	4798      	blx	r3
			xTimeToWake = xTickCount + xTicksToDelay;
    815c:	6b4c      	ldr	r4, [r1, #52]	; 0x34
			if (uxListRemove(&(pxCurrentTCB->xGenericListItem)) == (UBaseType_t)0) {
    815e:	4b08      	ldr	r3, [pc, #32]	; (8180 <vTaskDelay+0x5c>)
			xTimeToWake = xTickCount + xTicksToDelay;
    8160:	4404      	add	r4, r0
			if (uxListRemove(&(pxCurrentTCB->xGenericListItem)) == (UBaseType_t)0) {
    8162:	6b08      	ldr	r0, [r1, #48]	; 0x30
    8164:	3004      	adds	r0, #4
    8166:	4798      	blx	r3
			prvAddCurrentTaskToDelayedList(xTimeToWake);
    8168:	4b06      	ldr	r3, [pc, #24]	; (8184 <vTaskDelay+0x60>)
    816a:	4620      	mov	r0, r4
    816c:	4798      	blx	r3
		xAlreadyYielded = xTaskResumeAll();
    816e:	4b06      	ldr	r3, [pc, #24]	; (8188 <vTaskDelay+0x64>)
    8170:	4798      	blx	r3
	if (xAlreadyYielded == pdFALSE) {
    8172:	2800      	cmp	r0, #0
    8174:	d0d8      	beq.n	8128 <vTaskDelay+0x4>
    8176:	e7e1      	b.n	813c <vTaskDelay+0x18>
    8178:	20016214 	.word	0x20016214
    817c:	00007f25 	.word	0x00007f25
    8180:	00001dfb 	.word	0x00001dfb
    8184:	00007cad 	.word	0x00007cad
    8188:	00008039 	.word	0x00008039

0000818c <prvIdleTask>:
{
    818c:	b580      	push	{r7, lr}
		while (uxTasksDeleted > (UBaseType_t)0U) {
    818e:	4c19      	ldr	r4, [pc, #100]	; (81f4 <prvIdleTask+0x68>)
			vTaskSuspendAll();
    8190:	4f19      	ldr	r7, [pc, #100]	; (81f8 <prvIdleTask+0x6c>)
			(void)xTaskResumeAll();
    8192:	4d1a      	ldr	r5, [pc, #104]	; (81fc <prvIdleTask+0x70>)
		while (uxTasksDeleted > (UBaseType_t)0U) {
    8194:	f8d4 30ec 	ldr.w	r3, [r4, #236]	; 0xec
    8198:	b96b      	cbnz	r3, 81b6 <prvIdleTask+0x2a>
			if (listCURRENT_LIST_LENGTH(&(pxReadyTasksLists[tskIDLE_PRIORITY])) > (UBaseType_t)1) {
    819a:	6c23      	ldr	r3, [r4, #64]	; 0x40
    819c:	2b01      	cmp	r3, #1
    819e:	d9f8      	bls.n	8192 <prvIdleTask+0x6>
				taskYIELD();
    81a0:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
    81a4:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
    81a8:	f8c3 2d04 	str.w	r2, [r3, #3332]	; 0xd04
    81ac:	f3bf 8f4f 	dsb	sy
    81b0:	f3bf 8f6f 	isb	sy
    81b4:	e7ed      	b.n	8192 <prvIdleTask+0x6>
			vTaskSuspendAll();
    81b6:	47b8      	blx	r7
				xListIsEmpty = listLIST_IS_EMPTY(&xTasksWaitingTermination);
    81b8:	f8d4 60cc 	ldr.w	r6, [r4, #204]	; 0xcc
			(void)xTaskResumeAll();
    81bc:	47a8      	blx	r5
			if (xListIsEmpty == pdFALSE) {
    81be:	2e00      	cmp	r6, #0
    81c0:	d0e8      	beq.n	8194 <prvIdleTask+0x8>
				taskENTER_CRITICAL();
    81c2:	4b0f      	ldr	r3, [pc, #60]	; (8200 <prvIdleTask+0x74>)
		vPortFreeAligned(pxTCB->pxStack);
    81c4:	4e0f      	ldr	r6, [pc, #60]	; (8204 <prvIdleTask+0x78>)
				taskENTER_CRITICAL();
    81c6:	4798      	blx	r3
					pxTCB = (TCB_t *)listGET_OWNER_OF_HEAD_ENTRY((&xTasksWaitingTermination));
    81c8:	f8d4 30d8 	ldr.w	r3, [r4, #216]	; 0xd8
    81cc:	68dd      	ldr	r5, [r3, #12]
					(void)uxListRemove(&(pxTCB->xGenericListItem));
    81ce:	4b0e      	ldr	r3, [pc, #56]	; (8208 <prvIdleTask+0x7c>)
    81d0:	1d28      	adds	r0, r5, #4
    81d2:	4798      	blx	r3
					--uxCurrentNumberOfTasks;
    81d4:	6be3      	ldr	r3, [r4, #60]	; 0x3c
    81d6:	3b01      	subs	r3, #1
    81d8:	63e3      	str	r3, [r4, #60]	; 0x3c
					--uxTasksDeleted;
    81da:	f8d4 30ec 	ldr.w	r3, [r4, #236]	; 0xec
    81de:	3b01      	subs	r3, #1
    81e0:	f8c4 30ec 	str.w	r3, [r4, #236]	; 0xec
				taskEXIT_CRITICAL();
    81e4:	4b09      	ldr	r3, [pc, #36]	; (820c <prvIdleTask+0x80>)
    81e6:	4798      	blx	r3
		vPortFreeAligned(pxTCB->pxStack);
    81e8:	6b28      	ldr	r0, [r5, #48]	; 0x30
    81ea:	47b0      	blx	r6
	vPortFree(pxTCB);
    81ec:	4628      	mov	r0, r5
    81ee:	47b0      	blx	r6
}
    81f0:	e7cf      	b.n	8192 <prvIdleTask+0x6>
    81f2:	bf00      	nop
    81f4:	20016214 	.word	0x20016214
    81f8:	00007f25 	.word	0x00007f25
    81fc:	00008039 	.word	0x00008039
    8200:	00008ef5 	.word	0x00008ef5
    8204:	00001d51 	.word	0x00001d51
    8208:	00001dfb 	.word	0x00001dfb
    820c:	00008f35 	.word	0x00008f35

00008210 <vTaskSwitchContext>:
	if (uxSchedulerSuspended != (UBaseType_t)pdFALSE) {
    8210:	4b1b      	ldr	r3, [pc, #108]	; (8280 <vTaskSwitchContext+0x70>)
    8212:	f8d3 20f0 	ldr.w	r2, [r3, #240]	; 0xf0
{
    8216:	b530      	push	{r4, r5, lr}
	if (uxSchedulerSuspended != (UBaseType_t)pdFALSE) {
    8218:	b11a      	cbz	r2, 8222 <vTaskSwitchContext+0x12>
		xYieldPending = pdTRUE;
    821a:	2201      	movs	r2, #1
    821c:	f8c3 20fc 	str.w	r2, [r3, #252]	; 0xfc
}
    8220:	bd30      	pop	{r4, r5, pc}
		xYieldPending = pdFALSE;
    8222:	f8c3 20fc 	str.w	r2, [r3, #252]	; 0xfc
		taskSELECT_HIGHEST_PRIORITY_TASK();
    8226:	2214      	movs	r2, #20
    8228:	f8d3 10e8 	ldr.w	r1, [r3, #232]	; 0xe8
    822c:	fb02 3101 	mla	r1, r2, r1, r3
    8230:	6c09      	ldr	r1, [r1, #64]	; 0x40
    8232:	b199      	cbz	r1, 825c <vTaskSwitchContext+0x4c>
    8234:	f8d3 10e8 	ldr.w	r1, [r3, #232]	; 0xe8
    8238:	4d12      	ldr	r5, [pc, #72]	; (8284 <vTaskSwitchContext+0x74>)
    823a:	434a      	muls	r2, r1
    823c:	1898      	adds	r0, r3, r2
    823e:	442a      	add	r2, r5
    8240:	6c44      	ldr	r4, [r0, #68]	; 0x44
    8242:	6864      	ldr	r4, [r4, #4]
    8244:	6444      	str	r4, [r0, #68]	; 0x44
    8246:	4294      	cmp	r4, r2
    8248:	bf04      	itt	eq
    824a:	6862      	ldreq	r2, [r4, #4]
    824c:	6442      	streq	r2, [r0, #68]	; 0x44
    824e:	2214      	movs	r2, #20
    8250:	fb02 3101 	mla	r1, r2, r1, r3
    8254:	6c4a      	ldr	r2, [r1, #68]	; 0x44
    8256:	68d2      	ldr	r2, [r2, #12]
    8258:	631a      	str	r2, [r3, #48]	; 0x30
}
    825a:	e7e1      	b.n	8220 <vTaskSwitchContext+0x10>
		taskSELECT_HIGHEST_PRIORITY_TASK();
    825c:	f8d3 10e8 	ldr.w	r1, [r3, #232]	; 0xe8
    8260:	b941      	cbnz	r1, 8274 <vTaskSwitchContext+0x64>
    8262:	f04f 0380 	mov.w	r3, #128	; 0x80
    8266:	f383 8811 	msr	BASEPRI, r3
    826a:	f3bf 8f6f 	isb	sy
    826e:	f3bf 8f4f 	dsb	sy
    8272:	e7fe      	b.n	8272 <vTaskSwitchContext+0x62>
    8274:	f8d3 10e8 	ldr.w	r1, [r3, #232]	; 0xe8
    8278:	3901      	subs	r1, #1
    827a:	f8c3 10e8 	str.w	r1, [r3, #232]	; 0xe8
    827e:	e7d3      	b.n	8228 <vTaskSwitchContext+0x18>
    8280:	20016214 	.word	0x20016214
    8284:	2001625c 	.word	0x2001625c

00008288 <vTaskPlaceOnEventList>:
{
    8288:	b570      	push	{r4, r5, r6, lr}
    828a:	460d      	mov	r5, r1
	configASSERT(pxEventList);
    828c:	b940      	cbnz	r0, 82a0 <vTaskPlaceOnEventList+0x18>
    828e:	f04f 0380 	mov.w	r3, #128	; 0x80
    8292:	f383 8811 	msr	BASEPRI, r3
    8296:	f3bf 8f6f 	isb	sy
    829a:	f3bf 8f4f 	dsb	sy
    829e:	e7fe      	b.n	829e <vTaskPlaceOnEventList+0x16>
	vListInsert(pxEventList, &(pxCurrentTCB->xEventListItem));
    82a0:	4c0b      	ldr	r4, [pc, #44]	; (82d0 <vTaskPlaceOnEventList+0x48>)
    82a2:	4b0c      	ldr	r3, [pc, #48]	; (82d4 <vTaskPlaceOnEventList+0x4c>)
    82a4:	6b21      	ldr	r1, [r4, #48]	; 0x30
    82a6:	3118      	adds	r1, #24
    82a8:	4798      	blx	r3
	if (uxListRemove(&(pxCurrentTCB->xGenericListItem)) == (UBaseType_t)0) {
    82aa:	6b20      	ldr	r0, [r4, #48]	; 0x30
    82ac:	4b0a      	ldr	r3, [pc, #40]	; (82d8 <vTaskPlaceOnEventList+0x50>)
    82ae:	3004      	adds	r0, #4
    82b0:	4798      	blx	r3
		if (xTicksToWait == portMAX_DELAY) {
    82b2:	1c6b      	adds	r3, r5, #1
    82b4:	d106      	bne.n	82c4 <vTaskPlaceOnEventList+0x3c>
			vListInsertEnd(&xSuspendedTaskList, &(pxCurrentTCB->xGenericListItem));
    82b6:	6b21      	ldr	r1, [r4, #48]	; 0x30
    82b8:	4b08      	ldr	r3, [pc, #32]	; (82dc <vTaskPlaceOnEventList+0x54>)
    82ba:	4620      	mov	r0, r4
    82bc:	3104      	adds	r1, #4
}
    82be:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
			vListInsertEnd(&xSuspendedTaskList, &(pxCurrentTCB->xGenericListItem));
    82c2:	4718      	bx	r3
			xTimeToWake = xTickCount + xTicksToWait;
    82c4:	6b60      	ldr	r0, [r4, #52]	; 0x34
			prvAddCurrentTaskToDelayedList(xTimeToWake);
    82c6:	4b06      	ldr	r3, [pc, #24]	; (82e0 <vTaskPlaceOnEventList+0x58>)
    82c8:	4428      	add	r0, r5
}
    82ca:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
			prvAddCurrentTaskToDelayedList(xTimeToWake);
    82ce:	4718      	bx	r3
    82d0:	20016214 	.word	0x20016214
    82d4:	00001dcd 	.word	0x00001dcd
    82d8:	00001dfb 	.word	0x00001dfb
    82dc:	00001db5 	.word	0x00001db5
    82e0:	00007cad 	.word	0x00007cad

000082e4 <vTaskPlaceOnEventListRestricted>:
{
    82e4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    82e8:	460d      	mov	r5, r1
    82ea:	4616      	mov	r6, r2
	configASSERT(pxEventList);
    82ec:	b940      	cbnz	r0, 8300 <vTaskPlaceOnEventListRestricted+0x1c>
    82ee:	f04f 0380 	mov.w	r3, #128	; 0x80
    82f2:	f383 8811 	msr	BASEPRI, r3
    82f6:	f3bf 8f6f 	isb	sy
    82fa:	f3bf 8f4f 	dsb	sy
    82fe:	e7fe      	b.n	82fe <vTaskPlaceOnEventListRestricted+0x1a>
	vListInsertEnd(pxEventList, &(pxCurrentTCB->xEventListItem));
    8300:	4c0b      	ldr	r4, [pc, #44]	; (8330 <vTaskPlaceOnEventListRestricted+0x4c>)
    8302:	4f0c      	ldr	r7, [pc, #48]	; (8334 <vTaskPlaceOnEventListRestricted+0x50>)
    8304:	6b21      	ldr	r1, [r4, #48]	; 0x30
    8306:	3118      	adds	r1, #24
    8308:	47b8      	blx	r7
	if (uxListRemove(&(pxCurrentTCB->xGenericListItem)) == (UBaseType_t)0) {
    830a:	6b20      	ldr	r0, [r4, #48]	; 0x30
    830c:	4b0a      	ldr	r3, [pc, #40]	; (8338 <vTaskPlaceOnEventListRestricted+0x54>)
    830e:	3004      	adds	r0, #4
    8310:	4798      	blx	r3
		if (xWaitIndefinitely == pdTRUE) {
    8312:	2e01      	cmp	r6, #1
    8314:	d106      	bne.n	8324 <vTaskPlaceOnEventListRestricted+0x40>
			vListInsertEnd(&xSuspendedTaskList, &(pxCurrentTCB->xGenericListItem));
    8316:	6b21      	ldr	r1, [r4, #48]	; 0x30
    8318:	4620      	mov	r0, r4
    831a:	463b      	mov	r3, r7
    831c:	3104      	adds	r1, #4
}
    831e:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
			vListInsertEnd(&xSuspendedTaskList, &(pxCurrentTCB->xGenericListItem));
    8322:	4718      	bx	r3
			xTimeToWake = xTickCount + xTicksToWait;
    8324:	6b60      	ldr	r0, [r4, #52]	; 0x34
			prvAddCurrentTaskToDelayedList(xTimeToWake);
    8326:	4b05      	ldr	r3, [pc, #20]	; (833c <vTaskPlaceOnEventListRestricted+0x58>)
    8328:	4428      	add	r0, r5
}
    832a:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
			prvAddCurrentTaskToDelayedList(xTimeToWake);
    832e:	4718      	bx	r3
    8330:	20016214 	.word	0x20016214
    8334:	00001db5 	.word	0x00001db5
    8338:	00001dfb 	.word	0x00001dfb
    833c:	00007cad 	.word	0x00007cad

00008340 <xTaskRemoveFromEventList>:
	pxUnblockedTCB = (TCB_t *)listGET_OWNER_OF_HEAD_ENTRY(pxEventList);
    8340:	68c3      	ldr	r3, [r0, #12]
{
    8342:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
	pxUnblockedTCB = (TCB_t *)listGET_OWNER_OF_HEAD_ENTRY(pxEventList);
    8344:	68dd      	ldr	r5, [r3, #12]
	configASSERT(pxUnblockedTCB);
    8346:	b945      	cbnz	r5, 835a <xTaskRemoveFromEventList+0x1a>
    8348:	f04f 0380 	mov.w	r3, #128	; 0x80
    834c:	f383 8811 	msr	BASEPRI, r3
    8350:	f3bf 8f6f 	isb	sy
    8354:	f3bf 8f4f 	dsb	sy
    8358:	e7fe      	b.n	8358 <xTaskRemoveFromEventList+0x18>
	(void)uxListRemove(&(pxUnblockedTCB->xEventListItem));
    835a:	f105 0118 	add.w	r1, r5, #24
	if (uxSchedulerSuspended == (UBaseType_t)pdFALSE) {
    835e:	4c14      	ldr	r4, [pc, #80]	; (83b0 <xTaskRemoveFromEventList+0x70>)
	(void)uxListRemove(&(pxUnblockedTCB->xEventListItem));
    8360:	4f14      	ldr	r7, [pc, #80]	; (83b4 <xTaskRemoveFromEventList+0x74>)
    8362:	9101      	str	r1, [sp, #4]
    8364:	4608      	mov	r0, r1
    8366:	47b8      	blx	r7
	if (uxSchedulerSuspended == (UBaseType_t)pdFALSE) {
    8368:	f8d4 30f0 	ldr.w	r3, [r4, #240]	; 0xf0
    836c:	4e12      	ldr	r6, [pc, #72]	; (83b8 <xTaskRemoveFromEventList+0x78>)
    836e:	9901      	ldr	r1, [sp, #4]
    8370:	b9db      	cbnz	r3, 83aa <xTaskRemoveFromEventList+0x6a>
		(void)uxListRemove(&(pxUnblockedTCB->xGenericListItem));
    8372:	1d29      	adds	r1, r5, #4
    8374:	4608      	mov	r0, r1
    8376:	9101      	str	r1, [sp, #4]
    8378:	47b8      	blx	r7
		prvAddTaskToReadyList(pxUnblockedTCB);
    837a:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
    837c:	f8d4 20e8 	ldr.w	r2, [r4, #232]	; 0xe8
    8380:	9901      	ldr	r1, [sp, #4]
    8382:	4293      	cmp	r3, r2
    8384:	4a0d      	ldr	r2, [pc, #52]	; (83bc <xTaskRemoveFromEventList+0x7c>)
    8386:	bf88      	it	hi
    8388:	f8c4 30e8 	strhi.w	r3, [r4, #232]	; 0xe8
    838c:	2014      	movs	r0, #20
    838e:	fb00 2003 	mla	r0, r0, r3, r2
		vListInsertEnd(&(xPendingReadyList), &(pxUnblockedTCB->xEventListItem));
    8392:	47b0      	blx	r6
	if (pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority) {
    8394:	6b23      	ldr	r3, [r4, #48]	; 0x30
    8396:	6aea      	ldr	r2, [r5, #44]	; 0x2c
    8398:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    839a:	429a      	cmp	r2, r3
		xYieldPending = pdTRUE;
    839c:	bf8a      	itet	hi
    839e:	2001      	movhi	r0, #1
		xReturn = pdFALSE;
    83a0:	2000      	movls	r0, #0
		xYieldPending = pdTRUE;
    83a2:	f8c4 00fc 	strhi.w	r0, [r4, #252]	; 0xfc
}
    83a6:	b003      	add	sp, #12
    83a8:	bdf0      	pop	{r4, r5, r6, r7, pc}
		vListInsertEnd(&(xPendingReadyList), &(pxUnblockedTCB->xEventListItem));
    83aa:	f104 0014 	add.w	r0, r4, #20
    83ae:	e7f0      	b.n	8392 <xTaskRemoveFromEventList+0x52>
    83b0:	20016214 	.word	0x20016214
    83b4:	00001dfb 	.word	0x00001dfb
    83b8:	00001db5 	.word	0x00001db5
    83bc:	20016254 	.word	0x20016254

000083c0 <vTaskSetTimeOutState>:
	configASSERT(pxTimeOut);
    83c0:	b940      	cbnz	r0, 83d4 <vTaskSetTimeOutState+0x14>
    83c2:	f04f 0380 	mov.w	r3, #128	; 0x80
    83c6:	f383 8811 	msr	BASEPRI, r3
    83ca:	f3bf 8f6f 	isb	sy
    83ce:	f3bf 8f4f 	dsb	sy
    83d2:	e7fe      	b.n	83d2 <vTaskSetTimeOutState+0x12>
	pxTimeOut->xOverflowCount  = xNumOfOverflows;
    83d4:	4b03      	ldr	r3, [pc, #12]	; (83e4 <vTaskSetTimeOutState+0x24>)
    83d6:	f8d3 20f4 	ldr.w	r2, [r3, #244]	; 0xf4
	pxTimeOut->xTimeOnEntering = xTickCount;
    83da:	6b5b      	ldr	r3, [r3, #52]	; 0x34
	pxTimeOut->xOverflowCount  = xNumOfOverflows;
    83dc:	6002      	str	r2, [r0, #0]
	pxTimeOut->xTimeOnEntering = xTickCount;
    83de:	6043      	str	r3, [r0, #4]
}
    83e0:	4770      	bx	lr
    83e2:	bf00      	nop
    83e4:	20016214 	.word	0x20016214

000083e8 <xTaskCheckForTimeOut>:
{
    83e8:	b570      	push	{r4, r5, r6, lr}
    83ea:	460d      	mov	r5, r1
	configASSERT(pxTimeOut);
    83ec:	4604      	mov	r4, r0
    83ee:	b940      	cbnz	r0, 8402 <xTaskCheckForTimeOut+0x1a>
    83f0:	f04f 0380 	mov.w	r3, #128	; 0x80
    83f4:	f383 8811 	msr	BASEPRI, r3
    83f8:	f3bf 8f6f 	isb	sy
    83fc:	f3bf 8f4f 	dsb	sy
    8400:	e7fe      	b.n	8400 <xTaskCheckForTimeOut+0x18>
	configASSERT(pxTicksToWait);
    8402:	b941      	cbnz	r1, 8416 <xTaskCheckForTimeOut+0x2e>
    8404:	f04f 0380 	mov.w	r3, #128	; 0x80
    8408:	f383 8811 	msr	BASEPRI, r3
    840c:	f3bf 8f6f 	isb	sy
    8410:	f3bf 8f4f 	dsb	sy
    8414:	e7fe      	b.n	8414 <xTaskCheckForTimeOut+0x2c>
	taskENTER_CRITICAL();
    8416:	4b0f      	ldr	r3, [pc, #60]	; (8454 <xTaskCheckForTimeOut+0x6c>)
    8418:	4798      	blx	r3
		if (*pxTicksToWait == portMAX_DELAY) {
    841a:	682b      	ldr	r3, [r5, #0]
		const TickType_t xConstTickCount = xTickCount;
    841c:	4a0e      	ldr	r2, [pc, #56]	; (8458 <xTaskCheckForTimeOut+0x70>)
		if (*pxTicksToWait == portMAX_DELAY) {
    841e:	1c58      	adds	r0, r3, #1
		const TickType_t xConstTickCount = xTickCount;
    8420:	6b51      	ldr	r1, [r2, #52]	; 0x34
		if (*pxTicksToWait == portMAX_DELAY) {
    8422:	d010      	beq.n	8446 <xTaskCheckForTimeOut+0x5e>
		    if ((xNumOfOverflows != pxTimeOut->xOverflowCount)
    8424:	f8d2 00f4 	ldr.w	r0, [r2, #244]	; 0xf4
    8428:	e9d4 6200 	ldrd	r6, r2, [r4]
    842c:	4286      	cmp	r6, r0
    842e:	d001      	beq.n	8434 <xTaskCheckForTimeOut+0x4c>
		        && (xConstTickCount >= pxTimeOut->xTimeOnEntering)) /*lint !e525 Indentation preferred as is to make
    8430:	4291      	cmp	r1, r2
    8432:	d20d      	bcs.n	8450 <xTaskCheckForTimeOut+0x68>
		} else if ((xConstTickCount - pxTimeOut->xTimeOnEntering) < *pxTicksToWait) {
    8434:	1a88      	subs	r0, r1, r2
    8436:	4283      	cmp	r3, r0
    8438:	d90a      	bls.n	8450 <xTaskCheckForTimeOut+0x68>
			*pxTicksToWait -= (xConstTickCount - pxTimeOut->xTimeOnEntering);
    843a:	1a5b      	subs	r3, r3, r1
    843c:	4413      	add	r3, r2
    843e:	602b      	str	r3, [r5, #0]
			vTaskSetTimeOutState(pxTimeOut);
    8440:	4620      	mov	r0, r4
    8442:	4b06      	ldr	r3, [pc, #24]	; (845c <xTaskCheckForTimeOut+0x74>)
    8444:	4798      	blx	r3
			xReturn = pdFALSE;
    8446:	2400      	movs	r4, #0
	taskEXIT_CRITICAL();
    8448:	4b05      	ldr	r3, [pc, #20]	; (8460 <xTaskCheckForTimeOut+0x78>)
    844a:	4798      	blx	r3
}
    844c:	4620      	mov	r0, r4
    844e:	bd70      	pop	{r4, r5, r6, pc}
			xReturn = pdTRUE;
    8450:	2401      	movs	r4, #1
    8452:	e7f9      	b.n	8448 <xTaskCheckForTimeOut+0x60>
    8454:	00008ef5 	.word	0x00008ef5
    8458:	20016214 	.word	0x20016214
    845c:	000083c1 	.word	0x000083c1
    8460:	00008f35 	.word	0x00008f35

00008464 <vTaskMissedYield>:
	xYieldPending = pdTRUE;
    8464:	4b02      	ldr	r3, [pc, #8]	; (8470 <vTaskMissedYield+0xc>)
    8466:	2201      	movs	r2, #1
    8468:	f8c3 20fc 	str.w	r2, [r3, #252]	; 0xfc
}
    846c:	4770      	bx	lr
    846e:	bf00      	nop
    8470:	20016214 	.word	0x20016214

00008474 <xTaskGetSchedulerState>:

BaseType_t xTaskGetSchedulerState(void)
{
	BaseType_t xReturn;

	if (xSchedulerRunning == pdFALSE) {
    8474:	4b06      	ldr	r3, [pc, #24]	; (8490 <xTaskGetSchedulerState+0x1c>)
    8476:	f8d3 20e0 	ldr.w	r2, [r3, #224]	; 0xe0
    847a:	b132      	cbz	r2, 848a <xTaskGetSchedulerState+0x16>
		xReturn = taskSCHEDULER_NOT_STARTED;
	} else {
		if (uxSchedulerSuspended == (UBaseType_t)pdFALSE) {
    847c:	f8d3 30f0 	ldr.w	r3, [r3, #240]	; 0xf0
			xReturn = taskSCHEDULER_RUNNING;
		} else {
			xReturn = taskSCHEDULER_SUSPENDED;
    8480:	2b00      	cmp	r3, #0
    8482:	bf0c      	ite	eq
    8484:	2002      	moveq	r0, #2
    8486:	2000      	movne	r0, #0
    8488:	4770      	bx	lr
		xReturn = taskSCHEDULER_NOT_STARTED;
    848a:	2001      	movs	r0, #1
		}
	}

	return xReturn;
}
    848c:	4770      	bx	lr
    848e:	bf00      	nop
    8490:	20016214 	.word	0x20016214

00008494 <vTaskPriorityInherit>:
	/*-----------------------------------------------------------*/

#if (configUSE_MUTEXES == 1)

void vTaskPriorityInherit(TaskHandle_t const pxMutexHolder)
{
    8494:	b573      	push	{r0, r1, r4, r5, r6, lr}
	TCB_t *const pxTCB = (TCB_t *)pxMutexHolder;

	/* If the mutex was given back by an interrupt while the queue was
	locked then the mutex holder might now be NULL. */
	if (pxMutexHolder != NULL) {
    8496:	4604      	mov	r4, r0
    8498:	2800      	cmp	r0, #0
    849a:	d02c      	beq.n	84f6 <vTaskPriorityInherit+0x62>
		/* If the holder of the mutex has a priority below the priority of
		the task attempting to obtain the mutex then it will temporarily
		inherit the priority of the task attempting to obtain the mutex. */
		if (pxTCB->uxPriority < pxCurrentTCB->uxPriority) {
    849c:	4d18      	ldr	r5, [pc, #96]	; (8500 <vTaskPriorityInherit+0x6c>)
    849e:	6ac3      	ldr	r3, [r0, #44]	; 0x2c
    84a0:	6b2a      	ldr	r2, [r5, #48]	; 0x30
    84a2:	6ad2      	ldr	r2, [r2, #44]	; 0x2c
    84a4:	4293      	cmp	r3, r2
    84a6:	d226      	bcs.n	84f6 <vTaskPriorityInherit+0x62>
			/* Adjust the mutex holder state to account for its new
			priority.  Only reset the event list item value if the value is
			not	being used for anything else. */
			if ((listGET_LIST_ITEM_VALUE(&(pxTCB->xEventListItem)) & taskEVENT_LIST_ITEM_VALUE_IN_USE) == 0UL) {
    84a8:	6982      	ldr	r2, [r0, #24]
				mtCOVERAGE_TEST_MARKER();
			}

			/* If the task being modified is in the ready state it will need
			to be moved into a new list. */
			if (listIS_CONTAINED_WITHIN(&(pxReadyTasksLists[pxTCB->uxPriority]), &(pxTCB->xGenericListItem))
    84aa:	4e16      	ldr	r6, [pc, #88]	; (8504 <vTaskPriorityInherit+0x70>)
			if ((listGET_LIST_ITEM_VALUE(&(pxTCB->xEventListItem)) & taskEVENT_LIST_ITEM_VALUE_IN_USE) == 0UL) {
    84ac:	2a00      	cmp	r2, #0
				listSET_LIST_ITEM_VALUE(
    84ae:	bfa1      	itttt	ge
    84b0:	6b2a      	ldrge	r2, [r5, #48]	; 0x30
    84b2:	6ad2      	ldrge	r2, [r2, #44]	; 0x2c
    84b4:	f1c2 0205 	rsbge	r2, r2, #5
    84b8:	6182      	strge	r2, [r0, #24]
			if (listIS_CONTAINED_WITHIN(&(pxReadyTasksLists[pxTCB->uxPriority]), &(pxTCB->xGenericListItem))
    84ba:	2214      	movs	r2, #20
    84bc:	fb02 6303 	mla	r3, r2, r3, r6
			    != pdFALSE) {
    84c0:	6942      	ldr	r2, [r0, #20]
    84c2:	429a      	cmp	r2, r3
    84c4:	d114      	bne.n	84f0 <vTaskPriorityInherit+0x5c>
				if (uxListRemove(&(pxTCB->xGenericListItem)) == (UBaseType_t)0) {
    84c6:	1d01      	adds	r1, r0, #4
    84c8:	4b0f      	ldr	r3, [pc, #60]	; (8508 <vTaskPriorityInherit+0x74>)
    84ca:	9101      	str	r1, [sp, #4]
    84cc:	4608      	mov	r0, r1
    84ce:	4798      	blx	r3
				} else {
					mtCOVERAGE_TEST_MARKER();
				}

				/* Inherit the priority before being moved into the new list. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
    84d0:	6b2b      	ldr	r3, [r5, #48]	; 0x30
				prvAddTaskToReadyList(pxTCB);
    84d2:	f8d5 20e8 	ldr.w	r2, [r5, #232]	; 0xe8
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
    84d6:	6adb      	ldr	r3, [r3, #44]	; 0x2c
				prvAddTaskToReadyList(pxTCB);
    84d8:	9901      	ldr	r1, [sp, #4]
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
    84da:	62e3      	str	r3, [r4, #44]	; 0x2c
				prvAddTaskToReadyList(pxTCB);
    84dc:	4293      	cmp	r3, r2
    84de:	d80c      	bhi.n	84fa <vTaskPriorityInherit+0x66>
    84e0:	2014      	movs	r0, #20
    84e2:	fb00 6003 	mla	r0, r0, r3, r6
    84e6:	4b09      	ldr	r3, [pc, #36]	; (850c <vTaskPriorityInherit+0x78>)
			mtCOVERAGE_TEST_MARKER();
		}
	} else {
		mtCOVERAGE_TEST_MARKER();
	}
}
    84e8:	b002      	add	sp, #8
    84ea:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
				prvAddTaskToReadyList(pxTCB);
    84ee:	4718      	bx	r3
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
    84f0:	6b2b      	ldr	r3, [r5, #48]	; 0x30
    84f2:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    84f4:	62c3      	str	r3, [r0, #44]	; 0x2c
}
    84f6:	b002      	add	sp, #8
    84f8:	bd70      	pop	{r4, r5, r6, pc}
				prvAddTaskToReadyList(pxTCB);
    84fa:	f8c5 30e8 	str.w	r3, [r5, #232]	; 0xe8
    84fe:	e7ef      	b.n	84e0 <vTaskPriorityInherit+0x4c>
    8500:	20016214 	.word	0x20016214
    8504:	20016254 	.word	0x20016254
    8508:	00001dfb 	.word	0x00001dfb
    850c:	00001db5 	.word	0x00001db5

00008510 <xTaskPriorityDisinherit>:
	/*-----------------------------------------------------------*/

#if (configUSE_MUTEXES == 1)

BaseType_t xTaskPriorityDisinherit(TaskHandle_t const pxMutexHolder)
{
    8510:	b537      	push	{r0, r1, r2, r4, r5, lr}
	TCB_t *const pxTCB   = (TCB_t *)pxMutexHolder;
	BaseType_t   xReturn = pdFALSE;

	if (pxMutexHolder != NULL) {
    8512:	b910      	cbnz	r0, 851a <xTaskPriorityDisinherit+0xa>
	BaseType_t   xReturn = pdFALSE;
    8514:	2000      	movs	r0, #0
	} else {
		mtCOVERAGE_TEST_MARKER();
	}

	return xReturn;
}
    8516:	b003      	add	sp, #12
    8518:	bd30      	pop	{r4, r5, pc}
		configASSERT(pxTCB == pxCurrentTCB);
    851a:	4d1c      	ldr	r5, [pc, #112]	; (858c <xTaskPriorityDisinherit+0x7c>)
    851c:	6b2c      	ldr	r4, [r5, #48]	; 0x30
    851e:	4284      	cmp	r4, r0
    8520:	d008      	beq.n	8534 <xTaskPriorityDisinherit+0x24>
    8522:	f04f 0380 	mov.w	r3, #128	; 0x80
    8526:	f383 8811 	msr	BASEPRI, r3
    852a:	f3bf 8f6f 	isb	sy
    852e:	f3bf 8f4f 	dsb	sy
    8532:	e7fe      	b.n	8532 <xTaskPriorityDisinherit+0x22>
		configASSERT(pxTCB->uxMutexesHeld);
    8534:	6ca3      	ldr	r3, [r4, #72]	; 0x48
    8536:	b943      	cbnz	r3, 854a <xTaskPriorityDisinherit+0x3a>
    8538:	f04f 0380 	mov.w	r3, #128	; 0x80
    853c:	f383 8811 	msr	BASEPRI, r3
    8540:	f3bf 8f6f 	isb	sy
    8544:	f3bf 8f4f 	dsb	sy
    8548:	e7fe      	b.n	8548 <xTaskPriorityDisinherit+0x38>
		if (pxTCB->uxPriority != pxTCB->uxBasePriority) {
    854a:	6ae1      	ldr	r1, [r4, #44]	; 0x2c
    854c:	6c62      	ldr	r2, [r4, #68]	; 0x44
		(pxTCB->uxMutexesHeld)--;
    854e:	3b01      	subs	r3, #1
		if (pxTCB->uxPriority != pxTCB->uxBasePriority) {
    8550:	4291      	cmp	r1, r2
		(pxTCB->uxMutexesHeld)--;
    8552:	64a3      	str	r3, [r4, #72]	; 0x48
		if (pxTCB->uxPriority != pxTCB->uxBasePriority) {
    8554:	d0de      	beq.n	8514 <xTaskPriorityDisinherit+0x4>
			if (pxTCB->uxMutexesHeld == (UBaseType_t)0) {
    8556:	2b00      	cmp	r3, #0
    8558:	d1dc      	bne.n	8514 <xTaskPriorityDisinherit+0x4>
				if (uxListRemove(&(pxTCB->xGenericListItem)) == (UBaseType_t)0) {
    855a:	1d21      	adds	r1, r4, #4
    855c:	4b0c      	ldr	r3, [pc, #48]	; (8590 <xTaskPriorityDisinherit+0x80>)
    855e:	9101      	str	r1, [sp, #4]
    8560:	4608      	mov	r0, r1
    8562:	4798      	blx	r3
				pxTCB->uxPriority = pxTCB->uxBasePriority;
    8564:	6c63      	ldr	r3, [r4, #68]	; 0x44
    8566:	62e3      	str	r3, [r4, #44]	; 0x2c
				listSET_LIST_ITEM_VALUE(
    8568:	f1c3 0205 	rsb	r2, r3, #5
    856c:	61a2      	str	r2, [r4, #24]
				prvAddTaskToReadyList(pxTCB);
    856e:	f8d5 20e8 	ldr.w	r2, [r5, #232]	; 0xe8
    8572:	9901      	ldr	r1, [sp, #4]
    8574:	4293      	cmp	r3, r2
    8576:	4a07      	ldr	r2, [pc, #28]	; (8594 <xTaskPriorityDisinherit+0x84>)
    8578:	bf88      	it	hi
    857a:	f8c5 30e8 	strhi.w	r3, [r5, #232]	; 0xe8
    857e:	2014      	movs	r0, #20
    8580:	fb00 2003 	mla	r0, r0, r3, r2
    8584:	4b04      	ldr	r3, [pc, #16]	; (8598 <xTaskPriorityDisinherit+0x88>)
    8586:	4798      	blx	r3
				xReturn = pdTRUE;
    8588:	2001      	movs	r0, #1
	return xReturn;
    858a:	e7c4      	b.n	8516 <xTaskPriorityDisinherit+0x6>
    858c:	20016214 	.word	0x20016214
    8590:	00001dfb 	.word	0x00001dfb
    8594:	20016254 	.word	0x20016254
    8598:	00001db5 	.word	0x00001db5

0000859c <pvTaskIncrementMutexHeldCount>:

void *pvTaskIncrementMutexHeldCount(void)
{
	/* If xSemaphoreCreateMutex() is called before any tasks have been created
	then pxCurrentTCB will be NULL. */
	if (pxCurrentTCB != NULL) {
    859c:	4b04      	ldr	r3, [pc, #16]	; (85b0 <pvTaskIncrementMutexHeldCount+0x14>)
    859e:	6b1a      	ldr	r2, [r3, #48]	; 0x30
    85a0:	b11a      	cbz	r2, 85aa <pvTaskIncrementMutexHeldCount+0xe>
		(pxCurrentTCB->uxMutexesHeld)++;
    85a2:	6b19      	ldr	r1, [r3, #48]	; 0x30
    85a4:	6c8a      	ldr	r2, [r1, #72]	; 0x48
    85a6:	3201      	adds	r2, #1
    85a8:	648a      	str	r2, [r1, #72]	; 0x48
	}

	return pxCurrentTCB;
    85aa:	6b18      	ldr	r0, [r3, #48]	; 0x30
}
    85ac:	4770      	bx	lr
    85ae:	bf00      	nop
    85b0:	20016214 	.word	0x20016214

000085b4 <get_socket>:
 */
static struct lwip_sock *get_socket(int s)
{
	struct lwip_sock *sock;

	if ((s < 0) || (s >= NUM_SOCKETS)) {
    85b4:	2803      	cmp	r0, #3
    85b6:	d808      	bhi.n	85ca <get_socket+0x16>
		LWIP_DEBUGF(SOCKETS_DEBUG, ("get_socket(%d): invalid\n", s));
		set_errno(EBADF);
		return NULL;
	}

	sock = &sockets[s];
    85b8:	2318      	movs	r3, #24
    85ba:	4a05      	ldr	r2, [pc, #20]	; (85d0 <get_socket+0x1c>)
    85bc:	4343      	muls	r3, r0
    85be:	18d0      	adds	r0, r2, r3

	if (!sock->conn) {
    85c0:	58d3      	ldr	r3, [r2, r3]
		return NULL;
    85c2:	2b00      	cmp	r3, #0
    85c4:	bf08      	it	eq
    85c6:	2000      	moveq	r0, #0
    85c8:	4770      	bx	lr
    85ca:	2000      	movs	r0, #0
		set_errno(EBADF);
		return NULL;
	}

	return sock;
}
    85cc:	4770      	bx	lr
    85ce:	bf00      	nop
    85d0:	20016314 	.word	0x20016314

000085d4 <alloc_socket>:

	/* allocate a new socket identifier */
	for (i = 0; i < NUM_SOCKETS; ++i) {
		/* Protect socket array */
		SYS_ARCH_PROTECT(lev);
		if (!sockets[i].conn) {
    85d4:	4b0d      	ldr	r3, [pc, #52]	; (860c <alloc_socket+0x38>)
{
    85d6:	b570      	push	{r4, r5, r6, lr}
    85d8:	4604      	mov	r4, r0
		if (!sockets[i].conn) {
    85da:	2618      	movs	r6, #24
	for (i = 0; i < NUM_SOCKETS; ++i) {
    85dc:	2000      	movs	r0, #0
		if (!sockets[i].conn) {
    85de:	fb06 f500 	mul.w	r5, r6, r0
    85e2:	58ea      	ldr	r2, [r5, r3]
    85e4:	b962      	cbnz	r2, 8600 <alloc_socket+0x2c>
			sockets[i].conn = newconn;
    85e6:	195e      	adds	r6, r3, r5
    85e8:	515c      	str	r4, [r3, r5]
			/* The socket is not yet known to anyone, so no need to protect
			   after having marked it as used. */
			SYS_ARCH_UNPROTECT(lev);
			sockets[i].lastdata   = NULL;
			sockets[i].lastoffset = 0;
    85ea:	e9c6 2201 	strd	r2, r2, [r6, #4]
			sockets[i].rcvevent   = 0;
			/* TCP sendbuf is empty, but the socket is not yet writable until connected
			 * (unless it has been created by accept()). */
			sockets[i].sendevent      = (newconn->type == NETCONN_TCP ? (accepted != 0) : 1);
    85ee:	7824      	ldrb	r4, [r4, #0]
			sockets[i].errevent       = 0;
    85f0:	81f2      	strh	r2, [r6, #14]
			sockets[i].sendevent      = (newconn->type == NETCONN_TCP ? (accepted != 0) : 1);
    85f2:	2c10      	cmp	r4, #16
			sockets[i].err            = 0;
			sockets[i].select_waiting = 0;
    85f4:	e9c6 2204 	strd	r2, r2, [r6, #16]
			sockets[i].sendevent      = (newconn->type == NETCONN_TCP ? (accepted != 0) : 1);
    85f8:	bf18      	it	ne
    85fa:	2101      	movne	r1, #1
    85fc:	81b1      	strh	r1, [r6, #12]
			return i;
		}
		SYS_ARCH_UNPROTECT(lev);
	}
	return -1;
}
    85fe:	bd70      	pop	{r4, r5, r6, pc}
	for (i = 0; i < NUM_SOCKETS; ++i) {
    8600:	3001      	adds	r0, #1
    8602:	2804      	cmp	r0, #4
    8604:	d1eb      	bne.n	85de <alloc_socket+0xa>
	return -1;
    8606:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    860a:	e7f8      	b.n	85fe <alloc_socket+0x2a>
    860c:	20016314 	.word	0x20016314

00008610 <event_callback>:
/**
 * Callback registered in the netconn layer for each socket-netconn.
 * Processes recvevent (data available) and wakes up tasks waiting for select.
 */
static void event_callback(struct netconn *conn, enum netconn_evt evt, u16_t len)
{
    8610:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
	SYS_ARCH_DECL_PROTECT(lev);

	LWIP_UNUSED_ARG(len);

	/* Get socket */
	if (conn) {
    8614:	b128      	cbz	r0, 8622 <event_callback+0x12>
		s = conn->socket;
    8616:	6985      	ldr	r5, [r0, #24]
		if (s < 0) {
    8618:	2d00      	cmp	r5, #0
    861a:	da04      	bge.n	8626 <event_callback+0x16>
			 * Just count down (or up) if that's the case and we
			 * will use the data later. Note that only receive events
			 * can happen before the new socket is set up. */
			SYS_ARCH_PROTECT(lev);
			if (conn->socket < 0) {
				if (evt == NETCONN_EVT_RCVPLUS) {
    861c:	b909      	cbnz	r1, 8622 <event_callback+0x12>
					conn->socket--;
    861e:	3d01      	subs	r5, #1
    8620:	6185      	str	r5, [r0, #24]
			/* someone has changed select_cb_list, restart at the beginning */
			goto again;
		}
	}
	SYS_ARCH_UNPROTECT(lev);
}
    8622:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
		sock = get_socket(s);
    8626:	4b30      	ldr	r3, [pc, #192]	; (86e8 <event_callback+0xd8>)
    8628:	4628      	mov	r0, r5
    862a:	4798      	blx	r3
		if (!sock) {
    862c:	4604      	mov	r4, r0
    862e:	2800      	cmp	r0, #0
    8630:	d0f7      	beq.n	8622 <event_callback+0x12>
	switch (evt) {
    8632:	2904      	cmp	r1, #4
    8634:	d807      	bhi.n	8646 <event_callback+0x36>
    8636:	e8df f001 	tbb	[pc, r1]
    863a:	4303      	.short	0x4303
    863c:	4946      	.short	0x4946
    863e:	4b          	.byte	0x4b
    863f:	00          	.byte	0x00
		sock->rcvevent++;
    8640:	8943      	ldrh	r3, [r0, #10]
    8642:	3301      	adds	r3, #1
		sock->rcvevent--;
    8644:	8163      	strh	r3, [r4, #10]
	if (sock->select_waiting == 0) {
    8646:	6963      	ldr	r3, [r4, #20]
    8648:	2b00      	cmp	r3, #0
    864a:	d0ea      	beq.n	8622 <event_callback+0x12>
				if (scb->readset && FD_ISSET(s, scb->readset)) {
    864c:	116f      	asrs	r7, r5, #5
    864e:	f04f 0801 	mov.w	r8, #1
				if (!do_signal && scb->exceptset && FD_ISSET(s, scb->exceptset)) {
    8652:	f005 051f 	and.w	r5, r5, #31
	for (scb = select_cb_list; scb != NULL; scb = scb->next) {
    8656:	f8df 9094 	ldr.w	r9, [pc, #148]	; 86ec <event_callback+0xdc>
				sys_sem_signal(&scb->sem);
    865a:	f8df b094 	ldr.w	fp, [pc, #148]	; 86f0 <event_callback+0xe0>
    865e:	fa08 f805 	lsl.w	r8, r8, r5
	for (scb = select_cb_list; scb != NULL; scb = scb->next) {
    8662:	f8d9 6060 	ldr.w	r6, [r9, #96]	; 0x60
				scb->sem_signalled = 1;
    8666:	f04f 0a01 	mov.w	sl, #1
	for (scb = select_cb_list; scb != NULL; scb = scb->next) {
    866a:	2e00      	cmp	r6, #0
    866c:	d0d9      	beq.n	8622 <event_callback+0x12>
		if (scb->sem_signalled == 0) {
    866e:	6973      	ldr	r3, [r6, #20]
    8670:	b9f3      	cbnz	r3, 86b0 <event_callback+0xa0>
			if (sock->rcvevent > 0) {
    8672:	f9b4 200a 	ldrsh.w	r2, [r4, #10]
    8676:	2a00      	cmp	r2, #0
    8678:	dd06      	ble.n	8688 <event_callback+0x78>
				if (scb->readset && FD_ISSET(s, scb->readset)) {
    867a:	68b2      	ldr	r2, [r6, #8]
    867c:	b122      	cbz	r2, 8688 <event_callback+0x78>
    867e:	f852 3027 	ldr.w	r3, [r2, r7, lsl #2]
    8682:	40eb      	lsrs	r3, r5
    8684:	f003 0301 	and.w	r3, r3, #1
			if (sock->sendevent != 0) {
    8688:	89a2      	ldrh	r2, [r4, #12]
    868a:	b13a      	cbz	r2, 869c <event_callback+0x8c>
				if (!do_signal && scb->writeset && FD_ISSET(s, scb->writeset)) {
    868c:	b933      	cbnz	r3, 869c <event_callback+0x8c>
    868e:	68f2      	ldr	r2, [r6, #12]
    8690:	b122      	cbz	r2, 869c <event_callback+0x8c>
    8692:	f852 3027 	ldr.w	r3, [r2, r7, lsl #2]
    8696:	40eb      	lsrs	r3, r5
    8698:	f003 0301 	and.w	r3, r3, #1
			if (sock->errevent != 0) {
    869c:	89e2      	ldrh	r2, [r4, #14]
    869e:	b1d2      	cbz	r2, 86d6 <event_callback+0xc6>
				if (!do_signal && scb->exceptset && FD_ISSET(s, scb->exceptset)) {
    86a0:	b9db      	cbnz	r3, 86da <event_callback+0xca>
    86a2:	6933      	ldr	r3, [r6, #16]
    86a4:	b123      	cbz	r3, 86b0 <event_callback+0xa0>
    86a6:	f853 3027 	ldr.w	r3, [r3, r7, lsl #2]
    86aa:	ea18 0f03 	tst.w	r8, r3
    86ae:	d114      	bne.n	86da <event_callback+0xca>
		last_select_cb_ctr = select_cb_ctr;
    86b0:	f8d9 3064 	ldr.w	r3, [r9, #100]	; 0x64
		if (last_select_cb_ctr != select_cb_ctr) {
    86b4:	f8d9 2064 	ldr.w	r2, [r9, #100]	; 0x64
    86b8:	429a      	cmp	r2, r3
    86ba:	d1d2      	bne.n	8662 <event_callback+0x52>
	for (scb = select_cb_list; scb != NULL; scb = scb->next) {
    86bc:	6836      	ldr	r6, [r6, #0]
    86be:	e7d4      	b.n	866a <event_callback+0x5a>
		sock->rcvevent--;
    86c0:	8943      	ldrh	r3, [r0, #10]
    86c2:	3b01      	subs	r3, #1
    86c4:	e7be      	b.n	8644 <event_callback+0x34>
		sock->sendevent = 1;
    86c6:	2301      	movs	r3, #1
		sock->sendevent = 0;
    86c8:	81a3      	strh	r3, [r4, #12]
		break;
    86ca:	e7bc      	b.n	8646 <event_callback+0x36>
		sock->sendevent = 0;
    86cc:	2300      	movs	r3, #0
    86ce:	e7fb      	b.n	86c8 <event_callback+0xb8>
		sock->errevent = 1;
    86d0:	2301      	movs	r3, #1
    86d2:	81c3      	strh	r3, [r0, #14]
		break;
    86d4:	e7b7      	b.n	8646 <event_callback+0x36>
			if (do_signal) {
    86d6:	2b00      	cmp	r3, #0
    86d8:	d0ea      	beq.n	86b0 <event_callback+0xa0>
				scb->sem_signalled = 1;
    86da:	f8c6 a014 	str.w	sl, [r6, #20]
				sys_sem_signal(&scb->sem);
    86de:	f106 0018 	add.w	r0, r6, #24
    86e2:	47d8      	blx	fp
    86e4:	e7e4      	b.n	86b0 <event_callback+0xa0>
    86e6:	bf00      	nop
    86e8:	000085b5 	.word	0x000085b5
    86ec:	20016314 	.word	0x20016314
    86f0:	00006aad 	.word	0x00006aad

000086f4 <lwip_setsockopt_internal>:
	sock = data->sock;
#ifdef LWIP_DEBUG
	s = data->s;
#endif /* LWIP_DEBUG */
	level   = data->level;
	optname = data->optname;
    86f4:	e9d0 1301 	ldrd	r1, r3, [r0, #4]
	optval  = data->optval;
    86f8:	68c2      	ldr	r2, [r0, #12]
		case SO_REUSEADDR:
		case SO_REUSEPORT:
#endif      /* SO_REUSE */
			/* UNIMPL case SO_USELOOPBACK: */
			if (*(int *)optval) {
				ip_set_option(sock->conn->pcb.ip, optname);
    86fa:	6800      	ldr	r0, [r0, #0]
	switch (level) {
    86fc:	2906      	cmp	r1, #6
{
    86fe:	b410      	push	{r4}
				ip_set_option(sock->conn->pcb.ip, optname);
    8700:	6800      	ldr	r0, [r0, #0]
	switch (level) {
    8702:	d032      	beq.n	876a <lwip_setsockopt_internal+0x76>
    8704:	f640 74ff 	movw	r4, #4095	; 0xfff
    8708:	42a1      	cmp	r1, r4
    870a:	d008      	beq.n	871e <lwip_setsockopt_internal+0x2a>
    870c:	b9b1      	cbnz	r1, 873c <lwip_setsockopt_internal+0x48>
		} /* switch (optname) */
		break;

		/* Level: IPPROTO_IP */
	case IPPROTO_IP:
		switch (optname) {
    870e:	2b01      	cmp	r3, #1
    8710:	d027      	beq.n	8762 <lwip_setsockopt_internal+0x6e>
    8712:	2b02      	cmp	r3, #2
    8714:	d112      	bne.n	873c <lwip_setsockopt_internal+0x48>
		case IP_TTL:
			sock->conn->pcb.ip->ttl = (u8_t)(*(int *)optval);
    8716:	6843      	ldr	r3, [r0, #4]
    8718:	6812      	ldr	r2, [r2, #0]
    871a:	729a      	strb	r2, [r3, #10]
			LWIP_DEBUGF(SOCKETS_DEBUG,
			            ("lwip_setsockopt(%d, IPPROTO_IP, IP_TTL, ..) -> %d\n", s, sock->conn->pcb.ip->ttl));
			break;
    871c:	e00e      	b.n	873c <lwip_setsockopt_internal+0x48>
		switch (optname) {
    871e:	2b20      	cmp	r3, #32
    8720:	d005      	beq.n	872e <lwip_setsockopt_internal+0x3a>
    8722:	f241 010a 	movw	r1, #4106	; 0x100a
    8726:	428b      	cmp	r3, r1
    8728:	d010      	beq.n	874c <lwip_setsockopt_internal+0x58>
    872a:	2b08      	cmp	r3, #8
    872c:	d106      	bne.n	873c <lwip_setsockopt_internal+0x48>
				ip_set_option(sock->conn->pcb.ip, optname);
    872e:	6841      	ldr	r1, [r0, #4]
			if (*(int *)optval) {
    8730:	6814      	ldr	r4, [r2, #0]
    8732:	7a0a      	ldrb	r2, [r1, #8]
				ip_set_option(sock->conn->pcb.ip, optname);
    8734:	b25b      	sxtb	r3, r3
			if (*(int *)optval) {
    8736:	b134      	cbz	r4, 8746 <lwip_setsockopt_internal+0x52>
				ip_set_option(sock->conn->pcb.ip, optname);
    8738:	4313      	orrs	r3, r2
				ip_reset_option(sock->conn->pcb.ip, optname);
    873a:	720b      	strb	r3, [r1, #8]
#endif /* LWIP_UDP */
	default:
		LWIP_ASSERT("unhandled level", 0);
		break;
	} /* switch (level) */
	sys_sem_signal(&sock->conn->op_completed);
    873c:	4b15      	ldr	r3, [pc, #84]	; (8794 <lwip_setsockopt_internal+0xa0>)
}
    873e:	f85d 4b04 	ldr.w	r4, [sp], #4
	sys_sem_signal(&sock->conn->op_completed);
    8742:	300c      	adds	r0, #12
    8744:	4718      	bx	r3
				ip_reset_option(sock->conn->pcb.ip, optname);
    8746:	ea22 0303 	bic.w	r3, r2, r3
    874a:	e7f6      	b.n	873a <lwip_setsockopt_internal+0x46>
				ip_set_option(sock->conn->pcb.ip, optname);
    874c:	6841      	ldr	r1, [r0, #4]
			if (*(int *)optval) {
    874e:	6812      	ldr	r2, [r2, #0]
				udp_setflags(sock->conn->pcb.udp, udp_flags(sock->conn->pcb.udp) | UDP_FLAGS_NOCHKSUM);
    8750:	7c0b      	ldrb	r3, [r1, #16]
			if (*(int *)optval) {
    8752:	b11a      	cbz	r2, 875c <lwip_setsockopt_internal+0x68>
				udp_setflags(sock->conn->pcb.udp, udp_flags(sock->conn->pcb.udp) | UDP_FLAGS_NOCHKSUM);
    8754:	f043 0301 	orr.w	r3, r3, #1
				udp_setflags(sock->conn->pcb.udp, udp_flags(sock->conn->pcb.udp) & ~UDP_FLAGS_NOCHKSUM);
    8758:	740b      	strb	r3, [r1, #16]
    875a:	e7ef      	b.n	873c <lwip_setsockopt_internal+0x48>
    875c:	f023 0301 	bic.w	r3, r3, #1
    8760:	e7fa      	b.n	8758 <lwip_setsockopt_internal+0x64>
			sock->conn->pcb.ip->tos = (u8_t)(*(int *)optval);
    8762:	6843      	ldr	r3, [r0, #4]
    8764:	6812      	ldr	r2, [r2, #0]
    8766:	725a      	strb	r2, [r3, #9]
			break;
    8768:	e7e8      	b.n	873c <lwip_setsockopt_internal+0x48>
		switch (optname) {
    876a:	2b01      	cmp	r3, #1
    876c:	d006      	beq.n	877c <lwip_setsockopt_internal+0x88>
    876e:	2b02      	cmp	r3, #2
    8770:	d1e4      	bne.n	873c <lwip_setsockopt_internal+0x48>
			sock->conn->pcb.tcp->keep_idle = (u32_t)(*(int *)optval);
    8772:	6843      	ldr	r3, [r0, #4]
    8774:	6812      	ldr	r2, [r2, #0]
    8776:	f8c3 2090 	str.w	r2, [r3, #144]	; 0x90
			break;
    877a:	e7df      	b.n	873c <lwip_setsockopt_internal+0x48>
				ip_set_option(sock->conn->pcb.ip, optname);
    877c:	6841      	ldr	r1, [r0, #4]
			if (*(int *)optval) {
    877e:	6812      	ldr	r2, [r2, #0]
				tcp_nagle_disable(sock->conn->pcb.tcp);
    8780:	7f8b      	ldrb	r3, [r1, #30]
			if (*(int *)optval) {
    8782:	b11a      	cbz	r2, 878c <lwip_setsockopt_internal+0x98>
				tcp_nagle_disable(sock->conn->pcb.tcp);
    8784:	f043 0340 	orr.w	r3, r3, #64	; 0x40
				tcp_nagle_enable(sock->conn->pcb.tcp);
    8788:	778b      	strb	r3, [r1, #30]
    878a:	e7d7      	b.n	873c <lwip_setsockopt_internal+0x48>
    878c:	f023 0340 	bic.w	r3, r3, #64	; 0x40
    8790:	e7fa      	b.n	8788 <lwip_setsockopt_internal+0x94>
    8792:	bf00      	nop
    8794:	00006aad 	.word	0x00006aad

00008798 <lwip_socket_init>:
}
    8798:	4770      	bx	lr
	...

0000879c <lwip_accept>:
{
    879c:	b5f0      	push	{r4, r5, r6, r7, lr}
	sock = get_socket(s);
    879e:	4b3a      	ldr	r3, [pc, #232]	; (8888 <lwip_accept+0xec>)
{
    87a0:	b089      	sub	sp, #36	; 0x24
    87a2:	4616      	mov	r6, r2
	sock = get_socket(s);
    87a4:	4798      	blx	r3
{
    87a6:	460f      	mov	r7, r1
	if (!sock) {
    87a8:	4605      	mov	r5, r0
    87aa:	b148      	cbz	r0, 87c0 <lwip_accept+0x24>
	if (netconn_is_nonblocking(sock->conn) && (sock->rcvevent <= 0)) {
    87ac:	6800      	ldr	r0, [r0, #0]
    87ae:	7f03      	ldrb	r3, [r0, #28]
    87b0:	079a      	lsls	r2, r3, #30
    87b2:	d508      	bpl.n	87c6 <lwip_accept+0x2a>
    87b4:	f9b5 300a 	ldrsh.w	r3, [r5, #10]
    87b8:	2b00      	cmp	r3, #0
    87ba:	dc04      	bgt.n	87c6 <lwip_accept+0x2a>
		sock_set_errno(sock, EWOULDBLOCK);
    87bc:	230b      	movs	r3, #11
		sock_set_errno(sock, err_to_errno(err));
    87be:	612b      	str	r3, [r5, #16]
		return -1;
    87c0:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
    87c4:	e00a      	b.n	87dc <lwip_accept+0x40>
	err = netconn_accept(sock->conn, &newconn);
    87c6:	4b31      	ldr	r3, [pc, #196]	; (888c <lwip_accept+0xf0>)
    87c8:	a902      	add	r1, sp, #8
    87ca:	4798      	blx	r3
	if (err != ERR_OK) {
    87cc:	4603      	mov	r3, r0
    87ce:	b178      	cbz	r0, 87f0 <lwip_accept+0x54>
		if (netconn_type(sock->conn) != NETCONN_TCP) {
    87d0:	682a      	ldr	r2, [r5, #0]
    87d2:	7812      	ldrb	r2, [r2, #0]
    87d4:	2a10      	cmp	r2, #16
    87d6:	d004      	beq.n	87e2 <lwip_accept+0x46>
			sock_set_errno(sock, EOPNOTSUPP);
    87d8:	245f      	movs	r4, #95	; 0x5f
    87da:	612c      	str	r4, [r5, #16]
}
    87dc:	4620      	mov	r0, r4
    87de:	b009      	add	sp, #36	; 0x24
    87e0:	bdf0      	pop	{r4, r5, r6, r7, pc}
		sock_set_errno(sock, err_to_errno(err));
    87e2:	4243      	negs	r3, r0
    87e4:	2b0f      	cmp	r3, #15
    87e6:	d819      	bhi.n	881c <lwip_accept+0x80>
    87e8:	4a29      	ldr	r2, [pc, #164]	; (8890 <lwip_accept+0xf4>)
    87ea:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    87ee:	e7e6      	b.n	87be <lwip_accept+0x22>
	netconn_set_noautorecved(newconn, 1);
    87f0:	9802      	ldr	r0, [sp, #8]
	err = netconn_peer(newconn, &naddr, &port);
    87f2:	4c28      	ldr	r4, [pc, #160]	; (8894 <lwip_accept+0xf8>)
	netconn_set_noautorecved(newconn, 1);
    87f4:	7f02      	ldrb	r2, [r0, #28]
    87f6:	f042 0208 	orr.w	r2, r2, #8
    87fa:	7702      	strb	r2, [r0, #28]
	err = netconn_peer(newconn, &naddr, &port);
    87fc:	a903      	add	r1, sp, #12
    87fe:	f10d 0206 	add.w	r2, sp, #6
    8802:	47a0      	blx	r4
	if (err != ERR_OK) {
    8804:	4604      	mov	r4, r0
    8806:	b158      	cbz	r0, 8820 <lwip_accept+0x84>
		netconn_delete(newconn);
    8808:	9802      	ldr	r0, [sp, #8]
    880a:	4b23      	ldr	r3, [pc, #140]	; (8898 <lwip_accept+0xfc>)
		sock_set_errno(sock, err_to_errno(err));
    880c:	4264      	negs	r4, r4
		netconn_delete(newconn);
    880e:	4798      	blx	r3
		sock_set_errno(sock, err_to_errno(err));
    8810:	2c0f      	cmp	r4, #15
    8812:	d803      	bhi.n	881c <lwip_accept+0x80>
    8814:	4b1e      	ldr	r3, [pc, #120]	; (8890 <lwip_accept+0xf4>)
    8816:	f853 3024 	ldr.w	r3, [r3, r4, lsl #2]
    881a:	e7d0      	b.n	87be <lwip_accept+0x22>
    881c:	2305      	movs	r3, #5
    881e:	e7ce      	b.n	87be <lwip_accept+0x22>
	if (NULL != addr) {
    8820:	b1bf      	cbz	r7, 8852 <lwip_accept+0xb6>
		sin.sin_len    = sizeof(sin);
    8822:	f44f 7304 	mov.w	r3, #528	; 0x210
		memset(&sin, 0, sizeof(sin));
    8826:	e9cd 0006 	strd	r0, r0, [sp, #24]
		sin.sin_len    = sizeof(sin);
    882a:	f8ad 3010 	strh.w	r3, [sp, #16]
		sin.sin_port   = htons(port);
    882e:	f8bd 0006 	ldrh.w	r0, [sp, #6]
    8832:	4b1a      	ldr	r3, [pc, #104]	; (889c <lwip_accept+0x100>)
    8834:	4798      	blx	r3
		inet_addr_from_ipaddr(&sin.sin_addr, &naddr);
    8836:	9b03      	ldr	r3, [sp, #12]
    8838:	9305      	str	r3, [sp, #20]
		if (*addrlen > sizeof(sin))
    883a:	6833      	ldr	r3, [r6, #0]
		sin.sin_port   = htons(port);
    883c:	f8ad 0012 	strh.w	r0, [sp, #18]
		if (*addrlen > sizeof(sin))
    8840:	2b10      	cmp	r3, #16
			*addrlen = sizeof(sin);
    8842:	bf84      	itt	hi
    8844:	2310      	movhi	r3, #16
    8846:	6033      	strhi	r3, [r6, #0]
		MEMCPY(addr, &sin, *addrlen);
    8848:	6832      	ldr	r2, [r6, #0]
    884a:	4b15      	ldr	r3, [pc, #84]	; (88a0 <lwip_accept+0x104>)
    884c:	a904      	add	r1, sp, #16
    884e:	4638      	mov	r0, r7
    8850:	4798      	blx	r3
	newsock = alloc_socket(newconn, 1);
    8852:	4b14      	ldr	r3, [pc, #80]	; (88a4 <lwip_accept+0x108>)
    8854:	9802      	ldr	r0, [sp, #8]
    8856:	2101      	movs	r1, #1
    8858:	4798      	blx	r3
	if (newsock == -1) {
    885a:	1c43      	adds	r3, r0, #1
	newsock = alloc_socket(newconn, 1);
    885c:	4604      	mov	r4, r0
	if (newsock == -1) {
    885e:	d105      	bne.n	886c <lwip_accept+0xd0>
		netconn_delete(newconn);
    8860:	4b0d      	ldr	r3, [pc, #52]	; (8898 <lwip_accept+0xfc>)
    8862:	9802      	ldr	r0, [sp, #8]
    8864:	4798      	blx	r3
		sock_set_errno(sock, ENFILE);
    8866:	2317      	movs	r3, #23
	sock_set_errno(sock, 0);
    8868:	612b      	str	r3, [r5, #16]
	return newsock;
    886a:	e7b7      	b.n	87dc <lwip_accept+0x40>
	nsock->rcvevent += (s16_t)(-1 - newconn->socket);
    886c:	4a0e      	ldr	r2, [pc, #56]	; (88a8 <lwip_accept+0x10c>)
    886e:	9902      	ldr	r1, [sp, #8]
    8870:	2318      	movs	r3, #24
    8872:	fb03 2200 	mla	r2, r3, r0, r2
    8876:	698b      	ldr	r3, [r1, #24]
    8878:	8950      	ldrh	r0, [r2, #10]
    887a:	43db      	mvns	r3, r3
    887c:	4403      	add	r3, r0
    887e:	8153      	strh	r3, [r2, #10]
	newconn->socket = newsock;
    8880:	618c      	str	r4, [r1, #24]
	sock_set_errno(sock, 0);
    8882:	2300      	movs	r3, #0
    8884:	e7f0      	b.n	8868 <lwip_accept+0xcc>
    8886:	bf00      	nop
    8888:	000085b5 	.word	0x000085b5
    888c:	0000675d 	.word	0x0000675d
    8890:	0000aaa4 	.word	0x0000aaa4
    8894:	000066c1 	.word	0x000066c1
    8898:	00006695 	.word	0x00006695
    889c:	00000d65 	.word	0x00000d65
    88a0:	000094a5 	.word	0x000094a5
    88a4:	000085d5 	.word	0x000085d5
    88a8:	20016314 	.word	0x20016314

000088ac <lwip_bind>:
{
    88ac:	b537      	push	{r0, r1, r2, r4, r5, lr}
	sock = get_socket(s);
    88ae:	4b13      	ldr	r3, [pc, #76]	; (88fc <lwip_bind+0x50>)
{
    88b0:	4615      	mov	r5, r2
	sock = get_socket(s);
    88b2:	4798      	blx	r3
	if (!sock) {
    88b4:	4604      	mov	r4, r0
    88b6:	b1d8      	cbz	r0, 88f0 <lwip_bind+0x44>
	LWIP_ERROR(
    88b8:	2d10      	cmp	r5, #16
    88ba:	d104      	bne.n	88c6 <lwip_bind+0x1a>
    88bc:	784b      	ldrb	r3, [r1, #1]
    88be:	2b02      	cmp	r3, #2
    88c0:	d101      	bne.n	88c6 <lwip_bind+0x1a>
    88c2:	078b      	lsls	r3, r1, #30
    88c4:	d000      	beq.n	88c8 <lwip_bind+0x1c>
    88c6:	e7fe      	b.n	88c6 <lwip_bind+0x1a>
	inet_addr_to_ipaddr(&local_addr, &name_in->sin_addr);
    88c8:	684b      	ldr	r3, [r1, #4]
	err = netconn_bind(sock->conn, &local_addr, ntohs(local_port));
    88ca:	6805      	ldr	r5, [r0, #0]
	inet_addr_to_ipaddr(&local_addr, &name_in->sin_addr);
    88cc:	9301      	str	r3, [sp, #4]
	err = netconn_bind(sock->conn, &local_addr, ntohs(local_port));
    88ce:	8848      	ldrh	r0, [r1, #2]
    88d0:	4b0b      	ldr	r3, [pc, #44]	; (8900 <lwip_bind+0x54>)
    88d2:	4798      	blx	r3
    88d4:	4b0b      	ldr	r3, [pc, #44]	; (8904 <lwip_bind+0x58>)
    88d6:	4602      	mov	r2, r0
    88d8:	a901      	add	r1, sp, #4
    88da:	4628      	mov	r0, r5
    88dc:	4798      	blx	r3
	if (err != ERR_OK) {
    88de:	b150      	cbz	r0, 88f6 <lwip_bind+0x4a>
		sock_set_errno(sock, err_to_errno(err));
    88e0:	4243      	negs	r3, r0
    88e2:	2b0f      	cmp	r3, #15
    88e4:	bf96      	itet	ls
    88e6:	4a08      	ldrls	r2, [pc, #32]	; (8908 <lwip_bind+0x5c>)
    88e8:	2305      	movhi	r3, #5
    88ea:	f852 3023 	ldrls.w	r3, [r2, r3, lsl #2]
    88ee:	6123      	str	r3, [r4, #16]
		return -1;
    88f0:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    88f4:	e000      	b.n	88f8 <lwip_bind+0x4c>
	sock_set_errno(sock, 0);
    88f6:	6120      	str	r0, [r4, #16]
}
    88f8:	b003      	add	sp, #12
    88fa:	bd30      	pop	{r4, r5, pc}
    88fc:	000085b5 	.word	0x000085b5
    8900:	00000d6b 	.word	0x00000d6b
    8904:	000066fd 	.word	0x000066fd
    8908:	0000aaa4 	.word	0x0000aaa4

0000890c <lwip_close>:
{
    890c:	b570      	push	{r4, r5, r6, lr}
	sock = get_socket(s);
    890e:	4b12      	ldr	r3, [pc, #72]	; (8958 <lwip_close+0x4c>)
    8910:	4798      	blx	r3
	if (!sock) {
    8912:	4604      	mov	r4, r0
    8914:	b1d0      	cbz	r0, 894c <lwip_close+0x40>
	if (sock->conn != NULL) {
    8916:	6800      	ldr	r0, [r0, #0]
    8918:	b198      	cbz	r0, 8942 <lwip_close+0x36>
		is_tcp = netconn_type(sock->conn) == NETCONN_TCP;
    891a:	7805      	ldrb	r5, [r0, #0]
    891c:	f1a5 0310 	sub.w	r3, r5, #16
    8920:	425d      	negs	r5, r3
    8922:	415d      	adcs	r5, r3
	netconn_delete(sock->conn);
    8924:	4b0d      	ldr	r3, [pc, #52]	; (895c <lwip_close+0x50>)
    8926:	4798      	blx	r3
	lastdata         = sock->lastdata;
    8928:	6860      	ldr	r0, [r4, #4]
	sock->lastdata   = NULL;
    892a:	2600      	movs	r6, #0
    892c:	6066      	str	r6, [r4, #4]
	sock->lastoffset = 0;
    892e:	8126      	strh	r6, [r4, #8]
	sock->err        = 0;
    8930:	6126      	str	r6, [r4, #16]
	sock->conn = NULL;
    8932:	6026      	str	r6, [r4, #0]
	if (lastdata != NULL) {
    8934:	b168      	cbz	r0, 8952 <lwip_close+0x46>
		if (is_tcp) {
    8936:	b135      	cbz	r5, 8946 <lwip_close+0x3a>
			pbuf_free((struct pbuf *)lastdata);
    8938:	4b09      	ldr	r3, [pc, #36]	; (8960 <lwip_close+0x54>)
    893a:	4798      	blx	r3
	return 0;
    893c:	4635      	mov	r5, r6
}
    893e:	4628      	mov	r0, r5
    8940:	bd70      	pop	{r4, r5, r6, pc}
	int               is_tcp = 0;
    8942:	4605      	mov	r5, r0
    8944:	e7ee      	b.n	8924 <lwip_close+0x18>
			netbuf_delete((struct netbuf *)lastdata);
    8946:	4b07      	ldr	r3, [pc, #28]	; (8964 <lwip_close+0x58>)
    8948:	4798      	blx	r3
    894a:	e7f8      	b.n	893e <lwip_close+0x32>
		return -1;
    894c:	f04f 35ff 	mov.w	r5, #4294967295	; 0xffffffff
    8950:	e7f5      	b.n	893e <lwip_close+0x32>
	return 0;
    8952:	4605      	mov	r5, r0
    8954:	e7f3      	b.n	893e <lwip_close+0x32>
    8956:	bf00      	nop
    8958:	000085b5 	.word	0x000085b5
    895c:	00006695 	.word	0x00006695
    8960:	00003081 	.word	0x00003081
    8964:	00000d7d 	.word	0x00000d7d

00008968 <lwip_listen>:
{
    8968:	b510      	push	{r4, lr}
	sock = get_socket(s);
    896a:	4b0e      	ldr	r3, [pc, #56]	; (89a4 <lwip_listen+0x3c>)
    896c:	4798      	blx	r3
	if (!sock) {
    896e:	4604      	mov	r4, r0
    8970:	b1a8      	cbz	r0, 899e <lwip_listen+0x36>
	err = netconn_listen_with_backlog(sock->conn, (u8_t)backlog);
    8972:	f381 0108 	usat	r1, #8, r1
    8976:	6800      	ldr	r0, [r0, #0]
    8978:	4b0b      	ldr	r3, [pc, #44]	; (89a8 <lwip_listen+0x40>)
    897a:	b2c9      	uxtb	r1, r1
    897c:	4798      	blx	r3
	if (err != ERR_OK) {
    897e:	b120      	cbz	r0, 898a <lwip_listen+0x22>
		if (netconn_type(sock->conn) != NETCONN_TCP) {
    8980:	6823      	ldr	r3, [r4, #0]
    8982:	781b      	ldrb	r3, [r3, #0]
    8984:	2b10      	cmp	r3, #16
    8986:	d002      	beq.n	898e <lwip_listen+0x26>
			sock_set_errno(sock, EOPNOTSUPP);
    8988:	205f      	movs	r0, #95	; 0x5f
	sock_set_errno(sock, 0);
    898a:	6120      	str	r0, [r4, #16]
}
    898c:	bd10      	pop	{r4, pc}
		sock_set_errno(sock, err_to_errno(err));
    898e:	4243      	negs	r3, r0
    8990:	2b0f      	cmp	r3, #15
    8992:	bf96      	itet	ls
    8994:	4a05      	ldrls	r2, [pc, #20]	; (89ac <lwip_listen+0x44>)
    8996:	2305      	movhi	r3, #5
    8998:	f852 3023 	ldrls.w	r3, [r2, r3, lsl #2]
    899c:	6123      	str	r3, [r4, #16]
		return -1;
    899e:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    89a2:	e7f3      	b.n	898c <lwip_listen+0x24>
    89a4:	000085b5 	.word	0x000085b5
    89a8:	00006731 	.word	0x00006731
    89ac:	0000aaa4 	.word	0x0000aaa4

000089b0 <lwip_recvfrom>:
{
    89b0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    89b4:	b08b      	sub	sp, #44	; 0x2c
    89b6:	469b      	mov	fp, r3
	void *            buf = NULL;
    89b8:	2500      	movs	r5, #0
	sock = get_socket(s);
    89ba:	4b69      	ldr	r3, [pc, #420]	; (8b60 <lwip_recvfrom+0x1b0>)
{
    89bc:	9101      	str	r1, [sp, #4]
    89be:	4690      	mov	r8, r2
	void *            buf = NULL;
    89c0:	9504      	str	r5, [sp, #16]
	sock = get_socket(s);
    89c2:	4798      	blx	r3
{
    89c4:	f8dd 9054 	ldr.w	r9, [sp, #84]	; 0x54
	if (!sock) {
    89c8:	4604      	mov	r4, r0
    89ca:	2800      	cmp	r0, #0
    89cc:	d05b      	beq.n	8a86 <lwip_recvfrom+0xd6>
		if (sock->lastdata) {
    89ce:	6863      	ldr	r3, [r4, #4]
    89d0:	2b00      	cmp	r3, #0
    89d2:	d045      	beq.n	8a60 <lwip_recvfrom+0xb0>
			buf = sock->lastdata;
    89d4:	9304      	str	r3, [sp, #16]
		if (netconn_type(sock->conn) == NETCONN_TCP) {
    89d6:	6823      	ldr	r3, [r4, #0]
			p = (struct pbuf *)buf;
    89d8:	f8dd a010 	ldr.w	sl, [sp, #16]
		if (netconn_type(sock->conn) == NETCONN_TCP) {
    89dc:	781b      	ldrb	r3, [r3, #0]
		pbuf_copy_partial(p, (u8_t *)mem + off, copylen, sock->lastoffset);
    89de:	9901      	ldr	r1, [sp, #4]
		if (netconn_type(sock->conn) == NETCONN_TCP) {
    89e0:	2b10      	cmp	r3, #16
			p = ((struct netbuf *)buf)->p;
    89e2:	bf18      	it	ne
    89e4:	f8da a000 	ldrne.w	sl, [sl]
		buflen -= sock->lastoffset;
    89e8:	8923      	ldrh	r3, [r4, #8]
		buflen = p->tot_len;
    89ea:	f8ba 6008 	ldrh.w	r6, [sl, #8]
		buflen -= sock->lastoffset;
    89ee:	1af6      	subs	r6, r6, r3
    89f0:	b2b2      	uxth	r2, r6
		if (len > buflen) {
    89f2:	4542      	cmp	r2, r8
		buflen -= sock->lastoffset;
    89f4:	9200      	str	r2, [sp, #0]
			copylen = buflen;
    89f6:	bf38      	it	cc
    89f8:	9f00      	ldrcc	r7, [sp, #0]
		pbuf_copy_partial(p, (u8_t *)mem + off, copylen, sock->lastoffset);
    89fa:	4e5a      	ldr	r6, [pc, #360]	; (8b64 <lwip_recvfrom+0x1b4>)
			copylen = (u16_t)len;
    89fc:	bf28      	it	cs
    89fe:	fa1f f788 	uxthcs.w	r7, r8
		pbuf_copy_partial(p, (u8_t *)mem + off, copylen, sock->lastoffset);
    8a02:	463a      	mov	r2, r7
    8a04:	4429      	add	r1, r5
    8a06:	4650      	mov	r0, sl
    8a08:	47b0      	blx	r6
		if (netconn_type(sock->conn) == NETCONN_TCP) {
    8a0a:	6820      	ldr	r0, [r4, #0]
    8a0c:	7803      	ldrb	r3, [r0, #0]
			if ((len <= 0) || (p->flags & PBUF_FLAG_PUSH) || (sock->rcvevent <= 0) || ((flags & MSG_PEEK) != 0)) {
    8a0e:	f00b 0201 	and.w	r2, fp, #1
		if (netconn_type(sock->conn) == NETCONN_TCP) {
    8a12:	2b10      	cmp	r3, #16
		off += copylen;
    8a14:	443d      	add	r5, r7
			if ((len <= 0) || (p->flags & PBUF_FLAG_PUSH) || (sock->rcvevent <= 0) || ((flags & MSG_PEEK) != 0)) {
    8a16:	4616      	mov	r6, r2
		if (netconn_type(sock->conn) == NETCONN_TCP) {
    8a18:	d156      	bne.n	8ac8 <lwip_recvfrom+0x118>
			if ((len <= 0) || (p->flags & PBUF_FLAG_PUSH) || (sock->rcvevent <= 0) || ((flags & MSG_PEEK) != 0)) {
    8a1a:	ebb8 0807 	subs.w	r8, r8, r7
    8a1e:	d053      	beq.n	8ac8 <lwip_recvfrom+0x118>
    8a20:	f89a a00d 	ldrb.w	sl, [sl, #13]
    8a24:	f01a 0a01 	ands.w	sl, sl, #1
    8a28:	d14e      	bne.n	8ac8 <lwip_recvfrom+0x118>
    8a2a:	f9b4 200a 	ldrsh.w	r2, [r4, #10]
    8a2e:	2a00      	cmp	r2, #0
    8a30:	dd4a      	ble.n	8ac8 <lwip_recvfrom+0x118>
    8a32:	2e00      	cmp	r6, #0
    8a34:	f040 808c 	bne.w	8b50 <lwip_recvfrom+0x1a0>
			if ((netconn_type(sock->conn) == NETCONN_TCP) && (buflen - copylen > 0)) {
    8a38:	6823      	ldr	r3, [r4, #0]
				sock->lastdata = buf;
    8a3a:	9804      	ldr	r0, [sp, #16]
			if ((netconn_type(sock->conn) == NETCONN_TCP) && (buflen - copylen > 0)) {
    8a3c:	781b      	ldrb	r3, [r3, #0]
    8a3e:	2b10      	cmp	r3, #16
    8a40:	d17b      	bne.n	8b3a <lwip_recvfrom+0x18a>
    8a42:	9a00      	ldr	r2, [sp, #0]
    8a44:	1bd6      	subs	r6, r2, r7
    8a46:	2e00      	cmp	r6, #0
    8a48:	dd77      	ble.n	8b3a <lwip_recvfrom+0x18a>
				sock->lastoffset += copylen;
    8a4a:	8923      	ldrh	r3, [r4, #8]
				sock->lastdata = buf;
    8a4c:	6060      	str	r0, [r4, #4]
				sock->lastoffset += copylen;
    8a4e:	441f      	add	r7, r3
    8a50:	8127      	strh	r7, [r4, #8]
	} while (!done);
    8a52:	f1ba 0f00 	cmp.w	sl, #0
    8a56:	d0ba      	beq.n	89ce <lwip_recvfrom+0x1e>
	if (off > 0) {
    8a58:	b975      	cbnz	r5, 8a78 <lwip_recvfrom+0xc8>
	sock_set_errno(sock, 0);
    8a5a:	2300      	movs	r3, #0
    8a5c:	6123      	str	r3, [r4, #16]
	return off;
    8a5e:	e02c      	b.n	8aba <lwip_recvfrom+0x10a>
			if (((flags & MSG_DONTWAIT) || netconn_is_nonblocking(sock->conn)) && (sock->rcvevent <= 0)) {
    8a60:	f01b 0f08 	tst.w	fp, #8
    8a64:	d103      	bne.n	8a6e <lwip_recvfrom+0xbe>
    8a66:	6823      	ldr	r3, [r4, #0]
    8a68:	7f1b      	ldrb	r3, [r3, #28]
    8a6a:	079b      	lsls	r3, r3, #30
    8a6c:	d50e      	bpl.n	8a8c <lwip_recvfrom+0xdc>
    8a6e:	f9b4 300a 	ldrsh.w	r3, [r4, #10]
    8a72:	2b00      	cmp	r3, #0
    8a74:	dc0a      	bgt.n	8a8c <lwip_recvfrom+0xdc>
				if (off > 0) {
    8a76:	b125      	cbz	r5, 8a82 <lwip_recvfrom+0xd2>
		netconn_recved(sock->conn, (u32_t)off);
    8a78:	6820      	ldr	r0, [r4, #0]
    8a7a:	4b3b      	ldr	r3, [pc, #236]	; (8b68 <lwip_recvfrom+0x1b8>)
    8a7c:	4629      	mov	r1, r5
    8a7e:	4798      	blx	r3
    8a80:	e7eb      	b.n	8a5a <lwip_recvfrom+0xaa>
				sock_set_errno(sock, EWOULDBLOCK);
    8a82:	230b      	movs	r3, #11
    8a84:	6123      	str	r3, [r4, #16]
		return -1;
    8a86:	f04f 35ff 	mov.w	r5, #4294967295	; 0xffffffff
    8a8a:	e016      	b.n	8aba <lwip_recvfrom+0x10a>
			if (netconn_type(sock->conn) == NETCONN_TCP) {
    8a8c:	6820      	ldr	r0, [r4, #0]
    8a8e:	7803      	ldrb	r3, [r0, #0]
    8a90:	2b10      	cmp	r3, #16
				err = netconn_recv_tcp_pbuf(sock->conn, (struct pbuf **)&buf);
    8a92:	bf0c      	ite	eq
    8a94:	4b35      	ldreq	r3, [pc, #212]	; (8b6c <lwip_recvfrom+0x1bc>)
				err = netconn_recv(sock->conn, (struct netbuf **)&buf);
    8a96:	4b36      	ldrne	r3, [pc, #216]	; (8b70 <lwip_recvfrom+0x1c0>)
				err = netconn_recv_tcp_pbuf(sock->conn, (struct pbuf **)&buf);
    8a98:	a904      	add	r1, sp, #16
				err = netconn_recv(sock->conn, (struct netbuf **)&buf);
    8a9a:	4798      	blx	r3
			if (err != ERR_OK) {
    8a9c:	b188      	cbz	r0, 8ac2 <lwip_recvfrom+0x112>
				if (off > 0) {
    8a9e:	2d00      	cmp	r5, #0
    8aa0:	d1ea      	bne.n	8a78 <lwip_recvfrom+0xc8>
				sock_set_errno(sock, err_to_errno(err));
    8aa2:	4243      	negs	r3, r0
    8aa4:	2b0f      	cmp	r3, #15
    8aa6:	bf96      	itet	ls
    8aa8:	4a32      	ldrls	r2, [pc, #200]	; (8b74 <lwip_recvfrom+0x1c4>)
    8aaa:	2305      	movhi	r3, #5
    8aac:	f852 3023 	ldrls.w	r3, [r2, r3, lsl #2]
    8ab0:	6123      	str	r3, [r4, #16]
				if (err == ERR_CLSD) {
    8ab2:	300c      	adds	r0, #12
    8ab4:	bf18      	it	ne
    8ab6:	2001      	movne	r0, #1
    8ab8:	4245      	negs	r5, r0
}
    8aba:	4628      	mov	r0, r5
    8abc:	b00b      	add	sp, #44	; 0x2c
    8abe:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
			sock->lastdata = buf;
    8ac2:	9b04      	ldr	r3, [sp, #16]
    8ac4:	6063      	str	r3, [r4, #4]
    8ac6:	e786      	b.n	89d6 <lwip_recvfrom+0x26>
			if (from && fromlen) {
    8ac8:	9a14      	ldr	r2, [sp, #80]	; 0x50
    8aca:	b352      	cbz	r2, 8b22 <lwip_recvfrom+0x172>
    8acc:	f1b9 0f00 	cmp.w	r9, #0
    8ad0:	d027      	beq.n	8b22 <lwip_recvfrom+0x172>
				if (netconn_type(sock->conn) == NETCONN_TCP) {
    8ad2:	2b10      	cmp	r3, #16
    8ad4:	d12a      	bne.n	8b2c <lwip_recvfrom+0x17c>
					netconn_getaddr(sock->conn, addr, &port, 0);
    8ad6:	f8df a0b0 	ldr.w	sl, [pc, #176]	; 8b88 <lwip_recvfrom+0x1d8>
    8ada:	2300      	movs	r3, #0
    8adc:	f10d 020e 	add.w	r2, sp, #14
    8ae0:	a905      	add	r1, sp, #20
    8ae2:	47d0      	blx	sl
					addr = &fromaddr;
    8ae4:	f10d 0a14 	add.w	sl, sp, #20
				memset(&sin, 0, sizeof(sin));
    8ae8:	2300      	movs	r3, #0
    8aea:	e9cd 3308 	strd	r3, r3, [sp, #32]
				sin.sin_len    = sizeof(sin);
    8aee:	f44f 7304 	mov.w	r3, #528	; 0x210
    8af2:	f8ad 3018 	strh.w	r3, [sp, #24]
				sin.sin_port   = htons(port);
    8af6:	f8bd 000e 	ldrh.w	r0, [sp, #14]
    8afa:	4b1f      	ldr	r3, [pc, #124]	; (8b78 <lwip_recvfrom+0x1c8>)
    8afc:	4798      	blx	r3
				inet_addr_from_ipaddr(&sin.sin_addr, addr);
    8afe:	f8da 3000 	ldr.w	r3, [sl]
    8b02:	9307      	str	r3, [sp, #28]
				if (*fromlen > sizeof(sin)) {
    8b04:	f8d9 3000 	ldr.w	r3, [r9]
				sin.sin_port   = htons(port);
    8b08:	f8ad 001a 	strh.w	r0, [sp, #26]
				if (*fromlen > sizeof(sin)) {
    8b0c:	2b10      	cmp	r3, #16
					*fromlen = sizeof(sin);
    8b0e:	bf84      	itt	hi
    8b10:	2310      	movhi	r3, #16
    8b12:	f8c9 3000 	strhi.w	r3, [r9]
				MEMCPY(from, &sin, *fromlen);
    8b16:	f8d9 2000 	ldr.w	r2, [r9]
    8b1a:	9814      	ldr	r0, [sp, #80]	; 0x50
    8b1c:	4b17      	ldr	r3, [pc, #92]	; (8b7c <lwip_recvfrom+0x1cc>)
    8b1e:	a906      	add	r1, sp, #24
    8b20:	4798      	blx	r3
		if ((flags & MSG_PEEK) == 0) {
    8b22:	2e00      	cmp	r6, #0
    8b24:	d198      	bne.n	8a58 <lwip_recvfrom+0xa8>
    8b26:	f04f 0a01 	mov.w	sl, #1
    8b2a:	e785      	b.n	8a38 <lwip_recvfrom+0x88>
					addr = netbuf_fromaddr((struct netbuf *)buf);
    8b2c:	9b04      	ldr	r3, [sp, #16]
    8b2e:	f103 0a08 	add.w	sl, r3, #8
					port = netbuf_fromport((struct netbuf *)buf);
    8b32:	899b      	ldrh	r3, [r3, #12]
    8b34:	f8ad 300e 	strh.w	r3, [sp, #14]
    8b38:	e7d6      	b.n	8ae8 <lwip_recvfrom+0x138>
				sock->lastdata   = NULL;
    8b3a:	2200      	movs	r2, #0
				if (netconn_type(sock->conn) == NETCONN_TCP) {
    8b3c:	2b10      	cmp	r3, #16
				sock->lastdata   = NULL;
    8b3e:	6062      	str	r2, [r4, #4]
				sock->lastoffset = 0;
    8b40:	8122      	strh	r2, [r4, #8]
				if (netconn_type(sock->conn) == NETCONN_TCP) {
    8b42:	d102      	bne.n	8b4a <lwip_recvfrom+0x19a>
					pbuf_free((struct pbuf *)buf);
    8b44:	4b0e      	ldr	r3, [pc, #56]	; (8b80 <lwip_recvfrom+0x1d0>)
    8b46:	4798      	blx	r3
    8b48:	e783      	b.n	8a52 <lwip_recvfrom+0xa2>
					netbuf_delete((struct netbuf *)buf);
    8b4a:	4b0e      	ldr	r3, [pc, #56]	; (8b84 <lwip_recvfrom+0x1d4>)
    8b4c:	4798      	blx	r3
    8b4e:	e780      	b.n	8a52 <lwip_recvfrom+0xa2>
			if (from && fromlen) {
    8b50:	9b14      	ldr	r3, [sp, #80]	; 0x50
    8b52:	2b00      	cmp	r3, #0
    8b54:	d080      	beq.n	8a58 <lwip_recvfrom+0xa8>
    8b56:	f1b9 0f00 	cmp.w	r9, #0
    8b5a:	d1bc      	bne.n	8ad6 <lwip_recvfrom+0x126>
    8b5c:	e7e1      	b.n	8b22 <lwip_recvfrom+0x172>
    8b5e:	bf00      	nop
    8b60:	000085b5 	.word	0x000085b5
    8b64:	00003321 	.word	0x00003321
    8b68:	00006861 	.word	0x00006861
    8b6c:	000067c5 	.word	0x000067c5
    8b70:	000067d9 	.word	0x000067d9
    8b74:	0000aaa4 	.word	0x0000aaa4
    8b78:	00000d65 	.word	0x00000d65
    8b7c:	000094a5 	.word	0x000094a5
    8b80:	00003081 	.word	0x00003081
    8b84:	00000d7d 	.word	0x00000d7d
    8b88:	000066c1 	.word	0x000066c1

00008b8c <lwip_read>:
{
    8b8c:	b513      	push	{r0, r1, r4, lr}
	return lwip_recvfrom(s, mem, len, 0, NULL, NULL);
    8b8e:	2300      	movs	r3, #0
    8b90:	e9cd 3300 	strd	r3, r3, [sp]
    8b94:	4c01      	ldr	r4, [pc, #4]	; (8b9c <lwip_read+0x10>)
    8b96:	47a0      	blx	r4
}
    8b98:	b002      	add	sp, #8
    8b9a:	bd10      	pop	{r4, pc}
    8b9c:	000089b1 	.word	0x000089b1

00008ba0 <lwip_sendto>:
{
    8ba0:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
    8ba4:	b087      	sub	sp, #28
    8ba6:	4614      	mov	r4, r2
	sock = get_socket(s);
    8ba8:	4a28      	ldr	r2, [pc, #160]	; (8c4c <lwip_sendto+0xac>)
{
    8baa:	9301      	str	r3, [sp, #4]
    8bac:	4680      	mov	r8, r0
	sock = get_socket(s);
    8bae:	4790      	blx	r2
{
    8bb0:	e9dd 590e 	ldrd	r5, r9, [sp, #56]	; 0x38
	if (!sock) {
    8bb4:	9b01      	ldr	r3, [sp, #4]
{
    8bb6:	460f      	mov	r7, r1
	if (!sock) {
    8bb8:	4606      	mov	r6, r0
    8bba:	b920      	cbnz	r0, 8bc6 <lwip_sendto+0x26>
		return -1;
    8bbc:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
}
    8bc0:	b007      	add	sp, #28
    8bc2:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
	if (sock->conn->type == NETCONN_TCP) {
    8bc6:	6802      	ldr	r2, [r0, #0]
    8bc8:	7812      	ldrb	r2, [r2, #0]
    8bca:	2a10      	cmp	r2, #16
    8bcc:	d107      	bne.n	8bde <lwip_sendto+0x3e>
		return lwip_send(s, data, size, flags);
    8bce:	4622      	mov	r2, r4
    8bd0:	4c1f      	ldr	r4, [pc, #124]	; (8c50 <lwip_sendto+0xb0>)
    8bd2:	4640      	mov	r0, r8
    8bd4:	46a4      	mov	ip, r4
}
    8bd6:	b007      	add	sp, #28
    8bd8:	e8bd 43f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, lr}
		return lwip_send(s, data, size, flags);
    8bdc:	4760      	bx	ip
	LWIP_ERROR(
    8bde:	b915      	cbnz	r5, 8be6 <lwip_sendto+0x46>
    8be0:	f1b9 0f00 	cmp.w	r9, #0
    8be4:	d008      	beq.n	8bf8 <lwip_sendto+0x58>
    8be6:	f1b9 0f10 	cmp.w	r9, #16
    8bea:	d104      	bne.n	8bf6 <lwip_sendto+0x56>
    8bec:	786b      	ldrb	r3, [r5, #1]
    8bee:	2b02      	cmp	r3, #2
    8bf0:	d101      	bne.n	8bf6 <lwip_sendto+0x56>
    8bf2:	07ab      	lsls	r3, r5, #30
    8bf4:	d000      	beq.n	8bf8 <lwip_sendto+0x58>
    8bf6:	e7fe      	b.n	8bf6 <lwip_sendto+0x56>
	buf.p = buf.ptr = NULL;
    8bf8:	2300      	movs	r3, #0
    8bfa:	e9cd 3302 	strd	r3, r3, [sp, #8]
	if (to) {
    8bfe:	b30d      	cbz	r5, 8c44 <lwip_sendto+0xa4>
		inet_addr_to_ipaddr(&buf.addr, &to_in->sin_addr);
    8c00:	686b      	ldr	r3, [r5, #4]
    8c02:	9304      	str	r3, [sp, #16]
		remote_port = ntohs(to_in->sin_port);
    8c04:	8868      	ldrh	r0, [r5, #2]
    8c06:	4b13      	ldr	r3, [pc, #76]	; (8c54 <lwip_sendto+0xb4>)
    8c08:	4798      	blx	r3
		netbuf_fromport(&buf) = remote_port;
    8c0a:	f8ad 0014 	strh.w	r0, [sp, #20]
	err = netbuf_ref(&buf, data, short_size);
    8c0e:	4b12      	ldr	r3, [pc, #72]	; (8c58 <lwip_sendto+0xb8>)
    8c10:	b2a2      	uxth	r2, r4
    8c12:	4639      	mov	r1, r7
    8c14:	a802      	add	r0, sp, #8
    8c16:	4798      	blx	r3
	if (err == ERR_OK) {
    8c18:	4605      	mov	r5, r0
    8c1a:	b920      	cbnz	r0, 8c26 <lwip_sendto+0x86>
		err = netconn_send(sock->conn, &buf);
    8c1c:	6830      	ldr	r0, [r6, #0]
    8c1e:	4b0f      	ldr	r3, [pc, #60]	; (8c5c <lwip_sendto+0xbc>)
    8c20:	a902      	add	r1, sp, #8
    8c22:	4798      	blx	r3
    8c24:	4605      	mov	r5, r0
	netbuf_free(&buf);
    8c26:	4b0e      	ldr	r3, [pc, #56]	; (8c60 <lwip_sendto+0xc0>)
    8c28:	a802      	add	r0, sp, #8
    8c2a:	4798      	blx	r3
	sock_set_errno(sock, err_to_errno(err));
    8c2c:	426b      	negs	r3, r5
    8c2e:	2b0f      	cmp	r3, #15
    8c30:	bf96      	itet	ls
    8c32:	4a0c      	ldrls	r2, [pc, #48]	; (8c64 <lwip_sendto+0xc4>)
    8c34:	2305      	movhi	r3, #5
    8c36:	f852 3023 	ldrls.w	r3, [r2, r3, lsl #2]
    8c3a:	6133      	str	r3, [r6, #16]
	return (err == ERR_OK ? short_size : -1);
    8c3c:	2d00      	cmp	r5, #0
    8c3e:	d1bd      	bne.n	8bbc <lwip_sendto+0x1c>
    8c40:	b2a0      	uxth	r0, r4
    8c42:	e7bd      	b.n	8bc0 <lwip_sendto+0x20>
		ip_addr_set_any(&buf.addr);
    8c44:	9504      	str	r5, [sp, #16]
		netbuf_fromport(&buf) = 0;
    8c46:	f8ad 5014 	strh.w	r5, [sp, #20]
    8c4a:	e7e0      	b.n	8c0e <lwip_sendto+0x6e>
    8c4c:	000085b5 	.word	0x000085b5
    8c50:	00008c69 	.word	0x00008c69
    8c54:	00000d6b 	.word	0x00000d6b
    8c58:	00000dc5 	.word	0x00000dc5
    8c5c:	0000688d 	.word	0x0000688d
    8c60:	00000da9 	.word	0x00000da9
    8c64:	0000aaa4 	.word	0x0000aaa4

00008c68 <lwip_send>:
{
    8c68:	b570      	push	{r4, r5, r6, lr}
    8c6a:	b086      	sub	sp, #24
    8c6c:	461c      	mov	r4, r3
	sock = get_socket(s);
    8c6e:	4b19      	ldr	r3, [pc, #100]	; (8cd4 <lwip_send+0x6c>)
{
    8c70:	9203      	str	r2, [sp, #12]
    8c72:	4606      	mov	r6, r0
	sock = get_socket(s);
    8c74:	4798      	blx	r3
	if (!sock) {
    8c76:	9a03      	ldr	r2, [sp, #12]
    8c78:	4605      	mov	r5, r0
    8c7a:	b918      	cbnz	r0, 8c84 <lwip_send+0x1c>
		return -1;
    8c7c:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
}
    8c80:	b006      	add	sp, #24
    8c82:	bd70      	pop	{r4, r5, r6, pc}
	if (sock->conn->type != NETCONN_TCP) {
    8c84:	6800      	ldr	r0, [r0, #0]
    8c86:	7803      	ldrb	r3, [r0, #0]
    8c88:	2b10      	cmp	r3, #16
    8c8a:	f04f 0300 	mov.w	r3, #0
    8c8e:	d006      	beq.n	8c9e <lwip_send+0x36>
		return lwip_sendto(s, data, size, flags, NULL, 0);
    8c90:	e9cd 3300 	strd	r3, r3, [sp]
    8c94:	4630      	mov	r0, r6
    8c96:	4623      	mov	r3, r4
    8c98:	4c0f      	ldr	r4, [pc, #60]	; (8cd8 <lwip_send+0x70>)
    8c9a:	47a0      	blx	r4
    8c9c:	e7f0      	b.n	8c80 <lwip_send+0x18>
	written = 0;
    8c9e:	9305      	str	r3, [sp, #20]
	    = NETCONN_COPY | ((flags & MSG_MORE) ? NETCONN_MORE : 0) | ((flags & MSG_DONTWAIT) ? NETCONN_DONTBLOCK : 0);
    8ca0:	10e6      	asrs	r6, r4, #3
    8ca2:	1063      	asrs	r3, r4, #1
    8ca4:	f006 0602 	and.w	r6, r6, #2
    8ca8:	f003 0304 	and.w	r3, r3, #4
	err     = netconn_write_partly(sock->conn, data, size, write_flags, &written);
    8cac:	ac05      	add	r4, sp, #20
	    = NETCONN_COPY | ((flags & MSG_MORE) ? NETCONN_MORE : 0) | ((flags & MSG_DONTWAIT) ? NETCONN_DONTBLOCK : 0);
    8cae:	4333      	orrs	r3, r6
	err     = netconn_write_partly(sock->conn, data, size, write_flags, &written);
    8cb0:	9400      	str	r4, [sp, #0]
    8cb2:	f043 0301 	orr.w	r3, r3, #1
    8cb6:	4c09      	ldr	r4, [pc, #36]	; (8cdc <lwip_send+0x74>)
    8cb8:	47a0      	blx	r4
	sock_set_errno(sock, err_to_errno(err));
    8cba:	4243      	negs	r3, r0
    8cbc:	2b0f      	cmp	r3, #15
    8cbe:	bf96      	itet	ls
    8cc0:	4a07      	ldrls	r2, [pc, #28]	; (8ce0 <lwip_send+0x78>)
    8cc2:	2305      	movhi	r3, #5
    8cc4:	f852 3023 	ldrls.w	r3, [r2, r3, lsl #2]
    8cc8:	612b      	str	r3, [r5, #16]
	return (err == ERR_OK ? (int)written : -1);
    8cca:	2800      	cmp	r0, #0
    8ccc:	d1d6      	bne.n	8c7c <lwip_send+0x14>
    8cce:	9805      	ldr	r0, [sp, #20]
    8cd0:	e7d6      	b.n	8c80 <lwip_send+0x18>
    8cd2:	bf00      	nop
    8cd4:	000085b5 	.word	0x000085b5
    8cd8:	00008ba1 	.word	0x00008ba1
    8cdc:	000068bd 	.word	0x000068bd
    8ce0:	0000aaa4 	.word	0x0000aaa4

00008ce4 <lwip_socket>:
	switch (type) {
    8ce4:	2902      	cmp	r1, #2
{
    8ce6:	b538      	push	{r3, r4, r5, lr}
    8ce8:	4613      	mov	r3, r2
	switch (type) {
    8cea:	d01a      	beq.n	8d22 <lwip_socket+0x3e>
    8cec:	2903      	cmp	r1, #3
    8cee:	d005      	beq.n	8cfc <lwip_socket+0x18>
    8cf0:	2901      	cmp	r1, #1
    8cf2:	d01e      	beq.n	8d32 <lwip_socket+0x4e>
		return -1;
    8cf4:	f04f 35ff 	mov.w	r5, #4294967295	; 0xffffffff
}
    8cf8:	4628      	mov	r0, r5
    8cfa:	bd38      	pop	{r3, r4, r5, pc}
		conn = netconn_new_with_proto_and_callback(NETCONN_RAW, (u8_t)protocol, event_callback);
    8cfc:	4a14      	ldr	r2, [pc, #80]	; (8d50 <lwip_socket+0x6c>)
    8cfe:	b2d9      	uxtb	r1, r3
    8d00:	2040      	movs	r0, #64	; 0x40
		conn = netconn_new_with_callback((protocol == IPPROTO_UDPLITE) ? NETCONN_UDPLITE : NETCONN_UDP, event_callback);
    8d02:	4b14      	ldr	r3, [pc, #80]	; (8d54 <lwip_socket+0x70>)
    8d04:	4798      	blx	r3
    8d06:	4604      	mov	r4, r0
	if (!conn) {
    8d08:	2800      	cmp	r0, #0
    8d0a:	d0f3      	beq.n	8cf4 <lwip_socket+0x10>
	i = alloc_socket(conn, 0);
    8d0c:	4b12      	ldr	r3, [pc, #72]	; (8d58 <lwip_socket+0x74>)
    8d0e:	2100      	movs	r1, #0
    8d10:	4620      	mov	r0, r4
    8d12:	4798      	blx	r3
	if (i == -1) {
    8d14:	1c43      	adds	r3, r0, #1
	i = alloc_socket(conn, 0);
    8d16:	4605      	mov	r5, r0
	if (i == -1) {
    8d18:	d118      	bne.n	8d4c <lwip_socket+0x68>
		netconn_delete(conn);
    8d1a:	4b10      	ldr	r3, [pc, #64]	; (8d5c <lwip_socket+0x78>)
    8d1c:	4620      	mov	r0, r4
    8d1e:	4798      	blx	r3
		return -1;
    8d20:	e7ea      	b.n	8cf8 <lwip_socket+0x14>
		conn = netconn_new_with_callback((protocol == IPPROTO_UDPLITE) ? NETCONN_UDPLITE : NETCONN_UDP, event_callback);
    8d22:	2a88      	cmp	r2, #136	; 0x88
    8d24:	f04f 0100 	mov.w	r1, #0
    8d28:	4a09      	ldr	r2, [pc, #36]	; (8d50 <lwip_socket+0x6c>)
    8d2a:	bf0c      	ite	eq
    8d2c:	2021      	moveq	r0, #33	; 0x21
    8d2e:	2020      	movne	r0, #32
    8d30:	e7e7      	b.n	8d02 <lwip_socket+0x1e>
		conn = netconn_new_with_callback(NETCONN_TCP, event_callback);
    8d32:	4a07      	ldr	r2, [pc, #28]	; (8d50 <lwip_socket+0x6c>)
    8d34:	4b07      	ldr	r3, [pc, #28]	; (8d54 <lwip_socket+0x70>)
    8d36:	2100      	movs	r1, #0
    8d38:	2010      	movs	r0, #16
    8d3a:	4798      	blx	r3
		if (conn != NULL) {
    8d3c:	4604      	mov	r4, r0
    8d3e:	2800      	cmp	r0, #0
    8d40:	d0d8      	beq.n	8cf4 <lwip_socket+0x10>
			netconn_set_noautorecved(conn, 1);
    8d42:	7f03      	ldrb	r3, [r0, #28]
    8d44:	f043 0308 	orr.w	r3, r3, #8
    8d48:	7703      	strb	r3, [r0, #28]
	if (!conn) {
    8d4a:	e7df      	b.n	8d0c <lwip_socket+0x28>
	conn->socket = i;
    8d4c:	61a0      	str	r0, [r4, #24]
	return i;
    8d4e:	e7d3      	b.n	8cf8 <lwip_socket+0x14>
    8d50:	00008611 	.word	0x00008611
    8d54:	00006639 	.word	0x00006639
    8d58:	000085d5 	.word	0x000085d5
    8d5c:	00006695 	.word	0x00006695

00008d60 <lwip_write>:
{
    8d60:	b410      	push	{r4}
	return lwip_send(s, data, size, 0);
    8d62:	4c03      	ldr	r4, [pc, #12]	; (8d70 <lwip_write+0x10>)
    8d64:	2300      	movs	r3, #0
    8d66:	46a4      	mov	ip, r4
}
    8d68:	f85d 4b04 	ldr.w	r4, [sp], #4
	return lwip_send(s, data, size, 0);
    8d6c:	4760      	bx	ip
    8d6e:	bf00      	nop
    8d70:	00008c69 	.word	0x00008c69

00008d74 <lwip_setsockopt>:
{
    8d74:	b570      	push	{r4, r5, r6, lr}
    8d76:	461e      	mov	r6, r3
    8d78:	b086      	sub	sp, #24
	struct lwip_sock *             sock = get_socket(s);
    8d7a:	4b30      	ldr	r3, [pc, #192]	; (8e3c <lwip_setsockopt+0xc8>)
{
    8d7c:	4615      	mov	r5, r2
	struct lwip_sock *             sock = get_socket(s);
    8d7e:	4798      	blx	r3
	if (!sock) {
    8d80:	4604      	mov	r4, r0
    8d82:	b110      	cbz	r0, 8d8a <lwip_setsockopt+0x16>
	if (NULL == optval) {
    8d84:	b92e      	cbnz	r6, 8d92 <lwip_setsockopt+0x1e>
		sock_set_errno(sock, EFAULT);
    8d86:	230e      	movs	r3, #14
    8d88:	6103      	str	r3, [r0, #16]
		return -1;
    8d8a:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
}
    8d8e:	b006      	add	sp, #24
    8d90:	bd70      	pop	{r4, r5, r6, pc}
	switch (level) {
    8d92:	2906      	cmp	r1, #6
    8d94:	d026      	beq.n	8de4 <lwip_setsockopt+0x70>
    8d96:	f640 73ff 	movw	r3, #4095	; 0xfff
    8d9a:	4299      	cmp	r1, r3
    8d9c:	d002      	beq.n	8da4 <lwip_setsockopt+0x30>
    8d9e:	b1e9      	cbz	r1, 8ddc <lwip_setsockopt+0x68>
    8da0:	205c      	movs	r0, #92	; 0x5c
    8da2:	e046      	b.n	8e32 <lwip_setsockopt+0xbe>
		switch (optname) {
    8da4:	2d20      	cmp	r5, #32
    8da6:	d005      	beq.n	8db4 <lwip_setsockopt+0x40>
    8da8:	f241 030a 	movw	r3, #4106	; 0x100a
    8dac:	429d      	cmp	r5, r3
    8dae:	d006      	beq.n	8dbe <lwip_setsockopt+0x4a>
    8db0:	2d08      	cmp	r5, #8
    8db2:	d1f5      	bne.n	8da0 <lwip_setsockopt+0x2c>
			if (optlen < sizeof(int)) {
    8db4:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    8db6:	2b03      	cmp	r3, #3
    8db8:	d81e      	bhi.n	8df8 <lwip_setsockopt+0x84>
				err = EINVAL;
    8dba:	2016      	movs	r0, #22
    8dbc:	e039      	b.n	8e32 <lwip_setsockopt+0xbe>
			if (optlen < sizeof(int)) {
    8dbe:	9b0a      	ldr	r3, [sp, #40]	; 0x28
				err = EINVAL;
    8dc0:	2b03      	cmp	r3, #3
			if ((sock->conn->type != NETCONN_UDP) || ((udp_flags(sock->conn->pcb.udp) & UDP_FLAGS_UDPLITE) != 0)) {
    8dc2:	6823      	ldr	r3, [r4, #0]
    8dc4:	781a      	ldrb	r2, [r3, #0]
				err = EINVAL;
    8dc6:	bf8c      	ite	hi
    8dc8:	2000      	movhi	r0, #0
    8dca:	2016      	movls	r0, #22
			if ((sock->conn->type != NETCONN_UDP) || ((udp_flags(sock->conn->pcb.udp) & UDP_FLAGS_UDPLITE) != 0)) {
    8dcc:	2a20      	cmp	r2, #32
    8dce:	d103      	bne.n	8dd8 <lwip_setsockopt+0x64>
    8dd0:	685b      	ldr	r3, [r3, #4]
    8dd2:	7c1b      	ldrb	r3, [r3, #16]
    8dd4:	079b      	lsls	r3, r3, #30
    8dd6:	d52a      	bpl.n	8e2e <lwip_setsockopt+0xba>
				err = EAFNOSUPPORT;
    8dd8:	2061      	movs	r0, #97	; 0x61
    8dda:	e02a      	b.n	8e32 <lwip_setsockopt+0xbe>
		switch (optname) {
    8ddc:	1e6b      	subs	r3, r5, #1
    8dde:	2b01      	cmp	r3, #1
    8de0:	d9e8      	bls.n	8db4 <lwip_setsockopt+0x40>
    8de2:	e7dd      	b.n	8da0 <lwip_setsockopt+0x2c>
		if (optlen < sizeof(int)) {
    8de4:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    8de6:	2b03      	cmp	r3, #3
    8de8:	d9e7      	bls.n	8dba <lwip_setsockopt+0x46>
		if (sock->conn->type != NETCONN_TCP)
    8dea:	6803      	ldr	r3, [r0, #0]
    8dec:	781b      	ldrb	r3, [r3, #0]
    8dee:	2b10      	cmp	r3, #16
    8df0:	d121      	bne.n	8e36 <lwip_setsockopt+0xc2>
		switch (optname) {
    8df2:	1e6b      	subs	r3, r5, #1
    8df4:	2b01      	cmp	r3, #1
    8df6:	d8d3      	bhi.n	8da0 <lwip_setsockopt+0x2c>
	data.optlen  = &optlen;
    8df8:	ab0a      	add	r3, sp, #40	; 0x28
	data.level   = level;
    8dfa:	e9cd 4100 	strd	r4, r1, [sp]
	data.optval  = (void *)optval;
    8dfe:	e9cd 5602 	strd	r5, r6, [sp, #8]
	data.optlen  = &optlen;
    8e02:	9304      	str	r3, [sp, #16]
	data.err     = err;
    8e04:	2500      	movs	r5, #0
	tcpip_callback(lwip_setsockopt_internal, &data);
    8e06:	4b0e      	ldr	r3, [pc, #56]	; (8e40 <lwip_setsockopt+0xcc>)
    8e08:	480e      	ldr	r0, [pc, #56]	; (8e44 <lwip_setsockopt+0xd0>)
	data.err     = err;
    8e0a:	f88d 5014 	strb.w	r5, [sp, #20]
	tcpip_callback(lwip_setsockopt_internal, &data);
    8e0e:	2201      	movs	r2, #1
    8e10:	4669      	mov	r1, sp
    8e12:	4798      	blx	r3
	sys_arch_sem_wait(&sock->conn->op_completed, 0);
    8e14:	6820      	ldr	r0, [r4, #0]
    8e16:	4b0c      	ldr	r3, [pc, #48]	; (8e48 <lwip_setsockopt+0xd4>)
    8e18:	4629      	mov	r1, r5
    8e1a:	300c      	adds	r0, #12
    8e1c:	4798      	blx	r3
	err = data.err;
    8e1e:	f99d 0014 	ldrsb.w	r0, [sp, #20]
	sock_set_errno(sock, err);
    8e22:	6120      	str	r0, [r4, #16]
	return err ? -1 : 0;
    8e24:	1b40      	subs	r0, r0, r5
    8e26:	bf18      	it	ne
    8e28:	2001      	movne	r0, #1
    8e2a:	4240      	negs	r0, r0
    8e2c:	e7af      	b.n	8d8e <lwip_setsockopt+0x1a>
	if (err != ERR_OK) {
    8e2e:	2800      	cmp	r0, #0
    8e30:	d0e2      	beq.n	8df8 <lwip_setsockopt+0x84>
		sock_set_errno(sock, err);
    8e32:	6120      	str	r0, [r4, #16]
    8e34:	e7a9      	b.n	8d8a <lwip_setsockopt+0x16>
			return 0;
    8e36:	2000      	movs	r0, #0
    8e38:	e7a9      	b.n	8d8e <lwip_setsockopt+0x1a>
    8e3a:	bf00      	nop
    8e3c:	000085b5 	.word	0x000085b5
    8e40:	00009349 	.word	0x00009349
    8e44:	000086f5 	.word	0x000086f5
    8e48:	00006acd 	.word	0x00006acd

00008e4c <prvTaskExitError>:
	its caller as there is nothing to return to.  If a task wants to exit it
	should instead call vTaskDelete( NULL ).

	Artificially force an assert() to be triggered if configASSERT() is
	defined, then stop here so application writers can catch the error. */
	configASSERT(uxCriticalNesting == ~0UL);
    8e4c:	4b0a      	ldr	r3, [pc, #40]	; (8e78 <prvTaskExitError+0x2c>)
    8e4e:	681b      	ldr	r3, [r3, #0]
    8e50:	3301      	adds	r3, #1
    8e52:	d008      	beq.n	8e66 <prvTaskExitError+0x1a>
    8e54:	f04f 0380 	mov.w	r3, #128	; 0x80
    8e58:	f383 8811 	msr	BASEPRI, r3
    8e5c:	f3bf 8f6f 	isb	sy
    8e60:	f3bf 8f4f 	dsb	sy
    8e64:	e7fe      	b.n	8e64 <prvTaskExitError+0x18>
    8e66:	f04f 0380 	mov.w	r3, #128	; 0x80
    8e6a:	f383 8811 	msr	BASEPRI, r3
    8e6e:	f3bf 8f6f 	isb	sy
    8e72:	f3bf 8f4f 	dsb	sy
	portDISABLE_INTERRUPTS();
	for (;;)
    8e76:	e7fe      	b.n	8e76 <prvTaskExitError+0x2a>
    8e78:	20000014 	.word	0x20000014

00008e7c <prvPortStartFirstTask>:
}
/*-----------------------------------------------------------*/

static void prvPortStartFirstTask(void)
{
	__asm volatile(" ldr r0, =0xE000ED08 	\n" /* Use the NVIC offset register to locate the stack. */
    8e7c:	4806      	ldr	r0, [pc, #24]	; (8e98 <prvPortStartFirstTask+0x1c>)
    8e7e:	6800      	ldr	r0, [r0, #0]
    8e80:	6800      	ldr	r0, [r0, #0]
    8e82:	f380 8808 	msr	MSP, r0
    8e86:	b662      	cpsie	i
    8e88:	b661      	cpsie	f
    8e8a:	f3bf 8f4f 	dsb	sy
    8e8e:	f3bf 8f6f 	isb	sy
    8e92:	df00      	svc	0
    8e94:	bf00      	nop
	               " cpsie f				\n"
	               " dsb					\n"
	               " isb					\n"
	               " svc 0					\n" /* System call to start first task. */
	               " nop					\n");
}
    8e96:	0000      	.short	0x0000
    8e98:	e000ed08 	.word	0xe000ed08

00008e9c <vPortEnableVFP>:
/*-----------------------------------------------------------*/

/* This is a naked function. */
static void vPortEnableVFP(void)
{
	__asm volatile("	ldr.w r0, =0xE000ED88		\n" /* The FPU enable bits are in the CPACR. */
    8e9c:	f8df 000c 	ldr.w	r0, [pc, #12]	; 8eac <vPortEnableVFP+0x10>
    8ea0:	6801      	ldr	r1, [r0, #0]
    8ea2:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
    8ea6:	6001      	str	r1, [r0, #0]
    8ea8:	4770      	bx	lr
	               "	ldr r1, [r0]				\n"
	               "								\n"
	               "	orr r1, r1, #( 0xf << 20 )	\n" /* Enable CP10 and CP11 coprocessors, then save back. */
	               "	str r1, [r0]				\n"
	               "	bx r14						");
}
    8eaa:	0000      	.short	0x0000
    8eac:	e000ed88 	.word	0xe000ed88

00008eb0 <pxPortInitialiseStack>:
	*pxTopOfStack = portINITIAL_XPSR; /* xPSR */
    8eb0:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
	*pxTopOfStack = (StackType_t)pxCode; /* PC */
    8eb4:	e940 1302 	strd	r1, r3, [r0, #-8]
	*pxTopOfStack = (StackType_t)portTASK_RETURN_ADDRESS; /* LR */
    8eb8:	4b05      	ldr	r3, [pc, #20]	; (8ed0 <pxPortInitialiseStack+0x20>)
    8eba:	f840 3c0c 	str.w	r3, [r0, #-12]
	*pxTopOfStack = portINITIAL_EXEC_RETURN;
    8ebe:	f06f 0302 	mvn.w	r3, #2
	*pxTopOfStack = (StackType_t)pvParameters; /* R0 */
    8ec2:	f840 2c20 	str.w	r2, [r0, #-32]
	*pxTopOfStack = portINITIAL_EXEC_RETURN;
    8ec6:	f840 3c24 	str.w	r3, [r0, #-36]
}
    8eca:	3844      	subs	r0, #68	; 0x44
    8ecc:	4770      	bx	lr
    8ece:	bf00      	nop
    8ed0:	00008e4d 	.word	0x00008e4d

00008ed4 <SVCall_Handler>:
	__asm volatile("	ldr	r3, pxCurrentTCBConst2		\n" /* Restore the context. */
    8ed4:	4b06      	ldr	r3, [pc, #24]	; (8ef0 <pxCurrentTCBConst2>)
    8ed6:	6819      	ldr	r1, [r3, #0]
    8ed8:	6808      	ldr	r0, [r1, #0]
    8eda:	e8b0 4ff0 	ldmia.w	r0!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    8ede:	f380 8809 	msr	PSP, r0
    8ee2:	f3bf 8f6f 	isb	sy
    8ee6:	f04f 0000 	mov.w	r0, #0
    8eea:	f380 8811 	msr	BASEPRI, r0
    8eee:	4770      	bx	lr

00008ef0 <pxCurrentTCBConst2>:
    8ef0:	20016244 	.word	0x20016244

00008ef4 <vPortEnterCritical>:
    8ef4:	f04f 0380 	mov.w	r3, #128	; 0x80
    8ef8:	f383 8811 	msr	BASEPRI, r3
    8efc:	f3bf 8f6f 	isb	sy
    8f00:	f3bf 8f4f 	dsb	sy
	uxCriticalNesting++;
    8f04:	4a0a      	ldr	r2, [pc, #40]	; (8f30 <vPortEnterCritical+0x3c>)
    8f06:	6813      	ldr	r3, [r2, #0]
    8f08:	3301      	adds	r3, #1
	if (uxCriticalNesting == 1) {
    8f0a:	2b01      	cmp	r3, #1
	uxCriticalNesting++;
    8f0c:	6013      	str	r3, [r2, #0]
	if (uxCriticalNesting == 1) {
    8f0e:	d10e      	bne.n	8f2e <vPortEnterCritical+0x3a>
		configASSERT((portNVIC_INT_CTRL_REG & portVECTACTIVE_MASK) == 0);
    8f10:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
    8f14:	f8d3 3d04 	ldr.w	r3, [r3, #3332]	; 0xd04
    8f18:	b2db      	uxtb	r3, r3
    8f1a:	b143      	cbz	r3, 8f2e <vPortEnterCritical+0x3a>
    8f1c:	f04f 0380 	mov.w	r3, #128	; 0x80
    8f20:	f383 8811 	msr	BASEPRI, r3
    8f24:	f3bf 8f6f 	isb	sy
    8f28:	f3bf 8f4f 	dsb	sy
    8f2c:	e7fe      	b.n	8f2c <vPortEnterCritical+0x38>
}
    8f2e:	4770      	bx	lr
    8f30:	20000014 	.word	0x20000014

00008f34 <vPortExitCritical>:
	configASSERT(uxCriticalNesting);
    8f34:	4a08      	ldr	r2, [pc, #32]	; (8f58 <vPortExitCritical+0x24>)
    8f36:	6813      	ldr	r3, [r2, #0]
    8f38:	b943      	cbnz	r3, 8f4c <vPortExitCritical+0x18>
    8f3a:	f04f 0380 	mov.w	r3, #128	; 0x80
    8f3e:	f383 8811 	msr	BASEPRI, r3
    8f42:	f3bf 8f6f 	isb	sy
    8f46:	f3bf 8f4f 	dsb	sy
    8f4a:	e7fe      	b.n	8f4a <vPortExitCritical+0x16>
	uxCriticalNesting--;
    8f4c:	3b01      	subs	r3, #1
    8f4e:	6013      	str	r3, [r2, #0]
	if (uxCriticalNesting == 0) {
    8f50:	b90b      	cbnz	r3, 8f56 <vPortExitCritical+0x22>
	__asm volatile("	msr basepri, %0	" ::"r"(ulNewMaskValue));
    8f52:	f383 8811 	msr	BASEPRI, r3
}
    8f56:	4770      	bx	lr
    8f58:	20000014 	.word	0x20000014

00008f5c <PendSV_Handler>:
	__asm volatile(
    8f5c:	f3ef 8009 	mrs	r0, PSP
    8f60:	f3bf 8f6f 	isb	sy
    8f64:	4b14      	ldr	r3, [pc, #80]	; (8fb8 <pxCurrentTCBConst>)
    8f66:	681a      	ldr	r2, [r3, #0]
    8f68:	f01e 0f10 	tst.w	lr, #16
    8f6c:	bf08      	it	eq
    8f6e:	ed20 8a10 	vstmdbeq	r0!, {s16-s31}
    8f72:	e920 4ff0 	stmdb	r0!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    8f76:	6010      	str	r0, [r2, #0]
    8f78:	f84d 3d04 	str.w	r3, [sp, #-4]!
    8f7c:	f04f 0080 	mov.w	r0, #128	; 0x80
    8f80:	f380 8811 	msr	BASEPRI, r0
    8f84:	f3bf 8f4f 	dsb	sy
    8f88:	f3bf 8f6f 	isb	sy
    8f8c:	f7ff f940 	bl	8210 <vTaskSwitchContext>
    8f90:	f04f 0000 	mov.w	r0, #0
    8f94:	f380 8811 	msr	BASEPRI, r0
    8f98:	bc08      	pop	{r3}
    8f9a:	6819      	ldr	r1, [r3, #0]
    8f9c:	6808      	ldr	r0, [r1, #0]
    8f9e:	e8b0 4ff0 	ldmia.w	r0!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    8fa2:	f01e 0f10 	tst.w	lr, #16
    8fa6:	bf08      	it	eq
    8fa8:	ecb0 8a10 	vldmiaeq	r0!, {s16-s31}
    8fac:	f380 8809 	msr	PSP, r0
    8fb0:	f3bf 8f6f 	isb	sy
    8fb4:	4770      	bx	lr
    8fb6:	bf00      	nop

00008fb8 <pxCurrentTCBConst>:
    8fb8:	20016244 	.word	0x20016244

00008fbc <SysTick_Handler>:
{
    8fbc:	b508      	push	{r3, lr}
	__asm volatile("	mrs %0, basepri											\n"
    8fbe:	f3ef 8311 	mrs	r3, BASEPRI
    8fc2:	f04f 0280 	mov.w	r2, #128	; 0x80
    8fc6:	f382 8811 	msr	BASEPRI, r2
    8fca:	f3bf 8f6f 	isb	sy
    8fce:	f3bf 8f4f 	dsb	sy
		if (xTaskIncrementTick() != pdFALSE) {
    8fd2:	4b06      	ldr	r3, [pc, #24]	; (8fec <SysTick_Handler+0x30>)
    8fd4:	4798      	blx	r3
    8fd6:	b128      	cbz	r0, 8fe4 <SysTick_Handler+0x28>
			portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT;
    8fd8:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
    8fdc:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
    8fe0:	f8c3 2d04 	str.w	r2, [r3, #3332]	; 0xd04
	__asm volatile("	msr basepri, %0	" ::"r"(ulNewMaskValue));
    8fe4:	2300      	movs	r3, #0
    8fe6:	f383 8811 	msr	BASEPRI, r3
}
    8fea:	bd08      	pop	{r3, pc}
    8fec:	00007f45 	.word	0x00007f45

00008ff0 <vPortSetupTimerInterrupt>:
	portNVIC_SYSTICK_LOAD_REG = (configSYSTICK_CLOCK_HZ / configTICK_RATE_HZ) - 1UL;
    8ff0:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
    8ff4:	f642 62df 	movw	r2, #11999	; 0x2edf
    8ff8:	615a      	str	r2, [r3, #20]
	portNVIC_SYSTICK_CTRL_REG = (portNVIC_SYSTICK_CLK_BIT | portNVIC_SYSTICK_INT_BIT | portNVIC_SYSTICK_ENABLE_BIT);
    8ffa:	2207      	movs	r2, #7
    8ffc:	611a      	str	r2, [r3, #16]
}
    8ffe:	4770      	bx	lr

00009000 <xPortStartScheduler>:
	configASSERT(portCPUID != portCORTEX_M7_r0p1_ID);
    9000:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
{
    9004:	b513      	push	{r0, r1, r4, lr}
	configASSERT(portCPUID != portCORTEX_M7_r0p1_ID);
    9006:	4a34      	ldr	r2, [pc, #208]	; (90d8 <xPortStartScheduler+0xd8>)
    9008:	f8d3 1d00 	ldr.w	r1, [r3, #3328]	; 0xd00
    900c:	4291      	cmp	r1, r2
    900e:	d108      	bne.n	9022 <xPortStartScheduler+0x22>
	__asm volatile("	mov %0, %1												\n"
    9010:	f04f 0380 	mov.w	r3, #128	; 0x80
    9014:	f383 8811 	msr	BASEPRI, r3
    9018:	f3bf 8f6f 	isb	sy
    901c:	f3bf 8f4f 	dsb	sy
    9020:	e7fe      	b.n	9020 <xPortStartScheduler+0x20>
	configASSERT(portCPUID != portCORTEX_M7_r0p0_ID);
    9022:	f8d3 2d00 	ldr.w	r2, [r3, #3328]	; 0xd00
    9026:	4b2d      	ldr	r3, [pc, #180]	; (90dc <xPortStartScheduler+0xdc>)
    9028:	429a      	cmp	r2, r3
    902a:	d108      	bne.n	903e <xPortStartScheduler+0x3e>
    902c:	f04f 0380 	mov.w	r3, #128	; 0x80
    9030:	f383 8811 	msr	BASEPRI, r3
    9034:	f3bf 8f6f 	isb	sy
    9038:	f3bf 8f4f 	dsb	sy
    903c:	e7fe      	b.n	903c <xPortStartScheduler+0x3c>
		ulOriginalPriority = *pucFirstUserPriorityRegister;
    903e:	4b28      	ldr	r3, [pc, #160]	; (90e0 <xPortStartScheduler+0xe0>)
    9040:	781a      	ldrb	r2, [r3, #0]
    9042:	b2d2      	uxtb	r2, r2
    9044:	9201      	str	r2, [sp, #4]
		*pucFirstUserPriorityRegister = portMAX_8_BIT_VALUE;
    9046:	22ff      	movs	r2, #255	; 0xff
    9048:	701a      	strb	r2, [r3, #0]
		ucMaxPriorityValue = *pucFirstUserPriorityRegister;
    904a:	781b      	ldrb	r3, [r3, #0]
		ucMaxSysCallPriority = configMAX_SYSCALL_INTERRUPT_PRIORITY & ucMaxPriorityValue;
    904c:	4a25      	ldr	r2, [pc, #148]	; (90e4 <xPortStartScheduler+0xe4>)
		ucMaxPriorityValue = *pucFirstUserPriorityRegister;
    904e:	b2db      	uxtb	r3, r3
    9050:	f88d 3003 	strb.w	r3, [sp, #3]
		ucMaxSysCallPriority = configMAX_SYSCALL_INTERRUPT_PRIORITY & ucMaxPriorityValue;
    9054:	f89d 3003 	ldrb.w	r3, [sp, #3]
    9058:	f003 0380 	and.w	r3, r3, #128	; 0x80
    905c:	7013      	strb	r3, [r2, #0]
		ulMaxPRIGROUPValue = portMAX_PRIGROUP_BITS;
    905e:	2307      	movs	r3, #7
    9060:	6053      	str	r3, [r2, #4]
		while ((ucMaxPriorityValue & portTOP_BIT_OF_BYTE) == portTOP_BIT_OF_BYTE) {
    9062:	2100      	movs	r1, #0
    9064:	f89d 0003 	ldrb.w	r0, [sp, #3]
    9068:	0600      	lsls	r0, r0, #24
    906a:	f103 34ff 	add.w	r4, r3, #4294967295	; 0xffffffff
    906e:	d429      	bmi.n	90c4 <xPortStartScheduler+0xc4>
    9070:	b101      	cbz	r1, 9074 <xPortStartScheduler+0x74>
    9072:	6053      	str	r3, [r2, #4]
		ulMaxPRIGROUPValue <<= portPRIGROUP_SHIFT;
    9074:	6853      	ldr	r3, [r2, #4]
    9076:	021b      	lsls	r3, r3, #8
		ulMaxPRIGROUPValue &= portPRIORITY_GROUP_MASK;
    9078:	f403 63e0 	and.w	r3, r3, #1792	; 0x700
    907c:	6053      	str	r3, [r2, #4]
		*pucFirstUserPriorityRegister = ulOriginalPriority;
    907e:	9b01      	ldr	r3, [sp, #4]
    9080:	4a17      	ldr	r2, [pc, #92]	; (90e0 <xPortStartScheduler+0xe0>)
	portNVIC_SYSPRI2_REG |= portNVIC_PENDSV_PRI;
    9082:	f04f 24e0 	mov.w	r4, #3758153728	; 0xe000e000
		*pucFirstUserPriorityRegister = ulOriginalPriority;
    9086:	b2db      	uxtb	r3, r3
    9088:	7013      	strb	r3, [r2, #0]
	portNVIC_SYSPRI2_REG |= portNVIC_PENDSV_PRI;
    908a:	f8d4 3d20 	ldr.w	r3, [r4, #3360]	; 0xd20
    908e:	f443 0360 	orr.w	r3, r3, #14680064	; 0xe00000
    9092:	f8c4 3d20 	str.w	r3, [r4, #3360]	; 0xd20
	portNVIC_SYSPRI2_REG |= portNVIC_SYSTICK_PRI;
    9096:	f8d4 3d20 	ldr.w	r3, [r4, #3360]	; 0xd20
    909a:	f043 4360 	orr.w	r3, r3, #3758096384	; 0xe0000000
    909e:	f8c4 3d20 	str.w	r3, [r4, #3360]	; 0xd20
	vPortSetupTimerInterrupt();
    90a2:	4b11      	ldr	r3, [pc, #68]	; (90e8 <xPortStartScheduler+0xe8>)
    90a4:	4798      	blx	r3
	uxCriticalNesting = 0;
    90a6:	4b11      	ldr	r3, [pc, #68]	; (90ec <xPortStartScheduler+0xec>)
    90a8:	2200      	movs	r2, #0
    90aa:	601a      	str	r2, [r3, #0]
	vPortEnableVFP();
    90ac:	4b10      	ldr	r3, [pc, #64]	; (90f0 <xPortStartScheduler+0xf0>)
    90ae:	4798      	blx	r3
	*(portFPCCR) |= portASPEN_AND_LSPEN_BITS;
    90b0:	f8d4 3f34 	ldr.w	r3, [r4, #3892]	; 0xf34
    90b4:	f043 4340 	orr.w	r3, r3, #3221225472	; 0xc0000000
    90b8:	f8c4 3f34 	str.w	r3, [r4, #3892]	; 0xf34
	prvPortStartFirstTask();
    90bc:	4b0d      	ldr	r3, [pc, #52]	; (90f4 <xPortStartScheduler+0xf4>)
    90be:	4798      	blx	r3
	prvTaskExitError();
    90c0:	4b0d      	ldr	r3, [pc, #52]	; (90f8 <xPortStartScheduler+0xf8>)
    90c2:	4798      	blx	r3
			ucMaxPriorityValue <<= (uint8_t)0x01;
    90c4:	f89d 3003 	ldrb.w	r3, [sp, #3]
    90c8:	005b      	lsls	r3, r3, #1
    90ca:	b2db      	uxtb	r3, r3
    90cc:	f88d 3003 	strb.w	r3, [sp, #3]
    90d0:	2101      	movs	r1, #1
    90d2:	4623      	mov	r3, r4
    90d4:	e7c6      	b.n	9064 <xPortStartScheduler+0x64>
    90d6:	bf00      	nop
    90d8:	410fc271 	.word	0x410fc271
    90dc:	410fc270 	.word	0x410fc270
    90e0:	e000e400 	.word	0xe000e400
    90e4:	2001637c 	.word	0x2001637c
    90e8:	00008ff1 	.word	0x00008ff1
    90ec:	20000014 	.word	0x20000014
    90f0:	00008e9d 	.word	0x00008e9d
    90f4:	00008e7d 	.word	0x00008e7d
    90f8:	00008e4d 	.word	0x00008e4d

000090fc <vPortValidateInterruptPriority>:
{
	uint32_t ulCurrentInterrupt;
	uint8_t  ucCurrentPriority;

	/* Obtain the number of the currently executing interrupt. */
	__asm volatile("mrs %0, ipsr" : "=r"(ulCurrentInterrupt));
    90fc:	f3ef 8305 	mrs	r3, IPSR

	/* Is the interrupt number a user defined interrupt? */
	if (ulCurrentInterrupt >= portFIRST_USER_INTERRUPT_NUMBER) {
    9100:	2b0f      	cmp	r3, #15
    9102:	4a11      	ldr	r2, [pc, #68]	; (9148 <vPortValidateInterruptPriority+0x4c>)
    9104:	d90d      	bls.n	9122 <vPortValidateInterruptPriority+0x26>
		/* Look up the interrupt's priority. */
		ucCurrentPriority = pcInterruptPriorityRegisters[ulCurrentInterrupt];
    9106:	4911      	ldr	r1, [pc, #68]	; (914c <vPortValidateInterruptPriority+0x50>)
    9108:	5c5b      	ldrb	r3, [r3, r1]
		interrupt entry is as fast and simple as possible.

		The following links provide detailed information:
		http://www.freertos.org/RTOS-Cortex-M3-M4.html
		http://www.freertos.org/FAQHelp.html */
		configASSERT(ucCurrentPriority >= ucMaxSysCallPriority);
    910a:	7811      	ldrb	r1, [r2, #0]
    910c:	4299      	cmp	r1, r3
    910e:	d908      	bls.n	9122 <vPortValidateInterruptPriority+0x26>
    9110:	f04f 0380 	mov.w	r3, #128	; 0x80
    9114:	f383 8811 	msr	BASEPRI, r3
    9118:	f3bf 8f6f 	isb	sy
    911c:	f3bf 8f4f 	dsb	sy
    9120:	e7fe      	b.n	9120 <vPortValidateInterruptPriority+0x24>
	configuration then the correct setting can be achieved on all Cortex-M
	devices by calling NVIC_SetPriorityGrouping( 0 ); before starting the
	scheduler.  Note however that some vendor specific peripheral libraries
	assume a non-zero priority group setting, in which cases using a value
	of zero will result in unpredicable behaviour. */
	configASSERT((portAIRCR_REG & portPRIORITY_GROUP_MASK) <= ulMaxPRIGROUPValue);
    9122:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
    9126:	6852      	ldr	r2, [r2, #4]
    9128:	f8d3 3d0c 	ldr.w	r3, [r3, #3340]	; 0xd0c
    912c:	f403 63e0 	and.w	r3, r3, #1792	; 0x700
    9130:	4293      	cmp	r3, r2
    9132:	d908      	bls.n	9146 <vPortValidateInterruptPriority+0x4a>
    9134:	f04f 0380 	mov.w	r3, #128	; 0x80
    9138:	f383 8811 	msr	BASEPRI, r3
    913c:	f3bf 8f6f 	isb	sy
    9140:	f3bf 8f4f 	dsb	sy
    9144:	e7fe      	b.n	9144 <vPortValidateInterruptPriority+0x48>
}
    9146:	4770      	bx	lr
    9148:	2001637c 	.word	0x2001637c
    914c:	e000e3f0 	.word	0xe000e3f0

00009150 <netif_init>:
	netif_add(&loop_netif, &loop_ipaddr, &loop_netmask, &loop_gw, NULL, netif_loopif_init, tcpip_input);
#endif /* NO_SYS */
	netif_set_up(&loop_netif);

#endif /* LWIP_HAVE_LOOPIF */
}
    9150:	4770      	bx	lr
	...

00009154 <netif_set_ipaddr>:
 *
 * @note call netif_set_addr() if you also want to change netmask and
 * default gateway
 */
void netif_set_ipaddr(struct netif *netif, ip_addr_t *ipaddr)
{
    9154:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    9156:	4605      	mov	r5, r0
#if LWIP_TCP
	struct tcp_pcb *       pcb;
	struct tcp_pcb_listen *lpcb;

	/* address is actually being changed? */
	if (ipaddr && (ip_addr_cmp(ipaddr, &(netif->ip_addr))) == 0) {
    9158:	460c      	mov	r4, r1
    915a:	b159      	cbz	r1, 9174 <netif_set_ipaddr+0x20>
    915c:	680a      	ldr	r2, [r1, #0]
    915e:	6843      	ldr	r3, [r0, #4]
    9160:	429a      	cmp	r2, r3
    9162:	d006      	beq.n	9172 <netif_set_ipaddr+0x1e>
		/* extern struct tcp_pcb *tcp_active_pcbs; defined by tcp.h */
		LWIP_DEBUGF(NETIF_DEBUG | LWIP_DBG_STATE, ("netif_set_ipaddr: netif address being changed\n"));
		pcb = tcp_active_pcbs;
    9164:	4b0d      	ldr	r3, [pc, #52]	; (919c <netif_set_ipaddr+0x48>)
#endif /* LWIP_AUTOIP */
			) {
				/* this connection must be aborted */
				struct tcp_pcb *next = pcb->next;
				LWIP_DEBUGF(NETIF_DEBUG | LWIP_DBG_STATE, ("netif_set_ipaddr: aborting TCP pcb %p\n", (void *)pcb));
				tcp_abort(pcb);
    9166:	4e0e      	ldr	r6, [pc, #56]	; (91a0 <netif_set_ipaddr+0x4c>)
		pcb = tcp_active_pcbs;
    9168:	6818      	ldr	r0, [r3, #0]
		while (pcb != NULL) {
    916a:	b928      	cbnz	r0, 9178 <netif_set_ipaddr+0x24>
				pcb = next;
			} else {
				pcb = pcb->next;
			}
		}
		for (lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
    916c:	4b0d      	ldr	r3, [pc, #52]	; (91a4 <netif_set_ipaddr+0x50>)
    916e:	681b      	ldr	r3, [r3, #0]
    9170:	b953      	cbnz	r3, 9188 <netif_set_ipaddr+0x34>
	}
#endif
	snmp_delete_ipaddridx_tree(netif);
	snmp_delete_iprteidx_tree(0, netif);
	/* set new IP address to netif */
	ip_addr_set(&(netif->ip_addr), ipaddr);
    9172:	6824      	ldr	r4, [r4, #0]
    9174:	606c      	str	r4, [r5, #4]
	             netif->name[1],
	             ip4_addr1_16(&netif->ip_addr),
	             ip4_addr2_16(&netif->ip_addr),
	             ip4_addr3_16(&netif->ip_addr),
	             ip4_addr4_16(&netif->ip_addr)));
}
    9176:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
			if (ip_addr_cmp(&(pcb->local_ip), &(netif->ip_addr))
    9178:	6802      	ldr	r2, [r0, #0]
    917a:	686b      	ldr	r3, [r5, #4]
				struct tcp_pcb *next = pcb->next;
    917c:	68c7      	ldr	r7, [r0, #12]
			if (ip_addr_cmp(&(pcb->local_ip), &(netif->ip_addr))
    917e:	429a      	cmp	r2, r3
    9180:	d100      	bne.n	9184 <netif_set_ipaddr+0x30>
				tcp_abort(pcb);
    9182:	47b0      	blx	r6
{
    9184:	4638      	mov	r0, r7
    9186:	e7f0      	b.n	916a <netif_set_ipaddr+0x16>
			if ((!(ip_addr_isany(&(lpcb->local_ip)))) && (ip_addr_cmp(&(lpcb->local_ip), &(netif->ip_addr)))) {
    9188:	681a      	ldr	r2, [r3, #0]
    918a:	b122      	cbz	r2, 9196 <netif_set_ipaddr+0x42>
    918c:	6869      	ldr	r1, [r5, #4]
    918e:	428a      	cmp	r2, r1
				ip_addr_set(&(lpcb->local_ip), ipaddr);
    9190:	bf04      	itt	eq
    9192:	6822      	ldreq	r2, [r4, #0]
    9194:	601a      	streq	r2, [r3, #0]
		for (lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
    9196:	68db      	ldr	r3, [r3, #12]
    9198:	e7ea      	b.n	9170 <netif_set_ipaddr+0x1c>
    919a:	bf00      	nop
    919c:	200148fc 	.word	0x200148fc
    91a0:	000062ed 	.word	0x000062ed
    91a4:	200148f0 	.word	0x200148f0

000091a8 <netif_set_addr>:
{
    91a8:	b570      	push	{r4, r5, r6, lr}
    91aa:	4615      	mov	r5, r2
    91ac:	461c      	mov	r4, r3
	netif_set_ipaddr(netif, ipaddr);
    91ae:	4b05      	ldr	r3, [pc, #20]	; (91c4 <netif_set_addr+0x1c>)
{
    91b0:	4606      	mov	r6, r0
	netif_set_ipaddr(netif, ipaddr);
    91b2:	4798      	blx	r3
 */
void netif_set_netmask(struct netif *netif, ip_addr_t *netmask)
{
	snmp_delete_iprteidx_tree(0, netif);
	/* set new netmask to netif */
	ip_addr_set(&(netif->netmask), netmask);
    91b4:	b105      	cbz	r5, 91b8 <netif_set_addr+0x10>
    91b6:	682d      	ldr	r5, [r5, #0]
    91b8:	60b5      	str	r5, [r6, #8]
	ip_addr_set(&(netif->gw), gw);
    91ba:	b104      	cbz	r4, 91be <netif_set_addr+0x16>
    91bc:	6824      	ldr	r4, [r4, #0]
    91be:	60f4      	str	r4, [r6, #12]
}
    91c0:	bd70      	pop	{r4, r5, r6, pc}
    91c2:	bf00      	nop
    91c4:	00009155 	.word	0x00009155

000091c8 <netif_add>:
{
    91c8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	netif->state = state;
    91ca:	9e06      	ldr	r6, [sp, #24]
    91cc:	6206      	str	r6, [r0, #32]
	netif->num   = netif_num++;
    91ce:	4e0f      	ldr	r6, [pc, #60]	; (920c <netif_add+0x44>)
    91d0:	7937      	ldrb	r7, [r6, #4]
    91d2:	f880 7030 	strb.w	r7, [r0, #48]	; 0x30
	ip_addr_set_zero(&netif->ip_addr);
    91d6:	2500      	movs	r5, #0
	netif->num   = netif_num++;
    91d8:	f107 0c01 	add.w	ip, r7, #1
	netif->input = input;
    91dc:	9f08      	ldr	r7, [sp, #32]
    91de:	6107      	str	r7, [r0, #16]
	ip_addr_set_zero(&netif->netmask);
    91e0:	e9c0 5501 	strd	r5, r5, [r0, #4]
{
    91e4:	4604      	mov	r4, r0
	ip_addr_set_zero(&netif->gw);
    91e6:	60c5      	str	r5, [r0, #12]
	netif->flags = 0;
    91e8:	f880 502d 	strb.w	r5, [r0, #45]	; 0x2d
	netif->status_callback = NULL;
    91ec:	61c5      	str	r5, [r0, #28]
	netif_set_addr(netif, ipaddr, netmask, gw);
    91ee:	4f08      	ldr	r7, [pc, #32]	; (9210 <netif_add+0x48>)
	netif->num   = netif_num++;
    91f0:	f886 c004 	strb.w	ip, [r6, #4]
	netif_set_addr(netif, ipaddr, netmask, gw);
    91f4:	47b8      	blx	r7
	if (init(netif) != ERR_OK) {
    91f6:	9b07      	ldr	r3, [sp, #28]
    91f8:	4620      	mov	r0, r4
    91fa:	4798      	blx	r3
    91fc:	b920      	cbnz	r0, 9208 <netif_add+0x40>
	netif->next = netif_list;
    91fe:	6833      	ldr	r3, [r6, #0]
    9200:	6023      	str	r3, [r4, #0]
	netif_list  = netif;
    9202:	6034      	str	r4, [r6, #0]
}
    9204:	4620      	mov	r0, r4
    9206:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		return NULL;
    9208:	462c      	mov	r4, r5
    920a:	e7fb      	b.n	9204 <netif_add+0x3c>
    920c:	20016384 	.word	0x20016384
    9210:	000091a9 	.word	0x000091a9

00009214 <netif_set_default>:
		snmp_delete_iprteidx_tree(1, netif);
	} else {
		/* install default route */
		snmp_insert_iprteidx_tree(1, netif);
	}
	netif_default = netif;
    9214:	4b01      	ldr	r3, [pc, #4]	; (921c <netif_set_default+0x8>)
    9216:	6098      	str	r0, [r3, #8]
	LWIP_DEBUGF(
	    NETIF_DEBUG,
	    ("netif: setting default interface %c%c\n", netif ? netif->name[0] : '\'', netif ? netif->name[1] : '\''));
}
    9218:	4770      	bx	lr
    921a:	bf00      	nop
    921c:	20016384 	.word	0x20016384

00009220 <netif_set_up>:
 * up once configured.
 *
 * @see dhcp_start()
 */
void netif_set_up(struct netif *netif)
{
    9220:	b510      	push	{r4, lr}
	if (!(netif->flags & NETIF_FLAG_UP)) {
    9222:	f890 302d 	ldrb.w	r3, [r0, #45]	; 0x2d
    9226:	07da      	lsls	r2, r3, #31
{
    9228:	4604      	mov	r4, r0
	if (!(netif->flags & NETIF_FLAG_UP)) {
    922a:	d412      	bmi.n	9252 <netif_set_up+0x32>
		netif->flags |= NETIF_FLAG_UP;
    922c:	f043 0301 	orr.w	r3, r3, #1
    9230:	f880 302d 	strb.w	r3, [r0, #45]	; 0x2d

#if LWIP_SNMP
		snmp_get_sysuptime(&netif->ts);
#endif /* LWIP_SNMP */

		NETIF_STATUS_CALLBACK(netif);
    9234:	69c3      	ldr	r3, [r0, #28]
    9236:	b103      	cbz	r3, 923a <netif_set_up+0x1a>
    9238:	4798      	blx	r3

		if (netif->flags & NETIF_FLAG_LINK_UP) {
#if LWIP_ARP
			/* For Ethernet network interfaces, we would like to send a "gratuitous ARP" */
			if (netif->flags & (NETIF_FLAG_ETHARP)) {
    923a:	f894 302d 	ldrb.w	r3, [r4, #45]	; 0x2d
    923e:	f003 0330 	and.w	r3, r3, #48	; 0x30
    9242:	2b30      	cmp	r3, #48	; 0x30
    9244:	d105      	bne.n	9252 <netif_set_up+0x32>
				etharp_gratuitous(netif);
    9246:	1d21      	adds	r1, r4, #4
    9248:	4620      	mov	r0, r4
    924a:	4b02      	ldr	r3, [pc, #8]	; (9254 <netif_set_up+0x34>)
				igmp_report_groups(netif);
			}
#endif /* LWIP_IGMP */
		}
	}
}
    924c:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
				etharp_gratuitous(netif);
    9250:	4718      	bx	r3
}
    9252:	bd10      	pop	{r4, pc}
    9254:	00004ea5 	.word	0x00004ea5

00009258 <tcpip_thread>:
 * thread context.
 *
 * @param arg unused argument
 */
static void tcpip_thread(void *arg)
{
    9258:	b507      	push	{r0, r1, r2, lr}
	struct tcpip_msg *msg;
	LWIP_UNUSED_ARG(arg);

	if (tcpip_init_done != NULL) {
    925a:	4a1e      	ldr	r2, [pc, #120]	; (92d4 <tcpip_thread+0x7c>)
    925c:	6813      	ldr	r3, [r2, #0]
    925e:	b10b      	cbz	r3, 9264 <tcpip_thread+0xc>
		tcpip_init_done(tcpip_init_done_arg);
    9260:	6850      	ldr	r0, [r2, #4]
    9262:	4798      	blx	r3
	LOCK_TCPIP_CORE();
	while (1) { /* MAIN Loop */
		UNLOCK_TCPIP_CORE();
		LWIP_TCPIP_THREAD_ALIVE();
		/* wait for a message, timeouts are processed while waiting */
		sys_timeouts_mbox_fetch(&mbox, (void **)&msg);
    9264:	4e1c      	ldr	r6, [pc, #112]	; (92d8 <tcpip_thread+0x80>)
    9266:	4d1d      	ldr	r5, [pc, #116]	; (92dc <tcpip_thread+0x84>)
#endif /* LWIP_TCPIP_TIMEOUT */

		case TCPIP_MSG_CALLBACK:
			LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip_thread: CALLBACK %p\n", (void *)msg));
			msg->msg.cb.function(msg->msg.cb.ctx);
			memp_free(MEMP_TCPIP_MSG_API, msg);
    9268:	4c1d      	ldr	r4, [pc, #116]	; (92e0 <tcpip_thread+0x88>)
		sys_timeouts_mbox_fetch(&mbox, (void **)&msg);
    926a:	a901      	add	r1, sp, #4
    926c:	4630      	mov	r0, r6
    926e:	47a8      	blx	r5
		switch (msg->type) {
    9270:	9b01      	ldr	r3, [sp, #4]
    9272:	781a      	ldrb	r2, [r3, #0]
    9274:	2a05      	cmp	r2, #5
    9276:	d8f8      	bhi.n	926a <tcpip_thread+0x12>
    9278:	e8df f002 	tbb	[pc, r2]
    927c:	1e160803 	.word	0x1e160803
    9280:	2723      	.short	0x2723
			msg->msg.apimsg->function(&(msg->msg.apimsg->msg));
    9282:	6898      	ldr	r0, [r3, #8]
    9284:	f850 3b04 	ldr.w	r3, [r0], #4
    9288:	4798      	blx	r3
			break;
    928a:	e7ee      	b.n	926a <tcpip_thread+0x12>
			msg->msg.apimsg->function(&(msg->msg.apimsg->msg));
    928c:	e9d3 0102 	ldrd	r0, r1, [r3, #8]
			if (msg->msg.inp.netif->flags & (NETIF_FLAG_ETHARP | NETIF_FLAG_ETHERNET)) {
    9290:	f891 302d 	ldrb.w	r3, [r1, #45]	; 0x2d
    9294:	f013 0f60 	tst.w	r3, #96	; 0x60
				ethernet_input(msg->msg.inp.p, msg->msg.inp.netif);
    9298:	bf14      	ite	ne
    929a:	4b12      	ldrne	r3, [pc, #72]	; (92e4 <tcpip_thread+0x8c>)
				ip_input(msg->msg.inp.p, msg->msg.inp.netif);
    929c:	4b12      	ldreq	r3, [pc, #72]	; (92e8 <tcpip_thread+0x90>)
    929e:	4798      	blx	r3
			memp_free(MEMP_TCPIP_MSG_INPKT, msg);
    92a0:	9901      	ldr	r1, [sp, #4]
    92a2:	2009      	movs	r0, #9
			memp_free(MEMP_TCPIP_MSG_API, msg);
    92a4:	47a0      	blx	r4
			break;
    92a6:	e7e0      	b.n	926a <tcpip_thread+0x12>
			sys_timeout(msg->msg.tmo.msecs, msg->msg.tmo.h, msg->msg.tmo.arg);
    92a8:	e9d3 1203 	ldrd	r1, r2, [r3, #12]
    92ac:	6898      	ldr	r0, [r3, #8]
    92ae:	4b0f      	ldr	r3, [pc, #60]	; (92ec <tcpip_thread+0x94>)
    92b0:	4798      	blx	r3
			memp_free(MEMP_TCPIP_MSG_API, msg);
    92b2:	9901      	ldr	r1, [sp, #4]
    92b4:	2008      	movs	r0, #8
    92b6:	e7f5      	b.n	92a4 <tcpip_thread+0x4c>
			sys_untimeout(msg->msg.tmo.h, msg->msg.tmo.arg);
    92b8:	e9d3 0103 	ldrd	r0, r1, [r3, #12]
    92bc:	4b0c      	ldr	r3, [pc, #48]	; (92f0 <tcpip_thread+0x98>)
    92be:	4798      	blx	r3
			memp_free(MEMP_TCPIP_MSG_API, msg);
    92c0:	e7f7      	b.n	92b2 <tcpip_thread+0x5a>
			msg->msg.cb.function(msg->msg.cb.ctx);
    92c2:	e9d3 2002 	ldrd	r2, r0, [r3, #8]
    92c6:	4790      	blx	r2
			memp_free(MEMP_TCPIP_MSG_API, msg);
    92c8:	e7f3      	b.n	92b2 <tcpip_thread+0x5a>
			break;

		case TCPIP_MSG_CALLBACK_STATIC:
			LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip_thread: CALLBACK_STATIC %p\n", (void *)msg));
			msg->msg.cb.function(msg->msg.cb.ctx);
    92ca:	e9d3 2002 	ldrd	r2, r0, [r3, #8]
    92ce:	4790      	blx	r2
			break;
    92d0:	e7cb      	b.n	926a <tcpip_thread+0x12>
    92d2:	bf00      	nop
    92d4:	20016390 	.word	0x20016390
    92d8:	20016398 	.word	0x20016398
    92dc:	000011dd 	.word	0x000011dd
    92e0:	00004b49 	.word	0x00004b49
    92e4:	000051b9 	.word	0x000051b9
    92e8:	00005429 	.word	0x00005429
    92ec:	00001049 	.word	0x00001049
    92f0:	00001191 	.word	0x00001191

000092f4 <tcpip_input>:
 *          to an IP header (if inp doesn't have NETIF_FLAG_ETHARP or
 *          NETIF_FLAG_ETHERNET flags)
 * @param inp the network interface on which the packet was received
 */
err_t tcpip_input(struct pbuf *p, struct netif *inp)
{
    92f4:	b570      	push	{r4, r5, r6, lr}
	UNLOCK_TCPIP_CORE();
	return ret;
#else  /* LWIP_TCPIP_CORE_LOCKING_INPUT */
	struct tcpip_msg *msg;

	if (!sys_mbox_valid(&mbox)) {
    92f6:	4b0f      	ldr	r3, [pc, #60]	; (9334 <tcpip_input+0x40>)
{
    92f8:	4606      	mov	r6, r0
	if (!sys_mbox_valid(&mbox)) {
    92fa:	480f      	ldr	r0, [pc, #60]	; (9338 <tcpip_input+0x44>)
{
    92fc:	460d      	mov	r5, r1
	if (!sys_mbox_valid(&mbox)) {
    92fe:	4798      	blx	r3
    9300:	b1a0      	cbz	r0, 932c <tcpip_input+0x38>
		return ERR_VAL;
	}
	msg = (struct tcpip_msg *)memp_malloc(MEMP_TCPIP_MSG_INPKT);
    9302:	4b0e      	ldr	r3, [pc, #56]	; (933c <tcpip_input+0x48>)
    9304:	2009      	movs	r0, #9
    9306:	4798      	blx	r3
	if (msg == NULL) {
    9308:	4604      	mov	r4, r0
    930a:	b160      	cbz	r0, 9326 <tcpip_input+0x32>
		return ERR_MEM;
	}

	msg->type          = TCPIP_MSG_INPKT;
    930c:	2301      	movs	r3, #1
    930e:	7003      	strb	r3, [r0, #0]
	msg->msg.inp.p     = p;
	msg->msg.inp.netif = inp;
    9310:	e9c0 6502 	strd	r6, r5, [r0, #8]
	if (sys_mbox_trypost(&mbox, msg) != ERR_OK) {
    9314:	4601      	mov	r1, r0
    9316:	4b0a      	ldr	r3, [pc, #40]	; (9340 <tcpip_input+0x4c>)
    9318:	4807      	ldr	r0, [pc, #28]	; (9338 <tcpip_input+0x44>)
    931a:	4798      	blx	r3
    931c:	b140      	cbz	r0, 9330 <tcpip_input+0x3c>
		memp_free(MEMP_TCPIP_MSG_INPKT, msg);
    931e:	4b09      	ldr	r3, [pc, #36]	; (9344 <tcpip_input+0x50>)
    9320:	4621      	mov	r1, r4
    9322:	2009      	movs	r0, #9
    9324:	4798      	blx	r3
		return ERR_MEM;
    9326:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    932a:	e001      	b.n	9330 <tcpip_input+0x3c>
		return ERR_VAL;
    932c:	f06f 0005 	mvn.w	r0, #5
		return ERR_MEM;
	}
	return ERR_OK;
#endif /* LWIP_TCPIP_CORE_LOCKING_INPUT */
}
    9330:	bd70      	pop	{r4, r5, r6, pc}
    9332:	bf00      	nop
    9334:	00006c71 	.word	0x00006c71
    9338:	20016398 	.word	0x20016398
    933c:	00004b2d 	.word	0x00004b2d
    9340:	00006b7d 	.word	0x00006b7d
    9344:	00004b49 	.word	0x00004b49

00009348 <tcpip_callback_with_block>:
 * @param ctx parameter passed to f
 * @param block 1 to block until the request is posted, 0 to non-blocking mode
 * @return ERR_OK if the function was called, another err_t if not
 */
err_t tcpip_callback_with_block(tcpip_callback_fn function, void *ctx, u8_t block)
{
    9348:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    934a:	4607      	mov	r7, r0
	struct tcpip_msg *msg;

	if (sys_mbox_valid(&mbox)) {
    934c:	4b11      	ldr	r3, [pc, #68]	; (9394 <tcpip_callback_with_block+0x4c>)
    934e:	4812      	ldr	r0, [pc, #72]	; (9398 <tcpip_callback_with_block+0x50>)
{
    9350:	460e      	mov	r6, r1
    9352:	4615      	mov	r5, r2
	if (sys_mbox_valid(&mbox)) {
    9354:	4798      	blx	r3
    9356:	b1d0      	cbz	r0, 938e <tcpip_callback_with_block+0x46>
		msg = (struct tcpip_msg *)memp_malloc(MEMP_TCPIP_MSG_API);
    9358:	4b10      	ldr	r3, [pc, #64]	; (939c <tcpip_callback_with_block+0x54>)
    935a:	2008      	movs	r0, #8
    935c:	4798      	blx	r3
		if (msg == NULL) {
    935e:	4604      	mov	r4, r0
    9360:	b190      	cbz	r0, 9388 <tcpip_callback_with_block+0x40>
			return ERR_MEM;
		}

		msg->type            = TCPIP_MSG_CALLBACK;
    9362:	2304      	movs	r3, #4
		msg->msg.cb.function = function;
		msg->msg.cb.ctx      = ctx;
    9364:	e9c0 7602 	strd	r7, r6, [r0, #8]
		msg->type            = TCPIP_MSG_CALLBACK;
    9368:	7003      	strb	r3, [r0, #0]
		if (block) {
			sys_mbox_post(&mbox, msg);
    936a:	4601      	mov	r1, r0
    936c:	480a      	ldr	r0, [pc, #40]	; (9398 <tcpip_callback_with_block+0x50>)
		if (block) {
    936e:	b11d      	cbz	r5, 9378 <tcpip_callback_with_block+0x30>
			sys_mbox_post(&mbox, msg);
    9370:	4b0b      	ldr	r3, [pc, #44]	; (93a0 <tcpip_callback_with_block+0x58>)
    9372:	4798      	blx	r3
			if (sys_mbox_trypost(&mbox, msg) != ERR_OK) {
				memp_free(MEMP_TCPIP_MSG_API, msg);
				return ERR_MEM;
			}
		}
		return ERR_OK;
    9374:	2000      	movs	r0, #0
	}
	return ERR_VAL;
}
    9376:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
			if (sys_mbox_trypost(&mbox, msg) != ERR_OK) {
    9378:	4b0a      	ldr	r3, [pc, #40]	; (93a4 <tcpip_callback_with_block+0x5c>)
    937a:	4798      	blx	r3
    937c:	2800      	cmp	r0, #0
    937e:	d0fa      	beq.n	9376 <tcpip_callback_with_block+0x2e>
				memp_free(MEMP_TCPIP_MSG_API, msg);
    9380:	4b09      	ldr	r3, [pc, #36]	; (93a8 <tcpip_callback_with_block+0x60>)
    9382:	4621      	mov	r1, r4
    9384:	2008      	movs	r0, #8
    9386:	4798      	blx	r3
			return ERR_MEM;
    9388:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    938c:	e7f3      	b.n	9376 <tcpip_callback_with_block+0x2e>
	return ERR_VAL;
    938e:	f06f 0005 	mvn.w	r0, #5
    9392:	e7f0      	b.n	9376 <tcpip_callback_with_block+0x2e>
    9394:	00006c71 	.word	0x00006c71
    9398:	20016398 	.word	0x20016398
    939c:	00004b2d 	.word	0x00004b2d
    93a0:	00006b59 	.word	0x00006b59
    93a4:	00006b7d 	.word	0x00006b7d
    93a8:	00004b49 	.word	0x00004b49

000093ac <tcpip_apimsg>:
 *
 * @param apimsg a struct containing the function to call and its parameters
 * @return ERR_OK if the function was called, another err_t if not
 */
err_t tcpip_apimsg(struct api_msg *apimsg)
{
    93ac:	b530      	push	{r4, r5, lr}
#ifdef LWIP_DEBUG
	/* catch functions that don't set err */
	apimsg->msg.err = ERR_VAL;
#endif

	if (sys_mbox_valid(&mbox)) {
    93ae:	4b0d      	ldr	r3, [pc, #52]	; (93e4 <tcpip_apimsg+0x38>)
{
    93b0:	b087      	sub	sp, #28
    93b2:	4604      	mov	r4, r0
	if (sys_mbox_valid(&mbox)) {
    93b4:	480c      	ldr	r0, [pc, #48]	; (93e8 <tcpip_apimsg+0x3c>)
    93b6:	4798      	blx	r3
    93b8:	b180      	cbz	r0, 93dc <tcpip_apimsg+0x30>
		msg.type       = TCPIP_MSG_API;
		msg.msg.apimsg = apimsg;
		sys_mbox_post(&mbox, &msg);
    93ba:	480b      	ldr	r0, [pc, #44]	; (93e8 <tcpip_apimsg+0x3c>)
    93bc:	4b0b      	ldr	r3, [pc, #44]	; (93ec <tcpip_apimsg+0x40>)
		msg.msg.apimsg = apimsg;
    93be:	9403      	str	r4, [sp, #12]
		msg.type       = TCPIP_MSG_API;
    93c0:	2500      	movs	r5, #0
		sys_mbox_post(&mbox, &msg);
    93c2:	a901      	add	r1, sp, #4
		msg.type       = TCPIP_MSG_API;
    93c4:	f88d 5004 	strb.w	r5, [sp, #4]
		sys_mbox_post(&mbox, &msg);
    93c8:	4798      	blx	r3
		sys_arch_sem_wait(&apimsg->msg.conn->op_completed, 0);
    93ca:	6860      	ldr	r0, [r4, #4]
    93cc:	4b08      	ldr	r3, [pc, #32]	; (93f0 <tcpip_apimsg+0x44>)
    93ce:	4629      	mov	r1, r5
    93d0:	300c      	adds	r0, #12
    93d2:	4798      	blx	r3
		return apimsg->msg.err;
    93d4:	f994 0008 	ldrsb.w	r0, [r4, #8]
	}
	return ERR_VAL;
}
    93d8:	b007      	add	sp, #28
    93da:	bd30      	pop	{r4, r5, pc}
	return ERR_VAL;
    93dc:	f06f 0005 	mvn.w	r0, #5
    93e0:	e7fa      	b.n	93d8 <tcpip_apimsg+0x2c>
    93e2:	bf00      	nop
    93e4:	00006c71 	.word	0x00006c71
    93e8:	20016398 	.word	0x20016398
    93ec:	00006b59 	.word	0x00006b59
    93f0:	00006acd 	.word	0x00006acd

000093f4 <tcpip_init>:
 *
 * @param initfunc a function to call when tcpip_thread is running and finished initializing
 * @param arg argument to pass to initfunc
 */
void tcpip_init(tcpip_init_done_fn initfunc, void *arg)
{
    93f4:	b537      	push	{r0, r1, r2, r4, r5, lr}
	lwip_init();
    93f6:	4b0b      	ldr	r3, [pc, #44]	; (9424 <tcpip_init+0x30>)
{
    93f8:	4605      	mov	r5, r0
    93fa:	460c      	mov	r4, r1
	lwip_init();
    93fc:	4798      	blx	r3

	tcpip_init_done     = initfunc;
    93fe:	480a      	ldr	r0, [pc, #40]	; (9428 <tcpip_init+0x34>)
	tcpip_init_done_arg = arg;
	if (sys_mbox_new(&mbox, TCPIP_MBOX_SIZE) != ERR_OK) {
    9400:	4b0a      	ldr	r3, [pc, #40]	; (942c <tcpip_init+0x38>)
	tcpip_init_done_arg = arg;
    9402:	e9c0 5400 	strd	r5, r4, [r0]
	if (sys_mbox_new(&mbox, TCPIP_MBOX_SIZE) != ERR_OK) {
    9406:	2110      	movs	r1, #16
    9408:	3008      	adds	r0, #8
    940a:	4798      	blx	r3
	if (sys_mutex_new(&lock_tcpip_core) != ERR_OK) {
		LWIP_ASSERT("failed to create lock_tcpip_core", 0);
	}
#endif /* LWIP_TCPIP_CORE_LOCKING */

	sys_thread_new(TCPIP_THREAD_NAME, tcpip_thread, NULL, TCPIP_THREAD_STACKSIZE, TCPIP_THREAD_PRIO);
    940c:	2301      	movs	r3, #1
    940e:	9300      	str	r3, [sp, #0]
    9410:	4907      	ldr	r1, [pc, #28]	; (9430 <tcpip_init+0x3c>)
    9412:	4c08      	ldr	r4, [pc, #32]	; (9434 <tcpip_init+0x40>)
    9414:	4808      	ldr	r0, [pc, #32]	; (9438 <tcpip_init+0x44>)
    9416:	f44f 6383 	mov.w	r3, #1048	; 0x418
    941a:	2200      	movs	r2, #0
    941c:	47a0      	blx	r4
}
    941e:	b003      	add	sp, #12
    9420:	bd30      	pop	{r4, r5, pc}
    9422:	bf00      	nop
    9424:	00006fb5 	.word	0x00006fb5
    9428:	20016390 	.word	0x20016390
    942c:	00006b31 	.word	0x00006b31
    9430:	00009259 	.word	0x00009259
    9434:	00006c7d 	.word	0x00006c7d
    9438:	0000aae4 	.word	0x0000aae4

0000943c <__libc_init_array>:
    943c:	b570      	push	{r4, r5, r6, lr}
    943e:	4d0d      	ldr	r5, [pc, #52]	; (9474 <__libc_init_array+0x38>)
    9440:	4c0d      	ldr	r4, [pc, #52]	; (9478 <__libc_init_array+0x3c>)
    9442:	1b64      	subs	r4, r4, r5
    9444:	10a4      	asrs	r4, r4, #2
    9446:	2600      	movs	r6, #0
    9448:	42a6      	cmp	r6, r4
    944a:	d109      	bne.n	9460 <__libc_init_array+0x24>
    944c:	4d0b      	ldr	r5, [pc, #44]	; (947c <__libc_init_array+0x40>)
    944e:	4c0c      	ldr	r4, [pc, #48]	; (9480 <__libc_init_array+0x44>)
    9450:	f001 fb9c 	bl	ab8c <_init>
    9454:	1b64      	subs	r4, r4, r5
    9456:	10a4      	asrs	r4, r4, #2
    9458:	2600      	movs	r6, #0
    945a:	42a6      	cmp	r6, r4
    945c:	d105      	bne.n	946a <__libc_init_array+0x2e>
    945e:	bd70      	pop	{r4, r5, r6, pc}
    9460:	f855 3b04 	ldr.w	r3, [r5], #4
    9464:	4798      	blx	r3
    9466:	3601      	adds	r6, #1
    9468:	e7ee      	b.n	9448 <__libc_init_array+0xc>
    946a:	f855 3b04 	ldr.w	r3, [r5], #4
    946e:	4798      	blx	r3
    9470:	3601      	adds	r6, #1
    9472:	e7f2      	b.n	945a <__libc_init_array+0x1e>
    9474:	0000ab98 	.word	0x0000ab98
    9478:	0000ab98 	.word	0x0000ab98
    947c:	0000ab98 	.word	0x0000ab98
    9480:	0000ab9c 	.word	0x0000ab9c

00009484 <memcmp>:
    9484:	b510      	push	{r4, lr}
    9486:	3901      	subs	r1, #1
    9488:	4402      	add	r2, r0
    948a:	4290      	cmp	r0, r2
    948c:	d101      	bne.n	9492 <memcmp+0xe>
    948e:	2000      	movs	r0, #0
    9490:	e005      	b.n	949e <memcmp+0x1a>
    9492:	7803      	ldrb	r3, [r0, #0]
    9494:	f811 4f01 	ldrb.w	r4, [r1, #1]!
    9498:	42a3      	cmp	r3, r4
    949a:	d001      	beq.n	94a0 <memcmp+0x1c>
    949c:	1b18      	subs	r0, r3, r4
    949e:	bd10      	pop	{r4, pc}
    94a0:	3001      	adds	r0, #1
    94a2:	e7f2      	b.n	948a <memcmp+0x6>

000094a4 <memcpy>:
    94a4:	440a      	add	r2, r1
    94a6:	4291      	cmp	r1, r2
    94a8:	f100 33ff 	add.w	r3, r0, #4294967295	; 0xffffffff
    94ac:	d100      	bne.n	94b0 <memcpy+0xc>
    94ae:	4770      	bx	lr
    94b0:	b510      	push	{r4, lr}
    94b2:	f811 4b01 	ldrb.w	r4, [r1], #1
    94b6:	f803 4f01 	strb.w	r4, [r3, #1]!
    94ba:	4291      	cmp	r1, r2
    94bc:	d1f9      	bne.n	94b2 <memcpy+0xe>
    94be:	bd10      	pop	{r4, pc}

000094c0 <memset>:
    94c0:	4402      	add	r2, r0
    94c2:	4603      	mov	r3, r0
    94c4:	4293      	cmp	r3, r2
    94c6:	d100      	bne.n	94ca <memset+0xa>
    94c8:	4770      	bx	lr
    94ca:	f803 1b01 	strb.w	r1, [r3], #1
    94ce:	e7f9      	b.n	94c4 <memset+0x4>

000094d0 <iprintf>:
    94d0:	b40f      	push	{r0, r1, r2, r3}
    94d2:	4b0a      	ldr	r3, [pc, #40]	; (94fc <iprintf+0x2c>)
    94d4:	b513      	push	{r0, r1, r4, lr}
    94d6:	681c      	ldr	r4, [r3, #0]
    94d8:	b124      	cbz	r4, 94e4 <iprintf+0x14>
    94da:	69a3      	ldr	r3, [r4, #24]
    94dc:	b913      	cbnz	r3, 94e4 <iprintf+0x14>
    94de:	4620      	mov	r0, r4
    94e0:	f000 fb3c 	bl	9b5c <__sinit>
    94e4:	ab05      	add	r3, sp, #20
    94e6:	9a04      	ldr	r2, [sp, #16]
    94e8:	68a1      	ldr	r1, [r4, #8]
    94ea:	9301      	str	r3, [sp, #4]
    94ec:	4620      	mov	r0, r4
    94ee:	f000 fd49 	bl	9f84 <_vfiprintf_r>
    94f2:	b002      	add	sp, #8
    94f4:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    94f8:	b004      	add	sp, #16
    94fa:	4770      	bx	lr
    94fc:	20000018 	.word	0x20000018

00009500 <_puts_r>:
    9500:	b570      	push	{r4, r5, r6, lr}
    9502:	460e      	mov	r6, r1
    9504:	4605      	mov	r5, r0
    9506:	b118      	cbz	r0, 9510 <_puts_r+0x10>
    9508:	6983      	ldr	r3, [r0, #24]
    950a:	b90b      	cbnz	r3, 9510 <_puts_r+0x10>
    950c:	f000 fb26 	bl	9b5c <__sinit>
    9510:	69ab      	ldr	r3, [r5, #24]
    9512:	68ac      	ldr	r4, [r5, #8]
    9514:	b913      	cbnz	r3, 951c <_puts_r+0x1c>
    9516:	4628      	mov	r0, r5
    9518:	f000 fb20 	bl	9b5c <__sinit>
    951c:	4b2c      	ldr	r3, [pc, #176]	; (95d0 <_puts_r+0xd0>)
    951e:	429c      	cmp	r4, r3
    9520:	d120      	bne.n	9564 <_puts_r+0x64>
    9522:	686c      	ldr	r4, [r5, #4]
    9524:	6e63      	ldr	r3, [r4, #100]	; 0x64
    9526:	07db      	lsls	r3, r3, #31
    9528:	d405      	bmi.n	9536 <_puts_r+0x36>
    952a:	89a3      	ldrh	r3, [r4, #12]
    952c:	0598      	lsls	r0, r3, #22
    952e:	d402      	bmi.n	9536 <_puts_r+0x36>
    9530:	6da0      	ldr	r0, [r4, #88]	; 0x58
    9532:	f000 fbb1 	bl	9c98 <__retarget_lock_acquire_recursive>
    9536:	89a3      	ldrh	r3, [r4, #12]
    9538:	0719      	lsls	r1, r3, #28
    953a:	d51d      	bpl.n	9578 <_puts_r+0x78>
    953c:	6923      	ldr	r3, [r4, #16]
    953e:	b1db      	cbz	r3, 9578 <_puts_r+0x78>
    9540:	3e01      	subs	r6, #1
    9542:	68a3      	ldr	r3, [r4, #8]
    9544:	f816 1f01 	ldrb.w	r1, [r6, #1]!
    9548:	3b01      	subs	r3, #1
    954a:	60a3      	str	r3, [r4, #8]
    954c:	bb39      	cbnz	r1, 959e <_puts_r+0x9e>
    954e:	2b00      	cmp	r3, #0
    9550:	da38      	bge.n	95c4 <_puts_r+0xc4>
    9552:	4622      	mov	r2, r4
    9554:	210a      	movs	r1, #10
    9556:	4628      	mov	r0, r5
    9558:	f000 f92a 	bl	97b0 <__swbuf_r>
    955c:	3001      	adds	r0, #1
    955e:	d011      	beq.n	9584 <_puts_r+0x84>
    9560:	250a      	movs	r5, #10
    9562:	e011      	b.n	9588 <_puts_r+0x88>
    9564:	4b1b      	ldr	r3, [pc, #108]	; (95d4 <_puts_r+0xd4>)
    9566:	429c      	cmp	r4, r3
    9568:	d101      	bne.n	956e <_puts_r+0x6e>
    956a:	68ac      	ldr	r4, [r5, #8]
    956c:	e7da      	b.n	9524 <_puts_r+0x24>
    956e:	4b1a      	ldr	r3, [pc, #104]	; (95d8 <_puts_r+0xd8>)
    9570:	429c      	cmp	r4, r3
    9572:	bf08      	it	eq
    9574:	68ec      	ldreq	r4, [r5, #12]
    9576:	e7d5      	b.n	9524 <_puts_r+0x24>
    9578:	4621      	mov	r1, r4
    957a:	4628      	mov	r0, r5
    957c:	f000 f96a 	bl	9854 <__swsetup_r>
    9580:	2800      	cmp	r0, #0
    9582:	d0dd      	beq.n	9540 <_puts_r+0x40>
    9584:	f04f 35ff 	mov.w	r5, #4294967295	; 0xffffffff
    9588:	6e63      	ldr	r3, [r4, #100]	; 0x64
    958a:	07da      	lsls	r2, r3, #31
    958c:	d405      	bmi.n	959a <_puts_r+0x9a>
    958e:	89a3      	ldrh	r3, [r4, #12]
    9590:	059b      	lsls	r3, r3, #22
    9592:	d402      	bmi.n	959a <_puts_r+0x9a>
    9594:	6da0      	ldr	r0, [r4, #88]	; 0x58
    9596:	f000 fb80 	bl	9c9a <__retarget_lock_release_recursive>
    959a:	4628      	mov	r0, r5
    959c:	bd70      	pop	{r4, r5, r6, pc}
    959e:	2b00      	cmp	r3, #0
    95a0:	da04      	bge.n	95ac <_puts_r+0xac>
    95a2:	69a2      	ldr	r2, [r4, #24]
    95a4:	429a      	cmp	r2, r3
    95a6:	dc06      	bgt.n	95b6 <_puts_r+0xb6>
    95a8:	290a      	cmp	r1, #10
    95aa:	d004      	beq.n	95b6 <_puts_r+0xb6>
    95ac:	6823      	ldr	r3, [r4, #0]
    95ae:	1c5a      	adds	r2, r3, #1
    95b0:	6022      	str	r2, [r4, #0]
    95b2:	7019      	strb	r1, [r3, #0]
    95b4:	e7c5      	b.n	9542 <_puts_r+0x42>
    95b6:	4622      	mov	r2, r4
    95b8:	4628      	mov	r0, r5
    95ba:	f000 f8f9 	bl	97b0 <__swbuf_r>
    95be:	3001      	adds	r0, #1
    95c0:	d1bf      	bne.n	9542 <_puts_r+0x42>
    95c2:	e7df      	b.n	9584 <_puts_r+0x84>
    95c4:	6823      	ldr	r3, [r4, #0]
    95c6:	250a      	movs	r5, #10
    95c8:	1c5a      	adds	r2, r3, #1
    95ca:	6022      	str	r2, [r4, #0]
    95cc:	701d      	strb	r5, [r3, #0]
    95ce:	e7db      	b.n	9588 <_puts_r+0x88>
    95d0:	0000ab18 	.word	0x0000ab18
    95d4:	0000ab38 	.word	0x0000ab38
    95d8:	0000aaf8 	.word	0x0000aaf8

000095dc <puts>:
    95dc:	4b02      	ldr	r3, [pc, #8]	; (95e8 <puts+0xc>)
    95de:	4601      	mov	r1, r0
    95e0:	6818      	ldr	r0, [r3, #0]
    95e2:	f7ff bf8d 	b.w	9500 <_puts_r>
    95e6:	bf00      	nop
    95e8:	20000018 	.word	0x20000018

000095ec <setbuf>:
    95ec:	2900      	cmp	r1, #0
    95ee:	f44f 6380 	mov.w	r3, #1024	; 0x400
    95f2:	bf0c      	ite	eq
    95f4:	2202      	moveq	r2, #2
    95f6:	2200      	movne	r2, #0
    95f8:	f000 b800 	b.w	95fc <setvbuf>

000095fc <setvbuf>:
    95fc:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
    9600:	461d      	mov	r5, r3
    9602:	4b5d      	ldr	r3, [pc, #372]	; (9778 <setvbuf+0x17c>)
    9604:	681f      	ldr	r7, [r3, #0]
    9606:	4604      	mov	r4, r0
    9608:	460e      	mov	r6, r1
    960a:	4690      	mov	r8, r2
    960c:	b127      	cbz	r7, 9618 <setvbuf+0x1c>
    960e:	69bb      	ldr	r3, [r7, #24]
    9610:	b913      	cbnz	r3, 9618 <setvbuf+0x1c>
    9612:	4638      	mov	r0, r7
    9614:	f000 faa2 	bl	9b5c <__sinit>
    9618:	4b58      	ldr	r3, [pc, #352]	; (977c <setvbuf+0x180>)
    961a:	429c      	cmp	r4, r3
    961c:	d167      	bne.n	96ee <setvbuf+0xf2>
    961e:	687c      	ldr	r4, [r7, #4]
    9620:	f1b8 0f02 	cmp.w	r8, #2
    9624:	d006      	beq.n	9634 <setvbuf+0x38>
    9626:	f1b8 0f01 	cmp.w	r8, #1
    962a:	f200 809f 	bhi.w	976c <setvbuf+0x170>
    962e:	2d00      	cmp	r5, #0
    9630:	f2c0 809c 	blt.w	976c <setvbuf+0x170>
    9634:	6e63      	ldr	r3, [r4, #100]	; 0x64
    9636:	07db      	lsls	r3, r3, #31
    9638:	d405      	bmi.n	9646 <setvbuf+0x4a>
    963a:	89a3      	ldrh	r3, [r4, #12]
    963c:	0598      	lsls	r0, r3, #22
    963e:	d402      	bmi.n	9646 <setvbuf+0x4a>
    9640:	6da0      	ldr	r0, [r4, #88]	; 0x58
    9642:	f000 fb29 	bl	9c98 <__retarget_lock_acquire_recursive>
    9646:	4621      	mov	r1, r4
    9648:	4638      	mov	r0, r7
    964a:	f000 f9f3 	bl	9a34 <_fflush_r>
    964e:	6b61      	ldr	r1, [r4, #52]	; 0x34
    9650:	b141      	cbz	r1, 9664 <setvbuf+0x68>
    9652:	f104 0344 	add.w	r3, r4, #68	; 0x44
    9656:	4299      	cmp	r1, r3
    9658:	d002      	beq.n	9660 <setvbuf+0x64>
    965a:	4638      	mov	r0, r7
    965c:	f000 fb8c 	bl	9d78 <_free_r>
    9660:	2300      	movs	r3, #0
    9662:	6363      	str	r3, [r4, #52]	; 0x34
    9664:	2300      	movs	r3, #0
    9666:	61a3      	str	r3, [r4, #24]
    9668:	6063      	str	r3, [r4, #4]
    966a:	89a3      	ldrh	r3, [r4, #12]
    966c:	0619      	lsls	r1, r3, #24
    966e:	d503      	bpl.n	9678 <setvbuf+0x7c>
    9670:	6921      	ldr	r1, [r4, #16]
    9672:	4638      	mov	r0, r7
    9674:	f000 fb80 	bl	9d78 <_free_r>
    9678:	89a3      	ldrh	r3, [r4, #12]
    967a:	f423 634a 	bic.w	r3, r3, #3232	; 0xca0
    967e:	f023 0303 	bic.w	r3, r3, #3
    9682:	f1b8 0f02 	cmp.w	r8, #2
    9686:	81a3      	strh	r3, [r4, #12]
    9688:	d06c      	beq.n	9764 <setvbuf+0x168>
    968a:	ab01      	add	r3, sp, #4
    968c:	466a      	mov	r2, sp
    968e:	4621      	mov	r1, r4
    9690:	4638      	mov	r0, r7
    9692:	f000 fb03 	bl	9c9c <__swhatbuf_r>
    9696:	89a3      	ldrh	r3, [r4, #12]
    9698:	4318      	orrs	r0, r3
    969a:	81a0      	strh	r0, [r4, #12]
    969c:	2d00      	cmp	r5, #0
    969e:	d130      	bne.n	9702 <setvbuf+0x106>
    96a0:	9d00      	ldr	r5, [sp, #0]
    96a2:	4628      	mov	r0, r5
    96a4:	f000 fb60 	bl	9d68 <malloc>
    96a8:	4606      	mov	r6, r0
    96aa:	2800      	cmp	r0, #0
    96ac:	d155      	bne.n	975a <setvbuf+0x15e>
    96ae:	f8dd 9000 	ldr.w	r9, [sp]
    96b2:	45a9      	cmp	r9, r5
    96b4:	d14a      	bne.n	974c <setvbuf+0x150>
    96b6:	f04f 35ff 	mov.w	r5, #4294967295	; 0xffffffff
    96ba:	2200      	movs	r2, #0
    96bc:	60a2      	str	r2, [r4, #8]
    96be:	f104 0247 	add.w	r2, r4, #71	; 0x47
    96c2:	6022      	str	r2, [r4, #0]
    96c4:	6122      	str	r2, [r4, #16]
    96c6:	2201      	movs	r2, #1
    96c8:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
    96cc:	6162      	str	r2, [r4, #20]
    96ce:	6e62      	ldr	r2, [r4, #100]	; 0x64
    96d0:	f043 0302 	orr.w	r3, r3, #2
    96d4:	07d2      	lsls	r2, r2, #31
    96d6:	81a3      	strh	r3, [r4, #12]
    96d8:	d405      	bmi.n	96e6 <setvbuf+0xea>
    96da:	f413 7f00 	tst.w	r3, #512	; 0x200
    96de:	d102      	bne.n	96e6 <setvbuf+0xea>
    96e0:	6da0      	ldr	r0, [r4, #88]	; 0x58
    96e2:	f000 fada 	bl	9c9a <__retarget_lock_release_recursive>
    96e6:	4628      	mov	r0, r5
    96e8:	b003      	add	sp, #12
    96ea:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    96ee:	4b24      	ldr	r3, [pc, #144]	; (9780 <setvbuf+0x184>)
    96f0:	429c      	cmp	r4, r3
    96f2:	d101      	bne.n	96f8 <setvbuf+0xfc>
    96f4:	68bc      	ldr	r4, [r7, #8]
    96f6:	e793      	b.n	9620 <setvbuf+0x24>
    96f8:	4b22      	ldr	r3, [pc, #136]	; (9784 <setvbuf+0x188>)
    96fa:	429c      	cmp	r4, r3
    96fc:	bf08      	it	eq
    96fe:	68fc      	ldreq	r4, [r7, #12]
    9700:	e78e      	b.n	9620 <setvbuf+0x24>
    9702:	2e00      	cmp	r6, #0
    9704:	d0cd      	beq.n	96a2 <setvbuf+0xa6>
    9706:	69bb      	ldr	r3, [r7, #24]
    9708:	b913      	cbnz	r3, 9710 <setvbuf+0x114>
    970a:	4638      	mov	r0, r7
    970c:	f000 fa26 	bl	9b5c <__sinit>
    9710:	f1b8 0f01 	cmp.w	r8, #1
    9714:	bf08      	it	eq
    9716:	89a3      	ldrheq	r3, [r4, #12]
    9718:	6026      	str	r6, [r4, #0]
    971a:	bf04      	itt	eq
    971c:	f043 0301 	orreq.w	r3, r3, #1
    9720:	81a3      	strheq	r3, [r4, #12]
    9722:	89a2      	ldrh	r2, [r4, #12]
    9724:	f012 0308 	ands.w	r3, r2, #8
    9728:	e9c4 6504 	strd	r6, r5, [r4, #16]
    972c:	d01c      	beq.n	9768 <setvbuf+0x16c>
    972e:	07d3      	lsls	r3, r2, #31
    9730:	bf41      	itttt	mi
    9732:	2300      	movmi	r3, #0
    9734:	426d      	negmi	r5, r5
    9736:	60a3      	strmi	r3, [r4, #8]
    9738:	61a5      	strmi	r5, [r4, #24]
    973a:	bf58      	it	pl
    973c:	60a5      	strpl	r5, [r4, #8]
    973e:	6e65      	ldr	r5, [r4, #100]	; 0x64
    9740:	f015 0501 	ands.w	r5, r5, #1
    9744:	d115      	bne.n	9772 <setvbuf+0x176>
    9746:	f412 7f00 	tst.w	r2, #512	; 0x200
    974a:	e7c8      	b.n	96de <setvbuf+0xe2>
    974c:	4648      	mov	r0, r9
    974e:	f000 fb0b 	bl	9d68 <malloc>
    9752:	4606      	mov	r6, r0
    9754:	2800      	cmp	r0, #0
    9756:	d0ae      	beq.n	96b6 <setvbuf+0xba>
    9758:	464d      	mov	r5, r9
    975a:	89a3      	ldrh	r3, [r4, #12]
    975c:	f043 0380 	orr.w	r3, r3, #128	; 0x80
    9760:	81a3      	strh	r3, [r4, #12]
    9762:	e7d0      	b.n	9706 <setvbuf+0x10a>
    9764:	2500      	movs	r5, #0
    9766:	e7a8      	b.n	96ba <setvbuf+0xbe>
    9768:	60a3      	str	r3, [r4, #8]
    976a:	e7e8      	b.n	973e <setvbuf+0x142>
    976c:	f04f 35ff 	mov.w	r5, #4294967295	; 0xffffffff
    9770:	e7b9      	b.n	96e6 <setvbuf+0xea>
    9772:	2500      	movs	r5, #0
    9774:	e7b7      	b.n	96e6 <setvbuf+0xea>
    9776:	bf00      	nop
    9778:	20000018 	.word	0x20000018
    977c:	0000ab18 	.word	0x0000ab18
    9780:	0000ab38 	.word	0x0000ab38
    9784:	0000aaf8 	.word	0x0000aaf8

00009788 <strncmp>:
    9788:	b510      	push	{r4, lr}
    978a:	4603      	mov	r3, r0
    978c:	b172      	cbz	r2, 97ac <strncmp+0x24>
    978e:	3901      	subs	r1, #1
    9790:	1884      	adds	r4, r0, r2
    9792:	f813 0b01 	ldrb.w	r0, [r3], #1
    9796:	f811 2f01 	ldrb.w	r2, [r1, #1]!
    979a:	4290      	cmp	r0, r2
    979c:	d101      	bne.n	97a2 <strncmp+0x1a>
    979e:	42a3      	cmp	r3, r4
    97a0:	d101      	bne.n	97a6 <strncmp+0x1e>
    97a2:	1a80      	subs	r0, r0, r2
    97a4:	bd10      	pop	{r4, pc}
    97a6:	2800      	cmp	r0, #0
    97a8:	d1f3      	bne.n	9792 <strncmp+0xa>
    97aa:	e7fa      	b.n	97a2 <strncmp+0x1a>
    97ac:	4610      	mov	r0, r2
    97ae:	e7f9      	b.n	97a4 <strncmp+0x1c>

000097b0 <__swbuf_r>:
    97b0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    97b2:	460e      	mov	r6, r1
    97b4:	4614      	mov	r4, r2
    97b6:	4605      	mov	r5, r0
    97b8:	b118      	cbz	r0, 97c2 <__swbuf_r+0x12>
    97ba:	6983      	ldr	r3, [r0, #24]
    97bc:	b90b      	cbnz	r3, 97c2 <__swbuf_r+0x12>
    97be:	f000 f9cd 	bl	9b5c <__sinit>
    97c2:	4b21      	ldr	r3, [pc, #132]	; (9848 <__swbuf_r+0x98>)
    97c4:	429c      	cmp	r4, r3
    97c6:	d12b      	bne.n	9820 <__swbuf_r+0x70>
    97c8:	686c      	ldr	r4, [r5, #4]
    97ca:	69a3      	ldr	r3, [r4, #24]
    97cc:	60a3      	str	r3, [r4, #8]
    97ce:	89a3      	ldrh	r3, [r4, #12]
    97d0:	071a      	lsls	r2, r3, #28
    97d2:	d52f      	bpl.n	9834 <__swbuf_r+0x84>
    97d4:	6923      	ldr	r3, [r4, #16]
    97d6:	b36b      	cbz	r3, 9834 <__swbuf_r+0x84>
    97d8:	6923      	ldr	r3, [r4, #16]
    97da:	6820      	ldr	r0, [r4, #0]
    97dc:	1ac0      	subs	r0, r0, r3
    97de:	6963      	ldr	r3, [r4, #20]
    97e0:	b2f6      	uxtb	r6, r6
    97e2:	4283      	cmp	r3, r0
    97e4:	4637      	mov	r7, r6
    97e6:	dc04      	bgt.n	97f2 <__swbuf_r+0x42>
    97e8:	4621      	mov	r1, r4
    97ea:	4628      	mov	r0, r5
    97ec:	f000 f922 	bl	9a34 <_fflush_r>
    97f0:	bb30      	cbnz	r0, 9840 <__swbuf_r+0x90>
    97f2:	68a3      	ldr	r3, [r4, #8]
    97f4:	3b01      	subs	r3, #1
    97f6:	60a3      	str	r3, [r4, #8]
    97f8:	6823      	ldr	r3, [r4, #0]
    97fa:	1c5a      	adds	r2, r3, #1
    97fc:	6022      	str	r2, [r4, #0]
    97fe:	701e      	strb	r6, [r3, #0]
    9800:	6963      	ldr	r3, [r4, #20]
    9802:	3001      	adds	r0, #1
    9804:	4283      	cmp	r3, r0
    9806:	d004      	beq.n	9812 <__swbuf_r+0x62>
    9808:	89a3      	ldrh	r3, [r4, #12]
    980a:	07db      	lsls	r3, r3, #31
    980c:	d506      	bpl.n	981c <__swbuf_r+0x6c>
    980e:	2e0a      	cmp	r6, #10
    9810:	d104      	bne.n	981c <__swbuf_r+0x6c>
    9812:	4621      	mov	r1, r4
    9814:	4628      	mov	r0, r5
    9816:	f000 f90d 	bl	9a34 <_fflush_r>
    981a:	b988      	cbnz	r0, 9840 <__swbuf_r+0x90>
    981c:	4638      	mov	r0, r7
    981e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    9820:	4b0a      	ldr	r3, [pc, #40]	; (984c <__swbuf_r+0x9c>)
    9822:	429c      	cmp	r4, r3
    9824:	d101      	bne.n	982a <__swbuf_r+0x7a>
    9826:	68ac      	ldr	r4, [r5, #8]
    9828:	e7cf      	b.n	97ca <__swbuf_r+0x1a>
    982a:	4b09      	ldr	r3, [pc, #36]	; (9850 <__swbuf_r+0xa0>)
    982c:	429c      	cmp	r4, r3
    982e:	bf08      	it	eq
    9830:	68ec      	ldreq	r4, [r5, #12]
    9832:	e7ca      	b.n	97ca <__swbuf_r+0x1a>
    9834:	4621      	mov	r1, r4
    9836:	4628      	mov	r0, r5
    9838:	f000 f80c 	bl	9854 <__swsetup_r>
    983c:	2800      	cmp	r0, #0
    983e:	d0cb      	beq.n	97d8 <__swbuf_r+0x28>
    9840:	f04f 37ff 	mov.w	r7, #4294967295	; 0xffffffff
    9844:	e7ea      	b.n	981c <__swbuf_r+0x6c>
    9846:	bf00      	nop
    9848:	0000ab18 	.word	0x0000ab18
    984c:	0000ab38 	.word	0x0000ab38
    9850:	0000aaf8 	.word	0x0000aaf8

00009854 <__swsetup_r>:
    9854:	4b32      	ldr	r3, [pc, #200]	; (9920 <__swsetup_r+0xcc>)
    9856:	b570      	push	{r4, r5, r6, lr}
    9858:	681d      	ldr	r5, [r3, #0]
    985a:	4606      	mov	r6, r0
    985c:	460c      	mov	r4, r1
    985e:	b125      	cbz	r5, 986a <__swsetup_r+0x16>
    9860:	69ab      	ldr	r3, [r5, #24]
    9862:	b913      	cbnz	r3, 986a <__swsetup_r+0x16>
    9864:	4628      	mov	r0, r5
    9866:	f000 f979 	bl	9b5c <__sinit>
    986a:	4b2e      	ldr	r3, [pc, #184]	; (9924 <__swsetup_r+0xd0>)
    986c:	429c      	cmp	r4, r3
    986e:	d10f      	bne.n	9890 <__swsetup_r+0x3c>
    9870:	686c      	ldr	r4, [r5, #4]
    9872:	89a3      	ldrh	r3, [r4, #12]
    9874:	f9b4 200c 	ldrsh.w	r2, [r4, #12]
    9878:	0719      	lsls	r1, r3, #28
    987a:	d42c      	bmi.n	98d6 <__swsetup_r+0x82>
    987c:	06dd      	lsls	r5, r3, #27
    987e:	d411      	bmi.n	98a4 <__swsetup_r+0x50>
    9880:	2309      	movs	r3, #9
    9882:	6033      	str	r3, [r6, #0]
    9884:	f042 0340 	orr.w	r3, r2, #64	; 0x40
    9888:	81a3      	strh	r3, [r4, #12]
    988a:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    988e:	e03e      	b.n	990e <__swsetup_r+0xba>
    9890:	4b25      	ldr	r3, [pc, #148]	; (9928 <__swsetup_r+0xd4>)
    9892:	429c      	cmp	r4, r3
    9894:	d101      	bne.n	989a <__swsetup_r+0x46>
    9896:	68ac      	ldr	r4, [r5, #8]
    9898:	e7eb      	b.n	9872 <__swsetup_r+0x1e>
    989a:	4b24      	ldr	r3, [pc, #144]	; (992c <__swsetup_r+0xd8>)
    989c:	429c      	cmp	r4, r3
    989e:	bf08      	it	eq
    98a0:	68ec      	ldreq	r4, [r5, #12]
    98a2:	e7e6      	b.n	9872 <__swsetup_r+0x1e>
    98a4:	0758      	lsls	r0, r3, #29
    98a6:	d512      	bpl.n	98ce <__swsetup_r+0x7a>
    98a8:	6b61      	ldr	r1, [r4, #52]	; 0x34
    98aa:	b141      	cbz	r1, 98be <__swsetup_r+0x6a>
    98ac:	f104 0344 	add.w	r3, r4, #68	; 0x44
    98b0:	4299      	cmp	r1, r3
    98b2:	d002      	beq.n	98ba <__swsetup_r+0x66>
    98b4:	4630      	mov	r0, r6
    98b6:	f000 fa5f 	bl	9d78 <_free_r>
    98ba:	2300      	movs	r3, #0
    98bc:	6363      	str	r3, [r4, #52]	; 0x34
    98be:	89a3      	ldrh	r3, [r4, #12]
    98c0:	f023 0324 	bic.w	r3, r3, #36	; 0x24
    98c4:	81a3      	strh	r3, [r4, #12]
    98c6:	2300      	movs	r3, #0
    98c8:	6063      	str	r3, [r4, #4]
    98ca:	6923      	ldr	r3, [r4, #16]
    98cc:	6023      	str	r3, [r4, #0]
    98ce:	89a3      	ldrh	r3, [r4, #12]
    98d0:	f043 0308 	orr.w	r3, r3, #8
    98d4:	81a3      	strh	r3, [r4, #12]
    98d6:	6923      	ldr	r3, [r4, #16]
    98d8:	b94b      	cbnz	r3, 98ee <__swsetup_r+0x9a>
    98da:	89a3      	ldrh	r3, [r4, #12]
    98dc:	f403 7320 	and.w	r3, r3, #640	; 0x280
    98e0:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
    98e4:	d003      	beq.n	98ee <__swsetup_r+0x9a>
    98e6:	4621      	mov	r1, r4
    98e8:	4630      	mov	r0, r6
    98ea:	f000 f9fd 	bl	9ce8 <__smakebuf_r>
    98ee:	89a0      	ldrh	r0, [r4, #12]
    98f0:	f9b4 200c 	ldrsh.w	r2, [r4, #12]
    98f4:	f010 0301 	ands.w	r3, r0, #1
    98f8:	d00a      	beq.n	9910 <__swsetup_r+0xbc>
    98fa:	2300      	movs	r3, #0
    98fc:	60a3      	str	r3, [r4, #8]
    98fe:	6963      	ldr	r3, [r4, #20]
    9900:	425b      	negs	r3, r3
    9902:	61a3      	str	r3, [r4, #24]
    9904:	6923      	ldr	r3, [r4, #16]
    9906:	b943      	cbnz	r3, 991a <__swsetup_r+0xc6>
    9908:	f010 0080 	ands.w	r0, r0, #128	; 0x80
    990c:	d1ba      	bne.n	9884 <__swsetup_r+0x30>
    990e:	bd70      	pop	{r4, r5, r6, pc}
    9910:	0781      	lsls	r1, r0, #30
    9912:	bf58      	it	pl
    9914:	6963      	ldrpl	r3, [r4, #20]
    9916:	60a3      	str	r3, [r4, #8]
    9918:	e7f4      	b.n	9904 <__swsetup_r+0xb0>
    991a:	2000      	movs	r0, #0
    991c:	e7f7      	b.n	990e <__swsetup_r+0xba>
    991e:	bf00      	nop
    9920:	20000018 	.word	0x20000018
    9924:	0000ab18 	.word	0x0000ab18
    9928:	0000ab38 	.word	0x0000ab38
    992c:	0000aaf8 	.word	0x0000aaf8

00009930 <__sflush_r>:
    9930:	898a      	ldrh	r2, [r1, #12]
    9932:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    9934:	4605      	mov	r5, r0
    9936:	0710      	lsls	r0, r2, #28
    9938:	460c      	mov	r4, r1
    993a:	d457      	bmi.n	99ec <__sflush_r+0xbc>
    993c:	684b      	ldr	r3, [r1, #4]
    993e:	2b00      	cmp	r3, #0
    9940:	dc04      	bgt.n	994c <__sflush_r+0x1c>
    9942:	6c0b      	ldr	r3, [r1, #64]	; 0x40
    9944:	2b00      	cmp	r3, #0
    9946:	dc01      	bgt.n	994c <__sflush_r+0x1c>
    9948:	2000      	movs	r0, #0
    994a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    994c:	6ae6      	ldr	r6, [r4, #44]	; 0x2c
    994e:	2e00      	cmp	r6, #0
    9950:	d0fa      	beq.n	9948 <__sflush_r+0x18>
    9952:	2300      	movs	r3, #0
    9954:	f412 5280 	ands.w	r2, r2, #4096	; 0x1000
    9958:	682f      	ldr	r7, [r5, #0]
    995a:	602b      	str	r3, [r5, #0]
    995c:	d032      	beq.n	99c4 <__sflush_r+0x94>
    995e:	6d60      	ldr	r0, [r4, #84]	; 0x54
    9960:	89a3      	ldrh	r3, [r4, #12]
    9962:	075a      	lsls	r2, r3, #29
    9964:	d505      	bpl.n	9972 <__sflush_r+0x42>
    9966:	6863      	ldr	r3, [r4, #4]
    9968:	1ac0      	subs	r0, r0, r3
    996a:	6b63      	ldr	r3, [r4, #52]	; 0x34
    996c:	b10b      	cbz	r3, 9972 <__sflush_r+0x42>
    996e:	6c23      	ldr	r3, [r4, #64]	; 0x40
    9970:	1ac0      	subs	r0, r0, r3
    9972:	2300      	movs	r3, #0
    9974:	4602      	mov	r2, r0
    9976:	6ae6      	ldr	r6, [r4, #44]	; 0x2c
    9978:	6a21      	ldr	r1, [r4, #32]
    997a:	4628      	mov	r0, r5
    997c:	47b0      	blx	r6
    997e:	1c43      	adds	r3, r0, #1
    9980:	89a3      	ldrh	r3, [r4, #12]
    9982:	d106      	bne.n	9992 <__sflush_r+0x62>
    9984:	6829      	ldr	r1, [r5, #0]
    9986:	291d      	cmp	r1, #29
    9988:	d82c      	bhi.n	99e4 <__sflush_r+0xb4>
    998a:	4a29      	ldr	r2, [pc, #164]	; (9a30 <__sflush_r+0x100>)
    998c:	40ca      	lsrs	r2, r1
    998e:	07d6      	lsls	r6, r2, #31
    9990:	d528      	bpl.n	99e4 <__sflush_r+0xb4>
    9992:	2200      	movs	r2, #0
    9994:	6062      	str	r2, [r4, #4]
    9996:	04d9      	lsls	r1, r3, #19
    9998:	6922      	ldr	r2, [r4, #16]
    999a:	6022      	str	r2, [r4, #0]
    999c:	d504      	bpl.n	99a8 <__sflush_r+0x78>
    999e:	1c42      	adds	r2, r0, #1
    99a0:	d101      	bne.n	99a6 <__sflush_r+0x76>
    99a2:	682b      	ldr	r3, [r5, #0]
    99a4:	b903      	cbnz	r3, 99a8 <__sflush_r+0x78>
    99a6:	6560      	str	r0, [r4, #84]	; 0x54
    99a8:	6b61      	ldr	r1, [r4, #52]	; 0x34
    99aa:	602f      	str	r7, [r5, #0]
    99ac:	2900      	cmp	r1, #0
    99ae:	d0cb      	beq.n	9948 <__sflush_r+0x18>
    99b0:	f104 0344 	add.w	r3, r4, #68	; 0x44
    99b4:	4299      	cmp	r1, r3
    99b6:	d002      	beq.n	99be <__sflush_r+0x8e>
    99b8:	4628      	mov	r0, r5
    99ba:	f000 f9dd 	bl	9d78 <_free_r>
    99be:	2000      	movs	r0, #0
    99c0:	6360      	str	r0, [r4, #52]	; 0x34
    99c2:	e7c2      	b.n	994a <__sflush_r+0x1a>
    99c4:	6a21      	ldr	r1, [r4, #32]
    99c6:	2301      	movs	r3, #1
    99c8:	4628      	mov	r0, r5
    99ca:	47b0      	blx	r6
    99cc:	1c41      	adds	r1, r0, #1
    99ce:	d1c7      	bne.n	9960 <__sflush_r+0x30>
    99d0:	682b      	ldr	r3, [r5, #0]
    99d2:	2b00      	cmp	r3, #0
    99d4:	d0c4      	beq.n	9960 <__sflush_r+0x30>
    99d6:	2b1d      	cmp	r3, #29
    99d8:	d001      	beq.n	99de <__sflush_r+0xae>
    99da:	2b16      	cmp	r3, #22
    99dc:	d101      	bne.n	99e2 <__sflush_r+0xb2>
    99de:	602f      	str	r7, [r5, #0]
    99e0:	e7b2      	b.n	9948 <__sflush_r+0x18>
    99e2:	89a3      	ldrh	r3, [r4, #12]
    99e4:	f043 0340 	orr.w	r3, r3, #64	; 0x40
    99e8:	81a3      	strh	r3, [r4, #12]
    99ea:	e7ae      	b.n	994a <__sflush_r+0x1a>
    99ec:	690f      	ldr	r7, [r1, #16]
    99ee:	2f00      	cmp	r7, #0
    99f0:	d0aa      	beq.n	9948 <__sflush_r+0x18>
    99f2:	0793      	lsls	r3, r2, #30
    99f4:	680e      	ldr	r6, [r1, #0]
    99f6:	bf08      	it	eq
    99f8:	694b      	ldreq	r3, [r1, #20]
    99fa:	600f      	str	r7, [r1, #0]
    99fc:	bf18      	it	ne
    99fe:	2300      	movne	r3, #0
    9a00:	1bf6      	subs	r6, r6, r7
    9a02:	608b      	str	r3, [r1, #8]
    9a04:	2e00      	cmp	r6, #0
    9a06:	dd9f      	ble.n	9948 <__sflush_r+0x18>
    9a08:	6a21      	ldr	r1, [r4, #32]
    9a0a:	f8d4 c028 	ldr.w	ip, [r4, #40]	; 0x28
    9a0e:	4633      	mov	r3, r6
    9a10:	463a      	mov	r2, r7
    9a12:	4628      	mov	r0, r5
    9a14:	47e0      	blx	ip
    9a16:	2800      	cmp	r0, #0
    9a18:	dc06      	bgt.n	9a28 <__sflush_r+0xf8>
    9a1a:	89a3      	ldrh	r3, [r4, #12]
    9a1c:	f043 0340 	orr.w	r3, r3, #64	; 0x40
    9a20:	81a3      	strh	r3, [r4, #12]
    9a22:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    9a26:	e790      	b.n	994a <__sflush_r+0x1a>
    9a28:	4407      	add	r7, r0
    9a2a:	1a36      	subs	r6, r6, r0
    9a2c:	e7ea      	b.n	9a04 <__sflush_r+0xd4>
    9a2e:	bf00      	nop
    9a30:	20400001 	.word	0x20400001

00009a34 <_fflush_r>:
    9a34:	b538      	push	{r3, r4, r5, lr}
    9a36:	690b      	ldr	r3, [r1, #16]
    9a38:	4605      	mov	r5, r0
    9a3a:	460c      	mov	r4, r1
    9a3c:	b913      	cbnz	r3, 9a44 <_fflush_r+0x10>
    9a3e:	2500      	movs	r5, #0
    9a40:	4628      	mov	r0, r5
    9a42:	bd38      	pop	{r3, r4, r5, pc}
    9a44:	b118      	cbz	r0, 9a4e <_fflush_r+0x1a>
    9a46:	6983      	ldr	r3, [r0, #24]
    9a48:	b90b      	cbnz	r3, 9a4e <_fflush_r+0x1a>
    9a4a:	f000 f887 	bl	9b5c <__sinit>
    9a4e:	4b14      	ldr	r3, [pc, #80]	; (9aa0 <_fflush_r+0x6c>)
    9a50:	429c      	cmp	r4, r3
    9a52:	d11b      	bne.n	9a8c <_fflush_r+0x58>
    9a54:	686c      	ldr	r4, [r5, #4]
    9a56:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
    9a5a:	2b00      	cmp	r3, #0
    9a5c:	d0ef      	beq.n	9a3e <_fflush_r+0xa>
    9a5e:	6e62      	ldr	r2, [r4, #100]	; 0x64
    9a60:	07d0      	lsls	r0, r2, #31
    9a62:	d404      	bmi.n	9a6e <_fflush_r+0x3a>
    9a64:	0599      	lsls	r1, r3, #22
    9a66:	d402      	bmi.n	9a6e <_fflush_r+0x3a>
    9a68:	6da0      	ldr	r0, [r4, #88]	; 0x58
    9a6a:	f000 f915 	bl	9c98 <__retarget_lock_acquire_recursive>
    9a6e:	4628      	mov	r0, r5
    9a70:	4621      	mov	r1, r4
    9a72:	f7ff ff5d 	bl	9930 <__sflush_r>
    9a76:	6e63      	ldr	r3, [r4, #100]	; 0x64
    9a78:	07da      	lsls	r2, r3, #31
    9a7a:	4605      	mov	r5, r0
    9a7c:	d4e0      	bmi.n	9a40 <_fflush_r+0xc>
    9a7e:	89a3      	ldrh	r3, [r4, #12]
    9a80:	059b      	lsls	r3, r3, #22
    9a82:	d4dd      	bmi.n	9a40 <_fflush_r+0xc>
    9a84:	6da0      	ldr	r0, [r4, #88]	; 0x58
    9a86:	f000 f908 	bl	9c9a <__retarget_lock_release_recursive>
    9a8a:	e7d9      	b.n	9a40 <_fflush_r+0xc>
    9a8c:	4b05      	ldr	r3, [pc, #20]	; (9aa4 <_fflush_r+0x70>)
    9a8e:	429c      	cmp	r4, r3
    9a90:	d101      	bne.n	9a96 <_fflush_r+0x62>
    9a92:	68ac      	ldr	r4, [r5, #8]
    9a94:	e7df      	b.n	9a56 <_fflush_r+0x22>
    9a96:	4b04      	ldr	r3, [pc, #16]	; (9aa8 <_fflush_r+0x74>)
    9a98:	429c      	cmp	r4, r3
    9a9a:	bf08      	it	eq
    9a9c:	68ec      	ldreq	r4, [r5, #12]
    9a9e:	e7da      	b.n	9a56 <_fflush_r+0x22>
    9aa0:	0000ab18 	.word	0x0000ab18
    9aa4:	0000ab38 	.word	0x0000ab38
    9aa8:	0000aaf8 	.word	0x0000aaf8

00009aac <std>:
    9aac:	2300      	movs	r3, #0
    9aae:	b510      	push	{r4, lr}
    9ab0:	4604      	mov	r4, r0
    9ab2:	e9c0 3300 	strd	r3, r3, [r0]
    9ab6:	e9c0 3304 	strd	r3, r3, [r0, #16]
    9aba:	6083      	str	r3, [r0, #8]
    9abc:	8181      	strh	r1, [r0, #12]
    9abe:	6643      	str	r3, [r0, #100]	; 0x64
    9ac0:	81c2      	strh	r2, [r0, #14]
    9ac2:	6183      	str	r3, [r0, #24]
    9ac4:	4619      	mov	r1, r3
    9ac6:	2208      	movs	r2, #8
    9ac8:	305c      	adds	r0, #92	; 0x5c
    9aca:	f7ff fcf9 	bl	94c0 <memset>
    9ace:	4b05      	ldr	r3, [pc, #20]	; (9ae4 <std+0x38>)
    9ad0:	6263      	str	r3, [r4, #36]	; 0x24
    9ad2:	4b05      	ldr	r3, [pc, #20]	; (9ae8 <std+0x3c>)
    9ad4:	62a3      	str	r3, [r4, #40]	; 0x28
    9ad6:	4b05      	ldr	r3, [pc, #20]	; (9aec <std+0x40>)
    9ad8:	62e3      	str	r3, [r4, #44]	; 0x2c
    9ada:	4b05      	ldr	r3, [pc, #20]	; (9af0 <std+0x44>)
    9adc:	6224      	str	r4, [r4, #32]
    9ade:	6323      	str	r3, [r4, #48]	; 0x30
    9ae0:	bd10      	pop	{r4, pc}
    9ae2:	bf00      	nop
    9ae4:	0000a52d 	.word	0x0000a52d
    9ae8:	0000a54f 	.word	0x0000a54f
    9aec:	0000a587 	.word	0x0000a587
    9af0:	0000a5ab 	.word	0x0000a5ab

00009af4 <_cleanup_r>:
    9af4:	4901      	ldr	r1, [pc, #4]	; (9afc <_cleanup_r+0x8>)
    9af6:	f000 b8af 	b.w	9c58 <_fwalk_reent>
    9afa:	bf00      	nop
    9afc:	00009a35 	.word	0x00009a35

00009b00 <__sfmoreglue>:
    9b00:	b570      	push	{r4, r5, r6, lr}
    9b02:	2268      	movs	r2, #104	; 0x68
    9b04:	1e4d      	subs	r5, r1, #1
    9b06:	4355      	muls	r5, r2
    9b08:	460e      	mov	r6, r1
    9b0a:	f105 0174 	add.w	r1, r5, #116	; 0x74
    9b0e:	f000 f99d 	bl	9e4c <_malloc_r>
    9b12:	4604      	mov	r4, r0
    9b14:	b140      	cbz	r0, 9b28 <__sfmoreglue+0x28>
    9b16:	2100      	movs	r1, #0
    9b18:	e9c0 1600 	strd	r1, r6, [r0]
    9b1c:	300c      	adds	r0, #12
    9b1e:	60a0      	str	r0, [r4, #8]
    9b20:	f105 0268 	add.w	r2, r5, #104	; 0x68
    9b24:	f7ff fccc 	bl	94c0 <memset>
    9b28:	4620      	mov	r0, r4
    9b2a:	bd70      	pop	{r4, r5, r6, pc}

00009b2c <__sfp_lock_acquire>:
    9b2c:	4801      	ldr	r0, [pc, #4]	; (9b34 <__sfp_lock_acquire+0x8>)
    9b2e:	f000 b8b3 	b.w	9c98 <__retarget_lock_acquire_recursive>
    9b32:	bf00      	nop
    9b34:	2001639d 	.word	0x2001639d

00009b38 <__sfp_lock_release>:
    9b38:	4801      	ldr	r0, [pc, #4]	; (9b40 <__sfp_lock_release+0x8>)
    9b3a:	f000 b8ae 	b.w	9c9a <__retarget_lock_release_recursive>
    9b3e:	bf00      	nop
    9b40:	2001639d 	.word	0x2001639d

00009b44 <__sinit_lock_acquire>:
    9b44:	4801      	ldr	r0, [pc, #4]	; (9b4c <__sinit_lock_acquire+0x8>)
    9b46:	f000 b8a7 	b.w	9c98 <__retarget_lock_acquire_recursive>
    9b4a:	bf00      	nop
    9b4c:	2001639e 	.word	0x2001639e

00009b50 <__sinit_lock_release>:
    9b50:	4801      	ldr	r0, [pc, #4]	; (9b58 <__sinit_lock_release+0x8>)
    9b52:	f000 b8a2 	b.w	9c9a <__retarget_lock_release_recursive>
    9b56:	bf00      	nop
    9b58:	2001639e 	.word	0x2001639e

00009b5c <__sinit>:
    9b5c:	b510      	push	{r4, lr}
    9b5e:	4604      	mov	r4, r0
    9b60:	f7ff fff0 	bl	9b44 <__sinit_lock_acquire>
    9b64:	69a3      	ldr	r3, [r4, #24]
    9b66:	b11b      	cbz	r3, 9b70 <__sinit+0x14>
    9b68:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    9b6c:	f7ff bff0 	b.w	9b50 <__sinit_lock_release>
    9b70:	e9c4 3312 	strd	r3, r3, [r4, #72]	; 0x48
    9b74:	6523      	str	r3, [r4, #80]	; 0x50
    9b76:	4b13      	ldr	r3, [pc, #76]	; (9bc4 <__sinit+0x68>)
    9b78:	4a13      	ldr	r2, [pc, #76]	; (9bc8 <__sinit+0x6c>)
    9b7a:	681b      	ldr	r3, [r3, #0]
    9b7c:	62a2      	str	r2, [r4, #40]	; 0x28
    9b7e:	42a3      	cmp	r3, r4
    9b80:	bf04      	itt	eq
    9b82:	2301      	moveq	r3, #1
    9b84:	61a3      	streq	r3, [r4, #24]
    9b86:	4620      	mov	r0, r4
    9b88:	f000 f820 	bl	9bcc <__sfp>
    9b8c:	6060      	str	r0, [r4, #4]
    9b8e:	4620      	mov	r0, r4
    9b90:	f000 f81c 	bl	9bcc <__sfp>
    9b94:	60a0      	str	r0, [r4, #8]
    9b96:	4620      	mov	r0, r4
    9b98:	f000 f818 	bl	9bcc <__sfp>
    9b9c:	2200      	movs	r2, #0
    9b9e:	60e0      	str	r0, [r4, #12]
    9ba0:	2104      	movs	r1, #4
    9ba2:	6860      	ldr	r0, [r4, #4]
    9ba4:	f7ff ff82 	bl	9aac <std>
    9ba8:	68a0      	ldr	r0, [r4, #8]
    9baa:	2201      	movs	r2, #1
    9bac:	2109      	movs	r1, #9
    9bae:	f7ff ff7d 	bl	9aac <std>
    9bb2:	68e0      	ldr	r0, [r4, #12]
    9bb4:	2202      	movs	r2, #2
    9bb6:	2112      	movs	r1, #18
    9bb8:	f7ff ff78 	bl	9aac <std>
    9bbc:	2301      	movs	r3, #1
    9bbe:	61a3      	str	r3, [r4, #24]
    9bc0:	e7d2      	b.n	9b68 <__sinit+0xc>
    9bc2:	bf00      	nop
    9bc4:	0000aaf4 	.word	0x0000aaf4
    9bc8:	00009af5 	.word	0x00009af5

00009bcc <__sfp>:
    9bcc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    9bce:	4607      	mov	r7, r0
    9bd0:	f7ff ffac 	bl	9b2c <__sfp_lock_acquire>
    9bd4:	4b1e      	ldr	r3, [pc, #120]	; (9c50 <__sfp+0x84>)
    9bd6:	681e      	ldr	r6, [r3, #0]
    9bd8:	69b3      	ldr	r3, [r6, #24]
    9bda:	b913      	cbnz	r3, 9be2 <__sfp+0x16>
    9bdc:	4630      	mov	r0, r6
    9bde:	f7ff ffbd 	bl	9b5c <__sinit>
    9be2:	3648      	adds	r6, #72	; 0x48
    9be4:	e9d6 3401 	ldrd	r3, r4, [r6, #4]
    9be8:	3b01      	subs	r3, #1
    9bea:	d503      	bpl.n	9bf4 <__sfp+0x28>
    9bec:	6833      	ldr	r3, [r6, #0]
    9bee:	b30b      	cbz	r3, 9c34 <__sfp+0x68>
    9bf0:	6836      	ldr	r6, [r6, #0]
    9bf2:	e7f7      	b.n	9be4 <__sfp+0x18>
    9bf4:	f9b4 500c 	ldrsh.w	r5, [r4, #12]
    9bf8:	b9d5      	cbnz	r5, 9c30 <__sfp+0x64>
    9bfa:	4b16      	ldr	r3, [pc, #88]	; (9c54 <__sfp+0x88>)
    9bfc:	60e3      	str	r3, [r4, #12]
    9bfe:	f104 0058 	add.w	r0, r4, #88	; 0x58
    9c02:	6665      	str	r5, [r4, #100]	; 0x64
    9c04:	f000 f847 	bl	9c96 <__retarget_lock_init_recursive>
    9c08:	f7ff ff96 	bl	9b38 <__sfp_lock_release>
    9c0c:	e9c4 5501 	strd	r5, r5, [r4, #4]
    9c10:	e9c4 5504 	strd	r5, r5, [r4, #16]
    9c14:	6025      	str	r5, [r4, #0]
    9c16:	61a5      	str	r5, [r4, #24]
    9c18:	2208      	movs	r2, #8
    9c1a:	4629      	mov	r1, r5
    9c1c:	f104 005c 	add.w	r0, r4, #92	; 0x5c
    9c20:	f7ff fc4e 	bl	94c0 <memset>
    9c24:	e9c4 550d 	strd	r5, r5, [r4, #52]	; 0x34
    9c28:	e9c4 5512 	strd	r5, r5, [r4, #72]	; 0x48
    9c2c:	4620      	mov	r0, r4
    9c2e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    9c30:	3468      	adds	r4, #104	; 0x68
    9c32:	e7d9      	b.n	9be8 <__sfp+0x1c>
    9c34:	2104      	movs	r1, #4
    9c36:	4638      	mov	r0, r7
    9c38:	f7ff ff62 	bl	9b00 <__sfmoreglue>
    9c3c:	4604      	mov	r4, r0
    9c3e:	6030      	str	r0, [r6, #0]
    9c40:	2800      	cmp	r0, #0
    9c42:	d1d5      	bne.n	9bf0 <__sfp+0x24>
    9c44:	f7ff ff78 	bl	9b38 <__sfp_lock_release>
    9c48:	230c      	movs	r3, #12
    9c4a:	603b      	str	r3, [r7, #0]
    9c4c:	e7ee      	b.n	9c2c <__sfp+0x60>
    9c4e:	bf00      	nop
    9c50:	0000aaf4 	.word	0x0000aaf4
    9c54:	ffff0001 	.word	0xffff0001

00009c58 <_fwalk_reent>:
    9c58:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    9c5c:	4606      	mov	r6, r0
    9c5e:	4688      	mov	r8, r1
    9c60:	f100 0448 	add.w	r4, r0, #72	; 0x48
    9c64:	2700      	movs	r7, #0
    9c66:	e9d4 9501 	ldrd	r9, r5, [r4, #4]
    9c6a:	f1b9 0901 	subs.w	r9, r9, #1
    9c6e:	d505      	bpl.n	9c7c <_fwalk_reent+0x24>
    9c70:	6824      	ldr	r4, [r4, #0]
    9c72:	2c00      	cmp	r4, #0
    9c74:	d1f7      	bne.n	9c66 <_fwalk_reent+0xe>
    9c76:	4638      	mov	r0, r7
    9c78:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    9c7c:	89ab      	ldrh	r3, [r5, #12]
    9c7e:	2b01      	cmp	r3, #1
    9c80:	d907      	bls.n	9c92 <_fwalk_reent+0x3a>
    9c82:	f9b5 300e 	ldrsh.w	r3, [r5, #14]
    9c86:	3301      	adds	r3, #1
    9c88:	d003      	beq.n	9c92 <_fwalk_reent+0x3a>
    9c8a:	4629      	mov	r1, r5
    9c8c:	4630      	mov	r0, r6
    9c8e:	47c0      	blx	r8
    9c90:	4307      	orrs	r7, r0
    9c92:	3568      	adds	r5, #104	; 0x68
    9c94:	e7e9      	b.n	9c6a <_fwalk_reent+0x12>

00009c96 <__retarget_lock_init_recursive>:
    9c96:	4770      	bx	lr

00009c98 <__retarget_lock_acquire_recursive>:
    9c98:	4770      	bx	lr

00009c9a <__retarget_lock_release_recursive>:
    9c9a:	4770      	bx	lr

00009c9c <__swhatbuf_r>:
    9c9c:	b570      	push	{r4, r5, r6, lr}
    9c9e:	460e      	mov	r6, r1
    9ca0:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
    9ca4:	2900      	cmp	r1, #0
    9ca6:	b096      	sub	sp, #88	; 0x58
    9ca8:	4614      	mov	r4, r2
    9caa:	461d      	mov	r5, r3
    9cac:	da08      	bge.n	9cc0 <__swhatbuf_r+0x24>
    9cae:	f9b6 300c 	ldrsh.w	r3, [r6, #12]
    9cb2:	2200      	movs	r2, #0
    9cb4:	602a      	str	r2, [r5, #0]
    9cb6:	061a      	lsls	r2, r3, #24
    9cb8:	d410      	bmi.n	9cdc <__swhatbuf_r+0x40>
    9cba:	f44f 6380 	mov.w	r3, #1024	; 0x400
    9cbe:	e00e      	b.n	9cde <__swhatbuf_r+0x42>
    9cc0:	466a      	mov	r2, sp
    9cc2:	f000 fc99 	bl	a5f8 <_fstat_r>
    9cc6:	2800      	cmp	r0, #0
    9cc8:	dbf1      	blt.n	9cae <__swhatbuf_r+0x12>
    9cca:	9a01      	ldr	r2, [sp, #4]
    9ccc:	f402 4270 	and.w	r2, r2, #61440	; 0xf000
    9cd0:	f5a2 5300 	sub.w	r3, r2, #8192	; 0x2000
    9cd4:	425a      	negs	r2, r3
    9cd6:	415a      	adcs	r2, r3
    9cd8:	602a      	str	r2, [r5, #0]
    9cda:	e7ee      	b.n	9cba <__swhatbuf_r+0x1e>
    9cdc:	2340      	movs	r3, #64	; 0x40
    9cde:	2000      	movs	r0, #0
    9ce0:	6023      	str	r3, [r4, #0]
    9ce2:	b016      	add	sp, #88	; 0x58
    9ce4:	bd70      	pop	{r4, r5, r6, pc}
	...

00009ce8 <__smakebuf_r>:
    9ce8:	898b      	ldrh	r3, [r1, #12]
    9cea:	b573      	push	{r0, r1, r4, r5, r6, lr}
    9cec:	079d      	lsls	r5, r3, #30
    9cee:	4606      	mov	r6, r0
    9cf0:	460c      	mov	r4, r1
    9cf2:	d507      	bpl.n	9d04 <__smakebuf_r+0x1c>
    9cf4:	f104 0347 	add.w	r3, r4, #71	; 0x47
    9cf8:	6023      	str	r3, [r4, #0]
    9cfa:	6123      	str	r3, [r4, #16]
    9cfc:	2301      	movs	r3, #1
    9cfe:	6163      	str	r3, [r4, #20]
    9d00:	b002      	add	sp, #8
    9d02:	bd70      	pop	{r4, r5, r6, pc}
    9d04:	ab01      	add	r3, sp, #4
    9d06:	466a      	mov	r2, sp
    9d08:	f7ff ffc8 	bl	9c9c <__swhatbuf_r>
    9d0c:	9900      	ldr	r1, [sp, #0]
    9d0e:	4605      	mov	r5, r0
    9d10:	4630      	mov	r0, r6
    9d12:	f000 f89b 	bl	9e4c <_malloc_r>
    9d16:	b948      	cbnz	r0, 9d2c <__smakebuf_r+0x44>
    9d18:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
    9d1c:	059a      	lsls	r2, r3, #22
    9d1e:	d4ef      	bmi.n	9d00 <__smakebuf_r+0x18>
    9d20:	f023 0303 	bic.w	r3, r3, #3
    9d24:	f043 0302 	orr.w	r3, r3, #2
    9d28:	81a3      	strh	r3, [r4, #12]
    9d2a:	e7e3      	b.n	9cf4 <__smakebuf_r+0xc>
    9d2c:	4b0d      	ldr	r3, [pc, #52]	; (9d64 <__smakebuf_r+0x7c>)
    9d2e:	62b3      	str	r3, [r6, #40]	; 0x28
    9d30:	89a3      	ldrh	r3, [r4, #12]
    9d32:	6020      	str	r0, [r4, #0]
    9d34:	f043 0380 	orr.w	r3, r3, #128	; 0x80
    9d38:	81a3      	strh	r3, [r4, #12]
    9d3a:	9b00      	ldr	r3, [sp, #0]
    9d3c:	6163      	str	r3, [r4, #20]
    9d3e:	9b01      	ldr	r3, [sp, #4]
    9d40:	6120      	str	r0, [r4, #16]
    9d42:	b15b      	cbz	r3, 9d5c <__smakebuf_r+0x74>
    9d44:	f9b4 100e 	ldrsh.w	r1, [r4, #14]
    9d48:	4630      	mov	r0, r6
    9d4a:	f000 fc67 	bl	a61c <_isatty_r>
    9d4e:	b128      	cbz	r0, 9d5c <__smakebuf_r+0x74>
    9d50:	89a3      	ldrh	r3, [r4, #12]
    9d52:	f023 0303 	bic.w	r3, r3, #3
    9d56:	f043 0301 	orr.w	r3, r3, #1
    9d5a:	81a3      	strh	r3, [r4, #12]
    9d5c:	89a0      	ldrh	r0, [r4, #12]
    9d5e:	4305      	orrs	r5, r0
    9d60:	81a5      	strh	r5, [r4, #12]
    9d62:	e7cd      	b.n	9d00 <__smakebuf_r+0x18>
    9d64:	00009af5 	.word	0x00009af5

00009d68 <malloc>:
    9d68:	4b02      	ldr	r3, [pc, #8]	; (9d74 <malloc+0xc>)
    9d6a:	4601      	mov	r1, r0
    9d6c:	6818      	ldr	r0, [r3, #0]
    9d6e:	f000 b86d 	b.w	9e4c <_malloc_r>
    9d72:	bf00      	nop
    9d74:	20000018 	.word	0x20000018

00009d78 <_free_r>:
    9d78:	b538      	push	{r3, r4, r5, lr}
    9d7a:	4605      	mov	r5, r0
    9d7c:	2900      	cmp	r1, #0
    9d7e:	d041      	beq.n	9e04 <_free_r+0x8c>
    9d80:	f851 3c04 	ldr.w	r3, [r1, #-4]
    9d84:	1f0c      	subs	r4, r1, #4
    9d86:	2b00      	cmp	r3, #0
    9d88:	bfb8      	it	lt
    9d8a:	18e4      	addlt	r4, r4, r3
    9d8c:	f000 fcb8 	bl	a700 <__malloc_lock>
    9d90:	4a1d      	ldr	r2, [pc, #116]	; (9e08 <_free_r+0x90>)
    9d92:	6813      	ldr	r3, [r2, #0]
    9d94:	b933      	cbnz	r3, 9da4 <_free_r+0x2c>
    9d96:	6063      	str	r3, [r4, #4]
    9d98:	6014      	str	r4, [r2, #0]
    9d9a:	4628      	mov	r0, r5
    9d9c:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
    9da0:	f000 bcb4 	b.w	a70c <__malloc_unlock>
    9da4:	42a3      	cmp	r3, r4
    9da6:	d908      	bls.n	9dba <_free_r+0x42>
    9da8:	6820      	ldr	r0, [r4, #0]
    9daa:	1821      	adds	r1, r4, r0
    9dac:	428b      	cmp	r3, r1
    9dae:	bf01      	itttt	eq
    9db0:	6819      	ldreq	r1, [r3, #0]
    9db2:	685b      	ldreq	r3, [r3, #4]
    9db4:	1809      	addeq	r1, r1, r0
    9db6:	6021      	streq	r1, [r4, #0]
    9db8:	e7ed      	b.n	9d96 <_free_r+0x1e>
    9dba:	461a      	mov	r2, r3
    9dbc:	685b      	ldr	r3, [r3, #4]
    9dbe:	b10b      	cbz	r3, 9dc4 <_free_r+0x4c>
    9dc0:	42a3      	cmp	r3, r4
    9dc2:	d9fa      	bls.n	9dba <_free_r+0x42>
    9dc4:	6811      	ldr	r1, [r2, #0]
    9dc6:	1850      	adds	r0, r2, r1
    9dc8:	42a0      	cmp	r0, r4
    9dca:	d10b      	bne.n	9de4 <_free_r+0x6c>
    9dcc:	6820      	ldr	r0, [r4, #0]
    9dce:	4401      	add	r1, r0
    9dd0:	1850      	adds	r0, r2, r1
    9dd2:	4283      	cmp	r3, r0
    9dd4:	6011      	str	r1, [r2, #0]
    9dd6:	d1e0      	bne.n	9d9a <_free_r+0x22>
    9dd8:	6818      	ldr	r0, [r3, #0]
    9dda:	685b      	ldr	r3, [r3, #4]
    9ddc:	6053      	str	r3, [r2, #4]
    9dde:	4401      	add	r1, r0
    9de0:	6011      	str	r1, [r2, #0]
    9de2:	e7da      	b.n	9d9a <_free_r+0x22>
    9de4:	d902      	bls.n	9dec <_free_r+0x74>
    9de6:	230c      	movs	r3, #12
    9de8:	602b      	str	r3, [r5, #0]
    9dea:	e7d6      	b.n	9d9a <_free_r+0x22>
    9dec:	6820      	ldr	r0, [r4, #0]
    9dee:	1821      	adds	r1, r4, r0
    9df0:	428b      	cmp	r3, r1
    9df2:	bf04      	itt	eq
    9df4:	6819      	ldreq	r1, [r3, #0]
    9df6:	685b      	ldreq	r3, [r3, #4]
    9df8:	6063      	str	r3, [r4, #4]
    9dfa:	bf04      	itt	eq
    9dfc:	1809      	addeq	r1, r1, r0
    9dfe:	6021      	streq	r1, [r4, #0]
    9e00:	6054      	str	r4, [r2, #4]
    9e02:	e7ca      	b.n	9d9a <_free_r+0x22>
    9e04:	bd38      	pop	{r3, r4, r5, pc}
    9e06:	bf00      	nop
    9e08:	200163a0 	.word	0x200163a0

00009e0c <sbrk_aligned>:
    9e0c:	b570      	push	{r4, r5, r6, lr}
    9e0e:	4e0e      	ldr	r6, [pc, #56]	; (9e48 <sbrk_aligned+0x3c>)
    9e10:	460c      	mov	r4, r1
    9e12:	6831      	ldr	r1, [r6, #0]
    9e14:	4605      	mov	r5, r0
    9e16:	b911      	cbnz	r1, 9e1e <sbrk_aligned+0x12>
    9e18:	f000 fb78 	bl	a50c <_sbrk_r>
    9e1c:	6030      	str	r0, [r6, #0]
    9e1e:	4621      	mov	r1, r4
    9e20:	4628      	mov	r0, r5
    9e22:	f000 fb73 	bl	a50c <_sbrk_r>
    9e26:	1c43      	adds	r3, r0, #1
    9e28:	d00a      	beq.n	9e40 <sbrk_aligned+0x34>
    9e2a:	1cc4      	adds	r4, r0, #3
    9e2c:	f024 0403 	bic.w	r4, r4, #3
    9e30:	42a0      	cmp	r0, r4
    9e32:	d007      	beq.n	9e44 <sbrk_aligned+0x38>
    9e34:	1a21      	subs	r1, r4, r0
    9e36:	4628      	mov	r0, r5
    9e38:	f000 fb68 	bl	a50c <_sbrk_r>
    9e3c:	3001      	adds	r0, #1
    9e3e:	d101      	bne.n	9e44 <sbrk_aligned+0x38>
    9e40:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
    9e44:	4620      	mov	r0, r4
    9e46:	bd70      	pop	{r4, r5, r6, pc}
    9e48:	200163a4 	.word	0x200163a4

00009e4c <_malloc_r>:
    9e4c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    9e50:	1ccd      	adds	r5, r1, #3
    9e52:	f025 0503 	bic.w	r5, r5, #3
    9e56:	3508      	adds	r5, #8
    9e58:	2d0c      	cmp	r5, #12
    9e5a:	bf38      	it	cc
    9e5c:	250c      	movcc	r5, #12
    9e5e:	2d00      	cmp	r5, #0
    9e60:	4607      	mov	r7, r0
    9e62:	db01      	blt.n	9e68 <_malloc_r+0x1c>
    9e64:	42a9      	cmp	r1, r5
    9e66:	d905      	bls.n	9e74 <_malloc_r+0x28>
    9e68:	230c      	movs	r3, #12
    9e6a:	603b      	str	r3, [r7, #0]
    9e6c:	2600      	movs	r6, #0
    9e6e:	4630      	mov	r0, r6
    9e70:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    9e74:	4e2e      	ldr	r6, [pc, #184]	; (9f30 <_malloc_r+0xe4>)
    9e76:	f000 fc43 	bl	a700 <__malloc_lock>
    9e7a:	6833      	ldr	r3, [r6, #0]
    9e7c:	461c      	mov	r4, r3
    9e7e:	bb34      	cbnz	r4, 9ece <_malloc_r+0x82>
    9e80:	4629      	mov	r1, r5
    9e82:	4638      	mov	r0, r7
    9e84:	f7ff ffc2 	bl	9e0c <sbrk_aligned>
    9e88:	1c43      	adds	r3, r0, #1
    9e8a:	4604      	mov	r4, r0
    9e8c:	d14d      	bne.n	9f2a <_malloc_r+0xde>
    9e8e:	6834      	ldr	r4, [r6, #0]
    9e90:	4626      	mov	r6, r4
    9e92:	2e00      	cmp	r6, #0
    9e94:	d140      	bne.n	9f18 <_malloc_r+0xcc>
    9e96:	6823      	ldr	r3, [r4, #0]
    9e98:	4631      	mov	r1, r6
    9e9a:	4638      	mov	r0, r7
    9e9c:	eb04 0803 	add.w	r8, r4, r3
    9ea0:	f000 fb34 	bl	a50c <_sbrk_r>
    9ea4:	4580      	cmp	r8, r0
    9ea6:	d13a      	bne.n	9f1e <_malloc_r+0xd2>
    9ea8:	6821      	ldr	r1, [r4, #0]
    9eaa:	3503      	adds	r5, #3
    9eac:	1a6d      	subs	r5, r5, r1
    9eae:	f025 0503 	bic.w	r5, r5, #3
    9eb2:	3508      	adds	r5, #8
    9eb4:	2d0c      	cmp	r5, #12
    9eb6:	bf38      	it	cc
    9eb8:	250c      	movcc	r5, #12
    9eba:	4629      	mov	r1, r5
    9ebc:	4638      	mov	r0, r7
    9ebe:	f7ff ffa5 	bl	9e0c <sbrk_aligned>
    9ec2:	3001      	adds	r0, #1
    9ec4:	d02b      	beq.n	9f1e <_malloc_r+0xd2>
    9ec6:	6823      	ldr	r3, [r4, #0]
    9ec8:	442b      	add	r3, r5
    9eca:	6023      	str	r3, [r4, #0]
    9ecc:	e00e      	b.n	9eec <_malloc_r+0xa0>
    9ece:	6822      	ldr	r2, [r4, #0]
    9ed0:	1b52      	subs	r2, r2, r5
    9ed2:	d41e      	bmi.n	9f12 <_malloc_r+0xc6>
    9ed4:	2a0b      	cmp	r2, #11
    9ed6:	d916      	bls.n	9f06 <_malloc_r+0xba>
    9ed8:	1961      	adds	r1, r4, r5
    9eda:	42a3      	cmp	r3, r4
    9edc:	6025      	str	r5, [r4, #0]
    9ede:	bf18      	it	ne
    9ee0:	6059      	strne	r1, [r3, #4]
    9ee2:	6863      	ldr	r3, [r4, #4]
    9ee4:	bf08      	it	eq
    9ee6:	6031      	streq	r1, [r6, #0]
    9ee8:	5162      	str	r2, [r4, r5]
    9eea:	604b      	str	r3, [r1, #4]
    9eec:	4638      	mov	r0, r7
    9eee:	f104 060b 	add.w	r6, r4, #11
    9ef2:	f000 fc0b 	bl	a70c <__malloc_unlock>
    9ef6:	f026 0607 	bic.w	r6, r6, #7
    9efa:	1d23      	adds	r3, r4, #4
    9efc:	1af2      	subs	r2, r6, r3
    9efe:	d0b6      	beq.n	9e6e <_malloc_r+0x22>
    9f00:	1b9b      	subs	r3, r3, r6
    9f02:	50a3      	str	r3, [r4, r2]
    9f04:	e7b3      	b.n	9e6e <_malloc_r+0x22>
    9f06:	6862      	ldr	r2, [r4, #4]
    9f08:	42a3      	cmp	r3, r4
    9f0a:	bf0c      	ite	eq
    9f0c:	6032      	streq	r2, [r6, #0]
    9f0e:	605a      	strne	r2, [r3, #4]
    9f10:	e7ec      	b.n	9eec <_malloc_r+0xa0>
    9f12:	4623      	mov	r3, r4
    9f14:	6864      	ldr	r4, [r4, #4]
    9f16:	e7b2      	b.n	9e7e <_malloc_r+0x32>
    9f18:	4634      	mov	r4, r6
    9f1a:	6876      	ldr	r6, [r6, #4]
    9f1c:	e7b9      	b.n	9e92 <_malloc_r+0x46>
    9f1e:	230c      	movs	r3, #12
    9f20:	603b      	str	r3, [r7, #0]
    9f22:	4638      	mov	r0, r7
    9f24:	f000 fbf2 	bl	a70c <__malloc_unlock>
    9f28:	e7a1      	b.n	9e6e <_malloc_r+0x22>
    9f2a:	6025      	str	r5, [r4, #0]
    9f2c:	e7de      	b.n	9eec <_malloc_r+0xa0>
    9f2e:	bf00      	nop
    9f30:	200163a0 	.word	0x200163a0

00009f34 <__sfputc_r>:
    9f34:	6893      	ldr	r3, [r2, #8]
    9f36:	3b01      	subs	r3, #1
    9f38:	2b00      	cmp	r3, #0
    9f3a:	b410      	push	{r4}
    9f3c:	6093      	str	r3, [r2, #8]
    9f3e:	da07      	bge.n	9f50 <__sfputc_r+0x1c>
    9f40:	6994      	ldr	r4, [r2, #24]
    9f42:	42a3      	cmp	r3, r4
    9f44:	db01      	blt.n	9f4a <__sfputc_r+0x16>
    9f46:	290a      	cmp	r1, #10
    9f48:	d102      	bne.n	9f50 <__sfputc_r+0x1c>
    9f4a:	bc10      	pop	{r4}
    9f4c:	f7ff bc30 	b.w	97b0 <__swbuf_r>
    9f50:	6813      	ldr	r3, [r2, #0]
    9f52:	1c58      	adds	r0, r3, #1
    9f54:	6010      	str	r0, [r2, #0]
    9f56:	7019      	strb	r1, [r3, #0]
    9f58:	4608      	mov	r0, r1
    9f5a:	bc10      	pop	{r4}
    9f5c:	4770      	bx	lr

00009f5e <__sfputs_r>:
    9f5e:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    9f60:	4606      	mov	r6, r0
    9f62:	460f      	mov	r7, r1
    9f64:	4614      	mov	r4, r2
    9f66:	18d5      	adds	r5, r2, r3
    9f68:	42ac      	cmp	r4, r5
    9f6a:	d101      	bne.n	9f70 <__sfputs_r+0x12>
    9f6c:	2000      	movs	r0, #0
    9f6e:	e007      	b.n	9f80 <__sfputs_r+0x22>
    9f70:	f814 1b01 	ldrb.w	r1, [r4], #1
    9f74:	463a      	mov	r2, r7
    9f76:	4630      	mov	r0, r6
    9f78:	f7ff ffdc 	bl	9f34 <__sfputc_r>
    9f7c:	1c43      	adds	r3, r0, #1
    9f7e:	d1f3      	bne.n	9f68 <__sfputs_r+0xa>
    9f80:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	...

00009f84 <_vfiprintf_r>:
    9f84:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    9f88:	460d      	mov	r5, r1
    9f8a:	b09d      	sub	sp, #116	; 0x74
    9f8c:	4614      	mov	r4, r2
    9f8e:	4698      	mov	r8, r3
    9f90:	4606      	mov	r6, r0
    9f92:	b118      	cbz	r0, 9f9c <_vfiprintf_r+0x18>
    9f94:	6983      	ldr	r3, [r0, #24]
    9f96:	b90b      	cbnz	r3, 9f9c <_vfiprintf_r+0x18>
    9f98:	f7ff fde0 	bl	9b5c <__sinit>
    9f9c:	4b89      	ldr	r3, [pc, #548]	; (a1c4 <_vfiprintf_r+0x240>)
    9f9e:	429d      	cmp	r5, r3
    9fa0:	d11b      	bne.n	9fda <_vfiprintf_r+0x56>
    9fa2:	6875      	ldr	r5, [r6, #4]
    9fa4:	6e6b      	ldr	r3, [r5, #100]	; 0x64
    9fa6:	07d9      	lsls	r1, r3, #31
    9fa8:	d405      	bmi.n	9fb6 <_vfiprintf_r+0x32>
    9faa:	89ab      	ldrh	r3, [r5, #12]
    9fac:	059a      	lsls	r2, r3, #22
    9fae:	d402      	bmi.n	9fb6 <_vfiprintf_r+0x32>
    9fb0:	6da8      	ldr	r0, [r5, #88]	; 0x58
    9fb2:	f7ff fe71 	bl	9c98 <__retarget_lock_acquire_recursive>
    9fb6:	89ab      	ldrh	r3, [r5, #12]
    9fb8:	071b      	lsls	r3, r3, #28
    9fba:	d501      	bpl.n	9fc0 <_vfiprintf_r+0x3c>
    9fbc:	692b      	ldr	r3, [r5, #16]
    9fbe:	b9eb      	cbnz	r3, 9ffc <_vfiprintf_r+0x78>
    9fc0:	4629      	mov	r1, r5
    9fc2:	4630      	mov	r0, r6
    9fc4:	f7ff fc46 	bl	9854 <__swsetup_r>
    9fc8:	b1c0      	cbz	r0, 9ffc <_vfiprintf_r+0x78>
    9fca:	6e6b      	ldr	r3, [r5, #100]	; 0x64
    9fcc:	07dc      	lsls	r4, r3, #31
    9fce:	d50e      	bpl.n	9fee <_vfiprintf_r+0x6a>
    9fd0:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    9fd4:	b01d      	add	sp, #116	; 0x74
    9fd6:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    9fda:	4b7b      	ldr	r3, [pc, #492]	; (a1c8 <_vfiprintf_r+0x244>)
    9fdc:	429d      	cmp	r5, r3
    9fde:	d101      	bne.n	9fe4 <_vfiprintf_r+0x60>
    9fe0:	68b5      	ldr	r5, [r6, #8]
    9fe2:	e7df      	b.n	9fa4 <_vfiprintf_r+0x20>
    9fe4:	4b79      	ldr	r3, [pc, #484]	; (a1cc <_vfiprintf_r+0x248>)
    9fe6:	429d      	cmp	r5, r3
    9fe8:	bf08      	it	eq
    9fea:	68f5      	ldreq	r5, [r6, #12]
    9fec:	e7da      	b.n	9fa4 <_vfiprintf_r+0x20>
    9fee:	89ab      	ldrh	r3, [r5, #12]
    9ff0:	0598      	lsls	r0, r3, #22
    9ff2:	d4ed      	bmi.n	9fd0 <_vfiprintf_r+0x4c>
    9ff4:	6da8      	ldr	r0, [r5, #88]	; 0x58
    9ff6:	f7ff fe50 	bl	9c9a <__retarget_lock_release_recursive>
    9ffa:	e7e9      	b.n	9fd0 <_vfiprintf_r+0x4c>
    9ffc:	2300      	movs	r3, #0
    9ffe:	9309      	str	r3, [sp, #36]	; 0x24
    a000:	2320      	movs	r3, #32
    a002:	f88d 3029 	strb.w	r3, [sp, #41]	; 0x29
    a006:	f8cd 800c 	str.w	r8, [sp, #12]
    a00a:	2330      	movs	r3, #48	; 0x30
    a00c:	f8df 81c0 	ldr.w	r8, [pc, #448]	; a1d0 <_vfiprintf_r+0x24c>
    a010:	f88d 302a 	strb.w	r3, [sp, #42]	; 0x2a
    a014:	f04f 0901 	mov.w	r9, #1
    a018:	4623      	mov	r3, r4
    a01a:	469a      	mov	sl, r3
    a01c:	f813 2b01 	ldrb.w	r2, [r3], #1
    a020:	b10a      	cbz	r2, a026 <_vfiprintf_r+0xa2>
    a022:	2a25      	cmp	r2, #37	; 0x25
    a024:	d1f9      	bne.n	a01a <_vfiprintf_r+0x96>
    a026:	ebba 0b04 	subs.w	fp, sl, r4
    a02a:	d00b      	beq.n	a044 <_vfiprintf_r+0xc0>
    a02c:	465b      	mov	r3, fp
    a02e:	4622      	mov	r2, r4
    a030:	4629      	mov	r1, r5
    a032:	4630      	mov	r0, r6
    a034:	f7ff ff93 	bl	9f5e <__sfputs_r>
    a038:	3001      	adds	r0, #1
    a03a:	f000 80aa 	beq.w	a192 <_vfiprintf_r+0x20e>
    a03e:	9a09      	ldr	r2, [sp, #36]	; 0x24
    a040:	445a      	add	r2, fp
    a042:	9209      	str	r2, [sp, #36]	; 0x24
    a044:	f89a 3000 	ldrb.w	r3, [sl]
    a048:	2b00      	cmp	r3, #0
    a04a:	f000 80a2 	beq.w	a192 <_vfiprintf_r+0x20e>
    a04e:	2300      	movs	r3, #0
    a050:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
    a054:	e9cd 2305 	strd	r2, r3, [sp, #20]
    a058:	f10a 0a01 	add.w	sl, sl, #1
    a05c:	9304      	str	r3, [sp, #16]
    a05e:	9307      	str	r3, [sp, #28]
    a060:	f88d 3053 	strb.w	r3, [sp, #83]	; 0x53
    a064:	931a      	str	r3, [sp, #104]	; 0x68
    a066:	4654      	mov	r4, sl
    a068:	2205      	movs	r2, #5
    a06a:	f814 1b01 	ldrb.w	r1, [r4], #1
    a06e:	4858      	ldr	r0, [pc, #352]	; (a1d0 <_vfiprintf_r+0x24c>)
    a070:	f000 faf6 	bl	a660 <memchr>
    a074:	9a04      	ldr	r2, [sp, #16]
    a076:	b9d8      	cbnz	r0, a0b0 <_vfiprintf_r+0x12c>
    a078:	06d1      	lsls	r1, r2, #27
    a07a:	bf44      	itt	mi
    a07c:	2320      	movmi	r3, #32
    a07e:	f88d 3053 	strbmi.w	r3, [sp, #83]	; 0x53
    a082:	0713      	lsls	r3, r2, #28
    a084:	bf44      	itt	mi
    a086:	232b      	movmi	r3, #43	; 0x2b
    a088:	f88d 3053 	strbmi.w	r3, [sp, #83]	; 0x53
    a08c:	f89a 3000 	ldrb.w	r3, [sl]
    a090:	2b2a      	cmp	r3, #42	; 0x2a
    a092:	d015      	beq.n	a0c0 <_vfiprintf_r+0x13c>
    a094:	9a07      	ldr	r2, [sp, #28]
    a096:	4654      	mov	r4, sl
    a098:	2000      	movs	r0, #0
    a09a:	f04f 0c0a 	mov.w	ip, #10
    a09e:	4621      	mov	r1, r4
    a0a0:	f811 3b01 	ldrb.w	r3, [r1], #1
    a0a4:	3b30      	subs	r3, #48	; 0x30
    a0a6:	2b09      	cmp	r3, #9
    a0a8:	d94e      	bls.n	a148 <_vfiprintf_r+0x1c4>
    a0aa:	b1b0      	cbz	r0, a0da <_vfiprintf_r+0x156>
    a0ac:	9207      	str	r2, [sp, #28]
    a0ae:	e014      	b.n	a0da <_vfiprintf_r+0x156>
    a0b0:	eba0 0308 	sub.w	r3, r0, r8
    a0b4:	fa09 f303 	lsl.w	r3, r9, r3
    a0b8:	4313      	orrs	r3, r2
    a0ba:	9304      	str	r3, [sp, #16]
    a0bc:	46a2      	mov	sl, r4
    a0be:	e7d2      	b.n	a066 <_vfiprintf_r+0xe2>
    a0c0:	9b03      	ldr	r3, [sp, #12]
    a0c2:	1d19      	adds	r1, r3, #4
    a0c4:	681b      	ldr	r3, [r3, #0]
    a0c6:	9103      	str	r1, [sp, #12]
    a0c8:	2b00      	cmp	r3, #0
    a0ca:	bfbb      	ittet	lt
    a0cc:	425b      	neglt	r3, r3
    a0ce:	f042 0202 	orrlt.w	r2, r2, #2
    a0d2:	9307      	strge	r3, [sp, #28]
    a0d4:	9307      	strlt	r3, [sp, #28]
    a0d6:	bfb8      	it	lt
    a0d8:	9204      	strlt	r2, [sp, #16]
    a0da:	7823      	ldrb	r3, [r4, #0]
    a0dc:	2b2e      	cmp	r3, #46	; 0x2e
    a0de:	d10c      	bne.n	a0fa <_vfiprintf_r+0x176>
    a0e0:	7863      	ldrb	r3, [r4, #1]
    a0e2:	2b2a      	cmp	r3, #42	; 0x2a
    a0e4:	d135      	bne.n	a152 <_vfiprintf_r+0x1ce>
    a0e6:	9b03      	ldr	r3, [sp, #12]
    a0e8:	1d1a      	adds	r2, r3, #4
    a0ea:	681b      	ldr	r3, [r3, #0]
    a0ec:	9203      	str	r2, [sp, #12]
    a0ee:	2b00      	cmp	r3, #0
    a0f0:	bfb8      	it	lt
    a0f2:	f04f 33ff 	movlt.w	r3, #4294967295	; 0xffffffff
    a0f6:	3402      	adds	r4, #2
    a0f8:	9305      	str	r3, [sp, #20]
    a0fa:	f8df a0d8 	ldr.w	sl, [pc, #216]	; a1d4 <_vfiprintf_r+0x250>
    a0fe:	7821      	ldrb	r1, [r4, #0]
    a100:	2203      	movs	r2, #3
    a102:	4650      	mov	r0, sl
    a104:	f000 faac 	bl	a660 <memchr>
    a108:	b140      	cbz	r0, a11c <_vfiprintf_r+0x198>
    a10a:	2340      	movs	r3, #64	; 0x40
    a10c:	eba0 000a 	sub.w	r0, r0, sl
    a110:	fa03 f000 	lsl.w	r0, r3, r0
    a114:	9b04      	ldr	r3, [sp, #16]
    a116:	4303      	orrs	r3, r0
    a118:	3401      	adds	r4, #1
    a11a:	9304      	str	r3, [sp, #16]
    a11c:	f814 1b01 	ldrb.w	r1, [r4], #1
    a120:	482d      	ldr	r0, [pc, #180]	; (a1d8 <_vfiprintf_r+0x254>)
    a122:	f88d 1028 	strb.w	r1, [sp, #40]	; 0x28
    a126:	2206      	movs	r2, #6
    a128:	f000 fa9a 	bl	a660 <memchr>
    a12c:	2800      	cmp	r0, #0
    a12e:	d03f      	beq.n	a1b0 <_vfiprintf_r+0x22c>
    a130:	4b2a      	ldr	r3, [pc, #168]	; (a1dc <_vfiprintf_r+0x258>)
    a132:	bb1b      	cbnz	r3, a17c <_vfiprintf_r+0x1f8>
    a134:	9b03      	ldr	r3, [sp, #12]
    a136:	3307      	adds	r3, #7
    a138:	f023 0307 	bic.w	r3, r3, #7
    a13c:	3308      	adds	r3, #8
    a13e:	9303      	str	r3, [sp, #12]
    a140:	9b09      	ldr	r3, [sp, #36]	; 0x24
    a142:	443b      	add	r3, r7
    a144:	9309      	str	r3, [sp, #36]	; 0x24
    a146:	e767      	b.n	a018 <_vfiprintf_r+0x94>
    a148:	fb0c 3202 	mla	r2, ip, r2, r3
    a14c:	460c      	mov	r4, r1
    a14e:	2001      	movs	r0, #1
    a150:	e7a5      	b.n	a09e <_vfiprintf_r+0x11a>
    a152:	2300      	movs	r3, #0
    a154:	3401      	adds	r4, #1
    a156:	9305      	str	r3, [sp, #20]
    a158:	4619      	mov	r1, r3
    a15a:	f04f 0c0a 	mov.w	ip, #10
    a15e:	4620      	mov	r0, r4
    a160:	f810 2b01 	ldrb.w	r2, [r0], #1
    a164:	3a30      	subs	r2, #48	; 0x30
    a166:	2a09      	cmp	r2, #9
    a168:	d903      	bls.n	a172 <_vfiprintf_r+0x1ee>
    a16a:	2b00      	cmp	r3, #0
    a16c:	d0c5      	beq.n	a0fa <_vfiprintf_r+0x176>
    a16e:	9105      	str	r1, [sp, #20]
    a170:	e7c3      	b.n	a0fa <_vfiprintf_r+0x176>
    a172:	fb0c 2101 	mla	r1, ip, r1, r2
    a176:	4604      	mov	r4, r0
    a178:	2301      	movs	r3, #1
    a17a:	e7f0      	b.n	a15e <_vfiprintf_r+0x1da>
    a17c:	ab03      	add	r3, sp, #12
    a17e:	9300      	str	r3, [sp, #0]
    a180:	462a      	mov	r2, r5
    a182:	4b17      	ldr	r3, [pc, #92]	; (a1e0 <_vfiprintf_r+0x25c>)
    a184:	a904      	add	r1, sp, #16
    a186:	4630      	mov	r0, r6
    a188:	f3af 8000 	nop.w
    a18c:	4607      	mov	r7, r0
    a18e:	1c78      	adds	r0, r7, #1
    a190:	d1d6      	bne.n	a140 <_vfiprintf_r+0x1bc>
    a192:	6e6b      	ldr	r3, [r5, #100]	; 0x64
    a194:	07d9      	lsls	r1, r3, #31
    a196:	d405      	bmi.n	a1a4 <_vfiprintf_r+0x220>
    a198:	89ab      	ldrh	r3, [r5, #12]
    a19a:	059a      	lsls	r2, r3, #22
    a19c:	d402      	bmi.n	a1a4 <_vfiprintf_r+0x220>
    a19e:	6da8      	ldr	r0, [r5, #88]	; 0x58
    a1a0:	f7ff fd7b 	bl	9c9a <__retarget_lock_release_recursive>
    a1a4:	89ab      	ldrh	r3, [r5, #12]
    a1a6:	065b      	lsls	r3, r3, #25
    a1a8:	f53f af12 	bmi.w	9fd0 <_vfiprintf_r+0x4c>
    a1ac:	9809      	ldr	r0, [sp, #36]	; 0x24
    a1ae:	e711      	b.n	9fd4 <_vfiprintf_r+0x50>
    a1b0:	ab03      	add	r3, sp, #12
    a1b2:	9300      	str	r3, [sp, #0]
    a1b4:	462a      	mov	r2, r5
    a1b6:	4b0a      	ldr	r3, [pc, #40]	; (a1e0 <_vfiprintf_r+0x25c>)
    a1b8:	a904      	add	r1, sp, #16
    a1ba:	4630      	mov	r0, r6
    a1bc:	f000 f880 	bl	a2c0 <_printf_i>
    a1c0:	e7e4      	b.n	a18c <_vfiprintf_r+0x208>
    a1c2:	bf00      	nop
    a1c4:	0000ab18 	.word	0x0000ab18
    a1c8:	0000ab38 	.word	0x0000ab38
    a1cc:	0000aaf8 	.word	0x0000aaf8
    a1d0:	0000ab58 	.word	0x0000ab58
    a1d4:	0000ab5e 	.word	0x0000ab5e
    a1d8:	0000ab62 	.word	0x0000ab62
    a1dc:	00000000 	.word	0x00000000
    a1e0:	00009f5f 	.word	0x00009f5f

0000a1e4 <_printf_common>:
    a1e4:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    a1e8:	4616      	mov	r6, r2
    a1ea:	4699      	mov	r9, r3
    a1ec:	688a      	ldr	r2, [r1, #8]
    a1ee:	690b      	ldr	r3, [r1, #16]
    a1f0:	f8dd 8020 	ldr.w	r8, [sp, #32]
    a1f4:	4293      	cmp	r3, r2
    a1f6:	bfb8      	it	lt
    a1f8:	4613      	movlt	r3, r2
    a1fa:	6033      	str	r3, [r6, #0]
    a1fc:	f891 2043 	ldrb.w	r2, [r1, #67]	; 0x43
    a200:	4607      	mov	r7, r0
    a202:	460c      	mov	r4, r1
    a204:	b10a      	cbz	r2, a20a <_printf_common+0x26>
    a206:	3301      	adds	r3, #1
    a208:	6033      	str	r3, [r6, #0]
    a20a:	6823      	ldr	r3, [r4, #0]
    a20c:	0699      	lsls	r1, r3, #26
    a20e:	bf42      	ittt	mi
    a210:	6833      	ldrmi	r3, [r6, #0]
    a212:	3302      	addmi	r3, #2
    a214:	6033      	strmi	r3, [r6, #0]
    a216:	6825      	ldr	r5, [r4, #0]
    a218:	f015 0506 	ands.w	r5, r5, #6
    a21c:	d106      	bne.n	a22c <_printf_common+0x48>
    a21e:	f104 0a19 	add.w	sl, r4, #25
    a222:	68e3      	ldr	r3, [r4, #12]
    a224:	6832      	ldr	r2, [r6, #0]
    a226:	1a9b      	subs	r3, r3, r2
    a228:	42ab      	cmp	r3, r5
    a22a:	dc26      	bgt.n	a27a <_printf_common+0x96>
    a22c:	f894 2043 	ldrb.w	r2, [r4, #67]	; 0x43
    a230:	1e13      	subs	r3, r2, #0
    a232:	6822      	ldr	r2, [r4, #0]
    a234:	bf18      	it	ne
    a236:	2301      	movne	r3, #1
    a238:	0692      	lsls	r2, r2, #26
    a23a:	d42b      	bmi.n	a294 <_printf_common+0xb0>
    a23c:	f104 0243 	add.w	r2, r4, #67	; 0x43
    a240:	4649      	mov	r1, r9
    a242:	4638      	mov	r0, r7
    a244:	47c0      	blx	r8
    a246:	3001      	adds	r0, #1
    a248:	d01e      	beq.n	a288 <_printf_common+0xa4>
    a24a:	6823      	ldr	r3, [r4, #0]
    a24c:	68e5      	ldr	r5, [r4, #12]
    a24e:	6832      	ldr	r2, [r6, #0]
    a250:	f003 0306 	and.w	r3, r3, #6
    a254:	2b04      	cmp	r3, #4
    a256:	bf08      	it	eq
    a258:	1aad      	subeq	r5, r5, r2
    a25a:	68a3      	ldr	r3, [r4, #8]
    a25c:	6922      	ldr	r2, [r4, #16]
    a25e:	bf0c      	ite	eq
    a260:	ea25 75e5 	biceq.w	r5, r5, r5, asr #31
    a264:	2500      	movne	r5, #0
    a266:	4293      	cmp	r3, r2
    a268:	bfc4      	itt	gt
    a26a:	1a9b      	subgt	r3, r3, r2
    a26c:	18ed      	addgt	r5, r5, r3
    a26e:	2600      	movs	r6, #0
    a270:	341a      	adds	r4, #26
    a272:	42b5      	cmp	r5, r6
    a274:	d11a      	bne.n	a2ac <_printf_common+0xc8>
    a276:	2000      	movs	r0, #0
    a278:	e008      	b.n	a28c <_printf_common+0xa8>
    a27a:	2301      	movs	r3, #1
    a27c:	4652      	mov	r2, sl
    a27e:	4649      	mov	r1, r9
    a280:	4638      	mov	r0, r7
    a282:	47c0      	blx	r8
    a284:	3001      	adds	r0, #1
    a286:	d103      	bne.n	a290 <_printf_common+0xac>
    a288:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    a28c:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    a290:	3501      	adds	r5, #1
    a292:	e7c6      	b.n	a222 <_printf_common+0x3e>
    a294:	18e1      	adds	r1, r4, r3
    a296:	1c5a      	adds	r2, r3, #1
    a298:	2030      	movs	r0, #48	; 0x30
    a29a:	f881 0043 	strb.w	r0, [r1, #67]	; 0x43
    a29e:	4422      	add	r2, r4
    a2a0:	f894 1045 	ldrb.w	r1, [r4, #69]	; 0x45
    a2a4:	f882 1043 	strb.w	r1, [r2, #67]	; 0x43
    a2a8:	3302      	adds	r3, #2
    a2aa:	e7c7      	b.n	a23c <_printf_common+0x58>
    a2ac:	2301      	movs	r3, #1
    a2ae:	4622      	mov	r2, r4
    a2b0:	4649      	mov	r1, r9
    a2b2:	4638      	mov	r0, r7
    a2b4:	47c0      	blx	r8
    a2b6:	3001      	adds	r0, #1
    a2b8:	d0e6      	beq.n	a288 <_printf_common+0xa4>
    a2ba:	3601      	adds	r6, #1
    a2bc:	e7d9      	b.n	a272 <_printf_common+0x8e>
	...

0000a2c0 <_printf_i>:
    a2c0:	e92d 47ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, lr}
    a2c4:	7e0f      	ldrb	r7, [r1, #24]
    a2c6:	9d0c      	ldr	r5, [sp, #48]	; 0x30
    a2c8:	2f78      	cmp	r7, #120	; 0x78
    a2ca:	4691      	mov	r9, r2
    a2cc:	4680      	mov	r8, r0
    a2ce:	460c      	mov	r4, r1
    a2d0:	469a      	mov	sl, r3
    a2d2:	f101 0243 	add.w	r2, r1, #67	; 0x43
    a2d6:	d807      	bhi.n	a2e8 <_printf_i+0x28>
    a2d8:	2f62      	cmp	r7, #98	; 0x62
    a2da:	d80a      	bhi.n	a2f2 <_printf_i+0x32>
    a2dc:	2f00      	cmp	r7, #0
    a2de:	f000 80d8 	beq.w	a492 <_printf_i+0x1d2>
    a2e2:	2f58      	cmp	r7, #88	; 0x58
    a2e4:	f000 80a3 	beq.w	a42e <_printf_i+0x16e>
    a2e8:	f104 0542 	add.w	r5, r4, #66	; 0x42
    a2ec:	f884 7042 	strb.w	r7, [r4, #66]	; 0x42
    a2f0:	e03a      	b.n	a368 <_printf_i+0xa8>
    a2f2:	f1a7 0363 	sub.w	r3, r7, #99	; 0x63
    a2f6:	2b15      	cmp	r3, #21
    a2f8:	d8f6      	bhi.n	a2e8 <_printf_i+0x28>
    a2fa:	a101      	add	r1, pc, #4	; (adr r1, a300 <_printf_i+0x40>)
    a2fc:	f851 f023 	ldr.w	pc, [r1, r3, lsl #2]
    a300:	0000a359 	.word	0x0000a359
    a304:	0000a36d 	.word	0x0000a36d
    a308:	0000a2e9 	.word	0x0000a2e9
    a30c:	0000a2e9 	.word	0x0000a2e9
    a310:	0000a2e9 	.word	0x0000a2e9
    a314:	0000a2e9 	.word	0x0000a2e9
    a318:	0000a36d 	.word	0x0000a36d
    a31c:	0000a2e9 	.word	0x0000a2e9
    a320:	0000a2e9 	.word	0x0000a2e9
    a324:	0000a2e9 	.word	0x0000a2e9
    a328:	0000a2e9 	.word	0x0000a2e9
    a32c:	0000a479 	.word	0x0000a479
    a330:	0000a39d 	.word	0x0000a39d
    a334:	0000a45b 	.word	0x0000a45b
    a338:	0000a2e9 	.word	0x0000a2e9
    a33c:	0000a2e9 	.word	0x0000a2e9
    a340:	0000a49b 	.word	0x0000a49b
    a344:	0000a2e9 	.word	0x0000a2e9
    a348:	0000a39d 	.word	0x0000a39d
    a34c:	0000a2e9 	.word	0x0000a2e9
    a350:	0000a2e9 	.word	0x0000a2e9
    a354:	0000a463 	.word	0x0000a463
    a358:	682b      	ldr	r3, [r5, #0]
    a35a:	1d1a      	adds	r2, r3, #4
    a35c:	681b      	ldr	r3, [r3, #0]
    a35e:	602a      	str	r2, [r5, #0]
    a360:	f104 0542 	add.w	r5, r4, #66	; 0x42
    a364:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42
    a368:	2301      	movs	r3, #1
    a36a:	e0a3      	b.n	a4b4 <_printf_i+0x1f4>
    a36c:	6820      	ldr	r0, [r4, #0]
    a36e:	6829      	ldr	r1, [r5, #0]
    a370:	0606      	lsls	r6, r0, #24
    a372:	f101 0304 	add.w	r3, r1, #4
    a376:	d50a      	bpl.n	a38e <_printf_i+0xce>
    a378:	680e      	ldr	r6, [r1, #0]
    a37a:	602b      	str	r3, [r5, #0]
    a37c:	2e00      	cmp	r6, #0
    a37e:	da03      	bge.n	a388 <_printf_i+0xc8>
    a380:	232d      	movs	r3, #45	; 0x2d
    a382:	4276      	negs	r6, r6
    a384:	f884 3043 	strb.w	r3, [r4, #67]	; 0x43
    a388:	485e      	ldr	r0, [pc, #376]	; (a504 <_printf_i+0x244>)
    a38a:	230a      	movs	r3, #10
    a38c:	e019      	b.n	a3c2 <_printf_i+0x102>
    a38e:	680e      	ldr	r6, [r1, #0]
    a390:	602b      	str	r3, [r5, #0]
    a392:	f010 0f40 	tst.w	r0, #64	; 0x40
    a396:	bf18      	it	ne
    a398:	b236      	sxthne	r6, r6
    a39a:	e7ef      	b.n	a37c <_printf_i+0xbc>
    a39c:	682b      	ldr	r3, [r5, #0]
    a39e:	6820      	ldr	r0, [r4, #0]
    a3a0:	1d19      	adds	r1, r3, #4
    a3a2:	6029      	str	r1, [r5, #0]
    a3a4:	0601      	lsls	r1, r0, #24
    a3a6:	d501      	bpl.n	a3ac <_printf_i+0xec>
    a3a8:	681e      	ldr	r6, [r3, #0]
    a3aa:	e002      	b.n	a3b2 <_printf_i+0xf2>
    a3ac:	0646      	lsls	r6, r0, #25
    a3ae:	d5fb      	bpl.n	a3a8 <_printf_i+0xe8>
    a3b0:	881e      	ldrh	r6, [r3, #0]
    a3b2:	4854      	ldr	r0, [pc, #336]	; (a504 <_printf_i+0x244>)
    a3b4:	2f6f      	cmp	r7, #111	; 0x6f
    a3b6:	bf0c      	ite	eq
    a3b8:	2308      	moveq	r3, #8
    a3ba:	230a      	movne	r3, #10
    a3bc:	2100      	movs	r1, #0
    a3be:	f884 1043 	strb.w	r1, [r4, #67]	; 0x43
    a3c2:	6865      	ldr	r5, [r4, #4]
    a3c4:	60a5      	str	r5, [r4, #8]
    a3c6:	2d00      	cmp	r5, #0
    a3c8:	bfa2      	ittt	ge
    a3ca:	6821      	ldrge	r1, [r4, #0]
    a3cc:	f021 0104 	bicge.w	r1, r1, #4
    a3d0:	6021      	strge	r1, [r4, #0]
    a3d2:	b90e      	cbnz	r6, a3d8 <_printf_i+0x118>
    a3d4:	2d00      	cmp	r5, #0
    a3d6:	d04d      	beq.n	a474 <_printf_i+0x1b4>
    a3d8:	4615      	mov	r5, r2
    a3da:	fbb6 f1f3 	udiv	r1, r6, r3
    a3de:	fb03 6711 	mls	r7, r3, r1, r6
    a3e2:	5dc7      	ldrb	r7, [r0, r7]
    a3e4:	f805 7d01 	strb.w	r7, [r5, #-1]!
    a3e8:	4637      	mov	r7, r6
    a3ea:	42bb      	cmp	r3, r7
    a3ec:	460e      	mov	r6, r1
    a3ee:	d9f4      	bls.n	a3da <_printf_i+0x11a>
    a3f0:	2b08      	cmp	r3, #8
    a3f2:	d10b      	bne.n	a40c <_printf_i+0x14c>
    a3f4:	6823      	ldr	r3, [r4, #0]
    a3f6:	07de      	lsls	r6, r3, #31
    a3f8:	d508      	bpl.n	a40c <_printf_i+0x14c>
    a3fa:	6923      	ldr	r3, [r4, #16]
    a3fc:	6861      	ldr	r1, [r4, #4]
    a3fe:	4299      	cmp	r1, r3
    a400:	bfde      	ittt	le
    a402:	2330      	movle	r3, #48	; 0x30
    a404:	f805 3c01 	strble.w	r3, [r5, #-1]
    a408:	f105 35ff 	addle.w	r5, r5, #4294967295	; 0xffffffff
    a40c:	1b52      	subs	r2, r2, r5
    a40e:	6122      	str	r2, [r4, #16]
    a410:	f8cd a000 	str.w	sl, [sp]
    a414:	464b      	mov	r3, r9
    a416:	aa03      	add	r2, sp, #12
    a418:	4621      	mov	r1, r4
    a41a:	4640      	mov	r0, r8
    a41c:	f7ff fee2 	bl	a1e4 <_printf_common>
    a420:	3001      	adds	r0, #1
    a422:	d14c      	bne.n	a4be <_printf_i+0x1fe>
    a424:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    a428:	b004      	add	sp, #16
    a42a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    a42e:	4835      	ldr	r0, [pc, #212]	; (a504 <_printf_i+0x244>)
    a430:	f881 7045 	strb.w	r7, [r1, #69]	; 0x45
    a434:	6829      	ldr	r1, [r5, #0]
    a436:	6823      	ldr	r3, [r4, #0]
    a438:	f851 6b04 	ldr.w	r6, [r1], #4
    a43c:	6029      	str	r1, [r5, #0]
    a43e:	061d      	lsls	r5, r3, #24
    a440:	d514      	bpl.n	a46c <_printf_i+0x1ac>
    a442:	07df      	lsls	r7, r3, #31
    a444:	bf44      	itt	mi
    a446:	f043 0320 	orrmi.w	r3, r3, #32
    a44a:	6023      	strmi	r3, [r4, #0]
    a44c:	b91e      	cbnz	r6, a456 <_printf_i+0x196>
    a44e:	6823      	ldr	r3, [r4, #0]
    a450:	f023 0320 	bic.w	r3, r3, #32
    a454:	6023      	str	r3, [r4, #0]
    a456:	2310      	movs	r3, #16
    a458:	e7b0      	b.n	a3bc <_printf_i+0xfc>
    a45a:	6823      	ldr	r3, [r4, #0]
    a45c:	f043 0320 	orr.w	r3, r3, #32
    a460:	6023      	str	r3, [r4, #0]
    a462:	2378      	movs	r3, #120	; 0x78
    a464:	4828      	ldr	r0, [pc, #160]	; (a508 <_printf_i+0x248>)
    a466:	f884 3045 	strb.w	r3, [r4, #69]	; 0x45
    a46a:	e7e3      	b.n	a434 <_printf_i+0x174>
    a46c:	0659      	lsls	r1, r3, #25
    a46e:	bf48      	it	mi
    a470:	b2b6      	uxthmi	r6, r6
    a472:	e7e6      	b.n	a442 <_printf_i+0x182>
    a474:	4615      	mov	r5, r2
    a476:	e7bb      	b.n	a3f0 <_printf_i+0x130>
    a478:	682b      	ldr	r3, [r5, #0]
    a47a:	6826      	ldr	r6, [r4, #0]
    a47c:	6961      	ldr	r1, [r4, #20]
    a47e:	1d18      	adds	r0, r3, #4
    a480:	6028      	str	r0, [r5, #0]
    a482:	0635      	lsls	r5, r6, #24
    a484:	681b      	ldr	r3, [r3, #0]
    a486:	d501      	bpl.n	a48c <_printf_i+0x1cc>
    a488:	6019      	str	r1, [r3, #0]
    a48a:	e002      	b.n	a492 <_printf_i+0x1d2>
    a48c:	0670      	lsls	r0, r6, #25
    a48e:	d5fb      	bpl.n	a488 <_printf_i+0x1c8>
    a490:	8019      	strh	r1, [r3, #0]
    a492:	2300      	movs	r3, #0
    a494:	6123      	str	r3, [r4, #16]
    a496:	4615      	mov	r5, r2
    a498:	e7ba      	b.n	a410 <_printf_i+0x150>
    a49a:	682b      	ldr	r3, [r5, #0]
    a49c:	1d1a      	adds	r2, r3, #4
    a49e:	602a      	str	r2, [r5, #0]
    a4a0:	681d      	ldr	r5, [r3, #0]
    a4a2:	6862      	ldr	r2, [r4, #4]
    a4a4:	2100      	movs	r1, #0
    a4a6:	4628      	mov	r0, r5
    a4a8:	f000 f8da 	bl	a660 <memchr>
    a4ac:	b108      	cbz	r0, a4b2 <_printf_i+0x1f2>
    a4ae:	1b40      	subs	r0, r0, r5
    a4b0:	6060      	str	r0, [r4, #4]
    a4b2:	6863      	ldr	r3, [r4, #4]
    a4b4:	6123      	str	r3, [r4, #16]
    a4b6:	2300      	movs	r3, #0
    a4b8:	f884 3043 	strb.w	r3, [r4, #67]	; 0x43
    a4bc:	e7a8      	b.n	a410 <_printf_i+0x150>
    a4be:	6923      	ldr	r3, [r4, #16]
    a4c0:	462a      	mov	r2, r5
    a4c2:	4649      	mov	r1, r9
    a4c4:	4640      	mov	r0, r8
    a4c6:	47d0      	blx	sl
    a4c8:	3001      	adds	r0, #1
    a4ca:	d0ab      	beq.n	a424 <_printf_i+0x164>
    a4cc:	6823      	ldr	r3, [r4, #0]
    a4ce:	079b      	lsls	r3, r3, #30
    a4d0:	d413      	bmi.n	a4fa <_printf_i+0x23a>
    a4d2:	68e0      	ldr	r0, [r4, #12]
    a4d4:	9b03      	ldr	r3, [sp, #12]
    a4d6:	4298      	cmp	r0, r3
    a4d8:	bfb8      	it	lt
    a4da:	4618      	movlt	r0, r3
    a4dc:	e7a4      	b.n	a428 <_printf_i+0x168>
    a4de:	2301      	movs	r3, #1
    a4e0:	4632      	mov	r2, r6
    a4e2:	4649      	mov	r1, r9
    a4e4:	4640      	mov	r0, r8
    a4e6:	47d0      	blx	sl
    a4e8:	3001      	adds	r0, #1
    a4ea:	d09b      	beq.n	a424 <_printf_i+0x164>
    a4ec:	3501      	adds	r5, #1
    a4ee:	68e3      	ldr	r3, [r4, #12]
    a4f0:	9903      	ldr	r1, [sp, #12]
    a4f2:	1a5b      	subs	r3, r3, r1
    a4f4:	42ab      	cmp	r3, r5
    a4f6:	dcf2      	bgt.n	a4de <_printf_i+0x21e>
    a4f8:	e7eb      	b.n	a4d2 <_printf_i+0x212>
    a4fa:	2500      	movs	r5, #0
    a4fc:	f104 0619 	add.w	r6, r4, #25
    a500:	e7f5      	b.n	a4ee <_printf_i+0x22e>
    a502:	bf00      	nop
    a504:	0000ab69 	.word	0x0000ab69
    a508:	0000ab7a 	.word	0x0000ab7a

0000a50c <_sbrk_r>:
    a50c:	b538      	push	{r3, r4, r5, lr}
    a50e:	4d06      	ldr	r5, [pc, #24]	; (a528 <_sbrk_r+0x1c>)
    a510:	2300      	movs	r3, #0
    a512:	4604      	mov	r4, r0
    a514:	4608      	mov	r0, r1
    a516:	602b      	str	r3, [r5, #0]
    a518:	f7f6 fb1a 	bl	b50 <_sbrk>
    a51c:	1c43      	adds	r3, r0, #1
    a51e:	d102      	bne.n	a526 <_sbrk_r+0x1a>
    a520:	682b      	ldr	r3, [r5, #0]
    a522:	b103      	cbz	r3, a526 <_sbrk_r+0x1a>
    a524:	6023      	str	r3, [r4, #0]
    a526:	bd38      	pop	{r3, r4, r5, pc}
    a528:	200163a8 	.word	0x200163a8

0000a52c <__sread>:
    a52c:	b510      	push	{r4, lr}
    a52e:	460c      	mov	r4, r1
    a530:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
    a534:	f000 f8f0 	bl	a718 <_read_r>
    a538:	2800      	cmp	r0, #0
    a53a:	bfab      	itete	ge
    a53c:	6d63      	ldrge	r3, [r4, #84]	; 0x54
    a53e:	89a3      	ldrhlt	r3, [r4, #12]
    a540:	181b      	addge	r3, r3, r0
    a542:	f423 5380 	biclt.w	r3, r3, #4096	; 0x1000
    a546:	bfac      	ite	ge
    a548:	6563      	strge	r3, [r4, #84]	; 0x54
    a54a:	81a3      	strhlt	r3, [r4, #12]
    a54c:	bd10      	pop	{r4, pc}

0000a54e <__swrite>:
    a54e:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    a552:	461f      	mov	r7, r3
    a554:	898b      	ldrh	r3, [r1, #12]
    a556:	05db      	lsls	r3, r3, #23
    a558:	4605      	mov	r5, r0
    a55a:	460c      	mov	r4, r1
    a55c:	4616      	mov	r6, r2
    a55e:	d505      	bpl.n	a56c <__swrite+0x1e>
    a560:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
    a564:	2302      	movs	r3, #2
    a566:	2200      	movs	r2, #0
    a568:	f000 f868 	bl	a63c <_lseek_r>
    a56c:	89a3      	ldrh	r3, [r4, #12]
    a56e:	f9b4 100e 	ldrsh.w	r1, [r4, #14]
    a572:	f423 5380 	bic.w	r3, r3, #4096	; 0x1000
    a576:	81a3      	strh	r3, [r4, #12]
    a578:	4632      	mov	r2, r6
    a57a:	463b      	mov	r3, r7
    a57c:	4628      	mov	r0, r5
    a57e:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
    a582:	f000 b817 	b.w	a5b4 <_write_r>

0000a586 <__sseek>:
    a586:	b510      	push	{r4, lr}
    a588:	460c      	mov	r4, r1
    a58a:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
    a58e:	f000 f855 	bl	a63c <_lseek_r>
    a592:	1c43      	adds	r3, r0, #1
    a594:	89a3      	ldrh	r3, [r4, #12]
    a596:	bf15      	itete	ne
    a598:	6560      	strne	r0, [r4, #84]	; 0x54
    a59a:	f423 5380 	biceq.w	r3, r3, #4096	; 0x1000
    a59e:	f443 5380 	orrne.w	r3, r3, #4096	; 0x1000
    a5a2:	81a3      	strheq	r3, [r4, #12]
    a5a4:	bf18      	it	ne
    a5a6:	81a3      	strhne	r3, [r4, #12]
    a5a8:	bd10      	pop	{r4, pc}

0000a5aa <__sclose>:
    a5aa:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
    a5ae:	f000 b813 	b.w	a5d8 <_close_r>
	...

0000a5b4 <_write_r>:
    a5b4:	b538      	push	{r3, r4, r5, lr}
    a5b6:	4d07      	ldr	r5, [pc, #28]	; (a5d4 <_write_r+0x20>)
    a5b8:	4604      	mov	r4, r0
    a5ba:	4608      	mov	r0, r1
    a5bc:	4611      	mov	r1, r2
    a5be:	2200      	movs	r2, #0
    a5c0:	602a      	str	r2, [r5, #0]
    a5c2:	461a      	mov	r2, r3
    a5c4:	f7fd fa42 	bl	7a4c <_write>
    a5c8:	1c43      	adds	r3, r0, #1
    a5ca:	d102      	bne.n	a5d2 <_write_r+0x1e>
    a5cc:	682b      	ldr	r3, [r5, #0]
    a5ce:	b103      	cbz	r3, a5d2 <_write_r+0x1e>
    a5d0:	6023      	str	r3, [r4, #0]
    a5d2:	bd38      	pop	{r3, r4, r5, pc}
    a5d4:	200163a8 	.word	0x200163a8

0000a5d8 <_close_r>:
    a5d8:	b538      	push	{r3, r4, r5, lr}
    a5da:	4d06      	ldr	r5, [pc, #24]	; (a5f4 <_close_r+0x1c>)
    a5dc:	2300      	movs	r3, #0
    a5de:	4604      	mov	r4, r0
    a5e0:	4608      	mov	r0, r1
    a5e2:	602b      	str	r3, [r5, #0]
    a5e4:	f7f6 fac2 	bl	b6c <_close>
    a5e8:	1c43      	adds	r3, r0, #1
    a5ea:	d102      	bne.n	a5f2 <_close_r+0x1a>
    a5ec:	682b      	ldr	r3, [r5, #0]
    a5ee:	b103      	cbz	r3, a5f2 <_close_r+0x1a>
    a5f0:	6023      	str	r3, [r4, #0]
    a5f2:	bd38      	pop	{r3, r4, r5, pc}
    a5f4:	200163a8 	.word	0x200163a8

0000a5f8 <_fstat_r>:
    a5f8:	b538      	push	{r3, r4, r5, lr}
    a5fa:	4d07      	ldr	r5, [pc, #28]	; (a618 <_fstat_r+0x20>)
    a5fc:	2300      	movs	r3, #0
    a5fe:	4604      	mov	r4, r0
    a600:	4608      	mov	r0, r1
    a602:	4611      	mov	r1, r2
    a604:	602b      	str	r3, [r5, #0]
    a606:	f7f6 fab4 	bl	b72 <_fstat>
    a60a:	1c43      	adds	r3, r0, #1
    a60c:	d102      	bne.n	a614 <_fstat_r+0x1c>
    a60e:	682b      	ldr	r3, [r5, #0]
    a610:	b103      	cbz	r3, a614 <_fstat_r+0x1c>
    a612:	6023      	str	r3, [r4, #0]
    a614:	bd38      	pop	{r3, r4, r5, pc}
    a616:	bf00      	nop
    a618:	200163a8 	.word	0x200163a8

0000a61c <_isatty_r>:
    a61c:	b538      	push	{r3, r4, r5, lr}
    a61e:	4d06      	ldr	r5, [pc, #24]	; (a638 <_isatty_r+0x1c>)
    a620:	2300      	movs	r3, #0
    a622:	4604      	mov	r4, r0
    a624:	4608      	mov	r0, r1
    a626:	602b      	str	r3, [r5, #0]
    a628:	f7f6 faa8 	bl	b7c <_isatty>
    a62c:	1c43      	adds	r3, r0, #1
    a62e:	d102      	bne.n	a636 <_isatty_r+0x1a>
    a630:	682b      	ldr	r3, [r5, #0]
    a632:	b103      	cbz	r3, a636 <_isatty_r+0x1a>
    a634:	6023      	str	r3, [r4, #0]
    a636:	bd38      	pop	{r3, r4, r5, pc}
    a638:	200163a8 	.word	0x200163a8

0000a63c <_lseek_r>:
    a63c:	b538      	push	{r3, r4, r5, lr}
    a63e:	4d07      	ldr	r5, [pc, #28]	; (a65c <_lseek_r+0x20>)
    a640:	4604      	mov	r4, r0
    a642:	4608      	mov	r0, r1
    a644:	4611      	mov	r1, r2
    a646:	2200      	movs	r2, #0
    a648:	602a      	str	r2, [r5, #0]
    a64a:	461a      	mov	r2, r3
    a64c:	f7f6 fa98 	bl	b80 <_lseek>
    a650:	1c43      	adds	r3, r0, #1
    a652:	d102      	bne.n	a65a <_lseek_r+0x1e>
    a654:	682b      	ldr	r3, [r5, #0]
    a656:	b103      	cbz	r3, a65a <_lseek_r+0x1e>
    a658:	6023      	str	r3, [r4, #0]
    a65a:	bd38      	pop	{r3, r4, r5, pc}
    a65c:	200163a8 	.word	0x200163a8

0000a660 <memchr>:
    a660:	f001 01ff 	and.w	r1, r1, #255	; 0xff
    a664:	2a10      	cmp	r2, #16
    a666:	db2b      	blt.n	a6c0 <memchr+0x60>
    a668:	f010 0f07 	tst.w	r0, #7
    a66c:	d008      	beq.n	a680 <memchr+0x20>
    a66e:	f810 3b01 	ldrb.w	r3, [r0], #1
    a672:	3a01      	subs	r2, #1
    a674:	428b      	cmp	r3, r1
    a676:	d02d      	beq.n	a6d4 <memchr+0x74>
    a678:	f010 0f07 	tst.w	r0, #7
    a67c:	b342      	cbz	r2, a6d0 <memchr+0x70>
    a67e:	d1f6      	bne.n	a66e <memchr+0xe>
    a680:	b4f0      	push	{r4, r5, r6, r7}
    a682:	ea41 2101 	orr.w	r1, r1, r1, lsl #8
    a686:	ea41 4101 	orr.w	r1, r1, r1, lsl #16
    a68a:	f022 0407 	bic.w	r4, r2, #7
    a68e:	f07f 0700 	mvns.w	r7, #0
    a692:	2300      	movs	r3, #0
    a694:	e8f0 5602 	ldrd	r5, r6, [r0], #8
    a698:	3c08      	subs	r4, #8
    a69a:	ea85 0501 	eor.w	r5, r5, r1
    a69e:	ea86 0601 	eor.w	r6, r6, r1
    a6a2:	fa85 f547 	uadd8	r5, r5, r7
    a6a6:	faa3 f587 	sel	r5, r3, r7
    a6aa:	fa86 f647 	uadd8	r6, r6, r7
    a6ae:	faa5 f687 	sel	r6, r5, r7
    a6b2:	b98e      	cbnz	r6, a6d8 <memchr+0x78>
    a6b4:	d1ee      	bne.n	a694 <memchr+0x34>
    a6b6:	bcf0      	pop	{r4, r5, r6, r7}
    a6b8:	f001 01ff 	and.w	r1, r1, #255	; 0xff
    a6bc:	f002 0207 	and.w	r2, r2, #7
    a6c0:	b132      	cbz	r2, a6d0 <memchr+0x70>
    a6c2:	f810 3b01 	ldrb.w	r3, [r0], #1
    a6c6:	3a01      	subs	r2, #1
    a6c8:	ea83 0301 	eor.w	r3, r3, r1
    a6cc:	b113      	cbz	r3, a6d4 <memchr+0x74>
    a6ce:	d1f8      	bne.n	a6c2 <memchr+0x62>
    a6d0:	2000      	movs	r0, #0
    a6d2:	4770      	bx	lr
    a6d4:	3801      	subs	r0, #1
    a6d6:	4770      	bx	lr
    a6d8:	2d00      	cmp	r5, #0
    a6da:	bf06      	itte	eq
    a6dc:	4635      	moveq	r5, r6
    a6de:	3803      	subeq	r0, #3
    a6e0:	3807      	subne	r0, #7
    a6e2:	f015 0f01 	tst.w	r5, #1
    a6e6:	d107      	bne.n	a6f8 <memchr+0x98>
    a6e8:	3001      	adds	r0, #1
    a6ea:	f415 7f80 	tst.w	r5, #256	; 0x100
    a6ee:	bf02      	ittt	eq
    a6f0:	3001      	addeq	r0, #1
    a6f2:	f415 3fc0 	tsteq.w	r5, #98304	; 0x18000
    a6f6:	3001      	addeq	r0, #1
    a6f8:	bcf0      	pop	{r4, r5, r6, r7}
    a6fa:	3801      	subs	r0, #1
    a6fc:	4770      	bx	lr
    a6fe:	bf00      	nop

0000a700 <__malloc_lock>:
    a700:	4801      	ldr	r0, [pc, #4]	; (a708 <__malloc_lock+0x8>)
    a702:	f7ff bac9 	b.w	9c98 <__retarget_lock_acquire_recursive>
    a706:	bf00      	nop
    a708:	2001639c 	.word	0x2001639c

0000a70c <__malloc_unlock>:
    a70c:	4801      	ldr	r0, [pc, #4]	; (a714 <__malloc_unlock+0x8>)
    a70e:	f7ff bac4 	b.w	9c9a <__retarget_lock_release_recursive>
    a712:	bf00      	nop
    a714:	2001639c 	.word	0x2001639c

0000a718 <_read_r>:
    a718:	b538      	push	{r3, r4, r5, lr}
    a71a:	4d07      	ldr	r5, [pc, #28]	; (a738 <_read_r+0x20>)
    a71c:	4604      	mov	r4, r0
    a71e:	4608      	mov	r0, r1
    a720:	4611      	mov	r1, r2
    a722:	2200      	movs	r2, #0
    a724:	602a      	str	r2, [r5, #0]
    a726:	461a      	mov	r2, r3
    a728:	f7f6 fc24 	bl	f74 <_read>
    a72c:	1c43      	adds	r3, r0, #1
    a72e:	d102      	bne.n	a736 <_read_r+0x1e>
    a730:	682b      	ldr	r3, [r5, #0]
    a732:	b103      	cbz	r3, a736 <_read_r+0x1e>
    a734:	6023      	str	r3, [r4, #0]
    a736:	bd38      	pop	{r3, r4, r5, pc}
    a738:	200163a8 	.word	0x200163a8
    a73c:	682f2e2e 	.word	0x682f2e2e
    a740:	732f6c61 	.word	0x732f6c61
    a744:	682f6372 	.word	0x682f6372
    a748:	755f6c61 	.word	0x755f6c61
    a74c:	74726173 	.word	0x74726173
    a750:	6e79735f 	.word	0x6e79735f
    a754:	00632e63 	.word	0x00632e63
    a758:	652f2e2e 	.word	0x652f2e2e
    a75c:	72656874 	.word	0x72656874
    a760:	5f74656e 	.word	0x5f74656e
    a764:	2f796870 	.word	0x2f796870
    a768:	65687465 	.word	0x65687465
    a76c:	74656e72 	.word	0x74656e72
    a770:	7968705f 	.word	0x7968705f
    a774:	632e      	.short	0x632e
	...

0000a777 <CSWTCH.10>:
    a777:	2438 0010 5049 415f 4444 2052 2020 3a20     8$..IP_ADDR    :
    a787:	2520 0d73 000a 454e 5f54 414d 4b53 2020      %s...NET_MASK  
    a797:	3a20 2520 0d73 000a 4147 4554 4157 5f59      : %s...GATEWAY_
    a7a7:	5049 3a20 2520 0d73 000a 0a0d 6f53 6b63     IP : %s.....Sock
    a7b7:	7465 4120 4950 6920 706d 656c 656d 746e     et API implement
    a7c7:	7461 6f69 0d6e                               ation..

0000a7ce <memp_num>:
    a7ce:	0004 0005 0008 0010 0005 000f 0002 0004     ................
    a7de:	0008 0008 0003 0010 0010                    ..........

0000a7e8 <memp_sizes>:
    a7e8:	0020 0098 001c 0010 0020 0018 0010 002c      ....... .....,.
    a7f8:	0014 0014 0010 0010 05fc 2e2e 682f 6c61     ............/hal
    a808:	732f 6372 682f 6c61 6d5f 6361 615f 7973     /src/hal_mac_asy
    a818:	636e 632e ff00 ffff ffff 00ff 0000 0000     nc.c............
	...

0000a82a <ethbroadcast>:
    a82a:	ffff ffff ffff                              ......

0000a830 <ethzero>:
    a830:	0000 0000 0000 2e2e 682f 6c61 732f 6372     ......../hal/src
    a840:	682f 6c61 695f 2e6f 0063 4c43 534f 4445     /hal_io.c.CLOSED
    a850:	4c00 5349 4554 004e 5953 5f4e 4553 544e     .LISTEN.SYN_SENT
    a860:	5300 4e59 525f 5643 0044 5345 4154 4c42     .SYN_RCVD.ESTABL
    a870:	5349 4548 0044 4946 5f4e 4157 5449 315f     ISHED.FIN_WAIT_1
    a880:	4600 4e49 575f 4941 5f54 0032 4c43 534f     .FIN_WAIT_2.CLOS
    a890:	5f45 4157 5449 4300 4f4c 4953 474e 4c00     E_WAIT.CLOSING.L
    a8a0:	5341 5f54 4341 004b 4954 454d 575f 4941     AST_ACK.TIME_WAI
    a8b0:	0054 0000                                   T...

0000a8b4 <tcp_pcb_lists>:
    a8b4:	48f0 2001 48e8 2001 48fc 2001 4904 2001     .H. .H. .H. .I. 

0000a8c4 <tcp_persist_backoff>:
    a8c4:	0603 180c 6030                               ....0`x

0000a8cb <tcp_backoff>:
    a8cb:	0201 0403 0605 0707 0707 0707                .............

0000a8d8 <tcp_state_str>:
    a8d8:	a84a 0000 a851 0000 a858 0000 a861 0000     J...Q...X...a...
    a8e8:	a86a 0000 a876 0000 a881 0000 a88c 0000     j...v...........
    a8f8:	a897 0000 a89f 0000 a8a8 0000 3931 2e32     ............192.
    a908:	3631 2e38 2e31 3031 0030 3532 2e35 3532     168.1.100.255.25
    a918:	2e35 3532 2e35 0030 3931 2e32 3631 2e38     5.255.0.192.168.
    a928:	2e31 0031 2e2e 682f 6c70 732f 7265 6f63     1.1.../hpl/serco
    a938:	2f6d 7068 5f6c 6573 6372 6d6f 632e 0000     m/hpl_sercom.c..
    a948:	3000 4000 3400 4000 2000 4101 4000 4101     .0.@.4.@. .A.@.A
    a958:	0000 4300 0400 4300 0800 4300 0c00 4300     ...C...C...C...C

0000a968 <_i2cms>:
	...

0000a980 <sercomspi_regs>:
	...
    a990:	0d00 450a 6874 7265 656e 2074 696c 6b6e     ...Ethernet link
    a9a0:	7520 0d70 0d0a 4700 414d 0043 654c 0064      up....GMAC.Led.
    a9b0:	0000 0000 7620 6d54 2072 7653 0063 4547     .... vTmr Svc.GE
    a9c0:	0054 7445 6568 6e72 7465 625f 7361 6369     T.Ethernet_basic
	...

0000a9d1 <http_html_hdr>:
    a9d1:	5448 5054 312f 302e 3220 3030 4f20 0d4b     HTTP/1.0 200 OK.
    a9e1:	430a 6e6f 6574 746e 742d 7079 3a65 7420     .Content-type: t
    a9f1:	7865 2f74 7468 6c6d 0a0d 0a0d                ext/html.....

0000a9fe <socket_webpage>:
    a9fe:	683c 6d74 3e6c 3c20 6568 6461 3c3e 6974     <html> <head><ti
    aa0e:	6c74 3e65 6142 6973 2063 6577 7062 6761     tle>Basic webpag
    aa1e:	3c65 742f 7469 656c 3c3e 682f 6165 3e64     e</title></head>
    aa2e:	3c20 6f62 7964 203e 6557 636c 6d6f 2065      <body> Welcome 
    aa3e:	6f74 7920 756f 2072 6162 6973 2063 6577     to your basic we
    aa4e:	7062 6761 2065 7375 6e69 2067 6f53 6b63     bpage using Sock
    aa5e:	7465 4120 4950 202e 2f3c 6f62 7964 203e     et API. </body> 
    aa6e:	2f3c 7468 6c6d 003e 2e2e 682f 6c70 672f     </html>.../hpl/g
    aa7e:	616d 2f63 7068 5f6c 6d67 6361 632e 4900     mac/hpl_gmac.c.I
    aa8e:	4c44 0045 2509 0963 7525 2509 0975 7525     DLE..%c.%u.%u.%u
    aa9e:	0a0d 0000 0000                              ......

0000aaa4 <err_to_errno_table>:
    aaa4:	0000 0000 000c 0000 0069 0000 000b 0000     ........i.......
    aab4:	0071 0000 0073 0000 0016 0000 000b 0000     q...s...........
    aac4:	0062 0000 0072 0000 0067 0000 0068 0000     b...r...g...h...
    aad4:	006b 0000 006b 0000 0005 0000 ffff ffff     k...k...........
    aae4:	6374 6970 5f70 6874 6572 6461 0000 0000     tcpip_thread....

0000aaf4 <_global_impure_ptr>:
    aaf4:	001c 2000                                   ... 

0000aaf8 <__sf_fake_stderr>:
	...

0000ab18 <__sf_fake_stdin>:
	...

0000ab38 <__sf_fake_stdout>:
	...
    ab58:	2d23 2b30 0020 6c68 004c 6665 4567 4746     #-0+ .hlL.efgEFG
    ab68:	3000 3231 3433 3635 3837 4139 4342 4544     .0123456789ABCDE
    ab78:	0046 3130 3332 3534 3736 3938 6261 6463     F.0123456789abcd
    ab88:	6665 0000                                   ef..

0000ab8c <_init>:
    ab8c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    ab8e:	bf00      	nop
    ab90:	bcf8      	pop	{r3, r4, r5, r6, r7}
    ab92:	bc08      	pop	{r3}
    ab94:	469e      	mov	lr, r3
    ab96:	4770      	bx	lr

0000ab98 <__frame_dummy_init_array_entry>:
    ab98:	0289 0000                                   ....

0000ab9c <_fini>:
    ab9c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    ab9e:	bf00      	nop
    aba0:	bcf8      	pop	{r3, r4, r5, r6, r7}
    aba2:	bc08      	pop	{r3}
    aba4:	469e      	mov	lr, r3
    aba6:	4770      	bx	lr

0000aba8 <__do_global_dtors_aux_fini_array_entry>:
    aba8:	0265 0000                                   e...
