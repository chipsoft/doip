
AtmelStart.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         0000ce0c  00000000  00000000  00010000  2**3
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .ARM.exidx    00000008  0000ce0c  0000ce0c  0001ce0c  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  2 .relocate     00000080  20000000  0000ce14  00020000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  3 .bkupram      00000000  47000000  47000000  00020080  2**0
                  CONTENTS
  4 .qspi         00000000  04000000  04000000  00020080  2**0
                  CONTENTS
  5 .bss          00016844  20000080  0000cea0  00020080  2**5
                  ALLOC
  6 .stack        00010004  200168c4  000236e4  00020080  2**0
                  ALLOC
  7 .ARM.attributes 0000002e  00000000  00000000  00020080  2**0
                  CONTENTS, READONLY
  8 .comment      00000049  00000000  00000000  000200ae  2**0
                  CONTENTS, READONLY
  9 .debug_info   0004a93d  00000000  00000000  000200f7  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 10 .debug_abbrev 00009747  00000000  00000000  0006aa34  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 11 .debug_loc    00021af9  00000000  00000000  0007417b  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 12 .debug_aranges 00001cb8  00000000  00000000  00095c74  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 13 .debug_ranges 000036a0  00000000  00000000  0009792c  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 14 .debug_macro  0003fb5a  00000000  00000000  0009afcc  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 15 .debug_line   00036168  00000000  00000000  000dab26  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 16 .debug_str    001313ee  00000000  00000000  00110c8e  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 17 .debug_frame  0000602c  00000000  00000000  0024207c  2**2
                  CONTENTS, READONLY, DEBUGGING, OCTETS

Disassembly of section .text:

00000000 <exception_table>:
       0:	c8 68 02 20 b5 48 00 00 b1 48 00 00 b1 48 00 00     .h. .H...H...H..
      10:	b1 48 00 00 b1 48 00 00 b1 48 00 00 00 00 00 00     .H...H...H......
	...
      2c:	39 9d 00 00 b1 48 00 00 00 00 00 00 c1 9d 00 00     9....H..........
      3c:	21 9e 00 00 b1 48 00 00 b1 48 00 00 b1 48 00 00     !....H...H...H..
      4c:	b1 48 00 00 b1 48 00 00 b1 48 00 00 b1 48 00 00     .H...H...H...H..
      5c:	b1 48 00 00 b1 48 00 00 b1 48 00 00 b1 48 00 00     .H...H...H...H..
      6c:	b1 48 00 00 b1 48 00 00 b1 48 00 00 b1 48 00 00     .H...H...H...H..
      7c:	b1 48 00 00 b1 48 00 00 b1 48 00 00 b1 48 00 00     .H...H...H...H..
      8c:	b1 48 00 00 b1 48 00 00 b1 48 00 00 b1 48 00 00     .H...H...H...H..
      9c:	b1 48 00 00 b1 48 00 00 b1 48 00 00 b1 48 00 00     .H...H...H...H..
      ac:	b1 48 00 00 b1 48 00 00 b1 48 00 00 b1 48 00 00     .H...H...H...H..
      bc:	b1 48 00 00 b1 48 00 00 b1 48 00 00 b1 48 00 00     .H...H...H...H..
      cc:	b1 48 00 00 b1 48 00 00 b1 48 00 00 b1 48 00 00     .H...H...H...H..
      dc:	b1 48 00 00 b1 48 00 00 b1 48 00 00 00 00 00 00     .H...H...H......
	...
      f4:	e1 89 00 00 b1 48 00 00 b1 48 00 00 b1 48 00 00     .....H...H...H..
     104:	b1 48 00 00 b1 48 00 00 b1 48 00 00 b1 48 00 00     .H...H...H...H..
     114:	b1 48 00 00 b1 48 00 00 b1 48 00 00 b1 48 00 00     .H...H...H...H..
     124:	b1 48 00 00 b1 48 00 00 b1 48 00 00 b1 48 00 00     .H...H...H...H..
     134:	b1 48 00 00 b1 48 00 00 b1 48 00 00 b1 48 00 00     .H...H...H...H..
     144:	b1 48 00 00 b1 48 00 00 b1 48 00 00 b1 48 00 00     .H...H...H...H..
     154:	b1 48 00 00 b1 48 00 00 b1 48 00 00 b1 48 00 00     .H...H...H...H..
     164:	b1 48 00 00 b1 48 00 00 b1 48 00 00 b1 48 00 00     .H...H...H...H..
     174:	b1 48 00 00 b1 48 00 00 b1 48 00 00 b1 48 00 00     .H...H...H...H..
     184:	b1 48 00 00 b1 48 00 00 b1 48 00 00 d5 85 00 00     .H...H...H......
     194:	b1 48 00 00 b1 48 00 00 b1 48 00 00 b1 48 00 00     .H...H...H...H..
     1a4:	b1 48 00 00 b1 48 00 00 b1 48 00 00 b1 48 00 00     .H...H...H...H..
     1b4:	b1 48 00 00 b1 48 00 00 b1 48 00 00 b1 48 00 00     .H...H...H...H..
     1c4:	b1 48 00 00 b1 48 00 00 b1 48 00 00 b1 48 00 00     .H...H...H...H..
     1d4:	b1 48 00 00 b1 48 00 00 b1 48 00 00 b1 48 00 00     .H...H...H...H..
     1e4:	b1 48 00 00 b1 48 00 00 b1 48 00 00 b1 48 00 00     .H...H...H...H..
     1f4:	b1 48 00 00 b1 48 00 00 b1 48 00 00 b1 48 00 00     .H...H...H...H..
     204:	b1 48 00 00 b1 48 00 00 b1 48 00 00 b1 48 00 00     .H...H...H...H..
     214:	b1 48 00 00 b1 48 00 00 b1 48 00 00 b1 48 00 00     .H...H...H...H..
     224:	b1 48 00 00 b1 48 00 00 b1 48 00 00 b1 48 00 00     .H...H...H...H..
     234:	b1 48 00 00 b1 48 00 00 b1 48 00 00 b1 48 00 00     .H...H...H...H..
     244:	b1 48 00 00 b1 48 00 00 b1 48 00 00 b1 48 00 00     .H...H...H...H..
     254:	b1 48 00 00 b1 48 00 00 b1 48 00 00 b1 48 00 00     .H...H...H...H..

00000264 <__do_global_dtors_aux>:
     264:	b510      	push	{r4, lr}
     266:	4c05      	ldr	r4, [pc, #20]	; (27c <__do_global_dtors_aux+0x18>)
     268:	7823      	ldrb	r3, [r4, #0]
     26a:	b933      	cbnz	r3, 27a <__do_global_dtors_aux+0x16>
     26c:	4b04      	ldr	r3, [pc, #16]	; (280 <__do_global_dtors_aux+0x1c>)
     26e:	b113      	cbz	r3, 276 <__do_global_dtors_aux+0x12>
     270:	4804      	ldr	r0, [pc, #16]	; (284 <__do_global_dtors_aux+0x20>)
     272:	f3af 8000 	nop.w
     276:	2301      	movs	r3, #1
     278:	7023      	strb	r3, [r4, #0]
     27a:	bd10      	pop	{r4, pc}
     27c:	20000080 	.word	0x20000080
     280:	00000000 	.word	0x00000000
     284:	0000ce14 	.word	0x0000ce14

00000288 <frame_dummy>:
     288:	b508      	push	{r3, lr}
     28a:	4b03      	ldr	r3, [pc, #12]	; (298 <frame_dummy+0x10>)
     28c:	b11b      	cbz	r3, 296 <frame_dummy+0xe>
     28e:	4903      	ldr	r1, [pc, #12]	; (29c <frame_dummy+0x14>)
     290:	4803      	ldr	r0, [pc, #12]	; (2a0 <frame_dummy+0x18>)
     292:	f3af 8000 	nop.w
     296:	bd08      	pop	{r3, pc}
     298:	00000000 	.word	0x00000000
     29c:	20000084 	.word	0x20000084
     2a0:	0000ce14 	.word	0x0000ce14

000002a4 <stdio_io_init>:

/** IO descriptor for STDIO access. */
static struct io_descriptor *stdio_io = NULL;

void stdio_io_init(struct io_descriptor *io)
{
     2a4:	b570      	push	{r4, r5, r6, lr}
#if defined(__GNUC__)
	/* Specify that stdout and stdin should not be buffered. */
	setbuf(stdout, NULL);
     2a6:	4e07      	ldr	r6, [pc, #28]	; (2c4 <stdio_io_init+0x20>)
     2a8:	4d07      	ldr	r5, [pc, #28]	; (2c8 <stdio_io_init+0x24>)
     2aa:	6833      	ldr	r3, [r6, #0]
{
     2ac:	4604      	mov	r4, r0
	setbuf(stdout, NULL);
     2ae:	2100      	movs	r1, #0
     2b0:	6898      	ldr	r0, [r3, #8]
     2b2:	47a8      	blx	r5
	setbuf(stdin, NULL);
     2b4:	6833      	ldr	r3, [r6, #0]
     2b6:	2100      	movs	r1, #0
     2b8:	6858      	ldr	r0, [r3, #4]
     2ba:	47a8      	blx	r5
	 * and AVR GCC library:
	 * - printf() emits one character at a time.
	 * - getchar() requests only 1 byte to exit.
	 */
#endif
	stdio_io = io;
     2bc:	4b03      	ldr	r3, [pc, #12]	; (2cc <stdio_io_init+0x28>)
     2be:	601c      	str	r4, [r3, #0]
}
     2c0:	bd70      	pop	{r4, r5, r6, pc}
     2c2:	bf00      	nop
     2c4:	2000001c 	.word	0x2000001c
     2c8:	0000c0a9 	.word	0x0000c0a9
     2cc:	2000009c 	.word	0x2000009c

000002d0 <stdio_io_read>:
	stdio_io = io;
}

int32_t stdio_io_read(uint8_t *buf, const int32_t len)
{
	if (stdio_io == NULL) {
     2d0:	4a04      	ldr	r2, [pc, #16]	; (2e4 <stdio_io_read+0x14>)
{
     2d2:	4603      	mov	r3, r0
	if (stdio_io == NULL) {
     2d4:	6810      	ldr	r0, [r2, #0]
     2d6:	b118      	cbz	r0, 2e0 <stdio_io_read+0x10>
		return 0;
	}
	return io_read(stdio_io, buf, len);
     2d8:	b28a      	uxth	r2, r1
     2da:	4619      	mov	r1, r3
     2dc:	4b02      	ldr	r3, [pc, #8]	; (2e8 <stdio_io_read+0x18>)
     2de:	4718      	bx	r3
}
     2e0:	4770      	bx	lr
     2e2:	bf00      	nop
     2e4:	2000009c 	.word	0x2000009c
     2e8:	0000632d 	.word	0x0000632d

000002ec <stdio_io_write>:

int32_t stdio_io_write(const uint8_t *buf, const int32_t len)
{
	if (stdio_io == NULL) {
     2ec:	4a04      	ldr	r2, [pc, #16]	; (300 <stdio_io_write+0x14>)
{
     2ee:	4603      	mov	r3, r0
	if (stdio_io == NULL) {
     2f0:	6810      	ldr	r0, [r2, #0]
     2f2:	b118      	cbz	r0, 2fc <stdio_io_write+0x10>
		return 0;
	}
	return io_write(stdio_io, buf, len);
     2f4:	b28a      	uxth	r2, r1
     2f6:	4619      	mov	r1, r3
     2f8:	4b02      	ldr	r3, [pc, #8]	; (304 <stdio_io_write+0x18>)
     2fa:	4718      	bx	r3
}
     2fc:	4770      	bx	lr
     2fe:	bf00      	nop
     300:	2000009c 	.word	0x2000009c
     304:	000062fd 	.word	0x000062fd

00000308 <prvCopyDataToQueue>:

#endif /* configUSE_TRACE_FACILITY */
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue(Queue_t *const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition)
{
     308:	b570      	push	{r4, r5, r6, lr}
     30a:	4615      	mov	r5, r2
	BaseType_t xReturn = pdFALSE;

	if (pxQueue->uxItemSize == (UBaseType_t)0) {
     30c:	6c02      	ldr	r2, [r0, #64]	; 0x40
{
     30e:	4604      	mov	r4, r0
	if (pxQueue->uxItemSize == (UBaseType_t)0) {
     310:	b96a      	cbnz	r2, 32e <prvCopyDataToQueue+0x26>
#if (configUSE_MUTEXES == 1)
		{
			if (pxQueue->uxQueueType == queueQUEUE_IS_MUTEX) {
     312:	6806      	ldr	r6, [r0, #0]
     314:	b10e      	cbz	r6, 31a <prvCopyDataToQueue+0x12>
	BaseType_t xReturn = pdFALSE;
     316:	2500      	movs	r5, #0
     318:	e004      	b.n	324 <prvCopyDataToQueue+0x1c>
				/* The mutex is no longer being held. */
				xReturn                = xTaskPriorityDisinherit((void *)pxQueue->pxMutexHolder);
     31a:	6840      	ldr	r0, [r0, #4]
     31c:	4b16      	ldr	r3, [pc, #88]	; (378 <prvCopyDataToQueue+0x70>)
     31e:	4798      	blx	r3
				pxQueue->pxMutexHolder = NULL;
     320:	6066      	str	r6, [r4, #4]
				xReturn                = xTaskPriorityDisinherit((void *)pxQueue->pxMutexHolder);
     322:	4605      	mov	r5, r0
		} else {
			mtCOVERAGE_TEST_MARKER();
		}
	}

	++(pxQueue->uxMessagesWaiting);
     324:	6ba3      	ldr	r3, [r4, #56]	; 0x38
     326:	3301      	adds	r3, #1
     328:	63a3      	str	r3, [r4, #56]	; 0x38

	return xReturn;
}
     32a:	4628      	mov	r0, r5
     32c:	bd70      	pop	{r4, r5, r6, pc}
	} else if (xPosition == queueSEND_TO_BACK) {
     32e:	4b13      	ldr	r3, [pc, #76]	; (37c <prvCopyDataToQueue+0x74>)
     330:	b95d      	cbnz	r5, 34a <prvCopyDataToQueue+0x42>
		(void)memcpy((void *)pxQueue->pcWriteTo,
     332:	6880      	ldr	r0, [r0, #8]
     334:	4798      	blx	r3
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
     336:	68a3      	ldr	r3, [r4, #8]
     338:	6c22      	ldr	r2, [r4, #64]	; 0x40
     33a:	4413      	add	r3, r2
		if (pxQueue->pcWriteTo >= pxQueue->pcTail) /*lint !e946 MISRA exception justified as comparison of pointers is
     33c:	6862      	ldr	r2, [r4, #4]
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
     33e:	60a3      	str	r3, [r4, #8]
		if (pxQueue->pcWriteTo >= pxQueue->pcTail) /*lint !e946 MISRA exception justified as comparison of pointers is
     340:	4293      	cmp	r3, r2
     342:	d3e8      	bcc.n	316 <prvCopyDataToQueue+0xe>
			pxQueue->pcWriteTo = pxQueue->pcHead;
     344:	6823      	ldr	r3, [r4, #0]
     346:	60a3      	str	r3, [r4, #8]
     348:	e7ec      	b.n	324 <prvCopyDataToQueue+0x1c>
		(void)memcpy((void *)pxQueue->u.pcReadFrom,
     34a:	68c0      	ldr	r0, [r0, #12]
     34c:	4798      	blx	r3
		pxQueue->u.pcReadFrom -= pxQueue->uxItemSize;
     34e:	6c22      	ldr	r2, [r4, #64]	; 0x40
     350:	68e3      	ldr	r3, [r4, #12]
     352:	4251      	negs	r1, r2
     354:	1a9b      	subs	r3, r3, r2
		if (pxQueue->u.pcReadFrom
     356:	6822      	ldr	r2, [r4, #0]
		pxQueue->u.pcReadFrom -= pxQueue->uxItemSize;
     358:	60e3      	str	r3, [r4, #12]
		if (pxQueue->u.pcReadFrom
     35a:	4293      	cmp	r3, r2
			pxQueue->u.pcReadFrom = (pxQueue->pcTail - pxQueue->uxItemSize);
     35c:	bf3e      	ittt	cc
     35e:	6863      	ldrcc	r3, [r4, #4]
     360:	185b      	addcc	r3, r3, r1
     362:	60e3      	strcc	r3, [r4, #12]
		if (xPosition == queueOVERWRITE) {
     364:	2d02      	cmp	r5, #2
     366:	d1d6      	bne.n	316 <prvCopyDataToQueue+0xe>
			if (pxQueue->uxMessagesWaiting > (UBaseType_t)0) {
     368:	6ba3      	ldr	r3, [r4, #56]	; 0x38
     36a:	2b00      	cmp	r3, #0
     36c:	d0d3      	beq.n	316 <prvCopyDataToQueue+0xe>
				--(pxQueue->uxMessagesWaiting);
     36e:	6ba3      	ldr	r3, [r4, #56]	; 0x38
     370:	3b01      	subs	r3, #1
     372:	63a3      	str	r3, [r4, #56]	; 0x38
     374:	e7cf      	b.n	316 <prvCopyDataToQueue+0xe>
     376:	bf00      	nop
     378:	00009375 	.word	0x00009375
     37c:	0000c07d 	.word	0x0000c07d

00000380 <prvNotifyQueueSetContainer>:
	/*-----------------------------------------------------------*/

#if (configUSE_QUEUE_SETS == 1)

static BaseType_t prvNotifyQueueSetContainer(const Queue_t *const pxQueue, const BaseType_t xCopyPosition)
{
     380:	b537      	push	{r0, r1, r2, r4, r5, lr}
	Queue_t *  pxQueueSetContainer = pxQueue->pxQueueSetContainer;
     382:	6d44      	ldr	r4, [r0, #84]	; 0x54
{
     384:	9001      	str	r0, [sp, #4]
     386:	460a      	mov	r2, r1
	BaseType_t xReturn             = pdFALSE;

	/* This function must be called form a critical section. */

	configASSERT(pxQueueSetContainer);
     388:	b944      	cbnz	r4, 39c <prvNotifyQueueSetContainer+0x1c>

portFORCE_INLINE static void vPortRaiseBASEPRI(void)
{
	uint32_t ulNewBASEPRI;

	__asm volatile("	mov %0, %1												\n"
     38a:	f04f 0380 	mov.w	r3, #128	; 0x80
     38e:	f383 8811 	msr	BASEPRI, r3
     392:	f3bf 8f6f 	isb	sy
     396:	f3bf 8f4f 	dsb	sy
     39a:	e7fe      	b.n	39a <prvNotifyQueueSetContainer+0x1a>
	configASSERT(pxQueueSetContainer->uxMessagesWaiting < pxQueueSetContainer->uxLength);
     39c:	6ba1      	ldr	r1, [r4, #56]	; 0x38
     39e:	6be3      	ldr	r3, [r4, #60]	; 0x3c
     3a0:	4299      	cmp	r1, r3
     3a2:	d308      	bcc.n	3b6 <prvNotifyQueueSetContainer+0x36>
     3a4:	f04f 0380 	mov.w	r3, #128	; 0x80
     3a8:	f383 8811 	msr	BASEPRI, r3
     3ac:	f3bf 8f6f 	isb	sy
     3b0:	f3bf 8f4f 	dsb	sy
     3b4:	e7fe      	b.n	3b4 <prvNotifyQueueSetContainer+0x34>

	if (pxQueueSetContainer->uxMessagesWaiting < pxQueueSetContainer->uxLength) {
     3b6:	6ba1      	ldr	r1, [r4, #56]	; 0x38
     3b8:	428b      	cmp	r3, r1
     3ba:	d917      	bls.n	3ec <prvNotifyQueueSetContainer+0x6c>
		traceQUEUE_SEND(pxQueueSetContainer);

		/* The data copied is the handle of the queue that contains data. */
		xReturn = prvCopyDataToQueue(pxQueueSetContainer, &pxQueue, xCopyPosition);
     3bc:	4b0c      	ldr	r3, [pc, #48]	; (3f0 <prvNotifyQueueSetContainer+0x70>)
     3be:	a901      	add	r1, sp, #4
     3c0:	4620      	mov	r0, r4
     3c2:	4798      	blx	r3

		if (pxQueueSetContainer->xTxLock == queueUNLOCKED) {
     3c4:	6ca3      	ldr	r3, [r4, #72]	; 0x48
     3c6:	3301      	adds	r3, #1
		xReturn = prvCopyDataToQueue(pxQueueSetContainer, &pxQueue, xCopyPosition);
     3c8:	4605      	mov	r5, r0
		if (pxQueueSetContainer->xTxLock == queueUNLOCKED) {
     3ca:	d10b      	bne.n	3e4 <prvNotifyQueueSetContainer+0x64>
			if (listLIST_IS_EMPTY(&(pxQueueSetContainer->xTasksWaitingToReceive)) == pdFALSE) {
     3cc:	6a63      	ldr	r3, [r4, #36]	; 0x24
     3ce:	b133      	cbz	r3, 3de <prvNotifyQueueSetContainer+0x5e>
				if (xTaskRemoveFromEventList(&(pxQueueSetContainer->xTasksWaitingToReceive)) != pdFALSE) {
     3d0:	4b08      	ldr	r3, [pc, #32]	; (3f4 <prvNotifyQueueSetContainer+0x74>)
     3d2:	f104 0024 	add.w	r0, r4, #36	; 0x24
     3d6:	4798      	blx	r3
					/* The task waiting has a higher priority. */
					xReturn = pdTRUE;
     3d8:	2800      	cmp	r0, #0
     3da:	bf18      	it	ne
     3dc:	2501      	movne	r5, #1
	} else {
		mtCOVERAGE_TEST_MARKER();
	}

	return xReturn;
}
     3de:	4628      	mov	r0, r5
     3e0:	b003      	add	sp, #12
     3e2:	bd30      	pop	{r4, r5, pc}
			(pxQueueSetContainer->xTxLock)++;
     3e4:	6ca3      	ldr	r3, [r4, #72]	; 0x48
     3e6:	3301      	adds	r3, #1
     3e8:	64a3      	str	r3, [r4, #72]	; 0x48
     3ea:	e7f8      	b.n	3de <prvNotifyQueueSetContainer+0x5e>
	BaseType_t xReturn             = pdFALSE;
     3ec:	2500      	movs	r5, #0
	return xReturn;
     3ee:	e7f6      	b.n	3de <prvNotifyQueueSetContainer+0x5e>
     3f0:	00000309 	.word	0x00000309
     3f4:	000091a5 	.word	0x000091a5

000003f8 <prvCopyDataFromQueue>:
{
     3f8:	4603      	mov	r3, r0
     3fa:	b410      	push	{r4}
	if (pxQueue->uxItemSize != (UBaseType_t)0) {
     3fc:	6c1a      	ldr	r2, [r3, #64]	; 0x40
{
     3fe:	4608      	mov	r0, r1
	if (pxQueue->uxItemSize != (UBaseType_t)0) {
     400:	b16a      	cbz	r2, 41e <prvCopyDataFromQueue+0x26>
		pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
     402:	68dc      	ldr	r4, [r3, #12]
		if (pxQueue->u.pcReadFrom >= pxQueue->pcTail) /*lint !e946 MISRA exception justified as use of the relational
     404:	6859      	ldr	r1, [r3, #4]
		pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
     406:	4414      	add	r4, r2
		if (pxQueue->u.pcReadFrom >= pxQueue->pcTail) /*lint !e946 MISRA exception justified as use of the relational
     408:	428c      	cmp	r4, r1
			pxQueue->u.pcReadFrom = pxQueue->pcHead;
     40a:	bf28      	it	cs
     40c:	6819      	ldrcs	r1, [r3, #0]
		pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
     40e:	60dc      	str	r4, [r3, #12]
			pxQueue->u.pcReadFrom = pxQueue->pcHead;
     410:	bf28      	it	cs
     412:	60d9      	strcs	r1, [r3, #12]
		(void)memcpy((void *)pvBuffer,
     414:	68d9      	ldr	r1, [r3, #12]
}
     416:	f85d 4b04 	ldr.w	r4, [sp], #4
		(void)memcpy((void *)pvBuffer,
     41a:	4b02      	ldr	r3, [pc, #8]	; (424 <prvCopyDataFromQueue+0x2c>)
     41c:	4718      	bx	r3
}
     41e:	f85d 4b04 	ldr.w	r4, [sp], #4
     422:	4770      	bx	lr
     424:	0000c07d 	.word	0x0000c07d

00000428 <prvUnlockQueue>:
{
     428:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	taskENTER_CRITICAL();
     42c:	4e1f      	ldr	r6, [pc, #124]	; (4ac <prvUnlockQueue+0x84>)
						if (xTaskRemoveFromEventList(&(pxQueue->xTasksWaitingToReceive)) != pdFALSE) {
     42e:	4d20      	ldr	r5, [pc, #128]	; (4b0 <prvUnlockQueue+0x88>)
						vTaskMissedYield();
     430:	4f20      	ldr	r7, [pc, #128]	; (4b4 <prvUnlockQueue+0x8c>)
					if (prvNotifyQueueSetContainer(pxQueue, queueSEND_TO_BACK) == pdTRUE) {
     432:	f8df 8088 	ldr.w	r8, [pc, #136]	; 4bc <prvUnlockQueue+0x94>
{
     436:	4604      	mov	r4, r0
	taskENTER_CRITICAL();
     438:	47b0      	blx	r6
		while (pxQueue->xTxLock > queueLOCKED_UNMODIFIED) {
     43a:	6ca3      	ldr	r3, [r4, #72]	; 0x48
     43c:	2b00      	cmp	r3, #0
     43e:	dc14      	bgt.n	46a <prvUnlockQueue+0x42>
		pxQueue->xTxLock = queueUNLOCKED;
     440:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
     444:	64a3      	str	r3, [r4, #72]	; 0x48
	taskEXIT_CRITICAL();
     446:	4d1c      	ldr	r5, [pc, #112]	; (4b8 <prvUnlockQueue+0x90>)
				if (xTaskRemoveFromEventList(&(pxQueue->xTasksWaitingToSend)) != pdFALSE) {
     448:	4f19      	ldr	r7, [pc, #100]	; (4b0 <prvUnlockQueue+0x88>)
					vTaskMissedYield();
     44a:	f8df 8068 	ldr.w	r8, [pc, #104]	; 4b4 <prvUnlockQueue+0x8c>
	taskEXIT_CRITICAL();
     44e:	47a8      	blx	r5
	taskENTER_CRITICAL();
     450:	47b0      	blx	r6
				if (xTaskRemoveFromEventList(&(pxQueue->xTasksWaitingToSend)) != pdFALSE) {
     452:	f104 0610 	add.w	r6, r4, #16
		while (pxQueue->xRxLock > queueLOCKED_UNMODIFIED) {
     456:	6c63      	ldr	r3, [r4, #68]	; 0x44
     458:	2b00      	cmp	r3, #0
     45a:	dc1b      	bgt.n	494 <prvUnlockQueue+0x6c>
		pxQueue->xRxLock = queueUNLOCKED;
     45c:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
     460:	6463      	str	r3, [r4, #68]	; 0x44
	taskEXIT_CRITICAL();
     462:	462b      	mov	r3, r5
}
     464:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
	taskEXIT_CRITICAL();
     468:	4718      	bx	r3
				if (pxQueue->pxQueueSetContainer != NULL) {
     46a:	6d63      	ldr	r3, [r4, #84]	; 0x54
     46c:	b14b      	cbz	r3, 482 <prvUnlockQueue+0x5a>
					if (prvNotifyQueueSetContainer(pxQueue, queueSEND_TO_BACK) == pdTRUE) {
     46e:	2100      	movs	r1, #0
     470:	4620      	mov	r0, r4
     472:	47c0      	blx	r8
     474:	2801      	cmp	r0, #1
     476:	d100      	bne.n	47a <prvUnlockQueue+0x52>
						vTaskMissedYield();
     478:	47b8      	blx	r7
			--(pxQueue->xTxLock);
     47a:	6ca3      	ldr	r3, [r4, #72]	; 0x48
     47c:	3b01      	subs	r3, #1
     47e:	64a3      	str	r3, [r4, #72]	; 0x48
     480:	e7db      	b.n	43a <prvUnlockQueue+0x12>
					if (listLIST_IS_EMPTY(&(pxQueue->xTasksWaitingToReceive)) == pdFALSE) {
     482:	6a63      	ldr	r3, [r4, #36]	; 0x24
     484:	2b00      	cmp	r3, #0
     486:	d0db      	beq.n	440 <prvUnlockQueue+0x18>
						if (xTaskRemoveFromEventList(&(pxQueue->xTasksWaitingToReceive)) != pdFALSE) {
     488:	f104 0024 	add.w	r0, r4, #36	; 0x24
     48c:	47a8      	blx	r5
     48e:	2800      	cmp	r0, #0
     490:	d0f3      	beq.n	47a <prvUnlockQueue+0x52>
     492:	e7f1      	b.n	478 <prvUnlockQueue+0x50>
			if (listLIST_IS_EMPTY(&(pxQueue->xTasksWaitingToSend)) == pdFALSE) {
     494:	6923      	ldr	r3, [r4, #16]
     496:	2b00      	cmp	r3, #0
     498:	d0e0      	beq.n	45c <prvUnlockQueue+0x34>
				if (xTaskRemoveFromEventList(&(pxQueue->xTasksWaitingToSend)) != pdFALSE) {
     49a:	4630      	mov	r0, r6
     49c:	47b8      	blx	r7
     49e:	b100      	cbz	r0, 4a2 <prvUnlockQueue+0x7a>
					vTaskMissedYield();
     4a0:	47c0      	blx	r8
				--(pxQueue->xRxLock);
     4a2:	6c63      	ldr	r3, [r4, #68]	; 0x44
     4a4:	3b01      	subs	r3, #1
     4a6:	6463      	str	r3, [r4, #68]	; 0x44
     4a8:	e7d5      	b.n	456 <prvUnlockQueue+0x2e>
     4aa:	bf00      	nop
     4ac:	00009d59 	.word	0x00009d59
     4b0:	000091a5 	.word	0x000091a5
     4b4:	000092c9 	.word	0x000092c9
     4b8:	00009d99 	.word	0x00009d99
     4bc:	00000381 	.word	0x00000381

000004c0 <xQueueGenericReset>:
{
     4c0:	b538      	push	{r3, r4, r5, lr}
     4c2:	460d      	mov	r5, r1
	configASSERT(pxQueue);
     4c4:	4604      	mov	r4, r0
     4c6:	b940      	cbnz	r0, 4da <xQueueGenericReset+0x1a>
     4c8:	f04f 0380 	mov.w	r3, #128	; 0x80
     4cc:	f383 8811 	msr	BASEPRI, r3
     4d0:	f3bf 8f6f 	isb	sy
     4d4:	f3bf 8f4f 	dsb	sy
     4d8:	e7fe      	b.n	4d8 <xQueueGenericReset+0x18>
	taskENTER_CRITICAL();
     4da:	4b18      	ldr	r3, [pc, #96]	; (53c <xQueueGenericReset+0x7c>)
     4dc:	4798      	blx	r3
		pxQueue->pcTail            = pxQueue->pcHead + (pxQueue->uxLength * pxQueue->uxItemSize);
     4de:	e9d4 310f 	ldrd	r3, r1, [r4, #60]	; 0x3c
     4e2:	6822      	ldr	r2, [r4, #0]
		pxQueue->pcWriteTo         = pxQueue->pcHead;
     4e4:	60a2      	str	r2, [r4, #8]
		pxQueue->pcTail            = pxQueue->pcHead + (pxQueue->uxLength * pxQueue->uxItemSize);
     4e6:	434b      	muls	r3, r1
     4e8:	18d0      	adds	r0, r2, r3
		pxQueue->u.pcReadFrom      = pxQueue->pcHead + ((pxQueue->uxLength - (UBaseType_t)1U) * pxQueue->uxItemSize);
     4ea:	1a5b      	subs	r3, r3, r1
     4ec:	4413      	add	r3, r2
		pxQueue->pcTail            = pxQueue->pcHead + (pxQueue->uxLength * pxQueue->uxItemSize);
     4ee:	6060      	str	r0, [r4, #4]
		pxQueue->u.pcReadFrom      = pxQueue->pcHead + ((pxQueue->uxLength - (UBaseType_t)1U) * pxQueue->uxItemSize);
     4f0:	60e3      	str	r3, [r4, #12]
		pxQueue->uxMessagesWaiting = (UBaseType_t)0U;
     4f2:	2000      	movs	r0, #0
		pxQueue->xRxLock           = queueUNLOCKED;
     4f4:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
		pxQueue->uxMessagesWaiting = (UBaseType_t)0U;
     4f8:	63a0      	str	r0, [r4, #56]	; 0x38
		pxQueue->xRxLock           = queueUNLOCKED;
     4fa:	6463      	str	r3, [r4, #68]	; 0x44
		pxQueue->xTxLock           = queueUNLOCKED;
     4fc:	64a3      	str	r3, [r4, #72]	; 0x48
		if (xNewQueue == pdFALSE) {
     4fe:	b9ad      	cbnz	r5, 52c <xQueueGenericReset+0x6c>
			if (listLIST_IS_EMPTY(&(pxQueue->xTasksWaitingToSend)) == pdFALSE) {
     500:	6923      	ldr	r3, [r4, #16]
     502:	b17b      	cbz	r3, 524 <xQueueGenericReset+0x64>
				if (xTaskRemoveFromEventList(&(pxQueue->xTasksWaitingToSend)) == pdTRUE) {
     504:	4b0e      	ldr	r3, [pc, #56]	; (540 <xQueueGenericReset+0x80>)
     506:	f104 0010 	add.w	r0, r4, #16
     50a:	4798      	blx	r3
     50c:	2801      	cmp	r0, #1
     50e:	d109      	bne.n	524 <xQueueGenericReset+0x64>
					queueYIELD_IF_USING_PREEMPTION();
     510:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
     514:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
     518:	f8c3 2d04 	str.w	r2, [r3, #3332]	; 0xd04
     51c:	f3bf 8f4f 	dsb	sy
     520:	f3bf 8f6f 	isb	sy
	taskEXIT_CRITICAL();
     524:	4b07      	ldr	r3, [pc, #28]	; (544 <xQueueGenericReset+0x84>)
     526:	4798      	blx	r3
}
     528:	2001      	movs	r0, #1
     52a:	bd38      	pop	{r3, r4, r5, pc}
			vListInitialise(&(pxQueue->xTasksWaitingToSend));
     52c:	f104 0010 	add.w	r0, r4, #16
     530:	4d05      	ldr	r5, [pc, #20]	; (548 <xQueueGenericReset+0x88>)
     532:	47a8      	blx	r5
			vListInitialise(&(pxQueue->xTasksWaitingToReceive));
     534:	f104 0024 	add.w	r0, r4, #36	; 0x24
     538:	47a8      	blx	r5
     53a:	e7f3      	b.n	524 <xQueueGenericReset+0x64>
     53c:	00009d59 	.word	0x00009d59
     540:	000091a5 	.word	0x000091a5
     544:	00009d99 	.word	0x00009d99
     548:	00001df9 	.word	0x00001df9

0000054c <xQueueGenericCreate>:
{
     54c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
     54e:	460d      	mov	r5, r1
     550:	4617      	mov	r7, r2
	configASSERT(uxQueueLength > (UBaseType_t)0);
     552:	4606      	mov	r6, r0
     554:	b940      	cbnz	r0, 568 <xQueueGenericCreate+0x1c>
     556:	f04f 0380 	mov.w	r3, #128	; 0x80
     55a:	f383 8811 	msr	BASEPRI, r3
     55e:	f3bf 8f6f 	isb	sy
     562:	f3bf 8f4f 	dsb	sy
     566:	e7fe      	b.n	566 <xQueueGenericCreate+0x1a>
	if (uxItemSize == (UBaseType_t)0) {
     568:	b179      	cbz	r1, 58a <xQueueGenericCreate+0x3e>
		xQueueSizeInBytes = (size_t)(uxQueueLength * uxItemSize)
     56a:	4348      	muls	r0, r1
     56c:	3001      	adds	r0, #1
	pxNewQueue = (Queue_t *)pvPortMalloc(sizeof(Queue_t) + xQueueSizeInBytes);
     56e:	4b11      	ldr	r3, [pc, #68]	; (5b4 <xQueueGenericCreate+0x68>)
     570:	3058      	adds	r0, #88	; 0x58
     572:	4798      	blx	r3
	if (pxNewQueue != NULL) {
     574:	4604      	mov	r4, r0
     576:	b950      	cbnz	r0, 58e <xQueueGenericCreate+0x42>
     578:	f04f 0380 	mov.w	r3, #128	; 0x80
     57c:	f383 8811 	msr	BASEPRI, r3
     580:	f3bf 8f6f 	isb	sy
     584:	f3bf 8f4f 	dsb	sy
	configASSERT(xReturn);
     588:	e7fe      	b.n	588 <xQueueGenericCreate+0x3c>
		xQueueSizeInBytes = (size_t)0;
     58a:	4608      	mov	r0, r1
     58c:	e7ef      	b.n	56e <xQueueGenericCreate+0x22>
		if (uxItemSize == (UBaseType_t)0) {
     58e:	b175      	cbz	r5, 5ae <xQueueGenericCreate+0x62>
			pxNewQueue->pcHead = ((int8_t *)pxNewQueue) + sizeof(Queue_t);
     590:	f100 0358 	add.w	r3, r0, #88	; 0x58
     594:	6023      	str	r3, [r4, #0]
		pxNewQueue->uxItemSize = uxItemSize;
     596:	e9c4 650f 	strd	r6, r5, [r4, #60]	; 0x3c
		(void)xQueueGenericReset(pxNewQueue, pdTRUE);
     59a:	4b07      	ldr	r3, [pc, #28]	; (5b8 <xQueueGenericCreate+0x6c>)
     59c:	2101      	movs	r1, #1
     59e:	4620      	mov	r0, r4
     5a0:	4798      	blx	r3
			pxNewQueue->pxQueueSetContainer = NULL;
     5a2:	2300      	movs	r3, #0
			pxNewQueue->ucQueueType = ucQueueType;
     5a4:	f884 7050 	strb.w	r7, [r4, #80]	; 0x50
			pxNewQueue->pxQueueSetContainer = NULL;
     5a8:	6563      	str	r3, [r4, #84]	; 0x54
}
     5aa:	4620      	mov	r0, r4
     5ac:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
     5ae:	4603      	mov	r3, r0
     5b0:	e7f0      	b.n	594 <xQueueGenericCreate+0x48>
     5b2:	bf00      	nop
     5b4:	00001cfd 	.word	0x00001cfd
     5b8:	000004c1 	.word	0x000004c1

000005bc <xQueueCreateCountingSemaphore>:
{
     5bc:	b510      	push	{r4, lr}
     5be:	460c      	mov	r4, r1
	configASSERT(uxMaxCount != 0);
     5c0:	b940      	cbnz	r0, 5d4 <xQueueCreateCountingSemaphore+0x18>
     5c2:	f04f 0380 	mov.w	r3, #128	; 0x80
     5c6:	f383 8811 	msr	BASEPRI, r3
     5ca:	f3bf 8f6f 	isb	sy
     5ce:	f3bf 8f4f 	dsb	sy
     5d2:	e7fe      	b.n	5d2 <xQueueCreateCountingSemaphore+0x16>
	configASSERT(uxInitialCount <= uxMaxCount);
     5d4:	4288      	cmp	r0, r1
     5d6:	d208      	bcs.n	5ea <xQueueCreateCountingSemaphore+0x2e>
     5d8:	f04f 0380 	mov.w	r3, #128	; 0x80
     5dc:	f383 8811 	msr	BASEPRI, r3
     5e0:	f3bf 8f6f 	isb	sy
     5e4:	f3bf 8f4f 	dsb	sy
     5e8:	e7fe      	b.n	5e8 <xQueueCreateCountingSemaphore+0x2c>
	xHandle = xQueueGenericCreate(uxMaxCount, queueSEMAPHORE_QUEUE_ITEM_LENGTH, queueQUEUE_TYPE_COUNTING_SEMAPHORE);
     5ea:	4b08      	ldr	r3, [pc, #32]	; (60c <xQueueCreateCountingSemaphore+0x50>)
     5ec:	2202      	movs	r2, #2
     5ee:	2100      	movs	r1, #0
     5f0:	4798      	blx	r3
	if (xHandle != NULL) {
     5f2:	b108      	cbz	r0, 5f8 <xQueueCreateCountingSemaphore+0x3c>
		((Queue_t *)xHandle)->uxMessagesWaiting = uxInitialCount;
     5f4:	6384      	str	r4, [r0, #56]	; 0x38
}
     5f6:	bd10      	pop	{r4, pc}
     5f8:	f04f 0380 	mov.w	r3, #128	; 0x80
     5fc:	f383 8811 	msr	BASEPRI, r3
     600:	f3bf 8f6f 	isb	sy
     604:	f3bf 8f4f 	dsb	sy
	configASSERT(xHandle);
     608:	e7fe      	b.n	608 <xQueueCreateCountingSemaphore+0x4c>
     60a:	bf00      	nop
     60c:	0000054d 	.word	0x0000054d

00000610 <xQueueGenericSend>:
{
     610:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
     614:	b085      	sub	sp, #20
     616:	4689      	mov	r9, r1
     618:	9201      	str	r2, [sp, #4]
     61a:	461e      	mov	r6, r3
	configASSERT(pxQueue);
     61c:	4604      	mov	r4, r0
     61e:	b940      	cbnz	r0, 632 <xQueueGenericSend+0x22>
     620:	f04f 0380 	mov.w	r3, #128	; 0x80
     624:	f383 8811 	msr	BASEPRI, r3
     628:	f3bf 8f6f 	isb	sy
     62c:	f3bf 8f4f 	dsb	sy
     630:	e7fe      	b.n	630 <xQueueGenericSend+0x20>
	configASSERT(!((pvItemToQueue == NULL) && (pxQueue->uxItemSize != (UBaseType_t)0U)));
     632:	b951      	cbnz	r1, 64a <xQueueGenericSend+0x3a>
     634:	6c03      	ldr	r3, [r0, #64]	; 0x40
     636:	b143      	cbz	r3, 64a <xQueueGenericSend+0x3a>
     638:	f04f 0380 	mov.w	r3, #128	; 0x80
     63c:	f383 8811 	msr	BASEPRI, r3
     640:	f3bf 8f6f 	isb	sy
     644:	f3bf 8f4f 	dsb	sy
     648:	e7fe      	b.n	648 <xQueueGenericSend+0x38>
	configASSERT(!((xCopyPosition == queueOVERWRITE) && (pxQueue->uxLength != 1)));
     64a:	2e02      	cmp	r6, #2
     64c:	d10b      	bne.n	666 <xQueueGenericSend+0x56>
     64e:	6be3      	ldr	r3, [r4, #60]	; 0x3c
     650:	2b01      	cmp	r3, #1
     652:	d008      	beq.n	666 <xQueueGenericSend+0x56>
     654:	f04f 0380 	mov.w	r3, #128	; 0x80
     658:	f383 8811 	msr	BASEPRI, r3
     65c:	f3bf 8f6f 	isb	sy
     660:	f3bf 8f4f 	dsb	sy
     664:	e7fe      	b.n	664 <xQueueGenericSend+0x54>
		configASSERT(!((xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED) && (xTicksToWait != 0)));
     666:	4b46      	ldr	r3, [pc, #280]	; (780 <xQueueGenericSend+0x170>)
     668:	4798      	blx	r3
     66a:	4680      	mov	r8, r0
     66c:	b950      	cbnz	r0, 684 <xQueueGenericSend+0x74>
     66e:	9b01      	ldr	r3, [sp, #4]
     670:	b153      	cbz	r3, 688 <xQueueGenericSend+0x78>
     672:	f04f 0380 	mov.w	r3, #128	; 0x80
     676:	f383 8811 	msr	BASEPRI, r3
     67a:	f3bf 8f6f 	isb	sy
     67e:	f3bf 8f4f 	dsb	sy
     682:	e7fe      	b.n	682 <xQueueGenericSend+0x72>
     684:	f04f 0800 	mov.w	r8, #0
		taskENTER_CRITICAL();
     688:	f8df a11c 	ldr.w	sl, [pc, #284]	; 7a8 <xQueueGenericSend+0x198>
     68c:	4f3d      	ldr	r7, [pc, #244]	; (784 <xQueueGenericSend+0x174>)
     68e:	46d3      	mov	fp, sl
     690:	e041      	b.n	716 <xQueueGenericSend+0x106>
						if (listLIST_IS_EMPTY(&(pxQueue->xTasksWaitingToReceive)) == pdFALSE) {
     692:	6a63      	ldr	r3, [r4, #36]	; 0x24
     694:	b123      	cbz	r3, 6a0 <xQueueGenericSend+0x90>
							if (xTaskRemoveFromEventList(&(pxQueue->xTasksWaitingToReceive)) == pdTRUE) {
     696:	4b3c      	ldr	r3, [pc, #240]	; (788 <xQueueGenericSend+0x178>)
     698:	f104 0024 	add.w	r0, r4, #36	; 0x24
     69c:	4798      	blx	r3
     69e:	e04d      	b.n	73c <xQueueGenericSend+0x12c>
						} else if (xYieldRequired != pdFALSE) {
     6a0:	2800      	cmp	r0, #0
     6a2:	d14d      	bne.n	740 <xQueueGenericSend+0x130>
				taskEXIT_CRITICAL();
     6a4:	47b8      	blx	r7
				return pdPASS;
     6a6:	2001      	movs	r0, #1
}
     6a8:	b005      	add	sp, #20
     6aa:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
				if (xTicksToWait == (TickType_t)0) {
     6ae:	9d01      	ldr	r5, [sp, #4]
     6b0:	b915      	cbnz	r5, 6b8 <xQueueGenericSend+0xa8>
					taskEXIT_CRITICAL();
     6b2:	47b8      	blx	r7
			return errQUEUE_FULL;
     6b4:	2000      	movs	r0, #0
     6b6:	e7f7      	b.n	6a8 <xQueueGenericSend+0x98>
				} else if (xEntryTimeSet == pdFALSE) {
     6b8:	f1b8 0f00 	cmp.w	r8, #0
     6bc:	d102      	bne.n	6c4 <xQueueGenericSend+0xb4>
					vTaskSetTimeOutState(&xTimeOut);
     6be:	4b33      	ldr	r3, [pc, #204]	; (78c <xQueueGenericSend+0x17c>)
     6c0:	a802      	add	r0, sp, #8
     6c2:	4798      	blx	r3
		taskEXIT_CRITICAL();
     6c4:	47b8      	blx	r7
		vTaskSuspendAll();
     6c6:	4b32      	ldr	r3, [pc, #200]	; (790 <xQueueGenericSend+0x180>)
     6c8:	f8df 80e0 	ldr.w	r8, [pc, #224]	; 7ac <xQueueGenericSend+0x19c>
     6cc:	4d31      	ldr	r5, [pc, #196]	; (794 <xQueueGenericSend+0x184>)
     6ce:	4798      	blx	r3
		prvLockQueue(pxQueue);
     6d0:	47d8      	blx	fp
     6d2:	6c63      	ldr	r3, [r4, #68]	; 0x44
     6d4:	3301      	adds	r3, #1
     6d6:	bf04      	itt	eq
     6d8:	2300      	moveq	r3, #0
     6da:	6463      	streq	r3, [r4, #68]	; 0x44
     6dc:	6ca3      	ldr	r3, [r4, #72]	; 0x48
     6de:	3301      	adds	r3, #1
     6e0:	bf04      	itt	eq
     6e2:	2300      	moveq	r3, #0
     6e4:	64a3      	streq	r3, [r4, #72]	; 0x48
     6e6:	47b8      	blx	r7
		if (xTaskCheckForTimeOut(&xTimeOut, &xTicksToWait) == pdFALSE) {
     6e8:	4b2b      	ldr	r3, [pc, #172]	; (798 <xQueueGenericSend+0x188>)
     6ea:	a901      	add	r1, sp, #4
     6ec:	a802      	add	r0, sp, #8
     6ee:	4798      	blx	r3
     6f0:	2800      	cmp	r0, #0
     6f2:	d140      	bne.n	776 <xQueueGenericSend+0x166>
	taskENTER_CRITICAL();
     6f4:	47d8      	blx	fp
		if (pxQueue->uxMessagesWaiting == pxQueue->uxLength) {
     6f6:	6ba2      	ldr	r2, [r4, #56]	; 0x38
     6f8:	6be3      	ldr	r3, [r4, #60]	; 0x3c
     6fa:	429a      	cmp	r2, r3
     6fc:	d12b      	bne.n	756 <xQueueGenericSend+0x146>
	taskEXIT_CRITICAL();
     6fe:	47b8      	blx	r7
				vTaskPlaceOnEventList(&(pxQueue->xTasksWaitingToSend), xTicksToWait);
     700:	9901      	ldr	r1, [sp, #4]
     702:	4b26      	ldr	r3, [pc, #152]	; (79c <xQueueGenericSend+0x18c>)
     704:	f104 0010 	add.w	r0, r4, #16
     708:	4798      	blx	r3
				prvUnlockQueue(pxQueue);
     70a:	4620      	mov	r0, r4
     70c:	47c0      	blx	r8
				if (xTaskResumeAll() == pdFALSE) {
     70e:	47a8      	blx	r5
     710:	b330      	cbz	r0, 760 <xQueueGenericSend+0x150>
     712:	f04f 0801 	mov.w	r8, #1
		taskENTER_CRITICAL();
     716:	47d0      	blx	sl
			if ((pxQueue->uxMessagesWaiting < pxQueue->uxLength) || (xCopyPosition == queueOVERWRITE)) {
     718:	6ba2      	ldr	r2, [r4, #56]	; 0x38
     71a:	6be3      	ldr	r3, [r4, #60]	; 0x3c
     71c:	429a      	cmp	r2, r3
     71e:	d301      	bcc.n	724 <xQueueGenericSend+0x114>
     720:	2e02      	cmp	r6, #2
     722:	d1c4      	bne.n	6ae <xQueueGenericSend+0x9e>
				xYieldRequired = prvCopyDataToQueue(pxQueue, pvItemToQueue, xCopyPosition);
     724:	4b1e      	ldr	r3, [pc, #120]	; (7a0 <xQueueGenericSend+0x190>)
     726:	4632      	mov	r2, r6
     728:	4649      	mov	r1, r9
     72a:	4620      	mov	r0, r4
     72c:	4798      	blx	r3
					if (pxQueue->pxQueueSetContainer != NULL) {
     72e:	6d63      	ldr	r3, [r4, #84]	; 0x54
     730:	2b00      	cmp	r3, #0
     732:	d0ae      	beq.n	692 <xQueueGenericSend+0x82>
						if (prvNotifyQueueSetContainer(pxQueue, xCopyPosition) == pdTRUE) {
     734:	4b1b      	ldr	r3, [pc, #108]	; (7a4 <xQueueGenericSend+0x194>)
     736:	4631      	mov	r1, r6
     738:	4620      	mov	r0, r4
     73a:	4798      	blx	r3
							if (xTaskRemoveFromEventList(&(pxQueue->xTasksWaitingToReceive)) == pdTRUE) {
     73c:	2801      	cmp	r0, #1
     73e:	d1b1      	bne.n	6a4 <xQueueGenericSend+0x94>
							queueYIELD_IF_USING_PREEMPTION();
     740:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
     744:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
     748:	f8c3 2d04 	str.w	r2, [r3, #3332]	; 0xd04
     74c:	f3bf 8f4f 	dsb	sy
     750:	f3bf 8f6f 	isb	sy
     754:	e7a6      	b.n	6a4 <xQueueGenericSend+0x94>
	taskEXIT_CRITICAL();
     756:	47b8      	blx	r7
				prvUnlockQueue(pxQueue);
     758:	4620      	mov	r0, r4
     75a:	47c0      	blx	r8
				(void)xTaskResumeAll();
     75c:	47a8      	blx	r5
     75e:	e7d8      	b.n	712 <xQueueGenericSend+0x102>
					portYIELD_WITHIN_API();
     760:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
     764:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
     768:	f8c3 2d04 	str.w	r2, [r3, #3332]	; 0xd04
     76c:	f3bf 8f4f 	dsb	sy
     770:	f3bf 8f6f 	isb	sy
     774:	e7cd      	b.n	712 <xQueueGenericSend+0x102>
			prvUnlockQueue(pxQueue);
     776:	4620      	mov	r0, r4
     778:	47c0      	blx	r8
			(void)xTaskResumeAll();
     77a:	47a8      	blx	r5
     77c:	e79a      	b.n	6b4 <xQueueGenericSend+0xa4>
     77e:	bf00      	nop
     780:	000092d9 	.word	0x000092d9
     784:	00009d99 	.word	0x00009d99
     788:	000091a5 	.word	0x000091a5
     78c:	00009225 	.word	0x00009225
     790:	00008d89 	.word	0x00008d89
     794:	00008e9d 	.word	0x00008e9d
     798:	0000924d 	.word	0x0000924d
     79c:	000090ed 	.word	0x000090ed
     7a0:	00000309 	.word	0x00000309
     7a4:	00000381 	.word	0x00000381
     7a8:	00009d59 	.word	0x00009d59
     7ac:	00000429 	.word	0x00000429

000007b0 <xQueueGenericSendFromISR>:
{
     7b0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
     7b4:	460f      	mov	r7, r1
     7b6:	4616      	mov	r6, r2
     7b8:	461d      	mov	r5, r3
	configASSERT(pxQueue);
     7ba:	4604      	mov	r4, r0
     7bc:	b940      	cbnz	r0, 7d0 <xQueueGenericSendFromISR+0x20>
     7be:	f04f 0380 	mov.w	r3, #128	; 0x80
     7c2:	f383 8811 	msr	BASEPRI, r3
     7c6:	f3bf 8f6f 	isb	sy
     7ca:	f3bf 8f4f 	dsb	sy
     7ce:	e7fe      	b.n	7ce <xQueueGenericSendFromISR+0x1e>
	configASSERT(!((pvItemToQueue == NULL) && (pxQueue->uxItemSize != (UBaseType_t)0U)));
     7d0:	b951      	cbnz	r1, 7e8 <xQueueGenericSendFromISR+0x38>
     7d2:	6c03      	ldr	r3, [r0, #64]	; 0x40
     7d4:	b143      	cbz	r3, 7e8 <xQueueGenericSendFromISR+0x38>
     7d6:	f04f 0380 	mov.w	r3, #128	; 0x80
     7da:	f383 8811 	msr	BASEPRI, r3
     7de:	f3bf 8f6f 	isb	sy
     7e2:	f3bf 8f4f 	dsb	sy
     7e6:	e7fe      	b.n	7e6 <xQueueGenericSendFromISR+0x36>
	configASSERT(!((xCopyPosition == queueOVERWRITE) && (pxQueue->uxLength != 1)));
     7e8:	2d02      	cmp	r5, #2
     7ea:	d10b      	bne.n	804 <xQueueGenericSendFromISR+0x54>
     7ec:	6be3      	ldr	r3, [r4, #60]	; 0x3c
     7ee:	2b01      	cmp	r3, #1
     7f0:	d008      	beq.n	804 <xQueueGenericSendFromISR+0x54>
     7f2:	f04f 0380 	mov.w	r3, #128	; 0x80
     7f6:	f383 8811 	msr	BASEPRI, r3
     7fa:	f3bf 8f6f 	isb	sy
     7fe:	f3bf 8f4f 	dsb	sy
     802:	e7fe      	b.n	802 <xQueueGenericSendFromISR+0x52>
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
     804:	4b1d      	ldr	r3, [pc, #116]	; (87c <xQueueGenericSendFromISR+0xcc>)
     806:	4798      	blx	r3

portFORCE_INLINE static uint32_t ulPortRaiseBASEPRI(void)
{
	uint32_t ulOriginalBASEPRI, ulNewBASEPRI;

	__asm volatile("	mrs %0, basepri											\n"
     808:	f3ef 8811 	mrs	r8, BASEPRI
     80c:	f04f 0380 	mov.w	r3, #128	; 0x80
     810:	f383 8811 	msr	BASEPRI, r3
     814:	f3bf 8f6f 	isb	sy
     818:	f3bf 8f4f 	dsb	sy
		if ((pxQueue->uxMessagesWaiting < pxQueue->uxLength) || (xCopyPosition == queueOVERWRITE)) {
     81c:	6ba2      	ldr	r2, [r4, #56]	; 0x38
     81e:	6be3      	ldr	r3, [r4, #60]	; 0x3c
     820:	429a      	cmp	r2, r3
     822:	d301      	bcc.n	828 <xQueueGenericSendFromISR+0x78>
     824:	2d02      	cmp	r5, #2
     826:	d126      	bne.n	876 <xQueueGenericSendFromISR+0xc6>
			(void)prvCopyDataToQueue(pxQueue, pvItemToQueue, xCopyPosition);
     828:	4b15      	ldr	r3, [pc, #84]	; (880 <xQueueGenericSendFromISR+0xd0>)
     82a:	462a      	mov	r2, r5
     82c:	4639      	mov	r1, r7
     82e:	4620      	mov	r0, r4
     830:	4798      	blx	r3
			if (pxQueue->xTxLock == queueUNLOCKED) {
     832:	6ca3      	ldr	r3, [r4, #72]	; 0x48
     834:	3301      	adds	r3, #1
     836:	d11a      	bne.n	86e <xQueueGenericSendFromISR+0xbe>
					if (pxQueue->pxQueueSetContainer != NULL) {
     838:	6d63      	ldr	r3, [r4, #84]	; 0x54
     83a:	b13b      	cbz	r3, 84c <xQueueGenericSendFromISR+0x9c>
						if (prvNotifyQueueSetContainer(pxQueue, xCopyPosition) == pdTRUE) {
     83c:	4b11      	ldr	r3, [pc, #68]	; (884 <xQueueGenericSendFromISR+0xd4>)
     83e:	4629      	mov	r1, r5
     840:	4620      	mov	r0, r4
     842:	4798      	blx	r3
     844:	2801      	cmp	r0, #1
     846:	d00a      	beq.n	85e <xQueueGenericSendFromISR+0xae>
			xReturn = pdPASS;
     848:	2001      	movs	r0, #1
     84a:	e00c      	b.n	866 <xQueueGenericSendFromISR+0xb6>
						if (listLIST_IS_EMPTY(&(pxQueue->xTasksWaitingToReceive)) == pdFALSE) {
     84c:	6a63      	ldr	r3, [r4, #36]	; 0x24
     84e:	2b00      	cmp	r3, #0
     850:	d0fa      	beq.n	848 <xQueueGenericSendFromISR+0x98>
							if (xTaskRemoveFromEventList(&(pxQueue->xTasksWaitingToReceive)) != pdFALSE) {
     852:	4b0d      	ldr	r3, [pc, #52]	; (888 <xQueueGenericSendFromISR+0xd8>)
     854:	f104 0024 	add.w	r0, r4, #36	; 0x24
     858:	4798      	blx	r3
     85a:	2800      	cmp	r0, #0
     85c:	d0f4      	beq.n	848 <xQueueGenericSendFromISR+0x98>
							if (pxHigherPriorityTaskWoken != NULL) {
     85e:	2e00      	cmp	r6, #0
     860:	d0f2      	beq.n	848 <xQueueGenericSendFromISR+0x98>
								*pxHigherPriorityTaskWoken = pdTRUE;
     862:	2001      	movs	r0, #1
     864:	6030      	str	r0, [r6, #0]
}
/*-----------------------------------------------------------*/

portFORCE_INLINE static void vPortSetBASEPRI(uint32_t ulNewMaskValue)
{
	__asm volatile("	msr basepri, %0	" ::"r"(ulNewMaskValue));
     866:	f388 8811 	msr	BASEPRI, r8
}
     86a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
				++(pxQueue->xTxLock);
     86e:	6ca3      	ldr	r3, [r4, #72]	; 0x48
     870:	3301      	adds	r3, #1
     872:	64a3      	str	r3, [r4, #72]	; 0x48
     874:	e7e8      	b.n	848 <xQueueGenericSendFromISR+0x98>
			xReturn = errQUEUE_FULL;
     876:	2000      	movs	r0, #0
     878:	e7f5      	b.n	866 <xQueueGenericSendFromISR+0xb6>
     87a:	bf00      	nop
     87c:	00009f61 	.word	0x00009f61
     880:	00000309 	.word	0x00000309
     884:	00000381 	.word	0x00000381
     888:	000091a5 	.word	0x000091a5

0000088c <xQueueGiveFromISR>:
{
     88c:	b570      	push	{r4, r5, r6, lr}
     88e:	460d      	mov	r5, r1
	configASSERT(pxQueue);
     890:	4604      	mov	r4, r0
     892:	b940      	cbnz	r0, 8a6 <xQueueGiveFromISR+0x1a>
	__asm volatile("	mov %0, %1												\n"
     894:	f04f 0380 	mov.w	r3, #128	; 0x80
     898:	f383 8811 	msr	BASEPRI, r3
     89c:	f3bf 8f6f 	isb	sy
     8a0:	f3bf 8f4f 	dsb	sy
     8a4:	e7fe      	b.n	8a4 <xQueueGiveFromISR+0x18>
	configASSERT(pxQueue->uxItemSize == 0);
     8a6:	6c03      	ldr	r3, [r0, #64]	; 0x40
     8a8:	b143      	cbz	r3, 8bc <xQueueGiveFromISR+0x30>
     8aa:	f04f 0380 	mov.w	r3, #128	; 0x80
     8ae:	f383 8811 	msr	BASEPRI, r3
     8b2:	f3bf 8f6f 	isb	sy
     8b6:	f3bf 8f4f 	dsb	sy
     8ba:	e7fe      	b.n	8ba <xQueueGiveFromISR+0x2e>
	configASSERT(!((pxQueue->uxQueueType == queueQUEUE_IS_MUTEX) && (pxQueue->pxMutexHolder != NULL)));
     8bc:	6803      	ldr	r3, [r0, #0]
     8be:	b953      	cbnz	r3, 8d6 <xQueueGiveFromISR+0x4a>
     8c0:	6843      	ldr	r3, [r0, #4]
     8c2:	b143      	cbz	r3, 8d6 <xQueueGiveFromISR+0x4a>
     8c4:	f04f 0380 	mov.w	r3, #128	; 0x80
     8c8:	f383 8811 	msr	BASEPRI, r3
     8cc:	f3bf 8f6f 	isb	sy
     8d0:	f3bf 8f4f 	dsb	sy
     8d4:	e7fe      	b.n	8d4 <xQueueGiveFromISR+0x48>
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
     8d6:	4b1b      	ldr	r3, [pc, #108]	; (944 <xQueueGiveFromISR+0xb8>)
     8d8:	4798      	blx	r3
	__asm volatile("	mrs %0, basepri											\n"
     8da:	f3ef 8611 	mrs	r6, BASEPRI
     8de:	f04f 0380 	mov.w	r3, #128	; 0x80
     8e2:	f383 8811 	msr	BASEPRI, r3
     8e6:	f3bf 8f6f 	isb	sy
     8ea:	f3bf 8f4f 	dsb	sy
		if (pxQueue->uxMessagesWaiting < pxQueue->uxLength) {
     8ee:	6ba2      	ldr	r2, [r4, #56]	; 0x38
     8f0:	6be3      	ldr	r3, [r4, #60]	; 0x3c
     8f2:	429a      	cmp	r2, r3
     8f4:	d223      	bcs.n	93e <xQueueGiveFromISR+0xb2>
			++(pxQueue->uxMessagesWaiting);
     8f6:	6ba3      	ldr	r3, [r4, #56]	; 0x38
     8f8:	3301      	adds	r3, #1
     8fa:	63a3      	str	r3, [r4, #56]	; 0x38
			if (pxQueue->xTxLock == queueUNLOCKED) {
     8fc:	6ca3      	ldr	r3, [r4, #72]	; 0x48
     8fe:	3301      	adds	r3, #1
     900:	d119      	bne.n	936 <xQueueGiveFromISR+0xaa>
					if (pxQueue->pxQueueSetContainer != NULL) {
     902:	6d63      	ldr	r3, [r4, #84]	; 0x54
     904:	b13b      	cbz	r3, 916 <xQueueGiveFromISR+0x8a>
						if (prvNotifyQueueSetContainer(pxQueue, queueSEND_TO_BACK) == pdTRUE) {
     906:	4b10      	ldr	r3, [pc, #64]	; (948 <xQueueGiveFromISR+0xbc>)
     908:	2100      	movs	r1, #0
     90a:	4620      	mov	r0, r4
     90c:	4798      	blx	r3
     90e:	2801      	cmp	r0, #1
     910:	d00a      	beq.n	928 <xQueueGiveFromISR+0x9c>
			xReturn = pdPASS;
     912:	2001      	movs	r0, #1
     914:	e00c      	b.n	930 <xQueueGiveFromISR+0xa4>
						if (listLIST_IS_EMPTY(&(pxQueue->xTasksWaitingToReceive)) == pdFALSE) {
     916:	6a63      	ldr	r3, [r4, #36]	; 0x24
     918:	2b00      	cmp	r3, #0
     91a:	d0fa      	beq.n	912 <xQueueGiveFromISR+0x86>
							if (xTaskRemoveFromEventList(&(pxQueue->xTasksWaitingToReceive)) != pdFALSE) {
     91c:	4b0b      	ldr	r3, [pc, #44]	; (94c <xQueueGiveFromISR+0xc0>)
     91e:	f104 0024 	add.w	r0, r4, #36	; 0x24
     922:	4798      	blx	r3
     924:	2800      	cmp	r0, #0
     926:	d0f4      	beq.n	912 <xQueueGiveFromISR+0x86>
							if (pxHigherPriorityTaskWoken != NULL) {
     928:	2d00      	cmp	r5, #0
     92a:	d0f2      	beq.n	912 <xQueueGiveFromISR+0x86>
								*pxHigherPriorityTaskWoken = pdTRUE;
     92c:	2001      	movs	r0, #1
     92e:	6028      	str	r0, [r5, #0]
	__asm volatile("	msr basepri, %0	" ::"r"(ulNewMaskValue));
     930:	f386 8811 	msr	BASEPRI, r6
}
     934:	bd70      	pop	{r4, r5, r6, pc}
				++(pxQueue->xTxLock);
     936:	6ca3      	ldr	r3, [r4, #72]	; 0x48
     938:	3301      	adds	r3, #1
     93a:	64a3      	str	r3, [r4, #72]	; 0x48
     93c:	e7e9      	b.n	912 <xQueueGiveFromISR+0x86>
			xReturn = errQUEUE_FULL;
     93e:	2000      	movs	r0, #0
     940:	e7f6      	b.n	930 <xQueueGiveFromISR+0xa4>
     942:	bf00      	nop
     944:	00009f61 	.word	0x00009f61
     948:	00000381 	.word	0x00000381
     94c:	000091a5 	.word	0x000091a5

00000950 <xQueueGenericReceive>:
{
     950:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
     954:	b085      	sub	sp, #20
     956:	4688      	mov	r8, r1
     958:	9201      	str	r2, [sp, #4]
     95a:	4699      	mov	r9, r3
	configASSERT(pxQueue);
     95c:	4604      	mov	r4, r0
     95e:	b940      	cbnz	r0, 972 <xQueueGenericReceive+0x22>
	__asm volatile("	mov %0, %1												\n"
     960:	f04f 0380 	mov.w	r3, #128	; 0x80
     964:	f383 8811 	msr	BASEPRI, r3
     968:	f3bf 8f6f 	isb	sy
     96c:	f3bf 8f4f 	dsb	sy
     970:	e7fe      	b.n	970 <xQueueGenericReceive+0x20>
	configASSERT(!((pvBuffer == NULL) && (pxQueue->uxItemSize != (UBaseType_t)0U)));
     972:	b951      	cbnz	r1, 98a <xQueueGenericReceive+0x3a>
     974:	6c03      	ldr	r3, [r0, #64]	; 0x40
     976:	b143      	cbz	r3, 98a <xQueueGenericReceive+0x3a>
     978:	f04f 0380 	mov.w	r3, #128	; 0x80
     97c:	f383 8811 	msr	BASEPRI, r3
     980:	f3bf 8f6f 	isb	sy
     984:	f3bf 8f4f 	dsb	sy
     988:	e7fe      	b.n	988 <xQueueGenericReceive+0x38>
		configASSERT(!((xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED) && (xTicksToWait != 0)));
     98a:	4b49      	ldr	r3, [pc, #292]	; (ab0 <xQueueGenericReceive+0x160>)
     98c:	4798      	blx	r3
     98e:	4607      	mov	r7, r0
     990:	b950      	cbnz	r0, 9a8 <xQueueGenericReceive+0x58>
     992:	9b01      	ldr	r3, [sp, #4]
     994:	b14b      	cbz	r3, 9aa <xQueueGenericReceive+0x5a>
     996:	f04f 0380 	mov.w	r3, #128	; 0x80
     99a:	f383 8811 	msr	BASEPRI, r3
     99e:	f3bf 8f6f 	isb	sy
     9a2:	f3bf 8f4f 	dsb	sy
     9a6:	e7fe      	b.n	9a6 <xQueueGenericReceive+0x56>
     9a8:	2700      	movs	r7, #0
		taskENTER_CRITICAL();
     9aa:	f8df b134 	ldr.w	fp, [pc, #308]	; ae0 <xQueueGenericReceive+0x190>
     9ae:	4d41      	ldr	r5, [pc, #260]	; (ab4 <xQueueGenericReceive+0x164>)
     9b0:	46da      	mov	sl, fp
     9b2:	e051      	b.n	a58 <xQueueGenericReceive+0x108>
					if (listLIST_IS_EMPTY(&(pxQueue->xTasksWaitingToReceive)) == pdFALSE) {
     9b4:	6a63      	ldr	r3, [r4, #36]	; 0x24
					pxQueue->u.pcReadFrom = pcOriginalReadPosition;
     9b6:	60e6      	str	r6, [r4, #12]
					if (listLIST_IS_EMPTY(&(pxQueue->xTasksWaitingToReceive)) == pdFALSE) {
     9b8:	b12b      	cbz	r3, 9c6 <xQueueGenericReceive+0x76>
						if (xTaskRemoveFromEventList(&(pxQueue->xTasksWaitingToReceive)) != pdFALSE) {
     9ba:	4b3f      	ldr	r3, [pc, #252]	; (ab8 <xQueueGenericReceive+0x168>)
     9bc:	f104 0024 	add.w	r0, r4, #36	; 0x24
     9c0:	4798      	blx	r3
     9c2:	2800      	cmp	r0, #0
     9c4:	d165      	bne.n	a92 <xQueueGenericReceive+0x142>
				taskEXIT_CRITICAL();
     9c6:	47a8      	blx	r5
				return pdPASS;
     9c8:	2001      	movs	r0, #1
}
     9ca:	b005      	add	sp, #20
     9cc:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
				if (xTicksToWait == (TickType_t)0) {
     9d0:	9e01      	ldr	r6, [sp, #4]
     9d2:	b916      	cbnz	r6, 9da <xQueueGenericReceive+0x8a>
					taskEXIT_CRITICAL();
     9d4:	47a8      	blx	r5
			return errQUEUE_EMPTY;
     9d6:	2000      	movs	r0, #0
     9d8:	e7f7      	b.n	9ca <xQueueGenericReceive+0x7a>
				} else if (xEntryTimeSet == pdFALSE) {
     9da:	b917      	cbnz	r7, 9e2 <xQueueGenericReceive+0x92>
					vTaskSetTimeOutState(&xTimeOut);
     9dc:	4b37      	ldr	r3, [pc, #220]	; (abc <xQueueGenericReceive+0x16c>)
     9de:	a802      	add	r0, sp, #8
     9e0:	4798      	blx	r3
		taskEXIT_CRITICAL();
     9e2:	47a8      	blx	r5
		vTaskSuspendAll();
     9e4:	4b36      	ldr	r3, [pc, #216]	; (ac0 <xQueueGenericReceive+0x170>)
     9e6:	4f37      	ldr	r7, [pc, #220]	; (ac4 <xQueueGenericReceive+0x174>)
     9e8:	4e37      	ldr	r6, [pc, #220]	; (ac8 <xQueueGenericReceive+0x178>)
     9ea:	4798      	blx	r3
		prvLockQueue(pxQueue);
     9ec:	47d0      	blx	sl
     9ee:	6c63      	ldr	r3, [r4, #68]	; 0x44
     9f0:	3301      	adds	r3, #1
     9f2:	bf04      	itt	eq
     9f4:	2300      	moveq	r3, #0
     9f6:	6463      	streq	r3, [r4, #68]	; 0x44
     9f8:	6ca3      	ldr	r3, [r4, #72]	; 0x48
     9fa:	3301      	adds	r3, #1
     9fc:	bf04      	itt	eq
     9fe:	2300      	moveq	r3, #0
     a00:	64a3      	streq	r3, [r4, #72]	; 0x48
     a02:	47a8      	blx	r5
		if (xTaskCheckForTimeOut(&xTimeOut, &xTicksToWait) == pdFALSE) {
     a04:	4b31      	ldr	r3, [pc, #196]	; (acc <xQueueGenericReceive+0x17c>)
     a06:	a901      	add	r1, sp, #4
     a08:	a802      	add	r0, sp, #8
     a0a:	4798      	blx	r3
     a0c:	2800      	cmp	r0, #0
     a0e:	d14b      	bne.n	aa8 <xQueueGenericReceive+0x158>
	taskENTER_CRITICAL();
     a10:	47d0      	blx	sl
		if (pxQueue->uxMessagesWaiting == (UBaseType_t)0) {
     a12:	6ba3      	ldr	r3, [r4, #56]	; 0x38
     a14:	b9db      	cbnz	r3, a4e <xQueueGenericReceive+0xfe>
	taskEXIT_CRITICAL();
     a16:	47a8      	blx	r5
					if (pxQueue->uxQueueType == queueQUEUE_IS_MUTEX) {
     a18:	6823      	ldr	r3, [r4, #0]
     a1a:	b923      	cbnz	r3, a26 <xQueueGenericReceive+0xd6>
						taskENTER_CRITICAL();
     a1c:	47d0      	blx	sl
							vTaskPriorityInherit((void *)pxQueue->pxMutexHolder);
     a1e:	6860      	ldr	r0, [r4, #4]
     a20:	4b2b      	ldr	r3, [pc, #172]	; (ad0 <xQueueGenericReceive+0x180>)
     a22:	4798      	blx	r3
						taskEXIT_CRITICAL();
     a24:	47a8      	blx	r5
				vTaskPlaceOnEventList(&(pxQueue->xTasksWaitingToReceive), xTicksToWait);
     a26:	9901      	ldr	r1, [sp, #4]
     a28:	4b2a      	ldr	r3, [pc, #168]	; (ad4 <xQueueGenericReceive+0x184>)
     a2a:	f104 0024 	add.w	r0, r4, #36	; 0x24
     a2e:	4798      	blx	r3
				prvUnlockQueue(pxQueue);
     a30:	4620      	mov	r0, r4
     a32:	47b8      	blx	r7
				if (xTaskResumeAll() == pdFALSE) {
     a34:	47b0      	blx	r6
     a36:	b970      	cbnz	r0, a56 <xQueueGenericReceive+0x106>
					portYIELD_WITHIN_API();
     a38:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
     a3c:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
     a40:	f8c3 2d04 	str.w	r2, [r3, #3332]	; 0xd04
     a44:	f3bf 8f4f 	dsb	sy
     a48:	f3bf 8f6f 	isb	sy
     a4c:	e003      	b.n	a56 <xQueueGenericReceive+0x106>
	taskEXIT_CRITICAL();
     a4e:	47a8      	blx	r5
				prvUnlockQueue(pxQueue);
     a50:	4620      	mov	r0, r4
     a52:	47b8      	blx	r7
				(void)xTaskResumeAll();
     a54:	47b0      	blx	r6
     a56:	2701      	movs	r7, #1
		taskENTER_CRITICAL();
     a58:	47d8      	blx	fp
			if (pxQueue->uxMessagesWaiting > (UBaseType_t)0) {
     a5a:	6ba3      	ldr	r3, [r4, #56]	; 0x38
     a5c:	2b00      	cmp	r3, #0
     a5e:	d0b7      	beq.n	9d0 <xQueueGenericReceive+0x80>
				prvCopyDataFromQueue(pxQueue, pvBuffer);
     a60:	4b1d      	ldr	r3, [pc, #116]	; (ad8 <xQueueGenericReceive+0x188>)
				pcOriginalReadPosition = pxQueue->u.pcReadFrom;
     a62:	68e6      	ldr	r6, [r4, #12]
				prvCopyDataFromQueue(pxQueue, pvBuffer);
     a64:	4641      	mov	r1, r8
     a66:	4620      	mov	r0, r4
     a68:	4798      	blx	r3
				if (xJustPeeking == pdFALSE) {
     a6a:	f1b9 0f00 	cmp.w	r9, #0
     a6e:	d1a1      	bne.n	9b4 <xQueueGenericReceive+0x64>
					--(pxQueue->uxMessagesWaiting);
     a70:	6ba3      	ldr	r3, [r4, #56]	; 0x38
     a72:	3b01      	subs	r3, #1
     a74:	63a3      	str	r3, [r4, #56]	; 0x38
						if (pxQueue->uxQueueType == queueQUEUE_IS_MUTEX) {
     a76:	6823      	ldr	r3, [r4, #0]
     a78:	b913      	cbnz	r3, a80 <xQueueGenericReceive+0x130>
							    = (int8_t *)pvTaskIncrementMutexHeldCount(); /*lint !e961 Cast is not redundant as
     a7a:	4b18      	ldr	r3, [pc, #96]	; (adc <xQueueGenericReceive+0x18c>)
     a7c:	4798      	blx	r3
     a7e:	6060      	str	r0, [r4, #4]
					if (listLIST_IS_EMPTY(&(pxQueue->xTasksWaitingToSend)) == pdFALSE) {
     a80:	6923      	ldr	r3, [r4, #16]
     a82:	2b00      	cmp	r3, #0
     a84:	d09f      	beq.n	9c6 <xQueueGenericReceive+0x76>
						if (xTaskRemoveFromEventList(&(pxQueue->xTasksWaitingToSend)) == pdTRUE) {
     a86:	4b0c      	ldr	r3, [pc, #48]	; (ab8 <xQueueGenericReceive+0x168>)
     a88:	f104 0010 	add.w	r0, r4, #16
     a8c:	4798      	blx	r3
     a8e:	2801      	cmp	r0, #1
     a90:	d199      	bne.n	9c6 <xQueueGenericReceive+0x76>
							queueYIELD_IF_USING_PREEMPTION();
     a92:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
     a96:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
     a9a:	f8c3 2d04 	str.w	r2, [r3, #3332]	; 0xd04
     a9e:	f3bf 8f4f 	dsb	sy
     aa2:	f3bf 8f6f 	isb	sy
     aa6:	e78e      	b.n	9c6 <xQueueGenericReceive+0x76>
			prvUnlockQueue(pxQueue);
     aa8:	4620      	mov	r0, r4
     aaa:	47b8      	blx	r7
			(void)xTaskResumeAll();
     aac:	47b0      	blx	r6
     aae:	e792      	b.n	9d6 <xQueueGenericReceive+0x86>
     ab0:	000092d9 	.word	0x000092d9
     ab4:	00009d99 	.word	0x00009d99
     ab8:	000091a5 	.word	0x000091a5
     abc:	00009225 	.word	0x00009225
     ac0:	00008d89 	.word	0x00008d89
     ac4:	00000429 	.word	0x00000429
     ac8:	00008e9d 	.word	0x00008e9d
     acc:	0000924d 	.word	0x0000924d
     ad0:	000092f9 	.word	0x000092f9
     ad4:	000090ed 	.word	0x000090ed
     ad8:	000003f9 	.word	0x000003f9
     adc:	00009401 	.word	0x00009401
     ae0:	00009d59 	.word	0x00009d59

00000ae4 <vQueueDelete>:
	configASSERT(pxQueue);
     ae4:	b940      	cbnz	r0, af8 <vQueueDelete+0x14>
     ae6:	f04f 0380 	mov.w	r3, #128	; 0x80
     aea:	f383 8811 	msr	BASEPRI, r3
     aee:	f3bf 8f6f 	isb	sy
     af2:	f3bf 8f4f 	dsb	sy
     af6:	e7fe      	b.n	af6 <vQueueDelete+0x12>
	vPortFree(pxQueue);
     af8:	4b00      	ldr	r3, [pc, #0]	; (afc <vQueueDelete+0x18>)
     afa:	4718      	bx	r3
     afc:	00001db1 	.word	0x00001db1

00000b00 <vQueueWaitForMessageRestricted>:
{
     b00:	b570      	push	{r4, r5, r6, lr}
     b02:	4604      	mov	r4, r0
	prvLockQueue(pxQueue);
     b04:	4b0e      	ldr	r3, [pc, #56]	; (b40 <vQueueWaitForMessageRestricted+0x40>)
{
     b06:	460d      	mov	r5, r1
     b08:	4616      	mov	r6, r2
	prvLockQueue(pxQueue);
     b0a:	4798      	blx	r3
     b0c:	6c63      	ldr	r3, [r4, #68]	; 0x44
     b0e:	3301      	adds	r3, #1
     b10:	bf04      	itt	eq
     b12:	2300      	moveq	r3, #0
     b14:	6463      	streq	r3, [r4, #68]	; 0x44
     b16:	6ca3      	ldr	r3, [r4, #72]	; 0x48
     b18:	3301      	adds	r3, #1
     b1a:	bf04      	itt	eq
     b1c:	2300      	moveq	r3, #0
     b1e:	64a3      	streq	r3, [r4, #72]	; 0x48
     b20:	4b08      	ldr	r3, [pc, #32]	; (b44 <vQueueWaitForMessageRestricted+0x44>)
     b22:	4798      	blx	r3
	if (pxQueue->uxMessagesWaiting == (UBaseType_t)0U) {
     b24:	6ba3      	ldr	r3, [r4, #56]	; 0x38
     b26:	b92b      	cbnz	r3, b34 <vQueueWaitForMessageRestricted+0x34>
		vTaskPlaceOnEventListRestricted(&(pxQueue->xTasksWaitingToReceive), xTicksToWait, xWaitIndefinitely);
     b28:	4b07      	ldr	r3, [pc, #28]	; (b48 <vQueueWaitForMessageRestricted+0x48>)
     b2a:	4632      	mov	r2, r6
     b2c:	4629      	mov	r1, r5
     b2e:	f104 0024 	add.w	r0, r4, #36	; 0x24
     b32:	4798      	blx	r3
	prvUnlockQueue(pxQueue);
     b34:	4620      	mov	r0, r4
     b36:	4b05      	ldr	r3, [pc, #20]	; (b4c <vQueueWaitForMessageRestricted+0x4c>)
}
     b38:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	prvUnlockQueue(pxQueue);
     b3c:	4718      	bx	r3
     b3e:	bf00      	nop
     b40:	00009d59 	.word	0x00009d59
     b44:	00009d99 	.word	0x00009d99
     b48:	00009149 	.word	0x00009149
     b4c:	00000429 	.word	0x00000429

00000b50 <_sbrk>:
extern caddr_t _sbrk(int incr)
{
	static unsigned char *heap = NULL;
	unsigned char *       prev_heap;

	if (heap == NULL) {
     b50:	4a04      	ldr	r2, [pc, #16]	; (b64 <_sbrk+0x14>)
     b52:	6811      	ldr	r1, [r2, #0]
{
     b54:	4603      	mov	r3, r0
	if (heap == NULL) {
     b56:	b909      	cbnz	r1, b5c <_sbrk+0xc>
		heap = (unsigned char *)&_end;
     b58:	4903      	ldr	r1, [pc, #12]	; (b68 <_sbrk+0x18>)
     b5a:	6011      	str	r1, [r2, #0]
	}
	prev_heap = heap;
     b5c:	6810      	ldr	r0, [r2, #0]

	heap += incr;
     b5e:	4403      	add	r3, r0
     b60:	6013      	str	r3, [r2, #0]

	return (caddr_t)prev_heap;
}
     b62:	4770      	bx	lr
     b64:	200000a0 	.word	0x200000a0
     b68:	200268c8 	.word	0x200268c8

00000b6c <_close>:
 */
extern int _close(int file)
{
	(void)file;
	return -1;
}
     b6c:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
     b70:	4770      	bx	lr

00000b72 <_fstat>:
 * \brief Replacement of C library of _fstat
 */
extern int _fstat(int file, struct stat *st)
{
	(void)file;
	st->st_mode = S_IFCHR;
     b72:	f44f 5300 	mov.w	r3, #8192	; 0x2000
     b76:	604b      	str	r3, [r1, #4]

	return 0;
}
     b78:	2000      	movs	r0, #0
     b7a:	4770      	bx	lr

00000b7c <_lseek>:
 */
extern int _lseek(int file, int ptr, int dir)
{
	(void)file, (void)ptr, (void)dir;
	return 0;
}
     b7c:	2000      	movs	r0, #0
     b7e:	4770      	bx	lr

00000b80 <icmp_send_response>:
 *          p->payload pointing to the IP header
 * @param type Type of the ICMP header
 * @param code Code of the ICMP header
 */
static void icmp_send_response(struct pbuf *p, u8_t type, u8_t code)
{
     b80:	e92d 41ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, lr}
	/* we can use the echo header here */
	struct icmp_echo_hdr *icmphdr;
	ip_addr_t             iphdr_src;

	/* ICMP header + IP header + 8 bytes of data */
	q = pbuf_alloc(PBUF_IP, sizeof(struct icmp_echo_hdr) + IP_HLEN + ICMP_DEST_UNREACH_DATASIZE, PBUF_RAM);
     b84:	4b1b      	ldr	r3, [pc, #108]	; (bf4 <icmp_send_response+0x74>)
{
     b86:	4604      	mov	r4, r0
     b88:	4688      	mov	r8, r1
     b8a:	4616      	mov	r6, r2
	q = pbuf_alloc(PBUF_IP, sizeof(struct icmp_echo_hdr) + IP_HLEN + ICMP_DEST_UNREACH_DATASIZE, PBUF_RAM);
     b8c:	2124      	movs	r1, #36	; 0x24
     b8e:	2200      	movs	r2, #0
     b90:	2001      	movs	r0, #1
     b92:	4798      	blx	r3
	if (q == NULL) {
     b94:	4605      	mov	r5, r0
     b96:	b350      	cbz	r0, bee <icmp_send_response+0x6e>
		return;
	}
	LWIP_ASSERT("check that first pbuf can hold icmp message",
	            (q->len >= (sizeof(struct icmp_echo_hdr) + IP_HLEN + ICMP_DEST_UNREACH_DATASIZE)));

	iphdr = (struct ip_hdr *)p->payload;
     b98:	6867      	ldr	r7, [r4, #4]
	ip_addr_debug_print(ICMP_DEBUG, &(iphdr->src));
	LWIP_DEBUGF(ICMP_DEBUG, (" to "));
	ip_addr_debug_print(ICMP_DEBUG, &(iphdr->dest));
	LWIP_DEBUGF(ICMP_DEBUG, ("\n"));

	icmphdr        = (struct icmp_echo_hdr *)q->payload;
     b9a:	6844      	ldr	r4, [r0, #4]
	icmphdr->type  = type;
	icmphdr->code  = code;
	icmphdr->id    = 0;
     b9c:	2300      	movs	r3, #0
     b9e:	7123      	strb	r3, [r4, #4]
     ba0:	7163      	strb	r3, [r4, #5]
	icmphdr->seqno = 0;
     ba2:	71a3      	strb	r3, [r4, #6]
     ba4:	71e3      	strb	r3, [r4, #7]
	icmphdr->type  = type;
     ba6:	f884 8000 	strb.w	r8, [r4]
	icmphdr->code  = code;
     baa:	7066      	strb	r6, [r4, #1]

	/* copy fields from original packet */
	SMEMCPY(
     bac:	463b      	mov	r3, r7
     bae:	f104 0208 	add.w	r2, r4, #8
     bb2:	f107 011c 	add.w	r1, r7, #28
     bb6:	f853 0b04 	ldr.w	r0, [r3], #4
     bba:	f842 0b04 	str.w	r0, [r2], #4
     bbe:	428b      	cmp	r3, r1
     bc0:	d1f9      	bne.n	bb6 <icmp_send_response+0x36>
	    (u8_t *)q->payload + sizeof(struct icmp_echo_hdr), (u8_t *)p->payload, IP_HLEN + ICMP_DEST_UNREACH_DATASIZE);

	/* calculate checksum */
	icmphdr->chksum = 0;
     bc2:	2600      	movs	r6, #0
	icmphdr->chksum = inet_chksum(icmphdr, q->len);
     bc4:	8969      	ldrh	r1, [r5, #10]
     bc6:	4b0c      	ldr	r3, [pc, #48]	; (bf8 <icmp_send_response+0x78>)
	icmphdr->chksum = 0;
     bc8:	70a6      	strb	r6, [r4, #2]
     bca:	70e6      	strb	r6, [r4, #3]
	icmphdr->chksum = inet_chksum(icmphdr, q->len);
     bcc:	4620      	mov	r0, r4
     bce:	4798      	blx	r3
     bd0:	8060      	strh	r0, [r4, #2]
	ICMP_STATS_INC(icmp.xmit);
	/* increase number of messages attempted to send */
	snmp_inc_icmpoutmsgs();
	/* increase number of destination unreachable messages attempted to send */
	snmp_inc_icmpouttimeexcds();
	ip_addr_copy(iphdr_src, iphdr->src);
     bd2:	68fb      	ldr	r3, [r7, #12]
     bd4:	9303      	str	r3, [sp, #12]
	ip_output(q, NULL, &iphdr_src, ICMP_TTL, 0, IP_PROTO_ICMP);
     bd6:	2301      	movs	r3, #1
     bd8:	e9cd 6300 	strd	r6, r3, [sp]
     bdc:	4c07      	ldr	r4, [pc, #28]	; (bfc <icmp_send_response+0x7c>)
     bde:	23ff      	movs	r3, #255	; 0xff
     be0:	aa03      	add	r2, sp, #12
     be2:	4631      	mov	r1, r6
     be4:	4628      	mov	r0, r5
     be6:	47a0      	blx	r4
	pbuf_free(q);
     be8:	4b05      	ldr	r3, [pc, #20]	; (c00 <icmp_send_response+0x80>)
     bea:	4628      	mov	r0, r5
     bec:	4798      	blx	r3
}
     bee:	b004      	add	sp, #16
     bf0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
     bf4:	00003139 	.word	0x00003139
     bf8:	00008419 	.word	0x00008419
     bfc:	000065fd 	.word	0x000065fd
     c00:	000030e1 	.word	0x000030e1

00000c04 <icmp_input>:
{
     c04:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	iphdr = (struct ip_hdr *)p->payload;
     c08:	6846      	ldr	r6, [r0, #4]
	if (pbuf_header(p, -hlen) || (p->tot_len < sizeof(u16_t) * 2)) {
     c0a:	4f45      	ldr	r7, [pc, #276]	; (d20 <icmp_input+0x11c>)
	hlen  = IPH_HL(iphdr) * 4;
     c0c:	7835      	ldrb	r5, [r6, #0]
     c0e:	f8df 8134 	ldr.w	r8, [pc, #308]	; d44 <icmp_input+0x140>
     c12:	f005 050f 	and.w	r5, r5, #15
     c16:	00ad      	lsls	r5, r5, #2
{
     c18:	b087      	sub	sp, #28
	if (pbuf_header(p, -hlen) || (p->tot_len < sizeof(u16_t) * 2)) {
     c1a:	f1c5 0a00 	rsb	sl, r5, #0
     c1e:	fa0f fa8a 	sxth.w	sl, sl
{
     c22:	9105      	str	r1, [sp, #20]
	if (pbuf_header(p, -hlen) || (p->tot_len < sizeof(u16_t) * 2)) {
     c24:	4651      	mov	r1, sl
{
     c26:	4604      	mov	r4, r0
	if (pbuf_header(p, -hlen) || (p->tot_len < sizeof(u16_t) * 2)) {
     c28:	47b8      	blx	r7
     c2a:	b998      	cbnz	r0, c54 <icmp_input+0x50>
     c2c:	8923      	ldrh	r3, [r4, #8]
     c2e:	2b03      	cmp	r3, #3
     c30:	d910      	bls.n	c54 <icmp_input+0x50>
	type = *((u8_t *)p->payload);
     c32:	6863      	ldr	r3, [r4, #4]
	switch (type) {
     c34:	781b      	ldrb	r3, [r3, #0]
     c36:	2b08      	cmp	r3, #8
     c38:	d10c      	bne.n	c54 <icmp_input+0x50>
		if (ip_addr_ismulticast(&current_iphdr_dest)) {
     c3a:	f8df b100 	ldr.w	fp, [pc, #256]	; d3c <icmp_input+0x138>
		if (ip_addr_isbroadcast(&current_iphdr_dest, inp)) {
     c3e:	9905      	ldr	r1, [sp, #20]
		if (ip_addr_ismulticast(&current_iphdr_dest)) {
     c40:	f8db 0000 	ldr.w	r0, [fp]
		if (ip_addr_isbroadcast(&current_iphdr_dest, inp)) {
     c44:	4a37      	ldr	r2, [pc, #220]	; (d24 <icmp_input+0x120>)
		if (ip_addr_ismulticast(&current_iphdr_dest)) {
     c46:	f000 09f0 	and.w	r9, r0, #240	; 0xf0
		if (ip_addr_isbroadcast(&current_iphdr_dest, inp)) {
     c4a:	4790      	blx	r2
     c4c:	b910      	cbnz	r0, c54 <icmp_input+0x50>
		if (!accepted) {
     c4e:	f1b9 0fe0 	cmp.w	r9, #224	; 0xe0
     c52:	d105      	bne.n	c60 <icmp_input+0x5c>
	pbuf_free(p);
     c54:	4620      	mov	r0, r4
     c56:	4643      	mov	r3, r8
}
     c58:	b007      	add	sp, #28
     c5a:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	pbuf_free(p);
     c5e:	4718      	bx	r3
		if (p->tot_len < sizeof(struct icmp_echo_hdr)) {
     c60:	8923      	ldrh	r3, [r4, #8]
     c62:	2b07      	cmp	r3, #7
     c64:	d9f6      	bls.n	c54 <icmp_input+0x50>
		if (inet_chksum_pbuf(p) != 0) {
     c66:	4b30      	ldr	r3, [pc, #192]	; (d28 <icmp_input+0x124>)
     c68:	4620      	mov	r0, r4
     c6a:	4798      	blx	r3
     c6c:	2800      	cmp	r0, #0
     c6e:	d1f1      	bne.n	c54 <icmp_input+0x50>
		if (pbuf_header(p, (PBUF_IP_HLEN + PBUF_LINK_HLEN))) {
     c70:	2124      	movs	r1, #36	; 0x24
     c72:	4620      	mov	r0, r4
	hlen  = IPH_HL(iphdr) * 4;
     c74:	b22d      	sxth	r5, r5
		if (pbuf_header(p, (PBUF_IP_HLEN + PBUF_LINK_HLEN))) {
     c76:	47b8      	blx	r7
     c78:	2800      	cmp	r0, #0
     c7a:	d04a      	beq.n	d12 <icmp_input+0x10e>
			if (pbuf_header(p, hlen)) {
     c7c:	4629      	mov	r1, r5
     c7e:	4620      	mov	r0, r4
     c80:	47b8      	blx	r7
     c82:	4602      	mov	r2, r0
     c84:	2800      	cmp	r0, #0
     c86:	d1e5      	bne.n	c54 <icmp_input+0x50>
			r = pbuf_alloc(PBUF_LINK, p->tot_len, PBUF_RAM);
     c88:	8921      	ldrh	r1, [r4, #8]
     c8a:	4b28      	ldr	r3, [pc, #160]	; (d2c <icmp_input+0x128>)
     c8c:	2002      	movs	r0, #2
     c8e:	4798      	blx	r3
			if (r == NULL) {
     c90:	4681      	mov	r9, r0
     c92:	2800      	cmp	r0, #0
     c94:	d0de      	beq.n	c54 <icmp_input+0x50>
			if (pbuf_copy(r, p) != ERR_OK) {
     c96:	4a26      	ldr	r2, [pc, #152]	; (d30 <icmp_input+0x12c>)
     c98:	4621      	mov	r1, r4
     c9a:	4790      	blx	r2
     c9c:	2800      	cmp	r0, #0
     c9e:	d1d9      	bne.n	c54 <icmp_input+0x50>
			if (pbuf_header(r, -hlen)) {
     ca0:	4651      	mov	r1, sl
     ca2:	4648      	mov	r0, r9
			iphdr = (struct ip_hdr *)r->payload;
     ca4:	f8d9 6004 	ldr.w	r6, [r9, #4]
			if (pbuf_header(r, -hlen)) {
     ca8:	47b8      	blx	r7
     caa:	2800      	cmp	r0, #0
     cac:	d1d2      	bne.n	c54 <icmp_input+0x50>
			pbuf_free(p);
     cae:	4620      	mov	r0, r4
     cb0:	47c0      	blx	r8
			p = r;
     cb2:	464c      	mov	r4, r9
		ip_addr_copy(iphdr->src, *ip_current_dest_addr());
     cb4:	f8db 3000 	ldr.w	r3, [fp]
		iecho = (struct icmp_echo_hdr *)p->payload;
     cb8:	6862      	ldr	r2, [r4, #4]
		ip_addr_copy(iphdr->src, *ip_current_dest_addr());
     cba:	60f3      	str	r3, [r6, #12]
		ip_addr_copy(iphdr->dest, *ip_current_src_addr());
     cbc:	4b1d      	ldr	r3, [pc, #116]	; (d34 <icmp_input+0x130>)
     cbe:	681b      	ldr	r3, [r3, #0]
     cc0:	6133      	str	r3, [r6, #16]
		ICMPH_TYPE_SET(iecho, ICMP_ER);
     cc2:	2300      	movs	r3, #0
     cc4:	7013      	strb	r3, [r2, #0]
		if (iecho->chksum >= PP_HTONS(0xffffU - (ICMP_ECHO << 8))) {
     cc6:	8853      	ldrh	r3, [r2, #2]
     cc8:	f64f 71f6 	movw	r1, #65526	; 0xfff6
     ccc:	428b      	cmp	r3, r1
			iecho->chksum += PP_HTONS(ICMP_ECHO << 8) + 1;
     cce:	bf8c      	ite	hi
     cd0:	3309      	addhi	r3, #9
			iecho->chksum += PP_HTONS(ICMP_ECHO << 8);
     cd2:	3308      	addls	r3, #8
     cd4:	b29b      	uxth	r3, r3
     cd6:	8053      	strh	r3, [r2, #2]
		IPH_TTL_SET(iphdr, ICMP_TTL);
     cd8:	f04f 0aff 	mov.w	sl, #255	; 0xff
		IPH_CHKSUM_SET(iphdr, 0);
     cdc:	2300      	movs	r3, #0
     cde:	72b3      	strb	r3, [r6, #10]
     ce0:	72f3      	strb	r3, [r6, #11]
		IPH_CHKSUM_SET(iphdr, inet_chksum(iphdr, IP_HLEN));
     ce2:	2114      	movs	r1, #20
     ce4:	4b14      	ldr	r3, [pc, #80]	; (d38 <icmp_input+0x134>)
		IPH_TTL_SET(iphdr, ICMP_TTL);
     ce6:	f886 a008 	strb.w	sl, [r6, #8]
		IPH_CHKSUM_SET(iphdr, inet_chksum(iphdr, IP_HLEN));
     cea:	4630      	mov	r0, r6
     cec:	4798      	blx	r3
		if (pbuf_header(p, hlen)) {
     cee:	4629      	mov	r1, r5
		IPH_CHKSUM_SET(iphdr, inet_chksum(iphdr, IP_HLEN));
     cf0:	8170      	strh	r0, [r6, #10]
		if (pbuf_header(p, hlen)) {
     cf2:	4620      	mov	r0, r4
     cf4:	47b8      	blx	r7
     cf6:	4602      	mov	r2, r0
     cf8:	2800      	cmp	r0, #0
     cfa:	d1ab      	bne.n	c54 <icmp_input+0x50>
			ret = ip_output_if(p, ip_current_dest_addr(), IP_HDRINCL, ICMP_TTL, 0, IP_PROTO_ICMP, inp);
     cfc:	9b05      	ldr	r3, [sp, #20]
     cfe:	9302      	str	r3, [sp, #8]
     d00:	2301      	movs	r3, #1
     d02:	e9cd 0300 	strd	r0, r3, [sp]
     d06:	490d      	ldr	r1, [pc, #52]	; (d3c <icmp_input+0x138>)
     d08:	4d0d      	ldr	r5, [pc, #52]	; (d40 <icmp_input+0x13c>)
     d0a:	4653      	mov	r3, sl
     d0c:	4620      	mov	r0, r4
     d0e:	47a8      	blx	r5
	pbuf_free(p);
     d10:	e7a0      	b.n	c54 <icmp_input+0x50>
			if (pbuf_header(p, -(s16_t)(PBUF_IP_HLEN + PBUF_LINK_HLEN))) {
     d12:	f06f 0123 	mvn.w	r1, #35	; 0x23
     d16:	4620      	mov	r0, r4
     d18:	47b8      	blx	r7
     d1a:	2800      	cmp	r0, #0
     d1c:	d0ca      	beq.n	cb4 <icmp_input+0xb0>
     d1e:	e799      	b.n	c54 <icmp_input+0x50>
     d20:	00003089 	.word	0x00003089
     d24:	00008a1f 	.word	0x00008a1f
     d28:	00008429 	.word	0x00008429
     d2c:	00003139 	.word	0x00003139
     d30:	000032ed 	.word	0x000032ed
     d34:	20011108 	.word	0x20011108
     d38:	00008419 	.word	0x00008419
     d3c:	20011104 	.word	0x20011104
     d40:	00006511 	.word	0x00006511
     d44:	000030e1 	.word	0x000030e1

00000d48 <icmp_dest_unreach>:
{
     d48:	460a      	mov	r2, r1
	icmp_send_response(p, ICMP_DUR, t);
     d4a:	4b01      	ldr	r3, [pc, #4]	; (d50 <icmp_dest_unreach+0x8>)
     d4c:	2103      	movs	r1, #3
     d4e:	4718      	bx	r3
     d50:	00000b81 	.word	0x00000b81

00000d54 <icmp_time_exceeded>:
{
     d54:	460a      	mov	r2, r1
	icmp_send_response(p, ICMP_TE, t);
     d56:	4b01      	ldr	r3, [pc, #4]	; (d5c <icmp_time_exceeded+0x8>)
     d58:	210b      	movs	r1, #11
     d5a:	4718      	bx	r3
     d5c:	00000b81 	.word	0x00000b81

00000d60 <lwip_htons>:
 * @param n u16_t in host byte order
 * @return n in network byte order
 */
u16_t lwip_htons(u16_t n)
{
	return ((n & 0xff) << 8) | ((n & 0xff00) >> 8);
     d60:	ba40      	rev16	r0, r0
}
     d62:	b280      	uxth	r0, r0
     d64:	4770      	bx	lr

00000d66 <lwip_ntohs>:
     d66:	ba40      	rev16	r0, r0
     d68:	b280      	uxth	r0, r0
     d6a:	4770      	bx	lr

00000d6c <lwip_htonl>:
 * @return n in network byte order
 */
u32_t lwip_htonl(u32_t n)
{
	return ((n & 0xff) << 24) | ((n & 0xff00) << 8) | ((n & 0xff0000UL) >> 8) | ((n & 0xff000000UL) >> 24);
}
     d6c:	ba00      	rev	r0, r0
     d6e:	4770      	bx	lr

00000d70 <lwip_ntohl>:
 * @param n u32_t in network byte order
 * @return n in host byte order
 */
u32_t lwip_ntohl(u32_t n)
{
	return lwip_htonl(n);
     d70:	4b00      	ldr	r3, [pc, #0]	; (d74 <lwip_ntohl+0x4>)
     d72:	4718      	bx	r3
     d74:	00000d6d 	.word	0x00000d6d

00000d78 <netbuf_delete>:
 * Deallocate a netbuf allocated by netbuf_new().
 *
 * @param buf pointer to a netbuf allocated by netbuf_new()
 */
void netbuf_delete(struct netbuf *buf)
{
     d78:	b510      	push	{r4, lr}
	if (buf != NULL) {
     d7a:	4604      	mov	r4, r0
     d7c:	b160      	cbz	r0, d98 <netbuf_delete+0x20>
		if (buf->p != NULL) {
     d7e:	6800      	ldr	r0, [r0, #0]
     d80:	b120      	cbz	r0, d8c <netbuf_delete+0x14>
			pbuf_free(buf->p);
     d82:	4b06      	ldr	r3, [pc, #24]	; (d9c <netbuf_delete+0x24>)
     d84:	4798      	blx	r3
			buf->p = buf->ptr = NULL;
     d86:	2300      	movs	r3, #0
     d88:	e9c4 3300 	strd	r3, r3, [r4]
		}
		memp_free(MEMP_NETBUF, buf);
     d8c:	4621      	mov	r1, r4
     d8e:	4b04      	ldr	r3, [pc, #16]	; (da0 <netbuf_delete+0x28>)
	}
}
     d90:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		memp_free(MEMP_NETBUF, buf);
     d94:	2006      	movs	r0, #6
     d96:	4718      	bx	r3
}
     d98:	bd10      	pop	{r4, pc}
     d9a:	bf00      	nop
     d9c:	000030e1 	.word	0x000030e1
     da0:	00004c21 	.word	0x00004c21

00000da4 <netbuf_free>:
 * Free the packet buffer included in a netbuf
 *
 * @param buf pointer to the netbuf which contains the packet buffer to free
 */
void netbuf_free(struct netbuf *buf)
{
     da4:	b510      	push	{r4, lr}
	LWIP_ERROR("netbuf_free: invalid buf", (buf != NULL), return;);
     da6:	4604      	mov	r4, r0
     da8:	b900      	cbnz	r0, dac <netbuf_free+0x8>
     daa:	e7fe      	b.n	daa <netbuf_free+0x6>
	if (buf->p != NULL) {
     dac:	6800      	ldr	r0, [r0, #0]
     dae:	b108      	cbz	r0, db4 <netbuf_free+0x10>
		pbuf_free(buf->p);
     db0:	4b02      	ldr	r3, [pc, #8]	; (dbc <netbuf_free+0x18>)
     db2:	4798      	blx	r3
	}
	buf->p = buf->ptr = NULL;
     db4:	2300      	movs	r3, #0
     db6:	e9c4 3300 	strd	r3, r3, [r4]
}
     dba:	bd10      	pop	{r4, pc}
     dbc:	000030e1 	.word	0x000030e1

00000dc0 <netbuf_ref>:
 * @param size size of the data
 * @return ERR_OK if data is referenced
 *         ERR_MEM if data couldn't be referenced due to lack of memory
 */
err_t netbuf_ref(struct netbuf *buf, const void *dataptr, u16_t size)
{
     dc0:	b570      	push	{r4, r5, r6, lr}
     dc2:	460e      	mov	r6, r1
     dc4:	4615      	mov	r5, r2
	LWIP_ERROR("netbuf_ref: invalid buf", (buf != NULL), return ERR_ARG;);
     dc6:	4604      	mov	r4, r0
     dc8:	b900      	cbnz	r0, dcc <netbuf_ref+0xc>
     dca:	e7fe      	b.n	dca <netbuf_ref+0xa>
	if (buf->p != NULL) {
     dcc:	6800      	ldr	r0, [r0, #0]
     dce:	b108      	cbz	r0, dd4 <netbuf_ref+0x14>
		pbuf_free(buf->p);
     dd0:	4b09      	ldr	r3, [pc, #36]	; (df8 <netbuf_ref+0x38>)
     dd2:	4798      	blx	r3
	}
	buf->p = pbuf_alloc(PBUF_TRANSPORT, 0, PBUF_REF);
     dd4:	2100      	movs	r1, #0
     dd6:	4b09      	ldr	r3, [pc, #36]	; (dfc <netbuf_ref+0x3c>)
     dd8:	2202      	movs	r2, #2
     dda:	4608      	mov	r0, r1
     ddc:	4798      	blx	r3
     dde:	6020      	str	r0, [r4, #0]
	if (buf->p == NULL) {
     de0:	b918      	cbnz	r0, dea <netbuf_ref+0x2a>
		buf->ptr = NULL;
     de2:	6060      	str	r0, [r4, #4]
		return ERR_MEM;
     de4:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
	}
	buf->p->payload = (void *)dataptr;
	buf->p->len = buf->p->tot_len = size;
	buf->ptr                      = buf->p;
	return ERR_OK;
}
     de8:	bd70      	pop	{r4, r5, r6, pc}
	buf->p->payload = (void *)dataptr;
     dea:	6046      	str	r6, [r0, #4]
	buf->p->len = buf->p->tot_len = size;
     dec:	8105      	strh	r5, [r0, #8]
     dee:	8145      	strh	r5, [r0, #10]
	buf->ptr                      = buf->p;
     df0:	6060      	str	r0, [r4, #4]
	return ERR_OK;
     df2:	2000      	movs	r0, #0
     df4:	e7f8      	b.n	de8 <netbuf_ref+0x28>
     df6:	bf00      	nop
     df8:	000030e1 	.word	0x000030e1
     dfc:	00003139 	.word	0x00003139

00000e00 <ETHERNET_PHY_0_init>:
#include <ethernet_phy_main.h>

struct ethernet_phy_descriptor ETHERNET_PHY_0_desc;

void ETHERNET_PHY_0_init(void)
{
     e00:	b510      	push	{r4, lr}
	mac_async_enable(&COMMUNICATION_IO);
     e02:	4905      	ldr	r1, [pc, #20]	; (e18 <ETHERNET_PHY_0_init+0x18>)
     e04:	4b05      	ldr	r3, [pc, #20]	; (e1c <ETHERNET_PHY_0_init+0x1c>)
     e06:	4608      	mov	r0, r1
     e08:	4798      	blx	r3
	ethernet_phy_init(&ETHERNET_PHY_0_desc, &COMMUNICATION_IO, CONF_ETHERNET_PHY_0_IEEE8023_MII_PHY_ADDRESS);
#if CONF_ETHERNET_PHY_0_IEEE8023_MII_CONTROL_REG0_SETTING == 1
	ethernet_phy_write_reg(&ETHERNET_PHY_0_desc, MDIO_REG0_BMCR, CONF_ETHERNET_PHY_0_IEEE8023_MII_CONTROL_REG0);
#endif /* CONF_ETHERNET_PHY_0_IEEE8023_MII_CONTROL_REG0_SETTING */
}
     e0a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	ethernet_phy_init(&ETHERNET_PHY_0_desc, &COMMUNICATION_IO, CONF_ETHERNET_PHY_0_IEEE8023_MII_PHY_ADDRESS);
     e0e:	4902      	ldr	r1, [pc, #8]	; (e18 <ETHERNET_PHY_0_init+0x18>)
     e10:	4803      	ldr	r0, [pc, #12]	; (e20 <ETHERNET_PHY_0_init+0x20>)
     e12:	4b04      	ldr	r3, [pc, #16]	; (e24 <ETHERNET_PHY_0_init+0x24>)
     e14:	2200      	movs	r2, #0
     e16:	4718      	bx	r3
     e18:	2000a520 	.word	0x2000a520
     e1c:	00004c75 	.word	0x00004c75
     e20:	200000a4 	.word	0x200000a4
     e24:	00000fd1 	.word	0x00000fd1

00000e28 <ethernet_phys_init>:
}

void ethernet_phys_init(void)
{

	ETHERNET_PHY_0_init();
     e28:	4b00      	ldr	r3, [pc, #0]	; (e2c <ethernet_phys_init+0x4>)
     e2a:	4718      	bx	r3
     e2c:	00000e01 	.word	0x00000e01

00000e30 <usart_sync_write>:
 * \param[in] length The number of bytes to write
 *
 * \return The number of bytes written.
 */
static int32_t usart_sync_write(struct io_descriptor *const io_descr, const uint8_t *const buf, const uint16_t length)
{
     e30:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
     e34:	460e      	mov	r6, r1
     e36:	4615      	mov	r5, r2
	uint32_t                      offset = 0;
	struct usart_sync_descriptor *descr  = CONTAINER_OF(io_descr, struct usart_sync_descriptor, io);

	ASSERT(io_descr && buf && length);
     e38:	4604      	mov	r4, r0
     e3a:	b118      	cbz	r0, e44 <usart_sync_write+0x14>
     e3c:	b329      	cbz	r1, e8a <usart_sync_write+0x5a>
     e3e:	1e10      	subs	r0, r2, #0
     e40:	bf18      	it	ne
     e42:	2001      	movne	r0, #1
     e44:	4912      	ldr	r1, [pc, #72]	; (e90 <usart_sync_write+0x60>)
     e46:	4b13      	ldr	r3, [pc, #76]	; (e94 <usart_sync_write+0x64>)
	while (!_usart_sync_is_ready_to_send(&descr->device))
     e48:	4f13      	ldr	r7, [pc, #76]	; (e98 <usart_sync_write+0x68>)
	ASSERT(io_descr && buf && length);
     e4a:	22f1      	movs	r2, #241	; 0xf1
     e4c:	4798      	blx	r3
	while (!_usart_sync_is_ready_to_send(&descr->device))
     e4e:	3408      	adds	r4, #8
     e50:	46b9      	mov	r9, r7
     e52:	4620      	mov	r0, r4
     e54:	47b8      	blx	r7
     e56:	2800      	cmp	r0, #0
     e58:	d0fb      	beq.n	e52 <usart_sync_write+0x22>
		;
	do {
		_usart_sync_write_byte(&descr->device, buf[offset]);
     e5a:	f8df 8044 	ldr.w	r8, [pc, #68]	; ea0 <usart_sync_write+0x70>
	uint32_t                      offset = 0;
     e5e:	2700      	movs	r7, #0
		_usart_sync_write_byte(&descr->device, buf[offset]);
     e60:	5df1      	ldrb	r1, [r6, r7]
     e62:	4620      	mov	r0, r4
     e64:	47c0      	blx	r8
		while (!_usart_sync_is_ready_to_send(&descr->device))
     e66:	4620      	mov	r0, r4
     e68:	47c8      	blx	r9
     e6a:	2800      	cmp	r0, #0
     e6c:	d0fb      	beq.n	e66 <usart_sync_write+0x36>
			;
	} while (++offset < length);
     e6e:	3701      	adds	r7, #1
     e70:	42bd      	cmp	r5, r7
     e72:	d8f5      	bhi.n	e60 <usart_sync_write+0x30>
     e74:	2d00      	cmp	r5, #0
	while (!_usart_sync_is_transmit_done(&descr->device))
     e76:	4e09      	ldr	r6, [pc, #36]	; (e9c <usart_sync_write+0x6c>)
	} while (++offset < length);
     e78:	bf08      	it	eq
     e7a:	2501      	moveq	r5, #1
	while (!_usart_sync_is_transmit_done(&descr->device))
     e7c:	4620      	mov	r0, r4
     e7e:	47b0      	blx	r6
     e80:	2800      	cmp	r0, #0
     e82:	d0fb      	beq.n	e7c <usart_sync_write+0x4c>
		;
	return (int32_t)offset;
}
     e84:	4628      	mov	r0, r5
     e86:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
	ASSERT(io_descr && buf && length);
     e8a:	4608      	mov	r0, r1
     e8c:	e7da      	b.n	e44 <usart_sync_write+0x14>
     e8e:	bf00      	nop
     e90:	0000c960 	.word	0x0000c960
     e94:	00008a19 	.word	0x00008a19
     e98:	00007d5b 	.word	0x00007d5b
     e9c:	00007d65 	.word	0x00007d65
     ea0:	00007d4d 	.word	0x00007d4d

00000ea4 <usart_sync_read>:
 * \param[in] length The size of a buffer
 *
 * \return The number of bytes read.
 */
static int32_t usart_sync_read(struct io_descriptor *const io_descr, uint8_t *const buf, const uint16_t length)
{
     ea4:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
     ea8:	460e      	mov	r6, r1
     eaa:	4615      	mov	r5, r2
	uint32_t                      offset = 0;
	struct usart_sync_descriptor *descr  = CONTAINER_OF(io_descr, struct usart_sync_descriptor, io);

	ASSERT(io_descr && buf && length);
     eac:	4604      	mov	r4, r0
     eae:	b118      	cbz	r0, eb8 <usart_sync_read+0x14>
     eb0:	b1e9      	cbz	r1, eee <usart_sync_read+0x4a>
     eb2:	1e10      	subs	r0, r2, #0
     eb4:	bf18      	it	ne
     eb6:	2001      	movne	r0, #1
     eb8:	490e      	ldr	r1, [pc, #56]	; (ef4 <usart_sync_read+0x50>)
     eba:	4b0f      	ldr	r3, [pc, #60]	; (ef8 <usart_sync_read+0x54>)
	do {
		while (!_usart_sync_is_byte_received(&descr->device))
     ebc:	f8df 903c 	ldr.w	r9, [pc, #60]	; efc <usart_sync_read+0x58>
			;
		buf[offset] = _usart_sync_read_byte(&descr->device);
     ec0:	f8df 803c 	ldr.w	r8, [pc, #60]	; f00 <usart_sync_read+0x5c>
	ASSERT(io_descr && buf && length);
     ec4:	f44f 7286 	mov.w	r2, #268	; 0x10c
     ec8:	4798      	blx	r3
	uint32_t                      offset = 0;
     eca:	2700      	movs	r7, #0
		while (!_usart_sync_is_byte_received(&descr->device))
     ecc:	3408      	adds	r4, #8
     ece:	4620      	mov	r0, r4
     ed0:	47c8      	blx	r9
     ed2:	2800      	cmp	r0, #0
     ed4:	d0fb      	beq.n	ece <usart_sync_read+0x2a>
		buf[offset] = _usart_sync_read_byte(&descr->device);
     ed6:	4620      	mov	r0, r4
     ed8:	47c0      	blx	r8
     eda:	55f0      	strb	r0, [r6, r7]
	} while (++offset < length);
     edc:	3701      	adds	r7, #1
     ede:	42bd      	cmp	r5, r7
     ee0:	d8f5      	bhi.n	ece <usart_sync_read+0x2a>
     ee2:	2d00      	cmp	r5, #0

	return (int32_t)offset;
}
     ee4:	bf14      	ite	ne
     ee6:	4628      	movne	r0, r5
     ee8:	2001      	moveq	r0, #1
     eea:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
	ASSERT(io_descr && buf && length);
     eee:	4608      	mov	r0, r1
     ef0:	e7e2      	b.n	eb8 <usart_sync_read+0x14>
     ef2:	bf00      	nop
     ef4:	0000c960 	.word	0x0000c960
     ef8:	00008a19 	.word	0x00008a19
     efc:	00007d6f 	.word	0x00007d6f
     f00:	00007d53 	.word	0x00007d53

00000f04 <usart_sync_init>:
{
     f04:	b538      	push	{r3, r4, r5, lr}
     f06:	460d      	mov	r5, r1
	ASSERT(descr && hw);
     f08:	4604      	mov	r4, r0
     f0a:	b110      	cbz	r0, f12 <usart_sync_init+0xe>
     f0c:	1e08      	subs	r0, r1, #0
     f0e:	bf18      	it	ne
     f10:	2001      	movne	r0, #1
     f12:	4907      	ldr	r1, [pc, #28]	; (f30 <usart_sync_init+0x2c>)
     f14:	4b07      	ldr	r3, [pc, #28]	; (f34 <usart_sync_init+0x30>)
     f16:	2234      	movs	r2, #52	; 0x34
     f18:	4798      	blx	r3
	init_status = _usart_sync_init(&descr->device, hw);
     f1a:	4b07      	ldr	r3, [pc, #28]	; (f38 <usart_sync_init+0x34>)
     f1c:	4629      	mov	r1, r5
     f1e:	f104 0008 	add.w	r0, r4, #8
     f22:	4798      	blx	r3
	if (init_status) {
     f24:	b918      	cbnz	r0, f2e <usart_sync_init+0x2a>
	descr->io.read  = usart_sync_read;
     f26:	4b05      	ldr	r3, [pc, #20]	; (f3c <usart_sync_init+0x38>)
     f28:	6063      	str	r3, [r4, #4]
	descr->io.write = usart_sync_write;
     f2a:	4b05      	ldr	r3, [pc, #20]	; (f40 <usart_sync_init+0x3c>)
     f2c:	6023      	str	r3, [r4, #0]
}
     f2e:	bd38      	pop	{r3, r4, r5, pc}
     f30:	0000c960 	.word	0x0000c960
     f34:	00008a19 	.word	0x00008a19
     f38:	00007d0d 	.word	0x00007d0d
     f3c:	00000ea5 	.word	0x00000ea5
     f40:	00000e31 	.word	0x00000e31

00000f44 <usart_sync_enable>:
{
     f44:	b510      	push	{r4, lr}
	ASSERT(descr);
     f46:	4604      	mov	r4, r0
     f48:	3800      	subs	r0, #0
     f4a:	bf18      	it	ne
     f4c:	2001      	movne	r0, #1
     f4e:	4905      	ldr	r1, [pc, #20]	; (f64 <usart_sync_enable+0x20>)
     f50:	4b05      	ldr	r3, [pc, #20]	; (f68 <usart_sync_enable+0x24>)
     f52:	2253      	movs	r2, #83	; 0x53
     f54:	4798      	blx	r3
	_usart_sync_enable(&descr->device);
     f56:	f104 0008 	add.w	r0, r4, #8
     f5a:	4b04      	ldr	r3, [pc, #16]	; (f6c <usart_sync_enable+0x28>)
     f5c:	4798      	blx	r3
}
     f5e:	2000      	movs	r0, #0
     f60:	bd10      	pop	{r4, pc}
     f62:	bf00      	nop
     f64:	0000c960 	.word	0x0000c960
     f68:	00008a19 	.word	0x00008a19
     f6c:	00007d39 	.word	0x00007d39

00000f70 <_read>:
#include <stdio.h>

int __attribute__((weak)) _read(int file, char *ptr, int len); /* Remove GCC compiler warning */

int __attribute__((weak)) _read(int file, char *ptr, int len)
{
     f70:	b508      	push	{r3, lr}
     f72:	4603      	mov	r3, r0
     f74:	4608      	mov	r0, r1
     f76:	4611      	mov	r1, r2
	int n = 0;

	if (file != 0) {
     f78:	b923      	cbnz	r3, f84 <_read+0x14>
		return -1;
	}

	n = stdio_io_read((uint8_t *)ptr, len);
     f7a:	4b04      	ldr	r3, [pc, #16]	; (f8c <_read+0x1c>)
     f7c:	4798      	blx	r3
	if (n < 0) {
     f7e:	ea40 70e0 	orr.w	r0, r0, r0, asr #31
		return -1;
	}

	return n;
}
     f82:	bd08      	pop	{r3, pc}
		return -1;
     f84:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
     f88:	e7fb      	b.n	f82 <_read+0x12>
     f8a:	bf00      	nop
     f8c:	000002d1 	.word	0x000002d1

00000f90 <_gclk_init_generators_by_fref>:

void _gclk_init_generators_by_fref(uint32_t bm)
{

#if CONF_GCLK_GENERATOR_0_CONFIG == 1
	if (bm & (1ul << 0)) {
     f90:	07c3      	lsls	r3, r0, #31
     f92:	d507      	bpl.n	fa4 <_gclk_init_generators_by_fref+0x14>
}

static inline void hri_gclk_write_GENCTRL_reg(const void *const hw, uint8_t index, hri_gclk_genctrl_reg_t data)
{
	GCLK_CRITICAL_SECTION_ENTER();
	((Gclk *)hw)->GENCTRL[index].reg = data;
     f94:	4b04      	ldr	r3, [pc, #16]	; (fa8 <_gclk_init_generators_by_fref+0x18>)
     f96:	4a05      	ldr	r2, [pc, #20]	; (fac <_gclk_init_generators_by_fref+0x1c>)
     f98:	621a      	str	r2, [r3, #32]
	while (((Gclk *)hw)->SYNCBUSY.reg & reg) {
     f9a:	f643 72fd 	movw	r2, #16381	; 0x3ffd
     f9e:	6859      	ldr	r1, [r3, #4]
     fa0:	4211      	tst	r1, r2
     fa2:	d1fc      	bne.n	f9e <_gclk_init_generators_by_fref+0xe>
		        | (CONF_GCLK_GEN_11_DIVSEL << GCLK_GENCTRL_DIVSEL_Pos) | (CONF_GCLK_GEN_11_OE << GCLK_GENCTRL_OE_Pos)
		        | (CONF_GCLK_GEN_11_OOV << GCLK_GENCTRL_OOV_Pos) | (CONF_GCLK_GEN_11_IDC << GCLK_GENCTRL_IDC_Pos)
		        | (CONF_GCLK_GENERATOR_11_CONFIG << GCLK_GENCTRL_GENEN_Pos) | CONF_GCLK_GEN_11_SOURCE);
	}
#endif
}
     fa4:	4770      	bx	lr
     fa6:	bf00      	nop
     fa8:	40001c00 	.word	0x40001c00
     fac:	00010101 	.word	0x00010101

00000fb0 <stdio_redirect_init>:
	/* Print welcome message */
	printf("\r\nHello ATMEL World!\r\n");
}

void stdio_redirect_init(void)
{
     fb0:	b510      	push	{r4, lr}

	usart_sync_enable(&TARGET_IO);
     fb2:	4c04      	ldr	r4, [pc, #16]	; (fc4 <stdio_redirect_init+0x14>)
     fb4:	4b04      	ldr	r3, [pc, #16]	; (fc8 <stdio_redirect_init+0x18>)
     fb6:	4620      	mov	r0, r4
     fb8:	4798      	blx	r3
	stdio_io_init(&TARGET_IO.io);
     fba:	4620      	mov	r0, r4
     fbc:	4b03      	ldr	r3, [pc, #12]	; (fcc <stdio_redirect_init+0x1c>)
}
     fbe:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	stdio_io_init(&TARGET_IO.io);
     fc2:	4718      	bx	r3
     fc4:	2000a514 	.word	0x2000a514
     fc8:	00000f45 	.word	0x00000f45
     fcc:	000002a5 	.word	0x000002a5

00000fd0 <ethernet_phy_init>:
/**
 * \brief Perform a HW initialization to the PHY
 */
int32_t ethernet_phy_init(struct ethernet_phy_descriptor *const descr, struct mac_async_descriptor *const mac,
                          uint16_t addr)
{
     fd0:	b570      	push	{r4, r5, r6, lr}
     fd2:	460d      	mov	r5, r1
     fd4:	4616      	mov	r6, r2
	ASSERT(descr && mac && (addr <= 0x1F));
     fd6:	4604      	mov	r4, r0
     fd8:	b120      	cbz	r0, fe4 <ethernet_phy_init+0x14>
     fda:	b159      	cbz	r1, ff4 <ethernet_phy_init+0x24>
     fdc:	2a1f      	cmp	r2, #31
     fde:	bf8c      	ite	hi
     fe0:	2000      	movhi	r0, #0
     fe2:	2001      	movls	r0, #1
     fe4:	4904      	ldr	r1, [pc, #16]	; (ff8 <ethernet_phy_init+0x28>)
     fe6:	4b05      	ldr	r3, [pc, #20]	; (ffc <ethernet_phy_init+0x2c>)
     fe8:	222a      	movs	r2, #42	; 0x2a
     fea:	4798      	blx	r3

	descr->mac  = mac;
     fec:	6025      	str	r5, [r4, #0]
	descr->addr = addr;
     fee:	80a6      	strh	r6, [r4, #4]
	return ERR_NONE;
}
     ff0:	2000      	movs	r0, #0
     ff2:	bd70      	pop	{r4, r5, r6, pc}
	ASSERT(descr && mac && (addr <= 0x1F));
     ff4:	4608      	mov	r0, r1
     ff6:	e7f5      	b.n	fe4 <ethernet_phy_init+0x14>
     ff8:	0000c97c 	.word	0x0000c97c
     ffc:	00008a19 	.word	0x00008a19

00001000 <ethernet_phy_get_link_status>:

/**
 * \brief Get PHY link status
 */
int32_t ethernet_phy_get_link_status(struct ethernet_phy_descriptor *const descr, bool *status)
{
    1000:	b537      	push	{r0, r1, r2, r4, r5, lr}
    1002:	460d      	mov	r5, r1
	int32_t  rst;
	uint16_t val;

	ASSERT(descr && descr->mac && status);
    1004:	4604      	mov	r4, r0
    1006:	b120      	cbz	r0, 1012 <ethernet_phy_get_link_status+0x12>
    1008:	6800      	ldr	r0, [r0, #0]
    100a:	b110      	cbz	r0, 1012 <ethernet_phy_get_link_status+0x12>
    100c:	1e08      	subs	r0, r1, #0
    100e:	bf18      	it	ne
    1010:	2001      	movne	r0, #1
    1012:	4909      	ldr	r1, [pc, #36]	; (1038 <ethernet_phy_get_link_status+0x38>)
    1014:	4b09      	ldr	r3, [pc, #36]	; (103c <ethernet_phy_get_link_status+0x3c>)
    1016:	22a9      	movs	r2, #169	; 0xa9
    1018:	4798      	blx	r3
	rst = mac_async_read_phy_reg(descr->mac, descr->addr, MDIO_REG1_BMSR, &val);
    101a:	88a1      	ldrh	r1, [r4, #4]
    101c:	6820      	ldr	r0, [r4, #0]
    101e:	4c08      	ldr	r4, [pc, #32]	; (1040 <ethernet_phy_get_link_status+0x40>)
    1020:	f10d 0306 	add.w	r3, sp, #6
    1024:	2201      	movs	r2, #1
    1026:	47a0      	blx	r4
	if (rst == ERR_NONE) {
    1028:	b920      	cbnz	r0, 1034 <ethernet_phy_get_link_status+0x34>
		*status = (val & MDIO_REG1_BIT_LINK_STATUS) ? true : false;
    102a:	f8bd 3006 	ldrh.w	r3, [sp, #6]
    102e:	f3c3 0380 	ubfx	r3, r3, #2, #1
    1032:	702b      	strb	r3, [r5, #0]
	}
	return rst;
}
    1034:	b003      	add	sp, #12
    1036:	bd30      	pop	{r4, r5, pc}
    1038:	0000c97c 	.word	0x0000c97c
    103c:	00008a19 	.word	0x00008a19
    1040:	00004db9 	.word	0x00004db9

00001044 <sys_timeout>:
#if LWIP_DEBUG_TIMERNAMES
void sys_timeout_debug(u32_t msecs, sys_timeout_handler handler, void *arg, const char *handler_name)
#else  /* LWIP_DEBUG_TIMERNAMES */
void sys_timeout(u32_t msecs, sys_timeout_handler handler, void *arg)
#endif /* LWIP_DEBUG_TIMERNAMES */
{
    1044:	b570      	push	{r4, r5, r6, lr}
	struct sys_timeo *timeout, *t;

	timeout = (struct sys_timeo *)memp_malloc(MEMP_SYS_TIMEOUT);
    1046:	4b14      	ldr	r3, [pc, #80]	; (1098 <sys_timeout+0x54>)
{
    1048:	4604      	mov	r4, r0
	timeout = (struct sys_timeo *)memp_malloc(MEMP_SYS_TIMEOUT);
    104a:	200a      	movs	r0, #10
{
    104c:	460e      	mov	r6, r1
    104e:	4615      	mov	r5, r2
	timeout = (struct sys_timeo *)memp_malloc(MEMP_SYS_TIMEOUT);
    1050:	4798      	blx	r3
	if (timeout == NULL) {
    1052:	b140      	cbz	r0, 1066 <sys_timeout+0x22>
	LWIP_DEBUGF(
	    TIMERS_DEBUG,
	    ("sys_timeout: %p msecs=%" U32_F " handler=%s arg=%p\n", (void *)timeout, msecs, handler_name, (void *)arg));
#endif /* LWIP_DEBUG_TIMERNAMES */

	if (next_timeout == NULL) {
    1054:	4911      	ldr	r1, [pc, #68]	; (109c <sys_timeout+0x58>)
	timeout->time = msecs;
    1056:	6044      	str	r4, [r0, #4]
	timeout->next = NULL;
    1058:	2300      	movs	r3, #0
    105a:	6003      	str	r3, [r0, #0]
	if (next_timeout == NULL) {
    105c:	680b      	ldr	r3, [r1, #0]
	timeout->arg  = arg;
    105e:	e9c0 6502 	strd	r6, r5, [r0, #8]
	if (next_timeout == NULL) {
    1062:	b90b      	cbnz	r3, 1068 <sys_timeout+0x24>
	}

	if (next_timeout->time > msecs) {
		next_timeout->time -= msecs;
		timeout->next = next_timeout;
		next_timeout  = timeout;
    1064:	6008      	str	r0, [r1, #0]
				t->next       = timeout;
				break;
			}
		}
	}
}
    1066:	bd70      	pop	{r4, r5, r6, pc}
	if (next_timeout->time > msecs) {
    1068:	685a      	ldr	r2, [r3, #4]
    106a:	42a2      	cmp	r2, r4
    106c:	d903      	bls.n	1076 <sys_timeout+0x32>
		next_timeout->time -= msecs;
    106e:	1b12      	subs	r2, r2, r4
    1070:	605a      	str	r2, [r3, #4]
		timeout->next = next_timeout;
    1072:	6003      	str	r3, [r0, #0]
    1074:	e7f6      	b.n	1064 <sys_timeout+0x20>
			timeout->time -= t->time;
    1076:	685a      	ldr	r2, [r3, #4]
    1078:	6841      	ldr	r1, [r0, #4]
    107a:	461e      	mov	r6, r3
			if (t->next == NULL || t->next->time > timeout->time) {
    107c:	681b      	ldr	r3, [r3, #0]
			timeout->time -= t->time;
    107e:	1a8d      	subs	r5, r1, r2
    1080:	6045      	str	r5, [r0, #4]
			if (t->next == NULL || t->next->time > timeout->time) {
    1082:	b12b      	cbz	r3, 1090 <sys_timeout+0x4c>
    1084:	685c      	ldr	r4, [r3, #4]
    1086:	42a5      	cmp	r5, r4
    1088:	d2f5      	bcs.n	1076 <sys_timeout+0x32>
					t->next->time -= timeout->time;
    108a:	4422      	add	r2, r4
    108c:	1a52      	subs	r2, r2, r1
    108e:	605a      	str	r2, [r3, #4]
				timeout->next = t->next;
    1090:	6003      	str	r3, [r0, #0]
				t->next       = timeout;
    1092:	6030      	str	r0, [r6, #0]
				break;
    1094:	e7e7      	b.n	1066 <sys_timeout+0x22>
    1096:	bf00      	nop
    1098:	00004c05 	.word	0x00004c05
    109c:	200000ac 	.word	0x200000ac

000010a0 <tcp_timer_needed>:
	if (!tcpip_tcp_timer_active && (tcp_active_pcbs || tcp_tw_pcbs)) {
    10a0:	4b08      	ldr	r3, [pc, #32]	; (10c4 <tcp_timer_needed+0x24>)
    10a2:	685a      	ldr	r2, [r3, #4]
    10a4:	b962      	cbnz	r2, 10c0 <tcp_timer_needed+0x20>
    10a6:	4a08      	ldr	r2, [pc, #32]	; (10c8 <tcp_timer_needed+0x28>)
    10a8:	6812      	ldr	r2, [r2, #0]
    10aa:	b912      	cbnz	r2, 10b2 <tcp_timer_needed+0x12>
    10ac:	4a07      	ldr	r2, [pc, #28]	; (10cc <tcp_timer_needed+0x2c>)
    10ae:	6812      	ldr	r2, [r2, #0]
    10b0:	b132      	cbz	r2, 10c0 <tcp_timer_needed+0x20>
		tcpip_tcp_timer_active = 1;
    10b2:	2201      	movs	r2, #1
    10b4:	605a      	str	r2, [r3, #4]
		sys_timeout(TCP_TMR_INTERVAL, tcpip_tcp_timer, NULL);
    10b6:	4906      	ldr	r1, [pc, #24]	; (10d0 <tcp_timer_needed+0x30>)
    10b8:	4b06      	ldr	r3, [pc, #24]	; (10d4 <tcp_timer_needed+0x34>)
    10ba:	2200      	movs	r2, #0
    10bc:	20fa      	movs	r0, #250	; 0xfa
    10be:	4718      	bx	r3
}
    10c0:	4770      	bx	lr
    10c2:	bf00      	nop
    10c4:	200000ac 	.word	0x200000ac
    10c8:	20014950 	.word	0x20014950
    10cc:	20014958 	.word	0x20014958
    10d0:	000010d9 	.word	0x000010d9
    10d4:	00001045 	.word	0x00001045

000010d8 <tcpip_tcp_timer>:
	tcp_tmr();
    10d8:	4b09      	ldr	r3, [pc, #36]	; (1100 <tcpip_tcp_timer+0x28>)
{
    10da:	b510      	push	{r4, lr}
	tcp_tmr();
    10dc:	4798      	blx	r3
	if (tcp_active_pcbs || tcp_tw_pcbs) {
    10de:	4b09      	ldr	r3, [pc, #36]	; (1104 <tcpip_tcp_timer+0x2c>)
    10e0:	681b      	ldr	r3, [r3, #0]
    10e2:	b913      	cbnz	r3, 10ea <tcpip_tcp_timer+0x12>
    10e4:	4b08      	ldr	r3, [pc, #32]	; (1108 <tcpip_tcp_timer+0x30>)
    10e6:	681b      	ldr	r3, [r3, #0]
    10e8:	b133      	cbz	r3, 10f8 <tcpip_tcp_timer+0x20>
}
    10ea:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		sys_timeout(TCP_TMR_INTERVAL, tcpip_tcp_timer, NULL);
    10ee:	4907      	ldr	r1, [pc, #28]	; (110c <tcpip_tcp_timer+0x34>)
    10f0:	4b07      	ldr	r3, [pc, #28]	; (1110 <tcpip_tcp_timer+0x38>)
    10f2:	2200      	movs	r2, #0
    10f4:	20fa      	movs	r0, #250	; 0xfa
    10f6:	4718      	bx	r3
		tcpip_tcp_timer_active = 0;
    10f8:	4a06      	ldr	r2, [pc, #24]	; (1114 <tcpip_tcp_timer+0x3c>)
    10fa:	6053      	str	r3, [r2, #4]
}
    10fc:	bd10      	pop	{r4, pc}
    10fe:	bf00      	nop
    1100:	00007145 	.word	0x00007145
    1104:	20014950 	.word	0x20014950
    1108:	20014958 	.word	0x20014958
    110c:	000010d9 	.word	0x000010d9
    1110:	00001045 	.word	0x00001045
    1114:	200000ac 	.word	0x200000ac

00001118 <sys_timeouts_init>:
{
    1118:	b510      	push	{r4, lr}
	sys_timeout(IP_TMR_INTERVAL, ip_reass_timer, NULL);
    111a:	490c      	ldr	r1, [pc, #48]	; (114c <sys_timeouts_init+0x34>)
    111c:	4c0c      	ldr	r4, [pc, #48]	; (1150 <sys_timeouts_init+0x38>)
    111e:	2200      	movs	r2, #0
    1120:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
    1124:	47a0      	blx	r4
	sys_timeout(ARP_TMR_INTERVAL, arp_timer, NULL);
    1126:	490b      	ldr	r1, [pc, #44]	; (1154 <sys_timeouts_init+0x3c>)
    1128:	2200      	movs	r2, #0
    112a:	f241 3088 	movw	r0, #5000	; 0x1388
    112e:	47a0      	blx	r4
	sys_timeout(DHCP_COARSE_TIMER_MSECS, dhcp_timer_coarse, NULL);
    1130:	4909      	ldr	r1, [pc, #36]	; (1158 <sys_timeouts_init+0x40>)
    1132:	2200      	movs	r2, #0
    1134:	f64e 2060 	movw	r0, #60000	; 0xea60
    1138:	47a0      	blx	r4
	sys_timeout(DHCP_FINE_TIMER_MSECS, dhcp_timer_fine, NULL);
    113a:	4623      	mov	r3, r4
    113c:	4907      	ldr	r1, [pc, #28]	; (115c <sys_timeouts_init+0x44>)
}
    113e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	sys_timeout(DHCP_FINE_TIMER_MSECS, dhcp_timer_fine, NULL);
    1142:	2200      	movs	r2, #0
    1144:	f44f 70fa 	mov.w	r0, #500	; 0x1f4
    1148:	4718      	bx	r3
    114a:	bf00      	nop
    114c:	000011cd 	.word	0x000011cd
    1150:	00001045 	.word	0x00001045
    1154:	000011a9 	.word	0x000011a9
    1158:	00001185 	.word	0x00001185
    115c:	00001161 	.word	0x00001161

00001160 <dhcp_timer_fine>:
{
    1160:	b510      	push	{r4, lr}
	dhcp_fine_tmr();
    1162:	4b05      	ldr	r3, [pc, #20]	; (1178 <dhcp_timer_fine+0x18>)
    1164:	4798      	blx	r3
}
    1166:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	sys_timeout(DHCP_FINE_TIMER_MSECS, dhcp_timer_fine, NULL);
    116a:	4904      	ldr	r1, [pc, #16]	; (117c <dhcp_timer_fine+0x1c>)
    116c:	4b04      	ldr	r3, [pc, #16]	; (1180 <dhcp_timer_fine+0x20>)
    116e:	2200      	movs	r2, #0
    1170:	f44f 70fa 	mov.w	r0, #500	; 0x1f4
    1174:	4718      	bx	r3
    1176:	bf00      	nop
    1178:	00006145 	.word	0x00006145
    117c:	00001161 	.word	0x00001161
    1180:	00001045 	.word	0x00001045

00001184 <dhcp_timer_coarse>:
{
    1184:	b510      	push	{r4, lr}
	dhcp_coarse_tmr();
    1186:	4b05      	ldr	r3, [pc, #20]	; (119c <dhcp_timer_coarse+0x18>)
    1188:	4798      	blx	r3
}
    118a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	sys_timeout(DHCP_COARSE_TIMER_MSECS, dhcp_timer_coarse, NULL);
    118e:	4904      	ldr	r1, [pc, #16]	; (11a0 <dhcp_timer_coarse+0x1c>)
    1190:	4b04      	ldr	r3, [pc, #16]	; (11a4 <dhcp_timer_coarse+0x20>)
    1192:	2200      	movs	r2, #0
    1194:	f64e 2060 	movw	r0, #60000	; 0xea60
    1198:	4718      	bx	r3
    119a:	bf00      	nop
    119c:	00006019 	.word	0x00006019
    11a0:	00001185 	.word	0x00001185
    11a4:	00001045 	.word	0x00001045

000011a8 <arp_timer>:
{
    11a8:	b510      	push	{r4, lr}
	etharp_tmr();
    11aa:	4b05      	ldr	r3, [pc, #20]	; (11c0 <arp_timer+0x18>)
    11ac:	4798      	blx	r3
}
    11ae:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	sys_timeout(ARP_TMR_INTERVAL, arp_timer, NULL);
    11b2:	4904      	ldr	r1, [pc, #16]	; (11c4 <arp_timer+0x1c>)
    11b4:	4b04      	ldr	r3, [pc, #16]	; (11c8 <arp_timer+0x20>)
    11b6:	2200      	movs	r2, #0
    11b8:	f241 3088 	movw	r0, #5000	; 0x1388
    11bc:	4718      	bx	r3
    11be:	bf00      	nop
    11c0:	00004f39 	.word	0x00004f39
    11c4:	000011a9 	.word	0x000011a9
    11c8:	00001045 	.word	0x00001045

000011cc <ip_reass_timer>:
{
    11cc:	b510      	push	{r4, lr}
	ip_reass_tmr();
    11ce:	4b05      	ldr	r3, [pc, #20]	; (11e4 <ip_reass_timer+0x18>)
    11d0:	4798      	blx	r3
}
    11d2:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	sys_timeout(IP_TMR_INTERVAL, ip_reass_timer, NULL);
    11d6:	4904      	ldr	r1, [pc, #16]	; (11e8 <ip_reass_timer+0x1c>)
    11d8:	4b04      	ldr	r3, [pc, #16]	; (11ec <ip_reass_timer+0x20>)
    11da:	2200      	movs	r2, #0
    11dc:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
    11e0:	4718      	bx	r3
    11e2:	bf00      	nop
    11e4:	00002b19 	.word	0x00002b19
    11e8:	000011cd 	.word	0x000011cd
    11ec:	00001045 	.word	0x00001045

000011f0 <sys_untimeout>:
 *
 * @param handler callback function that would be called by the timeout
 * @param arg callback argument that would be passed to handler
 */
void sys_untimeout(sys_timeout_handler handler, void *arg)
{
    11f0:	b470      	push	{r4, r5, r6}
	struct sys_timeo *prev_t, *t;

	if (next_timeout == NULL) {
    11f2:	4d10      	ldr	r5, [pc, #64]	; (1234 <sys_untimeout+0x44>)
{
    11f4:	460c      	mov	r4, r1
	if (next_timeout == NULL) {
    11f6:	6829      	ldr	r1, [r5, #0]
    11f8:	b1d1      	cbz	r1, 1230 <sys_untimeout+0x40>
		return;
	}

	for (t = next_timeout, prev_t = NULL; t != NULL; prev_t = t, t = t->next) {
    11fa:	2200      	movs	r2, #0
		if ((t->h == handler) && (t->arg == arg)) {
    11fc:	688b      	ldr	r3, [r1, #8]
    11fe:	4283      	cmp	r3, r0
    1200:	680b      	ldr	r3, [r1, #0]
    1202:	d112      	bne.n	122a <sys_untimeout+0x3a>
    1204:	68ce      	ldr	r6, [r1, #12]
    1206:	42a6      	cmp	r6, r4
    1208:	d10f      	bne.n	122a <sys_untimeout+0x3a>
			/* We have a match */
			/* Unlink from previous in list */
			if (prev_t == NULL) {
    120a:	b962      	cbnz	r2, 1226 <sys_untimeout+0x36>
				next_timeout = t->next;
    120c:	602b      	str	r3, [r5, #0]
			} else {
				prev_t->next = t->next;
			}
			/* If not the last one, add time of this one back to next */
			if (t->next != NULL) {
    120e:	680b      	ldr	r3, [r1, #0]
    1210:	b11b      	cbz	r3, 121a <sys_untimeout+0x2a>
				t->next->time += t->time;
    1212:	685a      	ldr	r2, [r3, #4]
    1214:	6848      	ldr	r0, [r1, #4]
    1216:	4402      	add	r2, r0
    1218:	605a      	str	r2, [r3, #4]
			memp_free(MEMP_SYS_TIMEOUT, t);
			return;
		}
	}
	return;
}
    121a:	bc70      	pop	{r4, r5, r6}
			memp_free(MEMP_SYS_TIMEOUT, t);
    121c:	4b06      	ldr	r3, [pc, #24]	; (1238 <sys_untimeout+0x48>)
    121e:	200a      	movs	r0, #10
    1220:	4718      	bx	r3
    1222:	4619      	mov	r1, r3
    1224:	e7ea      	b.n	11fc <sys_untimeout+0xc>
				prev_t->next = t->next;
    1226:	6013      	str	r3, [r2, #0]
    1228:	e7f1      	b.n	120e <sys_untimeout+0x1e>
	for (t = next_timeout, prev_t = NULL; t != NULL; prev_t = t, t = t->next) {
    122a:	460a      	mov	r2, r1
    122c:	2b00      	cmp	r3, #0
    122e:	d1f8      	bne.n	1222 <sys_untimeout+0x32>
}
    1230:	bc70      	pop	{r4, r5, r6}
    1232:	4770      	bx	lr
    1234:	200000ac 	.word	0x200000ac
    1238:	00004c21 	.word	0x00004c21

0000123c <sys_timeouts_mbox_fetch>:
 *
 * @param mbox the mbox to fetch the message from
 * @param msg the place to store the message
 */
void sys_timeouts_mbox_fetch(sys_mbox_t *mbox, void **msg)
{
    123c:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	struct sys_timeo *  tmptimeout;
	sys_timeout_handler handler;
	void *              arg;

again:
	if (!next_timeout) {
    1240:	4c15      	ldr	r4, [pc, #84]	; (1298 <sys_timeouts_mbox_fetch+0x5c>)
		time_needed = sys_arch_mbox_fetch(mbox, msg, 0);
	} else {
		if (next_timeout->time > 0) {
			time_needed = sys_arch_mbox_fetch(mbox, msg, next_timeout->time);
    1242:	4f16      	ldr	r7, [pc, #88]	; (129c <sys_timeouts_mbox_fetch+0x60>)
{
    1244:	4605      	mov	r5, r0
    1246:	460e      	mov	r6, r1
	if (!next_timeout) {
    1248:	6822      	ldr	r2, [r4, #0]
    124a:	b92a      	cbnz	r2, 1258 <sys_timeouts_mbox_fetch+0x1c>
		time_needed = sys_arch_mbox_fetch(mbox, msg, 0);
    124c:	4631      	mov	r1, r6
    124e:	4628      	mov	r0, r5
    1250:	4b12      	ldr	r3, [pc, #72]	; (129c <sys_timeouts_mbox_fetch+0x60>)
			} else {
				next_timeout->time = 0;
			}
		}
	}
}
    1252:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
		time_needed = sys_arch_mbox_fetch(mbox, msg, 0);
    1256:	4718      	bx	r3
		if (next_timeout->time > 0) {
    1258:	6852      	ldr	r2, [r2, #4]
    125a:	b96a      	cbnz	r2, 1278 <sys_timeouts_mbox_fetch+0x3c>
			tmptimeout   = next_timeout;
    125c:	6821      	ldr	r1, [r4, #0]
			arg          = tmptimeout->arg;
    125e:	e9d1 8902 	ldrd	r8, r9, [r1, #8]
			next_timeout = tmptimeout->next;
    1262:	680b      	ldr	r3, [r1, #0]
    1264:	6023      	str	r3, [r4, #0]
			memp_free(MEMP_SYS_TIMEOUT, tmptimeout);
    1266:	200a      	movs	r0, #10
    1268:	4b0d      	ldr	r3, [pc, #52]	; (12a0 <sys_timeouts_mbox_fetch+0x64>)
    126a:	4798      	blx	r3
			if (handler != NULL) {
    126c:	f1b8 0f00 	cmp.w	r8, #0
    1270:	d0ea      	beq.n	1248 <sys_timeouts_mbox_fetch+0xc>
				handler(arg);
    1272:	4648      	mov	r0, r9
    1274:	47c0      	blx	r8
    1276:	e7e7      	b.n	1248 <sys_timeouts_mbox_fetch+0xc>
			time_needed = sys_arch_mbox_fetch(mbox, msg, next_timeout->time);
    1278:	4631      	mov	r1, r6
    127a:	4628      	mov	r0, r5
    127c:	47b8      	blx	r7
		if (time_needed == SYS_ARCH_TIMEOUT) {
    127e:	1c42      	adds	r2, r0, #1
			time_needed = sys_arch_mbox_fetch(mbox, msg, next_timeout->time);
    1280:	4603      	mov	r3, r0
		if (time_needed == SYS_ARCH_TIMEOUT) {
    1282:	d0eb      	beq.n	125c <sys_timeouts_mbox_fetch+0x20>
			if (time_needed < next_timeout->time) {
    1284:	6822      	ldr	r2, [r4, #0]
    1286:	6850      	ldr	r0, [r2, #4]
    1288:	4298      	cmp	r0, r3
				next_timeout->time -= time_needed;
    128a:	bf8b      	itete	hi
    128c:	1ac0      	subhi	r0, r0, r3
				next_timeout->time = 0;
    128e:	2300      	movls	r3, #0
				next_timeout->time -= time_needed;
    1290:	6050      	strhi	r0, [r2, #4]
				next_timeout->time = 0;
    1292:	6053      	strls	r3, [r2, #4]
}
    1294:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    1298:	200000ac 	.word	0x200000ac
    129c:	00007b55 	.word	0x00007b55
    12a0:	00004c21 	.word	0x00004c21

000012a4 <err_tcp>:
 * The application thread has then to decide what to do.
 *
 * @see tcp.h (struct tcp_pcb.err) for parameters
 */
static void err_tcp(void *arg, err_t err)
{
    12a4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	old_state   = conn->state;
	conn->state = NETCONN_NONE;

	/* Notify the user layer about a connection error. Used to signal
	   select. */
	API_EVENT(conn, NETCONN_EVT_ERROR, 0);
    12a8:	6a83      	ldr	r3, [r0, #40]	; 0x28
	old_state   = conn->state;
    12aa:	7846      	ldrb	r6, [r0, #1]
	conn->last_err = err;
    12ac:	7201      	strb	r1, [r0, #8]
	conn->pcb.tcp = NULL;
    12ae:	2200      	movs	r2, #0
{
    12b0:	4604      	mov	r4, r0
    12b2:	460d      	mov	r5, r1
	conn->pcb.tcp = NULL;
    12b4:	6042      	str	r2, [r0, #4]
	conn->state = NETCONN_NONE;
    12b6:	7042      	strb	r2, [r0, #1]
	API_EVENT(conn, NETCONN_EVT_ERROR, 0);
    12b8:	b10b      	cbz	r3, 12be <err_tcp+0x1a>
    12ba:	2104      	movs	r1, #4
    12bc:	4798      	blx	r3
	/* Try to release selects pending on 'read' or 'write', too.
	   They will get an error if they actually try to read or write. */
	API_EVENT(conn, NETCONN_EVT_RCVPLUS, 0);
    12be:	6aa3      	ldr	r3, [r4, #40]	; 0x28
    12c0:	b11b      	cbz	r3, 12ca <err_tcp+0x26>
    12c2:	2200      	movs	r2, #0
    12c4:	4611      	mov	r1, r2
    12c6:	4620      	mov	r0, r4
    12c8:	4798      	blx	r3
	API_EVENT(conn, NETCONN_EVT_SENDPLUS, 0);
    12ca:	6aa3      	ldr	r3, [r4, #40]	; 0x28
    12cc:	b11b      	cbz	r3, 12d6 <err_tcp+0x32>
    12ce:	2200      	movs	r2, #0
    12d0:	2102      	movs	r1, #2
    12d2:	4620      	mov	r0, r4
    12d4:	4798      	blx	r3

	/* pass NULL-message to recvmbox to wake up pending recv */
	if (sys_mbox_valid(&conn->recvmbox)) {
    12d6:	f104 0810 	add.w	r8, r4, #16
    12da:	4f14      	ldr	r7, [pc, #80]	; (132c <err_tcp+0x88>)
    12dc:	4640      	mov	r0, r8
    12de:	47b8      	blx	r7
    12e0:	b118      	cbz	r0, 12ea <err_tcp+0x46>
		/* use trypost to prevent deadlock */
		sys_mbox_trypost(&conn->recvmbox, NULL);
    12e2:	4b13      	ldr	r3, [pc, #76]	; (1330 <err_tcp+0x8c>)
    12e4:	2100      	movs	r1, #0
    12e6:	4640      	mov	r0, r8
    12e8:	4798      	blx	r3
	}
	/* pass NULL-message to acceptmbox to wake up pending accept */
	if (sys_mbox_valid(&conn->acceptmbox)) {
    12ea:	f104 0814 	add.w	r8, r4, #20
    12ee:	4640      	mov	r0, r8
    12f0:	47b8      	blx	r7
    12f2:	b118      	cbz	r0, 12fc <err_tcp+0x58>
		/* use trypost to preven deadlock */
		sys_mbox_trypost(&conn->acceptmbox, NULL);
    12f4:	4b0e      	ldr	r3, [pc, #56]	; (1330 <err_tcp+0x8c>)
    12f6:	2100      	movs	r1, #0
    12f8:	4640      	mov	r0, r8
    12fa:	4798      	blx	r3
	}

	if ((old_state == NETCONN_WRITE) || (old_state == NETCONN_CLOSE) || (old_state == NETCONN_CONNECT)) {
    12fc:	2e01      	cmp	r6, #1
    12fe:	d002      	beq.n	1306 <err_tcp+0x62>
    1300:	3e03      	subs	r6, #3
    1302:	2e01      	cmp	r6, #1
    1304:	d80f      	bhi.n	1326 <err_tcp+0x82>
		/* calling do_writemore/do_close_internal is not necessary
		   since the pcb has already been deleted! */
		int was_nonblocking_connect = IN_NONBLOCKING_CONNECT(conn);
    1306:	7f23      	ldrb	r3, [r4, #28]
		SET_NONBLOCKING_CONNECT(conn, 0);
    1308:	f023 0204 	bic.w	r2, r3, #4

		if (!was_nonblocking_connect) {
    130c:	f013 0304 	ands.w	r3, r3, #4
		SET_NONBLOCKING_CONNECT(conn, 0);
    1310:	7722      	strb	r2, [r4, #28]
		if (!was_nonblocking_connect) {
    1312:	d108      	bne.n	1326 <err_tcp+0x82>
			/* set error return code */
			LWIP_ASSERT("conn->current_msg != NULL", conn->current_msg != NULL);
			conn->current_msg->err = err;
    1314:	6a62      	ldr	r2, [r4, #36]	; 0x24
    1316:	7115      	strb	r5, [r2, #4]
			conn->current_msg      = NULL;
			/* wake up the waiting task */
			sys_sem_signal(&conn->op_completed);
    1318:	f104 000c 	add.w	r0, r4, #12
			conn->current_msg      = NULL;
    131c:	6263      	str	r3, [r4, #36]	; 0x24
		}
	} else {
		LWIP_ASSERT("conn->current_msg == NULL", conn->current_msg == NULL);
	}
}
    131e:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
			sys_sem_signal(&conn->op_completed);
    1322:	4b04      	ldr	r3, [pc, #16]	; (1334 <err_tcp+0x90>)
    1324:	4718      	bx	r3
}
    1326:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    132a:	bf00      	nop
    132c:	00007be1 	.word	0x00007be1
    1330:	00007aed 	.word	0x00007aed
    1334:	00007a1d 	.word	0x00007a1d

00001338 <recv_udp>:
{
    1338:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
    133c:	4617      	mov	r7, r2
    133e:	f8bd 9028 	ldrh.w	r9, [sp, #40]	; 0x28
    1342:	461d      	mov	r5, r3
	if ((conn == NULL) || !sys_mbox_valid(&conn->recvmbox)) {
    1344:	4606      	mov	r6, r0
    1346:	b128      	cbz	r0, 1354 <recv_udp+0x1c>
    1348:	f100 0810 	add.w	r8, r0, #16
    134c:	4b17      	ldr	r3, [pc, #92]	; (13ac <recv_udp+0x74>)
    134e:	4640      	mov	r0, r8
    1350:	4798      	blx	r3
    1352:	b928      	cbnz	r0, 1360 <recv_udp+0x28>
		pbuf_free(p);
    1354:	4b16      	ldr	r3, [pc, #88]	; (13b0 <recv_udp+0x78>)
    1356:	4638      	mov	r0, r7
}
    1358:	b003      	add	sp, #12
    135a:	e8bd 43f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, lr}
		pbuf_free(p);
    135e:	4718      	bx	r3
	buf = (struct netbuf *)memp_malloc(MEMP_NETBUF);
    1360:	4b14      	ldr	r3, [pc, #80]	; (13b4 <recv_udp+0x7c>)
    1362:	2006      	movs	r0, #6
    1364:	4798      	blx	r3
	if (buf == NULL) {
    1366:	4604      	mov	r4, r0
    1368:	2800      	cmp	r0, #0
    136a:	d0f3      	beq.n	1354 <recv_udp+0x1c>
		buf->ptr = p;
    136c:	e9c0 7700 	strd	r7, r7, [r0]
		ip_addr_set(&buf->addr, addr);
    1370:	b105      	cbz	r5, 1374 <recv_udp+0x3c>
    1372:	682d      	ldr	r5, [r5, #0]
	len = p->tot_len;
    1374:	893a      	ldrh	r2, [r7, #8]
	if (sys_mbox_trypost(&conn->recvmbox, buf) != ERR_OK) {
    1376:	4b10      	ldr	r3, [pc, #64]	; (13b8 <recv_udp+0x80>)
		ip_addr_set(&buf->addr, addr);
    1378:	60a5      	str	r5, [r4, #8]
	if (sys_mbox_trypost(&conn->recvmbox, buf) != ERR_OK) {
    137a:	4621      	mov	r1, r4
		buf->port = port;
    137c:	f8a4 900c 	strh.w	r9, [r4, #12]
	if (sys_mbox_trypost(&conn->recvmbox, buf) != ERR_OK) {
    1380:	4640      	mov	r0, r8
	len = p->tot_len;
    1382:	9201      	str	r2, [sp, #4]
	if (sys_mbox_trypost(&conn->recvmbox, buf) != ERR_OK) {
    1384:	4798      	blx	r3
    1386:	9a01      	ldr	r2, [sp, #4]
    1388:	4601      	mov	r1, r0
    138a:	b128      	cbz	r0, 1398 <recv_udp+0x60>
		netbuf_delete(buf);
    138c:	4b0b      	ldr	r3, [pc, #44]	; (13bc <recv_udp+0x84>)
    138e:	4620      	mov	r0, r4
}
    1390:	b003      	add	sp, #12
    1392:	e8bd 43f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, lr}
		netbuf_delete(buf);
    1396:	4718      	bx	r3
		API_EVENT(conn, NETCONN_EVT_RCVPLUS, len);
    1398:	6ab3      	ldr	r3, [r6, #40]	; 0x28
    139a:	b123      	cbz	r3, 13a6 <recv_udp+0x6e>
    139c:	4630      	mov	r0, r6
}
    139e:	b003      	add	sp, #12
    13a0:	e8bd 43f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, lr}
		API_EVENT(conn, NETCONN_EVT_RCVPLUS, len);
    13a4:	4718      	bx	r3
}
    13a6:	b003      	add	sp, #12
    13a8:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    13ac:	00007be1 	.word	0x00007be1
    13b0:	000030e1 	.word	0x000030e1
    13b4:	00004c05 	.word	0x00004c05
    13b8:	00007aed 	.word	0x00007aed
    13bc:	00000d79 	.word	0x00000d79

000013c0 <setup_tcp>:
 * and their arguments.
 *
 * @param conn the TCP netconn to setup
 */
static void setup_tcp(struct netconn *conn)
{
    13c0:	b507      	push	{r0, r1, r2, lr}
	struct tcp_pcb *pcb;

	pcb = conn->pcb.tcp;
	tcp_arg(pcb, conn);
    13c2:	4b0c      	ldr	r3, [pc, #48]	; (13f4 <setup_tcp+0x34>)
{
    13c4:	4601      	mov	r1, r0
	pcb = conn->pcb.tcp;
    13c6:	6840      	ldr	r0, [r0, #4]
	tcp_arg(pcb, conn);
    13c8:	9001      	str	r0, [sp, #4]
    13ca:	4798      	blx	r3
	tcp_recv(pcb, recv_tcp);
    13cc:	9801      	ldr	r0, [sp, #4]
    13ce:	490a      	ldr	r1, [pc, #40]	; (13f8 <setup_tcp+0x38>)
    13d0:	4b0a      	ldr	r3, [pc, #40]	; (13fc <setup_tcp+0x3c>)
    13d2:	4798      	blx	r3
	tcp_sent(pcb, sent_tcp);
    13d4:	9801      	ldr	r0, [sp, #4]
    13d6:	490a      	ldr	r1, [pc, #40]	; (1400 <setup_tcp+0x40>)
    13d8:	4b0a      	ldr	r3, [pc, #40]	; (1404 <setup_tcp+0x44>)
    13da:	4798      	blx	r3
	tcp_poll(pcb, poll_tcp, 4);
    13dc:	9801      	ldr	r0, [sp, #4]
    13de:	490a      	ldr	r1, [pc, #40]	; (1408 <setup_tcp+0x48>)
    13e0:	4b0a      	ldr	r3, [pc, #40]	; (140c <setup_tcp+0x4c>)
    13e2:	2204      	movs	r2, #4
    13e4:	4798      	blx	r3
	tcp_err(pcb, err_tcp);
    13e6:	490a      	ldr	r1, [pc, #40]	; (1410 <setup_tcp+0x50>)
    13e8:	9801      	ldr	r0, [sp, #4]
    13ea:	4b0a      	ldr	r3, [pc, #40]	; (1414 <setup_tcp+0x54>)
}
    13ec:	b003      	add	sp, #12
    13ee:	f85d eb04 	ldr.w	lr, [sp], #4
	tcp_err(pcb, err_tcp);
    13f2:	4718      	bx	r3
    13f4:	00006b31 	.word	0x00006b31
    13f8:	00001529 	.word	0x00001529
    13fc:	00006b35 	.word	0x00006b35
    1400:	000016a9 	.word	0x000016a9
    1404:	00006b3b 	.word	0x00006b3b
    1408:	000016f9 	.word	0x000016f9
    140c:	00006b49 	.word	0x00006b49
    1410:	000012a5 	.word	0x000012a5
    1414:	00006b3f 	.word	0x00006b3f

00001418 <do_close_internal>:
	LWIP_ASSERT("this is for tcp netconns only", (conn->type == NETCONN_TCP));
	LWIP_ASSERT("conn must be in state NETCONN_CLOSE", (conn->state == NETCONN_CLOSE));
	LWIP_ASSERT("pcb already closed", (conn->pcb.tcp != NULL));
	LWIP_ASSERT("conn->current_msg != NULL", conn->current_msg != NULL);

	shut    = conn->current_msg->msg.sd.shut;
    1418:	6a43      	ldr	r3, [r0, #36]	; 0x24
{
    141a:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	shut    = conn->current_msg->msg.sd.shut;
    141e:	7a1d      	ldrb	r5, [r3, #8]
	shut_tx = shut & NETCONN_SHUT_WR;
	/* shutting down both ends is the same as closing */
	close = shut == NETCONN_SHUT_RDWR;

	/* Set back some callback pointers */
	if (close) {
    1420:	2d03      	cmp	r5, #3
{
    1422:	4604      	mov	r4, r0
	shut_rx = shut & NETCONN_SHUT_RD;
    1424:	f005 0701 	and.w	r7, r5, #1
	shut_tx = shut & NETCONN_SHUT_WR;
    1428:	f005 0602 	and.w	r6, r5, #2
	if (close) {
    142c:	d103      	bne.n	1436 <do_close_internal+0x1e>
		tcp_arg(conn->pcb.tcp, NULL);
    142e:	6840      	ldr	r0, [r0, #4]
    1430:	4b31      	ldr	r3, [pc, #196]	; (14f8 <do_close_internal+0xe0>)
    1432:	2100      	movs	r1, #0
    1434:	4798      	blx	r3
	}
	if (conn->pcb.tcp->state == LISTEN) {
    1436:	6860      	ldr	r0, [r4, #4]
    1438:	7e03      	ldrb	r3, [r0, #24]
    143a:	2b01      	cmp	r3, #1
    143c:	d10a      	bne.n	1454 <do_close_internal+0x3c>
		tcp_accept(conn->pcb.tcp, NULL);
    143e:	4b2f      	ldr	r3, [pc, #188]	; (14fc <do_close_internal+0xe4>)
    1440:	2100      	movs	r1, #0
    1442:	4798      	blx	r3
			tcp_poll(conn->pcb.tcp, NULL, 4);
			tcp_err(conn->pcb.tcp, NULL);
		}
	}
	/* Try to close the connection */
	if (close) {
    1444:	2d03      	cmp	r5, #3
    1446:	d01d      	beq.n	1484 <do_close_internal+0x6c>
		err = tcp_close(conn->pcb.tcp);
	} else {
		err = tcp_shutdown(conn->pcb.tcp, shut_rx, shut_tx);
    1448:	6860      	ldr	r0, [r4, #4]
    144a:	4b2d      	ldr	r3, [pc, #180]	; (1500 <do_close_internal+0xe8>)
    144c:	4632      	mov	r2, r6
    144e:	4639      	mov	r1, r7
    1450:	4798      	blx	r3
    1452:	e01a      	b.n	148a <do_close_internal+0x72>
		if (shut_rx) {
    1454:	b137      	cbz	r7, 1464 <do_close_internal+0x4c>
			tcp_recv(conn->pcb.tcp, NULL);
    1456:	4b2b      	ldr	r3, [pc, #172]	; (1504 <do_close_internal+0xec>)
    1458:	2100      	movs	r1, #0
    145a:	4798      	blx	r3
			tcp_accept(conn->pcb.tcp, NULL);
    145c:	6860      	ldr	r0, [r4, #4]
    145e:	4b27      	ldr	r3, [pc, #156]	; (14fc <do_close_internal+0xe4>)
    1460:	2100      	movs	r1, #0
    1462:	4798      	blx	r3
		if (shut_tx) {
    1464:	b11e      	cbz	r6, 146e <do_close_internal+0x56>
			tcp_sent(conn->pcb.tcp, NULL);
    1466:	6860      	ldr	r0, [r4, #4]
    1468:	4b27      	ldr	r3, [pc, #156]	; (1508 <do_close_internal+0xf0>)
    146a:	2100      	movs	r1, #0
    146c:	4798      	blx	r3
		if (close) {
    146e:	2d03      	cmp	r5, #3
    1470:	d1ea      	bne.n	1448 <do_close_internal+0x30>
			tcp_poll(conn->pcb.tcp, NULL, 4);
    1472:	6860      	ldr	r0, [r4, #4]
    1474:	4b25      	ldr	r3, [pc, #148]	; (150c <do_close_internal+0xf4>)
    1476:	2100      	movs	r1, #0
    1478:	2204      	movs	r2, #4
    147a:	4798      	blx	r3
			tcp_err(conn->pcb.tcp, NULL);
    147c:	6860      	ldr	r0, [r4, #4]
    147e:	4b24      	ldr	r3, [pc, #144]	; (1510 <do_close_internal+0xf8>)
    1480:	2100      	movs	r1, #0
    1482:	4798      	blx	r3
		err = tcp_close(conn->pcb.tcp);
    1484:	6860      	ldr	r0, [r4, #4]
    1486:	4b23      	ldr	r3, [pc, #140]	; (1514 <do_close_internal+0xfc>)
    1488:	4798      	blx	r3
	}
	if (err == ERR_OK) {
    148a:	bb10      	cbnz	r0, 14d2 <do_close_internal+0xba>
		/* Closing succeeded */
		conn->current_msg->err = ERR_OK;
    148c:	6a63      	ldr	r3, [r4, #36]	; 0x24
		conn->current_msg      = NULL;
		conn->state            = NETCONN_NONE;
		if (close) {
    148e:	2d03      	cmp	r5, #3
		conn->current_msg->err = ERR_OK;
    1490:	7118      	strb	r0, [r3, #4]
		conn->current_msg      = NULL;
    1492:	6260      	str	r0, [r4, #36]	; 0x24
		conn->state            = NETCONN_NONE;
    1494:	7060      	strb	r0, [r4, #1]
		if (close) {
    1496:	d10d      	bne.n	14b4 <do_close_internal+0x9c>
			/* Set back some callback pointers as conn is going away */
			conn->pcb.tcp = NULL;
			/* Trigger select() in socket layer. Make sure everybody notices activity
			 on the connection, error first! */
			API_EVENT(conn, NETCONN_EVT_ERROR, 0);
    1498:	6aa3      	ldr	r3, [r4, #40]	; 0x28
			conn->pcb.tcp = NULL;
    149a:	6060      	str	r0, [r4, #4]
			API_EVENT(conn, NETCONN_EVT_ERROR, 0);
    149c:	b11b      	cbz	r3, 14a6 <do_close_internal+0x8e>
    149e:	4602      	mov	r2, r0
    14a0:	2104      	movs	r1, #4
    14a2:	4620      	mov	r0, r4
    14a4:	4798      	blx	r3
		}
		if (shut_rx) {
			API_EVENT(conn, NETCONN_EVT_RCVPLUS, 0);
    14a6:	6aa3      	ldr	r3, [r4, #40]	; 0x28
    14a8:	b133      	cbz	r3, 14b8 <do_close_internal+0xa0>
    14aa:	2200      	movs	r2, #0
    14ac:	4611      	mov	r1, r2
    14ae:	4620      	mov	r0, r4
    14b0:	4798      	blx	r3
    14b2:	e001      	b.n	14b8 <do_close_internal+0xa0>
		if (shut_rx) {
    14b4:	2f00      	cmp	r7, #0
    14b6:	d1f6      	bne.n	14a6 <do_close_internal+0x8e>
		}
		if (shut_tx) {
    14b8:	b12e      	cbz	r6, 14c6 <do_close_internal+0xae>
			API_EVENT(conn, NETCONN_EVT_SENDPLUS, 0);
    14ba:	6aa3      	ldr	r3, [r4, #40]	; 0x28
    14bc:	b11b      	cbz	r3, 14c6 <do_close_internal+0xae>
    14be:	2200      	movs	r2, #0
    14c0:	2102      	movs	r1, #2
    14c2:	4620      	mov	r0, r4
    14c4:	4798      	blx	r3
		}
		/* wake up the application task */
		sys_sem_signal(&conn->op_completed);
    14c6:	f104 000c 	add.w	r0, r4, #12
    14ca:	4b13      	ldr	r3, [pc, #76]	; (1518 <do_close_internal+0x100>)
		tcp_arg(conn->pcb.tcp, conn);
		/* don't restore recv callback: we don't want to receive any more data */
	}
	/* If closing didn't succeed, we get called again either
	   from poll_tcp or from sent_tcp */
}
    14cc:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
		sys_sem_signal(&conn->op_completed);
    14d0:	4718      	bx	r3
		tcp_sent(conn->pcb.tcp, sent_tcp);
    14d2:	6860      	ldr	r0, [r4, #4]
    14d4:	4911      	ldr	r1, [pc, #68]	; (151c <do_close_internal+0x104>)
    14d6:	4b0c      	ldr	r3, [pc, #48]	; (1508 <do_close_internal+0xf0>)
    14d8:	4798      	blx	r3
		tcp_poll(conn->pcb.tcp, poll_tcp, 4);
    14da:	6860      	ldr	r0, [r4, #4]
    14dc:	4910      	ldr	r1, [pc, #64]	; (1520 <do_close_internal+0x108>)
    14de:	4b0b      	ldr	r3, [pc, #44]	; (150c <do_close_internal+0xf4>)
    14e0:	2204      	movs	r2, #4
    14e2:	4798      	blx	r3
		tcp_err(conn->pcb.tcp, err_tcp);
    14e4:	6860      	ldr	r0, [r4, #4]
    14e6:	490f      	ldr	r1, [pc, #60]	; (1524 <do_close_internal+0x10c>)
    14e8:	4b09      	ldr	r3, [pc, #36]	; (1510 <do_close_internal+0xf8>)
    14ea:	4798      	blx	r3
		tcp_arg(conn->pcb.tcp, conn);
    14ec:	6860      	ldr	r0, [r4, #4]
    14ee:	4b02      	ldr	r3, [pc, #8]	; (14f8 <do_close_internal+0xe0>)
    14f0:	4621      	mov	r1, r4
}
    14f2:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
		tcp_arg(conn->pcb.tcp, conn);
    14f6:	4718      	bx	r3
    14f8:	00006b31 	.word	0x00006b31
    14fc:	00006b45 	.word	0x00006b45
    1500:	00007175 	.word	0x00007175
    1504:	00006b35 	.word	0x00006b35
    1508:	00006b3b 	.word	0x00006b3b
    150c:	00006b49 	.word	0x00006b49
    1510:	00006b3f 	.word	0x00006b3f
    1514:	0000702d 	.word	0x0000702d
    1518:	00007a1d 	.word	0x00007a1d
    151c:	000016a9 	.word	0x000016a9
    1520:	000016f9 	.word	0x000016f9
    1524:	000012a5 	.word	0x000012a5

00001528 <recv_tcp>:
{
    1528:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    152c:	4688      	mov	r8, r1
    152e:	4615      	mov	r5, r2
    1530:	461f      	mov	r7, r3
	if (conn == NULL) {
    1532:	4606      	mov	r6, r0
    1534:	b350      	cbz	r0, 158c <recv_tcp+0x64>
	if (!sys_mbox_valid(&conn->recvmbox)) {
    1536:	f100 0910 	add.w	r9, r0, #16
    153a:	4b17      	ldr	r3, [pc, #92]	; (1598 <recv_tcp+0x70>)
    153c:	4648      	mov	r0, r9
    153e:	4798      	blx	r3
    1540:	4604      	mov	r4, r0
    1542:	b960      	cbnz	r0, 155e <recv_tcp+0x36>
		if (p != NULL) {
    1544:	b91d      	cbnz	r5, 154e <recv_tcp+0x26>
		return ERR_OK;
    1546:	2400      	movs	r4, #0
}
    1548:	4620      	mov	r0, r4
    154a:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
			tcp_recved(pcb, p->tot_len);
    154e:	4640      	mov	r0, r8
    1550:	8929      	ldrh	r1, [r5, #8]
    1552:	4b12      	ldr	r3, [pc, #72]	; (159c <recv_tcp+0x74>)
    1554:	4798      	blx	r3
			pbuf_free(p);
    1556:	4b12      	ldr	r3, [pc, #72]	; (15a0 <recv_tcp+0x78>)
    1558:	4628      	mov	r0, r5
    155a:	4798      	blx	r3
    155c:	e7f4      	b.n	1548 <recv_tcp+0x20>
	NETCONN_SET_SAFE_ERR(conn, err);
    155e:	f996 3008 	ldrsb.w	r3, [r6, #8]
    1562:	3309      	adds	r3, #9
    1564:	bfa8      	it	ge
    1566:	7237      	strbge	r7, [r6, #8]
	if (p != NULL) {
    1568:	b175      	cbz	r5, 1588 <recv_tcp+0x60>
		len = p->tot_len;
    156a:	892f      	ldrh	r7, [r5, #8]
	if (sys_mbox_trypost(&conn->recvmbox, p) != ERR_OK) {
    156c:	4b0d      	ldr	r3, [pc, #52]	; (15a4 <recv_tcp+0x7c>)
    156e:	4629      	mov	r1, r5
    1570:	4648      	mov	r0, r9
    1572:	4798      	blx	r3
    1574:	4604      	mov	r4, r0
    1576:	b960      	cbnz	r0, 1592 <recv_tcp+0x6a>
		API_EVENT(conn, NETCONN_EVT_RCVPLUS, len);
    1578:	6ab3      	ldr	r3, [r6, #40]	; 0x28
    157a:	2b00      	cmp	r3, #0
    157c:	d0e3      	beq.n	1546 <recv_tcp+0x1e>
    157e:	4601      	mov	r1, r0
    1580:	463a      	mov	r2, r7
    1582:	4630      	mov	r0, r6
    1584:	4798      	blx	r3
    1586:	e7df      	b.n	1548 <recv_tcp+0x20>
		len = 0;
    1588:	462f      	mov	r7, r5
    158a:	e7ef      	b.n	156c <recv_tcp+0x44>
		return ERR_VAL;
    158c:	f06f 0405 	mvn.w	r4, #5
    1590:	e7da      	b.n	1548 <recv_tcp+0x20>
		return ERR_MEM;
    1592:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
    1596:	e7d7      	b.n	1548 <recv_tcp+0x20>
    1598:	00007be1 	.word	0x00007be1
    159c:	00006a85 	.word	0x00006a85
    15a0:	000030e1 	.word	0x000030e1
    15a4:	00007aed 	.word	0x00007aed

000015a8 <do_writemore.isra.0>:
 *
 * @param conn netconn (that is currently in state NETCONN_WRITE) to process
 * @return ERR_OK
 *         ERR_MEM if LWIP_TCPIP_CORE_LOCKING=1 and sending hasn't yet finished
 */
static err_t do_writemore(struct netconn *conn)
    15a8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    15ac:	4604      	mov	r4, r0
	err_t  err;
	void * dataptr;
	u16_t  len, available;
	u8_t   write_finished = 0;
	size_t diff;
	u8_t   dontblock = netconn_is_nonblocking(conn) || (conn->current_msg->msg.w.apiflags & NETCONN_DONTBLOCK);
    15ae:	6a40      	ldr	r0, [r0, #36]	; 0x24
    15b0:	7f26      	ldrb	r6, [r4, #28]
    15b2:	7c03      	ldrb	r3, [r0, #16]
			conn->current_msg->msg.w.len = conn->write_offset;
		}
	} else
#endif /* LWIP_SO_SNDTIMEO */
	{
		dataptr = (u8_t *)conn->current_msg->msg.w.dataptr + conn->write_offset;
    15b4:	6a25      	ldr	r5, [r4, #32]
    15b6:	6881      	ldr	r1, [r0, #8]
    15b8:	f003 0204 	and.w	r2, r3, #4
    15bc:	f006 0602 	and.w	r6, r6, #2
    15c0:	4316      	orrs	r6, r2
		diff    = conn->current_msg->msg.w.len - conn->write_offset;
    15c2:	68c2      	ldr	r2, [r0, #12]
#endif
			apiflags |= TCP_WRITE_FLAG_MORE;
		} else {
			len = (u16_t)diff;
		}
		available = tcp_sndbuf(conn->pcb.tcp);
    15c4:	6860      	ldr	r0, [r4, #4]
		diff    = conn->current_msg->msg.w.len - conn->write_offset;
    15c6:	1b52      	subs	r2, r2, r5
		if (diff > 0xffffUL) { /* max_u16_t */
    15c8:	f5b2 3f80 	cmp.w	r2, #65536	; 0x10000
		dataptr = (u8_t *)conn->current_msg->msg.w.dataptr + conn->write_offset;
    15cc:	4429      	add	r1, r5
		available = tcp_sndbuf(conn->pcb.tcp);
    15ce:	f8b0 5066 	ldrh.w	r5, [r0, #102]	; 0x66
			len = 0xffff;
    15d2:	bf2a      	itet	cs
    15d4:	f64f 72ff 	movwcs	r2, #65535	; 0xffff
			len = (u16_t)diff;
    15d8:	b292      	uxthcc	r2, r2
			apiflags |= TCP_WRITE_FLAG_MORE;
    15da:	f043 0302 	orrcs.w	r3, r3, #2
		if (available < len) {
    15de:	4295      	cmp	r5, r2
    15e0:	d230      	bcs.n	1644 <do_writemore.isra.0+0x9c>
			/* don't try to write more than sendbuf */
			len = available;
			if (dontblock) {
    15e2:	b11e      	cbz	r6, 15ec <do_writemore.isra.0+0x44>
				if (!len) {
    15e4:	b925      	cbnz	r5, 15f0 <do_writemore.isra.0+0x48>
					err = ERR_WOULDBLOCK;
    15e6:	f06f 0706 	mvn.w	r7, #6
    15ea:	e00a      	b.n	1602 <do_writemore.isra.0+0x5a>
				}
			} else {
#if LWIP_TCPIP_CORE_LOCKING
				conn->flags |= NETCONN_FLAG_WRITE_DELAYED;
#endif
				apiflags |= TCP_WRITE_FLAG_MORE;
    15ec:	f043 0302 	orr.w	r3, r3, #2
			}
		}
		LWIP_ASSERT("do_writemore: invalid length!", ((conn->write_offset + len) <= conn->current_msg->msg.w.len));
		err = tcp_write(conn->pcb.tcp, dataptr, len, apiflags);
    15f0:	4f2a      	ldr	r7, [pc, #168]	; (169c <do_writemore.isra.0+0xf4>)
    15f2:	462a      	mov	r2, r5
    15f4:	47b8      	blx	r7
		/* if OK or memory error, check available space */
		if ((err == ERR_OK) || (err == ERR_MEM)) {
    15f6:	1c43      	adds	r3, r0, #1
    15f8:	b2db      	uxtb	r3, r3
    15fa:	2b01      	cmp	r3, #1
		err = tcp_write(conn->pcb.tcp, dataptr, len, apiflags);
    15fc:	4607      	mov	r7, r0
		if ((err == ERR_OK) || (err == ERR_MEM)) {
    15fe:	d83e      	bhi.n	167e <do_writemore.isra.0+0xd6>
		err_mem:
			if (dontblock && (len < conn->current_msg->msg.w.len)) {
    1600:	b316      	cbz	r6, 1648 <do_writemore.isra.0+0xa0>
    1602:	6a63      	ldr	r3, [r4, #36]	; 0x24
    1604:	68db      	ldr	r3, [r3, #12]
    1606:	429d      	cmp	r5, r3
    1608:	d21e      	bcs.n	1648 <do_writemore.isra.0+0xa0>
				/* non-blocking write did not write everything: mark the pcb non-writable
				   and let poll_tcp check writable space to mark the pcb writable again */
				API_EVENT(conn, NETCONN_EVT_SENDMINUS, len);
    160a:	6aa3      	ldr	r3, [r4, #40]	; 0x28
    160c:	b11b      	cbz	r3, 1616 <do_writemore.isra.0+0x6e>
    160e:	462a      	mov	r2, r5
    1610:	2103      	movs	r1, #3
    1612:	4620      	mov	r0, r4
    1614:	4798      	blx	r3
				conn->flags |= NETCONN_FLAG_CHECK_WRITESPACE;
    1616:	7f23      	ldrb	r3, [r4, #28]
    1618:	f043 0310 	orr.w	r3, r3, #16
    161c:	7723      	strb	r3, [r4, #28]
				   let select mark this pcb as non-writable. */
				API_EVENT(conn, NETCONN_EVT_SENDMINUS, len);
			}
		}

		if (err == ERR_OK) {
    161e:	bb37      	cbnz	r7, 166e <do_writemore.isra.0+0xc6>
			conn->write_offset += len;
    1620:	6a22      	ldr	r2, [r4, #32]
			if ((conn->write_offset == conn->current_msg->msg.w.len) || dontblock) {
    1622:	6a63      	ldr	r3, [r4, #36]	; 0x24
			conn->write_offset += len;
    1624:	4415      	add	r5, r2
			if ((conn->write_offset == conn->current_msg->msg.w.len) || dontblock) {
    1626:	68da      	ldr	r2, [r3, #12]
			conn->write_offset += len;
    1628:	6225      	str	r5, [r4, #32]
			if ((conn->write_offset == conn->current_msg->msg.w.len) || dontblock) {
    162a:	4295      	cmp	r5, r2
    162c:	d000      	beq.n	1630 <do_writemore.isra.0+0x88>
    162e:	b11e      	cbz	r6, 1638 <do_writemore.isra.0+0x90>
				/* return sent length */
				conn->current_msg->msg.w.len = conn->write_offset;
    1630:	60dd      	str	r5, [r3, #12]
				/* everything was written */
				write_finished     = 1;
				conn->write_offset = 0;
    1632:	2300      	movs	r3, #0
    1634:	6223      	str	r3, [r4, #32]
				write_finished     = 1;
    1636:	2601      	movs	r6, #1
			}
			tcp_output(conn->pcb.tcp);
    1638:	6860      	ldr	r0, [r4, #4]
    163a:	4b19      	ldr	r3, [pc, #100]	; (16a0 <do_writemore.isra.0+0xf8>)
    163c:	4798      	blx	r3
			   the error to the application thread. */
			write_finished               = 1;
			conn->current_msg->msg.w.len = 0;
		}
	}
	if (write_finished) {
    163e:	bb0e      	cbnz	r6, 1684 <do_writemore.isra.0+0xdc>
#if LWIP_TCPIP_CORE_LOCKING
	else
		return ERR_MEM;
#endif
	return ERR_OK;
}
    1640:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    1644:	4615      	mov	r5, r2
    1646:	e7d3      	b.n	15f0 <do_writemore.isra.0+0x48>
			} else if ((tcp_sndbuf(conn->pcb.tcp) <= TCP_SNDLOWAT)
    1648:	6863      	ldr	r3, [r4, #4]
    164a:	f8b3 1066 	ldrh.w	r1, [r3, #102]	; 0x66
    164e:	f640 3267 	movw	r2, #2919	; 0xb67
    1652:	4291      	cmp	r1, r2
    1654:	d903      	bls.n	165e <do_writemore.isra.0+0xb6>
			           || (tcp_sndqueuelen(conn->pcb.tcp) >= TCP_SNDQUEUELOWAT)) {
    1656:	f8b3 3068 	ldrh.w	r3, [r3, #104]	; 0x68
    165a:	2b04      	cmp	r3, #4
    165c:	d9df      	bls.n	161e <do_writemore.isra.0+0x76>
				API_EVENT(conn, NETCONN_EVT_SENDMINUS, len);
    165e:	6aa3      	ldr	r3, [r4, #40]	; 0x28
    1660:	2b00      	cmp	r3, #0
    1662:	d0dc      	beq.n	161e <do_writemore.isra.0+0x76>
    1664:	462a      	mov	r2, r5
    1666:	2103      	movs	r1, #3
    1668:	4620      	mov	r0, r4
    166a:	4798      	blx	r3
    166c:	e7d7      	b.n	161e <do_writemore.isra.0+0x76>
		} else if ((err == ERR_MEM) && !dontblock) {
    166e:	1c7b      	adds	r3, r7, #1
    1670:	d105      	bne.n	167e <do_writemore.isra.0+0xd6>
    1672:	b926      	cbnz	r6, 167e <do_writemore.isra.0+0xd6>
			tcp_output(conn->pcb.tcp);
    1674:	6860      	ldr	r0, [r4, #4]
    1676:	4b0a      	ldr	r3, [pc, #40]	; (16a0 <do_writemore.isra.0+0xf8>)
}
    1678:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
			tcp_output(conn->pcb.tcp);
    167c:	4718      	bx	r3
			conn->current_msg->msg.w.len = 0;
    167e:	6a63      	ldr	r3, [r4, #36]	; 0x24
    1680:	2200      	movs	r2, #0
    1682:	60da      	str	r2, [r3, #12]
		conn->current_msg->err = err;
    1684:	6a63      	ldr	r3, [r4, #36]	; 0x24
    1686:	711f      	strb	r7, [r3, #4]
		conn->current_msg      = NULL;
    1688:	2300      	movs	r3, #0
    168a:	6263      	str	r3, [r4, #36]	; 0x24
		conn->state            = NETCONN_NONE;
    168c:	7063      	strb	r3, [r4, #1]
			sys_sem_signal(&conn->op_completed);
    168e:	f104 000c 	add.w	r0, r4, #12
    1692:	4b04      	ldr	r3, [pc, #16]	; (16a4 <do_writemore.isra.0+0xfc>)
}
    1694:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
			sys_sem_signal(&conn->op_completed);
    1698:	4718      	bx	r3
    169a:	bf00      	nop
    169c:	00001ff9 	.word	0x00001ff9
    16a0:	000024a1 	.word	0x000024a1
    16a4:	00007a1d 	.word	0x00007a1d

000016a8 <sent_tcp>:
{
    16a8:	b538      	push	{r3, r4, r5, lr}
	if (conn->state == NETCONN_WRITE) {
    16aa:	7843      	ldrb	r3, [r0, #1]
    16ac:	2b01      	cmp	r3, #1
{
    16ae:	4604      	mov	r4, r0
    16b0:	4615      	mov	r5, r2
	if (conn->state == NETCONN_WRITE) {
    16b2:	d119      	bne.n	16e8 <sent_tcp+0x40>
		do_writemore(conn);
    16b4:	4b0e      	ldr	r3, [pc, #56]	; (16f0 <sent_tcp+0x48>)
		do_close_internal(conn);
    16b6:	4798      	blx	r3
		if ((conn->pcb.tcp != NULL) && (tcp_sndbuf(conn->pcb.tcp) > TCP_SNDLOWAT)
    16b8:	6863      	ldr	r3, [r4, #4]
    16ba:	b19b      	cbz	r3, 16e4 <sent_tcp+0x3c>
    16bc:	f8b3 1066 	ldrh.w	r1, [r3, #102]	; 0x66
    16c0:	f640 3267 	movw	r2, #2919	; 0xb67
    16c4:	4291      	cmp	r1, r2
    16c6:	d90d      	bls.n	16e4 <sent_tcp+0x3c>
		    && (tcp_sndqueuelen(conn->pcb.tcp) < TCP_SNDQUEUELOWAT)) {
    16c8:	f8b3 3068 	ldrh.w	r3, [r3, #104]	; 0x68
    16cc:	2b04      	cmp	r3, #4
    16ce:	d809      	bhi.n	16e4 <sent_tcp+0x3c>
			conn->flags &= ~NETCONN_FLAG_CHECK_WRITESPACE;
    16d0:	7f23      	ldrb	r3, [r4, #28]
    16d2:	f023 0310 	bic.w	r3, r3, #16
    16d6:	7723      	strb	r3, [r4, #28]
			API_EVENT(conn, NETCONN_EVT_SENDPLUS, len);
    16d8:	6aa3      	ldr	r3, [r4, #40]	; 0x28
    16da:	b11b      	cbz	r3, 16e4 <sent_tcp+0x3c>
    16dc:	462a      	mov	r2, r5
    16de:	2102      	movs	r1, #2
    16e0:	4620      	mov	r0, r4
    16e2:	4798      	blx	r3
}
    16e4:	2000      	movs	r0, #0
    16e6:	bd38      	pop	{r3, r4, r5, pc}
	} else if (conn->state == NETCONN_CLOSE) {
    16e8:	2b04      	cmp	r3, #4
    16ea:	d1e5      	bne.n	16b8 <sent_tcp+0x10>
		do_close_internal(conn);
    16ec:	4b01      	ldr	r3, [pc, #4]	; (16f4 <sent_tcp+0x4c>)
    16ee:	e7e2      	b.n	16b6 <sent_tcp+0xe>
    16f0:	000015a9 	.word	0x000015a9
    16f4:	00001419 	.word	0x00001419

000016f8 <poll_tcp>:
{
    16f8:	b510      	push	{r4, lr}
	if (conn->state == NETCONN_WRITE) {
    16fa:	7843      	ldrb	r3, [r0, #1]
    16fc:	2b01      	cmp	r3, #1
{
    16fe:	4604      	mov	r4, r0
	if (conn->state == NETCONN_WRITE) {
    1700:	d11b      	bne.n	173a <poll_tcp+0x42>
		do_writemore(conn);
    1702:	4b10      	ldr	r3, [pc, #64]	; (1744 <poll_tcp+0x4c>)
		do_close_internal(conn);
    1704:	4798      	blx	r3
	if (conn->flags & NETCONN_FLAG_CHECK_WRITESPACE) {
    1706:	7f23      	ldrb	r3, [r4, #28]
    1708:	06da      	lsls	r2, r3, #27
    170a:	d514      	bpl.n	1736 <poll_tcp+0x3e>
		if ((conn->pcb.tcp != NULL) && (tcp_sndbuf(conn->pcb.tcp) > TCP_SNDLOWAT)
    170c:	6862      	ldr	r2, [r4, #4]
    170e:	b192      	cbz	r2, 1736 <poll_tcp+0x3e>
    1710:	f8b2 0066 	ldrh.w	r0, [r2, #102]	; 0x66
    1714:	f640 3167 	movw	r1, #2919	; 0xb67
    1718:	4288      	cmp	r0, r1
    171a:	d90c      	bls.n	1736 <poll_tcp+0x3e>
		    && (tcp_sndqueuelen(conn->pcb.tcp) < TCP_SNDQUEUELOWAT)) {
    171c:	f8b2 2068 	ldrh.w	r2, [r2, #104]	; 0x68
    1720:	2a04      	cmp	r2, #4
    1722:	d808      	bhi.n	1736 <poll_tcp+0x3e>
			conn->flags &= ~NETCONN_FLAG_CHECK_WRITESPACE;
    1724:	f023 0310 	bic.w	r3, r3, #16
    1728:	7723      	strb	r3, [r4, #28]
			API_EVENT(conn, NETCONN_EVT_SENDPLUS, 0);
    172a:	6aa3      	ldr	r3, [r4, #40]	; 0x28
    172c:	b11b      	cbz	r3, 1736 <poll_tcp+0x3e>
    172e:	2200      	movs	r2, #0
    1730:	2102      	movs	r1, #2
    1732:	4620      	mov	r0, r4
    1734:	4798      	blx	r3
}
    1736:	2000      	movs	r0, #0
    1738:	bd10      	pop	{r4, pc}
	} else if (conn->state == NETCONN_CLOSE) {
    173a:	2b04      	cmp	r3, #4
    173c:	d1e3      	bne.n	1706 <poll_tcp+0xe>
		do_close_internal(conn);
    173e:	4b02      	ldr	r3, [pc, #8]	; (1748 <poll_tcp+0x50>)
    1740:	e7e0      	b.n	1704 <poll_tcp+0xc>
    1742:	bf00      	nop
    1744:	000015a9 	.word	0x000015a9
    1748:	00001419 	.word	0x00001419

0000174c <do_newconn>:
{
    174c:	b570      	push	{r4, r5, r6, lr}
	msg->err = ERR_OK;
    174e:	2300      	movs	r3, #0
	if (msg->conn->pcb.tcp == NULL) {
    1750:	6805      	ldr	r5, [r0, #0]
	msg->err = ERR_OK;
    1752:	7103      	strb	r3, [r0, #4]
	if (msg->conn->pcb.tcp == NULL) {
    1754:	686b      	ldr	r3, [r5, #4]
{
    1756:	4604      	mov	r4, r0
	if (msg->conn->pcb.tcp == NULL) {
    1758:	b9bb      	cbnz	r3, 178a <do_newconn+0x3e>
	switch (NETCONNTYPE_GROUP(msg->conn->type)) {
    175a:	782b      	ldrb	r3, [r5, #0]
    175c:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
    1760:	2b10      	cmp	r3, #16
    1762:	d018      	beq.n	1796 <do_newconn+0x4a>
    1764:	2b20      	cmp	r3, #32
    1766:	d120      	bne.n	17aa <do_newconn+0x5e>
		msg->conn->pcb.udp = udp_new();
    1768:	4b11      	ldr	r3, [pc, #68]	; (17b0 <do_newconn+0x64>)
    176a:	4798      	blx	r3
		if (msg->conn->pcb.udp == NULL) {
    176c:	6822      	ldr	r2, [r4, #0]
		msg->conn->pcb.udp = udp_new();
    176e:	6068      	str	r0, [r5, #4]
		if (msg->conn->pcb.udp == NULL) {
    1770:	6850      	ldr	r0, [r2, #4]
    1772:	b910      	cbnz	r0, 177a <do_newconn+0x2e>
			msg->err = ERR_MEM;
    1774:	23ff      	movs	r3, #255	; 0xff
		msg->err = ERR_VAL;
    1776:	7123      	strb	r3, [r4, #4]
		break;
    1778:	e007      	b.n	178a <do_newconn+0x3e>
		if (msg->conn->type == NETCONN_UDPNOCHKSUM) {
    177a:	7813      	ldrb	r3, [r2, #0]
		udp_recv(msg->conn->pcb.udp, recv_udp, msg->conn);
    177c:	490d      	ldr	r1, [pc, #52]	; (17b4 <do_newconn+0x68>)
		if (msg->conn->type == NETCONN_UDPNOCHKSUM) {
    177e:	2b22      	cmp	r3, #34	; 0x22
			udp_setflags(msg->conn->pcb.udp, UDP_FLAGS_NOCHKSUM);
    1780:	bf04      	itt	eq
    1782:	2301      	moveq	r3, #1
    1784:	7403      	strbeq	r3, [r0, #16]
		udp_recv(msg->conn->pcb.udp, recv_udp, msg->conn);
    1786:	4b0c      	ldr	r3, [pc, #48]	; (17b8 <do_newconn+0x6c>)
    1788:	4798      	blx	r3
	TCPIP_APIMSG_ACK(msg);
    178a:	6820      	ldr	r0, [r4, #0]
    178c:	4b0b      	ldr	r3, [pc, #44]	; (17bc <do_newconn+0x70>)
}
    178e:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	TCPIP_APIMSG_ACK(msg);
    1792:	300c      	adds	r0, #12
    1794:	4718      	bx	r3
		msg->conn->pcb.tcp = tcp_new();
    1796:	4b0a      	ldr	r3, [pc, #40]	; (17c0 <do_newconn+0x74>)
    1798:	4798      	blx	r3
    179a:	6068      	str	r0, [r5, #4]
		if (msg->conn->pcb.tcp == NULL) {
    179c:	6820      	ldr	r0, [r4, #0]
    179e:	6843      	ldr	r3, [r0, #4]
    17a0:	2b00      	cmp	r3, #0
    17a2:	d0e7      	beq.n	1774 <do_newconn+0x28>
		setup_tcp(msg->conn);
    17a4:	4b07      	ldr	r3, [pc, #28]	; (17c4 <do_newconn+0x78>)
    17a6:	4798      	blx	r3
		break;
    17a8:	e7ef      	b.n	178a <do_newconn+0x3e>
		msg->err = ERR_VAL;
    17aa:	23fa      	movs	r3, #250	; 0xfa
    17ac:	e7e3      	b.n	1776 <do_newconn+0x2a>
    17ae:	bf00      	nop
    17b0:	00004879 	.word	0x00004879
    17b4:	00001339 	.word	0x00001339
    17b8:	00004841 	.word	0x00004841
    17bc:	00007a1d 	.word	0x00007a1d
    17c0:	00007395 	.word	0x00007395
    17c4:	000013c1 	.word	0x000013c1

000017c8 <netconn_alloc>:
{
    17c8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	conn = (struct netconn *)memp_malloc(MEMP_NETCONN);
    17ca:	4b17      	ldr	r3, [pc, #92]	; (1828 <netconn_alloc+0x60>)
{
    17cc:	4605      	mov	r5, r0
	conn = (struct netconn *)memp_malloc(MEMP_NETCONN);
    17ce:	2007      	movs	r0, #7
{
    17d0:	460e      	mov	r6, r1
	conn = (struct netconn *)memp_malloc(MEMP_NETCONN);
    17d2:	4798      	blx	r3
	if (conn == NULL) {
    17d4:	4604      	mov	r4, r0
    17d6:	b320      	cbz	r0, 1822 <netconn_alloc+0x5a>
	conn->last_err = ERR_OK;
    17d8:	2100      	movs	r1, #0
	if (sys_sem_new(&conn->op_completed, 0) != ERR_OK) {
    17da:	f100 070c 	add.w	r7, r0, #12
	conn->last_err = ERR_OK;
    17de:	7201      	strb	r1, [r0, #8]
	conn->type     = t;
    17e0:	7005      	strb	r5, [r0, #0]
	conn->pcb.tcp  = NULL;
    17e2:	6041      	str	r1, [r0, #4]
	if (sys_sem_new(&conn->op_completed, 0) != ERR_OK) {
    17e4:	4b11      	ldr	r3, [pc, #68]	; (182c <netconn_alloc+0x64>)
    17e6:	4638      	mov	r0, r7
    17e8:	4798      	blx	r3
    17ea:	b940      	cbnz	r0, 17fe <netconn_alloc+0x36>
	if (sys_mbox_new(&conn->recvmbox, size) != ERR_OK) {
    17ec:	2110      	movs	r1, #16
    17ee:	4b10      	ldr	r3, [pc, #64]	; (1830 <netconn_alloc+0x68>)
    17f0:	1860      	adds	r0, r4, r1
    17f2:	4798      	blx	r3
    17f4:	4605      	mov	r5, r0
    17f6:	b140      	cbz	r0, 180a <netconn_alloc+0x42>
		sys_sem_free(&conn->op_completed);
    17f8:	4b0e      	ldr	r3, [pc, #56]	; (1834 <netconn_alloc+0x6c>)
    17fa:	4638      	mov	r0, r7
    17fc:	4798      	blx	r3
	memp_free(MEMP_NETCONN, conn);
    17fe:	4621      	mov	r1, r4
    1800:	4b0d      	ldr	r3, [pc, #52]	; (1838 <netconn_alloc+0x70>)
    1802:	2007      	movs	r0, #7
    1804:	4798      	blx	r3
	return NULL;
    1806:	2400      	movs	r4, #0
    1808:	e00b      	b.n	1822 <netconn_alloc+0x5a>
	sys_mbox_set_invalid(&conn->acceptmbox);
    180a:	4b0c      	ldr	r3, [pc, #48]	; (183c <netconn_alloc+0x74>)
    180c:	f104 0014 	add.w	r0, r4, #20
    1810:	4798      	blx	r3
	conn->current_msg  = NULL;
    1812:	e9c4 5609 	strd	r5, r6, [r4, #36]	; 0x24
	conn->socket = -1;
    1816:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
	conn->state = NETCONN_NONE;
    181a:	7065      	strb	r5, [r4, #1]
	conn->socket = -1;
    181c:	61a3      	str	r3, [r4, #24]
	conn->write_offset = 0;
    181e:	6225      	str	r5, [r4, #32]
	conn->flags = 0;
    1820:	7725      	strb	r5, [r4, #28]
}
    1822:	4620      	mov	r0, r4
    1824:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    1826:	bf00      	nop
    1828:	00004c05 	.word	0x00004c05
    182c:	000079ad 	.word	0x000079ad
    1830:	00007aa1 	.word	0x00007aa1
    1834:	00007a0d 	.word	0x00007a0d
    1838:	00004c21 	.word	0x00004c21
    183c:	00007be5 	.word	0x00007be5

00001840 <netconn_free>:
{
    1840:	b513      	push	{r0, r1, r4, lr}
	sys_sem_free(&conn->op_completed);
    1842:	4b07      	ldr	r3, [pc, #28]	; (1860 <netconn_free+0x20>)
{
    1844:	4604      	mov	r4, r0
	sys_sem_free(&conn->op_completed);
    1846:	300c      	adds	r0, #12
    1848:	9001      	str	r0, [sp, #4]
    184a:	4798      	blx	r3
	sys_sem_set_invalid(&conn->op_completed);
    184c:	9801      	ldr	r0, [sp, #4]
    184e:	4b05      	ldr	r3, [pc, #20]	; (1864 <netconn_free+0x24>)
    1850:	4798      	blx	r3
	memp_free(MEMP_NETCONN, conn);
    1852:	4b05      	ldr	r3, [pc, #20]	; (1868 <netconn_free+0x28>)
    1854:	4621      	mov	r1, r4
    1856:	2007      	movs	r0, #7
}
    1858:	b002      	add	sp, #8
    185a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	memp_free(MEMP_NETCONN, conn);
    185e:	4718      	bx	r3
    1860:	00007a0d 	.word	0x00007a0d
    1864:	00007a99 	.word	0x00007a99
    1868:	00004c21 	.word	0x00004c21

0000186c <netconn_drain>:
{
    186c:	e92d 47f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, r9, sl, lr}
	if (sys_mbox_valid(&conn->recvmbox)) {
    1870:	f100 0510 	add.w	r5, r0, #16
{
    1874:	4604      	mov	r4, r0
	if (sys_mbox_valid(&conn->recvmbox)) {
    1876:	4f24      	ldr	r7, [pc, #144]	; (1908 <netconn_drain+0x9c>)
    1878:	4628      	mov	r0, r5
    187a:	47b8      	blx	r7
    187c:	b180      	cbz	r0, 18a0 <netconn_drain+0x34>
		while (sys_mbox_tryfetch(&conn->recvmbox, &mem) != SYS_MBOX_EMPTY) {
    187e:	f8df 8094 	ldr.w	r8, [pc, #148]	; 1914 <netconn_drain+0xa8>
				netbuf_delete((struct netbuf *)mem);
    1882:	f8df 909c 	ldr.w	r9, [pc, #156]	; 1920 <netconn_drain+0xb4>
					pbuf_free(p);
    1886:	f8df a09c 	ldr.w	sl, [pc, #156]	; 1924 <netconn_drain+0xb8>
		while (sys_mbox_tryfetch(&conn->recvmbox, &mem) != SYS_MBOX_EMPTY) {
    188a:	a901      	add	r1, sp, #4
    188c:	4628      	mov	r0, r5
    188e:	47c0      	blx	r8
    1890:	3001      	adds	r0, #1
    1892:	d11b      	bne.n	18cc <netconn_drain+0x60>
		sys_mbox_free(&conn->recvmbox);
    1894:	4b1d      	ldr	r3, [pc, #116]	; (190c <netconn_drain+0xa0>)
    1896:	4628      	mov	r0, r5
    1898:	4798      	blx	r3
		sys_mbox_set_invalid(&conn->recvmbox);
    189a:	4b1d      	ldr	r3, [pc, #116]	; (1910 <netconn_drain+0xa4>)
    189c:	4628      	mov	r0, r5
    189e:	4798      	blx	r3
	if (sys_mbox_valid(&conn->acceptmbox)) {
    18a0:	3414      	adds	r4, #20
    18a2:	4620      	mov	r0, r4
    18a4:	47b8      	blx	r7
    18a6:	b170      	cbz	r0, 18c6 <netconn_drain+0x5a>
		while (sys_mbox_tryfetch(&conn->acceptmbox, &mem) != SYS_MBOX_EMPTY) {
    18a8:	4e1a      	ldr	r6, [pc, #104]	; (1914 <netconn_drain+0xa8>)
				tcp_abort(newconn->pcb.tcp);
    18aa:	4f1b      	ldr	r7, [pc, #108]	; (1918 <netconn_drain+0xac>)
			netconn_free(newconn);
    18ac:	f8df 8078 	ldr.w	r8, [pc, #120]	; 1928 <netconn_drain+0xbc>
		while (sys_mbox_tryfetch(&conn->acceptmbox, &mem) != SYS_MBOX_EMPTY) {
    18b0:	a901      	add	r1, sp, #4
    18b2:	4620      	mov	r0, r4
    18b4:	47b0      	blx	r6
    18b6:	3001      	adds	r0, #1
    18b8:	d119      	bne.n	18ee <netconn_drain+0x82>
		sys_mbox_free(&conn->acceptmbox);
    18ba:	4b14      	ldr	r3, [pc, #80]	; (190c <netconn_drain+0xa0>)
    18bc:	4620      	mov	r0, r4
    18be:	4798      	blx	r3
		sys_mbox_set_invalid(&conn->acceptmbox);
    18c0:	4b13      	ldr	r3, [pc, #76]	; (1910 <netconn_drain+0xa4>)
    18c2:	4620      	mov	r0, r4
    18c4:	4798      	blx	r3
}
    18c6:	b002      	add	sp, #8
    18c8:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
			if (conn->type == NETCONN_TCP) {
    18cc:	7823      	ldrb	r3, [r4, #0]
				if (mem != NULL) {
    18ce:	9e01      	ldr	r6, [sp, #4]
			if (conn->type == NETCONN_TCP) {
    18d0:	2b10      	cmp	r3, #16
    18d2:	d109      	bne.n	18e8 <netconn_drain+0x7c>
				if (mem != NULL) {
    18d4:	2e00      	cmp	r6, #0
    18d6:	d0d8      	beq.n	188a <netconn_drain+0x1e>
					if (conn->pcb.tcp != NULL) {
    18d8:	6860      	ldr	r0, [r4, #4]
    18da:	b110      	cbz	r0, 18e2 <netconn_drain+0x76>
						tcp_recved(conn->pcb.tcp, p->tot_len);
    18dc:	8931      	ldrh	r1, [r6, #8]
    18de:	4b0f      	ldr	r3, [pc, #60]	; (191c <netconn_drain+0xb0>)
    18e0:	4798      	blx	r3
					pbuf_free(p);
    18e2:	4630      	mov	r0, r6
    18e4:	47d0      	blx	sl
    18e6:	e7d0      	b.n	188a <netconn_drain+0x1e>
				netbuf_delete((struct netbuf *)mem);
    18e8:	4630      	mov	r0, r6
    18ea:	47c8      	blx	r9
    18ec:	e7cd      	b.n	188a <netconn_drain+0x1e>
			struct netconn *newconn = (struct netconn *)mem;
    18ee:	9d01      	ldr	r5, [sp, #4]
			netconn_drain(newconn);
    18f0:	4628      	mov	r0, r5
    18f2:	f7ff ffbb 	bl	186c <netconn_drain>
			if (newconn->pcb.tcp != NULL) {
    18f6:	6868      	ldr	r0, [r5, #4]
    18f8:	b110      	cbz	r0, 1900 <netconn_drain+0x94>
				tcp_abort(newconn->pcb.tcp);
    18fa:	47b8      	blx	r7
				newconn->pcb.tcp = NULL;
    18fc:	2300      	movs	r3, #0
    18fe:	606b      	str	r3, [r5, #4]
			netconn_free(newconn);
    1900:	4628      	mov	r0, r5
    1902:	47c0      	blx	r8
    1904:	e7d4      	b.n	18b0 <netconn_drain+0x44>
    1906:	bf00      	nop
    1908:	00007be1 	.word	0x00007be1
    190c:	00007ac1 	.word	0x00007ac1
    1910:	00007be5 	.word	0x00007be5
    1914:	00007bb9 	.word	0x00007bb9
    1918:	00007279 	.word	0x00007279
    191c:	00006a85 	.word	0x00006a85
    1920:	00000d79 	.word	0x00000d79
    1924:	000030e1 	.word	0x000030e1
    1928:	00001841 	.word	0x00001841

0000192c <accept_function>:
{
    192c:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
	if (!sys_mbox_valid(&conn->acceptmbox)) {
    1930:	f100 0814 	add.w	r8, r0, #20
{
    1934:	4606      	mov	r6, r0
	if (!sys_mbox_valid(&conn->acceptmbox)) {
    1936:	4b25      	ldr	r3, [pc, #148]	; (19cc <accept_function+0xa0>)
    1938:	4640      	mov	r0, r8
{
    193a:	460f      	mov	r7, r1
    193c:	4615      	mov	r5, r2
	if (!sys_mbox_valid(&conn->acceptmbox)) {
    193e:	4798      	blx	r3
    1940:	2800      	cmp	r0, #0
    1942:	d040      	beq.n	19c6 <accept_function+0x9a>
	newconn = netconn_alloc(conn->type, conn->callback);
    1944:	6ab1      	ldr	r1, [r6, #40]	; 0x28
    1946:	7830      	ldrb	r0, [r6, #0]
    1948:	4b21      	ldr	r3, [pc, #132]	; (19d0 <accept_function+0xa4>)
    194a:	4798      	blx	r3
	if (newconn == NULL) {
    194c:	4604      	mov	r4, r0
    194e:	2800      	cmp	r0, #0
    1950:	d02c      	beq.n	19ac <accept_function+0x80>
	setup_tcp(newconn);
    1952:	4b20      	ldr	r3, [pc, #128]	; (19d4 <accept_function+0xa8>)
	newconn->pcb.tcp = newpcb;
    1954:	6047      	str	r7, [r0, #4]
	setup_tcp(newconn);
    1956:	4798      	blx	r3
	newconn->last_err = err;
    1958:	7225      	strb	r5, [r4, #8]
	if (sys_mbox_trypost(&conn->acceptmbox, newconn) != ERR_OK) {
    195a:	4b1f      	ldr	r3, [pc, #124]	; (19d8 <accept_function+0xac>)
    195c:	4621      	mov	r1, r4
    195e:	4640      	mov	r0, r8
    1960:	4798      	blx	r3
    1962:	4605      	mov	r5, r0
    1964:	b328      	cbz	r0, 19b2 <accept_function+0x86>
		struct tcp_pcb *pcb = newconn->pcb.tcp;
    1966:	6860      	ldr	r0, [r4, #4]
		tcp_arg(pcb, NULL);
    1968:	4b1c      	ldr	r3, [pc, #112]	; (19dc <accept_function+0xb0>)
    196a:	9001      	str	r0, [sp, #4]
    196c:	2100      	movs	r1, #0
    196e:	4798      	blx	r3
		tcp_recv(pcb, NULL);
    1970:	9801      	ldr	r0, [sp, #4]
    1972:	4b1b      	ldr	r3, [pc, #108]	; (19e0 <accept_function+0xb4>)
    1974:	2100      	movs	r1, #0
    1976:	4798      	blx	r3
		tcp_sent(pcb, NULL);
    1978:	9801      	ldr	r0, [sp, #4]
    197a:	4b1a      	ldr	r3, [pc, #104]	; (19e4 <accept_function+0xb8>)
    197c:	2100      	movs	r1, #0
    197e:	4798      	blx	r3
		tcp_poll(pcb, NULL, 4);
    1980:	2204      	movs	r2, #4
    1982:	9801      	ldr	r0, [sp, #4]
    1984:	4b18      	ldr	r3, [pc, #96]	; (19e8 <accept_function+0xbc>)
    1986:	2100      	movs	r1, #0
    1988:	4798      	blx	r3
		tcp_err(pcb, NULL);
    198a:	2100      	movs	r1, #0
    198c:	9801      	ldr	r0, [sp, #4]
    198e:	4b17      	ldr	r3, [pc, #92]	; (19ec <accept_function+0xc0>)
    1990:	4798      	blx	r3
		newconn->pcb.tcp = NULL;
    1992:	2300      	movs	r3, #0
		sys_mbox_free(&newconn->recvmbox);
    1994:	f104 0010 	add.w	r0, r4, #16
		newconn->pcb.tcp = NULL;
    1998:	6063      	str	r3, [r4, #4]
		sys_mbox_free(&newconn->recvmbox);
    199a:	4b15      	ldr	r3, [pc, #84]	; (19f0 <accept_function+0xc4>)
    199c:	9001      	str	r0, [sp, #4]
    199e:	4798      	blx	r3
		sys_mbox_set_invalid(&newconn->recvmbox);
    19a0:	9801      	ldr	r0, [sp, #4]
    19a2:	4b14      	ldr	r3, [pc, #80]	; (19f4 <accept_function+0xc8>)
    19a4:	4798      	blx	r3
		netconn_free(newconn);
    19a6:	4b14      	ldr	r3, [pc, #80]	; (19f8 <accept_function+0xcc>)
    19a8:	4620      	mov	r0, r4
    19aa:	4798      	blx	r3
		return ERR_MEM;
    19ac:	f04f 35ff 	mov.w	r5, #4294967295	; 0xffffffff
    19b0:	e005      	b.n	19be <accept_function+0x92>
		API_EVENT(conn, NETCONN_EVT_RCVPLUS, 0);
    19b2:	6ab3      	ldr	r3, [r6, #40]	; 0x28
    19b4:	b11b      	cbz	r3, 19be <accept_function+0x92>
    19b6:	4602      	mov	r2, r0
    19b8:	4601      	mov	r1, r0
    19ba:	4630      	mov	r0, r6
    19bc:	4798      	blx	r3
}
    19be:	4628      	mov	r0, r5
    19c0:	b002      	add	sp, #8
    19c2:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		return ERR_VAL;
    19c6:	f06f 0505 	mvn.w	r5, #5
    19ca:	e7f8      	b.n	19be <accept_function+0x92>
    19cc:	00007be1 	.word	0x00007be1
    19d0:	000017c9 	.word	0x000017c9
    19d4:	000013c1 	.word	0x000013c1
    19d8:	00007aed 	.word	0x00007aed
    19dc:	00006b31 	.word	0x00006b31
    19e0:	00006b35 	.word	0x00006b35
    19e4:	00006b3b 	.word	0x00006b3b
    19e8:	00006b49 	.word	0x00006b49
    19ec:	00006b3f 	.word	0x00006b3f
    19f0:	00007ac1 	.word	0x00007ac1
    19f4:	00007be5 	.word	0x00007be5
    19f8:	00001841 	.word	0x00001841

000019fc <do_delconn>:
{
    19fc:	b510      	push	{r4, lr}
    19fe:	4604      	mov	r4, r0
	if ((msg->conn->state != NETCONN_NONE) && (msg->conn->state != NETCONN_LISTEN)
    1a00:	6800      	ldr	r0, [r0, #0]
    1a02:	7843      	ldrb	r3, [r0, #1]
    1a04:	b183      	cbz	r3, 1a28 <do_delconn+0x2c>
    1a06:	3b02      	subs	r3, #2
    1a08:	2b01      	cmp	r3, #1
    1a0a:	d90d      	bls.n	1a28 <do_delconn+0x2c>
		msg->err = ERR_INPROGRESS;
    1a0c:	23fb      	movs	r3, #251	; 0xfb
    1a0e:	7123      	strb	r3, [r4, #4]
	if (sys_sem_valid(&msg->conn->op_completed)) {
    1a10:	6820      	ldr	r0, [r4, #0]
    1a12:	4b1b      	ldr	r3, [pc, #108]	; (1a80 <do_delconn+0x84>)
    1a14:	300c      	adds	r0, #12
    1a16:	4798      	blx	r3
    1a18:	2800      	cmp	r0, #0
    1a1a:	d030      	beq.n	1a7e <do_delconn+0x82>
		sys_sem_signal(&msg->conn->op_completed);
    1a1c:	6820      	ldr	r0, [r4, #0]
    1a1e:	4b19      	ldr	r3, [pc, #100]	; (1a84 <do_delconn+0x88>)
}
    1a20:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		sys_sem_signal(&msg->conn->op_completed);
    1a24:	300c      	adds	r0, #12
    1a26:	4718      	bx	r3
		netconn_drain(msg->conn);
    1a28:	4b17      	ldr	r3, [pc, #92]	; (1a88 <do_delconn+0x8c>)
    1a2a:	4798      	blx	r3
		if (msg->conn->pcb.tcp != NULL) {
    1a2c:	6823      	ldr	r3, [r4, #0]
    1a2e:	6858      	ldr	r0, [r3, #4]
    1a30:	b168      	cbz	r0, 1a4e <do_delconn+0x52>
			switch (NETCONNTYPE_GROUP(msg->conn->type)) {
    1a32:	781a      	ldrb	r2, [r3, #0]
    1a34:	f002 02f0 	and.w	r2, r2, #240	; 0xf0
    1a38:	2a10      	cmp	r2, #16
    1a3a:	d016      	beq.n	1a6a <do_delconn+0x6e>
    1a3c:	2a20      	cmp	r2, #32
    1a3e:	d103      	bne.n	1a48 <do_delconn+0x4c>
				msg->conn->pcb.udp->recv_arg = NULL;
    1a40:	2300      	movs	r3, #0
    1a42:	61c3      	str	r3, [r0, #28]
				udp_remove(msg->conn->pcb.udp);
    1a44:	4b11      	ldr	r3, [pc, #68]	; (1a8c <do_delconn+0x90>)
    1a46:	4798      	blx	r3
			msg->conn->pcb.tcp = NULL;
    1a48:	6823      	ldr	r3, [r4, #0]
    1a4a:	2200      	movs	r2, #0
    1a4c:	605a      	str	r2, [r3, #4]
		API_EVENT(msg->conn, NETCONN_EVT_RCVPLUS, 0);
    1a4e:	6820      	ldr	r0, [r4, #0]
    1a50:	6a83      	ldr	r3, [r0, #40]	; 0x28
    1a52:	b113      	cbz	r3, 1a5a <do_delconn+0x5e>
    1a54:	2200      	movs	r2, #0
    1a56:	4611      	mov	r1, r2
    1a58:	4798      	blx	r3
		API_EVENT(msg->conn, NETCONN_EVT_SENDPLUS, 0);
    1a5a:	6820      	ldr	r0, [r4, #0]
    1a5c:	6a83      	ldr	r3, [r0, #40]	; 0x28
    1a5e:	2b00      	cmp	r3, #0
    1a60:	d0d6      	beq.n	1a10 <do_delconn+0x14>
    1a62:	2200      	movs	r2, #0
    1a64:	2102      	movs	r1, #2
    1a66:	4798      	blx	r3
    1a68:	e7d2      	b.n	1a10 <do_delconn+0x14>
				msg->conn->state       = NETCONN_CLOSE;
    1a6a:	2204      	movs	r2, #4
    1a6c:	705a      	strb	r2, [r3, #1]
				msg->msg.sd.shut       = NETCONN_SHUT_RDWR;
    1a6e:	2203      	movs	r2, #3
    1a70:	7222      	strb	r2, [r4, #8]
				do_close_internal(msg->conn);
    1a72:	4618      	mov	r0, r3
				msg->conn->current_msg = msg;
    1a74:	625c      	str	r4, [r3, #36]	; 0x24
}
    1a76:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
				do_close_internal(msg->conn);
    1a7a:	4b05      	ldr	r3, [pc, #20]	; (1a90 <do_delconn+0x94>)
    1a7c:	4718      	bx	r3
}
    1a7e:	bd10      	pop	{r4, pc}
    1a80:	00007a95 	.word	0x00007a95
    1a84:	00007a1d 	.word	0x00007a1d
    1a88:	0000186d 	.word	0x0000186d
    1a8c:	00004849 	.word	0x00004849
    1a90:	00001419 	.word	0x00001419

00001a94 <do_bind>:
{
    1a94:	b510      	push	{r4, lr}
	if (ERR_IS_FATAL(msg->conn->last_err)) {
    1a96:	6803      	ldr	r3, [r0, #0]
    1a98:	f993 2008 	ldrsb.w	r2, [r3, #8]
    1a9c:	f112 0f09 	cmn.w	r2, #9
{
    1aa0:	4604      	mov	r4, r0
	if (ERR_IS_FATAL(msg->conn->last_err)) {
    1aa2:	da06      	bge.n	1ab2 <do_bind+0x1e>
		msg->err = msg->conn->last_err;
    1aa4:	7102      	strb	r2, [r0, #4]
	TCPIP_APIMSG_ACK(msg);
    1aa6:	6820      	ldr	r0, [r4, #0]
    1aa8:	4b0d      	ldr	r3, [pc, #52]	; (1ae0 <do_bind+0x4c>)
}
    1aaa:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	TCPIP_APIMSG_ACK(msg);
    1aae:	300c      	adds	r0, #12
    1ab0:	4718      	bx	r3
		msg->err = ERR_VAL;
    1ab2:	22fa      	movs	r2, #250	; 0xfa
    1ab4:	7102      	strb	r2, [r0, #4]
		if (msg->conn->pcb.tcp != NULL) {
    1ab6:	6858      	ldr	r0, [r3, #4]
    1ab8:	2800      	cmp	r0, #0
    1aba:	d0f4      	beq.n	1aa6 <do_bind+0x12>
			switch (NETCONNTYPE_GROUP(msg->conn->type)) {
    1abc:	781b      	ldrb	r3, [r3, #0]
    1abe:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
    1ac2:	2b10      	cmp	r3, #16
    1ac4:	d007      	beq.n	1ad6 <do_bind+0x42>
    1ac6:	2b20      	cmp	r3, #32
    1ac8:	d1ed      	bne.n	1aa6 <do_bind+0x12>
				msg->err = udp_bind(msg->conn->pcb.udp, msg->msg.bc.ipaddr, msg->msg.bc.port);
    1aca:	89a2      	ldrh	r2, [r4, #12]
    1acc:	68a1      	ldr	r1, [r4, #8]
    1ace:	4b05      	ldr	r3, [pc, #20]	; (1ae4 <do_bind+0x50>)
				msg->err = tcp_bind(msg->conn->pcb.tcp, msg->msg.bc.ipaddr, msg->msg.bc.port);
    1ad0:	4798      	blx	r3
    1ad2:	7120      	strb	r0, [r4, #4]
				break;
    1ad4:	e7e7      	b.n	1aa6 <do_bind+0x12>
				msg->err = tcp_bind(msg->conn->pcb.tcp, msg->msg.bc.ipaddr, msg->msg.bc.port);
    1ad6:	89a2      	ldrh	r2, [r4, #12]
    1ad8:	68a1      	ldr	r1, [r4, #8]
    1ada:	4b03      	ldr	r3, [pc, #12]	; (1ae8 <do_bind+0x54>)
    1adc:	e7f8      	b.n	1ad0 <do_bind+0x3c>
    1ade:	bf00      	nop
    1ae0:	00007a1d 	.word	0x00007a1d
    1ae4:	00004611 	.word	0x00004611
    1ae8:	00006939 	.word	0x00006939

00001aec <do_listen>:
{
    1aec:	b570      	push	{r4, r5, r6, lr}
	if (ERR_IS_FATAL(msg->conn->last_err)) {
    1aee:	6803      	ldr	r3, [r0, #0]
    1af0:	f993 2008 	ldrsb.w	r2, [r3, #8]
    1af4:	f112 0f09 	cmn.w	r2, #9
{
    1af8:	4604      	mov	r4, r0
	if (ERR_IS_FATAL(msg->conn->last_err)) {
    1afa:	da06      	bge.n	1b0a <do_listen+0x1e>
		msg->err = msg->conn->last_err;
    1afc:	7102      	strb	r2, [r0, #4]
	TCPIP_APIMSG_ACK(msg);
    1afe:	6820      	ldr	r0, [r4, #0]
    1b00:	4b24      	ldr	r3, [pc, #144]	; (1b94 <do_listen+0xa8>)
}
    1b02:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	TCPIP_APIMSG_ACK(msg);
    1b06:	300c      	adds	r0, #12
    1b08:	4718      	bx	r3
		msg->err = ERR_CONN;
    1b0a:	22f3      	movs	r2, #243	; 0xf3
    1b0c:	7102      	strb	r2, [r0, #4]
		if (msg->conn->pcb.tcp != NULL) {
    1b0e:	6858      	ldr	r0, [r3, #4]
    1b10:	2800      	cmp	r0, #0
    1b12:	d0f4      	beq.n	1afe <do_listen+0x12>
			if (msg->conn->type == NETCONN_TCP) {
    1b14:	781a      	ldrb	r2, [r3, #0]
    1b16:	2a10      	cmp	r2, #16
    1b18:	d13a      	bne.n	1b90 <do_listen+0xa4>
				if (msg->conn->state == NETCONN_NONE) {
    1b1a:	785b      	ldrb	r3, [r3, #1]
    1b1c:	2b00      	cmp	r3, #0
    1b1e:	d1ee      	bne.n	1afe <do_listen+0x12>
					struct tcp_pcb *lpcb = tcp_listen(msg->conn->pcb.tcp);
    1b20:	4b1d      	ldr	r3, [pc, #116]	; (1b98 <do_listen+0xac>)
    1b22:	21ff      	movs	r1, #255	; 0xff
    1b24:	4798      	blx	r3
					if (lpcb == NULL) {
    1b26:	4605      	mov	r5, r0
    1b28:	b910      	cbnz	r0, 1b30 <do_listen+0x44>
						msg->err = ERR_MEM;
    1b2a:	23ff      	movs	r3, #255	; 0xff
				msg->err = ERR_ARG;
    1b2c:	7123      	strb	r3, [r4, #4]
    1b2e:	e7e6      	b.n	1afe <do_listen+0x12>
						if (sys_mbox_valid(&msg->conn->recvmbox)) {
    1b30:	6820      	ldr	r0, [r4, #0]
    1b32:	4e1a      	ldr	r6, [pc, #104]	; (1b9c <do_listen+0xb0>)
    1b34:	3010      	adds	r0, #16
    1b36:	47b0      	blx	r6
    1b38:	b138      	cbz	r0, 1b4a <do_listen+0x5e>
							sys_mbox_free(&msg->conn->recvmbox);
    1b3a:	6820      	ldr	r0, [r4, #0]
    1b3c:	4b18      	ldr	r3, [pc, #96]	; (1ba0 <do_listen+0xb4>)
    1b3e:	3010      	adds	r0, #16
    1b40:	4798      	blx	r3
							sys_mbox_set_invalid(&msg->conn->recvmbox);
    1b42:	6820      	ldr	r0, [r4, #0]
    1b44:	4b17      	ldr	r3, [pc, #92]	; (1ba4 <do_listen+0xb8>)
    1b46:	3010      	adds	r0, #16
    1b48:	4798      	blx	r3
						if (!sys_mbox_valid(&msg->conn->acceptmbox)) {
    1b4a:	6820      	ldr	r0, [r4, #0]
						msg->err = ERR_OK;
    1b4c:	2300      	movs	r3, #0
    1b4e:	7123      	strb	r3, [r4, #4]
						if (!sys_mbox_valid(&msg->conn->acceptmbox)) {
    1b50:	3014      	adds	r0, #20
    1b52:	47b0      	blx	r6
    1b54:	b928      	cbnz	r0, 1b62 <do_listen+0x76>
							msg->err = sys_mbox_new(&msg->conn->acceptmbox, DEFAULT_ACCEPTMBOX_SIZE);
    1b56:	6820      	ldr	r0, [r4, #0]
    1b58:	4b13      	ldr	r3, [pc, #76]	; (1ba8 <do_listen+0xbc>)
    1b5a:	2110      	movs	r1, #16
    1b5c:	3014      	adds	r0, #20
    1b5e:	4798      	blx	r3
    1b60:	7120      	strb	r0, [r4, #4]
						if (msg->err == ERR_OK) {
    1b62:	f994 3004 	ldrsb.w	r3, [r4, #4]
    1b66:	b963      	cbnz	r3, 1b82 <do_listen+0x96>
							msg->conn->state   = NETCONN_LISTEN;
    1b68:	6821      	ldr	r1, [r4, #0]
    1b6a:	2302      	movs	r3, #2
    1b6c:	704b      	strb	r3, [r1, #1]
							msg->conn->pcb.tcp = lpcb;
    1b6e:	604d      	str	r5, [r1, #4]
							tcp_arg(msg->conn->pcb.tcp, msg->conn);
    1b70:	4628      	mov	r0, r5
    1b72:	4b0e      	ldr	r3, [pc, #56]	; (1bac <do_listen+0xc0>)
    1b74:	4798      	blx	r3
							tcp_accept(msg->conn->pcb.tcp, accept_function);
    1b76:	6823      	ldr	r3, [r4, #0]
    1b78:	490d      	ldr	r1, [pc, #52]	; (1bb0 <do_listen+0xc4>)
    1b7a:	6858      	ldr	r0, [r3, #4]
    1b7c:	4b0d      	ldr	r3, [pc, #52]	; (1bb4 <do_listen+0xc8>)
    1b7e:	4798      	blx	r3
    1b80:	e7bd      	b.n	1afe <do_listen+0x12>
							tcp_close(lpcb);
    1b82:	4b0d      	ldr	r3, [pc, #52]	; (1bb8 <do_listen+0xcc>)
    1b84:	4628      	mov	r0, r5
    1b86:	4798      	blx	r3
							msg->conn->pcb.tcp = NULL;
    1b88:	6823      	ldr	r3, [r4, #0]
    1b8a:	2200      	movs	r2, #0
    1b8c:	605a      	str	r2, [r3, #4]
    1b8e:	e7b6      	b.n	1afe <do_listen+0x12>
				msg->err = ERR_ARG;
    1b90:	23f2      	movs	r3, #242	; 0xf2
    1b92:	e7cb      	b.n	1b2c <do_listen+0x40>
    1b94:	00007a1d 	.word	0x00007a1d
    1b98:	000069b1 	.word	0x000069b1
    1b9c:	00007be1 	.word	0x00007be1
    1ba0:	00007ac1 	.word	0x00007ac1
    1ba4:	00007be5 	.word	0x00007be5
    1ba8:	00007aa1 	.word	0x00007aa1
    1bac:	00006b31 	.word	0x00006b31
    1bb0:	0000192d 	.word	0x0000192d
    1bb4:	00006b45 	.word	0x00006b45
    1bb8:	0000702d 	.word	0x0000702d

00001bbc <do_send>:
{
    1bbc:	b570      	push	{r4, r5, r6, lr}
	if (ERR_IS_FATAL(msg->conn->last_err)) {
    1bbe:	6803      	ldr	r3, [r0, #0]
    1bc0:	f993 2008 	ldrsb.w	r2, [r3, #8]
    1bc4:	f112 0f09 	cmn.w	r2, #9
{
    1bc8:	4604      	mov	r4, r0
	if (ERR_IS_FATAL(msg->conn->last_err)) {
    1bca:	da06      	bge.n	1bda <do_send+0x1e>
		msg->err = msg->conn->last_err;
    1bcc:	7102      	strb	r2, [r0, #4]
	TCPIP_APIMSG_ACK(msg);
    1bce:	6820      	ldr	r0, [r4, #0]
    1bd0:	4b0d      	ldr	r3, [pc, #52]	; (1c08 <do_send+0x4c>)
}
    1bd2:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	TCPIP_APIMSG_ACK(msg);
    1bd6:	300c      	adds	r0, #12
    1bd8:	4718      	bx	r3
		msg->err = ERR_CONN;
    1bda:	22f3      	movs	r2, #243	; 0xf3
    1bdc:	7102      	strb	r2, [r0, #4]
		if (msg->conn->pcb.tcp != NULL) {
    1bde:	6858      	ldr	r0, [r3, #4]
    1be0:	2800      	cmp	r0, #0
    1be2:	d0f4      	beq.n	1bce <do_send+0x12>
			switch (NETCONNTYPE_GROUP(msg->conn->type)) {
    1be4:	781b      	ldrb	r3, [r3, #0]
    1be6:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
    1bea:	2b20      	cmp	r3, #32
    1bec:	d1ef      	bne.n	1bce <do_send+0x12>
				if (ip_addr_isany(&msg->msg.b->addr)) {
    1bee:	68a2      	ldr	r2, [r4, #8]
    1bf0:	6893      	ldr	r3, [r2, #8]
					msg->err = udp_send(msg->conn->pcb.udp, msg->msg.b->p);
    1bf2:	6811      	ldr	r1, [r2, #0]
				if (ip_addr_isany(&msg->msg.b->addr)) {
    1bf4:	b91b      	cbnz	r3, 1bfe <do_send+0x42>
					msg->err = udp_send(msg->conn->pcb.udp, msg->msg.b->p);
    1bf6:	4b05      	ldr	r3, [pc, #20]	; (1c0c <do_send+0x50>)
    1bf8:	4798      	blx	r3
					msg->err = udp_sendto(msg->conn->pcb.udp, msg->msg.b->p, &msg->msg.b->addr, msg->msg.b->port);
    1bfa:	7120      	strb	r0, [r4, #4]
    1bfc:	e7e7      	b.n	1bce <do_send+0x12>
    1bfe:	8993      	ldrh	r3, [r2, #12]
    1c00:	4d03      	ldr	r5, [pc, #12]	; (1c10 <do_send+0x54>)
    1c02:	3208      	adds	r2, #8
    1c04:	47a8      	blx	r5
    1c06:	e7f8      	b.n	1bfa <do_send+0x3e>
    1c08:	00007a1d 	.word	0x00007a1d
    1c0c:	000047dd 	.word	0x000047dd
    1c10:	000047a9 	.word	0x000047a9

00001c14 <do_recv>:
	msg->err = ERR_OK;
    1c14:	2300      	movs	r3, #0
{
    1c16:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	msg->err = ERR_OK;
    1c1a:	7103      	strb	r3, [r0, #4]
	if (msg->conn->pcb.tcp != NULL) {
    1c1c:	6803      	ldr	r3, [r0, #0]
    1c1e:	685a      	ldr	r2, [r3, #4]
{
    1c20:	4604      	mov	r4, r0
	if (msg->conn->pcb.tcp != NULL) {
    1c22:	b182      	cbz	r2, 1c46 <do_recv+0x32>
		if (msg->conn->type == NETCONN_TCP) {
    1c24:	781b      	ldrb	r3, [r3, #0]
    1c26:	2b10      	cmp	r3, #16
    1c28:	d10d      	bne.n	1c46 <do_recv+0x32>
				u32_t remaining = msg->msg.r.len;
    1c2a:	6885      	ldr	r5, [r0, #8]
					tcp_recved(msg->conn->pcb.tcp, recved);
    1c2c:	4f09      	ldr	r7, [pc, #36]	; (1c54 <do_recv+0x40>)
    1c2e:	f64f 78ff 	movw	r8, #65535	; 0xffff
					u16_t recved = (remaining > 0xffff) ? 0xffff : (u16_t)remaining;
    1c32:	4545      	cmp	r5, r8
					tcp_recved(msg->conn->pcb.tcp, recved);
    1c34:	6823      	ldr	r3, [r4, #0]
    1c36:	462e      	mov	r6, r5
    1c38:	bf28      	it	cs
    1c3a:	4646      	movcs	r6, r8
    1c3c:	6858      	ldr	r0, [r3, #4]
    1c3e:	b2b1      	uxth	r1, r6
    1c40:	47b8      	blx	r7
				} while (remaining != 0);
    1c42:	1bad      	subs	r5, r5, r6
    1c44:	d1f5      	bne.n	1c32 <do_recv+0x1e>
	TCPIP_APIMSG_ACK(msg);
    1c46:	6820      	ldr	r0, [r4, #0]
    1c48:	4b03      	ldr	r3, [pc, #12]	; (1c58 <do_recv+0x44>)
}
    1c4a:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
	TCPIP_APIMSG_ACK(msg);
    1c4e:	300c      	adds	r0, #12
    1c50:	4718      	bx	r3
    1c52:	bf00      	nop
    1c54:	00006a85 	.word	0x00006a85
    1c58:	00007a1d 	.word	0x00007a1d

00001c5c <do_write>:
 * Called from netconn_write
 *
 * @param msg the api_msg_msg pointing to the connection
 */
void do_write(struct api_msg_msg *msg)
{
    1c5c:	4603      	mov	r3, r0
	if (ERR_IS_FATAL(msg->conn->last_err)) {
    1c5e:	6800      	ldr	r0, [r0, #0]
    1c60:	f990 2008 	ldrsb.w	r2, [r0, #8]
    1c64:	f112 0f09 	cmn.w	r2, #9
    1c68:	da03      	bge.n	1c72 <do_write+0x16>
#else  /* LWIP_TCP */
			msg->err = ERR_VAL;
#endif /* LWIP_TCP */
#if (LWIP_UDP || LWIP_RAW)
		} else {
			msg->err = ERR_VAL;
    1c6a:	711a      	strb	r2, [r3, #4]
#endif /* (LWIP_UDP || LWIP_RAW) */
		}
	}
	TCPIP_APIMSG_ACK(msg);
    1c6c:	300c      	adds	r0, #12
    1c6e:	4b0a      	ldr	r3, [pc, #40]	; (1c98 <do_write+0x3c>)
    1c70:	4718      	bx	r3
		if (msg->conn->type == NETCONN_TCP) {
    1c72:	7802      	ldrb	r2, [r0, #0]
    1c74:	2a10      	cmp	r2, #16
    1c76:	d10d      	bne.n	1c94 <do_write+0x38>
			if (msg->conn->state != NETCONN_NONE) {
    1c78:	7842      	ldrb	r2, [r0, #1]
    1c7a:	b10a      	cbz	r2, 1c80 <do_write+0x24>
				msg->err = ERR_INPROGRESS;
    1c7c:	22fb      	movs	r2, #251	; 0xfb
    1c7e:	e7f4      	b.n	1c6a <do_write+0xe>
			} else if (msg->conn->pcb.tcp != NULL) {
    1c80:	6841      	ldr	r1, [r0, #4]
    1c82:	b129      	cbz	r1, 1c90 <do_write+0x34>
				msg->conn->state = NETCONN_WRITE;
    1c84:	2101      	movs	r1, #1
				msg->conn->write_offset = 0;
    1c86:	e9c0 2308 	strd	r2, r3, [r0, #32]
				msg->conn->state = NETCONN_WRITE;
    1c8a:	7041      	strb	r1, [r0, #1]
				do_writemore(msg->conn);
    1c8c:	4b03      	ldr	r3, [pc, #12]	; (1c9c <do_write+0x40>)
    1c8e:	4718      	bx	r3
				msg->err = ERR_CONN;
    1c90:	22f3      	movs	r2, #243	; 0xf3
    1c92:	e7ea      	b.n	1c6a <do_write+0xe>
			msg->err = ERR_VAL;
    1c94:	22fa      	movs	r2, #250	; 0xfa
    1c96:	e7e8      	b.n	1c6a <do_write+0xe>
    1c98:	00007a1d 	.word	0x00007a1d
    1c9c:	000015a9 	.word	0x000015a9

00001ca0 <do_getaddr>:
 *
 * @param msg the api_msg_msg pointing to the connection
 */
void do_getaddr(struct api_msg_msg *msg)
{
	if (msg->conn->pcb.ip != NULL) {
    1ca0:	6801      	ldr	r1, [r0, #0]
    1ca2:	684b      	ldr	r3, [r1, #4]
{
    1ca4:	b430      	push	{r4, r5}
	if (msg->conn->pcb.ip != NULL) {
    1ca6:	b1bb      	cbz	r3, 1cd8 <do_getaddr+0x38>
		*(msg->msg.ad.ipaddr) = (msg->msg.ad.local ? msg->conn->pcb.ip->local_ip : msg->conn->pcb.ip->remote_ip);
    1ca8:	7c04      	ldrb	r4, [r0, #16]
    1caa:	6882      	ldr	r2, [r0, #8]
    1cac:	b17c      	cbz	r4, 1cce <do_getaddr+0x2e>
    1cae:	681d      	ldr	r5, [r3, #0]
    1cb0:	6015      	str	r5, [r2, #0]

		msg->err = ERR_OK;
    1cb2:	2200      	movs	r2, #0
    1cb4:	7102      	strb	r2, [r0, #4]
		switch (NETCONNTYPE_GROUP(msg->conn->type)) {
    1cb6:	780a      	ldrb	r2, [r1, #0]
    1cb8:	f002 02f0 	and.w	r2, r2, #240	; 0xf0
    1cbc:	2a10      	cmp	r2, #16
    1cbe:	d015      	beq.n	1cec <do_getaddr+0x4c>
    1cc0:	2a20      	cmp	r2, #32
    1cc2:	d10b      	bne.n	1cdc <do_getaddr+0x3c>
			}
			break;
#endif /* LWIP_RAW */
#if LWIP_UDP
		case NETCONN_UDP:
			if (msg->msg.ad.local) {
    1cc4:	b12c      	cbz	r4, 1cd2 <do_getaddr+0x32>
				*(msg->msg.ad.port) = msg->conn->pcb.udp->local_port;
    1cc6:	68c2      	ldr	r2, [r0, #12]
    1cc8:	8a5b      	ldrh	r3, [r3, #18]
			break;
#endif /* LWIP_UDP */
#if LWIP_TCP
		case NETCONN_TCP:
			*(msg->msg.ad.port)
			    = (msg->msg.ad.local ? msg->conn->pcb.tcp->local_port : msg->conn->pcb.tcp->remote_port);
    1cca:	8013      	strh	r3, [r2, #0]
			break;
    1ccc:	e006      	b.n	1cdc <do_getaddr+0x3c>
		*(msg->msg.ad.ipaddr) = (msg->msg.ad.local ? msg->conn->pcb.ip->local_ip : msg->conn->pcb.ip->remote_ip);
    1cce:	685d      	ldr	r5, [r3, #4]
    1cd0:	e7ee      	b.n	1cb0 <do_getaddr+0x10>
				if ((msg->conn->pcb.udp->flags & UDP_FLAGS_CONNECTED) == 0) {
    1cd2:	7c1a      	ldrb	r2, [r3, #16]
    1cd4:	0752      	lsls	r2, r2, #29
    1cd6:	d406      	bmi.n	1ce6 <do_getaddr+0x46>
					msg->err = ERR_CONN;
    1cd8:	23f3      	movs	r3, #243	; 0xf3
    1cda:	7103      	strb	r3, [r0, #4]
		}
	} else {
		msg->err = ERR_CONN;
	}
	TCPIP_APIMSG_ACK(msg);
}
    1cdc:	bc30      	pop	{r4, r5}
	TCPIP_APIMSG_ACK(msg);
    1cde:	4b06      	ldr	r3, [pc, #24]	; (1cf8 <do_getaddr+0x58>)
    1ce0:	f101 000c 	add.w	r0, r1, #12
    1ce4:	4718      	bx	r3
					*(msg->msg.ad.port) = msg->conn->pcb.udp->remote_port;
    1ce6:	68c2      	ldr	r2, [r0, #12]
    1ce8:	8a9b      	ldrh	r3, [r3, #20]
    1cea:	e7ee      	b.n	1cca <do_getaddr+0x2a>
			    = (msg->msg.ad.local ? msg->conn->pcb.tcp->local_port : msg->conn->pcb.tcp->remote_port);
    1cec:	b114      	cbz	r4, 1cf4 <do_getaddr+0x54>
    1cee:	8b5b      	ldrh	r3, [r3, #26]
			*(msg->msg.ad.port)
    1cf0:	68c2      	ldr	r2, [r0, #12]
    1cf2:	e7ea      	b.n	1cca <do_getaddr+0x2a>
			    = (msg->msg.ad.local ? msg->conn->pcb.tcp->local_port : msg->conn->pcb.tcp->remote_port);
    1cf4:	8b9b      	ldrh	r3, [r3, #28]
    1cf6:	e7fb      	b.n	1cf0 <do_getaddr+0x50>
    1cf8:	00007a1d 	.word	0x00007a1d

00001cfc <pvPortMalloc>:
		pxIterator->pxNextFreeBlock      = pxBlockToInsert;                                                            \
	}
/*-----------------------------------------------------------*/

void *pvPortMalloc(size_t xWantedSize)
{
    1cfc:	b570      	push	{r4, r5, r6, lr}
	BlockLink_t *     pxBlock, *pxPreviousBlock, *pxNewBlockLink;
	static BaseType_t xHeapHasBeenInitialised = pdFALSE;
	void *            pvReturn                = NULL;

	vTaskSuspendAll();
    1cfe:	4b26      	ldr	r3, [pc, #152]	; (1d98 <pvPortMalloc+0x9c>)
{
    1d00:	4604      	mov	r4, r0
	vTaskSuspendAll();
    1d02:	4798      	blx	r3
	{
		/* If this is the first call to malloc then the heap will require
		initialisation to setup the list of free blocks. */
		if (xHeapHasBeenInitialised == pdFALSE) {
    1d04:	4b25      	ldr	r3, [pc, #148]	; (1d9c <pvPortMalloc+0xa0>)
    1d06:	6898      	ldr	r0, [r3, #8]
    1d08:	b970      	cbnz	r0, 1d28 <pvPortMalloc+0x2c>
	xStart.pxNextFreeBlock = (void *)pucAlignedHeap;
	xStart.xBlockSize      = (size_t)0;

	/* xEnd is used to mark the end of the list of free blocks. */
	xEnd.xBlockSize      = configADJUSTED_HEAP_SIZE;
	xEnd.pxNextFreeBlock = NULL;
    1d0a:	4619      	mov	r1, r3
	                             & (~((portPOINTER_SIZE_TYPE)portBYTE_ALIGNMENT_MASK)));
    1d0c:	4a24      	ldr	r2, [pc, #144]	; (1da0 <pvPortMalloc+0xa4>)
	xEnd.pxNextFreeBlock = NULL;
    1d0e:	f841 0f0c 	str.w	r0, [r1, #12]!
	                             & (~((portPOINTER_SIZE_TYPE)portBYTE_ALIGNMENT_MASK)));
    1d12:	f022 0207 	bic.w	r2, r2, #7
	xEnd.xBlockSize      = configADJUSTED_HEAP_SIZE;
    1d16:	f24a 4508 	movw	r5, #41992	; 0xa408
	xStart.xBlockSize      = (size_t)0;
    1d1a:	e9c3 2000 	strd	r2, r0, [r3]

	/* To start with there is a single free block that is sized to take up the
	entire heap space. */
	pxFirstFreeBlock                  = (void *)pucAlignedHeap;
	pxFirstFreeBlock->xBlockSize      = configADJUSTED_HEAP_SIZE;
	pxFirstFreeBlock->pxNextFreeBlock = &xEnd;
    1d1e:	e9c2 1500 	strd	r1, r5, [r2]
			xHeapHasBeenInitialised = pdTRUE;
    1d22:	2201      	movs	r2, #1
	xEnd.xBlockSize      = configADJUSTED_HEAP_SIZE;
    1d24:	611d      	str	r5, [r3, #16]
			xHeapHasBeenInitialised = pdTRUE;
    1d26:	609a      	str	r2, [r3, #8]
		if (xWantedSize > 0) {
    1d28:	b12c      	cbz	r4, 1d36 <pvPortMalloc+0x3a>
			xWantedSize += heapSTRUCT_SIZE;
    1d2a:	3408      	adds	r4, #8
			if ((xWantedSize & portBYTE_ALIGNMENT_MASK) != 0) {
    1d2c:	0762      	lsls	r2, r4, #29
				xWantedSize += (portBYTE_ALIGNMENT - (xWantedSize & portBYTE_ALIGNMENT_MASK));
    1d2e:	bf1c      	itt	ne
    1d30:	f024 0407 	bicne.w	r4, r4, #7
    1d34:	3408      	addne	r4, #8
		if ((xWantedSize > 0) && (xWantedSize < configADJUSTED_HEAP_SIZE)) {
    1d36:	1e61      	subs	r1, r4, #1
    1d38:	f24a 4206 	movw	r2, #41990	; 0xa406
    1d3c:	4291      	cmp	r1, r2
    1d3e:	d829      	bhi.n	1d94 <pvPortMalloc+0x98>
			pxBlock         = xStart.pxNextFreeBlock;
    1d40:	681b      	ldr	r3, [r3, #0]
			pxPreviousBlock = &xStart;
    1d42:	4816      	ldr	r0, [pc, #88]	; (1d9c <pvPortMalloc+0xa0>)
			while ((pxBlock->xBlockSize < xWantedSize) && (pxBlock->pxNextFreeBlock != NULL)) {
    1d44:	6859      	ldr	r1, [r3, #4]
    1d46:	42a1      	cmp	r1, r4
    1d48:	d201      	bcs.n	1d4e <pvPortMalloc+0x52>
    1d4a:	681a      	ldr	r2, [r3, #0]
    1d4c:	b9fa      	cbnz	r2, 1d8e <pvPortMalloc+0x92>
			if (pxBlock != &xEnd) {
    1d4e:	4a15      	ldr	r2, [pc, #84]	; (1da4 <pvPortMalloc+0xa8>)
    1d50:	4293      	cmp	r3, r2
    1d52:	d01f      	beq.n	1d94 <pvPortMalloc+0x98>
				pvReturn = (void *)(((uint8_t *)pxPreviousBlock->pxNextFreeBlock) + heapSTRUCT_SIZE);
    1d54:	6805      	ldr	r5, [r0, #0]
				pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;
    1d56:	681e      	ldr	r6, [r3, #0]
    1d58:	6006      	str	r6, [r0, #0]
				if ((pxBlock->xBlockSize - xWantedSize) > heapMINIMUM_BLOCK_SIZE) {
    1d5a:	1b09      	subs	r1, r1, r4
    1d5c:	2910      	cmp	r1, #16
				pvReturn = (void *)(((uint8_t *)pxPreviousBlock->pxNextFreeBlock) + heapSTRUCT_SIZE);
    1d5e:	f105 0508 	add.w	r5, r5, #8
				if ((pxBlock->xBlockSize - xWantedSize) > heapMINIMUM_BLOCK_SIZE) {
    1d62:	d90b      	bls.n	1d7c <pvPortMalloc+0x80>
					pxNewBlockLink = (void *)(((uint8_t *)pxBlock) + xWantedSize);
    1d64:	1918      	adds	r0, r3, r4
					prvInsertBlockIntoFreeList((pxNewBlockLink));
    1d66:	3a0c      	subs	r2, #12
					pxNewBlockLink->xBlockSize = pxBlock->xBlockSize - xWantedSize;
    1d68:	6041      	str	r1, [r0, #4]
					pxBlock->xBlockSize        = xWantedSize;
    1d6a:	605c      	str	r4, [r3, #4]
					prvInsertBlockIntoFreeList((pxNewBlockLink));
    1d6c:	6844      	ldr	r4, [r0, #4]
    1d6e:	4611      	mov	r1, r2
    1d70:	6812      	ldr	r2, [r2, #0]
    1d72:	6856      	ldr	r6, [r2, #4]
    1d74:	42a6      	cmp	r6, r4
    1d76:	d3fa      	bcc.n	1d6e <pvPortMalloc+0x72>
    1d78:	6002      	str	r2, [r0, #0]
    1d7a:	6008      	str	r0, [r1, #0]
				xFreeBytesRemaining -= pxBlock->xBlockSize;
    1d7c:	490a      	ldr	r1, [pc, #40]	; (1da8 <pvPortMalloc+0xac>)
    1d7e:	685b      	ldr	r3, [r3, #4]
    1d80:	680a      	ldr	r2, [r1, #0]
    1d82:	1ad2      	subs	r2, r2, r3
    1d84:	600a      	str	r2, [r1, #0]
	(void)xTaskResumeAll();
    1d86:	4b09      	ldr	r3, [pc, #36]	; (1dac <pvPortMalloc+0xb0>)
    1d88:	4798      	blx	r3
}
    1d8a:	4628      	mov	r0, r5
    1d8c:	bd70      	pop	{r4, r5, r6, pc}
    1d8e:	4618      	mov	r0, r3
    1d90:	4613      	mov	r3, r2
    1d92:	e7d7      	b.n	1d44 <pvPortMalloc+0x48>
	void *            pvReturn                = NULL;
    1d94:	2500      	movs	r5, #0
    1d96:	e7f6      	b.n	1d86 <pvPortMalloc+0x8a>
    1d98:	00008d89 	.word	0x00008d89
    1d9c:	200000b4 	.word	0x200000b4
    1da0:	200000d0 	.word	0x200000d0
    1da4:	200000c0 	.word	0x200000c0
    1da8:	20000000 	.word	0x20000000
    1dac:	00008e9d 	.word	0x00008e9d

00001db0 <vPortFree>:
{
    1db0:	b570      	push	{r4, r5, r6, lr}
	if (pv != NULL) {
    1db2:	4604      	mov	r4, r0
    1db4:	b1b0      	cbz	r0, 1de4 <vPortFree+0x34>
		vTaskSuspendAll();
    1db6:	4b0c      	ldr	r3, [pc, #48]	; (1de8 <vPortFree+0x38>)
		puc -= heapSTRUCT_SIZE;
    1db8:	f1a0 0508 	sub.w	r5, r0, #8
		vTaskSuspendAll();
    1dbc:	4798      	blx	r3
			prvInsertBlockIntoFreeList(((BlockLink_t *)pxLink));
    1dbe:	f854 1c04 	ldr.w	r1, [r4, #-4]
    1dc2:	4b0a      	ldr	r3, [pc, #40]	; (1dec <vPortFree+0x3c>)
    1dc4:	461a      	mov	r2, r3
    1dc6:	681b      	ldr	r3, [r3, #0]
    1dc8:	6858      	ldr	r0, [r3, #4]
    1dca:	4288      	cmp	r0, r1
    1dcc:	d3fa      	bcc.n	1dc4 <vPortFree+0x14>
    1dce:	f844 3c08 	str.w	r3, [r4, #-8]
    1dd2:	6015      	str	r5, [r2, #0]
			xFreeBytesRemaining += pxLink->xBlockSize;
    1dd4:	4a06      	ldr	r2, [pc, #24]	; (1df0 <vPortFree+0x40>)
    1dd6:	6813      	ldr	r3, [r2, #0]
    1dd8:	440b      	add	r3, r1
    1dda:	6013      	str	r3, [r2, #0]
}
    1ddc:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		(void)xTaskResumeAll();
    1de0:	4b04      	ldr	r3, [pc, #16]	; (1df4 <vPortFree+0x44>)
    1de2:	4718      	bx	r3
}
    1de4:	bd70      	pop	{r4, r5, r6, pc}
    1de6:	bf00      	nop
    1de8:	00008d89 	.word	0x00008d89
    1dec:	200000b4 	.word	0x200000b4
    1df0:	20000000 	.word	0x20000000
    1df4:	00008e9d 	.word	0x00008e9d

00001df8 <vListInitialise>:
void vListInitialise(List_t *const pxList)
{
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = (ListItem_t *)&(
    1df8:	f100 0308 	add.w	r3, r0, #8
	    pxList->xListEnd); /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is
	                          checked and valid. */

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
    1dfc:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = (ListItem_t *)&(pxList->xListEnd); /*lint !e826 !e740 The mini list structure is used as
    1e00:	e9c0 2302 	strd	r2, r3, [r0, #8]
	pxList->pxIndex = (ListItem_t *)&(
    1e04:	6043      	str	r3, [r0, #4]
	                                                                the list end to save RAM.  This is checked and
	                                                                valid. */
	pxList->xListEnd.pxPrevious = (ListItem_t *)&(
    1e06:	6103      	str	r3, [r0, #16]
	    pxList->xListEnd); /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is
	                          checked and valid. */

	pxList->uxNumberOfItems = (UBaseType_t)0U;
    1e08:	2300      	movs	r3, #0
    1e0a:	6003      	str	r3, [r0, #0]

	/* Write known values into the list if
	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
	listSET_LIST_INTEGRITY_CHECK_1_VALUE(pxList);
	listSET_LIST_INTEGRITY_CHECK_2_VALUE(pxList);
}
    1e0c:	4770      	bx	lr

00001e0e <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem(ListItem_t *const pxItem)
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
    1e0e:	2300      	movs	r3, #0
    1e10:	6103      	str	r3, [r0, #16]

	/* Write known values into the list item if
	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
	listSET_FIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE(pxItem);
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE(pxItem);
}
    1e12:	4770      	bx	lr

00001e14 <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd(List_t *const pxList, ListItem_t *const pxNewListItem)
{
	ListItem_t *const pxIndex = pxList->pxIndex;
    1e14:	6843      	ldr	r3, [r0, #4]
	listTEST_LIST_ITEM_INTEGRITY(pxNewListItem);

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext     = pxIndex;
    1e16:	604b      	str	r3, [r1, #4]
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
    1e18:	689a      	ldr	r2, [r3, #8]
    1e1a:	608a      	str	r2, [r1, #8]

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
    1e1c:	689a      	ldr	r2, [r3, #8]
    1e1e:	6051      	str	r1, [r2, #4]
	pxIndex->pxPrevious         = pxNewListItem;
    1e20:	6099      	str	r1, [r3, #8]

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = (void *)pxList;

	(pxList->uxNumberOfItems)++;
    1e22:	6803      	ldr	r3, [r0, #0]
	pxNewListItem->pvContainer = (void *)pxList;
    1e24:	6108      	str	r0, [r1, #16]
	(pxList->uxNumberOfItems)++;
    1e26:	3301      	adds	r3, #1
    1e28:	6003      	str	r3, [r0, #0]
}
    1e2a:	4770      	bx	lr

00001e2c <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert(List_t *const pxList, ListItem_t *const pxNewListItem)
{
    1e2c:	b530      	push	{r4, r5, lr}
	ListItem_t *     pxIterator;
	const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
    1e2e:	680c      	ldr	r4, [r1, #0]
	new list item should be placed after it.  This ensures that TCB's which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if (xValueOfInsertion == portMAX_DELAY) {
    1e30:	1c63      	adds	r3, r4, #1
    1e32:	d10a      	bne.n	1e4a <vListInsert+0x1e>
		pxIterator = pxList->xListEnd.pxPrevious;
    1e34:	6903      	ldr	r3, [r0, #16]
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext             = pxIterator->pxNext;
    1e36:	685a      	ldr	r2, [r3, #4]
    1e38:	604a      	str	r2, [r1, #4]
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
    1e3a:	6091      	str	r1, [r2, #8]
	pxNewListItem->pxPrevious         = pxIterator;
    1e3c:	608b      	str	r3, [r1, #8]
	pxIterator->pxNext                = pxNewListItem;
    1e3e:	6059      	str	r1, [r3, #4]

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = (void *)pxList;

	(pxList->uxNumberOfItems)++;
    1e40:	6803      	ldr	r3, [r0, #0]
	pxNewListItem->pvContainer = (void *)pxList;
    1e42:	6108      	str	r0, [r1, #16]
	(pxList->uxNumberOfItems)++;
    1e44:	3301      	adds	r3, #1
    1e46:	6003      	str	r3, [r0, #0]
}
    1e48:	bd30      	pop	{r4, r5, pc}
		for (pxIterator = (ListItem_t *)&(pxList->xListEnd); pxIterator->pxNext->xItemValue <= xValueOfInsertion;
    1e4a:	f100 0208 	add.w	r2, r0, #8
    1e4e:	4613      	mov	r3, r2
    1e50:	6852      	ldr	r2, [r2, #4]
    1e52:	6815      	ldr	r5, [r2, #0]
    1e54:	42a5      	cmp	r5, r4
    1e56:	d9fa      	bls.n	1e4e <vListInsert+0x22>
    1e58:	e7ed      	b.n	1e36 <vListInsert+0xa>

00001e5a <uxListRemove>:
{
	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	List_t *const pxList = (List_t *)pxItemToRemove->pvContainer;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    1e5a:	e9d0 1201 	ldrd	r1, r2, [r0, #4]
	List_t *const pxList = (List_t *)pxItemToRemove->pvContainer;
    1e5e:	6903      	ldr	r3, [r0, #16]
	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    1e60:	608a      	str	r2, [r1, #8]
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    1e62:	6051      	str	r1, [r2, #4]

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if (pxList->pxIndex == pxItemToRemove) {
    1e64:	6859      	ldr	r1, [r3, #4]
    1e66:	4281      	cmp	r1, r0
		pxList->pxIndex = pxItemToRemove->pxPrevious;
    1e68:	bf08      	it	eq
    1e6a:	605a      	streq	r2, [r3, #4]
	} else {
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
    1e6c:	2200      	movs	r2, #0
    1e6e:	6102      	str	r2, [r0, #16]
	(pxList->uxNumberOfItems)--;
    1e70:	6818      	ldr	r0, [r3, #0]
    1e72:	3801      	subs	r0, #1
    1e74:	6018      	str	r0, [r3, #0]

	return pxList->uxNumberOfItems;
}
    1e76:	4770      	bx	lr

00001e78 <tcp_pbuf_prealloc>:
 * @param
 */
#if TCP_OVERSIZE
static struct pbuf *tcp_pbuf_prealloc(pbuf_layer layer, u16_t length, u16_t max_length, u16_t *oversize,
                                      struct tcp_pcb *pcb, u8_t apiflags, u8_t first_seg)
{
    1e78:	b570      	push	{r4, r5, r6, lr}
    1e7a:	460c      	mov	r4, r1
	LWIP_UNUSED_ARG(apiflags);
	LWIP_UNUSED_ARG(first_seg);
	/* always create MSS-sized pbufs */
	alloc = max_length;
#else  /* LWIP_NETIF_TX_SINGLE_PBUF */
	if (length < max_length) {
    1e7c:	4294      	cmp	r4, r2
{
    1e7e:	461e      	mov	r6, r3
    1e80:	f89d 1018 	ldrb.w	r1, [sp, #24]
    1e84:	9b04      	ldr	r3, [sp, #16]
	if (length < max_length) {
    1e86:	d21d      	bcs.n	1ec4 <tcp_pbuf_prealloc+0x4c>
		 *
		 * Did the user set TCP_WRITE_FLAG_MORE?
		 *
		 * Will the Nagle algorithm defer transmission of this segment?
		 */
		if ((apiflags & TCP_WRITE_FLAG_MORE)
    1e88:	f89d 5014 	ldrb.w	r5, [sp, #20]
    1e8c:	07ad      	lsls	r5, r5, #30
    1e8e:	d407      	bmi.n	1ea0 <tcp_pbuf_prealloc+0x28>
		    || (!(pcb->flags & TF_NODELAY) && (!first_seg || pcb->unsent != NULL || pcb->unacked != NULL))) {
    1e90:	7f9d      	ldrb	r5, [r3, #30]
    1e92:	066d      	lsls	r5, r5, #25
    1e94:	d416      	bmi.n	1ec4 <tcp_pbuf_prealloc+0x4c>
    1e96:	b119      	cbz	r1, 1ea0 <tcp_pbuf_prealloc+0x28>
    1e98:	6ed9      	ldr	r1, [r3, #108]	; 0x6c
    1e9a:	b909      	cbnz	r1, 1ea0 <tcp_pbuf_prealloc+0x28>
    1e9c:	6f1b      	ldr	r3, [r3, #112]	; 0x70
    1e9e:	b18b      	cbz	r3, 1ec4 <tcp_pbuf_prealloc+0x4c>
			alloc = LWIP_MIN(max_length, LWIP_MEM_ALIGN_SIZE(length + TCP_OVERSIZE));
    1ea0:	f204 55b7 	addw	r5, r4, #1463	; 0x5b7
    1ea4:	f025 0103 	bic.w	r1, r5, #3
    1ea8:	428a      	cmp	r2, r1
    1eaa:	bfa8      	it	ge
    1eac:	460a      	movge	r2, r1
    1eae:	b291      	uxth	r1, r2
		}
	}
#endif /* LWIP_NETIF_TX_SINGLE_PBUF */
	p = pbuf_alloc(layer, alloc, PBUF_RAM);
    1eb0:	4b05      	ldr	r3, [pc, #20]	; (1ec8 <tcp_pbuf_prealloc+0x50>)
    1eb2:	2200      	movs	r2, #0
    1eb4:	4798      	blx	r3
	if (p == NULL) {
    1eb6:	b120      	cbz	r0, 1ec2 <tcp_pbuf_prealloc+0x4a>
		return NULL;
	}
	LWIP_ASSERT("need unchained pbuf", p->next == NULL);
	*oversize = p->len - length;
    1eb8:	8943      	ldrh	r3, [r0, #10]
    1eba:	1b1b      	subs	r3, r3, r4
    1ebc:	8033      	strh	r3, [r6, #0]
	/* trim p->len to the currently used size */
	p->len = p->tot_len = length;
    1ebe:	8104      	strh	r4, [r0, #8]
    1ec0:	8144      	strh	r4, [r0, #10]
	return p;
}
    1ec2:	bd70      	pop	{r4, r5, r6, pc}
    1ec4:	4621      	mov	r1, r4
    1ec6:	e7f3      	b.n	1eb0 <tcp_pbuf_prealloc+0x38>
    1ec8:	00003139 	.word	0x00003139

00001ecc <tcp_create_segment>:
{
    1ecc:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    1ed0:	4680      	mov	r8, r0
    1ed2:	469a      	mov	sl, r3
	if ((seg = (struct tcp_seg *)memp_malloc(MEMP_TCP_SEG)) == NULL) {
    1ed4:	2003      	movs	r0, #3
    1ed6:	4b28      	ldr	r3, [pc, #160]	; (1f78 <tcp_create_segment+0xac>)
{
    1ed8:	f89d 9028 	ldrb.w	r9, [sp, #40]	; 0x28
    1edc:	460e      	mov	r6, r1
    1ede:	4617      	mov	r7, r2
	if ((seg = (struct tcp_seg *)memp_malloc(MEMP_TCP_SEG)) == NULL) {
    1ee0:	4798      	blx	r3
	u8_t            optlen = LWIP_TCP_OPT_LENGTH(optflags);
    1ee2:	ea4f 0b89 	mov.w	fp, r9, lsl #2
    1ee6:	fa5f f58b 	uxtb.w	r5, fp
	if ((seg = (struct tcp_seg *)memp_malloc(MEMP_TCP_SEG)) == NULL) {
    1eea:	4604      	mov	r4, r0
    1eec:	b928      	cbnz	r0, 1efa <tcp_create_segment+0x2e>
		pbuf_free(p);
    1eee:	4b23      	ldr	r3, [pc, #140]	; (1f7c <tcp_create_segment+0xb0>)
    1ef0:	4630      	mov	r0, r6
    1ef2:	4798      	blx	r3
}
    1ef4:	4620      	mov	r0, r4
    1ef6:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
	seg->flags = optflags;
    1efa:	f880 900a 	strb.w	r9, [r0, #10]
	seg->len   = p->tot_len - optlen;
    1efe:	8933      	ldrh	r3, [r6, #8]
	seg->next  = NULL;
    1f00:	f04f 0900 	mov.w	r9, #0
	seg->len   = p->tot_len - optlen;
    1f04:	eba3 030b 	sub.w	r3, r3, fp
	seg->p     = p;
    1f08:	e9c0 9600 	strd	r9, r6, [r0]
	seg->len   = p->tot_len - optlen;
    1f0c:	8103      	strh	r3, [r0, #8]
	if (pbuf_header(p, TCP_HLEN)) {
    1f0e:	2114      	movs	r1, #20
    1f10:	4630      	mov	r0, r6
    1f12:	4b1b      	ldr	r3, [pc, #108]	; (1f80 <tcp_create_segment+0xb4>)
    1f14:	4798      	blx	r3
    1f16:	4606      	mov	r6, r0
    1f18:	b120      	cbz	r0, 1f24 <tcp_create_segment+0x58>
		tcp_seg_free(seg);
    1f1a:	4620      	mov	r0, r4
    1f1c:	4b19      	ldr	r3, [pc, #100]	; (1f84 <tcp_create_segment+0xb8>)
    1f1e:	4798      	blx	r3
		return NULL;
    1f20:	464c      	mov	r4, r9
    1f22:	e7e7      	b.n	1ef4 <tcp_create_segment+0x28>
	seg->tcphdr        = (struct tcp_hdr *)seg->p->payload;
    1f24:	6863      	ldr	r3, [r4, #4]
	seg->tcphdr->src   = htons(pcb->local_port);
    1f26:	f8df 9064 	ldr.w	r9, [pc, #100]	; 1f8c <tcp_create_segment+0xc0>
	seg->tcphdr        = (struct tcp_hdr *)seg->p->payload;
    1f2a:	f8d3 b004 	ldr.w	fp, [r3, #4]
	seg->tcphdr->src   = htons(pcb->local_port);
    1f2e:	f8b8 001a 	ldrh.w	r0, [r8, #26]
	seg->tcphdr        = (struct tcp_hdr *)seg->p->payload;
    1f32:	f8c4 b00c 	str.w	fp, [r4, #12]
	seg->tcphdr->src   = htons(pcb->local_port);
    1f36:	47c8      	blx	r9
    1f38:	f8ab 0000 	strh.w	r0, [fp]
	seg->tcphdr->dest  = htons(pcb->remote_port);
    1f3c:	f8b8 001c 	ldrh.w	r0, [r8, #28]
    1f40:	f8d4 b00c 	ldr.w	fp, [r4, #12]
    1f44:	47c8      	blx	r9
	seg->tcphdr->seqno = htonl(seqno);
    1f46:	4b10      	ldr	r3, [pc, #64]	; (1f88 <tcp_create_segment+0xbc>)
	seg->tcphdr->dest  = htons(pcb->remote_port);
    1f48:	f8ab 0002 	strh.w	r0, [fp, #2]
	seg->tcphdr->seqno = htonl(seqno);
    1f4c:	4650      	mov	r0, sl
    1f4e:	f8d4 800c 	ldr.w	r8, [r4, #12]
	TCPH_HDRLEN_FLAGS_SET(seg->tcphdr, (5 + optlen / 4), flags);
    1f52:	02ad      	lsls	r5, r5, #10
	seg->tcphdr->seqno = htonl(seqno);
    1f54:	4798      	blx	r3
	TCPH_HDRLEN_FLAGS_SET(seg->tcphdr, (5 + optlen / 4), flags);
    1f56:	f505 45a0 	add.w	r5, r5, #20480	; 0x5000
    1f5a:	f405 4570 	and.w	r5, r5, #61440	; 0xf000
	seg->tcphdr->seqno = htonl(seqno);
    1f5e:	f8c8 0004 	str.w	r0, [r8, #4]
	TCPH_HDRLEN_FLAGS_SET(seg->tcphdr, (5 + optlen / 4), flags);
    1f62:	ea45 0007 	orr.w	r0, r5, r7
    1f66:	f8d4 800c 	ldr.w	r8, [r4, #12]
    1f6a:	47c8      	blx	r9
	seg->tcphdr->urgp = 0;
    1f6c:	68e3      	ldr	r3, [r4, #12]
	TCPH_HDRLEN_FLAGS_SET(seg->tcphdr, (5 + optlen / 4), flags);
    1f6e:	f8a8 000c 	strh.w	r0, [r8, #12]
	seg->tcphdr->urgp = 0;
    1f72:	749e      	strb	r6, [r3, #18]
    1f74:	74de      	strb	r6, [r3, #19]
	return seg;
    1f76:	e7bd      	b.n	1ef4 <tcp_create_segment+0x28>
    1f78:	00004c05 	.word	0x00004c05
    1f7c:	000030e1 	.word	0x000030e1
    1f80:	00003089 	.word	0x00003089
    1f84:	00006ac5 	.word	0x00006ac5
    1f88:	00000d6d 	.word	0x00000d6d
    1f8c:	00000d61 	.word	0x00000d61

00001f90 <tcp_output_alloc_header.constprop.0>:
	struct pbuf *   p = pbuf_alloc(PBUF_IP, TCP_HLEN + optlen + datalen, PBUF_RAM);
    1f90:	3114      	adds	r1, #20
static struct pbuf *tcp_output_alloc_header(struct tcp_pcb *pcb, u16_t optlen, u16_t datalen,
    1f92:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	struct pbuf *   p = pbuf_alloc(PBUF_IP, TCP_HLEN + optlen + datalen, PBUF_RAM);
    1f96:	4b15      	ldr	r3, [pc, #84]	; (1fec <tcp_output_alloc_header.constprop.0+0x5c>)
static struct pbuf *tcp_output_alloc_header(struct tcp_pcb *pcb, u16_t optlen, u16_t datalen,
    1f98:	4605      	mov	r5, r0
    1f9a:	4690      	mov	r8, r2
	struct pbuf *   p = pbuf_alloc(PBUF_IP, TCP_HLEN + optlen + datalen, PBUF_RAM);
    1f9c:	b289      	uxth	r1, r1
    1f9e:	2200      	movs	r2, #0
    1fa0:	2001      	movs	r0, #1
    1fa2:	4798      	blx	r3
	if (p != NULL) {
    1fa4:	4606      	mov	r6, r0
    1fa6:	b1e8      	cbz	r0, 1fe4 <tcp_output_alloc_header.constprop.0+0x54>
		tcphdr        = (struct tcp_hdr *)p->payload;
    1fa8:	6844      	ldr	r4, [r0, #4]
		tcphdr->src   = htons(pcb->local_port);
    1faa:	4f11      	ldr	r7, [pc, #68]	; (1ff0 <tcp_output_alloc_header.constprop.0+0x60>)
    1fac:	8b68      	ldrh	r0, [r5, #26]
    1fae:	47b8      	blx	r7
    1fb0:	8020      	strh	r0, [r4, #0]
		tcphdr->dest  = htons(pcb->remote_port);
    1fb2:	8ba8      	ldrh	r0, [r5, #28]
    1fb4:	47b8      	blx	r7
		tcphdr->ackno = htonl(pcb->rcv_nxt);
    1fb6:	4b0f      	ldr	r3, [pc, #60]	; (1ff4 <tcp_output_alloc_header.constprop.0+0x64>)
		tcphdr->dest  = htons(pcb->remote_port);
    1fb8:	8060      	strh	r0, [r4, #2]
		tcphdr->seqno = seqno_be;
    1fba:	f8c4 8004 	str.w	r8, [r4, #4]
		tcphdr->ackno = htonl(pcb->rcv_nxt);
    1fbe:	6aa8      	ldr	r0, [r5, #40]	; 0x28
    1fc0:	4798      	blx	r3
    1fc2:	60a0      	str	r0, [r4, #8]
		TCPH_HDRLEN_FLAGS_SET(tcphdr, (5 + optlen / 4), TCP_ACK);
    1fc4:	f245 0010 	movw	r0, #20496	; 0x5010
    1fc8:	47b8      	blx	r7
    1fca:	81a0      	strh	r0, [r4, #12]
		tcphdr->wnd    = htons(pcb->rcv_ann_wnd);
    1fcc:	8de8      	ldrh	r0, [r5, #46]	; 0x2e
    1fce:	47b8      	blx	r7
		tcphdr->chksum = 0;
    1fd0:	2300      	movs	r3, #0
    1fd2:	7423      	strb	r3, [r4, #16]
    1fd4:	7463      	strb	r3, [r4, #17]
		tcphdr->urgp   = 0;
    1fd6:	74a3      	strb	r3, [r4, #18]
    1fd8:	74e3      	strb	r3, [r4, #19]
		pcb->rcv_ann_right_edge = pcb->rcv_nxt + pcb->rcv_ann_wnd;
    1fda:	8dea      	ldrh	r2, [r5, #46]	; 0x2e
    1fdc:	6aab      	ldr	r3, [r5, #40]	; 0x28
		tcphdr->wnd    = htons(pcb->rcv_ann_wnd);
    1fde:	81e0      	strh	r0, [r4, #14]
		pcb->rcv_ann_right_edge = pcb->rcv_nxt + pcb->rcv_ann_wnd;
    1fe0:	4413      	add	r3, r2
    1fe2:	632b      	str	r3, [r5, #48]	; 0x30
}
    1fe4:	4630      	mov	r0, r6
    1fe6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    1fea:	bf00      	nop
    1fec:	00003139 	.word	0x00003139
    1ff0:	00000d61 	.word	0x00000d61
    1ff4:	00000d6d 	.word	0x00000d6d

00001ff8 <tcp_write>:
 * - TCP_WRITE_FLAG_COPY (0x01) data will be copied into memory belonging to the stack
 * - TCP_WRITE_FLAG_MORE (0x02) for TCP connection, PSH flag will be set on last segment sent,
 * @return ERR_OK if enqueued, another err_t on error
 */
err_t tcp_write(struct tcp_pcb *pcb, const void *arg, u16_t len, u8_t apiflags)
{
    1ff8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    1ffc:	ed2d 8b02 	vpush	{d8}
    2000:	b08d      	sub	sp, #52	; 0x34
    2002:	4604      	mov	r4, r0
    2004:	9306      	str	r3, [sp, #24]
	u16_t           pos = 0; /* position in 'arg' data */
	u16_t           queuelen;
	u8_t            optlen   = 0;
	u8_t            optflags = 0;
#if TCP_OVERSIZE
	u16_t oversize      = 0;
    2006:	2300      	movs	r3, #0
{
    2008:	4617      	mov	r7, r2
	u16_t oversize      = 0;
    200a:	f8ad 302e 	strh.w	r3, [sp, #46]	; 0x2e
#endif /* LWIP_NETIF_TX_SINGLE_PBUF */

	LWIP_DEBUGF(
	    TCP_OUTPUT_DEBUG,
	    ("tcp_write(pcb=%p, data=%p, len=%" U16_F ", apiflags=%" U16_F ")\n", (void *)pcb, arg, len, (u16_t)apiflags));
	LWIP_ERROR("tcp_write: arg == NULL (programmer violates API)", arg != NULL, return ERR_ARG;);
    200e:	9105      	str	r1, [sp, #20]
    2010:	b901      	cbnz	r1, 2014 <tcp_write+0x1c>
    2012:	e7fe      	b.n	2012 <tcp_write+0x1a>
	if ((pcb->state != ESTABLISHED) && (pcb->state != CLOSE_WAIT) && (pcb->state != SYN_SENT)
    2014:	7e03      	ldrb	r3, [r0, #24]
    2016:	2b07      	cmp	r3, #7
    2018:	d003      	beq.n	2022 <tcp_write+0x2a>
    201a:	3b02      	subs	r3, #2
    201c:	2b02      	cmp	r3, #2
    201e:	f200 8172 	bhi.w	2306 <tcp_write+0x30e>
	} else if (len == 0) {
    2022:	b177      	cbz	r7, 2042 <tcp_write+0x4a>
	if (len > pcb->snd_buf) {
    2024:	f8b4 3066 	ldrh.w	r3, [r4, #102]	; 0x66
    2028:	42bb      	cmp	r3, r7
    202a:	d206      	bcs.n	203a <tcp_write+0x42>
		pcb->flags |= TF_NAGLEMEMERR;
    202c:	7fa3      	ldrb	r3, [r4, #30]
    202e:	f063 037f 	orn	r3, r3, #127	; 0x7f
    2032:	77a3      	strb	r3, [r4, #30]
	}
	if (pcb->snd_queuelen != 0) {
		LWIP_ASSERT("tcp_write: valid queue length", pcb->unacked != NULL || pcb->unsent != NULL);
	}
	LWIP_DEBUGF(TCP_QLEN_DEBUG | LWIP_DBG_STATE, ("tcp_write: %" S16_F " (with mem err)\n", pcb->snd_queuelen));
	return ERR_MEM;
    2034:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    2038:	e167      	b.n	230a <tcp_write+0x312>
	if ((pcb->snd_queuelen >= TCP_SND_QUEUELEN) || (pcb->snd_queuelen > TCP_SNDQUEUELEN_OVERFLOW)) {
    203a:	f8b4 3068 	ldrh.w	r3, [r4, #104]	; 0x68
    203e:	2b07      	cmp	r3, #7
    2040:	d8f4      	bhi.n	202c <tcp_write+0x34>
	u16_t mss_local = LWIP_MIN(pcb->mss, pcb->snd_wnd_max / 2);
    2042:	f8b4 3062 	ldrh.w	r3, [r4, #98]	; 0x62
    2046:	8ee2      	ldrh	r2, [r4, #54]	; 0x36
	if (pcb->unsent != NULL) {
    2048:	f8d4 806c 	ldr.w	r8, [r4, #108]	; 0x6c
	u16_t mss_local = LWIP_MIN(pcb->mss, pcb->snd_wnd_max / 2);
    204c:	085b      	lsrs	r3, r3, #1
    204e:	4293      	cmp	r3, r2
    2050:	bf28      	it	cs
    2052:	4613      	movcs	r3, r2
    2054:	9307      	str	r3, [sp, #28]
	queuelen = pcb->snd_queuelen;
    2056:	f8b4 3068 	ldrh.w	r3, [r4, #104]	; 0x68
    205a:	9304      	str	r3, [sp, #16]
	if (pcb->unsent != NULL) {
    205c:	f1b8 0f00 	cmp.w	r8, #0
    2060:	d105      	bne.n	206e <tcp_write+0x76>
	struct tcp_seg *last_unsent = NULL, *seg = NULL, *prev_seg = NULL, *queue = NULL;
    2062:	46c2      	mov	sl, r8
	struct pbuf *   concat_p    = NULL;
    2064:	46c1      	mov	r9, r8
	u16_t oversize_used = 0;
    2066:	4645      	mov	r5, r8
	u16_t           pos = 0; /* position in 'arg' data */
    2068:	4646      	mov	r6, r8
    206a:	e05a      	b.n	2122 <tcp_write+0x12a>
    206c:	46c8      	mov	r8, r9
		for (last_unsent = pcb->unsent; last_unsent->next != NULL; last_unsent = last_unsent->next)
    206e:	f8d8 9000 	ldr.w	r9, [r8]
    2072:	46c2      	mov	sl, r8
    2074:	f1b9 0f00 	cmp.w	r9, #0
    2078:	d1f8      	bne.n	206c <tcp_write+0x74>
		unsent_optlen = LWIP_TCP_OPT_LENGTH(last_unsent->flags);
    207a:	f898 300a 	ldrb.w	r3, [r8, #10]
		oversize = pcb->unsent_oversize;
    207e:	f8b4 506a 	ldrh.w	r5, [r4, #106]	; 0x6a
		unsent_optlen = LWIP_TCP_OPT_LENGTH(last_unsent->flags);
    2082:	009a      	lsls	r2, r3, #2
    2084:	f013 0f02 	tst.w	r3, #2
    2088:	f002 0104 	and.w	r1, r2, #4
		space         = mss_local - (last_unsent->len + unsent_optlen);
    208c:	f8b8 3008 	ldrh.w	r3, [r8, #8]
    2090:	9a07      	ldr	r2, [sp, #28]
    2092:	eba2 0203 	sub.w	r2, r2, r3
		unsent_optlen = LWIP_TCP_OPT_LENGTH(last_unsent->flags);
    2096:	bf14      	ite	ne
    2098:	200c      	movne	r0, #12
    209a:	2000      	moveq	r0, #0
		space         = mss_local - (last_unsent->len + unsent_optlen);
    209c:	1a52      	subs	r2, r2, r1
    209e:	1a12      	subs	r2, r2, r0
    20a0:	b292      	uxth	r2, r2
		if (oversize > 0) {
    20a2:	2d00      	cmp	r5, #0
    20a4:	d047      	beq.n	2136 <tcp_write+0x13e>
			oversize_used = oversize < len ? oversize : len;
    20a6:	42bd      	cmp	r5, r7
    20a8:	4629      	mov	r1, r5
    20aa:	bf28      	it	cs
    20ac:	4639      	movcs	r1, r7
			oversize -= oversize_used;
    20ae:	1a6d      	subs	r5, r5, r1
			space -= oversize_used;
    20b0:	1a52      	subs	r2, r2, r1
			oversize -= oversize_used;
    20b2:	f8ad 502e 	strh.w	r5, [sp, #46]	; 0x2e
			space -= oversize_used;
    20b6:	b292      	uxth	r2, r2
			pos += oversize_used;
    20b8:	460d      	mov	r5, r1
		if ((pos < len) && (space > 0) && (last_unsent->len > 0)) {
    20ba:	42bd      	cmp	r5, r7
    20bc:	f080 80e7 	bcs.w	228e <tcp_write+0x296>
    20c0:	2a00      	cmp	r2, #0
    20c2:	f000 80e2 	beq.w	228a <tcp_write+0x292>
    20c6:	2b00      	cmp	r3, #0
    20c8:	f000 80df 	beq.w	228a <tcp_write+0x292>
			u16_t seglen = space < len - pos ? space : len - pos;
    20cc:	eba7 0805 	sub.w	r8, r7, r5
			if (apiflags & TCP_WRITE_FLAG_COPY) {
    20d0:	9b06      	ldr	r3, [sp, #24]
			u16_t seglen = space < len - pos ? space : len - pos;
    20d2:	4590      	cmp	r8, r2
    20d4:	bfa8      	it	ge
    20d6:	4690      	movge	r8, r2
			if (apiflags & TCP_WRITE_FLAG_COPY) {
    20d8:	07db      	lsls	r3, r3, #31
			u16_t seglen = space < len - pos ? space : len - pos;
    20da:	fa1f f688 	uxth.w	r6, r8
			if (apiflags & TCP_WRITE_FLAG_COPY) {
    20de:	d52c      	bpl.n	213a <tcp_write+0x142>
				if ((concat_p = tcp_pbuf_prealloc(PBUF_RAW, seglen, space, &oversize, pcb, apiflags, 1)) == NULL) {
    20e0:	2301      	movs	r3, #1
    20e2:	9302      	str	r3, [sp, #8]
    20e4:	9b06      	ldr	r3, [sp, #24]
    20e6:	f8df b248 	ldr.w	fp, [pc, #584]	; 2330 <tcp_write+0x338>
    20ea:	e9cd 4300 	strd	r4, r3, [sp]
    20ee:	4631      	mov	r1, r6
    20f0:	f10d 032e 	add.w	r3, sp, #46	; 0x2e
    20f4:	2003      	movs	r0, #3
    20f6:	47d8      	blx	fp
    20f8:	4683      	mov	fp, r0
    20fa:	2800      	cmp	r0, #0
    20fc:	f000 8100 	beq.w	2300 <tcp_write+0x308>
				TCP_DATA_COPY2(concat_p->payload, (u8_t *)arg + pos, seglen, &concat_chksum, &concat_chksum_swapped);
    2100:	9b05      	ldr	r3, [sp, #20]
    2102:	6840      	ldr	r0, [r0, #4]
    2104:	1959      	adds	r1, r3, r5
    2106:	4632      	mov	r2, r6
    2108:	4b82      	ldr	r3, [pc, #520]	; (2314 <tcp_write+0x31c>)
    210a:	4798      	blx	r3
			queuelen += pbuf_clen(concat_p);
    210c:	4b82      	ldr	r3, [pc, #520]	; (2318 <tcp_write+0x320>)
    210e:	4658      	mov	r0, fp
    2110:	4798      	blx	r3
    2112:	9b04      	ldr	r3, [sp, #16]
    2114:	4403      	add	r3, r0
			pos += seglen;
    2116:	442e      	add	r6, r5
			queuelen += pbuf_clen(concat_p);
    2118:	b29b      	uxth	r3, r3
			pos += seglen;
    211a:	b2b6      	uxth	r6, r6
			queuelen += pbuf_clen(concat_p);
    211c:	9304      	str	r3, [sp, #16]
    211e:	46d0      	mov	r8, sl
    2120:	46d9      	mov	r9, fp
		if (apiflags & TCP_WRITE_FLAG_COPY) {
    2122:	9b06      	ldr	r3, [sp, #24]
    2124:	f04f 0b00 	mov.w	fp, #0
    2128:	f003 0301 	and.w	r3, r3, #1
    212c:	ee08 3a10 	vmov	s16, r3
    2130:	f8cd b020 	str.w	fp, [sp, #32]
    2134:	e083      	b.n	223e <tcp_write+0x246>
	struct tcp_seg *last_unsent = NULL, *seg = NULL, *prev_seg = NULL, *queue = NULL;
    2136:	46a8      	mov	r8, r5
    2138:	e7bf      	b.n	20ba <tcp_write+0xc2>
				if ((concat_p = pbuf_alloc(PBUF_RAW, seglen, PBUF_ROM)) == NULL) {
    213a:	4b78      	ldr	r3, [pc, #480]	; (231c <tcp_write+0x324>)
    213c:	2201      	movs	r2, #1
    213e:	4631      	mov	r1, r6
    2140:	2003      	movs	r0, #3
    2142:	4798      	blx	r3
    2144:	4683      	mov	fp, r0
    2146:	2800      	cmp	r0, #0
    2148:	f000 80da 	beq.w	2300 <tcp_write+0x308>
				concat_p->payload = (u8_t *)arg + pos;
    214c:	9b05      	ldr	r3, [sp, #20]
    214e:	442b      	add	r3, r5
    2150:	6043      	str	r3, [r0, #4]
    2152:	e7db      	b.n	210c <tcp_write+0x114>
		u16_t        seglen  = left > max_len ? max_len : left;
    2154:	9a07      	ldr	r2, [sp, #28]
		u16_t        left    = len - pos;
    2156:	1bbb      	subs	r3, r7, r6
		u16_t        seglen  = left > max_len ? max_len : left;
    2158:	b29b      	uxth	r3, r3
    215a:	4293      	cmp	r3, r2
    215c:	bf28      	it	cs
    215e:	4613      	movcs	r3, r2
    2160:	ee08 3a90 	vmov	s17, r3
		if (apiflags & TCP_WRITE_FLAG_COPY) {
    2164:	ee18 3a10 	vmov	r3, s16
    2168:	b313      	cbz	r3, 21b0 <tcp_write+0x1b8>
			if ((p = tcp_pbuf_prealloc(
    216a:	fabb f38b 	clz	r3, fp
    216e:	095b      	lsrs	r3, r3, #5
    2170:	9302      	str	r3, [sp, #8]
    2172:	9b06      	ldr	r3, [sp, #24]
    2174:	f8df 81b8 	ldr.w	r8, [pc, #440]	; 2330 <tcp_write+0x338>
    2178:	e9cd 4300 	strd	r4, r3, [sp]
    217c:	ee18 1a90 	vmov	r1, s17
    2180:	f10d 032e 	add.w	r3, sp, #46	; 0x2e
    2184:	2000      	movs	r0, #0
    2186:	47c0      	blx	r8
    2188:	4680      	mov	r8, r0
    218a:	b358      	cbz	r0, 21e4 <tcp_write+0x1ec>
			TCP_DATA_COPY2((char *)p->payload + optlen, (u8_t *)arg + pos, seglen, &chksum, &chksum_swapped);
    218c:	9b05      	ldr	r3, [sp, #20]
    218e:	6840      	ldr	r0, [r0, #4]
    2190:	1999      	adds	r1, r3, r6
    2192:	ee18 2a90 	vmov	r2, s17
    2196:	4b5f      	ldr	r3, [pc, #380]	; (2314 <tcp_write+0x31c>)
    2198:	4798      	blx	r3
		queuelen += pbuf_clen(p);
    219a:	4b5f      	ldr	r3, [pc, #380]	; (2318 <tcp_write+0x320>)
    219c:	4640      	mov	r0, r8
    219e:	4798      	blx	r3
    21a0:	9b04      	ldr	r3, [sp, #16]
    21a2:	4403      	add	r3, r0
    21a4:	b29b      	uxth	r3, r3
		if ((queuelen > TCP_SND_QUEUELEN) || (queuelen > TCP_SNDQUEUELEN_OVERFLOW)) {
    21a6:	2b08      	cmp	r3, #8
		queuelen += pbuf_clen(p);
    21a8:	9304      	str	r3, [sp, #16]
		if ((queuelen > TCP_SND_QUEUELEN) || (queuelen > TCP_SNDQUEUELEN_OVERFLOW)) {
    21aa:	d931      	bls.n	2210 <tcp_write+0x218>
			pbuf_free(p);
    21ac:	4640      	mov	r0, r8
    21ae:	e017      	b.n	21e0 <tcp_write+0x1e8>
			if ((p2 = pbuf_alloc(PBUF_TRANSPORT, seglen, PBUF_ROM)) == NULL) {
    21b0:	ee18 1a90 	vmov	r1, s17
    21b4:	ee18 0a10 	vmov	r0, s16
    21b8:	4b58      	ldr	r3, [pc, #352]	; (231c <tcp_write+0x324>)
    21ba:	2201      	movs	r2, #1
    21bc:	4798      	blx	r3
    21be:	b188      	cbz	r0, 21e4 <tcp_write+0x1ec>
			p2->payload = (u8_t *)arg + pos;
    21c0:	9a05      	ldr	r2, [sp, #20]
			if ((p = pbuf_alloc(PBUF_TRANSPORT, optlen, PBUF_RAM)) == NULL) {
    21c2:	4b56      	ldr	r3, [pc, #344]	; (231c <tcp_write+0x324>)
			p2->payload = (u8_t *)arg + pos;
    21c4:	9009      	str	r0, [sp, #36]	; 0x24
    21c6:	4432      	add	r2, r6
    21c8:	6042      	str	r2, [r0, #4]
			if ((p = pbuf_alloc(PBUF_TRANSPORT, optlen, PBUF_RAM)) == NULL) {
    21ca:	ee18 1a10 	vmov	r1, s16
    21ce:	ee18 2a10 	vmov	r2, s16
    21d2:	ee18 0a10 	vmov	r0, s16
    21d6:	4798      	blx	r3
    21d8:	9b09      	ldr	r3, [sp, #36]	; 0x24
    21da:	4680      	mov	r8, r0
    21dc:	b9a0      	cbnz	r0, 2208 <tcp_write+0x210>
				pbuf_free(p2);
    21de:	4618      	mov	r0, r3
			pbuf_free(p);
    21e0:	4b4f      	ldr	r3, [pc, #316]	; (2320 <tcp_write+0x328>)
    21e2:	4798      	blx	r3
	pcb->flags |= TF_NAGLEMEMERR;
    21e4:	7fa3      	ldrb	r3, [r4, #30]
    21e6:	f063 037f 	orn	r3, r3, #127	; 0x7f
    21ea:	77a3      	strb	r3, [r4, #30]
	if (concat_p != NULL) {
    21ec:	f1b9 0f00 	cmp.w	r9, #0
    21f0:	d002      	beq.n	21f8 <tcp_write+0x200>
		pbuf_free(concat_p);
    21f2:	4b4b      	ldr	r3, [pc, #300]	; (2320 <tcp_write+0x328>)
    21f4:	4648      	mov	r0, r9
    21f6:	4798      	blx	r3
	if (queue != NULL) {
    21f8:	f1bb 0f00 	cmp.w	fp, #0
    21fc:	f43f af1a 	beq.w	2034 <tcp_write+0x3c>
		tcp_segs_free(queue);
    2200:	4b48      	ldr	r3, [pc, #288]	; (2324 <tcp_write+0x32c>)
    2202:	4658      	mov	r0, fp
    2204:	4798      	blx	r3
    2206:	e715      	b.n	2034 <tcp_write+0x3c>
			pbuf_cat(p /*header*/, p2 /*data*/);
    2208:	4619      	mov	r1, r3
    220a:	4b47      	ldr	r3, [pc, #284]	; (2328 <tcp_write+0x330>)
    220c:	4798      	blx	r3
    220e:	e7c4      	b.n	219a <tcp_write+0x1a2>
		if ((seg = tcp_create_segment(pcb, p, 0, pcb->snd_lbb + pos, optflags)) == NULL) {
    2210:	6de3      	ldr	r3, [r4, #92]	; 0x5c
    2212:	2200      	movs	r2, #0
    2214:	4641      	mov	r1, r8
    2216:	9200      	str	r2, [sp, #0]
    2218:	f8df 8118 	ldr.w	r8, [pc, #280]	; 2334 <tcp_write+0x33c>
    221c:	4433      	add	r3, r6
    221e:	4620      	mov	r0, r4
    2220:	47c0      	blx	r8
    2222:	4680      	mov	r8, r0
    2224:	2800      	cmp	r0, #0
    2226:	d0dd      	beq.n	21e4 <tcp_write+0x1ec>
		if (queue == NULL) {
    2228:	f1bb 0f00 	cmp.w	fp, #0
    222c:	d02b      	beq.n	2286 <tcp_write+0x28e>
			prev_seg->next = seg;
    222e:	9b08      	ldr	r3, [sp, #32]
    2230:	6018      	str	r0, [r3, #0]
		pos += seglen;
    2232:	ee18 3a90 	vmov	r3, s17
    2236:	441e      	add	r6, r3
    2238:	b2b6      	uxth	r6, r6
    223a:	f8cd 8020 	str.w	r8, [sp, #32]
	while (pos < len) {
    223e:	42be      	cmp	r6, r7
    2240:	d388      	bcc.n	2154 <tcp_write+0x15c>
    2242:	464b      	mov	r3, r9
    2244:	46d9      	mov	r9, fp
	if (oversize_used > 0) {
    2246:	b14d      	cbz	r5, 225c <tcp_write+0x264>
		for (p = last_unsent->p; p; p = p->next) {
    2248:	f8da 6004 	ldr.w	r6, [sl, #4]
				TCP_DATA_COPY((char *)p->payload + p->len, arg, oversize_used, last_unsent);
    224c:	f8df b0c4 	ldr.w	fp, [pc, #196]	; 2314 <tcp_write+0x31c>
		for (p = last_unsent->p; p; p = p->next) {
    2250:	b9fe      	cbnz	r6, 2292 <tcp_write+0x29a>
		last_unsent->len += oversize_used;
    2252:	f8ba 2008 	ldrh.w	r2, [sl, #8]
    2256:	4415      	add	r5, r2
    2258:	f8aa 5008 	strh.w	r5, [sl, #8]
	pcb->unsent_oversize = oversize;
    225c:	f8bd 202e 	ldrh.w	r2, [sp, #46]	; 0x2e
    2260:	f8a4 206a 	strh.w	r2, [r4, #106]	; 0x6a
	if (concat_p != NULL) {
    2264:	b343      	cbz	r3, 22b8 <tcp_write+0x2c0>
		pbuf_cat(last_unsent->p, concat_p);
    2266:	4a30      	ldr	r2, [pc, #192]	; (2328 <tcp_write+0x330>)
    2268:	f8da 0004 	ldr.w	r0, [sl, #4]
    226c:	9305      	str	r3, [sp, #20]
    226e:	4619      	mov	r1, r3
    2270:	4790      	blx	r2
		last_unsent->len += concat_p->tot_len;
    2272:	9b05      	ldr	r3, [sp, #20]
    2274:	f8ba 2008 	ldrh.w	r2, [sl, #8]
    2278:	891b      	ldrh	r3, [r3, #8]
    227a:	4413      	add	r3, r2
    227c:	f8aa 3008 	strh.w	r3, [sl, #8]
		last_unsent->next = queue;
    2280:	f8ca 9000 	str.w	r9, [sl]
    2284:	e01d      	b.n	22c2 <tcp_write+0x2ca>
    2286:	4683      	mov	fp, r0
    2288:	e7d3      	b.n	2232 <tcp_write+0x23a>
    228a:	462e      	mov	r6, r5
    228c:	e749      	b.n	2122 <tcp_write+0x12a>
	struct pbuf *   concat_p    = NULL;
    228e:	2300      	movs	r3, #0
    2290:	e7d9      	b.n	2246 <tcp_write+0x24e>
			p->tot_len += oversize_used;
    2292:	8932      	ldrh	r2, [r6, #8]
    2294:	442a      	add	r2, r5
    2296:	8132      	strh	r2, [r6, #8]
			if (p->next == NULL) {
    2298:	6832      	ldr	r2, [r6, #0]
    229a:	b95a      	cbnz	r2, 22b4 <tcp_write+0x2bc>
				TCP_DATA_COPY((char *)p->payload + p->len, arg, oversize_used, last_unsent);
    229c:	f8b6 c00a 	ldrh.w	ip, [r6, #10]
    22a0:	6870      	ldr	r0, [r6, #4]
    22a2:	9905      	ldr	r1, [sp, #20]
    22a4:	9307      	str	r3, [sp, #28]
    22a6:	462a      	mov	r2, r5
    22a8:	4460      	add	r0, ip
    22aa:	47d8      	blx	fp
				p->len += oversize_used;
    22ac:	8972      	ldrh	r2, [r6, #10]
    22ae:	9b07      	ldr	r3, [sp, #28]
    22b0:	442a      	add	r2, r5
    22b2:	8172      	strh	r2, [r6, #10]
		for (p = last_unsent->p; p; p = p->next) {
    22b4:	6836      	ldr	r6, [r6, #0]
    22b6:	e7cb      	b.n	2250 <tcp_write+0x258>
	if (last_unsent == NULL) {
    22b8:	f1ba 0f00 	cmp.w	sl, #0
    22bc:	d1e0      	bne.n	2280 <tcp_write+0x288>
		pcb->unsent = queue;
    22be:	f8c4 906c 	str.w	r9, [r4, #108]	; 0x6c
	pcb->snd_lbb += len;
    22c2:	6de3      	ldr	r3, [r4, #92]	; 0x5c
	pcb->snd_buf -= len;
    22c4:	f8b4 2066 	ldrh.w	r2, [r4, #102]	; 0x66
	pcb->snd_lbb += len;
    22c8:	443b      	add	r3, r7
    22ca:	65e3      	str	r3, [r4, #92]	; 0x5c
	pcb->snd_buf -= len;
    22cc:	1bd7      	subs	r7, r2, r7
	pcb->snd_queuelen = queuelen;
    22ce:	9b04      	ldr	r3, [sp, #16]
	pcb->snd_buf -= len;
    22d0:	f8a4 7066 	strh.w	r7, [r4, #102]	; 0x66
	pcb->snd_queuelen = queuelen;
    22d4:	f8a4 3068 	strh.w	r3, [r4, #104]	; 0x68
	if (seg != NULL && seg->tcphdr != NULL && ((apiflags & TCP_WRITE_FLAG_MORE) == 0)) {
    22d8:	f1b8 0f00 	cmp.w	r8, #0
    22dc:	d00e      	beq.n	22fc <tcp_write+0x304>
    22de:	f8d8 000c 	ldr.w	r0, [r8, #12]
    22e2:	b190      	cbz	r0, 230a <tcp_write+0x312>
    22e4:	9b06      	ldr	r3, [sp, #24]
    22e6:	f013 0402 	ands.w	r4, r3, #2
    22ea:	d107      	bne.n	22fc <tcp_write+0x304>
		TCPH_SET_FLAG(seg->tcphdr, TCP_PSH);
    22ec:	8985      	ldrh	r5, [r0, #12]
    22ee:	4b0f      	ldr	r3, [pc, #60]	; (232c <tcp_write+0x334>)
    22f0:	2008      	movs	r0, #8
    22f2:	4798      	blx	r3
    22f4:	f8d8 300c 	ldr.w	r3, [r8, #12]
    22f8:	4328      	orrs	r0, r5
    22fa:	8198      	strh	r0, [r3, #12]
	return ERR_OK;
    22fc:	2000      	movs	r0, #0
    22fe:	e004      	b.n	230a <tcp_write+0x312>
	struct tcp_seg *last_unsent = NULL, *seg = NULL, *prev_seg = NULL, *queue = NULL;
    2300:	f04f 0b00 	mov.w	fp, #0
    2304:	e76e      	b.n	21e4 <tcp_write+0x1ec>
		return ERR_CONN;
    2306:	f06f 000c 	mvn.w	r0, #12
}
    230a:	b00d      	add	sp, #52	; 0x34
    230c:	ecbd 8b02 	vpop	{d8}
    2310:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    2314:	0000c07d 	.word	0x0000c07d
    2318:	0000329d 	.word	0x0000329d
    231c:	00003139 	.word	0x00003139
    2320:	000030e1 	.word	0x000030e1
    2324:	00006ae9 	.word	0x00006ae9
    2328:	000032b7 	.word	0x000032b7
    232c:	00000d61 	.word	0x00000d61
    2330:	00001e79 	.word	0x00001e79
    2334:	00001ecd 	.word	0x00001ecd

00002338 <tcp_enqueue_flags>:

	LWIP_ASSERT("tcp_enqueue_flags: need either TCP_SYN or TCP_FIN in flags (programmer violates API)",
	            (flags & (TCP_SYN | TCP_FIN)) != 0);

	/* check for configured max queuelen and possible overflow */
	if ((pcb->snd_queuelen >= TCP_SND_QUEUELEN) || (pcb->snd_queuelen > TCP_SNDQUEUELEN_OVERFLOW)) {
    2338:	f8b0 3068 	ldrh.w	r3, [r0, #104]	; 0x68
    233c:	2b07      	cmp	r3, #7
{
    233e:	b573      	push	{r0, r1, r4, r5, r6, lr}
    2340:	4604      	mov	r4, r0
    2342:	460d      	mov	r5, r1
	if ((pcb->snd_queuelen >= TCP_SND_QUEUELEN) || (pcb->snd_queuelen > TCP_SNDQUEUELEN_OVERFLOW)) {
    2344:	d906      	bls.n	2354 <tcp_enqueue_flags+0x1c>
	}
	LWIP_ASSERT("tcp_enqueue_flags: check that first pbuf can hold optlen", (p->len >= optlen));

	/* Allocate memory for tcp_seg, and fill in fields. */
	if ((seg = tcp_create_segment(pcb, p, flags, pcb->snd_lbb, optflags)) == NULL) {
		pcb->flags |= TF_NAGLEMEMERR;
    2346:	7fa3      	ldrb	r3, [r4, #30]
    2348:	f063 037f 	orn	r3, r3, #127	; 0x7f
    234c:	77a3      	strb	r3, [r4, #30]
		return ERR_MEM;
    234e:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    2352:	e034      	b.n	23be <tcp_enqueue_flags+0x86>
	if (pcb->snd_buf == 0) {
    2354:	f8b0 3066 	ldrh.w	r3, [r0, #102]	; 0x66
	if (flags & TCP_SYN) {
    2358:	f3c1 0640 	ubfx	r6, r1, #1, #1
	optlen = LWIP_TCP_OPT_LENGTH(optflags);
    235c:	00b1      	lsls	r1, r6, #2
	if (pcb->snd_buf == 0) {
    235e:	2b00      	cmp	r3, #0
    2360:	d0f5      	beq.n	234e <tcp_enqueue_flags+0x16>
	if ((p = pbuf_alloc(PBUF_TRANSPORT, optlen, PBUF_RAM)) == NULL) {
    2362:	2200      	movs	r2, #0
    2364:	4b1a      	ldr	r3, [pc, #104]	; (23d0 <tcp_enqueue_flags+0x98>)
    2366:	4610      	mov	r0, r2
    2368:	4798      	blx	r3
    236a:	4601      	mov	r1, r0
    236c:	2800      	cmp	r0, #0
    236e:	d0ea      	beq.n	2346 <tcp_enqueue_flags+0xe>
	if ((seg = tcp_create_segment(pcb, p, flags, pcb->snd_lbb, optflags)) == NULL) {
    2370:	9600      	str	r6, [sp, #0]
    2372:	6de3      	ldr	r3, [r4, #92]	; 0x5c
    2374:	4e17      	ldr	r6, [pc, #92]	; (23d4 <tcp_enqueue_flags+0x9c>)
    2376:	462a      	mov	r2, r5
    2378:	4620      	mov	r0, r4
    237a:	47b0      	blx	r6
    237c:	2800      	cmp	r0, #0
    237e:	d0e2      	beq.n	2346 <tcp_enqueue_flags+0xe>
	             ntohl(seg->tcphdr->seqno),
	             ntohl(seg->tcphdr->seqno) + TCP_TCPLEN(seg),
	             (u16_t)flags));

	/* Now append seg to pcb->unsent queue */
	if (pcb->unsent == NULL) {
    2380:	6ee3      	ldr	r3, [r4, #108]	; 0x6c
    2382:	b9f3      	cbnz	r3, 23c2 <tcp_enqueue_flags+0x8a>
		pcb->unsent = seg;
    2384:	66e0      	str	r0, [r4, #108]	; 0x6c
			;
		useg->next = seg;
	}
#if TCP_OVERSIZE
	/* The new unsent tail has no space */
	pcb->unsent_oversize = 0;
    2386:	2300      	movs	r3, #0
#endif /* TCP_OVERSIZE */

	/* SYN and FIN bump the sequence number */
	if ((flags & TCP_SYN) || (flags & TCP_FIN)) {
    2388:	07aa      	lsls	r2, r5, #30
	pcb->unsent_oversize = 0;
    238a:	f8a4 306a 	strh.w	r3, [r4, #106]	; 0x6a
	if ((flags & TCP_SYN) || (flags & TCP_FIN)) {
    238e:	d007      	beq.n	23a0 <tcp_enqueue_flags+0x68>
		pcb->snd_lbb++;
    2390:	6de3      	ldr	r3, [r4, #92]	; 0x5c
    2392:	3301      	adds	r3, #1
    2394:	65e3      	str	r3, [r4, #92]	; 0x5c
		/* optlen does not influence snd_buf */
		pcb->snd_buf--;
    2396:	f8b4 3066 	ldrh.w	r3, [r4, #102]	; 0x66
    239a:	3b01      	subs	r3, #1
    239c:	f8a4 3066 	strh.w	r3, [r4, #102]	; 0x66
	}
	if (flags & TCP_FIN) {
    23a0:	07eb      	lsls	r3, r5, #31
		pcb->flags |= TF_FIN;
    23a2:	bf42      	ittt	mi
    23a4:	7fa3      	ldrbmi	r3, [r4, #30]
    23a6:	f043 0320 	orrmi.w	r3, r3, #32
    23aa:	77a3      	strbmi	r3, [r4, #30]
	}

	/* update number of segments on the queues */
	pcb->snd_queuelen += pbuf_clen(seg->p);
    23ac:	6840      	ldr	r0, [r0, #4]
    23ae:	4b0a      	ldr	r3, [pc, #40]	; (23d8 <tcp_enqueue_flags+0xa0>)
    23b0:	4798      	blx	r3
    23b2:	f8b4 3068 	ldrh.w	r3, [r4, #104]	; 0x68
    23b6:	4418      	add	r0, r3
    23b8:	f8a4 0068 	strh.w	r0, [r4, #104]	; 0x68
	LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_enqueue_flags: %" S16_F " (after enqueued)\n", pcb->snd_queuelen));
	if (pcb->snd_queuelen != 0) {
		LWIP_ASSERT("tcp_enqueue_flags: invalid queue length", pcb->unacked != NULL || pcb->unsent != NULL);
	}

	return ERR_OK;
    23bc:	2000      	movs	r0, #0
}
    23be:	b002      	add	sp, #8
    23c0:	bd70      	pop	{r4, r5, r6, pc}
		for (useg = pcb->unsent; useg->next != NULL; useg = useg->next)
    23c2:	461a      	mov	r2, r3
    23c4:	681b      	ldr	r3, [r3, #0]
    23c6:	2b00      	cmp	r3, #0
    23c8:	d1fb      	bne.n	23c2 <tcp_enqueue_flags+0x8a>
		useg->next = seg;
    23ca:	6010      	str	r0, [r2, #0]
    23cc:	e7db      	b.n	2386 <tcp_enqueue_flags+0x4e>
    23ce:	bf00      	nop
    23d0:	00003139 	.word	0x00003139
    23d4:	00001ecd 	.word	0x00001ecd
    23d8:	0000329d 	.word	0x0000329d

000023dc <tcp_send_fin>:
{
    23dc:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	if (pcb->unsent != NULL) {
    23e0:	6ec4      	ldr	r4, [r0, #108]	; 0x6c
{
    23e2:	4605      	mov	r5, r0
	if (pcb->unsent != NULL) {
    23e4:	b14c      	cbz	r4, 23fa <tcp_send_fin+0x1e>
		for (last_unsent = pcb->unsent; last_unsent->next != NULL; last_unsent = last_unsent->next)
    23e6:	4627      	mov	r7, r4
    23e8:	6824      	ldr	r4, [r4, #0]
    23ea:	2c00      	cmp	r4, #0
    23ec:	d1fb      	bne.n	23e6 <tcp_send_fin+0xa>
		if ((TCPH_FLAGS(last_unsent->tcphdr) & (TCP_SYN | TCP_FIN | TCP_RST)) == 0) {
    23ee:	68fb      	ldr	r3, [r7, #12]
    23f0:	8998      	ldrh	r0, [r3, #12]
    23f2:	4b0c      	ldr	r3, [pc, #48]	; (2424 <tcp_send_fin+0x48>)
    23f4:	4798      	blx	r3
    23f6:	0743      	lsls	r3, r0, #29
    23f8:	d005      	beq.n	2406 <tcp_send_fin+0x2a>
	return tcp_enqueue_flags(pcb, TCP_FIN);
    23fa:	4628      	mov	r0, r5
    23fc:	4b0a      	ldr	r3, [pc, #40]	; (2428 <tcp_send_fin+0x4c>)
}
    23fe:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
	return tcp_enqueue_flags(pcb, TCP_FIN);
    2402:	2101      	movs	r1, #1
    2404:	4718      	bx	r3
			TCPH_SET_FLAG(last_unsent->tcphdr, TCP_FIN);
    2406:	68fb      	ldr	r3, [r7, #12]
    2408:	2001      	movs	r0, #1
    240a:	899e      	ldrh	r6, [r3, #12]
    240c:	4b07      	ldr	r3, [pc, #28]	; (242c <tcp_send_fin+0x50>)
    240e:	4798      	blx	r3
    2410:	68fb      	ldr	r3, [r7, #12]
    2412:	4330      	orrs	r0, r6
    2414:	8198      	strh	r0, [r3, #12]
			pcb->flags |= TF_FIN;
    2416:	7fab      	ldrb	r3, [r5, #30]
    2418:	f043 0320 	orr.w	r3, r3, #32
    241c:	77ab      	strb	r3, [r5, #30]
}
    241e:	4620      	mov	r0, r4
    2420:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    2424:	00000d67 	.word	0x00000d67
    2428:	00002339 	.word	0x00002339
    242c:	00000d61 	.word	0x00000d61

00002430 <tcp_send_empty_ack>:
/** Send an ACK without data.
 *
 * @param pcb Protocol control block for the TCP connection to send the ACK
 */
err_t tcp_send_empty_ack(struct tcp_pcb *pcb)
{
    2430:	b5f0      	push	{r4, r5, r6, r7, lr}
	if (pcb->flags & TF_TIMESTAMP) {
		optlen = LWIP_TCP_OPT_LENGTH(TF_SEG_OPTS_TS);
	}
#endif

	p = tcp_output_alloc_header(pcb, optlen, 0, htonl(pcb->snd_nxt));
    2432:	4b16      	ldr	r3, [pc, #88]	; (248c <tcp_send_empty_ack+0x5c>)
{
    2434:	b085      	sub	sp, #20
    2436:	4604      	mov	r4, r0
	p = tcp_output_alloc_header(pcb, optlen, 0, htonl(pcb->snd_nxt));
    2438:	6d00      	ldr	r0, [r0, #80]	; 0x50
    243a:	4798      	blx	r3
    243c:	4b14      	ldr	r3, [pc, #80]	; (2490 <tcp_send_empty_ack+0x60>)
    243e:	4602      	mov	r2, r0
    2440:	2100      	movs	r1, #0
    2442:	4620      	mov	r0, r4
    2444:	4798      	blx	r3
	if (p == NULL) {
    2446:	4605      	mov	r5, r0
    2448:	b1e8      	cbz	r0, 2486 <tcp_send_empty_ack+0x56>
		return ERR_BUF;
	}
	tcphdr = (struct tcp_hdr *)p->payload;
	LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_output: sending ACK for %" U32_F "\n", pcb->rcv_nxt));
	/* remove ACK flags from the PCB, as we send an empty ACK now */
	pcb->flags &= ~(TF_ACK_DELAY | TF_ACK_NOW);
    244a:	7fa3      	ldrb	r3, [r4, #30]
	tcphdr = (struct tcp_hdr *)p->payload;
    244c:	6846      	ldr	r6, [r0, #4]
		tcp_build_timestamp_option(pcb, (u32_t *)(tcphdr + 1));
	}
#endif

#if CHECKSUM_GEN_TCP
	tcphdr->chksum = inet_chksum_pseudo(p, &(pcb->local_ip), &(pcb->remote_ip), IP_PROTO_TCP, p->tot_len);
    244e:	4f11      	ldr	r7, [pc, #68]	; (2494 <tcp_send_empty_ack+0x64>)
	pcb->flags &= ~(TF_ACK_DELAY | TF_ACK_NOW);
    2450:	f023 0303 	bic.w	r3, r3, #3
    2454:	77a3      	strb	r3, [r4, #30]
	tcphdr->chksum = inet_chksum_pseudo(p, &(pcb->local_ip), &(pcb->remote_ip), IP_PROTO_TCP, p->tot_len);
    2456:	8903      	ldrh	r3, [r0, #8]
    2458:	9300      	str	r3, [sp, #0]
    245a:	1d22      	adds	r2, r4, #4
    245c:	4621      	mov	r1, r4
    245e:	2306      	movs	r3, #6
    2460:	9203      	str	r2, [sp, #12]
    2462:	47b8      	blx	r7
#endif
#if LWIP_NETIF_HWADDRHINT
	ip_output_hinted(p, &(pcb->local_ip), &(pcb->remote_ip), pcb->ttl, pcb->tos, IP_PROTO_TCP, &(pcb->addr_hint));
#else  /* LWIP_NETIF_HWADDRHINT*/
	ip_output(p, &(pcb->local_ip), &(pcb->remote_ip), pcb->ttl, pcb->tos, IP_PROTO_TCP);
    2464:	2306      	movs	r3, #6
	tcphdr->chksum = inet_chksum_pseudo(p, &(pcb->local_ip), &(pcb->remote_ip), IP_PROTO_TCP, p->tot_len);
    2466:	8230      	strh	r0, [r6, #16]
	ip_output(p, &(pcb->local_ip), &(pcb->remote_ip), pcb->ttl, pcb->tos, IP_PROTO_TCP);
    2468:	9301      	str	r3, [sp, #4]
    246a:	7a63      	ldrb	r3, [r4, #9]
    246c:	9300      	str	r3, [sp, #0]
    246e:	7aa3      	ldrb	r3, [r4, #10]
    2470:	9a03      	ldr	r2, [sp, #12]
    2472:	4621      	mov	r1, r4
    2474:	4628      	mov	r0, r5
    2476:	4c08      	ldr	r4, [pc, #32]	; (2498 <tcp_send_empty_ack+0x68>)
    2478:	47a0      	blx	r4
#endif /* LWIP_NETIF_HWADDRHINT*/
	pbuf_free(p);
    247a:	4b08      	ldr	r3, [pc, #32]	; (249c <tcp_send_empty_ack+0x6c>)
    247c:	4628      	mov	r0, r5
    247e:	4798      	blx	r3

	return ERR_OK;
    2480:	2000      	movs	r0, #0
}
    2482:	b005      	add	sp, #20
    2484:	bdf0      	pop	{r4, r5, r6, r7, pc}
		return ERR_BUF;
    2486:	f06f 0001 	mvn.w	r0, #1
    248a:	e7fa      	b.n	2482 <tcp_send_empty_ack+0x52>
    248c:	00000d6d 	.word	0x00000d6d
    2490:	00001f91 	.word	0x00001f91
    2494:	00008389 	.word	0x00008389
    2498:	000065fd 	.word	0x000065fd
    249c:	000030e1 	.word	0x000030e1

000024a0 <tcp_output>:
 * @param pcb Protocol control block for the TCP connection to send data
 * @return ERR_OK if data has been sent or nothing to send
 *         another err_t on error
 */
err_t tcp_output(struct tcp_pcb *pcb)
{
    24a0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}

	/* First, check if we are invoked by the TCP input processing
	   code. If so, we do not output anything. Instead, we rely on the
	   input processing code to call us when input processing is done
	   with. */
	if (tcp_input_pcb == pcb) {
    24a4:	4b93      	ldr	r3, [pc, #588]	; (26f4 <tcp_output+0x254>)
    24a6:	681b      	ldr	r3, [r3, #0]
    24a8:	4283      	cmp	r3, r0
{
    24aa:	b085      	sub	sp, #20
    24ac:	4604      	mov	r4, r0
	if (tcp_input_pcb == pcb) {
    24ae:	d048      	beq.n	2542 <tcp_output+0xa2>
		return ERR_OK;
	}

	wnd = LWIP_MIN(pcb->snd_wnd, pcb->cwnd);
    24b0:	f8b0 3060 	ldrh.w	r3, [r0, #96]	; 0x60
    24b4:	f8b0 804c 	ldrh.w	r8, [r0, #76]	; 0x4c

	seg = pcb->unsent;
    24b8:	6ec5      	ldr	r5, [r0, #108]	; 0x6c
	wnd = LWIP_MIN(pcb->snd_wnd, pcb->cwnd);
    24ba:	4598      	cmp	r8, r3
    24bc:	bf28      	it	cs
    24be:	4698      	movcs	r8, r3
	 * because the ->unsent queue is empty or because the window does
	 * not allow it), construct an empty ACK segment and send it.
	 *
	 * If data is to be sent, we will just piggyback the ACK (see below).
	 */
	if (pcb->flags & TF_ACK_NOW && (seg == NULL || ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len > wnd)) {
    24c0:	7f83      	ldrb	r3, [r0, #30]
    24c2:	079a      	lsls	r2, r3, #30
    24c4:	d510      	bpl.n	24e8 <tcp_output+0x48>
    24c6:	b92d      	cbnz	r5, 24d4 <tcp_output+0x34>
		return tcp_send_empty_ack(pcb);
    24c8:	4b8b      	ldr	r3, [pc, #556]	; (26f8 <tcp_output+0x258>)
    24ca:	4620      	mov	r0, r4
	}
#endif /* TCP_OVERSIZE */

	pcb->flags &= ~TF_NAGLEMEMERR;
	return ERR_OK;
}
    24cc:	b005      	add	sp, #20
    24ce:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
		return tcp_send_empty_ack(pcb);
    24d2:	4718      	bx	r3
	if (pcb->flags & TF_ACK_NOW && (seg == NULL || ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len > wnd)) {
    24d4:	68eb      	ldr	r3, [r5, #12]
    24d6:	6858      	ldr	r0, [r3, #4]
    24d8:	4b88      	ldr	r3, [pc, #544]	; (26fc <tcp_output+0x25c>)
    24da:	4798      	blx	r3
    24dc:	892b      	ldrh	r3, [r5, #8]
    24de:	6ca2      	ldr	r2, [r4, #72]	; 0x48
    24e0:	1a9b      	subs	r3, r3, r2
    24e2:	4418      	add	r0, r3
    24e4:	4540      	cmp	r0, r8
    24e6:	d8ef      	bhi.n	24c8 <tcp_output+0x28>
	useg = pcb->unacked;
    24e8:	6f27      	ldr	r7, [r4, #112]	; 0x70
	if (useg != NULL) {
    24ea:	bb7f      	cbnz	r7, 254c <tcp_output+0xac>
	while (seg != NULL && ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len <= wnd) {
    24ec:	4e83      	ldr	r6, [pc, #524]	; (26fc <tcp_output+0x25c>)
    24ee:	b305      	cbz	r5, 2532 <tcp_output+0x92>
    24f0:	68eb      	ldr	r3, [r5, #12]
    24f2:	6858      	ldr	r0, [r3, #4]
    24f4:	47b0      	blx	r6
    24f6:	892b      	ldrh	r3, [r5, #8]
    24f8:	6ca2      	ldr	r2, [r4, #72]	; 0x48
    24fa:	1a9b      	subs	r3, r3, r2
    24fc:	4418      	add	r0, r3
    24fe:	4540      	cmp	r0, r8
    2500:	d817      	bhi.n	2532 <tcp_output+0x92>
		if ((tcp_do_output_nagle(pcb) == 0) && ((pcb->flags & (TF_NAGLEMEMERR | TF_FIN)) == 0)) {
    2502:	6f23      	ldr	r3, [r4, #112]	; 0x70
    2504:	b333      	cbz	r3, 2554 <tcp_output+0xb4>
    2506:	7fa2      	ldrb	r2, [r4, #30]
    2508:	f012 0f44 	tst.w	r2, #68	; 0x44
    250c:	d122      	bne.n	2554 <tcp_output+0xb4>
    250e:	6ee3      	ldr	r3, [r4, #108]	; 0x6c
    2510:	b12b      	cbz	r3, 251e <tcp_output+0x7e>
    2512:	6819      	ldr	r1, [r3, #0]
    2514:	b9f1      	cbnz	r1, 2554 <tcp_output+0xb4>
    2516:	8919      	ldrh	r1, [r3, #8]
    2518:	8ee3      	ldrh	r3, [r4, #54]	; 0x36
    251a:	4299      	cmp	r1, r3
    251c:	d21a      	bcs.n	2554 <tcp_output+0xb4>
    251e:	f8b4 3066 	ldrh.w	r3, [r4, #102]	; 0x66
    2522:	b1bb      	cbz	r3, 2554 <tcp_output+0xb4>
    2524:	f8b4 3068 	ldrh.w	r3, [r4, #104]	; 0x68
    2528:	2b07      	cmp	r3, #7
    252a:	d813      	bhi.n	2554 <tcp_output+0xb4>
    252c:	f012 0fa0 	tst.w	r2, #160	; 0xa0
    2530:	d110      	bne.n	2554 <tcp_output+0xb4>
	if (pcb->unsent == NULL) {
    2532:	6ee3      	ldr	r3, [r4, #108]	; 0x6c
    2534:	b90b      	cbnz	r3, 253a <tcp_output+0x9a>
		pcb->unsent_oversize = 0;
    2536:	f8a4 306a 	strh.w	r3, [r4, #106]	; 0x6a
	pcb->flags &= ~TF_NAGLEMEMERR;
    253a:	7fa3      	ldrb	r3, [r4, #30]
    253c:	f003 037f 	and.w	r3, r3, #127	; 0x7f
    2540:	77a3      	strb	r3, [r4, #30]
}
    2542:	2000      	movs	r0, #0
    2544:	b005      	add	sp, #20
    2546:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    254a:	461f      	mov	r7, r3
		for (; useg->next != NULL; useg = useg->next)
    254c:	683b      	ldr	r3, [r7, #0]
    254e:	2b00      	cmp	r3, #0
    2550:	d1fb      	bne.n	254a <tcp_output+0xaa>
    2552:	e7cb      	b.n	24ec <tcp_output+0x4c>
		pcb->unsent = seg->next;
    2554:	682b      	ldr	r3, [r5, #0]
    2556:	66e3      	str	r3, [r4, #108]	; 0x6c
		if (pcb->state != SYN_SENT) {
    2558:	7e23      	ldrb	r3, [r4, #24]
    255a:	2b02      	cmp	r3, #2
    255c:	d00d      	beq.n	257a <tcp_output+0xda>
			TCPH_SET_FLAG(seg->tcphdr, TCP_ACK);
    255e:	68eb      	ldr	r3, [r5, #12]
    2560:	2010      	movs	r0, #16
    2562:	f8b3 a00c 	ldrh.w	sl, [r3, #12]
    2566:	4b66      	ldr	r3, [pc, #408]	; (2700 <tcp_output+0x260>)
    2568:	4798      	blx	r3
    256a:	68eb      	ldr	r3, [r5, #12]
    256c:	ea4a 0000 	orr.w	r0, sl, r0
    2570:	8198      	strh	r0, [r3, #12]
			pcb->flags &= ~(TF_ACK_DELAY | TF_ACK_NOW);
    2572:	7fa3      	ldrb	r3, [r4, #30]
    2574:	f023 0303 	bic.w	r3, r3, #3
    2578:	77a3      	strb	r3, [r4, #30]
	/** @bug Exclude retransmitted segments from this count. */
	snmp_inc_tcpoutsegs();

	/* The TCP header has already been constructed, but the ackno and
	 wnd fields remain. */
	seg->tcphdr->ackno = htonl(pcb->rcv_nxt);
    257a:	6aa0      	ldr	r0, [r4, #40]	; 0x28
    257c:	f8df a194 	ldr.w	sl, [pc, #404]	; 2714 <tcp_output+0x274>
    2580:	f8d5 b00c 	ldr.w	fp, [r5, #12]
    2584:	47d0      	blx	sl

	/* advertise our receive window size in this TCP segment */
	seg->tcphdr->wnd = htons(pcb->rcv_ann_wnd);
    2586:	4b5e      	ldr	r3, [pc, #376]	; (2700 <tcp_output+0x260>)
	seg->tcphdr->ackno = htonl(pcb->rcv_nxt);
    2588:	f8cb 0008 	str.w	r0, [fp, #8]
	seg->tcphdr->wnd = htons(pcb->rcv_ann_wnd);
    258c:	8de0      	ldrh	r0, [r4, #46]	; 0x2e
    258e:	f8d5 b00c 	ldr.w	fp, [r5, #12]
    2592:	4798      	blx	r3

	pcb->rcv_ann_right_edge = pcb->rcv_nxt + pcb->rcv_ann_wnd;
    2594:	8de2      	ldrh	r2, [r4, #46]	; 0x2e
    2596:	6aa3      	ldr	r3, [r4, #40]	; 0x28
	seg->tcphdr->wnd = htons(pcb->rcv_ann_wnd);
    2598:	f8ab 000e 	strh.w	r0, [fp, #14]
	pcb->rcv_ann_right_edge = pcb->rcv_nxt + pcb->rcv_ann_wnd;
    259c:	4413      	add	r3, r2
    259e:	6323      	str	r3, [r4, #48]	; 0x30

	/* Add any requested options.  NB MSS option is only set on SYN
	   packets, so ignore it here */
	opts = (u32_t *)(void *)(seg->tcphdr + 1);
	if (seg->flags & TF_SEG_OPTS_MSS) {
    25a0:	7aab      	ldrb	r3, [r5, #10]
    25a2:	07db      	lsls	r3, r3, #31
		u16_t mss;
#if TCP_CALCULATE_EFF_SEND_MSS
		mss = tcp_eff_send_mss(TCP_MSS, &pcb->remote_ip);
    25a4:	f104 0904 	add.w	r9, r4, #4
	if (seg->flags & TF_SEG_OPTS_MSS) {
    25a8:	d50b      	bpl.n	25c2 <tcp_output+0x122>
		mss = tcp_eff_send_mss(TCP_MSS, &pcb->remote_ip);
    25aa:	4b56      	ldr	r3, [pc, #344]	; (2704 <tcp_output+0x264>)
	opts = (u32_t *)(void *)(seg->tcphdr + 1);
    25ac:	f8d5 b00c 	ldr.w	fp, [r5, #12]
		mss = tcp_eff_send_mss(TCP_MSS, &pcb->remote_ip);
    25b0:	4649      	mov	r1, r9
    25b2:	f240 50b4 	movw	r0, #1460	; 0x5b4
    25b6:	4798      	blx	r3
#else  /* TCP_CALCULATE_EFF_SEND_MSS */
		mss = TCP_MSS;
#endif /* TCP_CALCULATE_EFF_SEND_MSS */
		*opts = TCP_BUILD_MSS_OPTION(mss);
    25b8:	f040 7001 	orr.w	r0, r0, #33816576	; 0x2040000
    25bc:	47d0      	blx	sl
    25be:	f8cb 0014 	str.w	r0, [fp, #20]
	}
#endif

	/* Set retransmission timer running if it is not currently enabled
	   This must be set before checking the route. */
	if (pcb->rtime == -1) {
    25c2:	f9b4 3034 	ldrsh.w	r3, [r4, #52]	; 0x34
    25c6:	3301      	adds	r3, #1
		pcb->rtime = 0;
    25c8:	bf04      	itt	eq
    25ca:	2300      	moveq	r3, #0
    25cc:	86a3      	strheq	r3, [r4, #52]	; 0x34
	}

	/* If we don't have a local IP address, we get one by
	   calling ip_route(). */
	if (ip_addr_isany(&(pcb->local_ip))) {
    25ce:	6823      	ldr	r3, [r4, #0]
    25d0:	b933      	cbnz	r3, 25e0 <tcp_output+0x140>
		netif = ip_route(&(pcb->remote_ip));
    25d2:	4b4d      	ldr	r3, [pc, #308]	; (2708 <tcp_output+0x268>)
    25d4:	4648      	mov	r0, r9
    25d6:	4798      	blx	r3
		if (netif == NULL) {
    25d8:	2800      	cmp	r0, #0
    25da:	d033      	beq.n	2644 <tcp_output+0x1a4>
			return;
		}
		ip_addr_copy(pcb->local_ip, netif->ip_addr);
    25dc:	6843      	ldr	r3, [r0, #4]
    25de:	6023      	str	r3, [r4, #0]
	}

	if (pcb->rttest == 0) {
    25e0:	6ba3      	ldr	r3, [r4, #56]	; 0x38
    25e2:	b933      	cbnz	r3, 25f2 <tcp_output+0x152>
		pcb->rttest = tcp_ticks;
    25e4:	4949      	ldr	r1, [pc, #292]	; (270c <tcp_output+0x26c>)
		pcb->rtseq  = ntohl(seg->tcphdr->seqno);
    25e6:	68eb      	ldr	r3, [r5, #12]
		pcb->rttest = tcp_ticks;
    25e8:	6809      	ldr	r1, [r1, #0]
    25ea:	63a1      	str	r1, [r4, #56]	; 0x38
		pcb->rtseq  = ntohl(seg->tcphdr->seqno);
    25ec:	6858      	ldr	r0, [r3, #4]
    25ee:	47b0      	blx	r6
    25f0:	63e0      	str	r0, [r4, #60]	; 0x3c
	LWIP_DEBUGF(TCP_OUTPUT_DEBUG,
	            ("tcp_output_segment: %" U32_F ":%" U32_F "\n",
	             htonl(seg->tcphdr->seqno),
	             htonl(seg->tcphdr->seqno) + seg->len));

	len = (u16_t)((u8_t *)seg->tcphdr - (u8_t *)seg->p->payload);
    25f2:	6868      	ldr	r0, [r5, #4]
    25f4:	f8d5 a00c 	ldr.w	sl, [r5, #12]
    25f8:	6843      	ldr	r3, [r0, #4]
		}
#endif /* TCP_CHECKSUM_ON_COPY_SANITY_CHECK */
	}
#else  /* TCP_CHECKSUM_ON_COPY */
	seg->tcphdr->chksum
	    = inet_chksum_pseudo(seg->p, &(pcb->local_ip), &(pcb->remote_ip), IP_PROTO_TCP, seg->p->tot_len);
    25fa:	f8df b11c 	ldr.w	fp, [pc, #284]	; 2718 <tcp_output+0x278>
	seg->p->payload = seg->tcphdr;
    25fe:	f8c0 a004 	str.w	sl, [r0, #4]
	len = (u16_t)((u8_t *)seg->tcphdr - (u8_t *)seg->p->payload);
    2602:	ebaa 0303 	sub.w	r3, sl, r3
    2606:	b299      	uxth	r1, r3
	seg->p->len -= len;
    2608:	8943      	ldrh	r3, [r0, #10]
    260a:	1a5b      	subs	r3, r3, r1
    260c:	8143      	strh	r3, [r0, #10]
	seg->p->tot_len -= len;
    260e:	8903      	ldrh	r3, [r0, #8]
    2610:	1a5b      	subs	r3, r3, r1
    2612:	b29b      	uxth	r3, r3
	seg->tcphdr->chksum = 0;
    2614:	2100      	movs	r1, #0
	seg->p->tot_len -= len;
    2616:	8103      	strh	r3, [r0, #8]
	    = inet_chksum_pseudo(seg->p, &(pcb->local_ip), &(pcb->remote_ip), IP_PROTO_TCP, seg->p->tot_len);
    2618:	464a      	mov	r2, r9
	seg->tcphdr->chksum = 0;
    261a:	f88a 1010 	strb.w	r1, [sl, #16]
    261e:	f88a 1011 	strb.w	r1, [sl, #17]
	    = inet_chksum_pseudo(seg->p, &(pcb->local_ip), &(pcb->remote_ip), IP_PROTO_TCP, seg->p->tot_len);
    2622:	9300      	str	r3, [sp, #0]
    2624:	4621      	mov	r1, r4
    2626:	2306      	movs	r3, #6
    2628:	47d8      	blx	fp
	TCP_STATS_INC(tcp.xmit);

#if LWIP_NETIF_HWADDRHINT
	ip_output_hinted(seg->p, &(pcb->local_ip), &(pcb->remote_ip), pcb->ttl, pcb->tos, IP_PROTO_TCP, &(pcb->addr_hint));
#else  /* LWIP_NETIF_HWADDRHINT*/
	ip_output(seg->p, &(pcb->local_ip), &(pcb->remote_ip), pcb->ttl, pcb->tos, IP_PROTO_TCP);
    262a:	2306      	movs	r3, #6
	    = inet_chksum_pseudo(seg->p, &(pcb->local_ip), &(pcb->remote_ip), IP_PROTO_TCP, seg->p->tot_len);
    262c:	f8aa 0010 	strh.w	r0, [sl, #16]
	ip_output(seg->p, &(pcb->local_ip), &(pcb->remote_ip), pcb->ttl, pcb->tos, IP_PROTO_TCP);
    2630:	9301      	str	r3, [sp, #4]
    2632:	7a63      	ldrb	r3, [r4, #9]
    2634:	9300      	str	r3, [sp, #0]
    2636:	6868      	ldr	r0, [r5, #4]
    2638:	7aa3      	ldrb	r3, [r4, #10]
    263a:	f8df a0e0 	ldr.w	sl, [pc, #224]	; 271c <tcp_output+0x27c>
    263e:	464a      	mov	r2, r9
    2640:	4621      	mov	r1, r4
    2642:	47d0      	blx	sl
		snd_nxt = ntohl(seg->tcphdr->seqno) + TCP_TCPLEN(seg);
    2644:	68eb      	ldr	r3, [r5, #12]
    2646:	f8df a0d8 	ldr.w	sl, [pc, #216]	; 2720 <tcp_output+0x280>
    264a:	6858      	ldr	r0, [r3, #4]
    264c:	47b0      	blx	r6
    264e:	892a      	ldrh	r2, [r5, #8]
    2650:	68eb      	ldr	r3, [r5, #12]
    2652:	9203      	str	r2, [sp, #12]
    2654:	4683      	mov	fp, r0
    2656:	8998      	ldrh	r0, [r3, #12]
    2658:	47d0      	blx	sl
    265a:	9a03      	ldr	r2, [sp, #12]
    265c:	f010 0303 	ands.w	r3, r0, #3
    2660:	bf18      	it	ne
    2662:	2301      	movne	r3, #1
    2664:	441a      	add	r2, r3
    2666:	eb02 030b 	add.w	r3, r2, fp
		if (TCP_SEQ_LT(pcb->snd_nxt, snd_nxt)) {
    266a:	6d22      	ldr	r2, [r4, #80]	; 0x50
    266c:	1ad2      	subs	r2, r2, r3
    266e:	2a00      	cmp	r2, #0
			pcb->snd_nxt = snd_nxt;
    2670:	bfb8      	it	lt
    2672:	6523      	strlt	r3, [r4, #80]	; 0x50
		if (TCP_TCPLEN(seg) > 0) {
    2674:	68eb      	ldr	r3, [r5, #12]
    2676:	4652      	mov	r2, sl
    2678:	8998      	ldrh	r0, [r3, #12]
    267a:	f8b5 a008 	ldrh.w	sl, [r5, #8]
    267e:	4790      	blx	r2
    2680:	f010 0003 	ands.w	r0, r0, #3
    2684:	bf18      	it	ne
    2686:	2001      	movne	r0, #1
    2688:	eb10 0f0a 	cmn.w	r0, sl
    268c:	d02d      	beq.n	26ea <tcp_output+0x24a>
			seg->next = NULL;
    268e:	2300      	movs	r3, #0
    2690:	602b      	str	r3, [r5, #0]
			if (pcb->unacked == NULL) {
    2692:	6f23      	ldr	r3, [r4, #112]	; 0x70
    2694:	b913      	cbnz	r3, 269c <tcp_output+0x1fc>
				pcb->unacked = seg;
    2696:	6725      	str	r5, [r4, #112]	; 0x70
					useg->next = seg;
    2698:	462f      	mov	r7, r5
    269a:	e014      	b.n	26c6 <tcp_output+0x226>
				if (TCP_SEQ_LT(ntohl(seg->tcphdr->seqno), ntohl(useg->tcphdr->seqno))) {
    269c:	68eb      	ldr	r3, [r5, #12]
    269e:	6858      	ldr	r0, [r3, #4]
    26a0:	47b0      	blx	r6
    26a2:	68fb      	ldr	r3, [r7, #12]
    26a4:	4682      	mov	sl, r0
    26a6:	6858      	ldr	r0, [r3, #4]
    26a8:	47b0      	blx	r6
    26aa:	ebaa 0000 	sub.w	r0, sl, r0
    26ae:	2800      	cmp	r0, #0
    26b0:	da19      	bge.n	26e6 <tcp_output+0x246>
					struct tcp_seg **cur_seg = &(pcb->unacked);
    26b2:	f104 0a70 	add.w	sl, r4, #112	; 0x70
					while (*cur_seg && TCP_SEQ_LT(ntohl((*cur_seg)->tcphdr->seqno), ntohl(seg->tcphdr->seqno))) {
    26b6:	f8da 3000 	ldr.w	r3, [sl]
    26ba:	b933      	cbnz	r3, 26ca <tcp_output+0x22a>
					seg->next  = (*cur_seg);
    26bc:	f8da 3000 	ldr.w	r3, [sl]
    26c0:	602b      	str	r3, [r5, #0]
					(*cur_seg) = seg;
    26c2:	f8ca 5000 	str.w	r5, [sl]
		seg = pcb->unsent;
    26c6:	6ee5      	ldr	r5, [r4, #108]	; 0x6c
    26c8:	e711      	b.n	24ee <tcp_output+0x4e>
					while (*cur_seg && TCP_SEQ_LT(ntohl((*cur_seg)->tcphdr->seqno), ntohl(seg->tcphdr->seqno))) {
    26ca:	68db      	ldr	r3, [r3, #12]
    26cc:	6858      	ldr	r0, [r3, #4]
    26ce:	47b0      	blx	r6
    26d0:	68eb      	ldr	r3, [r5, #12]
    26d2:	4683      	mov	fp, r0
    26d4:	6858      	ldr	r0, [r3, #4]
    26d6:	47b0      	blx	r6
    26d8:	ebab 0000 	sub.w	r0, fp, r0
    26dc:	2800      	cmp	r0, #0
    26de:	daed      	bge.n	26bc <tcp_output+0x21c>
						cur_seg = &((*cur_seg)->next);
    26e0:	f8da a000 	ldr.w	sl, [sl]
    26e4:	e7e7      	b.n	26b6 <tcp_output+0x216>
					useg->next = seg;
    26e6:	603d      	str	r5, [r7, #0]
    26e8:	e7d6      	b.n	2698 <tcp_output+0x1f8>
			tcp_seg_free(seg);
    26ea:	4b09      	ldr	r3, [pc, #36]	; (2710 <tcp_output+0x270>)
    26ec:	4628      	mov	r0, r5
    26ee:	4798      	blx	r3
    26f0:	e7e9      	b.n	26c6 <tcp_output+0x226>
    26f2:	bf00      	nop
    26f4:	2000a50c 	.word	0x2000a50c
    26f8:	00002431 	.word	0x00002431
    26fc:	00000d71 	.word	0x00000d71
    2700:	00000d61 	.word	0x00000d61
    2704:	000073a1 	.word	0x000073a1
    2708:	0000635d 	.word	0x0000635d
    270c:	20014948 	.word	0x20014948
    2710:	00006ac5 	.word	0x00006ac5
    2714:	00000d6d 	.word	0x00000d6d
    2718:	00008389 	.word	0x00008389
    271c:	000065fd 	.word	0x000065fd
    2720:	00000d67 	.word	0x00000d67

00002724 <tcp_rst>:
 * @param remote_ip the remote IP address to send the segment to
 * @param local_port the local TCP port to send the segment from
 * @param remote_port the remote TCP port to send the segment to
 */
void tcp_rst(u32_t seqno, u32_t ackno, ip_addr_t *local_ip, ip_addr_t *remote_ip, u16_t local_port, u16_t remote_port)
{
    2724:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    2728:	4682      	mov	sl, r0
    272a:	4689      	mov	r9, r1
    272c:	4617      	mov	r7, r2
    272e:	4698      	mov	r8, r3
	struct pbuf *   p;
	struct tcp_hdr *tcphdr;
	p = pbuf_alloc(PBUF_IP, TCP_HLEN, PBUF_RAM);
    2730:	2200      	movs	r2, #0
    2732:	4b22      	ldr	r3, [pc, #136]	; (27bc <tcp_rst+0x98>)
{
    2734:	f8bd 6030 	ldrh.w	r6, [sp, #48]	; 0x30
    2738:	f8bd b034 	ldrh.w	fp, [sp, #52]	; 0x34
	p = pbuf_alloc(PBUF_IP, TCP_HLEN, PBUF_RAM);
    273c:	2114      	movs	r1, #20
    273e:	2001      	movs	r0, #1
    2740:	4798      	blx	r3
	if (p == NULL) {
    2742:	4605      	mov	r5, r0
    2744:	2800      	cmp	r0, #0
    2746:	d036      	beq.n	27b6 <tcp_rst+0x92>
		LWIP_DEBUGF(TCP_DEBUG, ("tcp_rst: could not allocate memory for pbuf\n"));
		return;
	}
	LWIP_ASSERT("check that first pbuf can hold struct tcp_hdr", (p->len >= sizeof(struct tcp_hdr)));

	tcphdr        = (struct tcp_hdr *)p->payload;
    2748:	6844      	ldr	r4, [r0, #4]
	tcphdr->src   = htons(local_port);
    274a:	4630      	mov	r0, r6
    274c:	4e1c      	ldr	r6, [pc, #112]	; (27c0 <tcp_rst+0x9c>)
    274e:	47b0      	blx	r6
    2750:	8020      	strh	r0, [r4, #0]
	tcphdr->dest  = htons(remote_port);
    2752:	4658      	mov	r0, fp
    2754:	47b0      	blx	r6
    2756:	8060      	strh	r0, [r4, #2]
	tcphdr->seqno = htonl(seqno);
    2758:	4650      	mov	r0, sl
    275a:	f8df a070 	ldr.w	sl, [pc, #112]	; 27cc <tcp_rst+0xa8>
    275e:	47d0      	blx	sl
    2760:	6060      	str	r0, [r4, #4]
	tcphdr->ackno = htonl(ackno);
    2762:	4648      	mov	r0, r9
    2764:	47d0      	blx	sl
    2766:	60a0      	str	r0, [r4, #8]
	TCPH_HDRLEN_FLAGS_SET(tcphdr, TCP_HLEN / 4, TCP_RST | TCP_ACK);
    2768:	f245 0014 	movw	r0, #20500	; 0x5014
    276c:	47b0      	blx	r6
	tcphdr->wnd    = PP_HTONS(TCP_WND);
    276e:	2316      	movs	r3, #22
    2770:	73a3      	strb	r3, [r4, #14]
    2772:	f06f 032f 	mvn.w	r3, #47	; 0x2f
    2776:	2600      	movs	r6, #0
    2778:	73e3      	strb	r3, [r4, #15]
	tcphdr->chksum = 0;
	tcphdr->urgp   = 0;

#if CHECKSUM_GEN_TCP
	tcphdr->chksum = inet_chksum_pseudo(p, local_ip, remote_ip, IP_PROTO_TCP, p->tot_len);
    277a:	892b      	ldrh	r3, [r5, #8]
	TCPH_HDRLEN_FLAGS_SET(tcphdr, TCP_HLEN / 4, TCP_RST | TCP_ACK);
    277c:	81a0      	strh	r0, [r4, #12]
	tcphdr->chksum = 0;
    277e:	7426      	strb	r6, [r4, #16]
    2780:	7466      	strb	r6, [r4, #17]
	tcphdr->urgp   = 0;
    2782:	74a6      	strb	r6, [r4, #18]
    2784:	74e6      	strb	r6, [r4, #19]
	tcphdr->chksum = inet_chksum_pseudo(p, local_ip, remote_ip, IP_PROTO_TCP, p->tot_len);
    2786:	4642      	mov	r2, r8
    2788:	9300      	str	r3, [sp, #0]
    278a:	4639      	mov	r1, r7
    278c:	f8df 9040 	ldr.w	r9, [pc, #64]	; 27d0 <tcp_rst+0xac>
    2790:	2306      	movs	r3, #6
    2792:	4628      	mov	r0, r5
    2794:	47c8      	blx	r9
#endif
	TCP_STATS_INC(tcp.xmit);
	snmp_inc_tcpoutrsts();
	/* Send output with hardcoded TTL since we have no access to the pcb */
	ip_output(p, local_ip, remote_ip, TCP_TTL, 0, IP_PROTO_TCP);
    2796:	2306      	movs	r3, #6
	tcphdr->chksum = inet_chksum_pseudo(p, local_ip, remote_ip, IP_PROTO_TCP, p->tot_len);
    2798:	8220      	strh	r0, [r4, #16]
	ip_output(p, local_ip, remote_ip, TCP_TTL, 0, IP_PROTO_TCP);
    279a:	4642      	mov	r2, r8
    279c:	e9cd 6300 	strd	r6, r3, [sp]
    27a0:	4c08      	ldr	r4, [pc, #32]	; (27c4 <tcp_rst+0xa0>)
    27a2:	23ff      	movs	r3, #255	; 0xff
    27a4:	4639      	mov	r1, r7
    27a6:	4628      	mov	r0, r5
    27a8:	47a0      	blx	r4
	pbuf_free(p);
    27aa:	4b07      	ldr	r3, [pc, #28]	; (27c8 <tcp_rst+0xa4>)
    27ac:	4628      	mov	r0, r5
	LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_rst: seqno %" U32_F " ackno %" U32_F ".\n", seqno, ackno));
}
    27ae:	b003      	add	sp, #12
    27b0:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	pbuf_free(p);
    27b4:	4718      	bx	r3
}
    27b6:	b003      	add	sp, #12
    27b8:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    27bc:	00003139 	.word	0x00003139
    27c0:	00000d61 	.word	0x00000d61
    27c4:	000065fd 	.word	0x000065fd
    27c8:	000030e1 	.word	0x000030e1
    27cc:	00000d6d 	.word	0x00000d6d
    27d0:	00008389 	.word	0x00008389

000027d4 <tcp_rexmit_rto>:
 */
void tcp_rexmit_rto(struct tcp_pcb *pcb)
{
	struct tcp_seg *seg;

	if (pcb->unacked == NULL) {
    27d4:	6f02      	ldr	r2, [r0, #112]	; 0x70
{
    27d6:	b410      	push	{r4}
	if (pcb->unacked == NULL) {
    27d8:	b192      	cbz	r2, 2800 <tcp_rexmit_rto+0x2c>
    27da:	4613      	mov	r3, r2
		return;
	}

	/* Move all unacked segments to the head of the unsent queue */
	for (seg = pcb->unacked; seg->next != NULL; seg = seg->next)
    27dc:	4619      	mov	r1, r3
    27de:	681b      	ldr	r3, [r3, #0]
    27e0:	2b00      	cmp	r3, #0
    27e2:	d1fb      	bne.n	27dc <tcp_rexmit_rto+0x8>
		;
	/* concatenate unsent queue after unacked queue */
	seg->next = pcb->unsent;
    27e4:	6ec4      	ldr	r4, [r0, #108]	; 0x6c
    27e6:	600c      	str	r4, [r1, #0]
	/* unsent queue is the concatenated queue (of unacked, unsent) */
	pcb->unsent = pcb->unacked;
	/* unacked queue is now empty */
	pcb->unacked = NULL;
    27e8:	e9c0 231b 	strd	r2, r3, [r0, #108]	; 0x6c
	/* last unsent hasn't changed, no need to reset unsent_oversize */

	/* increment number of retransmissions */
	++pcb->nrtx;
    27ec:	f890 2046 	ldrb.w	r2, [r0, #70]	; 0x46

	/* Don't take any RTT measurements after retransmitting. */
	pcb->rttest = 0;
    27f0:	6383      	str	r3, [r0, #56]	; 0x38
	++pcb->nrtx;
    27f2:	3201      	adds	r2, #1
    27f4:	f880 2046 	strb.w	r2, [r0, #70]	; 0x46

	/* Do the actual retransmission */
	tcp_output(pcb);
    27f8:	4b03      	ldr	r3, [pc, #12]	; (2808 <tcp_rexmit_rto+0x34>)
}
    27fa:	f85d 4b04 	ldr.w	r4, [sp], #4
	tcp_output(pcb);
    27fe:	4718      	bx	r3
}
    2800:	f85d 4b04 	ldr.w	r4, [sp], #4
    2804:	4770      	bx	lr
    2806:	bf00      	nop
    2808:	000024a1 	.word	0x000024a1

0000280c <tcp_rexmit>:
 * Called by tcp_receive() for fast retramsmit.
 *
 * @param pcb the tcp_pcb for which to retransmit the first unacked segment
 */
void tcp_rexmit(struct tcp_pcb *pcb)
{
    280c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	struct tcp_seg * seg;
	struct tcp_seg **cur_seg;

	if (pcb->unacked == NULL) {
    2810:	6f05      	ldr	r5, [r0, #112]	; 0x70
{
    2812:	4604      	mov	r4, r0
	if (pcb->unacked == NULL) {
    2814:	b1ad      	cbz	r5, 2842 <tcp_rexmit+0x36>
	}

	/* Move the first unacked segment to the unsent queue */
	/* Keep the unsent queue sorted. */
	seg          = pcb->unacked;
	pcb->unacked = seg->next;
    2816:	682b      	ldr	r3, [r5, #0]

	cur_seg = &(pcb->unsent);
	while (*cur_seg && TCP_SEQ_LT(ntohl((*cur_seg)->tcphdr->seqno), ntohl(seg->tcphdr->seqno))) {
    2818:	f8df 8044 	ldr.w	r8, [pc, #68]	; 2860 <tcp_rexmit+0x54>
	pcb->unacked = seg->next;
    281c:	6703      	str	r3, [r0, #112]	; 0x70
	cur_seg = &(pcb->unsent);
    281e:	f100 066c 	add.w	r6, r0, #108	; 0x6c
	while (*cur_seg && TCP_SEQ_LT(ntohl((*cur_seg)->tcphdr->seqno), ntohl(seg->tcphdr->seqno))) {
    2822:	6833      	ldr	r3, [r6, #0]
    2824:	b97b      	cbnz	r3, 2846 <tcp_rexmit+0x3a>
		cur_seg = &((*cur_seg)->next);
	}
	seg->next = *cur_seg;
    2826:	6833      	ldr	r3, [r6, #0]
    2828:	602b      	str	r3, [r5, #0]
	*cur_seg  = seg;
    282a:	6035      	str	r5, [r6, #0]
#if TCP_OVERSIZE
	if (seg->next == NULL) {
    282c:	682b      	ldr	r3, [r5, #0]
    282e:	b90b      	cbnz	r3, 2834 <tcp_rexmit+0x28>
		/* the retransmitted segment is last in unsent, so reset unsent_oversize */
		pcb->unsent_oversize = 0;
    2830:	f8a4 306a 	strh.w	r3, [r4, #106]	; 0x6a
	}
#endif /* TCP_OVERSIZE */

	++pcb->nrtx;
    2834:	f894 3046 	ldrb.w	r3, [r4, #70]	; 0x46
    2838:	3301      	adds	r3, #1
    283a:	f884 3046 	strb.w	r3, [r4, #70]	; 0x46

	/* Don't take any rtt measurements after retransmitting. */
	pcb->rttest = 0;
    283e:	2300      	movs	r3, #0
    2840:	63a3      	str	r3, [r4, #56]	; 0x38

	/* Do the actual retransmission. */
	snmp_inc_tcpretranssegs();
	/* No need to call tcp_output: we are always called from tcp_input()
	   and thus tcp_output directly returns. */
}
    2842:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	while (*cur_seg && TCP_SEQ_LT(ntohl((*cur_seg)->tcphdr->seqno), ntohl(seg->tcphdr->seqno))) {
    2846:	68db      	ldr	r3, [r3, #12]
    2848:	6858      	ldr	r0, [r3, #4]
    284a:	47c0      	blx	r8
    284c:	68eb      	ldr	r3, [r5, #12]
    284e:	4607      	mov	r7, r0
    2850:	6858      	ldr	r0, [r3, #4]
    2852:	47c0      	blx	r8
    2854:	1a38      	subs	r0, r7, r0
    2856:	2800      	cmp	r0, #0
    2858:	dae5      	bge.n	2826 <tcp_rexmit+0x1a>
		cur_seg = &((*cur_seg)->next);
    285a:	6836      	ldr	r6, [r6, #0]
    285c:	e7e1      	b.n	2822 <tcp_rexmit+0x16>
    285e:	bf00      	nop
    2860:	00000d71 	.word	0x00000d71

00002864 <tcp_rexmit_fast>:
 *
 * @param pcb the tcp_pcb for which to retransmit the first unacked segment
 */
void tcp_rexmit_fast(struct tcp_pcb *pcb)
{
	if (pcb->unacked != NULL && !(pcb->flags & TF_INFR)) {
    2864:	6f03      	ldr	r3, [r0, #112]	; 0x70
{
    2866:	b510      	push	{r4, lr}
    2868:	4604      	mov	r4, r0
	if (pcb->unacked != NULL && !(pcb->flags & TF_INFR)) {
    286a:	b30b      	cbz	r3, 28b0 <tcp_rexmit_fast+0x4c>
    286c:	7f83      	ldrb	r3, [r0, #30]
    286e:	075b      	lsls	r3, r3, #29
    2870:	d41e      	bmi.n	28b0 <tcp_rexmit_fast+0x4c>
		LWIP_DEBUGF(TCP_FR_DEBUG,
		            ("tcp_receive: dupacks %" U16_F " (%" U32_F "), fast retransmit %" U32_F "\n",
		             (u16_t)pcb->dupacks,
		             pcb->lastack,
		             ntohl(pcb->unacked->tcphdr->seqno)));
		tcp_rexmit(pcb);
    2872:	4b10      	ldr	r3, [pc, #64]	; (28b4 <tcp_rexmit_fast+0x50>)
    2874:	4798      	blx	r3

		/* Set ssthresh to half of the minimum of the current
		 * cwnd and the advertised window */
		if (pcb->cwnd > pcb->snd_wnd) {
    2876:	f8b4 204c 	ldrh.w	r2, [r4, #76]	; 0x4c
    287a:	f8b4 3060 	ldrh.w	r3, [r4, #96]	; 0x60
    287e:	429a      	cmp	r2, r3
			pcb->ssthresh = pcb->snd_wnd / 2;
    2880:	bf88      	it	hi
    2882:	085a      	lsrhi	r2, r3, #1
		} else {
			pcb->ssthresh = pcb->cwnd / 2;
		}

		/* The minimum value for ssthresh should be 2 MSS */
		if (pcb->ssthresh < 2 * pcb->mss) {
    2884:	8ee3      	ldrh	r3, [r4, #54]	; 0x36
			pcb->ssthresh = pcb->cwnd / 2;
    2886:	bf98      	it	ls
    2888:	0852      	lsrls	r2, r2, #1
		if (pcb->ssthresh < 2 * pcb->mss) {
    288a:	ebb2 0f43 	cmp.w	r2, r3, lsl #1
    288e:	ea4f 0143 	mov.w	r1, r3, lsl #1
    2892:	f8a4 204e 	strh.w	r2, [r4, #78]	; 0x4e
			LWIP_DEBUGF(TCP_FR_DEBUG,
			            ("tcp_receive: The minimum value for ssthresh %" U16_F " should be min 2 mss %" U16_F "...\n",
			             pcb->ssthresh,
			             2 * pcb->mss));
			pcb->ssthresh = 2 * pcb->mss;
    2896:	bfb8      	it	lt
    2898:	f8a4 104e 	strhlt.w	r1, [r4, #78]	; 0x4e
		}

		pcb->cwnd = pcb->ssthresh + 3 * pcb->mss;
    289c:	f8b4 204e 	ldrh.w	r2, [r4, #78]	; 0x4e
    28a0:	440b      	add	r3, r1
    28a2:	4413      	add	r3, r2
    28a4:	f8a4 304c 	strh.w	r3, [r4, #76]	; 0x4c
		pcb->flags |= TF_INFR;
    28a8:	7fa3      	ldrb	r3, [r4, #30]
    28aa:	f043 0304 	orr.w	r3, r3, #4
    28ae:	77a3      	strb	r3, [r4, #30]
	}
}
    28b0:	bd10      	pop	{r4, pc}
    28b2:	bf00      	nop
    28b4:	0000280d 	.word	0x0000280d

000028b8 <tcp_keepalive>:
 * Called by tcp_slowtmr()
 *
 * @param pcb the tcp_pcb for which to send a keepalive packet
 */
void tcp_keepalive(struct tcp_pcb *pcb)
{
    28b8:	b5f0      	push	{r4, r5, r6, r7, lr}
    28ba:	4604      	mov	r4, r0
	            ("tcp_keepalive: tcp_ticks %" U32_F "   pcb->tmr %" U32_F " pcb->keep_cnt_sent %" U16_F "\n",
	             tcp_ticks,
	             pcb->tmr,
	             pcb->keep_cnt_sent));

	p = tcp_output_alloc_header(pcb, 0, 0, htonl(pcb->snd_nxt - 1));
    28bc:	6d00      	ldr	r0, [r0, #80]	; 0x50
    28be:	4b13      	ldr	r3, [pc, #76]	; (290c <tcp_keepalive+0x54>)
{
    28c0:	b085      	sub	sp, #20
	p = tcp_output_alloc_header(pcb, 0, 0, htonl(pcb->snd_nxt - 1));
    28c2:	3801      	subs	r0, #1
    28c4:	4798      	blx	r3
    28c6:	4b12      	ldr	r3, [pc, #72]	; (2910 <tcp_keepalive+0x58>)
    28c8:	4602      	mov	r2, r0
    28ca:	2100      	movs	r1, #0
    28cc:	4620      	mov	r0, r4
    28ce:	4798      	blx	r3
	if (p == NULL) {
    28d0:	4605      	mov	r5, r0
    28d2:	b1c8      	cbz	r0, 2908 <tcp_keepalive+0x50>
		return;
	}
	tcphdr = (struct tcp_hdr *)p->payload;

#if CHECKSUM_GEN_TCP
	tcphdr->chksum = inet_chksum_pseudo(p, &pcb->local_ip, &pcb->remote_ip, IP_PROTO_TCP, p->tot_len);
    28d4:	8903      	ldrh	r3, [r0, #8]
	tcphdr = (struct tcp_hdr *)p->payload;
    28d6:	6846      	ldr	r6, [r0, #4]
	tcphdr->chksum = inet_chksum_pseudo(p, &pcb->local_ip, &pcb->remote_ip, IP_PROTO_TCP, p->tot_len);
    28d8:	4f0e      	ldr	r7, [pc, #56]	; (2914 <tcp_keepalive+0x5c>)
    28da:	9300      	str	r3, [sp, #0]
    28dc:	1d22      	adds	r2, r4, #4
    28de:	4621      	mov	r1, r4
    28e0:	2306      	movs	r3, #6
    28e2:	9203      	str	r2, [sp, #12]
    28e4:	47b8      	blx	r7

	/* Send output to IP */
#if LWIP_NETIF_HWADDRHINT
	ip_output_hinted(p, &pcb->local_ip, &pcb->remote_ip, pcb->ttl, 0, IP_PROTO_TCP, &(pcb->addr_hint));
#else  /* LWIP_NETIF_HWADDRHINT*/
	ip_output(p, &pcb->local_ip, &pcb->remote_ip, pcb->ttl, 0, IP_PROTO_TCP);
    28e6:	2300      	movs	r3, #0
    28e8:	2206      	movs	r2, #6
	tcphdr->chksum = inet_chksum_pseudo(p, &pcb->local_ip, &pcb->remote_ip, IP_PROTO_TCP, p->tot_len);
    28ea:	8230      	strh	r0, [r6, #16]
	ip_output(p, &pcb->local_ip, &pcb->remote_ip, pcb->ttl, 0, IP_PROTO_TCP);
    28ec:	e9cd 3200 	strd	r3, r2, [sp]
    28f0:	4621      	mov	r1, r4
    28f2:	7aa3      	ldrb	r3, [r4, #10]
    28f4:	9a03      	ldr	r2, [sp, #12]
    28f6:	4c08      	ldr	r4, [pc, #32]	; (2918 <tcp_keepalive+0x60>)
    28f8:	4628      	mov	r0, r5
    28fa:	47a0      	blx	r4
#endif /* LWIP_NETIF_HWADDRHINT*/

	pbuf_free(p);
    28fc:	4b07      	ldr	r3, [pc, #28]	; (291c <tcp_keepalive+0x64>)
    28fe:	4628      	mov	r0, r5

	LWIP_DEBUGF(TCP_DEBUG, ("tcp_keepalive: seqno %" U32_F " ackno %" U32_F ".\n", pcb->snd_nxt - 1, pcb->rcv_nxt));
}
    2900:	b005      	add	sp, #20
    2902:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
	pbuf_free(p);
    2906:	4718      	bx	r3
}
    2908:	b005      	add	sp, #20
    290a:	bdf0      	pop	{r4, r5, r6, r7, pc}
    290c:	00000d6d 	.word	0x00000d6d
    2910:	00001f91 	.word	0x00001f91
    2914:	00008389 	.word	0x00008389
    2918:	000065fd 	.word	0x000065fd
    291c:	000030e1 	.word	0x000030e1

00002920 <tcp_zero_window_probe>:
 * Called by tcp_slowtmr()
 *
 * @param pcb the tcp_pcb for which to send a zero-window probe packet
 */
void tcp_zero_window_probe(struct tcp_pcb *pcb)
{
    2920:	e92d 41ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, lr}
	            ("tcp_zero_window_probe: tcp_ticks %" U32_F "   pcb->tmr %" U32_F " pcb->keep_cnt_sent %" U16_F "\n",
	             tcp_ticks,
	             pcb->tmr,
	             pcb->keep_cnt_sent));

	seg = pcb->unacked;
    2924:	6f07      	ldr	r7, [r0, #112]	; 0x70
{
    2926:	4605      	mov	r5, r0

	if (seg == NULL) {
    2928:	b917      	cbnz	r7, 2930 <tcp_zero_window_probe+0x10>
		seg = pcb->unsent;
    292a:	6ec7      	ldr	r7, [r0, #108]	; 0x6c
	}
	if (seg == NULL) {
    292c:	2f00      	cmp	r7, #0
    292e:	d048      	beq.n	29c2 <tcp_zero_window_probe+0xa2>
		return;
	}

	is_fin = ((TCPH_FLAGS(seg->tcphdr) & TCP_FIN) != 0) && (seg->len == 0);
    2930:	68fb      	ldr	r3, [r7, #12]
    2932:	8998      	ldrh	r0, [r3, #12]
    2934:	4b24      	ldr	r3, [pc, #144]	; (29c8 <tcp_zero_window_probe+0xa8>)
    2936:	4798      	blx	r3
    2938:	f010 0401 	ands.w	r4, r0, #1
    293c:	bf18      	it	ne
    293e:	893c      	ldrhne	r4, [r7, #8]
	/* we want to send one seqno: either FIN or data (no options) */
	len = is_fin ? 0 : 1;

	p = tcp_output_alloc_header(pcb, 0, len, seg->tcphdr->seqno);
    2940:	68fb      	ldr	r3, [r7, #12]
	is_fin = ((TCPH_FLAGS(seg->tcphdr) & TCP_FIN) != 0) && (seg->len == 0);
    2942:	bf1c      	itt	ne
    2944:	fab4 f484 	clzne	r4, r4
    2948:	0964      	lsrne	r4, r4, #5
	p = tcp_output_alloc_header(pcb, 0, len, seg->tcphdr->seqno);
    294a:	685a      	ldr	r2, [r3, #4]
    294c:	4b1f      	ldr	r3, [pc, #124]	; (29cc <tcp_zero_window_probe+0xac>)
    294e:	f084 0101 	eor.w	r1, r4, #1
    2952:	4628      	mov	r0, r5
    2954:	4798      	blx	r3
	if (p == NULL) {
    2956:	4606      	mov	r6, r0
    2958:	2800      	cmp	r0, #0
    295a:	d032      	beq.n	29c2 <tcp_zero_window_probe+0xa2>
		LWIP_DEBUGF(TCP_DEBUG, ("tcp_zero_window_probe: no memory for pbuf\n"));
		return;
	}
	tcphdr = (struct tcp_hdr *)p->payload;
    295c:	f8d0 8004 	ldr.w	r8, [r0, #4]

	if (is_fin) {
    2960:	b324      	cbz	r4, 29ac <tcp_zero_window_probe+0x8c>
		/* FIN segment, no data */
		TCPH_FLAGS_SET(tcphdr, TCP_ACK | TCP_FIN);
    2962:	4b1b      	ldr	r3, [pc, #108]	; (29d0 <tcp_zero_window_probe+0xb0>)
    2964:	f9b8 400c 	ldrsh.w	r4, [r8, #12]
    2968:	2011      	movs	r0, #17
    296a:	4798      	blx	r3
    296c:	f424 547c 	bic.w	r4, r4, #16128	; 0x3f00
    2970:	4320      	orrs	r0, r4
    2972:	f8a8 000c 	strh.w	r0, [r8, #12]
		   Ensure we copy the first TCP data byte: */
		pbuf_copy_partial(seg->p, d, 1, seg->p->tot_len - seg->len);
	}

#if CHECKSUM_GEN_TCP
	tcphdr->chksum = inet_chksum_pseudo(p, &pcb->local_ip, &pcb->remote_ip, IP_PROTO_TCP, p->tot_len);
    2976:	8933      	ldrh	r3, [r6, #8]
    2978:	9300      	str	r3, [sp, #0]
    297a:	1d2a      	adds	r2, r5, #4
    297c:	4629      	mov	r1, r5
    297e:	4c15      	ldr	r4, [pc, #84]	; (29d4 <tcp_zero_window_probe+0xb4>)
    2980:	9203      	str	r2, [sp, #12]
    2982:	2306      	movs	r3, #6
    2984:	4630      	mov	r0, r6
    2986:	47a0      	blx	r4

	/* Send output to IP */
#if LWIP_NETIF_HWADDRHINT
	ip_output_hinted(p, &pcb->local_ip, &pcb->remote_ip, pcb->ttl, 0, IP_PROTO_TCP, &(pcb->addr_hint));
#else  /* LWIP_NETIF_HWADDRHINT*/
	ip_output(p, &pcb->local_ip, &pcb->remote_ip, pcb->ttl, 0, IP_PROTO_TCP);
    2988:	2300      	movs	r3, #0
	tcphdr->chksum = inet_chksum_pseudo(p, &pcb->local_ip, &pcb->remote_ip, IP_PROTO_TCP, p->tot_len);
    298a:	f8a8 0010 	strh.w	r0, [r8, #16]
	ip_output(p, &pcb->local_ip, &pcb->remote_ip, pcb->ttl, 0, IP_PROTO_TCP);
    298e:	2206      	movs	r2, #6
    2990:	e9cd 3200 	strd	r3, r2, [sp]
    2994:	4c10      	ldr	r4, [pc, #64]	; (29d8 <tcp_zero_window_probe+0xb8>)
    2996:	7aab      	ldrb	r3, [r5, #10]
    2998:	9a03      	ldr	r2, [sp, #12]
    299a:	4629      	mov	r1, r5
    299c:	4630      	mov	r0, r6
    299e:	47a0      	blx	r4
#endif /* LWIP_NETIF_HWADDRHINT*/

	pbuf_free(p);
    29a0:	4b0e      	ldr	r3, [pc, #56]	; (29dc <tcp_zero_window_probe+0xbc>)
    29a2:	4630      	mov	r0, r6

	LWIP_DEBUGF(TCP_DEBUG,
	            ("tcp_zero_window_probe: seqno %" U32_F " ackno %" U32_F ".\n", pcb->snd_nxt - 1, pcb->rcv_nxt));
}
    29a4:	b004      	add	sp, #16
    29a6:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
	pbuf_free(p);
    29aa:	4718      	bx	r3
		pbuf_copy_partial(seg->p, d, 1, seg->p->tot_len - seg->len);
    29ac:	6878      	ldr	r0, [r7, #4]
    29ae:	893a      	ldrh	r2, [r7, #8]
    29b0:	8903      	ldrh	r3, [r0, #8]
    29b2:	4c0b      	ldr	r4, [pc, #44]	; (29e0 <tcp_zero_window_probe+0xc0>)
    29b4:	1a9b      	subs	r3, r3, r2
    29b6:	b29b      	uxth	r3, r3
    29b8:	2201      	movs	r2, #1
    29ba:	f108 0114 	add.w	r1, r8, #20
    29be:	47a0      	blx	r4
    29c0:	e7d9      	b.n	2976 <tcp_zero_window_probe+0x56>
}
    29c2:	b004      	add	sp, #16
    29c4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    29c8:	00000d67 	.word	0x00000d67
    29cc:	00001f91 	.word	0x00001f91
    29d0:	00000d61 	.word	0x00000d61
    29d4:	00008389 	.word	0x00008389
    29d8:	000065fd 	.word	0x000065fd
    29dc:	000030e1 	.word	0x000030e1
    29e0:	00003381 	.word	0x00003381

000029e4 <ip_reass_free_complete_datagram>:
 * @param ipr datagram to free
 * @param prev the previous datagram in the linked list
 * @return the number of pbufs freed
 */
static int ip_reass_free_complete_datagram(struct ip_reassdata *ipr, struct ip_reassdata *prev)
{
    29e4:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
		LWIP_ASSERT("prev->next == ipr", prev->next == ipr);
	}

	snmp_inc_ipreasmfails();
#if LWIP_ICMP
	iprh = (struct ip_reass_helper *)ipr->p->payload;
    29e8:	6846      	ldr	r6, [r0, #4]
    29ea:	6873      	ldr	r3, [r6, #4]
	if (iprh->start == 0) {
    29ec:	889a      	ldrh	r2, [r3, #4]
{
    29ee:	4604      	mov	r4, r0
    29f0:	460f      	mov	r7, r1
	if (iprh->start == 0) {
    29f2:	2a00      	cmp	r2, #0
    29f4:	d12d      	bne.n	2a52 <ip_reass_free_complete_datagram+0x6e>
		/* The first fragment was received, send ICMP time exceeded. */
		/* First, de-queue the first pbuf from r->p. */
		p      = ipr->p;
		ipr->p = iprh->next_pbuf;
    29f6:	681a      	ldr	r2, [r3, #0]
    29f8:	6042      	str	r2, [r0, #4]
		/* Then, copy the original header into it. */
		SMEMCPY(p->payload, &ipr->iphdr, IP_HLEN);
    29fa:	f100 011c 	add.w	r1, r0, #28
    29fe:	f100 0208 	add.w	r2, r0, #8
    2a02:	f852 0b04 	ldr.w	r0, [r2], #4
    2a06:	f843 0b04 	str.w	r0, [r3], #4
    2a0a:	428a      	cmp	r2, r1
    2a0c:	d1f9      	bne.n	2a02 <ip_reass_free_complete_datagram+0x1e>
		icmp_time_exceeded(p, ICMP_TE_FRAG);
    2a0e:	4b17      	ldr	r3, [pc, #92]	; (2a6c <ip_reass_free_complete_datagram+0x88>)
    2a10:	2101      	movs	r1, #1
    2a12:	4630      	mov	r0, r6
    2a14:	4798      	blx	r3
		clen = pbuf_clen(p);
    2a16:	4b16      	ldr	r3, [pc, #88]	; (2a70 <ip_reass_free_complete_datagram+0x8c>)
    2a18:	4630      	mov	r0, r6
    2a1a:	4798      	blx	r3
		LWIP_ASSERT("pbufs_freed + clen <= 0xffff", pbufs_freed + clen <= 0xffff);
		pbufs_freed += clen;
		pbuf_free(p);
    2a1c:	4b15      	ldr	r3, [pc, #84]	; (2a74 <ip_reass_free_complete_datagram+0x90>)
		pbufs_freed += clen;
    2a1e:	b285      	uxth	r5, r0
		pbuf_free(p);
    2a20:	4630      	mov	r0, r6
    2a22:	4798      	blx	r3
	}
#endif /* LWIP_ICMP */

	/* First, free all received pbufs.  The individual pbufs need to be released
	   separately as they have not yet been chained */
	p = ipr->p;
    2a24:	6866      	ldr	r6, [r4, #4]
		struct pbuf *pcur;
		iprh = (struct ip_reass_helper *)p->payload;
		pcur = p;
		/* get the next pointer before freeing */
		p    = iprh->next_pbuf;
		clen = pbuf_clen(pcur);
    2a26:	f8df 8048 	ldr.w	r8, [pc, #72]	; 2a70 <ip_reass_free_complete_datagram+0x8c>
		LWIP_ASSERT("pbufs_freed + clen <= 0xffff", pbufs_freed + clen <= 0xffff);
		pbufs_freed += clen;
		pbuf_free(pcur);
    2a2a:	f8df 9048 	ldr.w	r9, [pc, #72]	; 2a74 <ip_reass_free_complete_datagram+0x90>
	while (p != NULL) {
    2a2e:	b996      	cbnz	r6, 2a56 <ip_reass_free_complete_datagram+0x72>
 */
static void ip_reass_dequeue_datagram(struct ip_reassdata *ipr, struct ip_reassdata *prev)
{

	/* dequeue the reass struct  */
	if (reassdatagrams == ipr) {
    2a30:	4e11      	ldr	r6, [pc, #68]	; (2a78 <ip_reass_free_complete_datagram+0x94>)
		/* it was the first in the list */
		reassdatagrams = ipr->next;
    2a32:	6823      	ldr	r3, [r4, #0]
	if (reassdatagrams == ipr) {
    2a34:	6832      	ldr	r2, [r6, #0]
    2a36:	4294      	cmp	r4, r2
		reassdatagrams = ipr->next;
    2a38:	bf0c      	ite	eq
    2a3a:	6033      	streq	r3, [r6, #0]
	} else {
		/* it wasn't the first, so it must have a valid 'prev' */
		LWIP_ASSERT("sanity check linked list", prev != NULL);
		prev->next = ipr->next;
    2a3c:	603b      	strne	r3, [r7, #0]
	}

	/* now we can free the ip_reass struct */
	memp_free(MEMP_REASSDATA, ipr);
    2a3e:	4621      	mov	r1, r4
    2a40:	4b0e      	ldr	r3, [pc, #56]	; (2a7c <ip_reass_free_complete_datagram+0x98>)
    2a42:	2004      	movs	r0, #4
    2a44:	4798      	blx	r3
	ip_reass_pbufcount -= pbufs_freed;
    2a46:	88b3      	ldrh	r3, [r6, #4]
    2a48:	1b5b      	subs	r3, r3, r5
    2a4a:	80b3      	strh	r3, [r6, #4]
}
    2a4c:	4628      	mov	r0, r5
    2a4e:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
	u16_t                   pbufs_freed = 0;
    2a52:	2500      	movs	r5, #0
    2a54:	e7e6      	b.n	2a24 <ip_reass_free_complete_datagram+0x40>
		iprh = (struct ip_reass_helper *)p->payload;
    2a56:	6873      	ldr	r3, [r6, #4]
		clen = pbuf_clen(pcur);
    2a58:	4630      	mov	r0, r6
		p    = iprh->next_pbuf;
    2a5a:	f8d3 a000 	ldr.w	sl, [r3]
		clen = pbuf_clen(pcur);
    2a5e:	47c0      	blx	r8
		pbufs_freed += clen;
    2a60:	4428      	add	r0, r5
    2a62:	b285      	uxth	r5, r0
		pbuf_free(pcur);
    2a64:	4630      	mov	r0, r6
    2a66:	47c8      	blx	r9
		p    = iprh->next_pbuf;
    2a68:	4656      	mov	r6, sl
    2a6a:	e7e0      	b.n	2a2e <ip_reass_free_complete_datagram+0x4a>
    2a6c:	00000d55 	.word	0x00000d55
    2a70:	0000329d 	.word	0x0000329d
    2a74:	000030e1 	.word	0x000030e1
    2a78:	2000a4d8 	.word	0x2000a4d8
    2a7c:	00004c21 	.word	0x00004c21

00002a80 <ip_reass_remove_oldest_datagram>:
{
    2a80:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
		r               = reassdatagrams;
    2a84:	f8df 8068 	ldr.w	r8, [pc, #104]	; 2af0 <ip_reass_remove_oldest_datagram+0x70>
			pbufs_freed_current = ip_reass_free_complete_datagram(oldest, prev);
    2a88:	f8df 9068 	ldr.w	r9, [pc, #104]	; 2af4 <ip_reass_remove_oldest_datagram+0x74>
{
    2a8c:	4605      	mov	r5, r0
    2a8e:	460f      	mov	r7, r1
	int                  pbufs_freed = 0, pbufs_freed_current;
    2a90:	2600      	movs	r6, #0
		other_datagrams = 0;
    2a92:	2400      	movs	r4, #0
		r               = reassdatagrams;
    2a94:	f8d8 3000 	ldr.w	r3, [r8]
		prev            = NULL;
    2a98:	4621      	mov	r1, r4
		oldest          = NULL;
    2a9a:	4620      	mov	r0, r4
		while (r != NULL) {
    2a9c:	b94b      	cbnz	r3, 2ab2 <ip_reass_remove_oldest_datagram+0x32>
		if (oldest != NULL) {
    2a9e:	b108      	cbz	r0, 2aa4 <ip_reass_remove_oldest_datagram+0x24>
			pbufs_freed_current = ip_reass_free_complete_datagram(oldest, prev);
    2aa0:	47c8      	blx	r9
			pbufs_freed += pbufs_freed_current;
    2aa2:	4406      	add	r6, r0
	} while ((pbufs_freed < pbufs_needed) && (other_datagrams > 1));
    2aa4:	42be      	cmp	r6, r7
    2aa6:	da01      	bge.n	2aac <ip_reass_remove_oldest_datagram+0x2c>
    2aa8:	2c01      	cmp	r4, #1
    2aaa:	dcf2      	bgt.n	2a92 <ip_reass_remove_oldest_datagram+0x12>
}
    2aac:	4630      	mov	r0, r6
    2aae:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
			if (!IP_ADDRESSES_AND_ID_MATCH(&r->iphdr, fraghdr)) {
    2ab2:	f8d5 c00c 	ldr.w	ip, [r5, #12]
    2ab6:	695a      	ldr	r2, [r3, #20]
    2ab8:	4562      	cmp	r2, ip
    2aba:	d109      	bne.n	2ad0 <ip_reass_remove_oldest_datagram+0x50>
    2abc:	f8d5 c010 	ldr.w	ip, [r5, #16]
    2ac0:	699a      	ldr	r2, [r3, #24]
    2ac2:	4562      	cmp	r2, ip
    2ac4:	d104      	bne.n	2ad0 <ip_reass_remove_oldest_datagram+0x50>
    2ac6:	f8b3 c00c 	ldrh.w	ip, [r3, #12]
    2aca:	88aa      	ldrh	r2, [r5, #4]
    2acc:	4594      	cmp	ip, r2
    2ace:	d007      	beq.n	2ae0 <ip_reass_remove_oldest_datagram+0x60>
				other_datagrams++;
    2ad0:	3401      	adds	r4, #1
				if (oldest == NULL) {
    2ad2:	b158      	cbz	r0, 2aec <ip_reass_remove_oldest_datagram+0x6c>
				} else if (r->timer <= oldest->timer) {
    2ad4:	f893 c01f 	ldrb.w	ip, [r3, #31]
    2ad8:	7fc2      	ldrb	r2, [r0, #31]
    2ada:	4594      	cmp	ip, r2
    2adc:	bf98      	it	ls
    2ade:	4618      	movls	r0, r3
			if (r->next != NULL) {
    2ae0:	681a      	ldr	r2, [r3, #0]
    2ae2:	2a00      	cmp	r2, #0
    2ae4:	bf18      	it	ne
    2ae6:	4619      	movne	r1, r3
    2ae8:	4613      	mov	r3, r2
    2aea:	e7d7      	b.n	2a9c <ip_reass_remove_oldest_datagram+0x1c>
    2aec:	4618      	mov	r0, r3
    2aee:	e7f7      	b.n	2ae0 <ip_reass_remove_oldest_datagram+0x60>
    2af0:	2000a4d8 	.word	0x2000a4d8
    2af4:	000029e5 	.word	0x000029e5

00002af8 <ipfrag_free_pbuf_custom>:
}

/** Free-callback function to free a 'struct pbuf_custom_ref', called by
 * pbuf_free. */
static void ipfrag_free_pbuf_custom(struct pbuf *p)
{
    2af8:	b510      	push	{r4, lr}
    2afa:	4604      	mov	r4, r0
	struct pbuf_custom_ref *pcr = (struct pbuf_custom_ref *)p;
	LWIP_ASSERT("pcr != NULL", pcr != NULL);
	LWIP_ASSERT("pcr == p", (void *)pcr == (void *)p);
	if (pcr->original != NULL) {
    2afc:	6940      	ldr	r0, [r0, #20]
    2afe:	b108      	cbz	r0, 2b04 <ipfrag_free_pbuf_custom+0xc>
		pbuf_free(pcr->original);
    2b00:	4b03      	ldr	r3, [pc, #12]	; (2b10 <ipfrag_free_pbuf_custom+0x18>)
    2b02:	4798      	blx	r3
	memp_free(MEMP_FRAG_PBUF, p);
    2b04:	4621      	mov	r1, r4
    2b06:	4b03      	ldr	r3, [pc, #12]	; (2b14 <ipfrag_free_pbuf_custom+0x1c>)
	}
	ip_frag_free_pbuf_custom_ref(pcr);
}
    2b08:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	memp_free(MEMP_FRAG_PBUF, p);
    2b0c:	2005      	movs	r0, #5
    2b0e:	4718      	bx	r3
    2b10:	000030e1 	.word	0x000030e1
    2b14:	00004c21 	.word	0x00004c21

00002b18 <ip_reass_tmr>:
	r = reassdatagrams;
    2b18:	4b09      	ldr	r3, [pc, #36]	; (2b40 <ip_reass_tmr+0x28>)
{
    2b1a:	b570      	push	{r4, r5, r6, lr}
	r = reassdatagrams;
    2b1c:	6818      	ldr	r0, [r3, #0]
			ip_reass_free_complete_datagram(tmp, prev);
    2b1e:	4d09      	ldr	r5, [pc, #36]	; (2b44 <ip_reass_tmr+0x2c>)
	struct ip_reassdata *r, *prev = NULL;
    2b20:	2400      	movs	r4, #0
	while (r != NULL) {
    2b22:	b900      	cbnz	r0, 2b26 <ip_reass_tmr+0xe>
}
    2b24:	bd70      	pop	{r4, r5, r6, pc}
		if (r->timer > 0) {
    2b26:	7fc3      	ldrb	r3, [r0, #31]
			r    = r->next;
    2b28:	6806      	ldr	r6, [r0, #0]
		if (r->timer > 0) {
    2b2a:	b123      	cbz	r3, 2b36 <ip_reass_tmr+0x1e>
			r->timer--;
    2b2c:	3b01      	subs	r3, #1
    2b2e:	77c3      	strb	r3, [r0, #31]
			ip_reass_free_complete_datagram(tmp, prev);
    2b30:	4604      	mov	r4, r0
    2b32:	4630      	mov	r0, r6
    2b34:	e7f5      	b.n	2b22 <ip_reass_tmr+0xa>
    2b36:	4621      	mov	r1, r4
    2b38:	47a8      	blx	r5
    2b3a:	4620      	mov	r0, r4
    2b3c:	e7f8      	b.n	2b30 <ip_reass_tmr+0x18>
    2b3e:	bf00      	nop
    2b40:	2000a4d8 	.word	0x2000a4d8
    2b44:	000029e5 	.word	0x000029e5

00002b48 <ip_reass>:
{
    2b48:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	fraghdr = (struct ip_hdr *)p->payload;
    2b4c:	6844      	ldr	r4, [r0, #4]
	if ((IPH_HL(fraghdr) * 4) != IP_HLEN) {
    2b4e:	7823      	ldrb	r3, [r4, #0]
    2b50:	f003 030f 	and.w	r3, r3, #15
    2b54:	2b05      	cmp	r3, #5
{
    2b56:	b085      	sub	sp, #20
    2b58:	4605      	mov	r5, r0
	if ((IPH_HL(fraghdr) * 4) != IP_HLEN) {
    2b5a:	f040 808f 	bne.w	2c7c <ip_reass+0x134>
	offset = (ntohs(IPH_OFFSET(fraghdr)) & IP_OFFMASK) * 8;
    2b5e:	4fa8      	ldr	r7, [pc, #672]	; (2e00 <ip_reass+0x2b8>)
    2b60:	88e0      	ldrh	r0, [r4, #6]
	clen = pbuf_clen(p);
    2b62:	f8df 92c4 	ldr.w	r9, [pc, #708]	; 2e28 <ip_reass+0x2e0>
	if ((ip_reass_pbufcount + clen) > IP_REASS_MAX_PBUFS) {
    2b66:	f8df a2a4 	ldr.w	sl, [pc, #676]	; 2e0c <ip_reass+0x2c4>
	offset = (ntohs(IPH_OFFSET(fraghdr)) & IP_OFFMASK) * 8;
    2b6a:	47b8      	blx	r7
    2b6c:	9002      	str	r0, [sp, #8]
	len    = ntohs(IPH_LEN(fraghdr)) - IPH_HL(fraghdr) * 4;
    2b6e:	8860      	ldrh	r0, [r4, #2]
    2b70:	47b8      	blx	r7
    2b72:	9003      	str	r0, [sp, #12]
	clen = pbuf_clen(p);
    2b74:	4628      	mov	r0, r5
	len    = ntohs(IPH_LEN(fraghdr)) - IPH_HL(fraghdr) * 4;
    2b76:	f894 8000 	ldrb.w	r8, [r4]
	clen = pbuf_clen(p);
    2b7a:	47c8      	blx	r9
	if ((ip_reass_pbufcount + clen) > IP_REASS_MAX_PBUFS) {
    2b7c:	f8ba 3004 	ldrh.w	r3, [sl, #4]
    2b80:	f8cd 9004 	str.w	r9, [sp, #4]
    2b84:	4403      	add	r3, r0
    2b86:	2b0a      	cmp	r3, #10
	clen = pbuf_clen(p);
    2b88:	4606      	mov	r6, r0
	if ((ip_reass_pbufcount + clen) > IP_REASS_MAX_PBUFS) {
    2b8a:	dc6d      	bgt.n	2c68 <ip_reass+0x120>
	for (ipr = reassdatagrams; ipr != NULL; ipr = ipr->next) {
    2b8c:	f8da 9000 	ldr.w	r9, [sl]
	struct ip_reassdata *   ipr_prev = NULL;
    2b90:	f04f 0a00 	mov.w	sl, #0
	for (ipr = reassdatagrams; ipr != NULL; ipr = ipr->next) {
    2b94:	f1b9 0f00 	cmp.w	r9, #0
    2b98:	d175      	bne.n	2c86 <ip_reass+0x13e>
	ipr = (struct ip_reassdata *)memp_malloc(MEMP_REASSDATA);
    2b9a:	f8df b290 	ldr.w	fp, [pc, #656]	; 2e2c <ip_reass+0x2e4>
    2b9e:	2004      	movs	r0, #4
    2ba0:	47d8      	blx	fp
	if (ipr == NULL) {
    2ba2:	4681      	mov	r9, r0
    2ba4:	b950      	cbnz	r0, 2bbc <ip_reass+0x74>
		if (ip_reass_remove_oldest_datagram(fraghdr, clen) >= clen) {
    2ba6:	4b97      	ldr	r3, [pc, #604]	; (2e04 <ip_reass+0x2bc>)
    2ba8:	4631      	mov	r1, r6
    2baa:	4620      	mov	r0, r4
    2bac:	4798      	blx	r3
    2bae:	4286      	cmp	r6, r0
    2bb0:	dc64      	bgt.n	2c7c <ip_reass+0x134>
			ipr = (struct ip_reassdata *)memp_malloc(MEMP_REASSDATA);
    2bb2:	2004      	movs	r0, #4
    2bb4:	47d8      	blx	fp
		if (ipr == NULL)
    2bb6:	4681      	mov	r9, r0
    2bb8:	2800      	cmp	r0, #0
    2bba:	d05f      	beq.n	2c7c <ip_reass+0x134>
	memset(ipr, 0, sizeof(struct ip_reassdata));
    2bbc:	221c      	movs	r2, #28
    2bbe:	2100      	movs	r1, #0
    2bc0:	4b91      	ldr	r3, [pc, #580]	; (2e08 <ip_reass+0x2c0>)
    2bc2:	f109 0004 	add.w	r0, r9, #4
    2bc6:	4798      	blx	r3
	ipr->timer = IP_REASS_MAXAGE;
    2bc8:	2203      	movs	r2, #3
    2bca:	f889 201f 	strb.w	r2, [r9, #31]
	ipr->next      = reassdatagrams;
    2bce:	4a8f      	ldr	r2, [pc, #572]	; (2e0c <ip_reass+0x2c4>)
    2bd0:	6811      	ldr	r1, [r2, #0]
    2bd2:	f8c9 1000 	str.w	r1, [r9]
	reassdatagrams = ipr;
    2bd6:	f8c2 9000 	str.w	r9, [r2]
	SMEMCPY(&(ipr->iphdr), fraghdr, IP_HLEN);
    2bda:	f109 0108 	add.w	r1, r9, #8
    2bde:	4622      	mov	r2, r4
    2be0:	f104 0014 	add.w	r0, r4, #20
    2be4:	f852 cb04 	ldr.w	ip, [r2], #4
    2be8:	f841 cb04 	str.w	ip, [r1], #4
    2bec:	4282      	cmp	r2, r0
    2bee:	d1f9      	bne.n	2be4 <ip_reass+0x9c>
	ip_reass_pbufcount += clen;
    2bf0:	f8df b218 	ldr.w	fp, [pc, #536]	; 2e0c <ip_reass+0x2c4>
    2bf4:	f8bb 0004 	ldrh.w	r0, [fp, #4]
    2bf8:	4406      	add	r6, r0
    2bfa:	f8ab 6004 	strh.w	r6, [fp, #4]
	if ((IPH_OFFSET(fraghdr) & PP_NTOHS(IP_MF)) == 0) {
    2bfe:	88e2      	ldrh	r2, [r4, #6]
    2c00:	0693      	lsls	r3, r2, #26
    2c02:	d40f      	bmi.n	2c24 <ip_reass+0xdc>
	len    = ntohs(IPH_LEN(fraghdr)) - IPH_HL(fraghdr) * 4;
    2c04:	9b03      	ldr	r3, [sp, #12]
		ipr->flags |= IP_REASS_FLAG_LASTFRAG;
    2c06:	f899 201e 	ldrb.w	r2, [r9, #30]
	len    = ntohs(IPH_LEN(fraghdr)) - IPH_HL(fraghdr) * 4;
    2c0a:	f008 000f 	and.w	r0, r8, #15
    2c0e:	eba3 0080 	sub.w	r0, r3, r0, lsl #2
		ipr->datagram_len = offset + len;
    2c12:	9b02      	ldr	r3, [sp, #8]
		ipr->flags |= IP_REASS_FLAG_LASTFRAG;
    2c14:	f042 0201 	orr.w	r2, r2, #1
		ipr->datagram_len = offset + len;
    2c18:	eb00 00c3 	add.w	r0, r0, r3, lsl #3
		ipr->flags |= IP_REASS_FLAG_LASTFRAG;
    2c1c:	f889 201e 	strb.w	r2, [r9, #30]
		ipr->datagram_len = offset + len;
    2c20:	f8a9 001c 	strh.w	r0, [r9, #28]
	fraghdr = (struct ip_hdr *)new_p->payload;
    2c24:	686e      	ldr	r6, [r5, #4]
	len     = ntohs(IPH_LEN(fraghdr)) - IPH_HL(fraghdr) * 4;
    2c26:	8870      	ldrh	r0, [r6, #2]
    2c28:	47b8      	blx	r7
    2c2a:	7834      	ldrb	r4, [r6, #0]
    2c2c:	f004 040f 	and.w	r4, r4, #15
    2c30:	eba0 0484 	sub.w	r4, r0, r4, lsl #2
	offset  = (ntohs(IPH_OFFSET(fraghdr)) & IP_OFFMASK) * 8;
    2c34:	88f0      	ldrh	r0, [r6, #6]
    2c36:	47b8      	blx	r7
    2c38:	f3c0 000c 	ubfx	r0, r0, #0, #13
	iprh            = (struct ip_reass_helper *)new_p->payload;
    2c3c:	6869      	ldr	r1, [r5, #4]
	for (q = ipr->p; q != NULL;) {
    2c3e:	f8d9 6004 	ldr.w	r6, [r9, #4]
	offset  = (ntohs(IPH_OFFSET(fraghdr)) & IP_OFFMASK) * 8;
    2c42:	00c0      	lsls	r0, r0, #3
	len     = ntohs(IPH_LEN(fraghdr)) - IPH_HL(fraghdr) * 4;
    2c44:	b2a4      	uxth	r4, r4
	iprh->next_pbuf = NULL;
    2c46:	2200      	movs	r2, #0
	iprh->end       = offset + len;
    2c48:	4404      	add	r4, r0
	iprh->next_pbuf = NULL;
    2c4a:	700a      	strb	r2, [r1, #0]
    2c4c:	704a      	strb	r2, [r1, #1]
    2c4e:	708a      	strb	r2, [r1, #2]
    2c50:	70ca      	strb	r2, [r1, #3]
	iprh->start     = offset;
    2c52:	8088      	strh	r0, [r1, #4]
	iprh->end       = offset + len;
    2c54:	fa1f fe84 	uxth.w	lr, r4
    2c58:	80cc      	strh	r4, [r1, #6]
	int                     valid = 1;
    2c5a:	2301      	movs	r3, #1
	for (q = ipr->p; q != NULL;) {
    2c5c:	bb3e      	cbnz	r6, 2cae <ip_reass+0x166>
		if (iprh_prev != NULL) {
    2c5e:	2a00      	cmp	r2, #0
    2c60:	d173      	bne.n	2d4a <ip_reass+0x202>
			ipr->p = new_p;
    2c62:	f8c9 5004 	str.w	r5, [r9, #4]
    2c66:	e02f      	b.n	2cc8 <ip_reass+0x180>
		if (!ip_reass_remove_oldest_datagram(fraghdr, clen) || ((ip_reass_pbufcount + clen) > IP_REASS_MAX_PBUFS))
    2c68:	4601      	mov	r1, r0
    2c6a:	4b66      	ldr	r3, [pc, #408]	; (2e04 <ip_reass+0x2bc>)
    2c6c:	4620      	mov	r0, r4
    2c6e:	4798      	blx	r3
    2c70:	b120      	cbz	r0, 2c7c <ip_reass+0x134>
    2c72:	f8ba 3004 	ldrh.w	r3, [sl, #4]
    2c76:	4433      	add	r3, r6
    2c78:	2b0a      	cmp	r3, #10
    2c7a:	dd87      	ble.n	2b8c <ip_reass+0x44>
	pbuf_free(p);
    2c7c:	4b64      	ldr	r3, [pc, #400]	; (2e10 <ip_reass+0x2c8>)
    2c7e:	4628      	mov	r0, r5
    2c80:	4798      	blx	r3
	return NULL;
    2c82:	2400      	movs	r4, #0
    2c84:	e09d      	b.n	2dc2 <ip_reass+0x27a>
		if (IP_ADDRESSES_AND_ID_MATCH(&ipr->iphdr, fraghdr)) {
    2c86:	68e2      	ldr	r2, [r4, #12]
    2c88:	f8d9 1014 	ldr.w	r1, [r9, #20]
    2c8c:	4291      	cmp	r1, r2
    2c8e:	d10a      	bne.n	2ca6 <ip_reass+0x15e>
    2c90:	6922      	ldr	r2, [r4, #16]
    2c92:	f8d9 1018 	ldr.w	r1, [r9, #24]
    2c96:	4291      	cmp	r1, r2
    2c98:	d105      	bne.n	2ca6 <ip_reass+0x15e>
    2c9a:	f8b9 100c 	ldrh.w	r1, [r9, #12]
    2c9e:	88a2      	ldrh	r2, [r4, #4]
    2ca0:	4291      	cmp	r1, r2
    2ca2:	f000 8092 	beq.w	2dca <ip_reass+0x282>
	for (ipr = reassdatagrams; ipr != NULL; ipr = ipr->next) {
    2ca6:	46ca      	mov	sl, r9
    2ca8:	f8d9 9000 	ldr.w	r9, [r9]
    2cac:	e772      	b.n	2b94 <ip_reass+0x4c>
		iprh_tmp = (struct ip_reass_helper *)q->payload;
    2cae:	6877      	ldr	r7, [r6, #4]
		if (iprh->start < iprh_tmp->start) {
    2cb0:	88bc      	ldrh	r4, [r7, #4]
    2cb2:	42a0      	cmp	r0, r4
    2cb4:	d23d      	bcs.n	2d32 <ip_reass+0x1ea>
			iprh->next_pbuf = q;
    2cb6:	600e      	str	r6, [r1, #0]
			if (iprh_prev != NULL) {
    2cb8:	2a00      	cmp	r2, #0
    2cba:	d0d2      	beq.n	2c62 <ip_reass+0x11a>
				if ((iprh->start < iprh_prev->end) || (iprh->end > iprh_tmp->start)) {
    2cbc:	88d6      	ldrh	r6, [r2, #6]
    2cbe:	4286      	cmp	r6, r0
    2cc0:	d851      	bhi.n	2d66 <ip_reass+0x21e>
    2cc2:	45a6      	cmp	lr, r4
    2cc4:	d84f      	bhi.n	2d66 <ip_reass+0x21e>
				iprh_prev->next_pbuf = new_p;
    2cc6:	6015      	str	r5, [r2, #0]
	if ((ipr->flags & IP_REASS_FLAG_LASTFRAG) != 0) {
    2cc8:	f899 201e 	ldrb.w	r2, [r9, #30]
    2ccc:	f012 0401 	ands.w	r4, r2, #1
    2cd0:	d077      	beq.n	2dc2 <ip_reass+0x27a>
		if (valid) {
    2cd2:	2b00      	cmp	r3, #0
    2cd4:	d0d5      	beq.n	2c82 <ip_reass+0x13a>
			if (((struct ip_reass_helper *)ipr->p->payload)->start != 0) {
    2cd6:	f8d9 2004 	ldr.w	r2, [r9, #4]
    2cda:	6854      	ldr	r4, [r2, #4]
    2cdc:	88a2      	ldrh	r2, [r4, #4]
    2cde:	2a00      	cmp	r2, #0
    2ce0:	d1cf      	bne.n	2c82 <ip_reass+0x13a>
				q         = iprh->next_pbuf;
    2ce2:	680a      	ldr	r2, [r1, #0]
				while (q != NULL) {
    2ce4:	2a00      	cmp	r2, #0
    2ce6:	d136      	bne.n	2d56 <ip_reass+0x20e>
		ipr->datagram_len += IP_HLEN;
    2ce8:	f8b9 201c 	ldrh.w	r2, [r9, #28]
		r = ((struct ip_reass_helper *)ipr->p->payload)->next_pbuf;
    2cec:	6825      	ldr	r5, [r4, #0]
		ipr->datagram_len += IP_HLEN;
    2cee:	3214      	adds	r2, #20
    2cf0:	f8a9 201c 	strh.w	r2, [r9, #28]
		SMEMCPY(fraghdr, &ipr->iphdr, IP_HLEN);
    2cf4:	4621      	mov	r1, r4
    2cf6:	f109 0208 	add.w	r2, r9, #8
    2cfa:	f109 001c 	add.w	r0, r9, #28
    2cfe:	f852 6b04 	ldr.w	r6, [r2], #4
    2d02:	f841 6b04 	str.w	r6, [r1], #4
    2d06:	4282      	cmp	r2, r0
    2d08:	d1f9      	bne.n	2cfe <ip_reass+0x1b6>
		IPH_LEN_SET(fraghdr, htons(ipr->datagram_len));
    2d0a:	4a42      	ldr	r2, [pc, #264]	; (2e14 <ip_reass+0x2cc>)
    2d0c:	f8b9 001c 	ldrh.w	r0, [r9, #28]
			pbuf_header(r, -IP_HLEN);
    2d10:	4f41      	ldr	r7, [pc, #260]	; (2e18 <ip_reass+0x2d0>)
			pbuf_cat(p, r);
    2d12:	4e42      	ldr	r6, [pc, #264]	; (2e1c <ip_reass+0x2d4>)
		IPH_LEN_SET(fraghdr, htons(ipr->datagram_len));
    2d14:	4790      	blx	r2
		IPH_OFFSET_SET(fraghdr, 0);
    2d16:	2200      	movs	r2, #0
		IPH_LEN_SET(fraghdr, htons(ipr->datagram_len));
    2d18:	8060      	strh	r0, [r4, #2]
		IPH_OFFSET_SET(fraghdr, 0);
    2d1a:	71a2      	strb	r2, [r4, #6]
    2d1c:	71e2      	strb	r2, [r4, #7]
		IPH_CHKSUM_SET(fraghdr, 0);
    2d1e:	72a2      	strb	r2, [r4, #10]
    2d20:	72e2      	strb	r2, [r4, #11]
		IPH_CHKSUM_SET(fraghdr, inet_chksum(fraghdr, IP_HLEN));
    2d22:	4620      	mov	r0, r4
    2d24:	4a3e      	ldr	r2, [pc, #248]	; (2e20 <ip_reass+0x2d8>)
    2d26:	2114      	movs	r1, #20
    2d28:	4790      	blx	r2
    2d2a:	8160      	strh	r0, [r4, #10]
		p = ipr->p;
    2d2c:	f8d9 4004 	ldr.w	r4, [r9, #4]
		while (r != NULL) {
    2d30:	e02d      	b.n	2d8e <ip_reass+0x246>
		} else if (iprh->start == iprh_tmp->start) {
    2d32:	d018      	beq.n	2d66 <ip_reass+0x21e>
		} else if (iprh->start < iprh_tmp->end) {
    2d34:	88fe      	ldrh	r6, [r7, #6]
    2d36:	4286      	cmp	r6, r0
    2d38:	d815      	bhi.n	2d66 <ip_reass+0x21e>
			if (iprh_prev != NULL) {
    2d3a:	b11a      	cbz	r2, 2d44 <ip_reass+0x1fc>
				if (iprh_prev->end != iprh_tmp->start) {
    2d3c:	88d2      	ldrh	r2, [r2, #6]
					valid = 0;
    2d3e:	42a2      	cmp	r2, r4
    2d40:	bf18      	it	ne
    2d42:	2300      	movne	r3, #0
		q         = iprh_tmp->next_pbuf;
    2d44:	683e      	ldr	r6, [r7, #0]
    2d46:	463a      	mov	r2, r7
    2d48:	e788      	b.n	2c5c <ip_reass+0x114>
			iprh_prev->next_pbuf = new_p;
    2d4a:	6015      	str	r5, [r2, #0]
			if (iprh_prev->end != iprh->start) {
    2d4c:	88d2      	ldrh	r2, [r2, #6]
				valid = 0;
    2d4e:	4282      	cmp	r2, r0
    2d50:	bf18      	it	ne
    2d52:	2300      	movne	r3, #0
    2d54:	e7b8      	b.n	2cc8 <ip_reass+0x180>
					iprh = (struct ip_reass_helper *)q->payload;
    2d56:	6850      	ldr	r0, [r2, #4]
					if (iprh_prev->end != iprh->start) {
    2d58:	88c9      	ldrh	r1, [r1, #6]
    2d5a:	8882      	ldrh	r2, [r0, #4]
    2d5c:	4291      	cmp	r1, r2
    2d5e:	d190      	bne.n	2c82 <ip_reass+0x13a>
					q         = iprh->next_pbuf;
    2d60:	6802      	ldr	r2, [r0, #0]
    2d62:	4601      	mov	r1, r0
    2d64:	e7be      	b.n	2ce4 <ip_reass+0x19c>
	ip_reass_pbufcount -= pbuf_clen(new_p);
    2d66:	9b01      	ldr	r3, [sp, #4]
    2d68:	4628      	mov	r0, r5
    2d6a:	4798      	blx	r3
    2d6c:	f8bb 3004 	ldrh.w	r3, [fp, #4]
    2d70:	1a18      	subs	r0, r3, r0
    2d72:	f8ab 0004 	strh.w	r0, [fp, #4]
	pbuf_free(new_p);
    2d76:	e781      	b.n	2c7c <ip_reass+0x134>
			iprh = (struct ip_reass_helper *)r->payload;
    2d78:	f8d5 8004 	ldr.w	r8, [r5, #4]
			pbuf_header(r, -IP_HLEN);
    2d7c:	f06f 0113 	mvn.w	r1, #19
    2d80:	4628      	mov	r0, r5
    2d82:	47b8      	blx	r7
			pbuf_cat(p, r);
    2d84:	4629      	mov	r1, r5
    2d86:	4620      	mov	r0, r4
    2d88:	47b0      	blx	r6
			r = iprh->next_pbuf;
    2d8a:	f8d8 5000 	ldr.w	r5, [r8]
		while (r != NULL) {
    2d8e:	2d00      	cmp	r5, #0
    2d90:	d1f2      	bne.n	2d78 <ip_reass+0x230>
	if (reassdatagrams == ipr) {
    2d92:	f8db 1000 	ldr.w	r1, [fp]
		reassdatagrams = ipr->next;
    2d96:	f8d9 2000 	ldr.w	r2, [r9]
	memp_free(MEMP_REASSDATA, ipr);
    2d9a:	4b22      	ldr	r3, [pc, #136]	; (2e24 <ip_reass+0x2dc>)
	if (reassdatagrams == ipr) {
    2d9c:	4589      	cmp	r9, r1
		prev->next = ipr->next;
    2d9e:	bf18      	it	ne
    2da0:	f8ca 2000 	strne.w	r2, [sl]
	memp_free(MEMP_REASSDATA, ipr);
    2da4:	4649      	mov	r1, r9
    2da6:	f04f 0004 	mov.w	r0, #4
		reassdatagrams = ipr->next;
    2daa:	bf08      	it	eq
    2dac:	f8cb 2000 	streq.w	r2, [fp]
	memp_free(MEMP_REASSDATA, ipr);
    2db0:	4798      	blx	r3
		ip_reass_pbufcount -= pbuf_clen(p);
    2db2:	9b01      	ldr	r3, [sp, #4]
    2db4:	4620      	mov	r0, r4
    2db6:	4798      	blx	r3
    2db8:	f8bb 3004 	ldrh.w	r3, [fp, #4]
    2dbc:	1a18      	subs	r0, r3, r0
    2dbe:	f8ab 0004 	strh.w	r0, [fp, #4]
}
    2dc2:	4620      	mov	r0, r4
    2dc4:	b005      	add	sp, #20
    2dc6:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		if (((ntohs(IPH_OFFSET(fraghdr)) & IP_OFFMASK) == 0) && ((ntohs(IPH_OFFSET(&ipr->iphdr)) & IP_OFFMASK) != 0)) {
    2dca:	88e0      	ldrh	r0, [r4, #6]
    2dcc:	47b8      	blx	r7
    2dce:	f3c0 000c 	ubfx	r0, r0, #0, #13
    2dd2:	2800      	cmp	r0, #0
    2dd4:	f47f af0c 	bne.w	2bf0 <ip_reass+0xa8>
    2dd8:	f8b9 000e 	ldrh.w	r0, [r9, #14]
    2ddc:	47b8      	blx	r7
    2dde:	f3c0 000c 	ubfx	r0, r0, #0, #13
    2de2:	2800      	cmp	r0, #0
    2de4:	f43f af04 	beq.w	2bf0 <ip_reass+0xa8>
			SMEMCPY(&ipr->iphdr, fraghdr, IP_HLEN);
    2de8:	4622      	mov	r2, r4
    2dea:	f109 0108 	add.w	r1, r9, #8
    2dee:	f104 0014 	add.w	r0, r4, #20
    2df2:	f852 cb04 	ldr.w	ip, [r2], #4
    2df6:	f841 cb04 	str.w	ip, [r1], #4
    2dfa:	4282      	cmp	r2, r0
    2dfc:	d1f9      	bne.n	2df2 <ip_reass+0x2aa>
    2dfe:	e6f7      	b.n	2bf0 <ip_reass+0xa8>
    2e00:	00000d67 	.word	0x00000d67
    2e04:	00002a81 	.word	0x00002a81
    2e08:	0000c099 	.word	0x0000c099
    2e0c:	2000a4d8 	.word	0x2000a4d8
    2e10:	000030e1 	.word	0x000030e1
    2e14:	00000d61 	.word	0x00000d61
    2e18:	00003089 	.word	0x00003089
    2e1c:	000032b7 	.word	0x000032b7
    2e20:	00008419 	.word	0x00008419
    2e24:	00004c21 	.word	0x00004c21
    2e28:	0000329d 	.word	0x0000329d
    2e2c:	00004c05 	.word	0x00004c05

00002e30 <ip_frag>:
 * @param dest destination ip address to which to send
 *
 * @return ERR_OK if sent successfully, err_t otherwise
 */
err_t ip_frag(struct pbuf *p, struct netif *netif, ip_addr_t *dest)
{
    2e30:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    2e34:	ed2d 8b02 	vpush	{d8}
    2e38:	b08d      	sub	sp, #52	; 0x34
	struct ip_hdr *original_iphdr;
#endif
	struct ip_hdr *iphdr;
	u16_t          nfb;
	u16_t          left, cop;
	u16_t          mtu = netif->mtu;
    2e3a:	8d0b      	ldrh	r3, [r1, #40]	; 0x28
    2e3c:	9305      	str	r3, [sp, #20]

	/* Copy the IP header in it */
	iphdr = (struct ip_hdr *)rambuf->payload;
	SMEMCPY(iphdr, p->payload, IP_HLEN);
#else  /* IP_FRAG_USES_STATIC_BUF */
	original_iphdr = (struct ip_hdr *)p->payload;
    2e3e:	6843      	ldr	r3, [r0, #4]
    2e40:	9306      	str	r3, [sp, #24]
{
    2e42:	4604      	mov	r4, r0
	iphdr          = original_iphdr;
#endif /* IP_FRAG_USES_STATIC_BUF */

	/* Save original offset */
	tmp = ntohs(IPH_OFFSET(iphdr));
    2e44:	88d8      	ldrh	r0, [r3, #6]
    2e46:	4b5e      	ldr	r3, [pc, #376]	; (2fc0 <ip_frag+0x190>)
{
    2e48:	ee08 2a10 	vmov	s16, r2
    2e4c:	468a      	mov	sl, r1
	tmp = ntohs(IPH_OFFSET(iphdr));
    2e4e:	4798      	blx	r3
	ofo = tmp & IP_OFFMASK;
	omf = tmp & IP_MF;

	left = p->tot_len - IP_HLEN;
    2e50:	8925      	ldrh	r5, [r4, #8]
	ofo = tmp & IP_OFFMASK;
    2e52:	f3c0 030c 	ubfx	r3, r0, #0, #13
    2e56:	9304      	str	r3, [sp, #16]
	left = p->tot_len - IP_HLEN;
    2e58:	3d14      	subs	r5, #20
	omf = tmp & IP_MF;
    2e5a:	f400 5300 	and.w	r3, r0, #8192	; 0x2000
    2e5e:	9308      	str	r3, [sp, #32]
	left = p->tot_len - IP_HLEN;
    2e60:	b2ab      	uxth	r3, r5
    2e62:	9302      	str	r3, [sp, #8]

	nfb = (mtu - IP_HLEN) / 8;
    2e64:	9b05      	ldr	r3, [sp, #20]
    2e66:	3b14      	subs	r3, #20
    2e68:	bf44      	itt	mi
    2e6a:	9b05      	ldrmi	r3, [sp, #20]
    2e6c:	3b0d      	submi	r3, #13
    2e6e:	f3c3 03cf 	ubfx	r3, r3, #3, #16
    2e72:	9307      	str	r3, [sp, #28]
		if (!last) {
			tmp = tmp | IP_MF;
		}

		/* Fill this fragment */
		cop = last ? left : nfb * 8;
    2e74:	00db      	lsls	r3, r3, #3
    2e76:	b29b      	uxth	r3, r3
    2e78:	9309      	str	r3, [sp, #36]	; 0x24
	u16_t          poff = IP_HLEN;
    2e7a:	2614      	movs	r6, #20
	u16_t newpbuflen = 0;
    2e7c:	2300      	movs	r3, #0
	while (left) {
    2e7e:	9a02      	ldr	r2, [sp, #8]
    2e80:	b92a      	cbnz	r2, 2e8e <ip_frag+0x5e>
	}
#if IP_FRAG_USES_STATIC_BUF
	pbuf_free(rambuf);
#endif /* IP_FRAG_USES_STATIC_BUF */
	snmp_inc_ipfragoks();
	return ERR_OK;
    2e82:	4610      	mov	r0, r2
}
    2e84:	b00d      	add	sp, #52	; 0x34
    2e86:	ecbd 8b02 	vpop	{d8}
    2e8a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		tmp = omf | (IP_OFFMASK & (ofo));
    2e8e:	9a04      	ldr	r2, [sp, #16]
		if (!last) {
    2e90:	9902      	ldr	r1, [sp, #8]
    2e92:	930a      	str	r3, [sp, #40]	; 0x28
		tmp = omf | (IP_OFFMASK & (ofo));
    2e94:	f3c2 0b0c 	ubfx	fp, r2, #0, #13
    2e98:	9a08      	ldr	r2, [sp, #32]
		rambuf = pbuf_alloc(PBUF_LINK, IP_HLEN, PBUF_RAM);
    2e9a:	4b4a      	ldr	r3, [pc, #296]	; (2fc4 <ip_frag+0x194>)
		tmp = omf | (IP_OFFMASK & (ofo));
    2e9c:	ea42 0b0b 	orr.w	fp, r2, fp
		last = (left <= mtu - IP_HLEN);
    2ea0:	9a05      	ldr	r2, [sp, #20]
    2ea2:	3a13      	subs	r2, #19
		if (!last) {
    2ea4:	428a      	cmp	r2, r1
		cop = last ? left : nfb * 8;
    2ea6:	bfd4      	ite	le
    2ea8:	9a09      	ldrle	r2, [sp, #36]	; 0x24
    2eaa:	9a02      	ldrgt	r2, [sp, #8]
    2eac:	9203      	str	r2, [sp, #12]
		rambuf = pbuf_alloc(PBUF_LINK, IP_HLEN, PBUF_RAM);
    2eae:	f04f 0114 	mov.w	r1, #20
    2eb2:	f04f 0200 	mov.w	r2, #0
    2eb6:	f04f 0002 	mov.w	r0, #2
			tmp = tmp | IP_MF;
    2eba:	bfd8      	it	le
    2ebc:	f44b 5b00 	orrle.w	fp, fp, #8192	; 0x2000
		rambuf = pbuf_alloc(PBUF_LINK, IP_HLEN, PBUF_RAM);
    2ec0:	4798      	blx	r3
		if (rambuf == NULL) {
    2ec2:	4607      	mov	r7, r0
    2ec4:	b340      	cbz	r0, 2f18 <ip_frag+0xe8>
		SMEMCPY(rambuf->payload, original_iphdr, IP_HLEN);
    2ec6:	9a06      	ldr	r2, [sp, #24]
    2ec8:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    2eca:	6841      	ldr	r1, [r0, #4]
    2ecc:	f102 0014 	add.w	r0, r2, #20
    2ed0:	f852 cb04 	ldr.w	ip, [r2], #4
    2ed4:	f841 cb04 	str.w	ip, [r1], #4
    2ed8:	4282      	cmp	r2, r0
    2eda:	d1f9      	bne.n	2ed0 <ip_frag+0xa0>
		p->payload = (u8_t *)p->payload + poff;
    2edc:	6862      	ldr	r2, [r4, #4]
		iphdr = (struct ip_hdr *)rambuf->payload;
    2ede:	f8d7 9004 	ldr.w	r9, [r7, #4]
		left_to_copy = cop;
    2ee2:	f8dd 800c 	ldr.w	r8, [sp, #12]
		p->payload = (u8_t *)p->payload + poff;
    2ee6:	4432      	add	r2, r6
    2ee8:	6062      	str	r2, [r4, #4]
		p->len -= poff;
    2eea:	8962      	ldrh	r2, [r4, #10]
    2eec:	1b96      	subs	r6, r2, r6
    2eee:	8166      	strh	r6, [r4, #10]
		while (left_to_copy) {
    2ef0:	461e      	mov	r6, r3
    2ef2:	f1b8 0f00 	cmp.w	r8, #0
    2ef6:	d036      	beq.n	2f66 <ip_frag+0x136>
			newpbuflen = (left_to_copy < p->len) ? left_to_copy : p->len;
    2ef8:	8966      	ldrh	r6, [r4, #10]
    2efa:	4546      	cmp	r6, r8
    2efc:	bf28      	it	cs
    2efe:	4646      	movcs	r6, r8
    2f00:	b2b6      	uxth	r6, r6
			if (!newpbuflen) {
    2f02:	b90e      	cbnz	r6, 2f08 <ip_frag+0xd8>
				p = p->next;
    2f04:	6824      	ldr	r4, [r4, #0]
    2f06:	e7f4      	b.n	2ef2 <ip_frag+0xc2>
	return (struct pbuf_custom_ref *)memp_malloc(MEMP_FRAG_PBUF);
    2f08:	4b2f      	ldr	r3, [pc, #188]	; (2fc8 <ip_frag+0x198>)
    2f0a:	2005      	movs	r0, #5
    2f0c:	4798      	blx	r3
			if (pcr == NULL) {
    2f0e:	4603      	mov	r3, r0
    2f10:	b928      	cbnz	r0, 2f1e <ip_frag+0xee>
				pbuf_free(rambuf);
    2f12:	4b2e      	ldr	r3, [pc, #184]	; (2fcc <ip_frag+0x19c>)
    2f14:	4638      	mov	r0, r7
    2f16:	4798      	blx	r3
			return ERR_MEM;
    2f18:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    2f1c:	e7b2      	b.n	2e84 <ip_frag+0x54>
			newpbuf = pbuf_alloced_custom(PBUF_RAW, newpbuflen, PBUF_REF, &pcr->pc, p->payload, newpbuflen);
    2f1e:	9601      	str	r6, [sp, #4]
    2f20:	6862      	ldr	r2, [r4, #4]
    2f22:	9200      	str	r2, [sp, #0]
    2f24:	900a      	str	r0, [sp, #40]	; 0x28
    2f26:	4d2a      	ldr	r5, [pc, #168]	; (2fd0 <ip_frag+0x1a0>)
    2f28:	2202      	movs	r2, #2
    2f2a:	4631      	mov	r1, r6
    2f2c:	2003      	movs	r0, #3
    2f2e:	47a8      	blx	r5
			if (newpbuf == NULL) {
    2f30:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    2f32:	b920      	cbnz	r0, 2f3e <ip_frag+0x10e>
	memp_free(MEMP_FRAG_PBUF, p);
    2f34:	4619      	mov	r1, r3
    2f36:	2005      	movs	r0, #5
    2f38:	4b26      	ldr	r3, [pc, #152]	; (2fd4 <ip_frag+0x1a4>)
    2f3a:	4798      	blx	r3
    2f3c:	e7e9      	b.n	2f12 <ip_frag+0xe2>
    2f3e:	e9cd 030a 	strd	r0, r3, [sp, #40]	; 0x28
			pbuf_ref(p);
    2f42:	4b25      	ldr	r3, [pc, #148]	; (2fd8 <ip_frag+0x1a8>)
    2f44:	4620      	mov	r0, r4
    2f46:	4798      	blx	r3
			pcr->original                = p;
    2f48:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
			pcr->pc.custom_free_function = ipfrag_free_pbuf_custom;
    2f4a:	4a24      	ldr	r2, [pc, #144]	; (2fdc <ip_frag+0x1ac>)
			pcr->original                = p;
    2f4c:	615c      	str	r4, [r3, #20]
			left_to_copy -= newpbuflen;
    2f4e:	eba8 0806 	sub.w	r8, r8, r6
			pcr->pc.custom_free_function = ipfrag_free_pbuf_custom;
    2f52:	611a      	str	r2, [r3, #16]
			pbuf_cat(rambuf, newpbuf);
    2f54:	990a      	ldr	r1, [sp, #40]	; 0x28
    2f56:	4b22      	ldr	r3, [pc, #136]	; (2fe0 <ip_frag+0x1b0>)
    2f58:	4638      	mov	r0, r7
			left_to_copy -= newpbuflen;
    2f5a:	fa1f f888 	uxth.w	r8, r8
			pbuf_cat(rambuf, newpbuf);
    2f5e:	4798      	blx	r3
			if (left_to_copy) {
    2f60:	f1b8 0f00 	cmp.w	r8, #0
    2f64:	d1ce      	bne.n	2f04 <ip_frag+0xd4>
		IPH_OFFSET_SET(iphdr, htons(tmp));
    2f66:	4658      	mov	r0, fp
    2f68:	f8df b07c 	ldr.w	fp, [pc, #124]	; 2fe8 <ip_frag+0x1b8>
    2f6c:	47d8      	blx	fp
		IPH_LEN_SET(iphdr, htons(cop + IP_HLEN));
    2f6e:	9b03      	ldr	r3, [sp, #12]
		IPH_OFFSET_SET(iphdr, htons(tmp));
    2f70:	f8a9 0006 	strh.w	r0, [r9, #6]
		IPH_LEN_SET(iphdr, htons(cop + IP_HLEN));
    2f74:	f103 0014 	add.w	r0, r3, #20
    2f78:	b280      	uxth	r0, r0
    2f7a:	47d8      	blx	fp
		IPH_CHKSUM_SET(iphdr, inet_chksum(iphdr, IP_HLEN));
    2f7c:	4b19      	ldr	r3, [pc, #100]	; (2fe4 <ip_frag+0x1b4>)
		IPH_LEN_SET(iphdr, htons(cop + IP_HLEN));
    2f7e:	f8a9 0002 	strh.w	r0, [r9, #2]
		IPH_CHKSUM_SET(iphdr, inet_chksum(iphdr, IP_HLEN));
    2f82:	2114      	movs	r1, #20
		IPH_CHKSUM_SET(iphdr, 0);
    2f84:	f889 800a 	strb.w	r8, [r9, #10]
    2f88:	f889 800b 	strb.w	r8, [r9, #11]
		IPH_CHKSUM_SET(iphdr, inet_chksum(iphdr, IP_HLEN));
    2f8c:	4648      	mov	r0, r9
    2f8e:	4798      	blx	r3
        netif->output(netif, rambuf, dest);
    2f90:	ee18 2a10 	vmov	r2, s16
    2f94:	f8da 3014 	ldr.w	r3, [sl, #20]
		IPH_CHKSUM_SET(iphdr, inet_chksum(iphdr, IP_HLEN));
    2f98:	f8a9 000a 	strh.w	r0, [r9, #10]
        netif->output(netif, rambuf, dest);
    2f9c:	4639      	mov	r1, r7
    2f9e:	4650      	mov	r0, sl
    2fa0:	4798      	blx	r3
        pbuf_free(rambuf);
    2fa2:	4b0a      	ldr	r3, [pc, #40]	; (2fcc <ip_frag+0x19c>)
    2fa4:	4638      	mov	r0, r7
    2fa6:	4798      	blx	r3
		left -= cop;
    2fa8:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
    2fac:	1ad5      	subs	r5, r2, r3
    2fae:	b2ab      	uxth	r3, r5
		ofo += nfb;
    2fb0:	9a07      	ldr	r2, [sp, #28]
		left -= cop;
    2fb2:	9302      	str	r3, [sp, #8]
		ofo += nfb;
    2fb4:	9b04      	ldr	r3, [sp, #16]
    2fb6:	4413      	add	r3, r2
    2fb8:	b29b      	uxth	r3, r3
    2fba:	9304      	str	r3, [sp, #16]
    2fbc:	4633      	mov	r3, r6
    2fbe:	e75e      	b.n	2e7e <ip_frag+0x4e>
    2fc0:	00000d67 	.word	0x00000d67
    2fc4:	00003139 	.word	0x00003139
    2fc8:	00004c05 	.word	0x00004c05
    2fcc:	000030e1 	.word	0x000030e1
    2fd0:	00003045 	.word	0x00003045
    2fd4:	00004c21 	.word	0x00004c21
    2fd8:	000032ad 	.word	0x000032ad
    2fdc:	00002af9 	.word	0x00002af9
    2fe0:	000032b7 	.word	0x000032b7
    2fe4:	00008419 	.word	0x00008419
    2fe8:	00000d61 	.word	0x00000d61

00002fec <pbuf_free_ooseq_callback>:
{
	struct tcp_pcb *pcb;
	SYS_ARCH_DECL_PROTECT(old_level);

	SYS_ARCH_PROTECT(old_level);
	pbuf_free_ooseq_pending = 0;
    2fec:	4b07      	ldr	r3, [pc, #28]	; (300c <pbuf_free_ooseq_callback+0x20>)
    2fee:	2200      	movs	r2, #0
#if !NO_SYS
/**
 * Just a callback function for tcpip_timeout() that calls pbuf_free_ooseq().
 */
static void pbuf_free_ooseq_callback(void *arg)
{
    2ff0:	b510      	push	{r4, lr}
	pbuf_free_ooseq_pending = 0;
    2ff2:	701a      	strb	r2, [r3, #0]
	for (pcb = tcp_active_pcbs; NULL != pcb; pcb = pcb->next) {
    2ff4:	4b06      	ldr	r3, [pc, #24]	; (3010 <pbuf_free_ooseq_callback+0x24>)
    2ff6:	681c      	ldr	r4, [r3, #0]
    2ff8:	b12c      	cbz	r4, 3006 <pbuf_free_ooseq_callback+0x1a>
		if (NULL != pcb->ooseq) {
    2ffa:	6f60      	ldr	r0, [r4, #116]	; 0x74
    2ffc:	b120      	cbz	r0, 3008 <pbuf_free_ooseq_callback+0x1c>
			tcp_segs_free(pcb->ooseq);
    2ffe:	4b05      	ldr	r3, [pc, #20]	; (3014 <pbuf_free_ooseq_callback+0x28>)
    3000:	4798      	blx	r3
			pcb->ooseq = NULL;
    3002:	2300      	movs	r3, #0
    3004:	6763      	str	r3, [r4, #116]	; 0x74
	LWIP_UNUSED_ARG(arg);
	pbuf_free_ooseq();
}
    3006:	bd10      	pop	{r4, pc}
	for (pcb = tcp_active_pcbs; NULL != pcb; pcb = pcb->next) {
    3008:	68e4      	ldr	r4, [r4, #12]
    300a:	e7f5      	b.n	2ff8 <pbuf_free_ooseq_callback+0xc>
    300c:	2000a4de 	.word	0x2000a4de
    3010:	20014950 	.word	0x20014950
    3014:	00006ae9 	.word	0x00006ae9

00003018 <pbuf_pool_is_empty>:
#endif /* !NO_SYS */

/** Queue a call to pbuf_free_ooseq if not already queued. */
static void pbuf_pool_is_empty(void)
{
    3018:	b538      	push	{r3, r4, r5, lr}
	SYS_ARCH_UNPROTECT(old_level);
#else  /* PBUF_POOL_FREE_OOSEQ_QUEUE_CALL */
	u8_t queued;
	SYS_ARCH_DECL_PROTECT(old_level);
	SYS_ARCH_PROTECT(old_level);
	queued                  = pbuf_free_ooseq_pending;
    301a:	4c07      	ldr	r4, [pc, #28]	; (3038 <pbuf_pool_is_empty+0x20>)
    301c:	7823      	ldrb	r3, [r4, #0]
	pbuf_free_ooseq_pending = 1;
    301e:	2201      	movs	r2, #1
    3020:	7022      	strb	r2, [r4, #0]
	SYS_ARCH_UNPROTECT(old_level);

	if (!queued) {
    3022:	f003 05ff 	and.w	r5, r3, #255	; 0xff
    3026:	b933      	cbnz	r3, 3036 <pbuf_pool_is_empty+0x1e>
		/* queue a call to pbuf_free_ooseq if not already queued */
		PBUF_POOL_FREE_OOSEQ_QUEUE_CALL();
    3028:	4804      	ldr	r0, [pc, #16]	; (303c <pbuf_pool_is_empty+0x24>)
    302a:	4b05      	ldr	r3, [pc, #20]	; (3040 <pbuf_pool_is_empty+0x28>)
    302c:	462a      	mov	r2, r5
    302e:	4629      	mov	r1, r5
    3030:	4798      	blx	r3
    3032:	b100      	cbz	r0, 3036 <pbuf_pool_is_empty+0x1e>
    3034:	7025      	strb	r5, [r4, #0]
	}
#endif /* PBUF_POOL_FREE_OOSEQ_QUEUE_CALL */
}
    3036:	bd38      	pop	{r3, r4, r5, pc}
    3038:	2000a4de 	.word	0x2000a4de
    303c:	00002fed 	.word	0x00002fed
    3040:	0000a1f1 	.word	0x0000a1f1

00003044 <pbuf_alloced_custom>:
 * @param payload_mem_len the size of the 'payload_mem' buffer, must be at least
 *        big enough to hold 'length' plus the header size
 */
struct pbuf *pbuf_alloced_custom(pbuf_layer l, u16_t length, pbuf_type type, struct pbuf_custom *p, void *payload_mem,
                                 u16_t payload_mem_len)
{
    3044:	b570      	push	{r4, r5, r6, lr}
    3046:	2803      	cmp	r0, #3
    3048:	9d04      	ldr	r5, [sp, #16]
    304a:	d818      	bhi.n	307e <pbuf_alloced_custom+0x3a>
	default:
		LWIP_ASSERT("pbuf_alloced_custom: bad pbuf layer", 0);
		return NULL;
	}

	if (LWIP_MEM_ALIGN_SIZE(offset) + length > payload_mem_len) {
    304c:	4c0d      	ldr	r4, [pc, #52]	; (3084 <pbuf_alloced_custom+0x40>)
    304e:	5c24      	ldrb	r4, [r4, r0]
    3050:	f8bd 0014 	ldrh.w	r0, [sp, #20]
    3054:	3403      	adds	r4, #3
    3056:	f024 0403 	bic.w	r4, r4, #3
    305a:	1866      	adds	r6, r4, r1
    305c:	4286      	cmp	r6, r0
    305e:	f04f 0000 	mov.w	r0, #0
    3062:	dc0b      	bgt.n	307c <pbuf_alloced_custom+0x38>
		LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_LEVEL_WARNING,
		            ("pbuf_alloced_custom(length=%" U16_F ") buffer too short\n", length));
		return NULL;
	}

	p->pbuf.next = NULL;
    3064:	6018      	str	r0, [r3, #0]
	if (payload_mem != NULL) {
    3066:	b105      	cbz	r5, 306a <pbuf_alloced_custom+0x26>
		p->pbuf.payload = (u8_t *)payload_mem + LWIP_MEM_ALIGN_SIZE(offset);
    3068:	4425      	add	r5, r4
	} else {
		p->pbuf.payload = NULL;
	}
	p->pbuf.flags = PBUF_FLAG_IS_CUSTOM;
    306a:	2002      	movs	r0, #2
	p->pbuf.len = p->pbuf.tot_len = length;
	p->pbuf.type                  = type;
    306c:	731a      	strb	r2, [r3, #12]
	p->pbuf.ref                   = 1;
    306e:	2201      	movs	r2, #1
	p->pbuf.flags = PBUF_FLAG_IS_CUSTOM;
    3070:	7358      	strb	r0, [r3, #13]
    3072:	605d      	str	r5, [r3, #4]
	p->pbuf.len = p->pbuf.tot_len = length;
    3074:	8119      	strh	r1, [r3, #8]
    3076:	8159      	strh	r1, [r3, #10]
	p->pbuf.ref                   = 1;
    3078:	81da      	strh	r2, [r3, #14]
	return &p->pbuf;
    307a:	4618      	mov	r0, r3
}
    307c:	bd70      	pop	{r4, r5, r6, pc}
		return NULL;
    307e:	2000      	movs	r0, #0
    3080:	e7fc      	b.n	307c <pbuf_alloced_custom+0x38>
    3082:	bf00      	nop
    3084:	0000c99b 	.word	0x0000c99b

00003088 <pbuf_header>:
 * not move the payload pointer in front of the start of the buffer.
 * @return non-zero on failure, zero on success.
 *
 */
u8_t pbuf_header(struct pbuf *p, s16_t header_size_increment)
{
    3088:	b530      	push	{r4, r5, lr}
	u16_t type;
	void *payload;
	u16_t increment_magnitude;

	LWIP_ASSERT("p != NULL", p != NULL);
	if ((header_size_increment == 0) || (p == NULL)) {
    308a:	b1d9      	cbz	r1, 30c4 <pbuf_header+0x3c>
    308c:	b1d8      	cbz	r0, 30c6 <pbuf_header+0x3e>
		return 0;
	}

	if (header_size_increment < 0) {
    308e:	2900      	cmp	r1, #0
		increment_magnitude = -header_size_increment;
    3090:	b28a      	uxth	r2, r1
	if (header_size_increment < 0) {
    3092:	da05      	bge.n	30a0 <pbuf_header+0x18>
		/* Check that we aren't going to move off the end of the pbuf */
		LWIP_ERROR("increment_magnitude <= p->len", (increment_magnitude <= p->len), return 1;);
    3094:	8943      	ldrh	r3, [r0, #10]
		increment_magnitude = -header_size_increment;
    3096:	4254      	negs	r4, r2
    3098:	b2a4      	uxth	r4, r4
		LWIP_ERROR("increment_magnitude <= p->len", (increment_magnitude <= p->len), return 1;);
    309a:	42a3      	cmp	r3, r4
    309c:	d201      	bcs.n	30a2 <pbuf_header+0x1a>
    309e:	e7fe      	b.n	309e <pbuf_header+0x16>
	} else {
		increment_magnitude = header_size_increment;
    30a0:	4614      	mov	r4, r2
    LWIP_ASSERT("p->payload - increment_magnitude >= p + SIZEOF_STRUCT_PBUF",
                (u8_t *)p->payload - increment_magnitude >= (u8_t *)p + SIZEOF_STRUCT_PBUF);
#endif
	}

	type = p->type;
    30a2:	7b05      	ldrb	r5, [r0, #12]
	/* remember current payload pointer */
	payload = p->payload;
    30a4:	6843      	ldr	r3, [r0, #4]

	/* pbuf types containing payloads? */
	if (type == PBUF_RAM || type == PBUF_POOL) {
    30a6:	b10d      	cbz	r5, 30ac <pbuf_header+0x24>
    30a8:	2d03      	cmp	r5, #3
    30aa:	d10d      	bne.n	30c8 <pbuf_header+0x40>
		/* set new payload pointer */
		p->payload = (u8_t *)p->payload - header_size_increment;
    30ac:	1a59      	subs	r1, r3, r1
		/* boundary check fails? */
		if ((u8_t *)p->payload < (u8_t *)p + SIZEOF_STRUCT_PBUF) {
    30ae:	f100 0310 	add.w	r3, r0, #16
    30b2:	4299      	cmp	r1, r3
    30b4:	d312      	bcc.n	30dc <pbuf_header+0x54>
		/* Unknown type */
		LWIP_ASSERT("bad pbuf type", 0);
		return 1;
	}
	/* modify pbuf length fields */
	p->len += header_size_increment;
    30b6:	8943      	ldrh	r3, [r0, #10]
			p->payload = (u8_t *)p->payload - header_size_increment;
    30b8:	6041      	str	r1, [r0, #4]
	p->len += header_size_increment;
    30ba:	4413      	add	r3, r2
    30bc:	8143      	strh	r3, [r0, #10]
	p->tot_len += header_size_increment;
    30be:	8903      	ldrh	r3, [r0, #8]
    30c0:	441a      	add	r2, r3
    30c2:	8102      	strh	r2, [r0, #8]

	LWIP_DEBUGF(
	    PBUF_DEBUG | LWIP_DBG_TRACE,
	    ("pbuf_header: old %p new %p (%" S16_F ")\n", (void *)payload, (void *)p->payload, header_size_increment));

	return 0;
    30c4:	2000      	movs	r0, #0
}
    30c6:	bd30      	pop	{r4, r5, pc}
	} else if (type == PBUF_REF || type == PBUF_ROM) {
    30c8:	3d01      	subs	r5, #1
    30ca:	2d01      	cmp	r5, #1
    30cc:	d806      	bhi.n	30dc <pbuf_header+0x54>
		if ((header_size_increment < 0) && (increment_magnitude <= p->len)) {
    30ce:	2900      	cmp	r1, #0
    30d0:	da04      	bge.n	30dc <pbuf_header+0x54>
    30d2:	8945      	ldrh	r5, [r0, #10]
    30d4:	42a5      	cmp	r5, r4
    30d6:	d301      	bcc.n	30dc <pbuf_header+0x54>
			p->payload = (u8_t *)p->payload - header_size_increment;
    30d8:	1a59      	subs	r1, r3, r1
    30da:	e7ec      	b.n	30b6 <pbuf_header+0x2e>
		return 1;
    30dc:	2001      	movs	r0, #1
    30de:	e7f2      	b.n	30c6 <pbuf_header+0x3e>

000030e0 <pbuf_free>:
 * 2->1->1 becomes 1->1->1
 * 1->1->1 becomes .......
 *
 */
u8_t pbuf_free(struct pbuf *p)
{
    30e0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	u16_t        type;
	struct pbuf *q;
	u8_t         count;

	if (p == NULL) {
    30e2:	b318      	cbz	r0, 312c <pbuf_free+0x4c>
					/* is this a ROM or RAM referencing pbuf? */
				} else if (type == PBUF_ROM || type == PBUF_REF) {
					memp_free(MEMP_PBUF, p);
					/* type == PBUF_RAM */
				} else {
					mem_free(p);
    30e4:	4e12      	ldr	r6, [pc, #72]	; (3130 <pbuf_free+0x50>)
					memp_free(MEMP_PBUF, p);
    30e6:	4d13      	ldr	r5, [pc, #76]	; (3134 <pbuf_free+0x54>)
	count = 0;
    30e8:	2400      	movs	r4, #0
		ref = --(p->ref);
    30ea:	89c3      	ldrh	r3, [r0, #14]
    30ec:	3b01      	subs	r3, #1
    30ee:	b29b      	uxth	r3, r3
    30f0:	81c3      	strh	r3, [r0, #14]
		if (ref == 0) {
    30f2:	b943      	cbnz	r3, 3106 <pbuf_free+0x26>
			if ((p->flags & PBUF_FLAG_IS_CUSTOM) != 0) {
    30f4:	7b43      	ldrb	r3, [r0, #13]
			q = p->next;
    30f6:	6807      	ldr	r7, [r0, #0]
			if ((p->flags & PBUF_FLAG_IS_CUSTOM) != 0) {
    30f8:	079b      	lsls	r3, r3, #30
    30fa:	d508      	bpl.n	310e <pbuf_free+0x2e>
				pc->custom_free_function(p);
    30fc:	6903      	ldr	r3, [r0, #16]
    30fe:	4798      	blx	r3
				}
			}
			count++;
    3100:	3401      	adds	r4, #1
    3102:	b2e4      	uxtb	r4, r4
	while (p != NULL) {
    3104:	b90f      	cbnz	r7, 310a <pbuf_free+0x2a>
		}
	}
	PERF_STOP("pbuf_free");
	/* return number of de-allocated pbufs */
	return count;
}
    3106:	4620      	mov	r0, r4
    3108:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    310a:	4638      	mov	r0, r7
    310c:	e7ed      	b.n	30ea <pbuf_free+0xa>
			type = p->type;
    310e:	7b03      	ldrb	r3, [r0, #12]
				if (type == PBUF_POOL) {
    3110:	2b03      	cmp	r3, #3
    3112:	d103      	bne.n	311c <pbuf_free+0x3c>
					memp_free(MEMP_PBUF_POOL, p);
    3114:	4601      	mov	r1, r0
    3116:	200c      	movs	r0, #12
					memp_free(MEMP_PBUF, p);
    3118:	47a8      	blx	r5
    311a:	e7f1      	b.n	3100 <pbuf_free+0x20>
				} else if (type == PBUF_ROM || type == PBUF_REF) {
    311c:	3b01      	subs	r3, #1
    311e:	2b01      	cmp	r3, #1
    3120:	d802      	bhi.n	3128 <pbuf_free+0x48>
					memp_free(MEMP_PBUF, p);
    3122:	4601      	mov	r1, r0
    3124:	200b      	movs	r0, #11
    3126:	e7f7      	b.n	3118 <pbuf_free+0x38>
					mem_free(p);
    3128:	47b0      	blx	r6
    312a:	e7e9      	b.n	3100 <pbuf_free+0x20>
		return 0;
    312c:	4604      	mov	r4, r0
    312e:	e7ea      	b.n	3106 <pbuf_free+0x26>
    3130:	0000667d 	.word	0x0000667d
    3134:	00004c21 	.word	0x00004c21

00003138 <pbuf_alloc>:
	switch (layer) {
    3138:	2803      	cmp	r0, #3
{
    313a:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    313e:	460e      	mov	r6, r1
    3140:	4617      	mov	r7, r2
    3142:	d901      	bls.n	3148 <pbuf_alloc+0x10>
	switch (type) {
    3144:	2400      	movs	r4, #0
    3146:	e01b      	b.n	3180 <pbuf_alloc+0x48>
    3148:	4b3a      	ldr	r3, [pc, #232]	; (3234 <pbuf_alloc+0xfc>)
    314a:	2a02      	cmp	r2, #2
    314c:	5c1d      	ldrb	r5, [r3, r0]
    314e:	d80d      	bhi.n	316c <pbuf_alloc+0x34>
    3150:	2a00      	cmp	r2, #0
    3152:	d056      	beq.n	3202 <pbuf_alloc+0xca>
		p = (struct pbuf *)memp_malloc(MEMP_PBUF);
    3154:	4b38      	ldr	r3, [pc, #224]	; (3238 <pbuf_alloc+0x100>)
    3156:	200b      	movs	r0, #11
    3158:	4798      	blx	r3
		if (p == NULL) {
    315a:	4604      	mov	r4, r0
    315c:	2800      	cmp	r0, #0
    315e:	d0f1      	beq.n	3144 <pbuf_alloc+0xc>
		p->payload = NULL;
    3160:	2300      	movs	r3, #0
    3162:	6043      	str	r3, [r0, #4]
		p->len = p->tot_len = length;
    3164:	8106      	strh	r6, [r0, #8]
    3166:	8146      	strh	r6, [r0, #10]
		p->next             = NULL;
    3168:	6003      	str	r3, [r0, #0]
    316a:	e060      	b.n	322e <pbuf_alloc+0xf6>
	switch (type) {
    316c:	2a03      	cmp	r2, #3
    316e:	d1e9      	bne.n	3144 <pbuf_alloc+0xc>
		p = (struct pbuf *)memp_malloc(MEMP_PBUF_POOL);
    3170:	f8df 80c4 	ldr.w	r8, [pc, #196]	; 3238 <pbuf_alloc+0x100>
    3174:	200c      	movs	r0, #12
    3176:	47c0      	blx	r8
		if (p == NULL) {
    3178:	4604      	mov	r4, r0
    317a:	b920      	cbnz	r0, 3186 <pbuf_alloc+0x4e>
			PBUF_POOL_IS_EMPTY();
    317c:	4b2f      	ldr	r3, [pc, #188]	; (323c <pbuf_alloc+0x104>)
    317e:	4798      	blx	r3
}
    3180:	4620      	mov	r0, r4
    3182:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
		p->payload = LWIP_MEM_ALIGN((void *)((u8_t *)p + (SIZEOF_STRUCT_PBUF + offset)));
    3186:	1943      	adds	r3, r0, r5
    3188:	3313      	adds	r3, #19
    318a:	f023 0303 	bic.w	r3, r3, #3
		p->len = LWIP_MIN(length, PBUF_POOL_BUFSIZE_ALIGNED - LWIP_MEM_ALIGN_SIZE(offset));
    318e:	3503      	adds	r5, #3
		p->payload = LWIP_MEM_ALIGN((void *)((u8_t *)p + (SIZEOF_STRUCT_PBUF + offset)));
    3190:	6043      	str	r3, [r0, #4]
		p->len = LWIP_MIN(length, PBUF_POOL_BUFSIZE_ALIGNED - LWIP_MEM_ALIGN_SIZE(offset));
    3192:	f025 0303 	bic.w	r3, r5, #3
    3196:	f5c3 65bd 	rsb	r5, r3, #1512	; 0x5e8
    319a:	3504      	adds	r5, #4
    319c:	42b5      	cmp	r5, r6
    319e:	bfa8      	it	ge
    31a0:	4635      	movge	r5, r6
		p->next = NULL;
    31a2:	f04f 0900 	mov.w	r9, #0
		p->ref = 1;
    31a6:	2301      	movs	r3, #1
		p->len = LWIP_MIN(length, PBUF_POOL_BUFSIZE_ALIGNED - LWIP_MEM_ALIGN_SIZE(offset));
    31a8:	8145      	strh	r5, [r0, #10]
		p->type = type;
    31aa:	7307      	strb	r7, [r0, #12]
		p->next = NULL;
    31ac:	f8c0 9000 	str.w	r9, [r0]
		p->tot_len = length;
    31b0:	8106      	strh	r6, [r0, #8]
		p->ref = 1;
    31b2:	81c3      	strh	r3, [r0, #14]
		rem_len = length - p->len;
    31b4:	1b75      	subs	r5, r6, r5
		while (rem_len > 0) {
    31b6:	4682      	mov	sl, r0
    31b8:	2d00      	cmp	r5, #0
    31ba:	dc04      	bgt.n	31c6 <pbuf_alloc+0x8e>
	p->ref = 1;
    31bc:	2301      	movs	r3, #1
    31be:	81e3      	strh	r3, [r4, #14]
	p->flags = 0;
    31c0:	2300      	movs	r3, #0
    31c2:	7363      	strb	r3, [r4, #13]
	return p;
    31c4:	e7dc      	b.n	3180 <pbuf_alloc+0x48>
			q = (struct pbuf *)memp_malloc(MEMP_PBUF_POOL);
    31c6:	200c      	movs	r0, #12
    31c8:	47c0      	blx	r8
			if (q == NULL) {
    31ca:	b928      	cbnz	r0, 31d8 <pbuf_alloc+0xa0>
				PBUF_POOL_IS_EMPTY();
    31cc:	4b1b      	ldr	r3, [pc, #108]	; (323c <pbuf_alloc+0x104>)
    31ce:	4798      	blx	r3
				pbuf_free(p);
    31d0:	4b1b      	ldr	r3, [pc, #108]	; (3240 <pbuf_alloc+0x108>)
    31d2:	4620      	mov	r0, r4
    31d4:	4798      	blx	r3
				return NULL;
    31d6:	e7b5      	b.n	3144 <pbuf_alloc+0xc>
			q->tot_len = (u16_t)rem_len;
    31d8:	b2ab      	uxth	r3, r5
			q->len     = LWIP_MIN((u16_t)rem_len, PBUF_POOL_BUFSIZE_ALIGNED);
    31da:	f240 52ec 	movw	r2, #1516	; 0x5ec
    31de:	4293      	cmp	r3, r2
			q->type  = type;
    31e0:	8187      	strh	r7, [r0, #12]
			q->next  = NULL;
    31e2:	f8c0 9000 	str.w	r9, [r0]
			r->next = q;
    31e6:	f8ca 0000 	str.w	r0, [sl]
			q->tot_len = (u16_t)rem_len;
    31ea:	8103      	strh	r3, [r0, #8]
			q->len     = LWIP_MIN((u16_t)rem_len, PBUF_POOL_BUFSIZE_ALIGNED);
    31ec:	bf28      	it	cs
    31ee:	4613      	movcs	r3, r2
			q->payload = (void *)((u8_t *)q + SIZEOF_STRUCT_PBUF);
    31f0:	f100 0210 	add.w	r2, r0, #16
    31f4:	6042      	str	r2, [r0, #4]
			q->ref = 1;
    31f6:	2201      	movs	r2, #1
			q->len     = LWIP_MIN((u16_t)rem_len, PBUF_POOL_BUFSIZE_ALIGNED);
    31f8:	8143      	strh	r3, [r0, #10]
			q->ref = 1;
    31fa:	81c2      	strh	r2, [r0, #14]
			rem_len -= q->len;
    31fc:	1aed      	subs	r5, r5, r3
    31fe:	4682      	mov	sl, r0
    3200:	e7da      	b.n	31b8 <pbuf_alloc+0x80>
		p = (struct pbuf *)mem_malloc(LWIP_MEM_ALIGN_SIZE(SIZEOF_STRUCT_PBUF + offset) + LWIP_MEM_ALIGN_SIZE(length));
    3202:	1ccb      	adds	r3, r1, #3
    3204:	f105 0013 	add.w	r0, r5, #19
    3208:	f023 0303 	bic.w	r3, r3, #3
    320c:	f020 0003 	bic.w	r0, r0, #3
    3210:	4418      	add	r0, r3
    3212:	b280      	uxth	r0, r0
    3214:	4b0b      	ldr	r3, [pc, #44]	; (3244 <pbuf_alloc+0x10c>)
    3216:	4798      	blx	r3
		if (p == NULL) {
    3218:	4604      	mov	r4, r0
    321a:	2800      	cmp	r0, #0
    321c:	d092      	beq.n	3144 <pbuf_alloc+0xc>
		p->payload = LWIP_MEM_ALIGN((void *)((u8_t *)p + SIZEOF_STRUCT_PBUF + offset));
    321e:	1943      	adds	r3, r0, r5
    3220:	3313      	adds	r3, #19
    3222:	f023 0303 	bic.w	r3, r3, #3
    3226:	6043      	str	r3, [r0, #4]
		p->len = p->tot_len = length;
    3228:	8106      	strh	r6, [r0, #8]
    322a:	8146      	strh	r6, [r0, #10]
		p->next             = NULL;
    322c:	6007      	str	r7, [r0, #0]
		p->type             = type;
    322e:	7327      	strb	r7, [r4, #12]
		break;
    3230:	e7c4      	b.n	31bc <pbuf_alloc+0x84>
    3232:	bf00      	nop
    3234:	0000c99b 	.word	0x0000c99b
    3238:	00004c05 	.word	0x00004c05
    323c:	00003019 	.word	0x00003019
    3240:	000030e1 	.word	0x000030e1
    3244:	00006809 	.word	0x00006809

00003248 <pbuf_realloc>:
{
    3248:	b538      	push	{r3, r4, r5, lr}
	if (new_len >= p->tot_len) {
    324a:	8903      	ldrh	r3, [r0, #8]
    324c:	428b      	cmp	r3, r1
{
    324e:	4604      	mov	r4, r0
	if (new_len >= p->tot_len) {
    3250:	d918      	bls.n	3284 <pbuf_realloc+0x3c>
    3252:	460d      	mov	r5, r1
		q->tot_len += (u16_t)grow;
    3254:	1aca      	subs	r2, r1, r3
	while (rem_len > q->len) {
    3256:	8963      	ldrh	r3, [r4, #10]
    3258:	42ab      	cmp	r3, r5
    325a:	d314      	bcc.n	3286 <pbuf_realloc+0x3e>
	if ((q->type == PBUF_RAM) && (rem_len != q->len)) {
    325c:	7b22      	ldrb	r2, [r4, #12]
    325e:	b94a      	cbnz	r2, 3274 <pbuf_realloc+0x2c>
    3260:	42ab      	cmp	r3, r5
    3262:	d007      	beq.n	3274 <pbuf_realloc+0x2c>
		q = (struct pbuf *)mem_trim(q, (u16_t)((u8_t *)q->payload - (u8_t *)q) + rem_len);
    3264:	6861      	ldr	r1, [r4, #4]
    3266:	4b0b      	ldr	r3, [pc, #44]	; (3294 <pbuf_realloc+0x4c>)
    3268:	1b09      	subs	r1, r1, r4
    326a:	4429      	add	r1, r5
    326c:	4620      	mov	r0, r4
    326e:	b289      	uxth	r1, r1
    3270:	4798      	blx	r3
    3272:	4604      	mov	r4, r0
	if (q->next != NULL) {
    3274:	6820      	ldr	r0, [r4, #0]
	q->len     = rem_len;
    3276:	8165      	strh	r5, [r4, #10]
	q->tot_len = q->len;
    3278:	8125      	strh	r5, [r4, #8]
	if (q->next != NULL) {
    327a:	b108      	cbz	r0, 3280 <pbuf_realloc+0x38>
		pbuf_free(q->next);
    327c:	4b06      	ldr	r3, [pc, #24]	; (3298 <pbuf_realloc+0x50>)
    327e:	4798      	blx	r3
	q->next = NULL;
    3280:	2300      	movs	r3, #0
    3282:	6023      	str	r3, [r4, #0]
}
    3284:	bd38      	pop	{r3, r4, r5, pc}
		rem_len -= q->len;
    3286:	1aed      	subs	r5, r5, r3
		q->tot_len += (u16_t)grow;
    3288:	8923      	ldrh	r3, [r4, #8]
    328a:	4413      	add	r3, r2
    328c:	8123      	strh	r3, [r4, #8]
		rem_len -= q->len;
    328e:	b2ad      	uxth	r5, r5
		q = q->next;
    3290:	6824      	ldr	r4, [r4, #0]
    3292:	e7e0      	b.n	3256 <pbuf_realloc+0xe>
    3294:	0000671d 	.word	0x0000671d
    3298:	000030e1 	.word	0x000030e1

0000329c <pbuf_clen>:
 * @param p first pbuf of chain
 * @return the number of pbufs in a chain
 */

u8_t pbuf_clen(struct pbuf *p)
{
    329c:	4603      	mov	r3, r0
	u8_t len;

	len = 0;
	while (p != NULL) {
    329e:	2200      	movs	r2, #0
    32a0:	b2d0      	uxtb	r0, r2
    32a2:	3201      	adds	r2, #1
    32a4:	b903      	cbnz	r3, 32a8 <pbuf_clen+0xc>
		++len;
		p = p->next;
	}
	return len;
}
    32a6:	4770      	bx	lr
		p = p->next;
    32a8:	681b      	ldr	r3, [r3, #0]
    32aa:	e7f9      	b.n	32a0 <pbuf_clen+0x4>

000032ac <pbuf_ref>:
 */
void pbuf_ref(struct pbuf *p)
{
	SYS_ARCH_DECL_PROTECT(old_level);
	/* pbuf given? */
	if (p != NULL) {
    32ac:	b110      	cbz	r0, 32b4 <pbuf_ref+0x8>
		SYS_ARCH_PROTECT(old_level);
		++(p->ref);
    32ae:	89c3      	ldrh	r3, [r0, #14]
    32b0:	3301      	adds	r3, #1
    32b2:	81c3      	strh	r3, [r0, #14]
		SYS_ARCH_UNPROTECT(old_level);
	}
}
    32b4:	4770      	bx	lr

000032b6 <pbuf_cat>:
 *
 * @see pbuf_chain()
 */

void pbuf_cat(struct pbuf *h, struct pbuf *t)
{
    32b6:	b510      	push	{r4, lr}
	struct pbuf *p;

	LWIP_ERROR("(h != NULL) && (t != NULL) (programmer violates API)", ((h != NULL) && (t != NULL)), return;);
    32b8:	b100      	cbz	r0, 32bc <pbuf_cat+0x6>
    32ba:	b909      	cbnz	r1, 32c0 <pbuf_cat+0xa>
    32bc:	e7fe      	b.n	32bc <pbuf_cat+0x6>

	/* proceed to last pbuf of chain */
	for (p = h; p->next != NULL; p = p->next) {
		/* add total length of second chain to all totals of first chain */
		p->tot_len += t->tot_len;
    32be:	4610      	mov	r0, r2
    32c0:	890b      	ldrh	r3, [r1, #8]
    32c2:	8904      	ldrh	r4, [r0, #8]
	for (p = h; p->next != NULL; p = p->next) {
    32c4:	6802      	ldr	r2, [r0, #0]
		p->tot_len += t->tot_len;
    32c6:	4423      	add	r3, r4
    32c8:	b29b      	uxth	r3, r3
    32ca:	8103      	strh	r3, [r0, #8]
	for (p = h; p->next != NULL; p = p->next) {
    32cc:	2a00      	cmp	r2, #0
    32ce:	d1f6      	bne.n	32be <pbuf_cat+0x8>
	LWIP_ASSERT("p->tot_len == p->len (of last pbuf in chain)", p->tot_len == p->len);
	LWIP_ASSERT("p->next == NULL", p->next == NULL);
	/* add total length of second chain to last pbuf total of first chain */
	p->tot_len += t->tot_len;
	/* chain last pbuf of head (p) with first of tail (t) */
	p->next = t;
    32d0:	6001      	str	r1, [r0, #0]
	/* p->next now references t, but the caller will drop its reference to t,
	 * so netto there is no change to the reference count of t.
	 */
}
    32d2:	bd10      	pop	{r4, pc}

000032d4 <pbuf_chain>:
 * The ->next field of the last pbuf of the head chain is adjusted.
 * The ->ref field of the first pbuf of the tail chain is adjusted.
 *
 */
void pbuf_chain(struct pbuf *h, struct pbuf *t)
{
    32d4:	b510      	push	{r4, lr}
	pbuf_cat(h, t);
    32d6:	4b03      	ldr	r3, [pc, #12]	; (32e4 <pbuf_chain+0x10>)
    32d8:	4798      	blx	r3
	/* t is now referenced by h */
	pbuf_ref(t);
	LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_chain: %p references %p\n", (void *)h, (void *)t));
}
    32da:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	pbuf_ref(t);
    32de:	4b02      	ldr	r3, [pc, #8]	; (32e8 <pbuf_chain+0x14>)
    32e0:	4608      	mov	r0, r1
    32e2:	4718      	bx	r3
    32e4:	000032b7 	.word	0x000032b7
    32e8:	000032ad 	.word	0x000032ad

000032ec <pbuf_copy>:
 * @return ERR_OK if pbuf was copied
 *         ERR_ARG if one of the pbufs is NULL or p_to is not big
 *                 enough to hold p_from
 */
err_t pbuf_copy(struct pbuf *p_to, struct pbuf *p_from)
{
    32ec:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    32f0:	460c      	mov	r4, r1
	u16_t offset_to = 0, offset_from = 0, len;

	LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_copy(%p, %p)\n", (void *)p_to, (void *)p_from));

	/* is the target big enough to hold the source? */
	LWIP_ERROR("pbuf_copy: target not big enough to hold source",
    32f2:	4605      	mov	r5, r0
    32f4:	b120      	cbz	r0, 3300 <pbuf_copy+0x14>
    32f6:	b119      	cbz	r1, 3300 <pbuf_copy+0x14>
    32f8:	8902      	ldrh	r2, [r0, #8]
    32fa:	890b      	ldrh	r3, [r1, #8]
    32fc:	429a      	cmp	r2, r3
    32fe:	d200      	bcs.n	3302 <pbuf_copy+0x16>
    3300:	e7fe      	b.n	3300 <pbuf_copy+0x14>
	u16_t offset_to = 0, offset_from = 0, len;
    3302:	f04f 0800 	mov.w	r8, #0
			len = p_from->len - offset_from;
		} else {
			/* current p_from does not fit into current p_to */
			len = p_to->len - offset_to;
		}
		MEMCPY((u8_t *)p_to->payload + offset_to, (u8_t *)p_from->payload + offset_from, len);
    3306:	f8df 9074 	ldr.w	r9, [pc, #116]	; 337c <pbuf_copy+0x90>
	u16_t offset_to = 0, offset_from = 0, len;
    330a:	4647      	mov	r7, r8
		if ((p_to->len - offset_to) >= (p_from->len - offset_from)) {
    330c:	8962      	ldrh	r2, [r4, #10]
    330e:	896e      	ldrh	r6, [r5, #10]
		MEMCPY((u8_t *)p_to->payload + offset_to, (u8_t *)p_from->payload + offset_from, len);
    3310:	6861      	ldr	r1, [r4, #4]
    3312:	6868      	ldr	r0, [r5, #4]
		if ((p_to->len - offset_to) >= (p_from->len - offset_from)) {
    3314:	1bf6      	subs	r6, r6, r7
    3316:	eba2 0208 	sub.w	r2, r2, r8
    331a:	4296      	cmp	r6, r2
			len = p_from->len - offset_from;
    331c:	bfac      	ite	ge
    331e:	b296      	uxthge	r6, r2
			len = p_to->len - offset_to;
    3320:	b2b6      	uxthlt	r6, r6
		MEMCPY((u8_t *)p_to->payload + offset_to, (u8_t *)p_from->payload + offset_from, len);
    3322:	4632      	mov	r2, r6
    3324:	4441      	add	r1, r8
    3326:	4438      	add	r0, r7
    3328:	47c8      	blx	r9
		offset_to += len;
    332a:	4437      	add	r7, r6
		offset_from += len;
		LWIP_ASSERT("offset_to <= p_to->len", offset_to <= p_to->len);
		LWIP_ASSERT("offset_from <= p_from->len", offset_from <= p_from->len);
		if (offset_from >= p_from->len) {
    332c:	8963      	ldrh	r3, [r4, #10]
		offset_from += len;
    332e:	4446      	add	r6, r8
    3330:	fa1f f886 	uxth.w	r8, r6
		if (offset_from >= p_from->len) {
    3334:	4543      	cmp	r3, r8
			/* on to next p_from (if any) */
			offset_from = 0;
			p_from      = p_from->next;
		}
		if (offset_to == p_to->len) {
    3336:	896b      	ldrh	r3, [r5, #10]
			p_from      = p_from->next;
    3338:	bf98      	it	ls
    333a:	6824      	ldrls	r4, [r4, #0]
		offset_to += len;
    333c:	b2bf      	uxth	r7, r7
			offset_from = 0;
    333e:	bf98      	it	ls
    3340:	f04f 0800 	movls.w	r8, #0
		if (offset_to == p_to->len) {
    3344:	42bb      	cmp	r3, r7
    3346:	d104      	bne.n	3352 <pbuf_copy+0x66>
			/* on to next p_to (if any) */
			offset_to = 0;
			p_to      = p_to->next;
    3348:	682d      	ldr	r5, [r5, #0]
			LWIP_ERROR("p_to != NULL", (p_to != NULL) || (p_from == NULL), return ERR_ARG;);
    334a:	b90d      	cbnz	r5, 3350 <pbuf_copy+0x64>
    334c:	b194      	cbz	r4, 3374 <pbuf_copy+0x88>
    334e:	e7fe      	b.n	334e <pbuf_copy+0x62>
			offset_to = 0;
    3350:	2700      	movs	r7, #0
		}

		if ((p_from != NULL) && (p_from->len == p_from->tot_len)) {
    3352:	b134      	cbz	r4, 3362 <pbuf_copy+0x76>
    3354:	8962      	ldrh	r2, [r4, #10]
    3356:	8923      	ldrh	r3, [r4, #8]
    3358:	429a      	cmp	r2, r3
    335a:	d102      	bne.n	3362 <pbuf_copy+0x76>
			/* don't copy more than one packet! */
			LWIP_ERROR("pbuf_copy() does not allow packet queues!\n", (p_from->next == NULL), return ERR_VAL;);
    335c:	6823      	ldr	r3, [r4, #0]
    335e:	b103      	cbz	r3, 3362 <pbuf_copy+0x76>
    3360:	e7fe      	b.n	3360 <pbuf_copy+0x74>
		}
		if ((p_to != NULL) && (p_to->len == p_to->tot_len)) {
    3362:	896a      	ldrh	r2, [r5, #10]
    3364:	892b      	ldrh	r3, [r5, #8]
    3366:	429a      	cmp	r2, r3
    3368:	d102      	bne.n	3370 <pbuf_copy+0x84>
			/* don't copy more than one packet! */
			LWIP_ERROR("pbuf_copy() does not allow packet queues!\n", (p_to->next == NULL), return ERR_VAL;);
    336a:	682b      	ldr	r3, [r5, #0]
    336c:	b103      	cbz	r3, 3370 <pbuf_copy+0x84>
    336e:	e7fe      	b.n	336e <pbuf_copy+0x82>
		}
	} while (p_from);
    3370:	2c00      	cmp	r4, #0
    3372:	d1cb      	bne.n	330c <pbuf_copy+0x20>
	LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_copy: end of chain reached.\n"));
	return ERR_OK;
}
    3374:	2000      	movs	r0, #0
    3376:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    337a:	bf00      	nop
    337c:	0000c07d 	.word	0x0000c07d

00003380 <pbuf_copy_partial>:
 * than buf->tot_len will be copied, irrespective of len
 * @param offset offset into the packet buffer from where to begin copying len bytes
 * @return the number of bytes copied, or 0 on failure
 */
u16_t pbuf_copy_partial(struct pbuf *buf, void *dataptr, u16_t len, u16_t offset)
{
    3380:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    3384:	4688      	mov	r8, r1
    3386:	4617      	mov	r7, r2
	struct pbuf *p;
	u16_t        left;
	u16_t        buf_copy_len;
	u16_t        copied_total = 0;

	LWIP_ERROR("pbuf_copy_partial: invalid buf", (buf != NULL), return 0;);
    3388:	4605      	mov	r5, r0
    338a:	b900      	cbnz	r0, 338e <pbuf_copy_partial+0xe>
    338c:	e7fe      	b.n	338c <pbuf_copy_partial+0xc>
	LWIP_ERROR("pbuf_copy_partial: invalid dataptr", (dataptr != NULL), return 0;);
    338e:	b9f1      	cbnz	r1, 33ce <pbuf_copy_partial+0x4e>
    3390:	e7fe      	b.n	3390 <pbuf_copy_partial+0x10>
		return 0;
	}

	/* Note some systems use byte copy if dataptr or one of the pbuf payload pointers are unaligned. */
	for (p = buf; len != 0 && p != NULL; p = p->next) {
		if ((offset != 0) && (offset >= p->len)) {
    3392:	896c      	ldrh	r4, [r5, #10]
    3394:	b153      	cbz	r3, 33ac <pbuf_copy_partial+0x2c>
    3396:	42a3      	cmp	r3, r4
    3398:	d308      	bcc.n	33ac <pbuf_copy_partial+0x2c>
			/* don't copy from this buffer -> on to the next */
			offset -= p->len;
    339a:	1b1b      	subs	r3, r3, r4
    339c:	b29b      	uxth	r3, r3
	for (p = buf; len != 0 && p != NULL; p = p->next) {
    339e:	682d      	ldr	r5, [r5, #0]
    33a0:	b10f      	cbz	r7, 33a6 <pbuf_copy_partial+0x26>
    33a2:	2d00      	cmp	r5, #0
    33a4:	d1f5      	bne.n	3392 <pbuf_copy_partial+0x12>
			len -= buf_copy_len;
			offset = 0;
		}
	}
	return copied_total;
}
    33a6:	4630      	mov	r0, r6
    33a8:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
			buf_copy_len = p->len - offset;
    33ac:	1ae4      	subs	r4, r4, r3
    33ae:	b2a4      	uxth	r4, r4
			if (buf_copy_len > len)
    33b0:	42bc      	cmp	r4, r7
			MEMCPY(&((char *)dataptr)[left], &((char *)p->payload)[offset], buf_copy_len);
    33b2:	6869      	ldr	r1, [r5, #4]
    33b4:	bf28      	it	cs
    33b6:	463c      	movcs	r4, r7
    33b8:	4419      	add	r1, r3
    33ba:	eb08 0006 	add.w	r0, r8, r6
    33be:	4622      	mov	r2, r4
			copied_total += buf_copy_len;
    33c0:	4426      	add	r6, r4
			len -= buf_copy_len;
    33c2:	1b3f      	subs	r7, r7, r4
			MEMCPY(&((char *)dataptr)[left], &((char *)p->payload)[offset], buf_copy_len);
    33c4:	47c8      	blx	r9
			copied_total += buf_copy_len;
    33c6:	b2b6      	uxth	r6, r6
			len -= buf_copy_len;
    33c8:	b2bf      	uxth	r7, r7
			offset = 0;
    33ca:	2300      	movs	r3, #0
    33cc:	e7e7      	b.n	339e <pbuf_copy_partial+0x1e>
			MEMCPY(&((char *)dataptr)[left], &((char *)p->payload)[offset], buf_copy_len);
    33ce:	f8df 9008 	ldr.w	r9, [pc, #8]	; 33d8 <pbuf_copy_partial+0x58>
	left = 0;
    33d2:	2600      	movs	r6, #0
    33d4:	e7e4      	b.n	33a0 <pbuf_copy_partial+0x20>
    33d6:	bf00      	nop
    33d8:	0000c07d 	.word	0x0000c07d

000033dc <tcp_parseopt>:
 * Currently, only the MSS option is supported!
 *
 * @param pcb the tcp_pcb for which a segment arrived
 */
static void tcp_parseopt(struct tcp_pcb *pcb)
{
    33dc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	u8_t *opts, opt;
#if LWIP_TCP_TIMESTAMPS
	u32_t tsval;
#endif

	opts = (u8_t *)tcphdr + TCP_HLEN;
    33de:	4f1f      	ldr	r7, [pc, #124]	; (345c <tcp_parseopt+0x80>)

	/* Parse the TCP MSS option, if present. */
	if (TCPH_HDRLEN(tcphdr) > 0x5) {
    33e0:	4e1f      	ldr	r6, [pc, #124]	; (3460 <tcp_parseopt+0x84>)
	opts = (u8_t *)tcphdr + TCP_HLEN;
    33e2:	683c      	ldr	r4, [r7, #0]
{
    33e4:	4605      	mov	r5, r0
	if (TCPH_HDRLEN(tcphdr) > 0x5) {
    33e6:	89a0      	ldrh	r0, [r4, #12]
    33e8:	47b0      	blx	r6
    33ea:	f3c0 300f 	ubfx	r0, r0, #12, #16
    33ee:	2805      	cmp	r0, #5
    33f0:	d914      	bls.n	341c <tcp_parseopt+0x40>
		max_c = (TCPH_HDRLEN(tcphdr) - 5) << 2;
    33f2:	683b      	ldr	r3, [r7, #0]
    33f4:	8998      	ldrh	r0, [r3, #12]
    33f6:	47b0      	blx	r6
    33f8:	0b02      	lsrs	r2, r0, #12
    33fa:	3a05      	subs	r2, #5
    33fc:	0092      	lsls	r2, r2, #2
	opts = (u8_t *)tcphdr + TCP_HLEN;
    33fe:	3414      	adds	r4, #20
		max_c = (TCPH_HDRLEN(tcphdr) - 5) << 2;
    3400:	b292      	uxth	r2, r2
		for (c = 0; c < max_c;) {
    3402:	2300      	movs	r3, #0
					return;
				}
				/* An MSS option with the right option length. */
				mss = (opts[c + 2] << 8) | opts[c + 3];
				/* Limit the mss to the configured TCP_MSS and prevent division by zero */
				pcb->mss = ((mss > TCP_MSS) || (mss == 0)) ? TCP_MSS : mss;
    3404:	f240 56b3 	movw	r6, #1459	; 0x5b3
    3408:	f240 57b4 	movw	r7, #1460	; 0x5b4
		for (c = 0; c < max_c;) {
    340c:	4293      	cmp	r3, r2
    340e:	d205      	bcs.n	341c <tcp_parseopt+0x40>
			opt = opts[c];
    3410:	5ce1      	ldrb	r1, [r4, r3]
			switch (opt) {
    3412:	2901      	cmp	r1, #1
    3414:	d003      	beq.n	341e <tcp_parseopt+0x42>
    3416:	2902      	cmp	r1, #2
    3418:	d004      	beq.n	3424 <tcp_parseopt+0x48>
    341a:	b9c1      	cbnz	r1, 344e <tcp_parseopt+0x72>
				   can skip past them. */
				c += opts[c + 1];
			}
		}
	}
}
    341c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
				++c;
    341e:	3301      	adds	r3, #1
				c += opts[c + 1];
    3420:	b29b      	uxth	r3, r3
    3422:	e7f3      	b.n	340c <tcp_parseopt+0x30>
				if (opts[c + 1] != 0x04 || c + 0x04 > max_c) {
    3424:	18e0      	adds	r0, r4, r3
    3426:	7841      	ldrb	r1, [r0, #1]
    3428:	2904      	cmp	r1, #4
    342a:	d1f7      	bne.n	341c <tcp_parseopt+0x40>
    342c:	1cd9      	adds	r1, r3, #3
    342e:	b289      	uxth	r1, r1
    3430:	428a      	cmp	r2, r1
    3432:	d9f3      	bls.n	341c <tcp_parseopt+0x40>
				mss = (opts[c + 2] << 8) | opts[c + 3];
    3434:	f890 c002 	ldrb.w	ip, [r0, #2]
    3438:	78c1      	ldrb	r1, [r0, #3]
    343a:	ea41 210c 	orr.w	r1, r1, ip, lsl #8
				pcb->mss = ((mss > TCP_MSS) || (mss == 0)) ? TCP_MSS : mss;
    343e:	1e48      	subs	r0, r1, #1
    3440:	b280      	uxth	r0, r0
    3442:	42b0      	cmp	r0, r6
    3444:	bf88      	it	hi
    3446:	4639      	movhi	r1, r7
    3448:	86e9      	strh	r1, [r5, #54]	; 0x36
				c += 0x04;
    344a:	3304      	adds	r3, #4
    344c:	e7e8      	b.n	3420 <tcp_parseopt+0x44>
				if (opts[c + 1] == 0) {
    344e:	18e1      	adds	r1, r4, r3
    3450:	7849      	ldrb	r1, [r1, #1]
    3452:	2900      	cmp	r1, #0
    3454:	d0e2      	beq.n	341c <tcp_parseopt+0x40>
				c += opts[c + 1];
    3456:	440b      	add	r3, r1
    3458:	e7e2      	b.n	3420 <tcp_parseopt+0x44>
    345a:	bf00      	nop
    345c:	2000a4e0 	.word	0x2000a4e0
    3460:	00000d67 	.word	0x00000d67

00003464 <tcp_oos_insert_segment>:
{
    3464:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	if (TCPH_FLAGS(cseg->tcphdr) & TCP_FIN) {
    3468:	68c3      	ldr	r3, [r0, #12]
    346a:	4e20      	ldr	r6, [pc, #128]	; (34ec <tcp_oos_insert_segment+0x88>)
{
    346c:	4605      	mov	r5, r0
	if (TCPH_FLAGS(cseg->tcphdr) & TCP_FIN) {
    346e:	8998      	ldrh	r0, [r3, #12]
{
    3470:	460c      	mov	r4, r1
	if (TCPH_FLAGS(cseg->tcphdr) & TCP_FIN) {
    3472:	47b0      	blx	r6
    3474:	07c2      	lsls	r2, r0, #31
    3476:	d41a      	bmi.n	34ae <tcp_oos_insert_segment+0x4a>
		while (next && TCP_SEQ_GEQ((seqno + cseg->len), (next->tcphdr->seqno + next->len))) {
    3478:	4f1d      	ldr	r7, [pc, #116]	; (34f0 <tcp_oos_insert_segment+0x8c>)
				TCPH_SET_FLAG(cseg->tcphdr, TCP_FIN);
    347a:	f8df 8080 	ldr.w	r8, [pc, #128]	; 34fc <tcp_oos_insert_segment+0x98>
			tcp_seg_free(old_seg);
    347e:	f8df 9080 	ldr.w	r9, [pc, #128]	; 3500 <tcp_oos_insert_segment+0x9c>
		while (next && TCP_SEQ_GEQ((seqno + cseg->len), (next->tcphdr->seqno + next->len))) {
    3482:	f8d4 c00c 	ldr.w	ip, [r4, #12]
    3486:	6878      	ldr	r0, [r7, #4]
    3488:	892b      	ldrh	r3, [r5, #8]
    348a:	f8dc 1004 	ldr.w	r1, [ip, #4]
    348e:	8922      	ldrh	r2, [r4, #8]
    3490:	4403      	add	r3, r0
    3492:	440a      	add	r2, r1
    3494:	1a9a      	subs	r2, r3, r2
    3496:	2a00      	cmp	r2, #0
    3498:	da10      	bge.n	34bc <tcp_oos_insert_segment+0x58>
		if (next && TCP_SEQ_GT(seqno + cseg->len, next->tcphdr->seqno)) {
    349a:	1a5b      	subs	r3, r3, r1
    349c:	2b00      	cmp	r3, #0
    349e:	dd0a      	ble.n	34b6 <tcp_oos_insert_segment+0x52>
			cseg->len = (u16_t)(next->tcphdr->seqno - seqno);
    34a0:	1a09      	subs	r1, r1, r0
    34a2:	b289      	uxth	r1, r1
			pbuf_realloc(cseg->p, cseg->len);
    34a4:	6868      	ldr	r0, [r5, #4]
    34a6:	4b13      	ldr	r3, [pc, #76]	; (34f4 <tcp_oos_insert_segment+0x90>)
			cseg->len = (u16_t)(next->tcphdr->seqno - seqno);
    34a8:	8129      	strh	r1, [r5, #8]
			pbuf_realloc(cseg->p, cseg->len);
    34aa:	4798      	blx	r3
    34ac:	e003      	b.n	34b6 <tcp_oos_insert_segment+0x52>
		tcp_segs_free(next);
    34ae:	4620      	mov	r0, r4
    34b0:	4b11      	ldr	r3, [pc, #68]	; (34f8 <tcp_oos_insert_segment+0x94>)
    34b2:	4798      	blx	r3
		next = NULL;
    34b4:	2400      	movs	r4, #0
	cseg->next = next;
    34b6:	602c      	str	r4, [r5, #0]
}
    34b8:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
			if (TCPH_FLAGS(next->tcphdr) & TCP_FIN) {
    34bc:	f8bc 000c 	ldrh.w	r0, [ip, #12]
    34c0:	47b0      	blx	r6
    34c2:	07c3      	lsls	r3, r0, #31
    34c4:	d508      	bpl.n	34d8 <tcp_oos_insert_segment+0x74>
				TCPH_SET_FLAG(cseg->tcphdr, TCP_FIN);
    34c6:	68eb      	ldr	r3, [r5, #12]
    34c8:	2001      	movs	r0, #1
    34ca:	f8b3 a00c 	ldrh.w	sl, [r3, #12]
    34ce:	47c0      	blx	r8
    34d0:	68eb      	ldr	r3, [r5, #12]
    34d2:	ea4a 0000 	orr.w	r0, sl, r0
    34d6:	8198      	strh	r0, [r3, #12]
			next    = next->next;
    34d8:	f8d4 a000 	ldr.w	sl, [r4]
			tcp_seg_free(old_seg);
    34dc:	4620      	mov	r0, r4
    34de:	47c8      	blx	r9
		while (next && TCP_SEQ_GEQ((seqno + cseg->len), (next->tcphdr->seqno + next->len))) {
    34e0:	4654      	mov	r4, sl
    34e2:	f1ba 0f00 	cmp.w	sl, #0
    34e6:	d1cc      	bne.n	3482 <tcp_oos_insert_segment+0x1e>
    34e8:	e7e5      	b.n	34b6 <tcp_oos_insert_segment+0x52>
    34ea:	bf00      	nop
    34ec:	00000d67 	.word	0x00000d67
    34f0:	2000a4e0 	.word	0x2000a4e0
    34f4:	00003249 	.word	0x00003249
    34f8:	00006ae9 	.word	0x00006ae9
    34fc:	00000d61 	.word	0x00000d61
    3500:	00006ac5 	.word	0x00006ac5

00003504 <tcp_receive>:
{
    3504:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
	if (flags & TCP_ACK) {
    3508:	4d75      	ldr	r5, [pc, #468]	; (36e0 <tcp_receive+0x1dc>)
    350a:	7a2b      	ldrb	r3, [r5, #8]
    350c:	06de      	lsls	r6, r3, #27
{
    350e:	4604      	mov	r4, r0
	if (flags & TCP_ACK) {
    3510:	f140 8132 	bpl.w	3778 <tcp_receive+0x274>
		right_wnd_edge = pcb->snd_wnd + pcb->snd_wl2;
    3514:	f8b0 1060 	ldrh.w	r1, [r0, #96]	; 0x60
		if (TCP_SEQ_LT(pcb->snd_wl1, seqno) || (pcb->snd_wl1 == seqno && TCP_SEQ_LT(pcb->snd_wl2, ackno))
    3518:	686a      	ldr	r2, [r5, #4]
    351a:	68eb      	ldr	r3, [r5, #12]
    351c:	e9d0 6015 	ldrd	r6, r0, [r0, #84]	; 0x54
    3520:	1ab7      	subs	r7, r6, r2
    3522:	2f00      	cmp	r7, #0
    3524:	db0a      	blt.n	353c <tcp_receive+0x38>
    3526:	4296      	cmp	r6, r2
    3528:	d102      	bne.n	3530 <tcp_receive+0x2c>
    352a:	1ac6      	subs	r6, r0, r3
    352c:	2e00      	cmp	r6, #0
    352e:	db05      	blt.n	353c <tcp_receive+0x38>
		    || (pcb->snd_wl2 == ackno && tcphdr->wnd > pcb->snd_wnd)) {
    3530:	4298      	cmp	r0, r3
    3532:	d118      	bne.n	3566 <tcp_receive+0x62>
    3534:	682e      	ldr	r6, [r5, #0]
    3536:	89f6      	ldrh	r6, [r6, #14]
    3538:	428e      	cmp	r6, r1
    353a:	d914      	bls.n	3566 <tcp_receive+0x62>
			pcb->snd_wnd = tcphdr->wnd;
    353c:	682e      	ldr	r6, [r5, #0]
			if (pcb->snd_wnd_max < tcphdr->wnd) {
    353e:	f8b4 c062 	ldrh.w	ip, [r4, #98]	; 0x62
			pcb->snd_wnd = tcphdr->wnd;
    3542:	89f6      	ldrh	r6, [r6, #14]
    3544:	f8a4 6060 	strh.w	r6, [r4, #96]	; 0x60
    3548:	b2b7      	uxth	r7, r6
			if (pcb->snd_wnd_max < tcphdr->wnd) {
    354a:	45bc      	cmp	ip, r7
			pcb->snd_wl2 = ackno;
    354c:	e9c4 2315 	strd	r2, r3, [r4, #84]	; 0x54
				pcb->snd_wnd_max = tcphdr->wnd;
    3550:	bf38      	it	cc
    3552:	f8a4 6062 	strhcc.w	r6, [r4, #98]	; 0x62
				if (pcb->persist_backoff == 0) {
    3556:	f894 2095 	ldrb.w	r2, [r4, #149]	; 0x95
			if (pcb->snd_wnd == 0) {
    355a:	bb97      	cbnz	r7, 35c2 <tcp_receive+0xbe>
				if (pcb->persist_backoff == 0) {
    355c:	b91a      	cbnz	r2, 3566 <tcp_receive+0x62>
					pcb->persist_cnt     = 0;
    355e:	f44f 7280 	mov.w	r2, #256	; 0x100
    3562:	f8a4 2094 	strh.w	r2, [r4, #148]	; 0x94
		if (TCP_SEQ_LEQ(ackno, pcb->lastack)) {
    3566:	6ca6      	ldr	r6, [r4, #72]	; 0x48
    3568:	1b9a      	subs	r2, r3, r6
    356a:	2a00      	cmp	r2, #0
    356c:	dc38      	bgt.n	35e0 <tcp_receive+0xdc>
			pcb->acked = 0;
    356e:	2200      	movs	r2, #0
    3570:	f8a4 2064 	strh.w	r2, [r4, #100]	; 0x64
			if (tcplen == 0) {
    3574:	8a2a      	ldrh	r2, [r5, #16]
    3576:	bb7a      	cbnz	r2, 35d8 <tcp_receive+0xd4>
				if (pcb->snd_wl2 + pcb->snd_wnd == right_wnd_edge) {
    3578:	f8b4 2060 	ldrh.w	r2, [r4, #96]	; 0x60
    357c:	6da7      	ldr	r7, [r4, #88]	; 0x58
		right_wnd_edge = pcb->snd_wnd + pcb->snd_wl2;
    357e:	4401      	add	r1, r0
				if (pcb->snd_wl2 + pcb->snd_wnd == right_wnd_edge) {
    3580:	443a      	add	r2, r7
    3582:	428a      	cmp	r2, r1
    3584:	d128      	bne.n	35d8 <tcp_receive+0xd4>
					if (pcb->rtime >= 0) {
    3586:	f9b4 2034 	ldrsh.w	r2, [r4, #52]	; 0x34
    358a:	2a00      	cmp	r2, #0
    358c:	db24      	blt.n	35d8 <tcp_receive+0xd4>
						if (pcb->lastack == ackno) {
    358e:	429e      	cmp	r6, r3
    3590:	d122      	bne.n	35d8 <tcp_receive+0xd4>
							if ((u8_t)(pcb->dupacks + 1) > pcb->dupacks) {
    3592:	f894 3047 	ldrb.w	r3, [r4, #71]	; 0x47
    3596:	2bff      	cmp	r3, #255	; 0xff
								++pcb->dupacks;
    3598:	bf1c      	itt	ne
    359a:	3301      	addne	r3, #1
    359c:	f884 3047 	strbne.w	r3, [r4, #71]	; 0x47
							if (pcb->dupacks > 3) {
    35a0:	f894 3047 	ldrb.w	r3, [r4, #71]	; 0x47
    35a4:	2b03      	cmp	r3, #3
    35a6:	d912      	bls.n	35ce <tcp_receive+0xca>
								if ((u16_t)(pcb->cwnd + pcb->mss) > pcb->cwnd) {
    35a8:	f8b4 204c 	ldrh.w	r2, [r4, #76]	; 0x4c
    35ac:	8ee3      	ldrh	r3, [r4, #54]	; 0x36
    35ae:	4413      	add	r3, r2
    35b0:	b29b      	uxth	r3, r3
    35b2:	429a      	cmp	r2, r3
    35b4:	d201      	bcs.n	35ba <tcp_receive+0xb6>
									pcb->cwnd += pcb->mss;
    35b6:	f8a4 304c 	strh.w	r3, [r4, #76]	; 0x4c
		       && TCP_SEQ_BETWEEN(ackno, ntohl(pcb->unsent->tcphdr->seqno) + TCP_TCPLEN(pcb->unsent), pcb->snd_nxt)) {
    35ba:	f8df 8130 	ldr.w	r8, [pc, #304]	; 36ec <tcp_receive+0x1e8>
    35be:	4f49      	ldr	r7, [pc, #292]	; (36e4 <tcp_receive+0x1e0>)
    35c0:	e0d3      	b.n	376a <tcp_receive+0x266>
			} else if (pcb->persist_backoff > 0) {
    35c2:	2a00      	cmp	r2, #0
    35c4:	d0cf      	beq.n	3566 <tcp_receive+0x62>
				pcb->persist_backoff = 0;
    35c6:	2200      	movs	r2, #0
    35c8:	f884 2095 	strb.w	r2, [r4, #149]	; 0x95
    35cc:	e7cb      	b.n	3566 <tcp_receive+0x62>
							} else if (pcb->dupacks == 3) {
    35ce:	d1f4      	bne.n	35ba <tcp_receive+0xb6>
								tcp_rexmit_fast(pcb);
    35d0:	4b45      	ldr	r3, [pc, #276]	; (36e8 <tcp_receive+0x1e4>)
    35d2:	4620      	mov	r0, r4
    35d4:	4798      	blx	r3
			if (!found_dupack) {
    35d6:	e7f0      	b.n	35ba <tcp_receive+0xb6>
				pcb->dupacks = 0;
    35d8:	2300      	movs	r3, #0
    35da:	f884 3047 	strb.w	r3, [r4, #71]	; 0x47
    35de:	e7ec      	b.n	35ba <tcp_receive+0xb6>
		} else if (TCP_SEQ_BETWEEN(ackno, pcb->lastack + 1, pcb->snd_nxt)) {
    35e0:	6d21      	ldr	r1, [r4, #80]	; 0x50
    35e2:	1a59      	subs	r1, r3, r1
    35e4:	2900      	cmp	r1, #0
    35e6:	dc76      	bgt.n	36d6 <tcp_receive+0x1d2>
			if (pcb->flags & TF_INFR) {
    35e8:	7fa1      	ldrb	r1, [r4, #30]
			pcb->lastack = ackno;
    35ea:	64a3      	str	r3, [r4, #72]	; 0x48
			if (pcb->flags & TF_INFR) {
    35ec:	0748      	lsls	r0, r1, #29
				pcb->flags &= ~TF_INFR;
    35ee:	bf41      	itttt	mi
    35f0:	f021 0104 	bicmi.w	r1, r1, #4
    35f4:	77a1      	strbmi	r1, [r4, #30]
				pcb->cwnd = pcb->ssthresh;
    35f6:	f8b4 104e 	ldrhmi.w	r1, [r4, #78]	; 0x4e
    35fa:	f8a4 104c 	strhmi.w	r1, [r4, #76]	; 0x4c
			pcb->rto = (pcb->sa >> 3) + pcb->sv;
    35fe:	f9b4 0040 	ldrsh.w	r0, [r4, #64]	; 0x40
    3602:	f8b4 1042 	ldrh.w	r1, [r4, #66]	; 0x42
			if (pcb->state >= ESTABLISHED) {
    3606:	7e23      	ldrb	r3, [r4, #24]
			pcb->rto = (pcb->sa >> 3) + pcb->sv;
    3608:	eb01 01e0 	add.w	r1, r1, r0, asr #3
    360c:	f8a4 1044 	strh.w	r1, [r4, #68]	; 0x44
			pcb->snd_buf += pcb->acked;
    3610:	f8b4 1066 	ldrh.w	r1, [r4, #102]	; 0x66
			pcb->acked = (u16_t)(ackno - pcb->lastack);
    3614:	b292      	uxth	r2, r2
    3616:	f8a4 2064 	strh.w	r2, [r4, #100]	; 0x64
			pcb->snd_buf += pcb->acked;
    361a:	440a      	add	r2, r1
    361c:	f8a4 2066 	strh.w	r2, [r4, #102]	; 0x66
			if (pcb->state >= ESTABLISHED) {
    3620:	2b03      	cmp	r3, #3
			pcb->nrtx = 0;
    3622:	f04f 0200 	mov.w	r2, #0
    3626:	f8a4 2046 	strh.w	r2, [r4, #70]	; 0x46
			if (pcb->state >= ESTABLISHED) {
    362a:	d90f      	bls.n	364c <tcp_receive+0x148>
				if (pcb->cwnd < pcb->ssthresh) {
    362c:	f8b4 204c 	ldrh.w	r2, [r4, #76]	; 0x4c
    3630:	f8b4 104e 	ldrh.w	r1, [r4, #78]	; 0x4e
								if ((u16_t)(pcb->cwnd + pcb->mss) > pcb->cwnd) {
    3634:	8ee3      	ldrh	r3, [r4, #54]	; 0x36
				if (pcb->cwnd < pcb->ssthresh) {
    3636:	4291      	cmp	r1, r2
					u16_t new_cwnd = (pcb->cwnd + pcb->mss * pcb->mss / pcb->cwnd);
    3638:	bf9c      	itt	ls
    363a:	435b      	mulls	r3, r3
    363c:	fbb3 f3f2 	udivls	r3, r3, r2
    3640:	4413      	add	r3, r2
    3642:	b29b      	uxth	r3, r3
					if (new_cwnd > pcb->cwnd) {
    3644:	429a      	cmp	r2, r3
    3646:	d201      	bcs.n	364c <tcp_receive+0x148>
						pcb->cwnd = new_cwnd;
    3648:	f8a4 304c 	strh.w	r3, [r4, #76]	; 0x4c
			       && TCP_SEQ_LEQ(ntohl(pcb->unacked->tcphdr->seqno) + TCP_TCPLEN(pcb->unacked), ackno)) {
    364c:	4f27      	ldr	r7, [pc, #156]	; (36ec <tcp_receive+0x1e8>)
    364e:	4e25      	ldr	r6, [pc, #148]	; (36e4 <tcp_receive+0x1e0>)
				pcb->snd_queuelen -= pbuf_clen(next->p);
    3650:	f8df 80a0 	ldr.w	r8, [pc, #160]	; 36f4 <tcp_receive+0x1f0>
    3654:	e033      	b.n	36be <tcp_receive+0x1ba>
			       && TCP_SEQ_LEQ(ntohl(pcb->unacked->tcphdr->seqno) + TCP_TCPLEN(pcb->unacked), ackno)) {
    3656:	68db      	ldr	r3, [r3, #12]
    3658:	6858      	ldr	r0, [r3, #4]
    365a:	47b8      	blx	r7
    365c:	6f22      	ldr	r2, [r4, #112]	; 0x70
    365e:	68d3      	ldr	r3, [r2, #12]
    3660:	f8b2 a008 	ldrh.w	sl, [r2, #8]
    3664:	4681      	mov	r9, r0
    3666:	8998      	ldrh	r0, [r3, #12]
    3668:	47b0      	blx	r6
    366a:	f010 0303 	ands.w	r3, r0, #3
    366e:	68e8      	ldr	r0, [r5, #12]
    3670:	bf18      	it	ne
    3672:	2301      	movne	r3, #1
    3674:	4453      	add	r3, sl
    3676:	eba9 0900 	sub.w	r9, r9, r0
    367a:	444b      	add	r3, r9
    367c:	2b00      	cmp	r3, #0
    367e:	dc21      	bgt.n	36c4 <tcp_receive+0x1c0>
				next         = pcb->unacked;
    3680:	f8d4 9070 	ldr.w	r9, [r4, #112]	; 0x70
				pcb->unacked = pcb->unacked->next;
    3684:	f8d9 3000 	ldr.w	r3, [r9]
    3688:	6723      	str	r3, [r4, #112]	; 0x70
				if ((pcb->acked != 0) && ((TCPH_FLAGS(next->tcphdr) & TCP_FIN) != 0)) {
    368a:	f8b4 3064 	ldrh.w	r3, [r4, #100]	; 0x64
    368e:	b15b      	cbz	r3, 36a8 <tcp_receive+0x1a4>
    3690:	f8d9 300c 	ldr.w	r3, [r9, #12]
    3694:	8998      	ldrh	r0, [r3, #12]
    3696:	47b0      	blx	r6
    3698:	07c1      	lsls	r1, r0, #31
					pcb->acked--;
    369a:	bf42      	ittt	mi
    369c:	f8b4 3064 	ldrhmi.w	r3, [r4, #100]	; 0x64
    36a0:	f103 33ff 	addmi.w	r3, r3, #4294967295	; 0xffffffff
    36a4:	f8a4 3064 	strhmi.w	r3, [r4, #100]	; 0x64
				pcb->snd_queuelen -= pbuf_clen(next->p);
    36a8:	f8d9 0004 	ldr.w	r0, [r9, #4]
    36ac:	47c0      	blx	r8
    36ae:	f8b4 3068 	ldrh.w	r3, [r4, #104]	; 0x68
    36b2:	1a18      	subs	r0, r3, r0
    36b4:	f8a4 0068 	strh.w	r0, [r4, #104]	; 0x68
				tcp_seg_free(next);
    36b8:	4b0d      	ldr	r3, [pc, #52]	; (36f0 <tcp_receive+0x1ec>)
    36ba:	4648      	mov	r0, r9
    36bc:	4798      	blx	r3
			while (pcb->unacked != NULL
    36be:	6f23      	ldr	r3, [r4, #112]	; 0x70
    36c0:	2b00      	cmp	r3, #0
    36c2:	d1c8      	bne.n	3656 <tcp_receive+0x152>
			if (pcb->unacked == NULL)
    36c4:	6f23      	ldr	r3, [r4, #112]	; 0x70
    36c6:	fab3 f383 	clz	r3, r3
    36ca:	095b      	lsrs	r3, r3, #5
    36cc:	425b      	negs	r3, r3
    36ce:	86a3      	strh	r3, [r4, #52]	; 0x34
			pcb->polltmr = 0;
    36d0:	2300      	movs	r3, #0
    36d2:	77e3      	strb	r3, [r4, #31]
    36d4:	e771      	b.n	35ba <tcp_receive+0xb6>
			pcb->acked = 0;
    36d6:	2300      	movs	r3, #0
    36d8:	f8a4 3064 	strh.w	r3, [r4, #100]	; 0x64
    36dc:	e76d      	b.n	35ba <tcp_receive+0xb6>
    36de:	bf00      	nop
    36e0:	2000a4e0 	.word	0x2000a4e0
    36e4:	00000d67 	.word	0x00000d67
    36e8:	00002865 	.word	0x00002865
    36ec:	00000d71 	.word	0x00000d71
    36f0:	00006ac5 	.word	0x00006ac5
    36f4:	0000329d 	.word	0x0000329d
		       && TCP_SEQ_BETWEEN(ackno, ntohl(pcb->unsent->tcphdr->seqno) + TCP_TCPLEN(pcb->unsent), pcb->snd_nxt)) {
    36f8:	68db      	ldr	r3, [r3, #12]
    36fa:	68ee      	ldr	r6, [r5, #12]
    36fc:	6858      	ldr	r0, [r3, #4]
    36fe:	47c0      	blx	r8
    3700:	6ee3      	ldr	r3, [r4, #108]	; 0x6c
    3702:	f8b3 a008 	ldrh.w	sl, [r3, #8]
    3706:	68db      	ldr	r3, [r3, #12]
    3708:	4681      	mov	r9, r0
    370a:	8998      	ldrh	r0, [r3, #12]
    370c:	47b8      	blx	r7
    370e:	f010 0003 	ands.w	r0, r0, #3
    3712:	bf18      	it	ne
    3714:	2001      	movne	r0, #1
    3716:	eba6 0609 	sub.w	r6, r6, r9
    371a:	4450      	add	r0, sl
    371c:	1a30      	subs	r0, r6, r0
    371e:	2800      	cmp	r0, #0
    3720:	db26      	blt.n	3770 <tcp_receive+0x26c>
    3722:	68eb      	ldr	r3, [r5, #12]
    3724:	6d22      	ldr	r2, [r4, #80]	; 0x50
    3726:	1a9b      	subs	r3, r3, r2
    3728:	2b00      	cmp	r3, #0
    372a:	dc21      	bgt.n	3770 <tcp_receive+0x26c>
			next        = pcb->unsent;
    372c:	6ee6      	ldr	r6, [r4, #108]	; 0x6c
			pcb->unsent = pcb->unsent->next;
    372e:	6833      	ldr	r3, [r6, #0]
    3730:	66e3      	str	r3, [r4, #108]	; 0x6c
			if (pcb->unsent == NULL) {
    3732:	b90b      	cbnz	r3, 3738 <tcp_receive+0x234>
				pcb->unsent_oversize = 0;
    3734:	f8a4 306a 	strh.w	r3, [r4, #106]	; 0x6a
			if ((pcb->acked != 0) && ((TCPH_FLAGS(next->tcphdr) & TCP_FIN) != 0)) {
    3738:	f8b4 3064 	ldrh.w	r3, [r4, #100]	; 0x64
    373c:	b153      	cbz	r3, 3754 <tcp_receive+0x250>
    373e:	68f3      	ldr	r3, [r6, #12]
    3740:	8998      	ldrh	r0, [r3, #12]
    3742:	47b8      	blx	r7
    3744:	07c2      	lsls	r2, r0, #31
				pcb->acked--;
    3746:	bf42      	ittt	mi
    3748:	f8b4 3064 	ldrhmi.w	r3, [r4, #100]	; 0x64
    374c:	f103 33ff 	addmi.w	r3, r3, #4294967295	; 0xffffffff
    3750:	f8a4 3064 	strhmi.w	r3, [r4, #100]	; 0x64
			pcb->snd_queuelen -= pbuf_clen(next->p);
    3754:	4b95      	ldr	r3, [pc, #596]	; (39ac <tcp_receive+0x4a8>)
    3756:	6870      	ldr	r0, [r6, #4]
    3758:	4798      	blx	r3
    375a:	f8b4 3068 	ldrh.w	r3, [r4, #104]	; 0x68
    375e:	1a18      	subs	r0, r3, r0
    3760:	f8a4 0068 	strh.w	r0, [r4, #104]	; 0x68
			tcp_seg_free(next);
    3764:	4b92      	ldr	r3, [pc, #584]	; (39b0 <tcp_receive+0x4ac>)
    3766:	4630      	mov	r0, r6
    3768:	4798      	blx	r3
		while (pcb->unsent != NULL
    376a:	6ee3      	ldr	r3, [r4, #108]	; 0x6c
    376c:	2b00      	cmp	r3, #0
    376e:	d1c3      	bne.n	36f8 <tcp_receive+0x1f4>
		if (pcb->rttest && TCP_SEQ_LT(pcb->rtseq, ackno)) {
    3770:	6ba1      	ldr	r1, [r4, #56]	; 0x38
    3772:	2900      	cmp	r1, #0
    3774:	f040 80a9 	bne.w	38ca <tcp_receive+0x3c6>
	if ((tcplen > 0) && (pcb->state < CLOSE_WAIT)) {
    3778:	8a2e      	ldrh	r6, [r5, #16]
		if (TCP_SEQ_BETWEEN(pcb->rcv_nxt, seqno + 1, seqno + tcplen - 1)) {
    377a:	686b      	ldr	r3, [r5, #4]
    377c:	6aa2      	ldr	r2, [r4, #40]	; 0x28
	if ((tcplen > 0) && (pcb->state < CLOSE_WAIT)) {
    377e:	2e00      	cmp	r6, #0
    3780:	f000 824d 	beq.w	3c1e <tcp_receive+0x71a>
    3784:	7e21      	ldrb	r1, [r4, #24]
    3786:	2906      	cmp	r1, #6
    3788:	f200 8249 	bhi.w	3c1e <tcp_receive+0x71a>
		if (TCP_SEQ_BETWEEN(pcb->rcv_nxt, seqno + 1, seqno + tcplen - 1)) {
    378c:	1ad1      	subs	r1, r2, r3
    378e:	2901      	cmp	r1, #1
    3790:	f100 80cd 	bmi.w	392e <tcp_receive+0x42a>
    3794:	f1c3 0001 	rsb	r0, r3, #1
    3798:	1b80      	subs	r0, r0, r6
    379a:	4410      	add	r0, r2
    379c:	2800      	cmp	r0, #0
    379e:	f300 80c6 	bgt.w	392e <tcp_receive+0x42a>
			p   = inseg.p;
    37a2:	69a8      	ldr	r0, [r5, #24]
			if (inseg.p->len < off) {
    37a4:	8943      	ldrh	r3, [r0, #10]
    37a6:	428b      	cmp	r3, r1
				new_tot_len = (u16_t)(inseg.p->tot_len - off);
    37a8:	b28a      	uxth	r2, r1
			if (inseg.p->len < off) {
    37aa:	f280 80bd 	bge.w	3928 <tcp_receive+0x424>
				new_tot_len = (u16_t)(inseg.p->tot_len - off);
    37ae:	8903      	ldrh	r3, [r0, #8]
    37b0:	1a9b      	subs	r3, r3, r2
    37b2:	b29b      	uxth	r3, r3
					p->len     = 0;
    37b4:	2600      	movs	r6, #0
				while (p->len < off) {
    37b6:	8942      	ldrh	r2, [r0, #10]
    37b8:	428a      	cmp	r2, r1
    37ba:	f2c0 80b0 	blt.w	391e <tcp_receive+0x41a>
				if (pbuf_header(p, (s16_t)-off)) {
    37be:	4249      	negs	r1, r1
    37c0:	b209      	sxth	r1, r1
				if (pbuf_header(inseg.p, (s16_t)-off)) {
    37c2:	4b7c      	ldr	r3, [pc, #496]	; (39b4 <tcp_receive+0x4b0>)
    37c4:	4798      	blx	r3
			inseg.len -= (u16_t)(pcb->rcv_nxt - seqno);
    37c6:	8ba9      	ldrh	r1, [r5, #28]
    37c8:	686b      	ldr	r3, [r5, #4]
    37ca:	6aa2      	ldr	r2, [r4, #40]	; 0x28
			inseg.tcphdr->seqno = seqno = pcb->rcv_nxt;
    37cc:	606a      	str	r2, [r5, #4]
			inseg.len -= (u16_t)(pcb->rcv_nxt - seqno);
    37ce:	440b      	add	r3, r1
    37d0:	1a9b      	subs	r3, r3, r2
    37d2:	83ab      	strh	r3, [r5, #28]
			inseg.tcphdr->seqno = seqno = pcb->rcv_nxt;
    37d4:	6a2b      	ldr	r3, [r5, #32]
    37d6:	605a      	str	r2, [r3, #4]
		if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, pcb->rcv_nxt + pcb->rcv_wnd - 1)) {
    37d8:	6869      	ldr	r1, [r5, #4]
    37da:	6aa2      	ldr	r2, [r4, #40]	; 0x28
    37dc:	1a8b      	subs	r3, r1, r2
    37de:	2b00      	cmp	r3, #0
    37e0:	f2c0 8217 	blt.w	3c12 <tcp_receive+0x70e>
    37e4:	8da0      	ldrh	r0, [r4, #44]	; 0x2c
    37e6:	1c4b      	adds	r3, r1, #1
    37e8:	1a9b      	subs	r3, r3, r2
    37ea:	1a1b      	subs	r3, r3, r0
    37ec:	2b00      	cmp	r3, #0
    37ee:	f300 8210 	bgt.w	3c12 <tcp_receive+0x70e>
			if (pcb->rcv_nxt == seqno) {
    37f2:	4291      	cmp	r1, r2
    37f4:	f040 815f 	bne.w	3ab6 <tcp_receive+0x5b2>
				tcplen = TCP_TCPLEN(&inseg);
    37f8:	6a2b      	ldr	r3, [r5, #32]
    37fa:	4e6f      	ldr	r6, [pc, #444]	; (39b8 <tcp_receive+0x4b4>)
    37fc:	8998      	ldrh	r0, [r3, #12]
    37fe:	8baf      	ldrh	r7, [r5, #28]
    3800:	47b0      	blx	r6
    3802:	f010 0003 	ands.w	r0, r0, #3
    3806:	bf18      	it	ne
    3808:	2001      	movne	r0, #1
				if (tcplen > pcb->rcv_wnd) {
    380a:	8da3      	ldrh	r3, [r4, #44]	; 0x2c
				tcplen = TCP_TCPLEN(&inseg);
    380c:	4438      	add	r0, r7
    380e:	b280      	uxth	r0, r0
				if (tcplen > pcb->rcv_wnd) {
    3810:	4283      	cmp	r3, r0
				tcplen = TCP_TCPLEN(&inseg);
    3812:	8228      	strh	r0, [r5, #16]
				if (tcplen > pcb->rcv_wnd) {
    3814:	d22b      	bcs.n	386e <tcp_receive+0x36a>
					if (TCPH_FLAGS(inseg.tcphdr) & TCP_FIN) {
    3816:	6a2b      	ldr	r3, [r5, #32]
    3818:	8998      	ldrh	r0, [r3, #12]
    381a:	47b0      	blx	r6
    381c:	07c3      	lsls	r3, r0, #31
    381e:	d50c      	bpl.n	383a <tcp_receive+0x336>
						TCPH_FLAGS_SET(inseg.tcphdr, TCPH_FLAGS(inseg.tcphdr) & ~TCP_FIN);
    3820:	6a2b      	ldr	r3, [r5, #32]
    3822:	899f      	ldrh	r7, [r3, #12]
    3824:	4638      	mov	r0, r7
    3826:	47b0      	blx	r6
    3828:	4b64      	ldr	r3, [pc, #400]	; (39bc <tcp_receive+0x4b8>)
    382a:	f000 003e 	and.w	r0, r0, #62	; 0x3e
    382e:	4798      	blx	r3
    3830:	f427 577c 	bic.w	r7, r7, #16128	; 0x3f00
    3834:	6a2b      	ldr	r3, [r5, #32]
    3836:	4307      	orrs	r7, r0
    3838:	819f      	strh	r7, [r3, #12]
					inseg.len = pcb->rcv_wnd;
    383a:	8da3      	ldrh	r3, [r4, #44]	; 0x2c
    383c:	83ab      	strh	r3, [r5, #28]
					if (TCPH_FLAGS(inseg.tcphdr) & TCP_SYN) {
    383e:	6a2b      	ldr	r3, [r5, #32]
    3840:	8998      	ldrh	r0, [r3, #12]
    3842:	47b0      	blx	r6
    3844:	0787      	lsls	r7, r0, #30
						inseg.len -= 1;
    3846:	bf48      	it	mi
    3848:	8bab      	ldrhmi	r3, [r5, #28]
					pbuf_realloc(inseg.p, inseg.len);
    384a:	69a8      	ldr	r0, [r5, #24]
						inseg.len -= 1;
    384c:	bf44      	itt	mi
    384e:	f103 33ff 	addmi.w	r3, r3, #4294967295	; 0xffffffff
    3852:	83ab      	strhmi	r3, [r5, #28]
					pbuf_realloc(inseg.p, inseg.len);
    3854:	8ba9      	ldrh	r1, [r5, #28]
    3856:	4b5a      	ldr	r3, [pc, #360]	; (39c0 <tcp_receive+0x4bc>)
    3858:	4798      	blx	r3
					tcplen = TCP_TCPLEN(&inseg);
    385a:	6a2b      	ldr	r3, [r5, #32]
    385c:	8baf      	ldrh	r7, [r5, #28]
    385e:	8998      	ldrh	r0, [r3, #12]
    3860:	47b0      	blx	r6
    3862:	f010 0003 	ands.w	r0, r0, #3
    3866:	bf18      	it	ne
    3868:	2001      	movne	r0, #1
    386a:	4438      	add	r0, r7
    386c:	8228      	strh	r0, [r5, #16]
				if (pcb->ooseq != NULL) {
    386e:	6f63      	ldr	r3, [r4, #116]	; 0x74
    3870:	b143      	cbz	r3, 3884 <tcp_receive+0x380>
					if (TCPH_FLAGS(inseg.tcphdr) & TCP_FIN) {
    3872:	6a2b      	ldr	r3, [r5, #32]
    3874:	8998      	ldrh	r0, [r3, #12]
    3876:	47b0      	blx	r6
    3878:	07c0      	lsls	r0, r0, #31
    387a:	d564      	bpl.n	3946 <tcp_receive+0x442>
							tcp_seg_free(old_ooseq);
    387c:	4f4c      	ldr	r7, [pc, #304]	; (39b0 <tcp_receive+0x4ac>)
						while (pcb->ooseq != NULL) {
    387e:	6f60      	ldr	r0, [r4, #116]	; 0x74
    3880:	2800      	cmp	r0, #0
    3882:	d15c      	bne.n	393e <tcp_receive+0x43a>
				pcb->rcv_nxt = seqno + tcplen;
    3884:	8a29      	ldrh	r1, [r5, #16]
				pcb->rcv_wnd -= tcplen;
    3886:	8da3      	ldrh	r3, [r4, #44]	; 0x2c
				pcb->rcv_nxt = seqno + tcplen;
    3888:	686a      	ldr	r2, [r5, #4]
				tcp_update_rcv_ann_wnd(pcb);
    388a:	4f4e      	ldr	r7, [pc, #312]	; (39c4 <tcp_receive+0x4c0>)
				pcb->rcv_nxt = seqno + tcplen;
    388c:	440a      	add	r2, r1
				pcb->rcv_wnd -= tcplen;
    388e:	1a5b      	subs	r3, r3, r1
				pcb->rcv_nxt = seqno + tcplen;
    3890:	62a2      	str	r2, [r4, #40]	; 0x28
				pcb->rcv_wnd -= tcplen;
    3892:	85a3      	strh	r3, [r4, #44]	; 0x2c
				tcp_update_rcv_ann_wnd(pcb);
    3894:	4620      	mov	r0, r4
    3896:	47b8      	blx	r7
				if (inseg.p->tot_len > 0) {
    3898:	69ab      	ldr	r3, [r5, #24]
    389a:	9701      	str	r7, [sp, #4]
    389c:	891a      	ldrh	r2, [r3, #8]
    389e:	b112      	cbz	r2, 38a6 <tcp_receive+0x3a2>
					recv_data = inseg.p;
    38a0:	626b      	str	r3, [r5, #36]	; 0x24
					inseg.p = NULL;
    38a2:	2300      	movs	r3, #0
    38a4:	61ab      	str	r3, [r5, #24]
				if (TCPH_FLAGS(inseg.tcphdr) & TCP_FIN) {
    38a6:	6a2b      	ldr	r3, [r5, #32]
    38a8:	8998      	ldrh	r0, [r3, #12]
    38aa:	47b0      	blx	r6
    38ac:	07c7      	lsls	r7, r0, #31
    38ae:	d505      	bpl.n	38bc <tcp_receive+0x3b8>
					recv_flags |= TF_GOT_FIN;
    38b0:	f895 3028 	ldrb.w	r3, [r5, #40]	; 0x28
    38b4:	f043 0320 	orr.w	r3, r3, #32
    38b8:	f885 3028 	strb.w	r3, [r5, #40]	; 0x28
							pbuf_cat(recv_data, cseg->p);
    38bc:	f8df a10c 	ldr.w	sl, [pc, #268]	; 39cc <tcp_receive+0x4c8>
					tcp_seg_free(cseg);
    38c0:	f8df b0ec 	ldr.w	fp, [pc, #236]	; 39b0 <tcp_receive+0x4ac>
						cseg->p = NULL;
    38c4:	f04f 0900 	mov.w	r9, #0
    38c8:	e0de      	b.n	3a88 <tcp_receive+0x584>
		if (pcb->rttest && TCP_SEQ_LT(pcb->rtseq, ackno)) {
    38ca:	6be3      	ldr	r3, [r4, #60]	; 0x3c
    38cc:	68ea      	ldr	r2, [r5, #12]
    38ce:	1a9b      	subs	r3, r3, r2
    38d0:	2b00      	cmp	r3, #0
    38d2:	f6bf af51 	bge.w	3778 <tcp_receive+0x274>
			m = (s16_t)(tcp_ticks - pcb->rttest);
    38d6:	4b3c      	ldr	r3, [pc, #240]	; (39c8 <tcp_receive+0x4c4>)
    38d8:	881f      	ldrh	r7, [r3, #0]
			m = m - (pcb->sa >> 3);
    38da:	f9b4 3040 	ldrsh.w	r3, [r4, #64]	; 0x40
			m = (s16_t)(tcp_ticks - pcb->rttest);
    38de:	b289      	uxth	r1, r1
			m = m - (pcb->sa >> 3);
    38e0:	f3c3 00cf 	ubfx	r0, r3, #3, #16
			m = (s16_t)(tcp_ticks - pcb->rttest);
    38e4:	1a7a      	subs	r2, r7, r1
			m = m - (pcb->sa >> 3);
    38e6:	1a12      	subs	r2, r2, r0
    38e8:	b216      	sxth	r6, r2
			if (m < 0) {
    38ea:	2e00      	cmp	r6, #0
			pcb->sa += m;
    38ec:	fa13 f282 	uxtah	r2, r3, r2
				m = -m;
    38f0:	bfb8      	it	lt
    38f2:	1bc9      	sublt	r1, r1, r7
			m = m - (pcb->sv >> 2);
    38f4:	f9b4 3042 	ldrsh.w	r3, [r4, #66]	; 0x42
				m = -m;
    38f8:	bfbc      	itt	lt
    38fa:	1809      	addlt	r1, r1, r0
    38fc:	b20e      	sxthlt	r6, r1
			pcb->sv += m;
    38fe:	eba3 03a3 	sub.w	r3, r3, r3, asr #2
    3902:	4433      	add	r3, r6
			pcb->sa += m;
    3904:	b212      	sxth	r2, r2
			pcb->sv += m;
    3906:	b29b      	uxth	r3, r3
    3908:	f8a4 3042 	strh.w	r3, [r4, #66]	; 0x42
			pcb->rto = (pcb->sa >> 3) + pcb->sv;
    390c:	eb03 03e2 	add.w	r3, r3, r2, asr #3
    3910:	f8a4 3044 	strh.w	r3, [r4, #68]	; 0x44
			pcb->rttest = 0;
    3914:	2300      	movs	r3, #0
			pcb->sa += m;
    3916:	f8a4 2040 	strh.w	r2, [r4, #64]	; 0x40
			pcb->rttest = 0;
    391a:	63a3      	str	r3, [r4, #56]	; 0x38
    391c:	e72c      	b.n	3778 <tcp_receive+0x274>
					p->tot_len = new_tot_len;
    391e:	8103      	strh	r3, [r0, #8]
					p->len     = 0;
    3920:	8146      	strh	r6, [r0, #10]
					off -= p->len;
    3922:	1a89      	subs	r1, r1, r2
					p          = p->next;
    3924:	6800      	ldr	r0, [r0, #0]
    3926:	e746      	b.n	37b6 <tcp_receive+0x2b2>
				if (pbuf_header(inseg.p, (s16_t)-off)) {
    3928:	4252      	negs	r2, r2
    392a:	b211      	sxth	r1, r2
    392c:	e749      	b.n	37c2 <tcp_receive+0x2be>
			if (TCP_SEQ_LT(seqno, pcb->rcv_nxt)) {
    392e:	1a9b      	subs	r3, r3, r2
    3930:	2b00      	cmp	r3, #0
				tcp_ack_now(pcb);
    3932:	bfbe      	ittt	lt
    3934:	7fa3      	ldrblt	r3, [r4, #30]
    3936:	f043 0302 	orrlt.w	r3, r3, #2
    393a:	77a3      	strblt	r3, [r4, #30]
    393c:	e74c      	b.n	37d8 <tcp_receive+0x2d4>
							pcb->ooseq                = pcb->ooseq->next;
    393e:	6803      	ldr	r3, [r0, #0]
    3940:	6763      	str	r3, [r4, #116]	; 0x74
							tcp_seg_free(old_ooseq);
    3942:	47b8      	blx	r7
    3944:	e79b      	b.n	387e <tcp_receive+0x37a>
						next = pcb->ooseq;
    3946:	6f67      	ldr	r7, [r4, #116]	; 0x74
								TCPH_SET_FLAG(inseg.tcphdr, TCP_FIN);
    3948:	f8df 8070 	ldr.w	r8, [pc, #112]	; 39bc <tcp_receive+0x4b8>
							tcp_seg_free(prev);
    394c:	f8df 9060 	ldr.w	r9, [pc, #96]	; 39b0 <tcp_receive+0x4ac>
						while (next && TCP_SEQ_GEQ(seqno + tcplen, next->tcphdr->seqno + next->len)) {
    3950:	6868      	ldr	r0, [r5, #4]
    3952:	8a2b      	ldrh	r3, [r5, #16]
    3954:	4403      	add	r3, r0
    3956:	b337      	cbz	r7, 39a6 <tcp_receive+0x4a2>
    3958:	f8d7 c00c 	ldr.w	ip, [r7, #12]
    395c:	8939      	ldrh	r1, [r7, #8]
    395e:	f8dc 2004 	ldr.w	r2, [ip, #4]
    3962:	4411      	add	r1, r2
    3964:	1a59      	subs	r1, r3, r1
    3966:	2900      	cmp	r1, #0
    3968:	da32      	bge.n	39d0 <tcp_receive+0x4cc>
						if (next && TCP_SEQ_GT(seqno + tcplen, next->tcphdr->seqno)) {
    396a:	1a9b      	subs	r3, r3, r2
    396c:	2b00      	cmp	r3, #0
    396e:	dd1a      	ble.n	39a6 <tcp_receive+0x4a2>
							if (TCPH_FLAGS(inseg.tcphdr) & TCP_SYN) {
    3970:	6a2b      	ldr	r3, [r5, #32]
							inseg.len = (u16_t)(next->tcphdr->seqno - seqno);
    3972:	1a12      	subs	r2, r2, r0
    3974:	83aa      	strh	r2, [r5, #28]
							if (TCPH_FLAGS(inseg.tcphdr) & TCP_SYN) {
    3976:	8998      	ldrh	r0, [r3, #12]
    3978:	47b0      	blx	r6
    397a:	0783      	lsls	r3, r0, #30
								inseg.len -= 1;
    397c:	bf48      	it	mi
    397e:	8bab      	ldrhmi	r3, [r5, #28]
							pbuf_realloc(inseg.p, inseg.len);
    3980:	69a8      	ldr	r0, [r5, #24]
								inseg.len -= 1;
    3982:	bf44      	itt	mi
    3984:	f103 33ff 	addmi.w	r3, r3, #4294967295	; 0xffffffff
    3988:	83ab      	strhmi	r3, [r5, #28]
							pbuf_realloc(inseg.p, inseg.len);
    398a:	8ba9      	ldrh	r1, [r5, #28]
    398c:	4b0c      	ldr	r3, [pc, #48]	; (39c0 <tcp_receive+0x4bc>)
    398e:	4798      	blx	r3
							tcplen = TCP_TCPLEN(&inseg);
    3990:	6a2b      	ldr	r3, [r5, #32]
    3992:	f8b5 801c 	ldrh.w	r8, [r5, #28]
    3996:	8998      	ldrh	r0, [r3, #12]
    3998:	47b0      	blx	r6
    399a:	f010 0003 	ands.w	r0, r0, #3
    399e:	bf18      	it	ne
    39a0:	2001      	movne	r0, #1
    39a2:	4440      	add	r0, r8
    39a4:	8228      	strh	r0, [r5, #16]
						pcb->ooseq = next;
    39a6:	6767      	str	r7, [r4, #116]	; 0x74
    39a8:	e76c      	b.n	3884 <tcp_receive+0x380>
    39aa:	bf00      	nop
    39ac:	0000329d 	.word	0x0000329d
    39b0:	00006ac5 	.word	0x00006ac5
    39b4:	00003089 	.word	0x00003089
    39b8:	00000d67 	.word	0x00000d67
    39bc:	00000d61 	.word	0x00000d61
    39c0:	00003249 	.word	0x00003249
    39c4:	00006a4d 	.word	0x00006a4d
    39c8:	20014948 	.word	0x20014948
    39cc:	000032b7 	.word	0x000032b7
							if (TCPH_FLAGS(next->tcphdr) & TCP_FIN && (TCPH_FLAGS(inseg.tcphdr) & TCP_SYN) == 0) {
    39d0:	f8bc 000c 	ldrh.w	r0, [ip, #12]
    39d4:	47b0      	blx	r6
    39d6:	07c1      	lsls	r1, r0, #31
    39d8:	d517      	bpl.n	3a0a <tcp_receive+0x506>
    39da:	6a2b      	ldr	r3, [r5, #32]
    39dc:	8998      	ldrh	r0, [r3, #12]
    39de:	47b0      	blx	r6
    39e0:	0782      	lsls	r2, r0, #30
    39e2:	d412      	bmi.n	3a0a <tcp_receive+0x506>
								TCPH_SET_FLAG(inseg.tcphdr, TCP_FIN);
    39e4:	6a2b      	ldr	r3, [r5, #32]
    39e6:	2001      	movs	r0, #1
    39e8:	f8b3 a00c 	ldrh.w	sl, [r3, #12]
    39ec:	47c0      	blx	r8
    39ee:	6a2b      	ldr	r3, [r5, #32]
    39f0:	ea4a 0000 	orr.w	r0, sl, r0
    39f4:	8198      	strh	r0, [r3, #12]
								tcplen = TCP_TCPLEN(&inseg);
    39f6:	b280      	uxth	r0, r0
    39f8:	f8b5 a01c 	ldrh.w	sl, [r5, #28]
    39fc:	47b0      	blx	r6
    39fe:	f010 0003 	ands.w	r0, r0, #3
    3a02:	bf18      	it	ne
    3a04:	2001      	movne	r0, #1
    3a06:	4450      	add	r0, sl
    3a08:	8228      	strh	r0, [r5, #16]
							next = next->next;
    3a0a:	f8d7 a000 	ldr.w	sl, [r7]
							tcp_seg_free(prev);
    3a0e:	4638      	mov	r0, r7
    3a10:	47c8      	blx	r9
							next = next->next;
    3a12:	4657      	mov	r7, sl
    3a14:	e79c      	b.n	3950 <tcp_receive+0x44c>
					seqno = pcb->ooseq->tcphdr->seqno;
    3a16:	606b      	str	r3, [r5, #4]
					pcb->rcv_nxt += TCP_TCPLEN(cseg);
    3a18:	8988      	ldrh	r0, [r1, #12]
    3a1a:	f8b7 8008 	ldrh.w	r8, [r7, #8]
    3a1e:	47b0      	blx	r6
    3a20:	f010 0003 	ands.w	r0, r0, #3
    3a24:	6aa3      	ldr	r3, [r4, #40]	; 0x28
					pcb->rcv_wnd -= TCP_TCPLEN(cseg);
    3a26:	68fa      	ldr	r2, [r7, #12]
					pcb->rcv_nxt += TCP_TCPLEN(cseg);
    3a28:	bf18      	it	ne
    3a2a:	2001      	movne	r0, #1
    3a2c:	4440      	add	r0, r8
    3a2e:	4418      	add	r0, r3
    3a30:	62a0      	str	r0, [r4, #40]	; 0x28
					pcb->rcv_wnd -= TCP_TCPLEN(cseg);
    3a32:	8990      	ldrh	r0, [r2, #12]
    3a34:	f8b7 8008 	ldrh.w	r8, [r7, #8]
    3a38:	47b0      	blx	r6
    3a3a:	f010 0003 	ands.w	r0, r0, #3
    3a3e:	8da3      	ldrh	r3, [r4, #44]	; 0x2c
    3a40:	bf18      	it	ne
    3a42:	2001      	movne	r0, #1
    3a44:	4440      	add	r0, r8
    3a46:	1a18      	subs	r0, r3, r0
    3a48:	85a0      	strh	r0, [r4, #44]	; 0x2c
					tcp_update_rcv_ann_wnd(pcb);
    3a4a:	9b01      	ldr	r3, [sp, #4]
    3a4c:	4620      	mov	r0, r4
    3a4e:	4798      	blx	r3
					if (cseg->p->tot_len > 0) {
    3a50:	6879      	ldr	r1, [r7, #4]
    3a52:	890b      	ldrh	r3, [r1, #8]
    3a54:	b123      	cbz	r3, 3a60 <tcp_receive+0x55c>
						if (recv_data) {
    3a56:	6a68      	ldr	r0, [r5, #36]	; 0x24
    3a58:	b328      	cbz	r0, 3aa6 <tcp_receive+0x5a2>
							pbuf_cat(recv_data, cseg->p);
    3a5a:	47d0      	blx	sl
						cseg->p = NULL;
    3a5c:	f8c7 9004 	str.w	r9, [r7, #4]
					if (TCPH_FLAGS(cseg->tcphdr) & TCP_FIN) {
    3a60:	68fb      	ldr	r3, [r7, #12]
    3a62:	8998      	ldrh	r0, [r3, #12]
    3a64:	47b0      	blx	r6
    3a66:	07c0      	lsls	r0, r0, #31
    3a68:	d50a      	bpl.n	3a80 <tcp_receive+0x57c>
						recv_flags |= TF_GOT_FIN;
    3a6a:	f895 3028 	ldrb.w	r3, [r5, #40]	; 0x28
    3a6e:	f043 0320 	orr.w	r3, r3, #32
    3a72:	f885 3028 	strb.w	r3, [r5, #40]	; 0x28
						if (pcb->state == ESTABLISHED) { /* force passive close or we can move to active close */
    3a76:	7e23      	ldrb	r3, [r4, #24]
    3a78:	2b04      	cmp	r3, #4
							pcb->state = CLOSE_WAIT;
    3a7a:	bf04      	itt	eq
    3a7c:	2307      	moveq	r3, #7
    3a7e:	7623      	strbeq	r3, [r4, #24]
					pcb->ooseq = cseg->next;
    3a80:	683b      	ldr	r3, [r7, #0]
    3a82:	6763      	str	r3, [r4, #116]	; 0x74
					tcp_seg_free(cseg);
    3a84:	4638      	mov	r0, r7
    3a86:	47d8      	blx	fp
				while (pcb->ooseq != NULL && pcb->ooseq->tcphdr->seqno == pcb->rcv_nxt) {
    3a88:	6f67      	ldr	r7, [r4, #116]	; 0x74
    3a8a:	b127      	cbz	r7, 3a96 <tcp_receive+0x592>
    3a8c:	68f9      	ldr	r1, [r7, #12]
    3a8e:	6aa2      	ldr	r2, [r4, #40]	; 0x28
    3a90:	684b      	ldr	r3, [r1, #4]
    3a92:	4293      	cmp	r3, r2
    3a94:	d0bf      	beq.n	3a16 <tcp_receive+0x512>
				tcp_ack(pcb);
    3a96:	7fa3      	ldrb	r3, [r4, #30]
    3a98:	07d9      	lsls	r1, r3, #31
    3a9a:	d506      	bpl.n	3aaa <tcp_receive+0x5a6>
    3a9c:	f023 0301 	bic.w	r3, r3, #1
			tcp_ack_now(pcb);
    3aa0:	f043 0302 	orr.w	r3, r3, #2
    3aa4:	e003      	b.n	3aae <tcp_receive+0x5aa>
							recv_data = cseg->p;
    3aa6:	6269      	str	r1, [r5, #36]	; 0x24
    3aa8:	e7d8      	b.n	3a5c <tcp_receive+0x558>
				tcp_ack(pcb);
    3aaa:	f043 0301 	orr.w	r3, r3, #1
    3aae:	77a3      	strb	r3, [r4, #30]
}
    3ab0:	b003      	add	sp, #12
    3ab2:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
				tcp_send_empty_ack(pcb);
    3ab6:	4b60      	ldr	r3, [pc, #384]	; (3c38 <tcp_receive+0x734>)
    3ab8:	4620      	mov	r0, r4
    3aba:	4798      	blx	r3
				if (pcb->ooseq == NULL) {
    3abc:	6f66      	ldr	r6, [r4, #116]	; 0x74
    3abe:	b926      	cbnz	r6, 3aca <tcp_receive+0x5c6>
					pcb->ooseq = tcp_seg_copy(&inseg);
    3ac0:	485e      	ldr	r0, [pc, #376]	; (3c3c <tcp_receive+0x738>)
    3ac2:	4b5f      	ldr	r3, [pc, #380]	; (3c40 <tcp_receive+0x73c>)
    3ac4:	4798      	blx	r3
    3ac6:	6760      	str	r0, [r4, #116]	; 0x74
    3ac8:	e7f2      	b.n	3ab0 <tcp_receive+0x5ac>
						if (seqno == next->tcphdr->seqno) {
    3aca:	686b      	ldr	r3, [r5, #4]
					prev = NULL;
    3acc:	2700      	movs	r7, #0
    3ace:	f103 3cff 	add.w	ip, r3, #4294967295	; 0xffffffff
    3ad2:	f103 0e01 	add.w	lr, r3, #1
						if (seqno == next->tcphdr->seqno) {
    3ad6:	68f0      	ldr	r0, [r6, #12]
    3ad8:	6841      	ldr	r1, [r0, #4]
    3ada:	4299      	cmp	r1, r3
    3adc:	d114      	bne.n	3b08 <tcp_receive+0x604>
							if (inseg.len > next->len) {
    3ade:	8baa      	ldrh	r2, [r5, #28]
    3ae0:	8933      	ldrh	r3, [r6, #8]
    3ae2:	429a      	cmp	r2, r3
    3ae4:	d9e4      	bls.n	3ab0 <tcp_receive+0x5ac>
								cseg = tcp_seg_copy(&inseg);
    3ae6:	4855      	ldr	r0, [pc, #340]	; (3c3c <tcp_receive+0x738>)
    3ae8:	4b55      	ldr	r3, [pc, #340]	; (3c40 <tcp_receive+0x73c>)
    3aea:	4798      	blx	r3
								if (cseg != NULL) {
    3aec:	2800      	cmp	r0, #0
    3aee:	d0df      	beq.n	3ab0 <tcp_receive+0x5ac>
									if (prev != NULL) {
    3af0:	b147      	cbz	r7, 3b04 <tcp_receive+0x600>
										prev->next = cseg;
    3af2:	6038      	str	r0, [r7, #0]
										tcp_oos_insert_segment(cseg, next);
    3af4:	4631      	mov	r1, r6
    3af6:	4b53      	ldr	r3, [pc, #332]	; (3c44 <tcp_receive+0x740>)
}
    3af8:	b003      	add	sp, #12
    3afa:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
										tcp_oos_insert_segment(cseg, next);
    3afe:	4718      	bx	r3
    3b00:	4616      	mov	r6, r2
    3b02:	e7e8      	b.n	3ad6 <tcp_receive+0x5d2>
										pcb->ooseq = cseg;
    3b04:	6760      	str	r0, [r4, #116]	; 0x74
									tcp_oos_insert_segment(cseg, next);
    3b06:	e7f5      	b.n	3af4 <tcp_receive+0x5f0>
							if (prev == NULL) {
    3b08:	b94f      	cbnz	r7, 3b1e <tcp_receive+0x61a>
								if (TCP_SEQ_LT(seqno, next->tcphdr->seqno)) {
    3b0a:	1a5a      	subs	r2, r3, r1
    3b0c:	2a00      	cmp	r2, #0
    3b0e:	da28      	bge.n	3b62 <tcp_receive+0x65e>
									cseg = tcp_seg_copy(&inseg);
    3b10:	484a      	ldr	r0, [pc, #296]	; (3c3c <tcp_receive+0x738>)
    3b12:	4b4b      	ldr	r3, [pc, #300]	; (3c40 <tcp_receive+0x73c>)
    3b14:	4798      	blx	r3
									if (cseg != NULL) {
    3b16:	2800      	cmp	r0, #0
    3b18:	d0ca      	beq.n	3ab0 <tcp_receive+0x5ac>
										pcb->ooseq = cseg;
    3b1a:	6760      	str	r0, [r4, #116]	; 0x74
    3b1c:	e7ea      	b.n	3af4 <tcp_receive+0x5f0>
								if (TCP_SEQ_BETWEEN(seqno, prev->tcphdr->seqno + 1, next->tcphdr->seqno - 1)) {
    3b1e:	68fa      	ldr	r2, [r7, #12]
    3b20:	6852      	ldr	r2, [r2, #4]
    3b22:	ebac 0202 	sub.w	r2, ip, r2
    3b26:	2a00      	cmp	r2, #0
    3b28:	db1b      	blt.n	3b62 <tcp_receive+0x65e>
    3b2a:	ebae 0201 	sub.w	r2, lr, r1
    3b2e:	2a00      	cmp	r2, #0
    3b30:	dc17      	bgt.n	3b62 <tcp_receive+0x65e>
									cseg = tcp_seg_copy(&inseg);
    3b32:	4842      	ldr	r0, [pc, #264]	; (3c3c <tcp_receive+0x738>)
    3b34:	4b42      	ldr	r3, [pc, #264]	; (3c40 <tcp_receive+0x73c>)
    3b36:	4798      	blx	r3
									if (cseg != NULL) {
    3b38:	4604      	mov	r4, r0
    3b3a:	2800      	cmp	r0, #0
    3b3c:	d0b8      	beq.n	3ab0 <tcp_receive+0x5ac>
										if (TCP_SEQ_GT(prev->tcphdr->seqno + prev->len, seqno)) {
    3b3e:	68fb      	ldr	r3, [r7, #12]
    3b40:	6869      	ldr	r1, [r5, #4]
    3b42:	685a      	ldr	r2, [r3, #4]
    3b44:	893b      	ldrh	r3, [r7, #8]
    3b46:	4413      	add	r3, r2
    3b48:	1a5b      	subs	r3, r3, r1
    3b4a:	2b00      	cmp	r3, #0
    3b4c:	dd05      	ble.n	3b5a <tcp_receive+0x656>
											prev->len = (u16_t)(seqno - prev->tcphdr->seqno);
    3b4e:	1a89      	subs	r1, r1, r2
    3b50:	b289      	uxth	r1, r1
											pbuf_realloc(prev->p, prev->len);
    3b52:	6878      	ldr	r0, [r7, #4]
    3b54:	4b3c      	ldr	r3, [pc, #240]	; (3c48 <tcp_receive+0x744>)
											prev->len = (u16_t)(seqno - prev->tcphdr->seqno);
    3b56:	8139      	strh	r1, [r7, #8]
											pbuf_realloc(prev->p, prev->len);
    3b58:	4798      	blx	r3
										prev->next = cseg;
    3b5a:	603c      	str	r4, [r7, #0]
										tcp_oos_insert_segment(cseg, next);
    3b5c:	4631      	mov	r1, r6
    3b5e:	4620      	mov	r0, r4
    3b60:	e7c9      	b.n	3af6 <tcp_receive+0x5f2>
							if (next->next == NULL && TCP_SEQ_GT(seqno, next->tcphdr->seqno)) {
    3b62:	6832      	ldr	r2, [r6, #0]
    3b64:	4637      	mov	r7, r6
    3b66:	2a00      	cmp	r2, #0
    3b68:	d1ca      	bne.n	3b00 <tcp_receive+0x5fc>
    3b6a:	1a5b      	subs	r3, r3, r1
    3b6c:	2b00      	cmp	r3, #0
    3b6e:	dd9f      	ble.n	3ab0 <tcp_receive+0x5ac>
								if (TCPH_FLAGS(next->tcphdr) & TCP_FIN) {
    3b70:	8980      	ldrh	r0, [r0, #12]
    3b72:	4f36      	ldr	r7, [pc, #216]	; (3c4c <tcp_receive+0x748>)
    3b74:	47b8      	blx	r7
    3b76:	07c2      	lsls	r2, r0, #31
    3b78:	d49a      	bmi.n	3ab0 <tcp_receive+0x5ac>
								next->next = tcp_seg_copy(&inseg);
    3b7a:	4830      	ldr	r0, [pc, #192]	; (3c3c <tcp_receive+0x738>)
    3b7c:	4b30      	ldr	r3, [pc, #192]	; (3c40 <tcp_receive+0x73c>)
    3b7e:	4798      	blx	r3
    3b80:	6030      	str	r0, [r6, #0]
								if (next->next != NULL) {
    3b82:	2800      	cmp	r0, #0
    3b84:	d094      	beq.n	3ab0 <tcp_receive+0x5ac>
									if (TCP_SEQ_GT(next->tcphdr->seqno + next->len, seqno)) {
    3b86:	68f3      	ldr	r3, [r6, #12]
    3b88:	6869      	ldr	r1, [r5, #4]
    3b8a:	685a      	ldr	r2, [r3, #4]
    3b8c:	8933      	ldrh	r3, [r6, #8]
    3b8e:	4413      	add	r3, r2
    3b90:	1a5b      	subs	r3, r3, r1
    3b92:	2b00      	cmp	r3, #0
    3b94:	dd05      	ble.n	3ba2 <tcp_receive+0x69e>
										next->len = (u16_t)(seqno - next->tcphdr->seqno);
    3b96:	1a89      	subs	r1, r1, r2
    3b98:	b289      	uxth	r1, r1
										pbuf_realloc(next->p, next->len);
    3b9a:	6870      	ldr	r0, [r6, #4]
    3b9c:	4b2a      	ldr	r3, [pc, #168]	; (3c48 <tcp_receive+0x744>)
										next->len = (u16_t)(seqno - next->tcphdr->seqno);
    3b9e:	8131      	strh	r1, [r6, #8]
										pbuf_realloc(next->p, next->len);
    3ba0:	4798      	blx	r3
									if ((u32_t)tcplen + seqno > pcb->rcv_nxt + (u32_t)pcb->rcv_wnd) {
    3ba2:	686b      	ldr	r3, [r5, #4]
    3ba4:	8a2a      	ldrh	r2, [r5, #16]
    3ba6:	6aa1      	ldr	r1, [r4, #40]	; 0x28
    3ba8:	441a      	add	r2, r3
    3baa:	8da3      	ldrh	r3, [r4, #44]	; 0x2c
    3bac:	440b      	add	r3, r1
    3bae:	429a      	cmp	r2, r3
    3bb0:	f67f af7e 	bls.w	3ab0 <tcp_receive+0x5ac>
										if (TCPH_FLAGS(next->next->tcphdr) & TCP_FIN) {
    3bb4:	6833      	ldr	r3, [r6, #0]
    3bb6:	68db      	ldr	r3, [r3, #12]
    3bb8:	8998      	ldrh	r0, [r3, #12]
    3bba:	47b8      	blx	r7
    3bbc:	07c3      	lsls	r3, r0, #31
    3bbe:	d511      	bpl.n	3be4 <tcp_receive+0x6e0>
											TCPH_FLAGS_SET(next->next->tcphdr,
    3bc0:	6833      	ldr	r3, [r6, #0]
    3bc2:	68db      	ldr	r3, [r3, #12]
    3bc4:	f8b3 800c 	ldrh.w	r8, [r3, #12]
    3bc8:	4640      	mov	r0, r8
    3bca:	47b8      	blx	r7
    3bcc:	4b20      	ldr	r3, [pc, #128]	; (3c50 <tcp_receive+0x74c>)
    3bce:	f000 003e 	and.w	r0, r0, #62	; 0x3e
    3bd2:	4798      	blx	r3
    3bd4:	6833      	ldr	r3, [r6, #0]
    3bd6:	f428 587c 	bic.w	r8, r8, #16128	; 0x3f00
    3bda:	68db      	ldr	r3, [r3, #12]
    3bdc:	ea48 0800 	orr.w	r8, r8, r0
    3be0:	f8a3 800c 	strh.w	r8, [r3, #12]
										next->next->len = pcb->rcv_nxt + pcb->rcv_wnd - seqno;
    3be4:	8da1      	ldrh	r1, [r4, #44]	; 0x2c
    3be6:	686a      	ldr	r2, [r5, #4]
    3be8:	6833      	ldr	r3, [r6, #0]
    3bea:	1a89      	subs	r1, r1, r2
    3bec:	6aa2      	ldr	r2, [r4, #40]	; 0x28
										pbuf_realloc(next->next->p, next->next->len);
    3bee:	6858      	ldr	r0, [r3, #4]
										next->next->len = pcb->rcv_nxt + pcb->rcv_wnd - seqno;
    3bf0:	4411      	add	r1, r2
    3bf2:	b289      	uxth	r1, r1
    3bf4:	8119      	strh	r1, [r3, #8]
										pbuf_realloc(next->next->p, next->next->len);
    3bf6:	4b14      	ldr	r3, [pc, #80]	; (3c48 <tcp_receive+0x744>)
    3bf8:	4798      	blx	r3
										tcplen = TCP_TCPLEN(next->next);
    3bfa:	6833      	ldr	r3, [r6, #0]
    3bfc:	891c      	ldrh	r4, [r3, #8]
    3bfe:	68db      	ldr	r3, [r3, #12]
    3c00:	8998      	ldrh	r0, [r3, #12]
    3c02:	47b8      	blx	r7
    3c04:	f010 0003 	ands.w	r0, r0, #3
    3c08:	bf18      	it	ne
    3c0a:	2001      	movne	r0, #1
    3c0c:	4420      	add	r0, r4
    3c0e:	8228      	strh	r0, [r5, #16]
    3c10:	e74e      	b.n	3ab0 <tcp_receive+0x5ac>
			tcp_send_empty_ack(pcb);
    3c12:	4b09      	ldr	r3, [pc, #36]	; (3c38 <tcp_receive+0x734>)
    3c14:	4620      	mov	r0, r4
}
    3c16:	b003      	add	sp, #12
    3c18:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
			tcp_send_empty_ack(pcb);
    3c1c:	4718      	bx	r3
		if (!TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, pcb->rcv_nxt + pcb->rcv_wnd - 1)) {
    3c1e:	1a99      	subs	r1, r3, r2
    3c20:	2900      	cmp	r1, #0
    3c22:	db06      	blt.n	3c32 <tcp_receive+0x72e>
    3c24:	3301      	adds	r3, #1
    3c26:	1a9b      	subs	r3, r3, r2
    3c28:	8da2      	ldrh	r2, [r4, #44]	; 0x2c
    3c2a:	1a9b      	subs	r3, r3, r2
    3c2c:	2b00      	cmp	r3, #0
    3c2e:	f77f af3f 	ble.w	3ab0 <tcp_receive+0x5ac>
			tcp_ack_now(pcb);
    3c32:	7fa3      	ldrb	r3, [r4, #30]
    3c34:	e734      	b.n	3aa0 <tcp_receive+0x59c>
    3c36:	bf00      	nop
    3c38:	00002431 	.word	0x00002431
    3c3c:	2000a4f4 	.word	0x2000a4f4
    3c40:	00006afd 	.word	0x00006afd
    3c44:	00003465 	.word	0x00003465
    3c48:	00003249 	.word	0x00003249
    3c4c:	00000d67 	.word	0x00000d67
    3c50:	00000d61 	.word	0x00000d61

00003c54 <tcp_input>:
{
    3c54:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	iphdr  = (struct ip_hdr *)p->payload;
    3c58:	6843      	ldr	r3, [r0, #4]
	tcphdr = (struct tcp_hdr *)((u8_t *)p->payload + IPH_HL(iphdr) * 4);
    3c5a:	4d97      	ldr	r5, [pc, #604]	; (3eb8 <tcp_input+0x264>)
    3c5c:	781a      	ldrb	r2, [r3, #0]
	if (pbuf_header(p, -((s16_t)(IPH_HL(iphdr) * 4))) || (p->tot_len < sizeof(struct tcp_hdr))) {
    3c5e:	f8df 928c 	ldr.w	r9, [pc, #652]	; 3eec <tcp_input+0x298>
{
    3c62:	460c      	mov	r4, r1
    3c64:	f002 010f 	and.w	r1, r2, #15
	tcphdr = (struct tcp_hdr *)((u8_t *)p->payload + IPH_HL(iphdr) * 4);
    3c68:	eb03 0381 	add.w	r3, r3, r1, lsl #2
	if (pbuf_header(p, -((s16_t)(IPH_HL(iphdr) * 4))) || (p->tot_len < sizeof(struct tcp_hdr))) {
    3c6c:	0089      	lsls	r1, r1, #2
{
    3c6e:	b085      	sub	sp, #20
	if (pbuf_header(p, -((s16_t)(IPH_HL(iphdr) * 4))) || (p->tot_len < sizeof(struct tcp_hdr))) {
    3c70:	4249      	negs	r1, r1
{
    3c72:	4606      	mov	r6, r0
	tcphdr = (struct tcp_hdr *)((u8_t *)p->payload + IPH_HL(iphdr) * 4);
    3c74:	602b      	str	r3, [r5, #0]
	if (pbuf_header(p, -((s16_t)(IPH_HL(iphdr) * 4))) || (p->tot_len < sizeof(struct tcp_hdr))) {
    3c76:	47c8      	blx	r9
    3c78:	2800      	cmp	r0, #0
    3c7a:	f040 80ec 	bne.w	3e56 <tcp_input+0x202>
    3c7e:	8933      	ldrh	r3, [r6, #8]
    3c80:	2b13      	cmp	r3, #19
    3c82:	f240 80e8 	bls.w	3e56 <tcp_input+0x202>
	if (ip_addr_isbroadcast(&current_iphdr_dest, inp) || ip_addr_ismulticast(&current_iphdr_dest)) {
    3c86:	4f8d      	ldr	r7, [pc, #564]	; (3ebc <tcp_input+0x268>)
    3c88:	4b8d      	ldr	r3, [pc, #564]	; (3ec0 <tcp_input+0x26c>)
    3c8a:	6838      	ldr	r0, [r7, #0]
    3c8c:	4621      	mov	r1, r4
    3c8e:	4798      	blx	r3
    3c90:	2800      	cmp	r0, #0
    3c92:	f040 80e0 	bne.w	3e56 <tcp_input+0x202>
    3c96:	683b      	ldr	r3, [r7, #0]
    3c98:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
    3c9c:	2be0      	cmp	r3, #224	; 0xe0
    3c9e:	f000 80da 	beq.w	3e56 <tcp_input+0x202>
	if (inet_chksum_pseudo(p, ip_current_src_addr(), ip_current_dest_addr(), IP_PROTO_TCP, p->tot_len) != 0) {
    3ca2:	f8df 8230 	ldr.w	r8, [pc, #560]	; 3ed4 <tcp_input+0x280>
    3ca6:	8933      	ldrh	r3, [r6, #8]
    3ca8:	9300      	str	r3, [sp, #0]
    3caa:	4c86      	ldr	r4, [pc, #536]	; (3ec4 <tcp_input+0x270>)
    3cac:	2306      	movs	r3, #6
    3cae:	463a      	mov	r2, r7
    3cb0:	4641      	mov	r1, r8
    3cb2:	4630      	mov	r0, r6
    3cb4:	47a0      	blx	r4
    3cb6:	2800      	cmp	r0, #0
    3cb8:	f040 80cd 	bne.w	3e56 <tcp_input+0x202>
	hdrlen = TCPH_HDRLEN(tcphdr);
    3cbc:	682b      	ldr	r3, [r5, #0]
    3cbe:	4c82      	ldr	r4, [pc, #520]	; (3ec8 <tcp_input+0x274>)
    3cc0:	8998      	ldrh	r0, [r3, #12]
    3cc2:	47a0      	blx	r4
    3cc4:	0b00      	lsrs	r0, r0, #12
	if (pbuf_header(p, -(hdrlen * 4))) {
    3cc6:	ebc0 3080 	rsb	r0, r0, r0, lsl #14
    3cca:	0081      	lsls	r1, r0, #2
    3ccc:	b209      	sxth	r1, r1
    3cce:	4630      	mov	r0, r6
    3cd0:	47c8      	blx	r9
    3cd2:	4682      	mov	sl, r0
    3cd4:	2800      	cmp	r0, #0
    3cd6:	f040 80be 	bne.w	3e56 <tcp_input+0x202>
	tcphdr->src  = ntohs(tcphdr->src);
    3cda:	f8d5 9000 	ldr.w	r9, [r5]
	seqno = tcphdr->seqno = ntohl(tcphdr->seqno);
    3cde:	f8df b210 	ldr.w	fp, [pc, #528]	; 3ef0 <tcp_input+0x29c>
	tcphdr->src  = ntohs(tcphdr->src);
    3ce2:	f8b9 0000 	ldrh.w	r0, [r9]
    3ce6:	47a0      	blx	r4
    3ce8:	f8a9 0000 	strh.w	r0, [r9]
	tcphdr->dest = ntohs(tcphdr->dest);
    3cec:	f8d5 9000 	ldr.w	r9, [r5]
    3cf0:	f8b9 0002 	ldrh.w	r0, [r9, #2]
    3cf4:	47a0      	blx	r4
    3cf6:	f8a9 0002 	strh.w	r0, [r9, #2]
	seqno = tcphdr->seqno = ntohl(tcphdr->seqno);
    3cfa:	f8d5 9000 	ldr.w	r9, [r5]
    3cfe:	f8d9 0004 	ldr.w	r0, [r9, #4]
    3d02:	47d8      	blx	fp
    3d04:	f8c9 0004 	str.w	r0, [r9, #4]
	ackno = tcphdr->ackno = ntohl(tcphdr->ackno);
    3d08:	f8d5 9000 	ldr.w	r9, [r5]
	seqno = tcphdr->seqno = ntohl(tcphdr->seqno);
    3d0c:	6068      	str	r0, [r5, #4]
	ackno = tcphdr->ackno = ntohl(tcphdr->ackno);
    3d0e:	f8d9 0008 	ldr.w	r0, [r9, #8]
    3d12:	47d8      	blx	fp
    3d14:	f8c9 0008 	str.w	r0, [r9, #8]
	tcphdr->wnd           = ntohs(tcphdr->wnd);
    3d18:	f8d5 9000 	ldr.w	r9, [r5]
	ackno = tcphdr->ackno = ntohl(tcphdr->ackno);
    3d1c:	60e8      	str	r0, [r5, #12]
	tcphdr->wnd           = ntohs(tcphdr->wnd);
    3d1e:	f8b9 000e 	ldrh.w	r0, [r9, #14]
    3d22:	47a0      	blx	r4
	flags  = TCPH_FLAGS(tcphdr);
    3d24:	682b      	ldr	r3, [r5, #0]
	tcphdr->wnd           = ntohs(tcphdr->wnd);
    3d26:	f8a9 000e 	strh.w	r0, [r9, #14]
	flags  = TCPH_FLAGS(tcphdr);
    3d2a:	8998      	ldrh	r0, [r3, #12]
	for (pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
    3d2c:	f8df 91a0 	ldr.w	r9, [pc, #416]	; 3ed0 <tcp_input+0x27c>
	flags  = TCPH_FLAGS(tcphdr);
    3d30:	47a0      	blx	r4
    3d32:	f000 023f 	and.w	r2, r0, #63	; 0x3f
    3d36:	b2c3      	uxtb	r3, r0
    3d38:	722a      	strb	r2, [r5, #8]
	tcplen = p->tot_len + ((flags & (TCP_FIN | TCP_SYN)) ? 1 : 0);
    3d3a:	f010 0003 	ands.w	r0, r0, #3
    3d3e:	8932      	ldrh	r2, [r6, #8]
    3d40:	9203      	str	r2, [sp, #12]
    3d42:	bf18      	it	ne
    3d44:	2001      	movne	r0, #1
    3d46:	4410      	add	r0, r2
    3d48:	b282      	uxth	r2, r0
    3d4a:	9202      	str	r2, [sp, #8]
	for (pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
    3d4c:	f8d9 0000 	ldr.w	r0, [r9]
	tcplen = p->tot_len + ((flags & (TCP_FIN | TCP_SYN)) ? 1 : 0);
    3d50:	822a      	strh	r2, [r5, #16]
		    && ip_addr_cmp(&(pcb->remote_ip), &current_iphdr_src)
    3d52:	f8d8 2000 	ldr.w	r2, [r8]
		if (pcb->remote_port == tcphdr->src && pcb->local_port == tcphdr->dest
    3d56:	f8d5 c000 	ldr.w	ip, [r5]
		    && ip_addr_cmp(&(pcb->local_ip), &current_iphdr_dest)) {
    3d5a:	f8d7 e000 	ldr.w	lr, [r7]
		    && ip_addr_cmp(&(pcb->remote_ip), &current_iphdr_src)
    3d5e:	4611      	mov	r1, r2
	for (pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
    3d60:	4604      	mov	r4, r0
    3d62:	b914      	cbnz	r4, 3d6a <tcp_input+0x116>
		for (pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
    3d64:	4a59      	ldr	r2, [pc, #356]	; (3ecc <tcp_input+0x278>)
    3d66:	6810      	ldr	r0, [r2, #0]
    3d68:	e07c      	b.n	3e64 <tcp_input+0x210>
		if (pcb->remote_port == tcphdr->src && pcb->local_port == tcphdr->dest
    3d6a:	f8b4 b01c 	ldrh.w	fp, [r4, #28]
    3d6e:	f8bc 2000 	ldrh.w	r2, [ip]
    3d72:	4593      	cmp	fp, r2
    3d74:	d138      	bne.n	3de8 <tcp_input+0x194>
    3d76:	f8b4 b01a 	ldrh.w	fp, [r4, #26]
    3d7a:	f8bc 2002 	ldrh.w	r2, [ip, #2]
    3d7e:	4593      	cmp	fp, r2
    3d80:	d132      	bne.n	3de8 <tcp_input+0x194>
		    && ip_addr_cmp(&(pcb->remote_ip), &current_iphdr_src)
    3d82:	6862      	ldr	r2, [r4, #4]
    3d84:	428a      	cmp	r2, r1
    3d86:	d12f      	bne.n	3de8 <tcp_input+0x194>
		    && ip_addr_cmp(&(pcb->local_ip), &current_iphdr_dest)) {
    3d88:	6822      	ldr	r2, [r4, #0]
    3d8a:	4572      	cmp	r2, lr
    3d8c:	d12c      	bne.n	3de8 <tcp_input+0x194>
			if (prev != NULL) {
    3d8e:	f1ba 0f00 	cmp.w	sl, #0
    3d92:	d005      	beq.n	3da0 <tcp_input+0x14c>
				prev->next      = pcb->next;
    3d94:	68e2      	ldr	r2, [r4, #12]
    3d96:	f8ca 200c 	str.w	r2, [sl, #12]
				tcp_active_pcbs = pcb;
    3d9a:	4a4d      	ldr	r2, [pc, #308]	; (3ed0 <tcp_input+0x27c>)
				pcb->next       = tcp_active_pcbs;
    3d9c:	60e0      	str	r0, [r4, #12]
				tcp_active_pcbs = pcb;
    3d9e:	6014      	str	r4, [r2, #0]
		inseg.next   = NULL;
    3da0:	2200      	movs	r2, #0
		inseg.len    = p->tot_len;
    3da2:	9903      	ldr	r1, [sp, #12]
		inseg.next   = NULL;
    3da4:	616a      	str	r2, [r5, #20]
		if (flags & TCP_PSH) {
    3da6:	071b      	lsls	r3, r3, #28
		recv_data  = NULL;
    3da8:	e9c5 c208 	strd	ip, r2, [r5, #32]
		inseg.len    = p->tot_len;
    3dac:	83a9      	strh	r1, [r5, #28]
		inseg.p      = p;
    3dae:	61ae      	str	r6, [r5, #24]
		recv_flags = 0;
    3db0:	f885 2028 	strb.w	r2, [r5, #40]	; 0x28
		if (flags & TCP_PSH) {
    3db4:	d503      	bpl.n	3dbe <tcp_input+0x16a>
			p->flags |= PBUF_FLAG_PUSH;
    3db6:	7b73      	ldrb	r3, [r6, #13]
    3db8:	f043 0301 	orr.w	r3, r3, #1
    3dbc:	7373      	strb	r3, [r6, #13]
		if (pcb->refused_data != NULL) {
    3dbe:	6fa3      	ldr	r3, [r4, #120]	; 0x78
    3dc0:	2b00      	cmp	r3, #0
    3dc2:	f040 80e9 	bne.w	3f98 <tcp_input+0x344>
	if (flags & TCP_RST) {
    3dc6:	7a2a      	ldrb	r2, [r5, #8]
		tcp_input_pcb = pcb;
    3dc8:	62ec      	str	r4, [r5, #44]	; 0x2c
	if (flags & TCP_RST) {
    3dca:	0757      	lsls	r7, r2, #29
    3dcc:	f100 80fc 	bmi.w	3fc8 <tcp_input+0x374>
	if ((flags & TCP_SYN) && (pcb->state != SYN_SENT && pcb->state != SYN_RCVD)) {
    3dd0:	0796      	lsls	r6, r2, #30
			pcb->flags &= ~TF_ACK_DELAY;
    3dd2:	7fa3      	ldrb	r3, [r4, #30]
	if ((flags & TCP_SYN) && (pcb->state != SYN_SENT && pcb->state != SYN_RCVD)) {
    3dd4:	f140 8127 	bpl.w	4026 <tcp_input+0x3d2>
    3dd8:	7e22      	ldrb	r2, [r4, #24]
    3dda:	3a02      	subs	r2, #2
    3ddc:	2a01      	cmp	r2, #1
    3dde:	f240 8122 	bls.w	4026 <tcp_input+0x3d2>
			tcp_ack_now(pcb);
    3de2:	f043 0302 	orr.w	r3, r3, #2
    3de6:	e0ff      	b.n	3fe8 <tcp_input+0x394>
	for (pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
    3de8:	46a2      	mov	sl, r4
    3dea:	68e4      	ldr	r4, [r4, #12]
    3dec:	e7b9      	b.n	3d62 <tcp_input+0x10e>
			if (pcb->remote_port == tcphdr->src && pcb->local_port == tcphdr->dest
    3dee:	f8bc 2000 	ldrh.w	r2, [ip]
    3df2:	f8b0 a01c 	ldrh.w	sl, [r0, #28]
    3df6:	4592      	cmp	sl, r2
    3df8:	d133      	bne.n	3e62 <tcp_input+0x20e>
    3dfa:	f8bc 2002 	ldrh.w	r2, [ip, #2]
    3dfe:	8b44      	ldrh	r4, [r0, #26]
    3e00:	4294      	cmp	r4, r2
    3e02:	d12e      	bne.n	3e62 <tcp_input+0x20e>
			    && ip_addr_cmp(&(pcb->remote_ip), &current_iphdr_src)
    3e04:	6842      	ldr	r2, [r0, #4]
    3e06:	4291      	cmp	r1, r2
    3e08:	d12b      	bne.n	3e62 <tcp_input+0x20e>
			    && ip_addr_cmp(&(pcb->local_ip), &current_iphdr_dest)) {
    3e0a:	6802      	ldr	r2, [r0, #0]
    3e0c:	4596      	cmp	lr, r2
    3e0e:	d128      	bne.n	3e62 <tcp_input+0x20e>
	if (flags & TCP_RST) {
    3e10:	075a      	lsls	r2, r3, #29
    3e12:	d420      	bmi.n	3e56 <tcp_input+0x202>
	if (flags & TCP_SYN) {
    3e14:	079f      	lsls	r7, r3, #30
    3e16:	d511      	bpl.n	3e3c <tcp_input+0x1e8>
		if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, pcb->rcv_nxt + pcb->rcv_wnd)) {
    3e18:	686f      	ldr	r7, [r5, #4]
    3e1a:	6a83      	ldr	r3, [r0, #40]	; 0x28
    3e1c:	1afb      	subs	r3, r7, r3
    3e1e:	d412      	bmi.n	3e46 <tcp_input+0x1f2>
    3e20:	8d82      	ldrh	r2, [r0, #44]	; 0x2c
    3e22:	1a9b      	subs	r3, r3, r2
    3e24:	2b00      	cmp	r3, #0
    3e26:	dc0e      	bgt.n	3e46 <tcp_input+0x1f2>
			tcp_rst(ackno, seqno + tcplen, ip_current_dest_addr(), ip_current_src_addr(), tcphdr->dest, tcphdr->src);
    3e28:	9902      	ldr	r1, [sp, #8]
    3e2a:	4b2a      	ldr	r3, [pc, #168]	; (3ed4 <tcp_input+0x280>)
    3e2c:	4a23      	ldr	r2, [pc, #140]	; (3ebc <tcp_input+0x268>)
    3e2e:	e9cd 4a00 	strd	r4, sl, [sp]
    3e32:	4439      	add	r1, r7
			tcp_rst(ackno, seqno + tcplen, ip_current_dest_addr(), ip_current_src_addr(), tcphdr->dest, tcphdr->src);
    3e34:	68e8      	ldr	r0, [r5, #12]
    3e36:	4c28      	ldr	r4, [pc, #160]	; (3ed8 <tcp_input+0x284>)
    3e38:	47a0      	blx	r4
    3e3a:	e00c      	b.n	3e56 <tcp_input+0x202>
	} else if (flags & TCP_FIN) {
    3e3c:	07d9      	lsls	r1, r3, #31
		pcb->tmr = tcp_ticks;
    3e3e:	bf42      	ittt	mi
    3e40:	4b26      	ldrmi	r3, [pc, #152]	; (3edc <tcp_input+0x288>)
    3e42:	681b      	ldrmi	r3, [r3, #0]
    3e44:	6243      	strmi	r3, [r0, #36]	; 0x24
	if ((tcplen > 0)) {
    3e46:	9b02      	ldr	r3, [sp, #8]
    3e48:	b12b      	cbz	r3, 3e56 <tcp_input+0x202>
		pcb->flags |= TF_ACK_NOW;
    3e4a:	7f83      	ldrb	r3, [r0, #30]
    3e4c:	f043 0302 	orr.w	r3, r3, #2
    3e50:	7783      	strb	r3, [r0, #30]
		return tcp_output(pcb);
    3e52:	4b23      	ldr	r3, [pc, #140]	; (3ee0 <tcp_input+0x28c>)
    3e54:	4798      	blx	r3
	pbuf_free(p);
    3e56:	4b23      	ldr	r3, [pc, #140]	; (3ee4 <tcp_input+0x290>)
    3e58:	4630      	mov	r0, r6
}
    3e5a:	b005      	add	sp, #20
    3e5c:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	pbuf_free(p);
    3e60:	4718      	bx	r3
		for (pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
    3e62:	68c0      	ldr	r0, [r0, #12]
    3e64:	2800      	cmp	r0, #0
    3e66:	d1c2      	bne.n	3dee <tcp_input+0x19a>
		for (lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
    3e68:	4a1f      	ldr	r2, [pc, #124]	; (3ee8 <tcp_input+0x294>)
    3e6a:	6814      	ldr	r4, [r2, #0]
    3e6c:	46a2      	mov	sl, r4
    3e6e:	f1ba 0f00 	cmp.w	sl, #0
    3e72:	d10f      	bne.n	3e94 <tcp_input+0x240>
		if (!(TCPH_FLAGS(tcphdr) & TCP_RST)) {
    3e74:	f8bc 000c 	ldrh.w	r0, [ip, #12]
    3e78:	4b13      	ldr	r3, [pc, #76]	; (3ec8 <tcp_input+0x274>)
    3e7a:	4798      	blx	r3
    3e7c:	0742      	lsls	r2, r0, #29
    3e7e:	d4ea      	bmi.n	3e56 <tcp_input+0x202>
			tcp_rst(ackno, seqno + tcplen, ip_current_dest_addr(), ip_current_src_addr(), tcphdr->dest, tcphdr->src);
    3e80:	682b      	ldr	r3, [r5, #0]
    3e82:	8a28      	ldrh	r0, [r5, #16]
    3e84:	881a      	ldrh	r2, [r3, #0]
    3e86:	9201      	str	r2, [sp, #4]
    3e88:	885b      	ldrh	r3, [r3, #2]
    3e8a:	9300      	str	r3, [sp, #0]
    3e8c:	6869      	ldr	r1, [r5, #4]
    3e8e:	4b11      	ldr	r3, [pc, #68]	; (3ed4 <tcp_input+0x280>)
    3e90:	4a0a      	ldr	r2, [pc, #40]	; (3ebc <tcp_input+0x268>)
    3e92:	e2e9      	b.n	4468 <tcp_input+0x814>
			if (lpcb->local_port == tcphdr->dest) {
    3e94:	f8bc b002 	ldrh.w	fp, [ip, #2]
    3e98:	f8ba 201a 	ldrh.w	r2, [sl, #26]
    3e9c:	455a      	cmp	r2, fp
    3e9e:	d107      	bne.n	3eb0 <tcp_input+0x25c>
				if (ip_addr_cmp(&(lpcb->local_ip), &current_iphdr_dest) || ip_addr_isany(&(lpcb->local_ip))) {
    3ea0:	f8da 2000 	ldr.w	r2, [sl]
    3ea4:	4596      	cmp	lr, r2
    3ea6:	f000 82c7 	beq.w	4438 <tcp_input+0x7e4>
    3eaa:	2a00      	cmp	r2, #0
    3eac:	f000 82c4 	beq.w	4438 <tcp_input+0x7e4>
		for (lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
    3eb0:	4650      	mov	r0, sl
    3eb2:	f8da a00c 	ldr.w	sl, [sl, #12]
    3eb6:	e7da      	b.n	3e6e <tcp_input+0x21a>
    3eb8:	2000a4e0 	.word	0x2000a4e0
    3ebc:	20011104 	.word	0x20011104
    3ec0:	00008a1f 	.word	0x00008a1f
    3ec4:	00008389 	.word	0x00008389
    3ec8:	00000d67 	.word	0x00000d67
    3ecc:	20014958 	.word	0x20014958
    3ed0:	20014950 	.word	0x20014950
    3ed4:	20011108 	.word	0x20011108
    3ed8:	00002725 	.word	0x00002725
    3edc:	20014948 	.word	0x20014948
    3ee0:	000024a1 	.word	0x000024a1
    3ee4:	000030e1 	.word	0x000030e1
    3ee8:	20014944 	.word	0x20014944
    3eec:	00003089 	.word	0x00003089
    3ef0:	00000d71 	.word	0x00000d71
	} else if (flags & TCP_SYN) {
    3ef4:	079b      	lsls	r3, r3, #30
    3ef6:	d5ae      	bpl.n	3e56 <tcp_input+0x202>
		npcb = tcp_alloc(pcb->prio);
    3ef8:	f89a 0019 	ldrb.w	r0, [sl, #25]
    3efc:	4b98      	ldr	r3, [pc, #608]	; (4160 <tcp_input+0x50c>)
    3efe:	4798      	blx	r3
		if (npcb == NULL) {
    3f00:	4683      	mov	fp, r0
    3f02:	2800      	cmp	r0, #0
    3f04:	d0a7      	beq.n	3e56 <tcp_input+0x202>
		ip_addr_copy(npcb->local_ip, current_iphdr_dest);
    3f06:	683b      	ldr	r3, [r7, #0]
    3f08:	6003      	str	r3, [r0, #0]
		npcb->remote_port        = tcphdr->src;
    3f0a:	682a      	ldr	r2, [r5, #0]
		npcb->local_port = pcb->local_port;
    3f0c:	f8ba 301a 	ldrh.w	r3, [sl, #26]
    3f10:	8343      	strh	r3, [r0, #26]
		ip_addr_copy(npcb->remote_ip, current_iphdr_src);
    3f12:	f8d8 3000 	ldr.w	r3, [r8]
		npcb->remote_port        = tcphdr->src;
    3f16:	7851      	ldrb	r1, [r2, #1]
		ip_addr_copy(npcb->remote_ip, current_iphdr_src);
    3f18:	6043      	str	r3, [r0, #4]
		npcb->remote_port        = tcphdr->src;
    3f1a:	7813      	ldrb	r3, [r2, #0]
    3f1c:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
    3f20:	8383      	strh	r3, [r0, #28]
		npcb->state              = SYN_RCVD;
    3f22:	2303      	movs	r3, #3
    3f24:	7603      	strb	r3, [r0, #24]
		npcb->rcv_nxt            = seqno + 1;
    3f26:	686b      	ldr	r3, [r5, #4]
    3f28:	1c59      	adds	r1, r3, #1
    3f2a:	6281      	str	r1, [r0, #40]	; 0x28
		npcb->rcv_ann_right_edge = npcb->rcv_nxt;
    3f2c:	6301      	str	r1, [r0, #48]	; 0x30
		npcb->snd_wl1            = seqno - 1; /* initialise to seqno-1 to force window update */
    3f2e:	3b01      	subs	r3, #1
		npcb->snd_wnd            = tcphdr->wnd;
    3f30:	89d2      	ldrh	r2, [r2, #14]
		npcb->snd_wl1            = seqno - 1; /* initialise to seqno-1 to force window update */
    3f32:	6543      	str	r3, [r0, #84]	; 0x54
		npcb->callback_arg       = pcb->callback_arg;
    3f34:	f8da 3010 	ldr.w	r3, [sl, #16]
    3f38:	6103      	str	r3, [r0, #16]
		npcb->accept = pcb->accept;
    3f3a:	f8da 3014 	ldr.w	r3, [sl, #20]
		npcb->snd_wnd            = tcphdr->wnd;
    3f3e:	f8a0 2060 	strh.w	r2, [r0, #96]	; 0x60
		npcb->snd_wnd_max        = tcphdr->wnd;
    3f42:	f8a0 2062 	strh.w	r2, [r0, #98]	; 0x62
		npcb->ssthresh           = npcb->snd_wnd;
    3f46:	f8a0 204e 	strh.w	r2, [r0, #78]	; 0x4e
		npcb->accept = pcb->accept;
    3f4a:	6143      	str	r3, [r0, #20]
		npcb->so_options = pcb->so_options & SOF_INHERITED;
    3f4c:	f89a 3008 	ldrb.w	r3, [sl, #8]
    3f50:	f023 0373 	bic.w	r3, r3, #115	; 0x73
    3f54:	7203      	strb	r3, [r0, #8]
		TCP_REG_ACTIVE(npcb);
    3f56:	f8d9 3000 	ldr.w	r3, [r9]
    3f5a:	60c3      	str	r3, [r0, #12]
    3f5c:	4b81      	ldr	r3, [pc, #516]	; (4164 <tcp_input+0x510>)
    3f5e:	f8c9 0000 	str.w	r0, [r9]
    3f62:	4798      	blx	r3
    3f64:	4b80      	ldr	r3, [pc, #512]	; (4168 <tcp_input+0x514>)
    3f66:	2201      	movs	r2, #1
    3f68:	701a      	strb	r2, [r3, #0]
		tcp_parseopt(npcb);
    3f6a:	4658      	mov	r0, fp
    3f6c:	4b7f      	ldr	r3, [pc, #508]	; (416c <tcp_input+0x518>)
    3f6e:	4798      	blx	r3
		npcb->mss = tcp_eff_send_mss(npcb->mss, &(npcb->remote_ip));
    3f70:	4b7f      	ldr	r3, [pc, #508]	; (4170 <tcp_input+0x51c>)
    3f72:	f8bb 0036 	ldrh.w	r0, [fp, #54]	; 0x36
    3f76:	f10b 0104 	add.w	r1, fp, #4
    3f7a:	4798      	blx	r3
		rc = tcp_enqueue_flags(npcb, TCP_SYN | TCP_ACK);
    3f7c:	4b7d      	ldr	r3, [pc, #500]	; (4174 <tcp_input+0x520>)
		npcb->mss = tcp_eff_send_mss(npcb->mss, &(npcb->remote_ip));
    3f7e:	f8ab 0036 	strh.w	r0, [fp, #54]	; 0x36
		rc = tcp_enqueue_flags(npcb, TCP_SYN | TCP_ACK);
    3f82:	2112      	movs	r1, #18
    3f84:	4658      	mov	r0, fp
    3f86:	4798      	blx	r3
		if (rc != ERR_OK) {
    3f88:	b120      	cbz	r0, 3f94 <tcp_input+0x340>
			tcp_abandon(npcb, 0);
    3f8a:	4b7b      	ldr	r3, [pc, #492]	; (4178 <tcp_input+0x524>)
    3f8c:	4621      	mov	r1, r4
    3f8e:	4658      	mov	r0, fp
    3f90:	4798      	blx	r3
			return rc;
    3f92:	e760      	b.n	3e56 <tcp_input+0x202>
		return tcp_output(npcb);
    3f94:	4658      	mov	r0, fp
    3f96:	e75c      	b.n	3e52 <tcp_input+0x1fe>
			if ((tcp_process_refused_data(pcb) == ERR_ABRT) || ((pcb->refused_data != NULL) && (tcplen > 0))) {
    3f98:	4b78      	ldr	r3, [pc, #480]	; (417c <tcp_input+0x528>)
    3f9a:	4620      	mov	r0, r4
    3f9c:	4798      	blx	r3
    3f9e:	300a      	adds	r0, #10
    3fa0:	d007      	beq.n	3fb2 <tcp_input+0x35e>
    3fa2:	6fa3      	ldr	r3, [r4, #120]	; 0x78
    3fa4:	2b00      	cmp	r3, #0
    3fa6:	f43f af0e 	beq.w	3dc6 <tcp_input+0x172>
    3faa:	8a2b      	ldrh	r3, [r5, #16]
    3fac:	2b00      	cmp	r3, #0
    3fae:	f43f af0a 	beq.w	3dc6 <tcp_input+0x172>
		if (inseg.p != NULL) {
    3fb2:	69a8      	ldr	r0, [r5, #24]
		tcp_input_pcb = NULL;
    3fb4:	2400      	movs	r4, #0
    3fb6:	62ec      	str	r4, [r5, #44]	; 0x2c
		recv_data     = NULL;
    3fb8:	626c      	str	r4, [r5, #36]	; 0x24
		if (inseg.p != NULL) {
    3fba:	b110      	cbz	r0, 3fc2 <tcp_input+0x36e>
			pbuf_free(inseg.p);
    3fbc:	4b70      	ldr	r3, [pc, #448]	; (4180 <tcp_input+0x52c>)
    3fbe:	4798      	blx	r3
			inseg.p = NULL;
    3fc0:	61ac      	str	r4, [r5, #24]
}
    3fc2:	b005      	add	sp, #20
    3fc4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		if (pcb->state == SYN_SENT) {
    3fc8:	7e23      	ldrb	r3, [r4, #24]
    3fca:	2b02      	cmp	r3, #2
    3fcc:	d10e      	bne.n	3fec <tcp_input+0x398>
			if (ackno == pcb->snd_nxt) {
    3fce:	6d22      	ldr	r2, [r4, #80]	; 0x50
    3fd0:	68eb      	ldr	r3, [r5, #12]
    3fd2:	429a      	cmp	r2, r3
    3fd4:	d112      	bne.n	3ffc <tcp_input+0x3a8>
			recv_flags |= TF_RESET;
    3fd6:	f895 3028 	ldrb.w	r3, [r5, #40]	; 0x28
    3fda:	f043 0308 	orr.w	r3, r3, #8
    3fde:	f885 3028 	strb.w	r3, [r5, #40]	; 0x28
			pcb->flags &= ~TF_ACK_DELAY;
    3fe2:	7fa3      	ldrb	r3, [r4, #30]
    3fe4:	f023 0301 	bic.w	r3, r3, #1
			tcp_ack_now(pcb);
    3fe8:	77a3      	strb	r3, [r4, #30]
		if (err != ERR_ABRT) {
    3fea:	e007      	b.n	3ffc <tcp_input+0x3a8>
			if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, pcb->rcv_nxt + pcb->rcv_wnd)) {
    3fec:	686b      	ldr	r3, [r5, #4]
    3fee:	6aa2      	ldr	r2, [r4, #40]	; 0x28
    3ff0:	1a9b      	subs	r3, r3, r2
    3ff2:	d403      	bmi.n	3ffc <tcp_input+0x3a8>
    3ff4:	8da2      	ldrh	r2, [r4, #44]	; 0x2c
    3ff6:	1a9b      	subs	r3, r3, r2
    3ff8:	2b00      	cmp	r3, #0
    3ffa:	ddec      	ble.n	3fd6 <tcp_input+0x382>
			if (recv_flags & TF_RESET) {
    3ffc:	f895 3028 	ldrb.w	r3, [r5, #40]	; 0x28
    4000:	071f      	lsls	r7, r3, #28
    4002:	f140 81a3 	bpl.w	434c <tcp_input+0x6f8>
				TCP_EVENT_ERR(pcb->errf, pcb->callback_arg, ERR_RST);
    4006:	f8d4 308c 	ldr.w	r3, [r4, #140]	; 0x8c
    400a:	b11b      	cbz	r3, 4014 <tcp_input+0x3c0>
    400c:	f06f 010a 	mvn.w	r1, #10
					TCP_EVENT_ERR(pcb->errf, pcb->callback_arg, ERR_CLSD);
    4010:	6920      	ldr	r0, [r4, #16]
    4012:	4798      	blx	r3
				tcp_pcb_remove(&tcp_active_pcbs, pcb);
    4014:	4621      	mov	r1, r4
    4016:	485b      	ldr	r0, [pc, #364]	; (4184 <tcp_input+0x530>)
    4018:	4b5b      	ldr	r3, [pc, #364]	; (4188 <tcp_input+0x534>)
    401a:	4798      	blx	r3
				memp_free(MEMP_TCP_PCB, pcb);
    401c:	4b5b      	ldr	r3, [pc, #364]	; (418c <tcp_input+0x538>)
    401e:	4621      	mov	r1, r4
    4020:	2001      	movs	r0, #1
    4022:	4798      	blx	r3
    4024:	e7c5      	b.n	3fb2 <tcp_input+0x35e>
	if ((pcb->flags & TF_RXCLOSED) == 0) {
    4026:	06d8      	lsls	r0, r3, #27
		pcb->tmr = tcp_ticks;
    4028:	bf5e      	ittt	pl
    402a:	4b59      	ldrpl	r3, [pc, #356]	; (4190 <tcp_input+0x53c>)
    402c:	681b      	ldrpl	r3, [r3, #0]
    402e:	6263      	strpl	r3, [r4, #36]	; 0x24
	pcb->keep_cnt_sent = 0;
    4030:	2300      	movs	r3, #0
    4032:	f884 3096 	strb.w	r3, [r4, #150]	; 0x96
	tcp_parseopt(pcb);
    4036:	4620      	mov	r0, r4
    4038:	4b4c      	ldr	r3, [pc, #304]	; (416c <tcp_input+0x518>)
    403a:	4798      	blx	r3
	switch (pcb->state) {
    403c:	7e23      	ldrb	r3, [r4, #24]
    403e:	3b02      	subs	r3, #2
    4040:	2b07      	cmp	r3, #7
    4042:	d8db      	bhi.n	3ffc <tcp_input+0x3a8>
    4044:	e8df f013 	tbh	[pc, r3, lsl #1]
    4048:	006f0008 	.word	0x006f0008
    404c:	00ec00e8 	.word	0x00ec00e8
    4050:	00e80134 	.word	0x00e80134
    4054:	01700152 	.word	0x01700152
		if ((flags & TCP_ACK) && (flags & TCP_SYN) && ackno == ntohl(pcb->unacked->tcphdr->seqno) + 1) {
    4058:	7a2b      	ldrb	r3, [r5, #8]
    405a:	f003 0312 	and.w	r3, r3, #18
    405e:	2b12      	cmp	r3, #18
    4060:	d14f      	bne.n	4102 <tcp_input+0x4ae>
    4062:	6f23      	ldr	r3, [r4, #112]	; 0x70
    4064:	68db      	ldr	r3, [r3, #12]
    4066:	6858      	ldr	r0, [r3, #4]
    4068:	4b4a      	ldr	r3, [pc, #296]	; (4194 <tcp_input+0x540>)
    406a:	4798      	blx	r3
    406c:	68eb      	ldr	r3, [r5, #12]
    406e:	3001      	adds	r0, #1
    4070:	4298      	cmp	r0, r3
    4072:	d146      	bne.n	4102 <tcp_input+0x4ae>
			pcb->snd_buf++;
    4074:	f8b4 3066 	ldrh.w	r3, [r4, #102]	; 0x66
			pcb->lastack            = ackno;
    4078:	64a0      	str	r0, [r4, #72]	; 0x48
			pcb->snd_buf++;
    407a:	3301      	adds	r3, #1
    407c:	f8a4 3066 	strh.w	r3, [r4, #102]	; 0x66
			pcb->rcv_nxt            = seqno + 1;
    4080:	686b      	ldr	r3, [r5, #4]
			pcb->mss = tcp_eff_send_mss(pcb->mss, &(pcb->remote_ip));
    4082:	8ee0      	ldrh	r0, [r4, #54]	; 0x36
			pcb->rcv_nxt            = seqno + 1;
    4084:	1c5a      	adds	r2, r3, #1
    4086:	62a2      	str	r2, [r4, #40]	; 0x28
			pcb->rcv_ann_right_edge = pcb->rcv_nxt;
    4088:	6322      	str	r2, [r4, #48]	; 0x30
			pcb->snd_wnd            = tcphdr->wnd;
    408a:	682a      	ldr	r2, [r5, #0]
			pcb->snd_wl1            = seqno - 1; /* initialise to seqno - 1 to force window update */
    408c:	3b01      	subs	r3, #1
			pcb->snd_wnd            = tcphdr->wnd;
    408e:	89d2      	ldrh	r2, [r2, #14]
			pcb->snd_wl1            = seqno - 1; /* initialise to seqno - 1 to force window update */
    4090:	6563      	str	r3, [r4, #84]	; 0x54
			pcb->state              = ESTABLISHED;
    4092:	2304      	movs	r3, #4
			pcb->mss = tcp_eff_send_mss(pcb->mss, &(pcb->remote_ip));
    4094:	18e1      	adds	r1, r4, r3
			pcb->snd_wnd            = tcphdr->wnd;
    4096:	f8a4 2060 	strh.w	r2, [r4, #96]	; 0x60
			pcb->snd_wnd_max        = tcphdr->wnd;
    409a:	f8a4 2062 	strh.w	r2, [r4, #98]	; 0x62
			pcb->state              = ESTABLISHED;
    409e:	7623      	strb	r3, [r4, #24]
			pcb->mss = tcp_eff_send_mss(pcb->mss, &(pcb->remote_ip));
    40a0:	4b33      	ldr	r3, [pc, #204]	; (4170 <tcp_input+0x51c>)
    40a2:	4798      	blx	r3
			pcb->ssthresh = pcb->mss * 10;
    40a4:	eb00 0380 	add.w	r3, r0, r0, lsl #2
    40a8:	005b      	lsls	r3, r3, #1
    40aa:	f8a4 304e 	strh.w	r3, [r4, #78]	; 0x4e
			pcb->cwnd = ((pcb->cwnd == 1) ? (pcb->mss * 2) : pcb->mss);
    40ae:	f8b4 304c 	ldrh.w	r3, [r4, #76]	; 0x4c
			pcb->mss = tcp_eff_send_mss(pcb->mss, &(pcb->remote_ip));
    40b2:	86e0      	strh	r0, [r4, #54]	; 0x36
			pcb->cwnd = ((pcb->cwnd == 1) ? (pcb->mss * 2) : pcb->mss);
    40b4:	2b01      	cmp	r3, #1
    40b6:	bf08      	it	eq
    40b8:	0040      	lsleq	r0, r0, #1
			--pcb->snd_queuelen;
    40ba:	f8b4 3068 	ldrh.w	r3, [r4, #104]	; 0x68
			pcb->cwnd = ((pcb->cwnd == 1) ? (pcb->mss * 2) : pcb->mss);
    40be:	bf08      	it	eq
    40c0:	b280      	uxtheq	r0, r0
    40c2:	f8a4 004c 	strh.w	r0, [r4, #76]	; 0x4c
			rseg         = pcb->unacked;
    40c6:	6f20      	ldr	r0, [r4, #112]	; 0x70
			--pcb->snd_queuelen;
    40c8:	3b01      	subs	r3, #1
    40ca:	f8a4 3068 	strh.w	r3, [r4, #104]	; 0x68
			pcb->unacked = rseg->next;
    40ce:	6803      	ldr	r3, [r0, #0]
    40d0:	6723      	str	r3, [r4, #112]	; 0x70
			tcp_seg_free(rseg);
    40d2:	4b31      	ldr	r3, [pc, #196]	; (4198 <tcp_input+0x544>)
    40d4:	4798      	blx	r3
			if (pcb->unacked == NULL)
    40d6:	6f23      	ldr	r3, [r4, #112]	; 0x70
    40d8:	b93b      	cbnz	r3, 40ea <tcp_input+0x496>
				pcb->rtime = -1;
    40da:	f64f 73ff 	movw	r3, #65535	; 0xffff
    40de:	86a3      	strh	r3, [r4, #52]	; 0x34
			TCP_EVENT_CONNECTED(pcb, ERR_OK, err);
    40e0:	f8d4 3084 	ldr.w	r3, [r4, #132]	; 0x84
    40e4:	b933      	cbnz	r3, 40f4 <tcp_input+0x4a0>
			tcp_ack_now(pcb);
    40e6:	7fa3      	ldrb	r3, [r4, #30]
    40e8:	e67b      	b.n	3de2 <tcp_input+0x18e>
				pcb->rtime = 0;
    40ea:	2300      	movs	r3, #0
    40ec:	86a3      	strh	r3, [r4, #52]	; 0x34
				pcb->nrtx  = 0;
    40ee:	f884 3046 	strb.w	r3, [r4, #70]	; 0x46
    40f2:	e7f5      	b.n	40e0 <tcp_input+0x48c>
			TCP_EVENT_CONNECTED(pcb, ERR_OK, err);
    40f4:	6920      	ldr	r0, [r4, #16]
    40f6:	2200      	movs	r2, #0
    40f8:	4621      	mov	r1, r4
    40fa:	4798      	blx	r3
			if (err == ERR_ABRT) {
    40fc:	300a      	adds	r0, #10
    40fe:	d1f2      	bne.n	40e6 <tcp_input+0x492>
    4100:	e757      	b.n	3fb2 <tcp_input+0x35e>
		else if (flags & TCP_ACK) {
    4102:	7a2b      	ldrb	r3, [r5, #8]
    4104:	06d9      	lsls	r1, r3, #27
    4106:	f57f af79 	bpl.w	3ffc <tcp_input+0x3a8>
			tcp_rst(ackno, seqno + tcplen, ip_current_dest_addr(), ip_current_src_addr(), tcphdr->dest, tcphdr->src);
    410a:	682b      	ldr	r3, [r5, #0]
    410c:	8a28      	ldrh	r0, [r5, #16]
    410e:	881a      	ldrh	r2, [r3, #0]
    4110:	9201      	str	r2, [sp, #4]
    4112:	6869      	ldr	r1, [r5, #4]
    4114:	885b      	ldrh	r3, [r3, #2]
    4116:	9300      	str	r3, [sp, #0]
    4118:	4401      	add	r1, r0
    411a:	4b20      	ldr	r3, [pc, #128]	; (419c <tcp_input+0x548>)
    411c:	4a20      	ldr	r2, [pc, #128]	; (41a0 <tcp_input+0x54c>)
    411e:	68e8      	ldr	r0, [r5, #12]
				tcp_rst(
    4120:	4e20      	ldr	r6, [pc, #128]	; (41a4 <tcp_input+0x550>)
    4122:	47b0      	blx	r6
		if (err != ERR_ABRT) {
    4124:	e76a      	b.n	3ffc <tcp_input+0x3a8>
		if (flags & TCP_ACK) {
    4126:	7a2b      	ldrb	r3, [r5, #8]
    4128:	06da      	lsls	r2, r3, #27
    412a:	d568      	bpl.n	41fe <tcp_input+0x5aa>
			if (TCP_SEQ_BETWEEN(ackno, pcb->lastack + 1, pcb->snd_nxt)) {
    412c:	6ca3      	ldr	r3, [r4, #72]	; 0x48
    412e:	68e8      	ldr	r0, [r5, #12]
    4130:	43db      	mvns	r3, r3
    4132:	42c3      	cmn	r3, r0
    4134:	d458      	bmi.n	41e8 <tcp_input+0x594>
    4136:	6d23      	ldr	r3, [r4, #80]	; 0x50
    4138:	1ac3      	subs	r3, r0, r3
    413a:	2b00      	cmp	r3, #0
    413c:	dc54      	bgt.n	41e8 <tcp_input+0x594>
				pcb->state = ESTABLISHED;
    413e:	2304      	movs	r3, #4
    4140:	7623      	strb	r3, [r4, #24]
				TCP_EVENT_ACCEPT(pcb, ERR_OK, err);
    4142:	6963      	ldr	r3, [r4, #20]
    4144:	b91b      	cbnz	r3, 414e <tcp_input+0x4fa>
						tcp_abort(pcb);
    4146:	4b18      	ldr	r3, [pc, #96]	; (41a8 <tcp_input+0x554>)
    4148:	4620      	mov	r0, r4
    414a:	4798      	blx	r3
						goto aborted;
    414c:	e731      	b.n	3fb2 <tcp_input+0x35e>
				TCP_EVENT_ACCEPT(pcb, ERR_OK, err);
    414e:	6920      	ldr	r0, [r4, #16]
    4150:	2200      	movs	r2, #0
    4152:	4621      	mov	r1, r4
    4154:	4798      	blx	r3
				if (err != ERR_OK) {
    4156:	b348      	cbz	r0, 41ac <tcp_input+0x558>
					if (err != ERR_ABRT) {
    4158:	300a      	adds	r0, #10
    415a:	f43f af2a 	beq.w	3fb2 <tcp_input+0x35e>
    415e:	e7f2      	b.n	4146 <tcp_input+0x4f2>
    4160:	0000729d 	.word	0x0000729d
    4164:	000010a1 	.word	0x000010a1
    4168:	20014954 	.word	0x20014954
    416c:	000033dd 	.word	0x000033dd
    4170:	000073a1 	.word	0x000073a1
    4174:	00002339 	.word	0x00002339
    4178:	000071cd 	.word	0x000071cd
    417c:	00007075 	.word	0x00007075
    4180:	000030e1 	.word	0x000030e1
    4184:	20014950 	.word	0x20014950
    4188:	00006e5d 	.word	0x00006e5d
    418c:	00004c21 	.word	0x00004c21
    4190:	20014948 	.word	0x20014948
    4194:	00000d71 	.word	0x00000d71
    4198:	00006ac5 	.word	0x00006ac5
    419c:	20011108 	.word	0x20011108
    41a0:	20011104 	.word	0x20011104
    41a4:	00002725 	.word	0x00002725
    41a8:	00007279 	.word	0x00007279
				tcp_receive(pcb);
    41ac:	4b95      	ldr	r3, [pc, #596]	; (4404 <tcp_input+0x7b0>)
				old_cwnd = pcb->cwnd;
    41ae:	f8b4 604c 	ldrh.w	r6, [r4, #76]	; 0x4c
				tcp_receive(pcb);
    41b2:	4620      	mov	r0, r4
    41b4:	4798      	blx	r3
				if (pcb->acked != 0) {
    41b6:	f8b4 3064 	ldrh.w	r3, [r4, #100]	; 0x64
    41ba:	b113      	cbz	r3, 41c2 <tcp_input+0x56e>
					pcb->acked--;
    41bc:	3b01      	subs	r3, #1
    41be:	f8a4 3064 	strh.w	r3, [r4, #100]	; 0x64
				pcb->cwnd = ((old_cwnd == 1) ? (pcb->mss * 2) : pcb->mss);
    41c2:	8ee3      	ldrh	r3, [r4, #54]	; 0x36
    41c4:	2e01      	cmp	r6, #1
    41c6:	bf04      	itt	eq
    41c8:	005b      	lsleq	r3, r3, #1
    41ca:	b29b      	uxtheq	r3, r3
    41cc:	f8a4 304c 	strh.w	r3, [r4, #76]	; 0x4c
		if (recv_flags & TF_GOT_FIN) { /* passive close */
    41d0:	f895 3028 	ldrb.w	r3, [r5, #40]	; 0x28
    41d4:	069e      	lsls	r6, r3, #26
    41d6:	f57f af11 	bpl.w	3ffc <tcp_input+0x3a8>
			tcp_ack_now(pcb);
    41da:	7fa3      	ldrb	r3, [r4, #30]
    41dc:	f043 0302 	orr.w	r3, r3, #2
    41e0:	77a3      	strb	r3, [r4, #30]
			pcb->state = CLOSE_WAIT;
    41e2:	2307      	movs	r3, #7
			pcb->state = FIN_WAIT_2;
    41e4:	7623      	strb	r3, [r4, #24]
		if (err != ERR_ABRT) {
    41e6:	e709      	b.n	3ffc <tcp_input+0x3a8>
				    ackno, seqno + tcplen, ip_current_dest_addr(), ip_current_src_addr(), tcphdr->dest, tcphdr->src);
    41e8:	682b      	ldr	r3, [r5, #0]
				tcp_rst(
    41ea:	8a2e      	ldrh	r6, [r5, #16]
    41ec:	881a      	ldrh	r2, [r3, #0]
    41ee:	9201      	str	r2, [sp, #4]
    41f0:	6869      	ldr	r1, [r5, #4]
    41f2:	885b      	ldrh	r3, [r3, #2]
    41f4:	9300      	str	r3, [sp, #0]
    41f6:	4a84      	ldr	r2, [pc, #528]	; (4408 <tcp_input+0x7b4>)
    41f8:	4b84      	ldr	r3, [pc, #528]	; (440c <tcp_input+0x7b8>)
    41fa:	4431      	add	r1, r6
    41fc:	e790      	b.n	4120 <tcp_input+0x4cc>
		} else if ((flags & TCP_SYN) && (seqno == pcb->rcv_nxt - 1)) {
    41fe:	079f      	lsls	r7, r3, #30
    4200:	f57f aefc 	bpl.w	3ffc <tcp_input+0x3a8>
    4204:	6aa3      	ldr	r3, [r4, #40]	; 0x28
    4206:	686a      	ldr	r2, [r5, #4]
    4208:	3b01      	subs	r3, #1
    420a:	4293      	cmp	r3, r2
    420c:	f47f aef6 	bne.w	3ffc <tcp_input+0x3a8>
			tcp_rexmit(pcb);
    4210:	4b7f      	ldr	r3, [pc, #508]	; (4410 <tcp_input+0x7bc>)
    4212:	4620      	mov	r0, r4
    4214:	4798      	blx	r3
		if (err != ERR_ABRT) {
    4216:	e6f1      	b.n	3ffc <tcp_input+0x3a8>
		tcp_receive(pcb);
    4218:	4b7a      	ldr	r3, [pc, #488]	; (4404 <tcp_input+0x7b0>)
    421a:	4620      	mov	r0, r4
    421c:	4798      	blx	r3
    421e:	e7d7      	b.n	41d0 <tcp_input+0x57c>
		tcp_receive(pcb);
    4220:	4b78      	ldr	r3, [pc, #480]	; (4404 <tcp_input+0x7b0>)
    4222:	4620      	mov	r0, r4
    4224:	4798      	blx	r3
		if (recv_flags & TF_GOT_FIN) {
    4226:	f895 3028 	ldrb.w	r3, [r5, #40]	; 0x28
    422a:	f013 0f20 	tst.w	r3, #32
    422e:	7a2b      	ldrb	r3, [r5, #8]
    4230:	d034      	beq.n	429c <tcp_input+0x648>
			if ((flags & TCP_ACK) && (ackno == pcb->snd_nxt)) {
    4232:	f013 0f10 	tst.w	r3, #16
    4236:	7fa3      	ldrb	r3, [r4, #30]
				tcp_ack_now(pcb);
    4238:	f043 0302 	orr.w	r3, r3, #2
			if ((flags & TCP_ACK) && (ackno == pcb->snd_nxt)) {
    423c:	d02b      	beq.n	4296 <tcp_input+0x642>
    423e:	6d21      	ldr	r1, [r4, #80]	; 0x50
    4240:	68ea      	ldr	r2, [r5, #12]
    4242:	4291      	cmp	r1, r2
    4244:	d127      	bne.n	4296 <tcp_input+0x642>
				tcp_ack_now(pcb);
    4246:	77a3      	strb	r3, [r4, #30]
				tcp_pcb_purge(pcb);
    4248:	4620      	mov	r0, r4
    424a:	4b72      	ldr	r3, [pc, #456]	; (4414 <tcp_input+0x7c0>)
    424c:	4798      	blx	r3
				TCP_RMV_ACTIVE(pcb);
    424e:	4a72      	ldr	r2, [pc, #456]	; (4418 <tcp_input+0x7c4>)
    4250:	6813      	ldr	r3, [r2, #0]
    4252:	429c      	cmp	r4, r3
    4254:	d102      	bne.n	425c <tcp_input+0x608>
			TCP_RMV_ACTIVE(pcb);
    4256:	68e3      	ldr	r3, [r4, #12]
    4258:	6013      	str	r3, [r2, #0]
    425a:	e00d      	b.n	4278 <tcp_input+0x624>
				TCP_RMV_ACTIVE(pcb);
    425c:	4a6f      	ldr	r2, [pc, #444]	; (441c <tcp_input+0x7c8>)
    425e:	2100      	movs	r1, #0
    4260:	6013      	str	r3, [r2, #0]
    4262:	b913      	cbnz	r3, 426a <tcp_input+0x616>
    4264:	2900      	cmp	r1, #0
    4266:	d1f7      	bne.n	4258 <tcp_input+0x604>
    4268:	e006      	b.n	4278 <tcp_input+0x624>
    426a:	68d8      	ldr	r0, [r3, #12]
    426c:	4284      	cmp	r4, r0
    426e:	d10f      	bne.n	4290 <tcp_input+0x63c>
    4270:	b101      	cbz	r1, 4274 <tcp_input+0x620>
    4272:	6013      	str	r3, [r2, #0]
			TCP_RMV_ACTIVE(pcb);
    4274:	68e2      	ldr	r2, [r4, #12]
    4276:	60da      	str	r2, [r3, #12]
    4278:	4b69      	ldr	r3, [pc, #420]	; (4420 <tcp_input+0x7cc>)
    427a:	2201      	movs	r2, #1
    427c:	701a      	strb	r2, [r3, #0]
			pcb->state = TIME_WAIT;
    427e:	230a      	movs	r3, #10
    4280:	7623      	strb	r3, [r4, #24]
			TCP_REG(&tcp_tw_pcbs, pcb);
    4282:	4b68      	ldr	r3, [pc, #416]	; (4424 <tcp_input+0x7d0>)
    4284:	681a      	ldr	r2, [r3, #0]
    4286:	60e2      	str	r2, [r4, #12]
    4288:	601c      	str	r4, [r3, #0]
    428a:	4b67      	ldr	r3, [pc, #412]	; (4428 <tcp_input+0x7d4>)
    428c:	4798      	blx	r3
		if (err != ERR_ABRT) {
    428e:	e6b5      	b.n	3ffc <tcp_input+0x3a8>
    4290:	2101      	movs	r1, #1
    4292:	4603      	mov	r3, r0
    4294:	e7e5      	b.n	4262 <tcp_input+0x60e>
				tcp_ack_now(pcb);
    4296:	77a3      	strb	r3, [r4, #30]
				pcb->state = CLOSING;
    4298:	2308      	movs	r3, #8
    429a:	e7a3      	b.n	41e4 <tcp_input+0x590>
		} else if ((flags & TCP_ACK) && (ackno == pcb->snd_nxt)) {
    429c:	06d8      	lsls	r0, r3, #27
    429e:	f57f aead 	bpl.w	3ffc <tcp_input+0x3a8>
    42a2:	6d22      	ldr	r2, [r4, #80]	; 0x50
    42a4:	68eb      	ldr	r3, [r5, #12]
    42a6:	429a      	cmp	r2, r3
    42a8:	f47f aea8 	bne.w	3ffc <tcp_input+0x3a8>
			pcb->state = FIN_WAIT_2;
    42ac:	2306      	movs	r3, #6
    42ae:	e799      	b.n	41e4 <tcp_input+0x590>
		tcp_receive(pcb);
    42b0:	4b54      	ldr	r3, [pc, #336]	; (4404 <tcp_input+0x7b0>)
    42b2:	4620      	mov	r0, r4
    42b4:	4798      	blx	r3
		if (recv_flags & TF_GOT_FIN) {
    42b6:	f895 3028 	ldrb.w	r3, [r5, #40]	; 0x28
    42ba:	0699      	lsls	r1, r3, #26
    42bc:	f57f ae9e 	bpl.w	3ffc <tcp_input+0x3a8>
			tcp_ack_now(pcb);
    42c0:	7fa3      	ldrb	r3, [r4, #30]
    42c2:	f043 0302 	orr.w	r3, r3, #2
    42c6:	77a3      	strb	r3, [r4, #30]
			tcp_pcb_purge(pcb);
    42c8:	4620      	mov	r0, r4
    42ca:	4b52      	ldr	r3, [pc, #328]	; (4414 <tcp_input+0x7c0>)
    42cc:	4798      	blx	r3
			TCP_RMV_ACTIVE(pcb);
    42ce:	4a52      	ldr	r2, [pc, #328]	; (4418 <tcp_input+0x7c4>)
    42d0:	6813      	ldr	r3, [r2, #0]
    42d2:	429c      	cmp	r4, r3
    42d4:	d0bf      	beq.n	4256 <tcp_input+0x602>
    42d6:	4a51      	ldr	r2, [pc, #324]	; (441c <tcp_input+0x7c8>)
    42d8:	2100      	movs	r1, #0
    42da:	6013      	str	r3, [r2, #0]
    42dc:	2b00      	cmp	r3, #0
    42de:	d0c1      	beq.n	4264 <tcp_input+0x610>
    42e0:	68d8      	ldr	r0, [r3, #12]
    42e2:	4284      	cmp	r4, r0
    42e4:	d0c4      	beq.n	4270 <tcp_input+0x61c>
    42e6:	2101      	movs	r1, #1
    42e8:	4603      	mov	r3, r0
    42ea:	e7f7      	b.n	42dc <tcp_input+0x688>
		tcp_receive(pcb);
    42ec:	4b45      	ldr	r3, [pc, #276]	; (4404 <tcp_input+0x7b0>)
    42ee:	4620      	mov	r0, r4
    42f0:	4798      	blx	r3
		if (flags & TCP_ACK && ackno == pcb->snd_nxt) {
    42f2:	7a2b      	ldrb	r3, [r5, #8]
    42f4:	06da      	lsls	r2, r3, #27
    42f6:	f57f ae81 	bpl.w	3ffc <tcp_input+0x3a8>
    42fa:	6d22      	ldr	r2, [r4, #80]	; 0x50
    42fc:	68eb      	ldr	r3, [r5, #12]
    42fe:	429a      	cmp	r2, r3
    4300:	f47f ae7c 	bne.w	3ffc <tcp_input+0x3a8>
			tcp_pcb_purge(pcb);
    4304:	4b43      	ldr	r3, [pc, #268]	; (4414 <tcp_input+0x7c0>)
    4306:	4620      	mov	r0, r4
    4308:	4798      	blx	r3
			TCP_RMV_ACTIVE(pcb);
    430a:	4a43      	ldr	r2, [pc, #268]	; (4418 <tcp_input+0x7c4>)
    430c:	6813      	ldr	r3, [r2, #0]
    430e:	429c      	cmp	r4, r3
    4310:	d0a1      	beq.n	4256 <tcp_input+0x602>
    4312:	4a42      	ldr	r2, [pc, #264]	; (441c <tcp_input+0x7c8>)
    4314:	2100      	movs	r1, #0
    4316:	6013      	str	r3, [r2, #0]
    4318:	2b00      	cmp	r3, #0
    431a:	d0a3      	beq.n	4264 <tcp_input+0x610>
    431c:	68d8      	ldr	r0, [r3, #12]
    431e:	4284      	cmp	r4, r0
    4320:	d0a6      	beq.n	4270 <tcp_input+0x61c>
    4322:	2101      	movs	r1, #1
    4324:	4603      	mov	r3, r0
    4326:	e7f7      	b.n	4318 <tcp_input+0x6c4>
		tcp_receive(pcb);
    4328:	4b36      	ldr	r3, [pc, #216]	; (4404 <tcp_input+0x7b0>)
    432a:	4620      	mov	r0, r4
    432c:	4798      	blx	r3
		if (flags & TCP_ACK && ackno == pcb->snd_nxt) {
    432e:	7a2b      	ldrb	r3, [r5, #8]
    4330:	06db      	lsls	r3, r3, #27
    4332:	f57f ae63 	bpl.w	3ffc <tcp_input+0x3a8>
    4336:	68eb      	ldr	r3, [r5, #12]
    4338:	6d22      	ldr	r2, [r4, #80]	; 0x50
    433a:	429a      	cmp	r2, r3
			recv_flags |= TF_CLOSED;
    433c:	bf02      	ittt	eq
    433e:	f895 3028 	ldrbeq.w	r3, [r5, #40]	; 0x28
    4342:	f043 0310 	orreq.w	r3, r3, #16
    4346:	f885 3028 	strbeq.w	r3, [r5, #40]	; 0x28
		if (err != ERR_ABRT) {
    434a:	e657      	b.n	3ffc <tcp_input+0x3a8>
			} else if (recv_flags & TF_CLOSED) {
    434c:	06de      	lsls	r6, r3, #27
    434e:	d50b      	bpl.n	4368 <tcp_input+0x714>
				if (!(pcb->flags & TF_RXCLOSED)) {
    4350:	7fa3      	ldrb	r3, [r4, #30]
    4352:	06d8      	lsls	r0, r3, #27
    4354:	f53f ae5e 	bmi.w	4014 <tcp_input+0x3c0>
					TCP_EVENT_ERR(pcb->errf, pcb->callback_arg, ERR_CLSD);
    4358:	f8d4 308c 	ldr.w	r3, [r4, #140]	; 0x8c
    435c:	2b00      	cmp	r3, #0
    435e:	f43f ae59 	beq.w	4014 <tcp_input+0x3c0>
    4362:	f06f 010b 	mvn.w	r1, #11
    4366:	e653      	b.n	4010 <tcp_input+0x3bc>
				if (pcb->acked > 0) {
    4368:	f8b4 2064 	ldrh.w	r2, [r4, #100]	; 0x64
    436c:	b992      	cbnz	r2, 4394 <tcp_input+0x740>
				if (recv_data != NULL) {
    436e:	6a6a      	ldr	r2, [r5, #36]	; 0x24
    4370:	b9ca      	cbnz	r2, 43a6 <tcp_input+0x752>
				if (recv_flags & TF_GOT_FIN) {
    4372:	f895 3028 	ldrb.w	r3, [r5, #40]	; 0x28
    4376:	0699      	lsls	r1, r3, #26
    4378:	d506      	bpl.n	4388 <tcp_input+0x734>
					if (pcb->refused_data != NULL) {
    437a:	6fa3      	ldr	r3, [r4, #120]	; 0x78
    437c:	2b00      	cmp	r3, #0
    437e:	d02e      	beq.n	43de <tcp_input+0x78a>
						pcb->refused_data->flags |= PBUF_FLAG_TCP_FIN;
    4380:	7b5a      	ldrb	r2, [r3, #13]
    4382:	f042 0220 	orr.w	r2, r2, #32
    4386:	735a      	strb	r2, [r3, #13]
				tcp_input_pcb = NULL;
    4388:	2300      	movs	r3, #0
    438a:	62eb      	str	r3, [r5, #44]	; 0x2c
				tcp_output(pcb);
    438c:	4620      	mov	r0, r4
    438e:	4b27      	ldr	r3, [pc, #156]	; (442c <tcp_input+0x7d8>)
    4390:	4798      	blx	r3
    4392:	e60e      	b.n	3fb2 <tcp_input+0x35e>
					TCP_EVENT_SENT(pcb, pcb->acked, err);
    4394:	6fe3      	ldr	r3, [r4, #124]	; 0x7c
    4396:	2b00      	cmp	r3, #0
    4398:	d0e9      	beq.n	436e <tcp_input+0x71a>
    439a:	6920      	ldr	r0, [r4, #16]
    439c:	4621      	mov	r1, r4
    439e:	4798      	blx	r3
					if (err == ERR_ABRT) {
    43a0:	300a      	adds	r0, #10
    43a2:	d1e4      	bne.n	436e <tcp_input+0x71a>
    43a4:	e605      	b.n	3fb2 <tcp_input+0x35e>
					if (pcb->flags & TF_RXCLOSED) {
    43a6:	7fa3      	ldrb	r3, [r4, #30]
    43a8:	f013 0310 	ands.w	r3, r3, #16
    43ac:	d003      	beq.n	43b6 <tcp_input+0x762>
						pbuf_free(recv_data);
    43ae:	4b20      	ldr	r3, [pc, #128]	; (4430 <tcp_input+0x7dc>)
    43b0:	4610      	mov	r0, r2
    43b2:	4798      	blx	r3
    43b4:	e6c7      	b.n	4146 <tcp_input+0x4f2>
					TCP_EVENT_RECV(pcb, recv_data, ERR_OK, err);
    43b6:	f8d4 6080 	ldr.w	r6, [r4, #128]	; 0x80
    43ba:	b15e      	cbz	r6, 43d4 <tcp_input+0x780>
    43bc:	6920      	ldr	r0, [r4, #16]
    43be:	4621      	mov	r1, r4
    43c0:	47b0      	blx	r6
					if (err == ERR_ABRT) {
    43c2:	f110 0f0a 	cmn.w	r0, #10
    43c6:	f43f adf4 	beq.w	3fb2 <tcp_input+0x35e>
					if (err != ERR_OK) {
    43ca:	2800      	cmp	r0, #0
    43cc:	d0d1      	beq.n	4372 <tcp_input+0x71e>
						pcb->refused_data = recv_data;
    43ce:	6a6b      	ldr	r3, [r5, #36]	; 0x24
    43d0:	67a3      	str	r3, [r4, #120]	; 0x78
    43d2:	e7ce      	b.n	4372 <tcp_input+0x71e>
					TCP_EVENT_RECV(pcb, recv_data, ERR_OK, err);
    43d4:	4633      	mov	r3, r6
    43d6:	4630      	mov	r0, r6
    43d8:	4621      	mov	r1, r4
    43da:	4e16      	ldr	r6, [pc, #88]	; (4434 <tcp_input+0x7e0>)
    43dc:	e7f0      	b.n	43c0 <tcp_input+0x76c>
						if (pcb->rcv_wnd != TCP_WND) {
    43de:	8da3      	ldrh	r3, [r4, #44]	; 0x2c
						TCP_EVENT_CLOSED(pcb, err);
    43e0:	f8d4 6080 	ldr.w	r6, [r4, #128]	; 0x80
						if (pcb->rcv_wnd != TCP_WND) {
    43e4:	f241 62d0 	movw	r2, #5840	; 0x16d0
    43e8:	4293      	cmp	r3, r2
							pcb->rcv_wnd++;
    43ea:	bf1c      	itt	ne
    43ec:	3301      	addne	r3, #1
    43ee:	85a3      	strhne	r3, [r4, #44]	; 0x2c
						TCP_EVENT_CLOSED(pcb, err);
    43f0:	2e00      	cmp	r6, #0
    43f2:	d0c9      	beq.n	4388 <tcp_input+0x734>
    43f4:	2300      	movs	r3, #0
    43f6:	6920      	ldr	r0, [r4, #16]
    43f8:	461a      	mov	r2, r3
    43fa:	4621      	mov	r1, r4
    43fc:	47b0      	blx	r6
						if (err == ERR_ABRT) {
    43fe:	300a      	adds	r0, #10
    4400:	d1c2      	bne.n	4388 <tcp_input+0x734>
    4402:	e5d6      	b.n	3fb2 <tcp_input+0x35e>
    4404:	00003505 	.word	0x00003505
    4408:	20011104 	.word	0x20011104
    440c:	20011108 	.word	0x20011108
    4410:	0000280d 	.word	0x0000280d
    4414:	00006b55 	.word	0x00006b55
    4418:	20014950 	.word	0x20014950
    441c:	20014940 	.word	0x20014940
    4420:	20014954 	.word	0x20014954
    4424:	20014958 	.word	0x20014958
    4428:	000010a1 	.word	0x000010a1
    442c:	000024a1 	.word	0x000024a1
    4430:	000030e1 	.word	0x000030e1
    4434:	00007045 	.word	0x00007045
			if (prev != NULL) {
    4438:	b138      	cbz	r0, 444a <tcp_input+0x7f6>
				((struct tcp_pcb_listen *)prev)->next = lpcb->next;
    443a:	f8da 200c 	ldr.w	r2, [sl, #12]
    443e:	60c2      	str	r2, [r0, #12]
				tcp_listen_pcbs.listen_pcbs = lpcb;
    4440:	4a0a      	ldr	r2, [pc, #40]	; (446c <tcp_input+0x818>)
				lpcb->next = tcp_listen_pcbs.listen_pcbs;
    4442:	f8ca 400c 	str.w	r4, [sl, #12]
				tcp_listen_pcbs.listen_pcbs = lpcb;
    4446:	f8c2 a000 	str.w	sl, [r2]
	if (flags & TCP_RST) {
    444a:	075a      	lsls	r2, r3, #29
    444c:	f53f ad03 	bmi.w	3e56 <tcp_input+0x202>
	if (flags & TCP_ACK) {
    4450:	f013 0410 	ands.w	r4, r3, #16
    4454:	f43f ad4e 	beq.w	3ef4 <tcp_input+0x2a0>
		tcp_rst(ackno, seqno + tcplen, ip_current_dest_addr(), ip_current_src_addr(), tcphdr->dest, tcphdr->src);
    4458:	f8bc 3000 	ldrh.w	r3, [ip]
    445c:	6868      	ldr	r0, [r5, #4]
    445e:	4a04      	ldr	r2, [pc, #16]	; (4470 <tcp_input+0x81c>)
    4460:	9902      	ldr	r1, [sp, #8]
    4462:	e9cd b300 	strd	fp, r3, [sp]
    4466:	4b03      	ldr	r3, [pc, #12]	; (4474 <tcp_input+0x820>)
			tcp_rst(ackno, seqno + tcplen, ip_current_dest_addr(), ip_current_src_addr(), tcphdr->dest, tcphdr->src);
    4468:	4401      	add	r1, r0
    446a:	e4e3      	b.n	3e34 <tcp_input+0x1e0>
    446c:	20014944 	.word	0x20014944
    4470:	20011104 	.word	0x20011104
    4474:	20011108 	.word	0x20011108

00004478 <udp_init>:
void udp_init(void)
{
#if LWIP_RANDOMIZE_INITIAL_LOCAL_PORTS && defined(LWIP_RAND)
	udp_port = UDP_ENSURE_LOCAL_PORT_RANGE(LWIP_RAND());
#endif /* LWIP_RANDOMIZE_INITIAL_LOCAL_PORTS && defined(LWIP_RAND) */
}
    4478:	4770      	bx	lr
	...

0000447c <udp_input>:
 * @param p pbuf to be demultiplexed to a UDP PCB.
 * @param inp network interface on which the datagram was received.
 *
 */
void udp_input(struct pbuf *p, struct netif *inp)
{
    447c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}

	PERF_START;

	UDP_STATS_INC(udp.recv);

	iphdr = (struct ip_hdr *)p->payload;
    4480:	f8d0 a004 	ldr.w	sl, [r0, #4]

	/* Check minimum length (IP header + UDP header)
	 * and move payload pointer to UDP header */
	if (p->tot_len < (IPH_HL(iphdr) * 4 + UDP_HLEN) || pbuf_header(p, -(s16_t)(IPH_HL(iphdr) * 4))) {
    4484:	8903      	ldrh	r3, [r0, #8]
{
    4486:	468b      	mov	fp, r1
    4488:	f89a 1000 	ldrb.w	r1, [sl]
    448c:	f001 010f 	and.w	r1, r1, #15
	if (p->tot_len < (IPH_HL(iphdr) * 4 + UDP_HLEN) || pbuf_header(p, -(s16_t)(IPH_HL(iphdr) * 4))) {
    4490:	1c8a      	adds	r2, r1, #2
    4492:	ebb3 0f82 	cmp.w	r3, r2, lsl #2
{
    4496:	b085      	sub	sp, #20
    4498:	4605      	mov	r5, r0
	if (p->tot_len < (IPH_HL(iphdr) * 4 + UDP_HLEN) || pbuf_header(p, -(s16_t)(IPH_HL(iphdr) * 4))) {
    449a:	db05      	blt.n	44a8 <udp_input+0x2c>
    449c:	0089      	lsls	r1, r1, #2
    449e:	4b53      	ldr	r3, [pc, #332]	; (45ec <udp_input+0x170>)
    44a0:	4249      	negs	r1, r1
    44a2:	4798      	blx	r3
    44a4:	4606      	mov	r6, r0
    44a6:	b128      	cbz	r0, 44b4 <udp_input+0x38>
		/* drop short packets */
		LWIP_DEBUGF(UDP_DEBUG, ("udp_input: short UDP datagram (%" U16_F " bytes) discarded\n", p->tot_len));
		UDP_STATS_INC(udp.lenerr);
		UDP_STATS_INC(udp.drop);
		snmp_inc_udpinerrors();
		pbuf_free(p);
    44a8:	4b51      	ldr	r3, [pc, #324]	; (45f0 <udp_input+0x174>)
    44aa:	4628      	mov	r0, r5
	} else {
		pbuf_free(p);
	}
end:
	PERF_STOP("udp_input");
}
    44ac:	b005      	add	sp, #20
    44ae:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
		pbuf_free(p);
    44b2:	4718      	bx	r3
	broadcast = ip_addr_isbroadcast(&current_iphdr_dest, inp);
    44b4:	4c4f      	ldr	r4, [pc, #316]	; (45f4 <udp_input+0x178>)
    44b6:	4b50      	ldr	r3, [pc, #320]	; (45f8 <udp_input+0x17c>)
    44b8:	6820      	ldr	r0, [r4, #0]
	udphdr = (struct udp_hdr *)p->payload;
    44ba:	f8d5 9004 	ldr.w	r9, [r5, #4]
	broadcast = ip_addr_isbroadcast(&current_iphdr_dest, inp);
    44be:	4659      	mov	r1, fp
    44c0:	4798      	blx	r3
	src  = ntohs(udphdr->src);
    44c2:	4b4e      	ldr	r3, [pc, #312]	; (45fc <udp_input+0x180>)
	broadcast = ip_addr_isbroadcast(&current_iphdr_dest, inp);
    44c4:	4680      	mov	r8, r0
	src  = ntohs(udphdr->src);
    44c6:	f8b9 0000 	ldrh.w	r0, [r9]
    44ca:	4798      	blx	r3
	dest = ntohs(udphdr->dest);
    44cc:	4b4b      	ldr	r3, [pc, #300]	; (45fc <udp_input+0x180>)
	src  = ntohs(udphdr->src);
    44ce:	4607      	mov	r7, r0
	dest = ntohs(udphdr->dest);
    44d0:	f8b9 0002 	ldrh.w	r0, [r9, #2]
    44d4:	4798      	blx	r3
	if (dest == DHCP_CLIENT_PORT) {
    44d6:	2844      	cmp	r0, #68	; 0x44
	dest = ntohs(udphdr->dest);
    44d8:	9003      	str	r0, [sp, #12]
	if (dest == DHCP_CLIENT_PORT) {
    44da:	d130      	bne.n	453e <udp_input+0xc2>
		if (src == DHCP_SERVER_PORT) {
    44dc:	2f43      	cmp	r7, #67	; 0x43
    44de:	d149      	bne.n	4574 <udp_input+0xf8>
			if ((inp->dhcp != NULL) && (inp->dhcp->pcb != NULL)) {
    44e0:	f8db 3024 	ldr.w	r3, [fp, #36]	; 0x24
    44e4:	2b00      	cmp	r3, #0
    44e6:	d045      	beq.n	4574 <udp_input+0xf8>
    44e8:	685c      	ldr	r4, [r3, #4]
    44ea:	2c00      	cmp	r4, #0
    44ec:	d042      	beq.n	4574 <udp_input+0xf8>
				if ((ip_addr_isany(&inp->dhcp->pcb->remote_ip)
    44ee:	6863      	ldr	r3, [r4, #4]
    44f0:	b11b      	cbz	r3, 44fa <udp_input+0x7e>
				     || ip_addr_cmp(&(inp->dhcp->pcb->remote_ip), &current_iphdr_src))) {
    44f2:	4a43      	ldr	r2, [pc, #268]	; (4600 <udp_input+0x184>)
    44f4:	6812      	ldr	r2, [r2, #0]
    44f6:	4293      	cmp	r3, r2
    44f8:	d13c      	bne.n	4574 <udp_input+0xf8>
			if (udphdr->chksum != 0) {
    44fa:	f8b9 3006 	ldrh.w	r3, [r9, #6]
    44fe:	b14b      	cbz	r3, 4514 <udp_input+0x98>
				if (inet_chksum_pseudo(p, ip_current_src_addr(), ip_current_dest_addr(), IP_PROTO_UDP, p->tot_len)
    4500:	892b      	ldrh	r3, [r5, #8]
    4502:	9300      	str	r3, [sp, #0]
    4504:	4a3b      	ldr	r2, [pc, #236]	; (45f4 <udp_input+0x178>)
    4506:	493e      	ldr	r1, [pc, #248]	; (4600 <udp_input+0x184>)
    4508:	4e3e      	ldr	r6, [pc, #248]	; (4604 <udp_input+0x188>)
    450a:	2311      	movs	r3, #17
    450c:	4628      	mov	r0, r5
    450e:	47b0      	blx	r6
    4510:	2800      	cmp	r0, #0
    4512:	d1c9      	bne.n	44a8 <udp_input+0x2c>
		if (pbuf_header(p, -UDP_HLEN)) {
    4514:	4e35      	ldr	r6, [pc, #212]	; (45ec <udp_input+0x170>)
    4516:	f06f 0107 	mvn.w	r1, #7
    451a:	4628      	mov	r0, r5
    451c:	47b0      	blx	r6
    451e:	2800      	cmp	r0, #0
    4520:	d1c2      	bne.n	44a8 <udp_input+0x2c>
		if (pcb != NULL) {
    4522:	2c00      	cmp	r4, #0
    4524:	d02e      	beq.n	4584 <udp_input+0x108>
			if (pcb->recv != NULL) {
    4526:	69a6      	ldr	r6, [r4, #24]
    4528:	2e00      	cmp	r6, #0
    452a:	d0bd      	beq.n	44a8 <udp_input+0x2c>
				pcb->recv(pcb->recv_arg, pcb, p, ip_current_src_addr(), src);
    452c:	9700      	str	r7, [sp, #0]
    452e:	4b34      	ldr	r3, [pc, #208]	; (4600 <udp_input+0x184>)
    4530:	69e0      	ldr	r0, [r4, #28]
    4532:	462a      	mov	r2, r5
    4534:	4621      	mov	r1, r4
    4536:	47b0      	blx	r6
}
    4538:	b005      	add	sp, #20
    453a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		for (pcb = udp_pcbs; pcb != NULL; pcb = pcb->next) {
    453e:	4b32      	ldr	r3, [pc, #200]	; (4608 <udp_input+0x18c>)
				if ((!broadcast && ip_addr_isany(&pcb->local_ip)) || ip_addr_cmp(&(pcb->local_ip), &current_iphdr_dest)
    4540:	6821      	ldr	r1, [r4, #0]
		for (pcb = udp_pcbs; pcb != NULL; pcb = pcb->next) {
    4542:	f8d3 e000 	ldr.w	lr, [r3]
			    && (ip_addr_isany(&pcb->remote_ip) || ip_addr_cmp(&(pcb->remote_ip), &current_iphdr_src))) {
    4546:	4b2e      	ldr	r3, [pc, #184]	; (4600 <udp_input+0x184>)
		for (pcb = udp_pcbs; pcb != NULL; pcb = pcb->next) {
    4548:	4674      	mov	r4, lr
			    && (ip_addr_isany(&pcb->remote_ip) || ip_addr_cmp(&(pcb->remote_ip), &current_iphdr_src))) {
    454a:	f8d3 c000 	ldr.w	ip, [r3]
		uncon_pcb   = NULL;
    454e:	4633      	mov	r3, r6
		for (pcb = udp_pcbs; pcb != NULL; pcb = pcb->next) {
    4550:	b914      	cbnz	r4, 4558 <udp_input+0xdc>
	if (pcb != NULL || ip_addr_cmp(&inp->ip_addr, &current_iphdr_dest)) {
    4552:	b17b      	cbz	r3, 4574 <udp_input+0xf8>
    4554:	461c      	mov	r4, r3
    4556:	e7d0      	b.n	44fa <udp_input+0x7e>
			if (pcb->local_port == dest) {
    4558:	8a62      	ldrh	r2, [r4, #18]
    455a:	9803      	ldr	r0, [sp, #12]
    455c:	4282      	cmp	r2, r0
    455e:	d106      	bne.n	456e <udp_input+0xf2>
				if ((!broadcast && ip_addr_isany(&pcb->local_ip)) || ip_addr_cmp(&(pcb->local_ip), &current_iphdr_dest)
    4560:	6822      	ldr	r2, [r4, #0]
    4562:	f1b8 0f00 	cmp.w	r8, #0
    4566:	d123      	bne.n	45b0 <udp_input+0x134>
    4568:	b352      	cbz	r2, 45c0 <udp_input+0x144>
    456a:	4291      	cmp	r1, r2
    456c:	d028      	beq.n	45c0 <udp_input+0x144>
		for (pcb = udp_pcbs; pcb != NULL; pcb = pcb->next) {
    456e:	4626      	mov	r6, r4
    4570:	68e4      	ldr	r4, [r4, #12]
    4572:	e7ed      	b.n	4550 <udp_input+0xd4>
	if (pcb != NULL || ip_addr_cmp(&inp->ip_addr, &current_iphdr_dest)) {
    4574:	4b1f      	ldr	r3, [pc, #124]	; (45f4 <udp_input+0x178>)
    4576:	f8db 2004 	ldr.w	r2, [fp, #4]
    457a:	681b      	ldr	r3, [r3, #0]
    457c:	429a      	cmp	r2, r3
    457e:	d193      	bne.n	44a8 <udp_input+0x2c>
    4580:	2400      	movs	r4, #0
    4582:	e7ba      	b.n	44fa <udp_input+0x7e>
			if (!broadcast && !ip_addr_ismulticast(&current_iphdr_dest)) {
    4584:	f1b8 0f00 	cmp.w	r8, #0
    4588:	d18e      	bne.n	44a8 <udp_input+0x2c>
    458a:	4b1a      	ldr	r3, [pc, #104]	; (45f4 <udp_input+0x178>)
    458c:	681b      	ldr	r3, [r3, #0]
    458e:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
    4592:	2be0      	cmp	r3, #224	; 0xe0
    4594:	d088      	beq.n	44a8 <udp_input+0x2c>
				pbuf_header(p, (IPH_HL(iphdr) * 4) + UDP_HLEN);
    4596:	f89a 1000 	ldrb.w	r1, [sl]
    459a:	f001 010f 	and.w	r1, r1, #15
    459e:	3102      	adds	r1, #2
    45a0:	0089      	lsls	r1, r1, #2
    45a2:	4628      	mov	r0, r5
    45a4:	47b0      	blx	r6
				icmp_dest_unreach(p, ICMP_DUR_PORT);
    45a6:	4b19      	ldr	r3, [pc, #100]	; (460c <udp_input+0x190>)
    45a8:	2103      	movs	r1, #3
    45aa:	4628      	mov	r0, r5
    45ac:	4798      	blx	r3
    45ae:	e77b      	b.n	44a8 <udp_input+0x2c>
				if ((!broadcast && ip_addr_isany(&pcb->local_ip)) || ip_addr_cmp(&(pcb->local_ip), &current_iphdr_dest)
    45b0:	4291      	cmp	r1, r2
    45b2:	d005      	beq.n	45c0 <udp_input+0x144>
				     && (ip_addr_isany(&pcb->local_ip)
    45b4:	b122      	cbz	r2, 45c0 <udp_input+0x144>
				         || ip_addr_netcmp(&pcb->local_ip, ip_current_dest_addr(), &inp->netmask)))) {
    45b6:	f8db 0008 	ldr.w	r0, [fp, #8]
    45ba:	404a      	eors	r2, r1
    45bc:	4202      	tst	r2, r0
    45be:	d1d6      	bne.n	456e <udp_input+0xf2>
					if ((uncon_pcb == NULL) && ((pcb->flags & UDP_FLAGS_CONNECTED) == 0)) {
    45c0:	b923      	cbnz	r3, 45cc <udp_input+0x150>
    45c2:	7c22      	ldrb	r2, [r4, #16]
    45c4:	f012 0f04 	tst.w	r2, #4
    45c8:	bf08      	it	eq
    45ca:	4623      	moveq	r3, r4
			if ((local_match != 0) && (pcb->remote_port == src)
    45cc:	8aa2      	ldrh	r2, [r4, #20]
    45ce:	42ba      	cmp	r2, r7
    45d0:	d1cd      	bne.n	456e <udp_input+0xf2>
			    && (ip_addr_isany(&pcb->remote_ip) || ip_addr_cmp(&(pcb->remote_ip), &current_iphdr_src))) {
    45d2:	6862      	ldr	r2, [r4, #4]
    45d4:	b10a      	cbz	r2, 45da <udp_input+0x15e>
    45d6:	4562      	cmp	r2, ip
    45d8:	d1c9      	bne.n	456e <udp_input+0xf2>
				if (prev != NULL) {
    45da:	2e00      	cmp	r6, #0
    45dc:	d08d      	beq.n	44fa <udp_input+0x7e>
					prev->next = pcb->next;
    45de:	68e3      	ldr	r3, [r4, #12]
    45e0:	60f3      	str	r3, [r6, #12]
					udp_pcbs   = pcb;
    45e2:	4b09      	ldr	r3, [pc, #36]	; (4608 <udp_input+0x18c>)
					pcb->next  = udp_pcbs;
    45e4:	f8c4 e00c 	str.w	lr, [r4, #12]
					udp_pcbs   = pcb;
    45e8:	601c      	str	r4, [r3, #0]
    45ea:	e786      	b.n	44fa <udp_input+0x7e>
    45ec:	00003089 	.word	0x00003089
    45f0:	000030e1 	.word	0x000030e1
    45f4:	20011104 	.word	0x20011104
    45f8:	00008a1f 	.word	0x00008a1f
    45fc:	00000d67 	.word	0x00000d67
    4600:	20011108 	.word	0x20011108
    4604:	00008389 	.word	0x00008389
    4608:	2000a510 	.word	0x2000a510
    460c:	00000d49 	.word	0x00000d49

00004610 <udp_bind>:
 * another UDP PCB.
 *
 * @see udp_disconnect()
 */
err_t udp_bind(struct udp_pcb *pcb, ip_addr_t *ipaddr, u16_t port)
{
    4610:	b5f0      	push	{r4, r5, r6, r7, lr}
	ip_addr_debug_print(UDP_DEBUG, ipaddr);
	LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE, (", port = %" U16_F ")\n", port));

	rebind = 0;
	/* Check for double bind and rebind of the same pcb */
	for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
    4612:	4f1f      	ldr	r7, [pc, #124]	; (4690 <udp_bind+0x80>)
    4614:	683d      	ldr	r5, [r7, #0]
	rebind = 0;
    4616:	2300      	movs	r3, #0
	for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
    4618:	462c      	mov	r4, r5
    461a:	b9c4      	cbnz	r4, 464e <udp_bind+0x3e>
				return ERR_USE;
			}
		}
	}

	ip_addr_set(&pcb->local_ip, ipaddr);
    461c:	b101      	cbz	r1, 4620 <udp_bind+0x10>
    461e:	6809      	ldr	r1, [r1, #0]
    4620:	6001      	str	r1, [r0, #0]

	/* no port specified? */
	if (port == 0) {
    4622:	b972      	cbnz	r2, 4642 <udp_bind+0x32>
    4624:	4e1b      	ldr	r6, [pc, #108]	; (4694 <udp_bind+0x84>)
    4626:	8832      	ldrh	r2, [r6, #0]
    4628:	f44f 4180 	mov.w	r1, #16384	; 0x4000
	if (udp_port++ == UDP_LOCAL_PORT_RANGE_END) {
    462c:	f64f 7cff 	movw	ip, #65535	; 0xffff
    4630:	4562      	cmp	r2, ip
    4632:	bf1a      	itte	ne
    4634:	3201      	addne	r2, #1
    4636:	b292      	uxthne	r2, r2
		udp_port = UDP_LOCAL_PORT_RANGE_START;
    4638:	f44f 4240 	moveq.w	r2, #49152	; 0xc000
	for (pcb = udp_pcbs; pcb != NULL; pcb = pcb->next) {
    463c:	462c      	mov	r4, r5
    463e:	b9dc      	cbnz	r4, 4678 <udp_bind+0x68>
    4640:	8032      	strh	r2, [r6, #0]
			/* no more ports available in local range */
			LWIP_DEBUGF(UDP_DEBUG, ("udp_bind: out of free UDP ports\n"));
			return ERR_USE;
		}
	}
	pcb->local_port = port;
    4642:	8242      	strh	r2, [r0, #18]
	snmp_insert_udpidx_tree(pcb);
	/* pcb not active yet? */
	if (rebind == 0) {
    4644:	b90b      	cbnz	r3, 464a <udp_bind+0x3a>
		/* place the PCB on the active list if not already there */
		pcb->next = udp_pcbs;
    4646:	60c5      	str	r5, [r0, #12]
		udp_pcbs  = pcb;
    4648:	6038      	str	r0, [r7, #0]
	             ip4_addr1_16(&pcb->local_ip),
	             ip4_addr2_16(&pcb->local_ip),
	             ip4_addr3_16(&pcb->local_ip),
	             ip4_addr4_16(&pcb->local_ip),
	             pcb->local_port));
	return ERR_OK;
    464a:	2000      	movs	r0, #0
    464c:	e010      	b.n	4670 <udp_bind+0x60>
		if (pcb == ipcb) {
    464e:	4284      	cmp	r4, r0
    4650:	d00f      	beq.n	4672 <udp_bind+0x62>
			if ((ipcb->local_port == port) &&
    4652:	8a66      	ldrh	r6, [r4, #18]
    4654:	4296      	cmp	r6, r2
    4656:	d10d      	bne.n	4674 <udp_bind+0x64>
			    (ip_addr_isany(&(ipcb->local_ip)) || ip_addr_isany(ipaddr) || ip_addr_cmp(&(ipcb->local_ip), ipaddr))) {
    4658:	f8d4 c000 	ldr.w	ip, [r4]
    465c:	f1bc 0f00 	cmp.w	ip, #0
    4660:	d004      	beq.n	466c <udp_bind+0x5c>
    4662:	b119      	cbz	r1, 466c <udp_bind+0x5c>
    4664:	680e      	ldr	r6, [r1, #0]
    4666:	b10e      	cbz	r6, 466c <udp_bind+0x5c>
    4668:	45b4      	cmp	ip, r6
    466a:	d103      	bne.n	4674 <udp_bind+0x64>
				return ERR_USE;
    466c:	f06f 0007 	mvn.w	r0, #7
}
    4670:	bdf0      	pop	{r4, r5, r6, r7, pc}
			rebind = 1;
    4672:	2301      	movs	r3, #1
	for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
    4674:	68e4      	ldr	r4, [r4, #12]
    4676:	e7d0      	b.n	461a <udp_bind+0xa>
		if (pcb->local_port == udp_port) {
    4678:	f8b4 e012 	ldrh.w	lr, [r4, #18]
    467c:	4596      	cmp	lr, r2
    467e:	d105      	bne.n	468c <udp_bind+0x7c>
			if (++n > (UDP_LOCAL_PORT_RANGE_END - UDP_LOCAL_PORT_RANGE_START)) {
    4680:	3901      	subs	r1, #1
    4682:	b289      	uxth	r1, r1
    4684:	2900      	cmp	r1, #0
    4686:	d1d3      	bne.n	4630 <udp_bind+0x20>
    4688:	8032      	strh	r2, [r6, #0]
    468a:	e7ef      	b.n	466c <udp_bind+0x5c>
	for (pcb = udp_pcbs; pcb != NULL; pcb = pcb->next) {
    468c:	68e4      	ldr	r4, [r4, #12]
    468e:	e7d6      	b.n	463e <udp_bind+0x2e>
    4690:	2000a510 	.word	0x2000a510
    4694:	20000004 	.word	0x20000004

00004698 <udp_sendto_if>:
{
    4698:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    469c:	4690      	mov	r8, r2
    469e:	b087      	sub	sp, #28
	if (pcb->local_port == 0) {
    46a0:	8a42      	ldrh	r2, [r0, #18]
{
    46a2:	f8dd 9040 	ldr.w	r9, [sp, #64]	; 0x40
    46a6:	4606      	mov	r6, r0
    46a8:	460f      	mov	r7, r1
    46aa:	469a      	mov	sl, r3
	if (pcb->local_port == 0) {
    46ac:	2a00      	cmp	r2, #0
    46ae:	d042      	beq.n	4736 <udp_sendto_if+0x9e>
	if (pbuf_header(p, UDP_HLEN)) {
    46b0:	4b35      	ldr	r3, [pc, #212]	; (4788 <udp_sendto_if+0xf0>)
    46b2:	2108      	movs	r1, #8
    46b4:	4638      	mov	r0, r7
    46b6:	4798      	blx	r3
    46b8:	2800      	cmp	r0, #0
    46ba:	d146      	bne.n	474a <udp_sendto_if+0xb2>
    46bc:	463c      	mov	r4, r7
	udphdr->src  = htons(pcb->local_port);
    46be:	f8df b0e0 	ldr.w	fp, [pc, #224]	; 47a0 <udp_sendto_if+0x108>
    46c2:	8a70      	ldrh	r0, [r6, #18]
	udphdr       = (struct udp_hdr *)q->payload;
    46c4:	6865      	ldr	r5, [r4, #4]
	udphdr->src  = htons(pcb->local_port);
    46c6:	47d8      	blx	fp
    46c8:	8028      	strh	r0, [r5, #0]
	udphdr->dest = htons(dst_port);
    46ca:	4650      	mov	r0, sl
    46cc:	47d8      	blx	fp
	if (ip_addr_isany(&pcb->local_ip)) {
    46ce:	6832      	ldr	r2, [r6, #0]
	udphdr->dest = htons(dst_port);
    46d0:	8068      	strh	r0, [r5, #2]
	udphdr->chksum = 0x0000;
    46d2:	2300      	movs	r3, #0
    46d4:	71ab      	strb	r3, [r5, #6]
    46d6:	71eb      	strb	r3, [r5, #7]
	if (ip_addr_isany(&pcb->local_ip)) {
    46d8:	465b      	mov	r3, fp
    46da:	2a00      	cmp	r2, #0
    46dc:	d143      	bne.n	4766 <udp_sendto_if+0xce>
		src_ip = &(netif->ip_addr);
    46de:	f109 0104 	add.w	r1, r9, #4
		udphdr->len = htons(q->tot_len);
    46e2:	8920      	ldrh	r0, [r4, #8]
    46e4:	9105      	str	r1, [sp, #20]
    46e6:	4798      	blx	r3
    46e8:	80a8      	strh	r0, [r5, #4]
		if ((pcb->flags & UDP_FLAGS_NOCHKSUM) == 0) {
    46ea:	7c33      	ldrb	r3, [r6, #16]
    46ec:	9905      	ldr	r1, [sp, #20]
    46ee:	f013 0f01 	tst.w	r3, #1
    46f2:	d10e      	bne.n	4712 <udp_sendto_if+0x7a>
				udpchksum = inet_chksum_pseudo(q, src_ip, dst_ip, IP_PROTO_UDP, q->tot_len);
    46f4:	8923      	ldrh	r3, [r4, #8]
    46f6:	9300      	str	r3, [sp, #0]
    46f8:	f8df a0a8 	ldr.w	sl, [pc, #168]	; 47a4 <udp_sendto_if+0x10c>
    46fc:	2311      	movs	r3, #17
    46fe:	4642      	mov	r2, r8
    4700:	4620      	mov	r0, r4
    4702:	47d0      	blx	sl
				udpchksum = 0xffff;
    4704:	f64f 73ff 	movw	r3, #65535	; 0xffff
    4708:	2800      	cmp	r0, #0
    470a:	bf18      	it	ne
    470c:	4603      	movne	r3, r0
			udphdr->chksum = udpchksum;
    470e:	9905      	ldr	r1, [sp, #20]
    4710:	80eb      	strh	r3, [r5, #6]
		err = ip_output_if(q, src_ip, dst_ip, pcb->ttl, pcb->tos, IP_PROTO_UDP, netif);
    4712:	2311      	movs	r3, #17
    4714:	9301      	str	r3, [sp, #4]
    4716:	7a73      	ldrb	r3, [r6, #9]
    4718:	4d1c      	ldr	r5, [pc, #112]	; (478c <udp_sendto_if+0xf4>)
    471a:	9300      	str	r3, [sp, #0]
    471c:	f8cd 9008 	str.w	r9, [sp, #8]
    4720:	7ab3      	ldrb	r3, [r6, #10]
    4722:	4642      	mov	r2, r8
    4724:	4620      	mov	r0, r4
    4726:	47a8      	blx	r5
	if (q != p) {
    4728:	42bc      	cmp	r4, r7
		err = ip_output_if(q, src_ip, dst_ip, pcb->ttl, pcb->tos, IP_PROTO_UDP, netif);
    472a:	4605      	mov	r5, r0
	if (q != p) {
    472c:	d009      	beq.n	4742 <udp_sendto_if+0xaa>
		pbuf_free(q);
    472e:	4b18      	ldr	r3, [pc, #96]	; (4790 <udp_sendto_if+0xf8>)
    4730:	4620      	mov	r0, r4
    4732:	4798      	blx	r3
		q = NULL;
    4734:	e005      	b.n	4742 <udp_sendto_if+0xaa>
		err = udp_bind(pcb, &pcb->local_ip, pcb->local_port);
    4736:	4b17      	ldr	r3, [pc, #92]	; (4794 <udp_sendto_if+0xfc>)
    4738:	4601      	mov	r1, r0
    473a:	4798      	blx	r3
		if (err != ERR_OK) {
    473c:	4605      	mov	r5, r0
    473e:	2800      	cmp	r0, #0
    4740:	d0b6      	beq.n	46b0 <udp_sendto_if+0x18>
}
    4742:	4628      	mov	r0, r5
    4744:	b007      	add	sp, #28
    4746:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		q = pbuf_alloc(PBUF_IP, UDP_HLEN, PBUF_RAM);
    474a:	4b13      	ldr	r3, [pc, #76]	; (4798 <udp_sendto_if+0x100>)
    474c:	2200      	movs	r2, #0
    474e:	2108      	movs	r1, #8
    4750:	2001      	movs	r0, #1
    4752:	4798      	blx	r3
		if (q == NULL) {
    4754:	4604      	mov	r4, r0
    4756:	b1a0      	cbz	r0, 4782 <udp_sendto_if+0xea>
		if (p->tot_len != 0) {
    4758:	893b      	ldrh	r3, [r7, #8]
    475a:	2b00      	cmp	r3, #0
    475c:	d0af      	beq.n	46be <udp_sendto_if+0x26>
			pbuf_chain(q, p);
    475e:	4b0f      	ldr	r3, [pc, #60]	; (479c <udp_sendto_if+0x104>)
    4760:	4639      	mov	r1, r7
    4762:	4798      	blx	r3
    4764:	e7ab      	b.n	46be <udp_sendto_if+0x26>
		if (!ip_addr_cmp(&(pcb->local_ip), &(netif->ip_addr))) {
    4766:	f8d9 1004 	ldr.w	r1, [r9, #4]
    476a:	428a      	cmp	r2, r1
    476c:	d007      	beq.n	477e <udp_sendto_if+0xe6>
			if (q != p) {
    476e:	42bc      	cmp	r4, r7
    4770:	d002      	beq.n	4778 <udp_sendto_if+0xe0>
				pbuf_free(q);
    4772:	4b07      	ldr	r3, [pc, #28]	; (4790 <udp_sendto_if+0xf8>)
    4774:	4620      	mov	r0, r4
    4776:	4798      	blx	r3
			return ERR_VAL;
    4778:	f06f 0505 	mvn.w	r5, #5
    477c:	e7e1      	b.n	4742 <udp_sendto_if+0xaa>
	if (ip_addr_isany(&pcb->local_ip)) {
    477e:	4631      	mov	r1, r6
    4780:	e7af      	b.n	46e2 <udp_sendto_if+0x4a>
			return ERR_MEM;
    4782:	f04f 35ff 	mov.w	r5, #4294967295	; 0xffffffff
    4786:	e7dc      	b.n	4742 <udp_sendto_if+0xaa>
    4788:	00003089 	.word	0x00003089
    478c:	00006511 	.word	0x00006511
    4790:	000030e1 	.word	0x000030e1
    4794:	00004611 	.word	0x00004611
    4798:	00003139 	.word	0x00003139
    479c:	000032d5 	.word	0x000032d5
    47a0:	00000d61 	.word	0x00000d61
    47a4:	00008389 	.word	0x00008389

000047a8 <udp_sendto>:
{
    47a8:	b530      	push	{r4, r5, lr}
    47aa:	b087      	sub	sp, #28
    47ac:	4605      	mov	r5, r0
	netif = ip_route(dst_ip);
    47ae:	4c09      	ldr	r4, [pc, #36]	; (47d4 <udp_sendto+0x2c>)
    47b0:	9203      	str	r2, [sp, #12]
    47b2:	4610      	mov	r0, r2
{
    47b4:	e9cd 3104 	strd	r3, r1, [sp, #16]
	netif = ip_route(dst_ip);
    47b8:	47a0      	blx	r4
	if (netif == NULL) {
    47ba:	b140      	cbz	r0, 47ce <udp_sendto+0x26>
	return udp_sendto_if(pcb, p, dst_ip, dst_port, netif);
    47bc:	9000      	str	r0, [sp, #0]
    47be:	e9dd 2303 	ldrd	r2, r3, [sp, #12]
    47c2:	9905      	ldr	r1, [sp, #20]
    47c4:	4c04      	ldr	r4, [pc, #16]	; (47d8 <udp_sendto+0x30>)
    47c6:	4628      	mov	r0, r5
    47c8:	47a0      	blx	r4
}
    47ca:	b007      	add	sp, #28
    47cc:	bd30      	pop	{r4, r5, pc}
		return ERR_RTE;
    47ce:	f06f 0003 	mvn.w	r0, #3
    47d2:	e7fa      	b.n	47ca <udp_sendto+0x22>
    47d4:	0000635d 	.word	0x0000635d
    47d8:	00004699 	.word	0x00004699

000047dc <udp_send>:
{
    47dc:	b410      	push	{r4}
	return udp_sendto(pcb, p, &pcb->remote_ip, pcb->remote_port);
    47de:	4c04      	ldr	r4, [pc, #16]	; (47f0 <udp_send+0x14>)
    47e0:	8a83      	ldrh	r3, [r0, #20]
{
    47e2:	4602      	mov	r2, r0
	return udp_sendto(pcb, p, &pcb->remote_ip, pcb->remote_port);
    47e4:	46a4      	mov	ip, r4
    47e6:	3204      	adds	r2, #4
}
    47e8:	f85d 4b04 	ldr.w	r4, [sp], #4
	return udp_sendto(pcb, p, &pcb->remote_ip, pcb->remote_port);
    47ec:	4760      	bx	ip
    47ee:	bf00      	nop
    47f0:	000047a9 	.word	0x000047a9

000047f4 <udp_connect>:
 * The udp pcb is bound to a random local port if not already bound.
 *
 * @see udp_disconnect()
 */
err_t udp_connect(struct udp_pcb *pcb, ip_addr_t *ipaddr, u16_t port)
{
    47f4:	b570      	push	{r4, r5, r6, lr}
    47f6:	4616      	mov	r6, r2
	struct udp_pcb *ipcb;

	if (pcb->local_port == 0) {
    47f8:	8a42      	ldrh	r2, [r0, #18]
{
    47fa:	4604      	mov	r4, r0
    47fc:	460d      	mov	r5, r1
	if (pcb->local_port == 0) {
    47fe:	b16a      	cbz	r2, 481c <udp_connect+0x28>
		if (err != ERR_OK) {
			return err;
		}
	}

	ip_addr_set(&pcb->remote_ip, ipaddr);
    4800:	b995      	cbnz	r5, 4828 <udp_connect+0x34>
	             ip4_addr3_16(&pcb->local_ip),
	             ip4_addr4_16(&pcb->local_ip),
	             pcb->local_port));

	/* Insert UDP PCB into the list of active UDP PCBs. */
	for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
    4802:	4a0d      	ldr	r2, [pc, #52]	; (4838 <udp_connect+0x44>)
	pcb->flags |= UDP_FLAGS_CONNECTED;
    4804:	7c23      	ldrb	r3, [r4, #16]
	for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
    4806:	6811      	ldr	r1, [r2, #0]
	ip_addr_set(&pcb->remote_ip, ipaddr);
    4808:	6065      	str	r5, [r4, #4]
	pcb->flags |= UDP_FLAGS_CONNECTED;
    480a:	f043 0304 	orr.w	r3, r3, #4
	pcb->remote_port = port;
    480e:	82a6      	strh	r6, [r4, #20]
	pcb->flags |= UDP_FLAGS_CONNECTED;
    4810:	7423      	strb	r3, [r4, #16]
	for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
    4812:	4608      	mov	r0, r1
    4814:	b950      	cbnz	r0, 482c <udp_connect+0x38>
			/* already on the list, just return */
			return ERR_OK;
		}
	}
	/* PCB not yet on the list, add PCB now */
	pcb->next = udp_pcbs;
    4816:	60e1      	str	r1, [r4, #12]
	udp_pcbs  = pcb;
    4818:	6014      	str	r4, [r2, #0]
	return ERR_OK;
    481a:	e004      	b.n	4826 <udp_connect+0x32>
		err_t err = udp_bind(pcb, &pcb->local_ip, pcb->local_port);
    481c:	4b07      	ldr	r3, [pc, #28]	; (483c <udp_connect+0x48>)
    481e:	4601      	mov	r1, r0
    4820:	4798      	blx	r3
		if (err != ERR_OK) {
    4822:	2800      	cmp	r0, #0
    4824:	d0ec      	beq.n	4800 <udp_connect+0xc>
}
    4826:	bd70      	pop	{r4, r5, r6, pc}
	ip_addr_set(&pcb->remote_ip, ipaddr);
    4828:	682d      	ldr	r5, [r5, #0]
    482a:	e7ea      	b.n	4802 <udp_connect+0xe>
		if (pcb == ipcb) {
    482c:	42a0      	cmp	r0, r4
    482e:	d001      	beq.n	4834 <udp_connect+0x40>
	for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
    4830:	68c0      	ldr	r0, [r0, #12]
    4832:	e7ef      	b.n	4814 <udp_connect+0x20>
			return ERR_OK;
    4834:	2000      	movs	r0, #0
    4836:	e7f6      	b.n	4826 <udp_connect+0x32>
    4838:	2000a510 	.word	0x2000a510
    483c:	00004611 	.word	0x00004611

00004840 <udp_recv>:
 */
void udp_recv(struct udp_pcb *pcb, udp_recv_fn recv, void *recv_arg)
{
	/* remember recv() callback and user data */
	pcb->recv     = recv;
	pcb->recv_arg = recv_arg;
    4840:	e9c0 1206 	strd	r1, r2, [r0, #24]
}
    4844:	4770      	bx	lr
	...

00004848 <udp_remove>:
{
	struct udp_pcb *pcb2;

	snmp_delete_udpidx_tree(pcb);
	/* pcb to be removed is first in list? */
	if (udp_pcbs == pcb) {
    4848:	4a09      	ldr	r2, [pc, #36]	; (4870 <udp_remove+0x28>)
    484a:	6813      	ldr	r3, [r2, #0]
    484c:	4283      	cmp	r3, r0
{
    484e:	4601      	mov	r1, r0
	if (udp_pcbs == pcb) {
    4850:	d10b      	bne.n	486a <udp_remove+0x22>
		/* make list start at 2nd pcb */
		udp_pcbs = udp_pcbs->next;
    4852:	68c3      	ldr	r3, [r0, #12]
    4854:	6013      	str	r3, [r2, #0]
				/* remove pcb from list */
				pcb2->next = pcb->next;
			}
		}
	}
	memp_free(MEMP_UDP_PCB, pcb);
    4856:	4b07      	ldr	r3, [pc, #28]	; (4874 <udp_remove+0x2c>)
    4858:	2000      	movs	r0, #0
    485a:	4718      	bx	r3
			if (pcb2->next != NULL && pcb2->next == pcb) {
    485c:	68da      	ldr	r2, [r3, #12]
    485e:	b11a      	cbz	r2, 4868 <udp_remove+0x20>
    4860:	428a      	cmp	r2, r1
				pcb2->next = pcb->next;
    4862:	bf04      	itt	eq
    4864:	68ca      	ldreq	r2, [r1, #12]
    4866:	60da      	streq	r2, [r3, #12]
		for (pcb2 = udp_pcbs; pcb2 != NULL; pcb2 = pcb2->next) {
    4868:	68db      	ldr	r3, [r3, #12]
    486a:	2b00      	cmp	r3, #0
    486c:	d1f6      	bne.n	485c <udp_remove+0x14>
    486e:	e7f2      	b.n	4856 <udp_remove+0xe>
    4870:	2000a510 	.word	0x2000a510
    4874:	00004c21 	.word	0x00004c21

00004878 <udp_new>:
 * could not be allocated.
 *
 * @see udp_remove()
 */
struct udp_pcb *udp_new(void)
{
    4878:	b510      	push	{r4, lr}
	struct udp_pcb *pcb;
	pcb = (struct udp_pcb *)memp_malloc(MEMP_UDP_PCB);
    487a:	4b06      	ldr	r3, [pc, #24]	; (4894 <udp_new+0x1c>)
    487c:	2000      	movs	r0, #0
    487e:	4798      	blx	r3
	/* could allocate UDP PCB? */
	if (pcb != NULL) {
    4880:	4604      	mov	r4, r0
    4882:	b128      	cbz	r0, 4890 <udp_new+0x18>
		/* UDP Lite: by initializing to all zeroes, chksum_len is set to 0
		 * which means checksum is generated over the whole datagram per default
		 * (recommended as default by RFC 3828). */
		/* initialize PCB to all zeroes */
		memset(pcb, 0, sizeof(struct udp_pcb));
    4884:	4b04      	ldr	r3, [pc, #16]	; (4898 <udp_new+0x20>)
    4886:	2220      	movs	r2, #32
    4888:	2100      	movs	r1, #0
    488a:	4798      	blx	r3
		pcb->ttl = UDP_TTL;
    488c:	23ff      	movs	r3, #255	; 0xff
    488e:	72a3      	strb	r3, [r4, #10]
	}
	return pcb;
}
    4890:	4620      	mov	r0, r4
    4892:	bd10      	pop	{r4, pc}
    4894:	00004c05 	.word	0x00004c05
    4898:	0000c099 	.word	0x0000c099

0000489c <_osc32kctrl_init_sources>:
}

static inline hri_osc32kctrl_osculp32k_reg_t hri_osc32kctrl_read_OSCULP32K_CALIB_bf(const void *const hw)
{
	uint32_t tmp;
	tmp = ((Osc32kctrl *)hw)->OSCULP32K.reg;
    489c:	4b03      	ldr	r3, [pc, #12]	; (48ac <_osc32kctrl_init_sources+0x10>)
    489e:	69da      	ldr	r2, [r3, #28]
	calib = hri_osc32kctrl_read_OSCULP32K_CALIB_bf(hw);
	hri_osc32kctrl_write_OSCULP32K_reg(hw,
#if CONF_OSCULP32K_CALIB_ENABLE == 1
	                                   OSC32KCTRL_OSCULP32K_CALIB(CONF_OSCULP32K_CALIB)
#else
	                                   OSC32KCTRL_OSCULP32K_CALIB(calib)
    48a0:	f402 527c 	and.w	r2, r2, #16128	; 0x3f00
}

static inline void hri_osc32kctrl_write_OSCULP32K_reg(const void *const hw, hri_osc32kctrl_osculp32k_reg_t data)
{
	OSC32KCTRL_CRITICAL_SECTION_ENTER();
	((Osc32kctrl *)hw)->OSCULP32K.reg = data;
    48a4:	61da      	str	r2, [r3, #28]
	((Osc32kctrl *)hw)->RTCCTRL.reg = data;
    48a6:	2201      	movs	r2, #1
    48a8:	741a      	strb	r2, [r3, #16]
#endif
#endif

	hri_osc32kctrl_write_RTCCTRL_reg(hw, OSC32KCTRL_RTCCTRL_RTCSEL(CONF_RTCCTRL));
	(void)calib;
}
    48aa:	4770      	bx	lr
    48ac:	40001400 	.word	0x40001400

000048b0 <Dummy_Handler>:
/**
 * \brief Default interrupt handler for unused IRQs.
 */
void Dummy_Handler(void)
{
	while (1) {
    48b0:	e7fe      	b.n	48b0 <Dummy_Handler>
	...

000048b4 <Reset_Handler>:
	if (pSrc != pDest) {
    48b4:	4918      	ldr	r1, [pc, #96]	; (4918 <Reset_Handler+0x64>)
    48b6:	4819      	ldr	r0, [pc, #100]	; (491c <Reset_Handler+0x68>)
    48b8:	4281      	cmp	r1, r0
{
    48ba:	b510      	push	{r4, lr}
	if (pSrc != pDest) {
    48bc:	d00a      	beq.n	48d4 <Reset_Handler+0x20>
			*pDest++ = *pSrc++;
    48be:	4b18      	ldr	r3, [pc, #96]	; (4920 <Reset_Handler+0x6c>)
    48c0:	1cda      	adds	r2, r3, #3
    48c2:	1a12      	subs	r2, r2, r0
    48c4:	f022 0203 	bic.w	r2, r2, #3
    48c8:	1ec4      	subs	r4, r0, #3
    48ca:	42a3      	cmp	r3, r4
    48cc:	bf38      	it	cc
    48ce:	2200      	movcc	r2, #0
    48d0:	4b14      	ldr	r3, [pc, #80]	; (4924 <Reset_Handler+0x70>)
    48d2:	4798      	blx	r3
		*pDest++ = 0;
    48d4:	4b14      	ldr	r3, [pc, #80]	; (4928 <Reset_Handler+0x74>)
    48d6:	4815      	ldr	r0, [pc, #84]	; (492c <Reset_Handler+0x78>)
    48d8:	1cda      	adds	r2, r3, #3
    48da:	1a12      	subs	r2, r2, r0
    48dc:	1ec1      	subs	r1, r0, #3
    48de:	f022 0203 	bic.w	r2, r2, #3
    48e2:	4299      	cmp	r1, r3
    48e4:	bf88      	it	hi
    48e6:	2200      	movhi	r2, #0
    48e8:	4b11      	ldr	r3, [pc, #68]	; (4930 <Reset_Handler+0x7c>)
    48ea:	2100      	movs	r1, #0
    48ec:	4798      	blx	r3
	SCB->VTOR = ((uint32_t)pSrc & SCB_VTOR_TBLOFF_Msk);
    48ee:	4a11      	ldr	r2, [pc, #68]	; (4934 <Reset_Handler+0x80>)
    48f0:	4b11      	ldr	r3, [pc, #68]	; (4938 <Reset_Handler+0x84>)
    48f2:	f022 027f 	bic.w	r2, r2, #127	; 0x7f
    48f6:	609a      	str	r2, [r3, #8]
	SCB->CPACR |= (0xFu << 20);
    48f8:	f8d3 2088 	ldr.w	r2, [r3, #136]	; 0x88
    48fc:	f442 0270 	orr.w	r2, r2, #15728640	; 0xf00000
    4900:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88
  \details Acts as a special kind of Data Memory Barrier.
           It completes when all explicit memory accesses before this instruction complete.
 */
__STATIC_FORCEINLINE void __DSB(void)
{
  __ASM volatile ("dsb 0xF":::"memory");
    4904:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
    4908:	f3bf 8f6f 	isb	sy
	__libc_init_array();
    490c:	4b0b      	ldr	r3, [pc, #44]	; (493c <Reset_Handler+0x88>)
    490e:	4798      	blx	r3
	main();
    4910:	4b0b      	ldr	r3, [pc, #44]	; (4940 <Reset_Handler+0x8c>)
    4912:	4798      	blx	r3
	while (1)
    4914:	e7fe      	b.n	4914 <Reset_Handler+0x60>
    4916:	bf00      	nop
    4918:	0000ce14 	.word	0x0000ce14
    491c:	20000000 	.word	0x20000000
    4920:	20000080 	.word	0x20000080
    4924:	0000c07d 	.word	0x0000c07d
    4928:	200168c4 	.word	0x200168c4
    492c:	20000080 	.word	0x20000080
    4930:	0000c099 	.word	0x0000c099
    4934:	00000000 	.word	0x00000000
    4938:	e000ed00 	.word	0xe000ed00
    493c:	0000c015 	.word	0x0000c015
    4940:	00004b89 	.word	0x00004b89

00004944 <_gpio_set_pin_function>:

/**
 * \brief Set gpio pin function
 */
static inline void _gpio_set_pin_function(const uint32_t gpio, const uint32_t function)
{
    4944:	b530      	push	{r4, r5, lr}
	uint8_t port = GPIO_PORT(gpio);
	uint8_t pin  = GPIO_PIN(gpio);

	if (function == GPIO_PIN_FUNCTION_OFF) {
    4946:	1c4b      	adds	r3, r1, #1
	uint8_t pin  = GPIO_PIN(gpio);
    4948:	b2c5      	uxtb	r5, r0
    494a:	4b18      	ldr	r3, [pc, #96]	; (49ac <_gpio_set_pin_function+0x68>)
    494c:	f000 041f 	and.w	r4, r0, #31
	uint8_t port = GPIO_PORT(gpio);
    4950:	ea4f 1050 	mov.w	r0, r0, lsr #5
    4954:	ea4f 10c0 	mov.w	r0, r0, lsl #7
static inline void hri_port_write_PINCFG_PMUXEN_bit(const void *const hw, uint8_t submodule_index, uint8_t index,
                                                    bool value)
{
	uint8_t tmp;
	PORT_CRITICAL_SECTION_ENTER();
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
    4958:	4403      	add	r3, r0
	if (function == GPIO_PIN_FUNCTION_OFF) {
    495a:	d107      	bne.n	496c <_gpio_set_pin_function+0x28>
    495c:	4423      	add	r3, r4
    495e:	f893 2040 	ldrb.w	r2, [r3, #64]	; 0x40
	tmp &= ~PORT_PINCFG_PMUXEN;
    4962:	f002 02fe 	and.w	r2, r2, #254	; 0xfe
	tmp |= value << PORT_PINCFG_PMUXEN_Pos;
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
    4966:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
		} else {
			// Even numbered pin
			hri_port_write_PMUX_PMUXE_bf(PORT, port, pin >> 1, function & 0xffff);
		}
	}
}
    496a:	bd30      	pop	{r4, r5, pc}
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
    496c:	1918      	adds	r0, r3, r4
    496e:	eb03 0354 	add.w	r3, r3, r4, lsr #1
    4972:	f890 2040 	ldrb.w	r2, [r0, #64]	; 0x40
	tmp &= ~PORT_PINCFG_PMUXEN;
    4976:	f002 02fe 	and.w	r2, r2, #254	; 0xfe
	tmp |= value << PORT_PINCFG_PMUXEN_Pos;
    497a:	f042 0201 	orr.w	r2, r2, #1
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
    497e:	f880 2040 	strb.w	r2, [r0, #64]	; 0x40
	tmp = ((Port *)hw)->Group[submodule_index].PMUX[index].reg;
    4982:	f893 2030 	ldrb.w	r2, [r3, #48]	; 0x30
		if (pin & 1) {
    4986:	f015 0f01 	tst.w	r5, #1
			hri_port_write_PMUX_PMUXO_bf(PORT, port, pin >> 1, function & 0xffff);
    498a:	b2c9      	uxtb	r1, r1
	tmp &= ~PORT_PMUX_PMUXO_Msk;
    498c:	bf19      	ittee	ne
    498e:	f002 020f 	andne.w	r2, r2, #15
	tmp |= PORT_PMUX_PMUXO(data);
    4992:	ea42 1101 	orrne.w	r1, r2, r1, lsl #4
	tmp |= PORT_PMUX_PMUXE(data);
    4996:	f001 010f 	andeq.w	r1, r1, #15
	tmp &= ~PORT_PMUX_PMUXE_Msk;
    499a:	f002 02f0 	andeq.w	r2, r2, #240	; 0xf0
	tmp |= PORT_PMUX_PMUXO(data);
    499e:	bf14      	ite	ne
    49a0:	b2c9      	uxtbne	r1, r1
	tmp |= PORT_PMUX_PMUXE(data);
    49a2:	4311      	orreq	r1, r2
	((Port *)hw)->Group[submodule_index].PMUX[index].reg = tmp;
    49a4:	f883 1030 	strb.w	r1, [r3, #48]	; 0x30
}
    49a8:	e7df      	b.n	496a <_gpio_set_pin_function+0x26>
    49aa:	bf00      	nop
    49ac:	41008000 	.word	0x41008000

000049b0 <TARGET_IO_PORT_init>:
struct usart_sync_descriptor TARGET_IO;

struct mac_async_descriptor COMMUNICATION_IO;

void TARGET_IO_PORT_init(void)
{
    49b0:	b510      	push	{r4, lr}
 *                      found in the header files for the device
 *
 */
static inline void gpio_set_pin_function(const uint32_t pin, uint32_t function)
{
	_gpio_set_pin_function(pin, function);
    49b2:	4c05      	ldr	r4, [pc, #20]	; (49c8 <TARGET_IO_PORT_init+0x18>)
    49b4:	4905      	ldr	r1, [pc, #20]	; (49cc <TARGET_IO_PORT_init+0x1c>)
    49b6:	2039      	movs	r0, #57	; 0x39
    49b8:	47a0      	blx	r4
    49ba:	4623      	mov	r3, r4
    49bc:	4904      	ldr	r1, [pc, #16]	; (49d0 <TARGET_IO_PORT_init+0x20>)

	gpio_set_pin_function(PB25, PINMUX_PB25D_SERCOM2_PAD0);

	gpio_set_pin_function(PB24, PINMUX_PB24D_SERCOM2_PAD1);
}
    49be:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    49c2:	2038      	movs	r0, #56	; 0x38
    49c4:	4718      	bx	r3
    49c6:	bf00      	nop
    49c8:	00004945 	.word	0x00004945
    49cc:	00390003 	.word	0x00390003
    49d0:	00380003 	.word	0x00380003

000049d4 <TARGET_IO_CLOCK_init>:
}

static inline void hri_gclk_write_PCHCTRL_reg(const void *const hw, uint8_t index, hri_gclk_pchctrl_reg_t data)
{
	GCLK_CRITICAL_SECTION_ENTER();
	((Gclk *)hw)->PCHCTRL[index].reg = data;
    49d4:	4b06      	ldr	r3, [pc, #24]	; (49f0 <TARGET_IO_CLOCK_init+0x1c>)
    49d6:	2240      	movs	r2, #64	; 0x40
    49d8:	f8c3 20dc 	str.w	r2, [r3, #220]	; 0xdc
    49dc:	2243      	movs	r2, #67	; 0x43
    49de:	f8c3 208c 	str.w	r2, [r3, #140]	; 0x8c
}

static inline void hri_mclk_set_APBBMASK_SERCOM2_bit(const void *const hw)
{
	MCLK_CRITICAL_SECTION_ENTER();
	((Mclk *)hw)->APBBMASK.reg |= MCLK_APBBMASK_SERCOM2;
    49e2:	4a04      	ldr	r2, [pc, #16]	; (49f4 <TARGET_IO_CLOCK_init+0x20>)
    49e4:	6993      	ldr	r3, [r2, #24]
    49e6:	f443 7300 	orr.w	r3, r3, #512	; 0x200
    49ea:	6193      	str	r3, [r2, #24]
{
	hri_gclk_write_PCHCTRL_reg(GCLK, SERCOM2_GCLK_ID_CORE, CONF_GCLK_SERCOM2_CORE_SRC | (1 << GCLK_PCHCTRL_CHEN_Pos));
	hri_gclk_write_PCHCTRL_reg(GCLK, SERCOM2_GCLK_ID_SLOW, CONF_GCLK_SERCOM2_SLOW_SRC | (1 << GCLK_PCHCTRL_CHEN_Pos));

	hri_mclk_set_APBBMASK_SERCOM2_bit(MCLK);
}
    49ec:	4770      	bx	lr
    49ee:	bf00      	nop
    49f0:	40001c00 	.word	0x40001c00
    49f4:	40000800 	.word	0x40000800

000049f8 <TARGET_IO_init>:

void TARGET_IO_init(void)
{
    49f8:	b510      	push	{r4, lr}
	TARGET_IO_CLOCK_init();
    49fa:	4b05      	ldr	r3, [pc, #20]	; (4a10 <TARGET_IO_init+0x18>)
	usart_sync_init(&TARGET_IO, SERCOM2, (void *)NULL);
    49fc:	4905      	ldr	r1, [pc, #20]	; (4a14 <TARGET_IO_init+0x1c>)
    49fe:	4806      	ldr	r0, [pc, #24]	; (4a18 <TARGET_IO_init+0x20>)
	TARGET_IO_CLOCK_init();
    4a00:	4798      	blx	r3
	usart_sync_init(&TARGET_IO, SERCOM2, (void *)NULL);
    4a02:	4b06      	ldr	r3, [pc, #24]	; (4a1c <TARGET_IO_init+0x24>)
    4a04:	2200      	movs	r2, #0
    4a06:	4798      	blx	r3
	TARGET_IO_PORT_init();
}
    4a08:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	TARGET_IO_PORT_init();
    4a0c:	4b04      	ldr	r3, [pc, #16]	; (4a20 <TARGET_IO_init+0x28>)
    4a0e:	4718      	bx	r3
    4a10:	000049d5 	.word	0x000049d5
    4a14:	41012000 	.word	0x41012000
    4a18:	2000a514 	.word	0x2000a514
    4a1c:	00000f05 	.word	0x00000f05
    4a20:	000049b1 	.word	0x000049b1

00004a24 <COMMUNICATION_IO_PORT_init>:

void COMMUNICATION_IO_PORT_init(void)
{
    4a24:	b510      	push	{r4, lr}
    4a26:	4911      	ldr	r1, [pc, #68]	; (4a6c <COMMUNICATION_IO_PORT_init+0x48>)
    4a28:	4c11      	ldr	r4, [pc, #68]	; (4a70 <COMMUNICATION_IO_PORT_init+0x4c>)
    4a2a:	204b      	movs	r0, #75	; 0x4b
    4a2c:	47a0      	blx	r4
    4a2e:	4911      	ldr	r1, [pc, #68]	; (4a74 <COMMUNICATION_IO_PORT_init+0x50>)
    4a30:	204c      	movs	r0, #76	; 0x4c
    4a32:	47a0      	blx	r4
    4a34:	4910      	ldr	r1, [pc, #64]	; (4a78 <COMMUNICATION_IO_PORT_init+0x54>)
    4a36:	200d      	movs	r0, #13
    4a38:	47a0      	blx	r4
    4a3a:	4910      	ldr	r1, [pc, #64]	; (4a7c <COMMUNICATION_IO_PORT_init+0x58>)
    4a3c:	200c      	movs	r0, #12
    4a3e:	47a0      	blx	r4
    4a40:	490f      	ldr	r1, [pc, #60]	; (4a80 <COMMUNICATION_IO_PORT_init+0x5c>)
    4a42:	2054      	movs	r0, #84	; 0x54
    4a44:	47a0      	blx	r4
    4a46:	490f      	ldr	r1, [pc, #60]	; (4a84 <COMMUNICATION_IO_PORT_init+0x60>)
    4a48:	200f      	movs	r0, #15
    4a4a:	47a0      	blx	r4
    4a4c:	490e      	ldr	r1, [pc, #56]	; (4a88 <COMMUNICATION_IO_PORT_init+0x64>)
    4a4e:	2012      	movs	r0, #18
    4a50:	47a0      	blx	r4
    4a52:	490e      	ldr	r1, [pc, #56]	; (4a8c <COMMUNICATION_IO_PORT_init+0x68>)
    4a54:	2013      	movs	r0, #19
    4a56:	47a0      	blx	r4
    4a58:	490d      	ldr	r1, [pc, #52]	; (4a90 <COMMUNICATION_IO_PORT_init+0x6c>)
    4a5a:	200e      	movs	r0, #14
    4a5c:	47a0      	blx	r4
    4a5e:	4623      	mov	r3, r4
    4a60:	490c      	ldr	r1, [pc, #48]	; (4a94 <COMMUNICATION_IO_PORT_init+0x70>)
	gpio_set_pin_function(PA19, PINMUX_PA19L_GMAC_GTX1);

	gpio_set_pin_function(PA14, PINMUX_PA14L_GMAC_GTXCK);

	gpio_set_pin_function(PA17, PINMUX_PA17L_GMAC_GTXEN);
}
    4a62:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    4a66:	2011      	movs	r0, #17
    4a68:	4718      	bx	r3
    4a6a:	bf00      	nop
    4a6c:	004b000b 	.word	0x004b000b
    4a70:	00004945 	.word	0x00004945
    4a74:	004c000b 	.word	0x004c000b
    4a78:	000d000b 	.word	0x000d000b
    4a7c:	000c000b 	.word	0x000c000b
    4a80:	0054000b 	.word	0x0054000b
    4a84:	000f000b 	.word	0x000f000b
    4a88:	0012000b 	.word	0x0012000b
    4a8c:	0013000b 	.word	0x0013000b
    4a90:	000e000b 	.word	0x000e000b
    4a94:	0011000b 	.word	0x0011000b

00004a98 <COMMUNICATION_IO_CLOCK_init>:
	((Mclk *)hw)->AHBMASK.reg |= MCLK_AHBMASK_GMAC;
    4a98:	4b04      	ldr	r3, [pc, #16]	; (4aac <COMMUNICATION_IO_CLOCK_init+0x14>)
    4a9a:	691a      	ldr	r2, [r3, #16]
    4a9c:	f442 4280 	orr.w	r2, r2, #16384	; 0x4000
    4aa0:	611a      	str	r2, [r3, #16]
}

static inline void hri_mclk_set_APBCMASK_GMAC_bit(const void *const hw)
{
	MCLK_CRITICAL_SECTION_ENTER();
	((Mclk *)hw)->APBCMASK.reg |= MCLK_APBCMASK_GMAC;
    4aa2:	69da      	ldr	r2, [r3, #28]
    4aa4:	f042 0204 	orr.w	r2, r2, #4
    4aa8:	61da      	str	r2, [r3, #28]

void COMMUNICATION_IO_CLOCK_init(void)
{
	hri_mclk_set_AHBMASK_GMAC_bit(MCLK);
	hri_mclk_set_APBCMASK_GMAC_bit(MCLK);
}
    4aaa:	4770      	bx	lr
    4aac:	40000800 	.word	0x40000800

00004ab0 <COMMUNICATION_IO_init>:

void COMMUNICATION_IO_init(void)
{
    4ab0:	b510      	push	{r4, lr}
	COMMUNICATION_IO_CLOCK_init();
    4ab2:	4b05      	ldr	r3, [pc, #20]	; (4ac8 <COMMUNICATION_IO_init+0x18>)
	mac_async_init(&COMMUNICATION_IO, GMAC);
    4ab4:	4905      	ldr	r1, [pc, #20]	; (4acc <COMMUNICATION_IO_init+0x1c>)
    4ab6:	4806      	ldr	r0, [pc, #24]	; (4ad0 <COMMUNICATION_IO_init+0x20>)
	COMMUNICATION_IO_CLOCK_init();
    4ab8:	4798      	blx	r3
	mac_async_init(&COMMUNICATION_IO, GMAC);
    4aba:	4b06      	ldr	r3, [pc, #24]	; (4ad4 <COMMUNICATION_IO_init+0x24>)
    4abc:	4798      	blx	r3
	COMMUNICATION_IO_PORT_init();
}
    4abe:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	COMMUNICATION_IO_PORT_init();
    4ac2:	4b05      	ldr	r3, [pc, #20]	; (4ad8 <COMMUNICATION_IO_init+0x28>)
    4ac4:	4718      	bx	r3
    4ac6:	bf00      	nop
    4ac8:	00004a99 	.word	0x00004a99
    4acc:	42000800 	.word	0x42000800
    4ad0:	2000a520 	.word	0x2000a520
    4ad4:	00004c45 	.word	0x00004c45
    4ad8:	00004a25 	.word	0x00004a25

00004adc <system_init>:
	mac_async_enable(&COMMUNICATION_IO);
	mac_async_write(&COMMUNICATION_IO, (uint8_t *)"Hello World!", 12);
}

void system_init(void)
{
    4adc:	b510      	push	{r4, lr}
 * Currently the following initialization functions are supported:
 *  - System clock initialization
 */
static inline void init_mcu(void)
{
	_init_chip();
    4ade:	4b0d      	ldr	r3, [pc, #52]	; (4b14 <system_init+0x38>)
    4ae0:	4798      	blx	r3
	((Port *)hw)->Group[submodule_index].OUTSET.reg = mask;
    4ae2:	4b0d      	ldr	r3, [pc, #52]	; (4b18 <system_init+0x3c>)
    4ae4:	f44f 2280 	mov.w	r2, #262144	; 0x40000
    4ae8:	f8c3 2118 	str.w	r2, [r3, #280]	; 0x118
	((Port *)hw)->Group[submodule_index].DIRSET.reg = mask;
    4aec:	f8c3 2108 	str.w	r2, [r3, #264]	; 0x108

static inline void hri_port_write_WRCONFIG_reg(const void *const hw, uint8_t submodule_index,
                                               hri_port_wrconfig_reg_t data)
{
	PORT_CRITICAL_SECTION_ENTER();
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
    4af0:	f04f 4280 	mov.w	r2, #1073741824	; 0x40000000
    4af4:	f8c3 2128 	str.w	r2, [r3, #296]	; 0x128
    4af8:	4a08      	ldr	r2, [pc, #32]	; (4b1c <system_init+0x40>)
    4afa:	f8c3 2128 	str.w	r2, [r3, #296]	; 0x128
    4afe:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
    4b02:	4b07      	ldr	r3, [pc, #28]	; (4b20 <system_init+0x44>)
    4b04:	2052      	movs	r0, #82	; 0x52
    4b06:	4798      	blx	r3
	// Set pin direction to output
	gpio_set_pin_direction(LED_0, GPIO_DIRECTION_OUT);

	gpio_set_pin_function(LED_0, GPIO_PIN_FUNCTION_OFF);

	TARGET_IO_init();
    4b08:	4b06      	ldr	r3, [pc, #24]	; (4b24 <system_init+0x48>)
    4b0a:	4798      	blx	r3

	COMMUNICATION_IO_init();
}
    4b0c:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	COMMUNICATION_IO_init();
    4b10:	4b05      	ldr	r3, [pc, #20]	; (4b28 <system_init+0x4c>)
    4b12:	4718      	bx	r3
    4b14:	00007945 	.word	0x00007945
    4b18:	41008000 	.word	0x41008000
    4b1c:	c0000004 	.word	0xc0000004
    4b20:	00004945 	.word	0x00004945
    4b24:	000049f9 	.word	0x000049f9
    4b28:	00004ab1 	.word	0x00004ab1

00004b2c <print_ipaddress>:

/* define to avoid compilation warning */
// #define LWIP_TIMEVAL_PRIVATE 0

void print_ipaddress(void)
{
    4b2c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	static char tmp_buff[16];
	printf("IP_ADDR    : %s\r\n",
    4b30:	4f0e      	ldr	r7, [pc, #56]	; (4b6c <print_ipaddress+0x40>)
    4b32:	4e0f      	ldr	r6, [pc, #60]	; (4b70 <print_ipaddress+0x44>)
    4b34:	4d0f      	ldr	r5, [pc, #60]	; (4b74 <print_ipaddress+0x48>)
    4b36:	4c10      	ldr	r4, [pc, #64]	; (4b78 <print_ipaddress+0x4c>)
    4b38:	2210      	movs	r2, #16
    4b3a:	4639      	mov	r1, r7
    4b3c:	4630      	mov	r0, r6
    4b3e:	47a8      	blx	r5
    4b40:	4601      	mov	r1, r0
    4b42:	480e      	ldr	r0, [pc, #56]	; (4b7c <print_ipaddress+0x50>)
    4b44:	47a0      	blx	r4
	       ipaddr_ntoa_r((const ip_addr_t *)&(TCPIP_STACK_INTERFACE_0_desc.ip_addr), tmp_buff, 16));
	printf("NET_MASK   : %s\r\n",
    4b46:	2210      	movs	r2, #16
    4b48:	4639      	mov	r1, r7
    4b4a:	1d30      	adds	r0, r6, #4
    4b4c:	47a8      	blx	r5
    4b4e:	4601      	mov	r1, r0
    4b50:	480b      	ldr	r0, [pc, #44]	; (4b80 <print_ipaddress+0x54>)
    4b52:	47a0      	blx	r4
	       ipaddr_ntoa_r((const ip_addr_t *)&(TCPIP_STACK_INTERFACE_0_desc.netmask), tmp_buff, 16));
	printf("GATEWAY_IP : %s\r\n", ipaddr_ntoa_r((const ip_addr_t *)&(TCPIP_STACK_INTERFACE_0_desc.gw), tmp_buff, 16));
    4b54:	4639      	mov	r1, r7
    4b56:	f106 0008 	add.w	r0, r6, #8
    4b5a:	2210      	movs	r2, #16
    4b5c:	47a8      	blx	r5
    4b5e:	4623      	mov	r3, r4
    4b60:	4601      	mov	r1, r0
}
    4b62:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
	printf("GATEWAY_IP : %s\r\n", ipaddr_ntoa_r((const ip_addr_t *)&(TCPIP_STACK_INTERFACE_0_desc.gw), tmp_buff, 16));
    4b66:	4807      	ldr	r0, [pc, #28]	; (4b84 <print_ipaddress+0x58>)
    4b68:	4718      	bx	r3
    4b6a:	bf00      	nop
    4b6c:	2000a53c 	.word	0x2000a53c
    4b70:	20014964 	.word	0x20014964
    4b74:	00008a55 	.word	0x00008a55
    4b78:	0000b395 	.word	0x0000b395
    4b7c:	0000c99f 	.word	0x0000c99f
    4b80:	0000c9b1 	.word	0x0000c9b1
    4b84:	0000c9c3 	.word	0x0000c9c3

00004b88 <main>:
 * #define LWIP_TIMEVAL_PRIVATE		0
 *
 */

int main(void)
{
    4b88:	b508      	push	{r3, lr}
	/* Initializes MCU, drivers and middleware */
	atmel_start_init();
    4b8a:	4b05      	ldr	r3, [pc, #20]	; (4ba0 <main+0x18>)
    4b8c:	4798      	blx	r3

	/* Initialize SEGGER RTT for debug output */
	rtt_printf_init();
    4b8e:	4b05      	ldr	r3, [pc, #20]	; (4ba4 <main+0x1c>)
    4b90:	4798      	blx	r3

	/*Handles Socket API */
	printf("\r\nSocket API implementation\r\n");
    4b92:	4b05      	ldr	r3, [pc, #20]	; (4ba8 <main+0x20>)
    4b94:	4805      	ldr	r0, [pc, #20]	; (4bac <main+0x24>)
    4b96:	4798      	blx	r3
	basic_socket();
    4b98:	4b05      	ldr	r3, [pc, #20]	; (4bb0 <main+0x28>)
    4b9a:	4798      	blx	r3

	while (1)
    4b9c:	e7fe      	b.n	4b9c <main+0x14>
    4b9e:	bf00      	nop
    4ba0:	00004df5 	.word	0x00004df5
    4ba4:	0000b3c1 	.word	0x0000b3c1
    4ba8:	0000b395 	.word	0x0000b395
    4bac:	0000c9d5 	.word	0x0000c9d5
    4bb0:	0000858d 	.word	0x0000858d

00004bb4 <memp_init>:
 * Initialize this module.
 *
 * Carves out memp_memory into linked lists for each pool-type.
 */
void memp_init(void)
{
    4bb4:	b5f0      	push	{r4, r5, r6, r7, lr}
		MEMP_STATS_AVAIL(err, i, 0);
		MEMP_STATS_AVAIL(avail, i, memp_num[i]);
	}

#if !MEMP_SEPARATE_POOLS
	memp = (struct memp *)LWIP_MEM_ALIGN(memp_memory);
    4bb6:	4b10      	ldr	r3, [pc, #64]	; (4bf8 <memp_init+0x44>)
    4bb8:	4c10      	ldr	r4, [pc, #64]	; (4bfc <memp_init+0x48>)
    4bba:	4911      	ldr	r1, [pc, #68]	; (4c00 <memp_init+0x4c>)
    4bbc:	f023 0303 	bic.w	r3, r3, #3
#endif /* !MEMP_SEPARATE_POOLS */
	/* for every pool: */
	for (i = 0; i < MEMP_MAX; ++i) {
    4bc0:	f104 001a 	add.w	r0, r4, #26
	memp = (struct memp *)LWIP_MEM_ALIGN(memp_memory);
    4bc4:	220d      	movs	r2, #13
		memp_tab[i] = NULL;
    4bc6:	2600      	movs	r6, #0
    4bc8:	f841 6b04 	str.w	r6, [r1], #4
#if MEMP_SEPARATE_POOLS
		memp = (struct memp *)memp_bases[i];
#endif /* MEMP_SEPARATE_POOLS */
		/* create a linked list of memp elements */
		for (j = 0; j < memp_num[i]; ++j) {
    4bcc:	f834 cb02 	ldrh.w	ip, [r4], #2
    4bd0:	2500      	movs	r5, #0
    4bd2:	b2af      	uxth	r7, r5
    4bd4:	45bc      	cmp	ip, r7
    4bd6:	d805      	bhi.n	4be4 <memp_init+0x30>
	for (i = 0; i < MEMP_MAX; ++i) {
    4bd8:	3a01      	subs	r2, #1
    4bda:	b292      	uxth	r2, r2
    4bdc:	3002      	adds	r0, #2
    4bde:	2a00      	cmp	r2, #0
    4be0:	d1f2      	bne.n	4bc8 <memp_init+0x14>
#if MEMP_OVERFLOW_CHECK
	memp_overflow_init();
	/* check everything a first time to see if it worked */
	memp_overflow_check_all();
#endif /* MEMP_OVERFLOW_CHECK */
}
    4be2:	bdf0      	pop	{r4, r5, r6, r7, pc}
			memp->next  = memp_tab[i];
    4be4:	f851 7c04 	ldr.w	r7, [r1, #-4]
    4be8:	601f      	str	r7, [r3, #0]
			memp        = (struct memp *)(void *)((u8_t *)memp + MEMP_SIZE + memp_sizes[i]
    4bea:	8807      	ldrh	r7, [r0, #0]
			memp_tab[i] = memp;
    4bec:	f841 3c04 	str.w	r3, [r1, #-4]
			memp        = (struct memp *)(void *)((u8_t *)memp + MEMP_SIZE + memp_sizes[i]
    4bf0:	3501      	adds	r5, #1
    4bf2:	443b      	add	r3, r7
		for (j = 0; j < memp_num[i]; ++j) {
    4bf4:	e7ed      	b.n	4bd2 <memp_init+0x1e>
    4bf6:	bf00      	nop
    4bf8:	2000a583 	.word	0x2000a583
    4bfc:	0000c9f4 	.word	0x0000c9f4
    4c00:	2000a54c 	.word	0x2000a54c

00004c04 <memp_malloc>:
#endif
{
	struct memp *memp;
	SYS_ARCH_DECL_PROTECT(old_level);

	LWIP_ERROR("memp_malloc: type < MEMP_MAX", (type < MEMP_MAX), return NULL;);
    4c04:	280c      	cmp	r0, #12
    4c06:	d900      	bls.n	4c0a <memp_malloc+0x6>
    4c08:	e7fe      	b.n	4c08 <memp_malloc+0x4>
	SYS_ARCH_PROTECT(old_level);
#if MEMP_OVERFLOW_CHECK >= 2
	memp_overflow_check_all();
#endif /* MEMP_OVERFLOW_CHECK >= 2 */

	memp = memp_tab[type];
    4c0a:	4a04      	ldr	r2, [pc, #16]	; (4c1c <memp_malloc+0x18>)
    4c0c:	f852 3020 	ldr.w	r3, [r2, r0, lsl #2]

	if (memp != NULL) {
    4c10:	b113      	cbz	r3, 4c18 <memp_malloc+0x14>
		memp_tab[type] = memp->next;
    4c12:	6819      	ldr	r1, [r3, #0]
    4c14:	f842 1020 	str.w	r1, [r2, r0, lsl #2]
	}

	SYS_ARCH_UNPROTECT(old_level);

	return memp;
}
    4c18:	4618      	mov	r0, r3
    4c1a:	4770      	bx	lr
    4c1c:	2000a54c 	.word	0x2000a54c

00004c20 <memp_free>:
void memp_free(memp_t type, void *mem)
{
	struct memp *memp;
	SYS_ARCH_DECL_PROTECT(old_level);

	if (mem == NULL) {
    4c20:	b129      	cbz	r1, 4c2e <memp_free+0xe>
#endif /* MEMP_OVERFLOW_CHECK >= 2 */
#endif /* MEMP_OVERFLOW_CHECK */

	MEMP_STATS_DEC(used, type);

	memp->next     = memp_tab[type];
    4c22:	4b03      	ldr	r3, [pc, #12]	; (4c30 <memp_free+0x10>)
    4c24:	f853 2020 	ldr.w	r2, [r3, r0, lsl #2]
    4c28:	600a      	str	r2, [r1, #0]
	memp_tab[type] = memp;
    4c2a:	f843 1020 	str.w	r1, [r3, r0, lsl #2]
#if MEMP_SANITY_CHECK
	LWIP_ASSERT("memp sanity", memp_sanity());
#endif /* MEMP_SANITY_CHECK */

	SYS_ARCH_UNPROTECT(old_level);
}
    4c2e:	4770      	bx	lr
    4c30:	2000a54c 	.word	0x2000a54c

00004c34 <mac_read_cb>:
 */
static void mac_read_cb(struct _mac_async_device *dev)
{
	struct mac_async_descriptor *const descr = CONTAINER_OF(dev, struct mac_async_descriptor, dev);

	if (descr->cb.receive) {
    4c34:	6943      	ldr	r3, [r0, #20]
    4c36:	b103      	cbz	r3, 4c3a <mac_read_cb+0x6>
		descr->cb.receive(descr);
    4c38:	4718      	bx	r3
	}
}
    4c3a:	4770      	bx	lr

00004c3c <mac_write_cb>:
 */
static void mac_write_cb(struct _mac_async_device *dev)
{
	struct mac_async_descriptor *const descr = CONTAINER_OF(dev, struct mac_async_descriptor, dev);

	if (descr->cb.transmit) {
    4c3c:	6983      	ldr	r3, [r0, #24]
    4c3e:	b103      	cbz	r3, 4c42 <mac_write_cb+0x6>
		descr->cb.transmit(descr);
    4c40:	4718      	bx	r3
	}
}
    4c42:	4770      	bx	lr

00004c44 <mac_async_init>:
{
    4c44:	b570      	push	{r4, r5, r6, lr}
    4c46:	460d      	mov	r5, r1
	ASSERT(descr && hw);
    4c48:	4604      	mov	r4, r0
    4c4a:	b110      	cbz	r0, 4c52 <mac_async_init+0xe>
    4c4c:	1e08      	subs	r0, r1, #0
    4c4e:	bf18      	it	ne
    4c50:	2001      	movne	r0, #1
    4c52:	4905      	ldr	r1, [pc, #20]	; (4c68 <mac_async_init+0x24>)
    4c54:	4b05      	ldr	r3, [pc, #20]	; (4c6c <mac_async_init+0x28>)
    4c56:	2231      	movs	r2, #49	; 0x31
    4c58:	4798      	blx	r3
	return _mac_async_init(&descr->dev, hw);
    4c5a:	4629      	mov	r1, r5
    4c5c:	4620      	mov	r0, r4
    4c5e:	4b04      	ldr	r3, [pc, #16]	; (4c70 <mac_async_init+0x2c>)
}
    4c60:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	return _mac_async_init(&descr->dev, hw);
    4c64:	4718      	bx	r3
    4c66:	bf00      	nop
    4c68:	0000ca28 	.word	0x0000ca28
    4c6c:	00008a19 	.word	0x00008a19
    4c70:	00008621 	.word	0x00008621

00004c74 <mac_async_enable>:
{
    4c74:	b510      	push	{r4, lr}
	ASSERT(descr);
    4c76:	4604      	mov	r4, r0
    4c78:	3800      	subs	r0, #0
    4c7a:	4b05      	ldr	r3, [pc, #20]	; (4c90 <mac_async_enable+0x1c>)
    4c7c:	4905      	ldr	r1, [pc, #20]	; (4c94 <mac_async_enable+0x20>)
    4c7e:	bf18      	it	ne
    4c80:	2001      	movne	r0, #1
    4c82:	2245      	movs	r2, #69	; 0x45
    4c84:	4798      	blx	r3
	return _mac_async_enable(&descr->dev);
    4c86:	4620      	mov	r0, r4
    4c88:	4b03      	ldr	r3, [pc, #12]	; (4c98 <mac_async_enable+0x24>)
}
    4c8a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	return _mac_async_enable(&descr->dev);
    4c8e:	4718      	bx	r3
    4c90:	00008a19 	.word	0x00008a19
    4c94:	0000ca28 	.word	0x0000ca28
    4c98:	000086d1 	.word	0x000086d1

00004c9c <mac_async_write>:
{
    4c9c:	b570      	push	{r4, r5, r6, lr}
    4c9e:	460d      	mov	r5, r1
    4ca0:	4616      	mov	r6, r2
	ASSERT(descr && buf && len);
    4ca2:	4604      	mov	r4, r0
    4ca4:	b118      	cbz	r0, 4cae <mac_async_write+0x12>
    4ca6:	b169      	cbz	r1, 4cc4 <mac_async_write+0x28>
    4ca8:	1e10      	subs	r0, r2, #0
    4caa:	bf18      	it	ne
    4cac:	2001      	movne	r0, #1
    4cae:	4906      	ldr	r1, [pc, #24]	; (4cc8 <mac_async_write+0x2c>)
    4cb0:	4b06      	ldr	r3, [pc, #24]	; (4ccc <mac_async_write+0x30>)
    4cb2:	2257      	movs	r2, #87	; 0x57
    4cb4:	4798      	blx	r3
	return _mac_async_write(&descr->dev, buf, len);
    4cb6:	4632      	mov	r2, r6
    4cb8:	4629      	mov	r1, r5
    4cba:	4620      	mov	r0, r4
    4cbc:	4b04      	ldr	r3, [pc, #16]	; (4cd0 <mac_async_write+0x34>)
}
    4cbe:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	return _mac_async_write(&descr->dev, buf, len);
    4cc2:	4718      	bx	r3
	ASSERT(descr && buf && len);
    4cc4:	4608      	mov	r0, r1
    4cc6:	e7f2      	b.n	4cae <mac_async_write+0x12>
    4cc8:	0000ca28 	.word	0x0000ca28
    4ccc:	00008a19 	.word	0x00008a19
    4cd0:	000086e1 	.word	0x000086e1

00004cd4 <mac_async_read>:
{
    4cd4:	b570      	push	{r4, r5, r6, lr}
	ASSERT(descr);
    4cd6:	4604      	mov	r4, r0
    4cd8:	3800      	subs	r0, #0
{
    4cda:	460d      	mov	r5, r1
    4cdc:	4616      	mov	r6, r2
	ASSERT(descr);
    4cde:	4907      	ldr	r1, [pc, #28]	; (4cfc <mac_async_read+0x28>)
    4ce0:	4b07      	ldr	r3, [pc, #28]	; (4d00 <mac_async_read+0x2c>)
    4ce2:	f04f 0261 	mov.w	r2, #97	; 0x61
    4ce6:	bf18      	it	ne
    4ce8:	2001      	movne	r0, #1
    4cea:	4798      	blx	r3
	return _mac_async_read(&descr->dev, buf, len);
    4cec:	4632      	mov	r2, r6
    4cee:	4629      	mov	r1, r5
    4cf0:	4620      	mov	r0, r4
    4cf2:	4b04      	ldr	r3, [pc, #16]	; (4d04 <mac_async_read+0x30>)
}
    4cf4:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	return _mac_async_read(&descr->dev, buf, len);
    4cf8:	4718      	bx	r3
    4cfa:	bf00      	nop
    4cfc:	0000ca28 	.word	0x0000ca28
    4d00:	00008a19 	.word	0x00008a19
    4d04:	000087dd 	.word	0x000087dd

00004d08 <mac_async_read_len>:
{
    4d08:	b510      	push	{r4, lr}
	ASSERT(descr);
    4d0a:	4604      	mov	r4, r0
    4d0c:	3800      	subs	r0, #0
    4d0e:	4b05      	ldr	r3, [pc, #20]	; (4d24 <mac_async_read_len+0x1c>)
    4d10:	4905      	ldr	r1, [pc, #20]	; (4d28 <mac_async_read_len+0x20>)
    4d12:	bf18      	it	ne
    4d14:	2001      	movne	r0, #1
    4d16:	226b      	movs	r2, #107	; 0x6b
    4d18:	4798      	blx	r3
	return _mac_async_read_len(&descr->dev);
    4d1a:	4620      	mov	r0, r4
    4d1c:	4b03      	ldr	r3, [pc, #12]	; (4d2c <mac_async_read_len+0x24>)
}
    4d1e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	return _mac_async_read_len(&descr->dev);
    4d22:	4718      	bx	r3
    4d24:	00008a19 	.word	0x00008a19
    4d28:	0000ca28 	.word	0x0000ca28
    4d2c:	000088c5 	.word	0x000088c5

00004d30 <mac_async_register_callback>:
{
    4d30:	b570      	push	{r4, r5, r6, lr}
	ASSERT(descr);
    4d32:	4605      	mov	r5, r0
    4d34:	3800      	subs	r0, #0
{
    4d36:	460e      	mov	r6, r1
    4d38:	4614      	mov	r4, r2
	ASSERT(descr);
    4d3a:	bf18      	it	ne
    4d3c:	2001      	movne	r0, #1
    4d3e:	490c      	ldr	r1, [pc, #48]	; (4d70 <mac_async_register_callback+0x40>)
    4d40:	4b0c      	ldr	r3, [pc, #48]	; (4d74 <mac_async_register_callback+0x44>)
    4d42:	2289      	movs	r2, #137	; 0x89
    4d44:	4798      	blx	r3
	switch (type) {
    4d46:	b126      	cbz	r6, 4d52 <mac_async_register_callback+0x22>
    4d48:	2e01      	cmp	r6, #1
    4d4a:	d00d      	beq.n	4d68 <mac_async_register_callback+0x38>
}
    4d4c:	f06f 000c 	mvn.w	r0, #12
    4d50:	bd70      	pop	{r4, r5, r6, pc}
		return _mac_async_register_callback(&descr->dev, type, (func == NULL) ? NULL : (FUNC_PTR)mac_read_cb);
    4d52:	4a09      	ldr	r2, [pc, #36]	; (4d78 <mac_async_register_callback+0x48>)
		descr->cb.receive = (mac_async_cb_t)func;
    4d54:	616c      	str	r4, [r5, #20]
		return _mac_async_register_callback(&descr->dev, type, (func == NULL) ? NULL : (FUNC_PTR)mac_read_cb);
    4d56:	2c00      	cmp	r4, #0
		return _mac_async_register_callback(&descr->dev, type, (func == NULL) ? NULL : (FUNC_PTR)mac_write_cb);
    4d58:	bf08      	it	eq
    4d5a:	4622      	moveq	r2, r4
    4d5c:	4631      	mov	r1, r6
    4d5e:	4628      	mov	r0, r5
    4d60:	4b06      	ldr	r3, [pc, #24]	; (4d7c <mac_async_register_callback+0x4c>)
}
    4d62:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		return _mac_async_register_callback(&descr->dev, type, (func == NULL) ? NULL : (FUNC_PTR)mac_write_cb);
    4d66:	4718      	bx	r3
    4d68:	4a05      	ldr	r2, [pc, #20]	; (4d80 <mac_async_register_callback+0x50>)
		descr->cb.transmit = (mac_async_cb_t)func;
    4d6a:	61ac      	str	r4, [r5, #24]
		return _mac_async_register_callback(&descr->dev, type, (func == NULL) ? NULL : (FUNC_PTR)mac_write_cb);
    4d6c:	2c00      	cmp	r4, #0
    4d6e:	e7f3      	b.n	4d58 <mac_async_register_callback+0x28>
    4d70:	0000ca28 	.word	0x0000ca28
    4d74:	00008a19 	.word	0x00008a19
    4d78:	00004c35 	.word	0x00004c35
    4d7c:	00008919 	.word	0x00008919
    4d80:	00004c3d 	.word	0x00004c3d

00004d84 <mac_async_set_filter>:
{
    4d84:	b570      	push	{r4, r5, r6, lr}
    4d86:	460e      	mov	r6, r1
    4d88:	4615      	mov	r5, r2
	ASSERT(descr && filter);
    4d8a:	4604      	mov	r4, r0
    4d8c:	b110      	cbz	r0, 4d94 <mac_async_set_filter+0x10>
    4d8e:	1e10      	subs	r0, r2, #0
    4d90:	bf18      	it	ne
    4d92:	2001      	movne	r0, #1
    4d94:	4905      	ldr	r1, [pc, #20]	; (4dac <mac_async_set_filter+0x28>)
    4d96:	4b06      	ldr	r3, [pc, #24]	; (4db0 <mac_async_set_filter+0x2c>)
    4d98:	229b      	movs	r2, #155	; 0x9b
    4d9a:	4798      	blx	r3
	return _mac_async_set_filter(&descr->dev, index, filter);
    4d9c:	462a      	mov	r2, r5
    4d9e:	4631      	mov	r1, r6
    4da0:	4620      	mov	r0, r4
    4da2:	4b04      	ldr	r3, [pc, #16]	; (4db4 <mac_async_set_filter+0x30>)
}
    4da4:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	return _mac_async_set_filter(&descr->dev, index, filter);
    4da8:	4718      	bx	r3
    4daa:	bf00      	nop
    4dac:	0000ca28 	.word	0x0000ca28
    4db0:	00008a19 	.word	0x00008a19
    4db4:	00008941 	.word	0x00008941

00004db8 <mac_async_read_phy_reg>:
{
    4db8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    4dbc:	460e      	mov	r6, r1
    4dbe:	4617      	mov	r7, r2
    4dc0:	461d      	mov	r5, r3
	ASSERT(descr && val);
    4dc2:	4604      	mov	r4, r0
    4dc4:	b110      	cbz	r0, 4dcc <mac_async_read_phy_reg+0x14>
    4dc6:	1e18      	subs	r0, r3, #0
    4dc8:	bf18      	it	ne
    4dca:	2001      	movne	r0, #1
    4dcc:	4906      	ldr	r1, [pc, #24]	; (4de8 <mac_async_read_phy_reg+0x30>)
    4dce:	4b07      	ldr	r3, [pc, #28]	; (4dec <mac_async_read_phy_reg+0x34>)
    4dd0:	22b8      	movs	r2, #184	; 0xb8
    4dd2:	4798      	blx	r3
	return _mac_async_read_phy_reg(&descr->dev, addr, reg, val);
    4dd4:	4620      	mov	r0, r4
    4dd6:	4c06      	ldr	r4, [pc, #24]	; (4df0 <mac_async_read_phy_reg+0x38>)
    4dd8:	462b      	mov	r3, r5
    4dda:	463a      	mov	r2, r7
    4ddc:	4631      	mov	r1, r6
    4dde:	46a4      	mov	ip, r4
}
    4de0:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
	return _mac_async_read_phy_reg(&descr->dev, addr, reg, val);
    4de4:	4760      	bx	ip
    4de6:	bf00      	nop
    4de8:	0000ca28 	.word	0x0000ca28
    4dec:	00008a19 	.word	0x00008a19
    4df0:	00008981 	.word	0x00008981

00004df4 <atmel_start_init>:

/**
 * Initializes MCU, drivers and middleware in the project
 **/
void atmel_start_init(void)
{
    4df4:	b510      	push	{r4, lr}
	system_init();
    4df6:	4b04      	ldr	r3, [pc, #16]	; (4e08 <atmel_start_init+0x14>)
    4df8:	4798      	blx	r3
	ethernet_phys_init();
    4dfa:	4b04      	ldr	r3, [pc, #16]	; (4e0c <atmel_start_init+0x18>)
    4dfc:	4798      	blx	r3
	stdio_redirect_init();
}
    4dfe:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	stdio_redirect_init();
    4e02:	4b03      	ldr	r3, [pc, #12]	; (4e10 <atmel_start_init+0x1c>)
    4e04:	4718      	bx	r3
    4e06:	bf00      	nop
    4e08:	00004add 	.word	0x00004add
    4e0c:	00000e29 	.word	0x00000e29
    4e10:	00000fb1 	.word	0x00000fb1

00004e14 <etharp_free_entry>:

#endif /* ARP_QUEUEING */

/** Clean up ARP table entries */
static void etharp_free_entry(int i)
{
    4e14:	b570      	push	{r4, r5, r6, lr}
	/* remove from SNMP ARP index tree */
	snmp_delete_arpidx_tree(arp_table[i].netif, &arp_table[i].ipaddr);
	/* and empty packet queue */
	if (arp_table[i].q != NULL) {
    4e16:	2614      	movs	r6, #20
    4e18:	4c07      	ldr	r4, [pc, #28]	; (4e38 <etharp_free_entry+0x24>)
    4e1a:	4346      	muls	r6, r0
{
    4e1c:	4605      	mov	r5, r0
	if (arp_table[i].q != NULL) {
    4e1e:	59a0      	ldr	r0, [r4, r6]
    4e20:	b118      	cbz	r0, 4e2a <etharp_free_entry+0x16>
		/* remove all queued packets */
		LWIP_DEBUGF(
		    ETHARP_DEBUG,
		    ("etharp_free_entry: freeing entry %" U16_F ", packet queue %p.\n", (u16_t)i, (void *)(arp_table[i].q)));
		free_etharp_q(arp_table[i].q);
    4e22:	4b06      	ldr	r3, [pc, #24]	; (4e3c <etharp_free_entry+0x28>)
    4e24:	4798      	blx	r3
		arp_table[i].q = NULL;
    4e26:	2300      	movs	r3, #0
    4e28:	51a3      	str	r3, [r4, r6]
	}
	/* recycle entry for re-use */
	arp_table[i].state = ETHARP_STATE_EMPTY;
    4e2a:	2014      	movs	r0, #20
    4e2c:	fb00 4405 	mla	r4, r0, r5, r4
    4e30:	2300      	movs	r3, #0
    4e32:	74a3      	strb	r3, [r4, #18]
	arp_table[i].ctime = 0;
	arp_table[i].netif = NULL;
	ip_addr_set_zero(&arp_table[i].ipaddr);
	arp_table[i].ethaddr = ethzero;
#endif /* LWIP_DEBUG */
}
    4e34:	bd70      	pop	{r4, r5, r6, pc}
    4e36:	bf00      	nop
    4e38:	20011004 	.word	0x20011004
    4e3c:	000030e1 	.word	0x000030e1

00004e40 <etharp_find_entry>:
 *
 * @return The ARP entry index that matched or is created, ERR_MEM if no
 * entry is found or could be recycled.
 */
static s8_t etharp_find_entry(ip_addr_t *ipaddr, u8_t flags)
{
    4e40:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    4e44:	2200      	movs	r2, #0
	s8_t old_pending = ARP_TABLE_SIZE, old_stable = ARP_TABLE_SIZE;
	s8_t empty = ARP_TABLE_SIZE;
	u8_t i = 0, age_pending = 0, age_stable = 0;
	/* oldest entry with packets on queue */
	s8_t old_queue = ARP_TABLE_SIZE;
    4e46:	230a      	movs	r3, #10
{
    4e48:	460e      	mov	r6, r1
    4e4a:	4930      	ldr	r1, [pc, #192]	; (4f0c <etharp_find_entry+0xcc>)
    4e4c:	4604      	mov	r4, r0
	/* its age */
	u8_t age_queue = 0;
    4e4e:	4692      	mov	sl, r2
	u8_t i = 0, age_pending = 0, age_stable = 0;
    4e50:	4691      	mov	r9, r2
    4e52:	4690      	mov	r8, r2
	s8_t empty = ARP_TABLE_SIZE;
    4e54:	4618      	mov	r0, r3
	s8_t old_pending = ARP_TABLE_SIZE, old_stable = ARP_TABLE_SIZE;
    4e56:	469e      	mov	lr, r3
    4e58:	469c      	mov	ip, r3
	 */

	for (i = 0; i < ARP_TABLE_SIZE; ++i) {
		u8_t state = arp_table[i].state;
		/* no empty entry found yet and now we do find one? */
		if ((empty == ARP_TABLE_SIZE) && (state == ETHARP_STATE_EMPTY)) {
    4e5a:	280a      	cmp	r0, #10
		u8_t state = arp_table[i].state;
    4e5c:	f891 b012 	ldrb.w	fp, [r1, #18]
		if ((empty == ARP_TABLE_SIZE) && (state == ETHARP_STATE_EMPTY)) {
    4e60:	d11c      	bne.n	4e9c <etharp_find_entry+0x5c>
    4e62:	f1bb 0f00 	cmp.w	fp, #0
    4e66:	d11c      	bne.n	4ea2 <etharp_find_entry+0x62>
			LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_find_entry: found empty entry %" U16_F "\n", (u16_t)i));
			/* remember first empty entry */
			empty = i;
    4e68:	b250      	sxtb	r0, r2
	for (i = 0; i < ARP_TABLE_SIZE; ++i) {
    4e6a:	3201      	adds	r2, #1
    4e6c:	2a0a      	cmp	r2, #10
    4e6e:	f101 0114 	add.w	r1, r1, #20
    4e72:	d1f2      	bne.n	4e5a <etharp_find_entry+0x1a>
		}
	}
	/* { we have no match } => try to create a new entry */

	/* don't create new entry, only search? */
	if (((flags & ETHARP_FLAG_FIND_ONLY) != 0) ||
    4e74:	2e01      	cmp	r6, #1
    4e76:	d146      	bne.n	4f06 <etharp_find_entry+0xc6>
    4e78:	280a      	cmp	r0, #10
    4e7a:	d031      	beq.n	4ee0 <etharp_find_entry+0xa0>
	 * { ETHARP_FLAG_TRY_HARD is set at this point }
	 */

	/* 1) empty entry available? */
	if (empty < ARP_TABLE_SIZE) {
		i = empty;
    4e7c:	b2c6      	uxtb	r6, r0

	LWIP_ASSERT("i < ARP_TABLE_SIZE", i < ARP_TABLE_SIZE);
	LWIP_ASSERT("arp_table[i].state == ETHARP_STATE_EMPTY", arp_table[i].state == ETHARP_STATE_EMPTY);

	/* IP address given? */
	if (ipaddr != NULL) {
    4e7e:	b12c      	cbz	r4, 4e8c <etharp_find_entry+0x4c>
		/* set IP address */
		ip_addr_copy(arp_table[i].ipaddr, *ipaddr);
    4e80:	4922      	ldr	r1, [pc, #136]	; (4f0c <etharp_find_entry+0xcc>)
    4e82:	6822      	ldr	r2, [r4, #0]
    4e84:	2314      	movs	r3, #20
    4e86:	fb03 1306 	mla	r3, r3, r6, r1
    4e8a:	605a      	str	r2, [r3, #4]
	}
	arp_table[i].ctime = 0;
    4e8c:	4a1f      	ldr	r2, [pc, #124]	; (4f0c <etharp_find_entry+0xcc>)
    4e8e:	2314      	movs	r3, #20
    4e90:	fb03 2506 	mla	r5, r3, r6, r2
    4e94:	2300      	movs	r3, #0
    4e96:	74eb      	strb	r3, [r5, #19]
	return (err_t)i;
    4e98:	b270      	sxtb	r0, r6
    4e9a:	e008      	b.n	4eae <etharp_find_entry+0x6e>
		} else if (state != ETHARP_STATE_EMPTY) {
    4e9c:	f1bb 0f00 	cmp.w	fp, #0
    4ea0:	d0e3      	beq.n	4e6a <etharp_find_entry+0x2a>
			if (ipaddr && ip_addr_cmp(ipaddr, &arp_table[i].ipaddr)) {
    4ea2:	b134      	cbz	r4, 4eb2 <etharp_find_entry+0x72>
    4ea4:	6827      	ldr	r7, [r4, #0]
    4ea6:	684d      	ldr	r5, [r1, #4]
    4ea8:	42af      	cmp	r7, r5
    4eaa:	d102      	bne.n	4eb2 <etharp_find_entry+0x72>
				return i;
    4eac:	b250      	sxtb	r0, r2
}
    4eae:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
			if (state == ETHARP_STATE_PENDING) {
    4eb2:	f1bb 0f01 	cmp.w	fp, #1
					if (arp_table[i].ctime >= age_queue) {
    4eb6:	7ccf      	ldrb	r7, [r1, #19]
			if (state == ETHARP_STATE_PENDING) {
    4eb8:	d10c      	bne.n	4ed4 <etharp_find_entry+0x94>
				if (arp_table[i].q != NULL) {
    4eba:	680d      	ldr	r5, [r1, #0]
    4ebc:	b125      	cbz	r5, 4ec8 <etharp_find_entry+0x88>
					if (arp_table[i].ctime >= age_queue) {
    4ebe:	4557      	cmp	r7, sl
    4ec0:	d3d3      	bcc.n	4e6a <etharp_find_entry+0x2a>
						old_queue = i;
    4ec2:	b253      	sxtb	r3, r2
    4ec4:	46ba      	mov	sl, r7
    4ec6:	e7d0      	b.n	4e6a <etharp_find_entry+0x2a>
					if (arp_table[i].ctime >= age_pending) {
    4ec8:	4547      	cmp	r7, r8
    4eca:	d3ce      	bcc.n	4e6a <etharp_find_entry+0x2a>
						old_pending = i;
    4ecc:	fa4f fc82 	sxtb.w	ip, r2
    4ed0:	46b8      	mov	r8, r7
    4ed2:	e7ca      	b.n	4e6a <etharp_find_entry+0x2a>
					if (arp_table[i].ctime >= age_stable) {
    4ed4:	454f      	cmp	r7, r9
						old_stable = i;
    4ed6:	bf24      	itt	cs
    4ed8:	fa4f fe82 	sxtbcs.w	lr, r2
    4edc:	46b9      	movcs	r9, r7
    4ede:	e7c4      	b.n	4e6a <etharp_find_entry+0x2a>
		if (old_stable < ARP_TABLE_SIZE) {
    4ee0:	f1be 0f0a 	cmp.w	lr, #10
    4ee4:	d005      	beq.n	4ef2 <etharp_find_entry+0xb2>
			i = old_stable;
    4ee6:	fa5f f68e 	uxtb.w	r6, lr
		etharp_free_entry(i);
    4eea:	4b09      	ldr	r3, [pc, #36]	; (4f10 <etharp_find_entry+0xd0>)
    4eec:	4630      	mov	r0, r6
    4eee:	4798      	blx	r3
    4ef0:	e7c5      	b.n	4e7e <etharp_find_entry+0x3e>
		} else if (old_pending < ARP_TABLE_SIZE) {
    4ef2:	f1bc 0f0a 	cmp.w	ip, #10
    4ef6:	d002      	beq.n	4efe <etharp_find_entry+0xbe>
			i = old_pending;
    4ef8:	fa5f f68c 	uxtb.w	r6, ip
			            ("etharp_find_entry: selecting oldest pending entry %" U16_F " (without queue)\n", (u16_t)i));
    4efc:	e7f5      	b.n	4eea <etharp_find_entry+0xaa>
		} else if (old_queue < ARP_TABLE_SIZE) {
    4efe:	2b0a      	cmp	r3, #10
    4f00:	d001      	beq.n	4f06 <etharp_find_entry+0xc6>
			i = old_queue;
    4f02:	b2de      	uxtb	r6, r3
			             (void *)(arp_table[i].q)));
    4f04:	e7f1      	b.n	4eea <etharp_find_entry+0xaa>
		return (s8_t)ERR_MEM;
    4f06:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    4f0a:	e7d0      	b.n	4eae <etharp_find_entry+0x6e>
    4f0c:	20011004 	.word	0x20011004
    4f10:	00004e15 	.word	0x00004e15

00004f14 <etharp_send_ip>:
 * @params src the source MAC address to be copied into the ethernet header
 * @params dst the destination MAC address to be copied into the ethernet header
 * @return ERR_OK if the packet was sent, any other err_t on failure
 */
static err_t etharp_send_ip(struct netif *netif, struct pbuf *p, struct eth_addr *src, struct eth_addr *dst)
{
    4f14:	b430      	push	{r4, r5}
	struct eth_hdr *ethhdr = (struct eth_hdr *)p->payload;
    4f16:	684c      	ldr	r4, [r1, #4]

	LWIP_ASSERT("netif->hwaddr_len must be the same as ETHARP_HWADDR_LEN for etharp!",
	            (netif->hwaddr_len == ETHARP_HWADDR_LEN));
	ETHADDR32_COPY(&ethhdr->dest, dst);
    4f18:	681d      	ldr	r5, [r3, #0]
    4f1a:	f8c4 5002 	str.w	r5, [r4, #2]
    4f1e:	889b      	ldrh	r3, [r3, #4]
    4f20:	80e3      	strh	r3, [r4, #6]
	ETHADDR16_COPY(&ethhdr->src, src);
    4f22:	6813      	ldr	r3, [r2, #0]
    4f24:	60a3      	str	r3, [r4, #8]
    4f26:	8893      	ldrh	r3, [r2, #4]
    4f28:	81a3      	strh	r3, [r4, #12]
	ethhdr->type = PP_HTONS(ETHTYPE_IP);
    4f2a:	2308      	movs	r3, #8
    4f2c:	73a3      	strb	r3, [r4, #14]
    4f2e:	2300      	movs	r3, #0
    4f30:	73e3      	strb	r3, [r4, #15]
	LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_send_ip: sending packet %p\n", (void *)p));
	/* send the packet */
	return netif->linkoutput(netif, p);
}
    4f32:	bc30      	pop	{r4, r5}
	return netif->linkoutput(netif, p);
    4f34:	6983      	ldr	r3, [r0, #24]
    4f36:	4718      	bx	r3

00004f38 <etharp_tmr>:
{
    4f38:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    4f3a:	4c0e      	ldr	r4, [pc, #56]	; (4f74 <etharp_tmr+0x3c>)
				etharp_free_entry(i);
    4f3c:	4e0e      	ldr	r6, [pc, #56]	; (4f78 <etharp_tmr+0x40>)
{
    4f3e:	2500      	movs	r5, #0
				arp_table[i].state = ETHARP_STATE_STABLE;
    4f40:	2702      	movs	r7, #2
		u8_t state = arp_table[i].state;
    4f42:	7ca2      	ldrb	r2, [r4, #18]
		if (state != ETHARP_STATE_EMPTY
    4f44:	b15a      	cbz	r2, 4f5e <etharp_tmr+0x26>
			arp_table[i].ctime++;
    4f46:	7ce3      	ldrb	r3, [r4, #19]
    4f48:	3301      	adds	r3, #1
    4f4a:	b2db      	uxtb	r3, r3
			if ((arp_table[i].ctime >= ARP_MAXAGE)
    4f4c:	2bef      	cmp	r3, #239	; 0xef
			arp_table[i].ctime++;
    4f4e:	74e3      	strb	r3, [r4, #19]
			if ((arp_table[i].ctime >= ARP_MAXAGE)
    4f50:	d803      	bhi.n	4f5a <etharp_tmr+0x22>
			    || ((arp_table[i].state == ETHARP_STATE_PENDING) && (arp_table[i].ctime >= ARP_MAXPENDING))) {
    4f52:	2a01      	cmp	r2, #1
    4f54:	d109      	bne.n	4f6a <etharp_tmr+0x32>
    4f56:	2b01      	cmp	r3, #1
    4f58:	d901      	bls.n	4f5e <etharp_tmr+0x26>
				etharp_free_entry(i);
    4f5a:	4628      	mov	r0, r5
    4f5c:	47b0      	blx	r6
	for (i = 0; i < ARP_TABLE_SIZE; ++i) {
    4f5e:	3501      	adds	r5, #1
    4f60:	2d0a      	cmp	r5, #10
    4f62:	f104 0414 	add.w	r4, r4, #20
    4f66:	d1ec      	bne.n	4f42 <etharp_tmr+0xa>
}
    4f68:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
			} else if (arp_table[i].state == ETHARP_STATE_STABLE_REREQUESTING) {
    4f6a:	2a03      	cmp	r2, #3
				arp_table[i].state = ETHARP_STATE_STABLE;
    4f6c:	bf08      	it	eq
    4f6e:	74a7      	strbeq	r7, [r4, #18]
    4f70:	e7f5      	b.n	4f5e <etharp_tmr+0x26>
    4f72:	bf00      	nop
    4f74:	20011004 	.word	0x20011004
    4f78:	00004e15 	.word	0x00004e15

00004f7c <etharp_cleanup_netif>:
 * Remove all ARP table entries of the specified netif.
 *
 * @param netif points to a network interface
 */
void etharp_cleanup_netif(struct netif *netif)
{
    4f7c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    4f7e:	4d08      	ldr	r5, [pc, #32]	; (4fa0 <etharp_cleanup_netif+0x24>)
	u8_t i;

	for (i = 0; i < ARP_TABLE_SIZE; ++i) {
		u8_t state = arp_table[i].state;
		if ((state != ETHARP_STATE_EMPTY) && (arp_table[i].netif == netif)) {
			etharp_free_entry(i);
    4f80:	4f08      	ldr	r7, [pc, #32]	; (4fa4 <etharp_cleanup_netif+0x28>)
{
    4f82:	4606      	mov	r6, r0
    4f84:	2400      	movs	r4, #0
		if ((state != ETHARP_STATE_EMPTY) && (arp_table[i].netif == netif)) {
    4f86:	7cab      	ldrb	r3, [r5, #18]
    4f88:	b123      	cbz	r3, 4f94 <etharp_cleanup_netif+0x18>
    4f8a:	68ab      	ldr	r3, [r5, #8]
    4f8c:	42b3      	cmp	r3, r6
    4f8e:	d101      	bne.n	4f94 <etharp_cleanup_netif+0x18>
			etharp_free_entry(i);
    4f90:	4620      	mov	r0, r4
    4f92:	47b8      	blx	r7
	for (i = 0; i < ARP_TABLE_SIZE; ++i) {
    4f94:	3401      	adds	r4, #1
    4f96:	2c0a      	cmp	r4, #10
    4f98:	f105 0514 	add.w	r5, r5, #20
    4f9c:	d1f3      	bne.n	4f86 <etharp_cleanup_netif+0xa>
		}
	}
}
    4f9e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    4fa0:	20011004 	.word	0x20011004
    4fa4:	00004e15 	.word	0x00004e15

00004fa8 <etharp_request>:
 * @return ERR_OK if the request has been sent
 *         ERR_MEM if the ARP packet couldn't be allocated
 *         any other err_t on failure
 */
err_t etharp_request(struct netif *netif, ip_addr_t *ipaddr)
{
    4fa8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	p = pbuf_alloc(PBUF_RAW, SIZEOF_ETHARP_PACKET, PBUF_RAM);
    4fac:	4b23      	ldr	r3, [pc, #140]	; (503c <etharp_request+0x94>)
{
    4fae:	4605      	mov	r5, r0
    4fb0:	460f      	mov	r7, r1
	p = pbuf_alloc(PBUF_RAW, SIZEOF_ETHARP_PACKET, PBUF_RAM);
    4fb2:	2200      	movs	r2, #0
    4fb4:	212c      	movs	r1, #44	; 0x2c
    4fb6:	2003      	movs	r0, #3
    4fb8:	4798      	blx	r3
	if (p == NULL) {
    4fba:	4606      	mov	r6, r0
    4fbc:	2800      	cmp	r0, #0
    4fbe:	d039      	beq.n	5034 <etharp_request+0x8c>
	ethhdr = (struct eth_hdr *)p->payload;
    4fc0:	6844      	ldr	r4, [r0, #4]
	hdr->opcode = htons(opcode);
    4fc2:	4b1f      	ldr	r3, [pc, #124]	; (5040 <etharp_request+0x98>)
    4fc4:	2001      	movs	r0, #1
    4fc6:	4798      	blx	r3
    4fc8:	82e0      	strh	r0, [r4, #22]
	ETHADDR16_COPY(&hdr->shwaddr, hwsrc_addr);
    4fca:	f8d5 302b 	ldr.w	r3, [r5, #43]	; 0x2b
    4fce:	61a3      	str	r3, [r4, #24]
    4fd0:	f8b5 302f 	ldrh.w	r3, [r5, #47]	; 0x2f
    4fd4:	83a3      	strh	r3, [r4, #28]
	ETHADDR16_COPY(&hdr->dhwaddr, hwdst_addr);
    4fd6:	4b1b      	ldr	r3, [pc, #108]	; (5044 <etharp_request+0x9c>)
    4fd8:	681a      	ldr	r2, [r3, #0]
    4fda:	889b      	ldrh	r3, [r3, #4]
    4fdc:	84e3      	strh	r3, [r4, #38]	; 0x26
	ETHADDR16_COPY(&ethhdr->dest, ethdst_addr);
    4fde:	4b1a      	ldr	r3, [pc, #104]	; (5048 <etharp_request+0xa0>)
	ETHADDR16_COPY(&hdr->dhwaddr, hwdst_addr);
    4fe0:	f8c4 2022 	str.w	r2, [r4, #34]	; 0x22
	ETHADDR16_COPY(&ethhdr->dest, ethdst_addr);
    4fe4:	681a      	ldr	r2, [r3, #0]
    4fe6:	889b      	ldrh	r3, [r3, #4]
    4fe8:	f8c4 2002 	str.w	r2, [r4, #2]
    4fec:	80e3      	strh	r3, [r4, #6]
	ETHADDR16_COPY(&ethhdr->src, ethsrc_addr);
    4fee:	f8d5 302b 	ldr.w	r3, [r5, #43]	; 0x2b
    4ff2:	60a3      	str	r3, [r4, #8]
    4ff4:	f8b5 302f 	ldrh.w	r3, [r5, #47]	; 0x2f
    4ff8:	81a3      	strh	r3, [r4, #12]
	IPADDR2_COPY(&hdr->sipaddr, ipsrc_addr);
    4ffa:	686b      	ldr	r3, [r5, #4]
    4ffc:	f8c4 301e 	str.w	r3, [r4, #30]
	IPADDR2_COPY(&hdr->dipaddr, ipdst_addr);
    5000:	683b      	ldr	r3, [r7, #0]
    5002:	62a3      	str	r3, [r4, #40]	; 0x28
	hdr->hwtype = PP_HTONS(HWTYPE_ETHERNET);
    5004:	2300      	movs	r3, #0
    5006:	7423      	strb	r3, [r4, #16]
	hdr->proto  = PP_HTONS(ETHTYPE_IP);
    5008:	74e3      	strb	r3, [r4, #19]
	hdr->hwtype = PP_HTONS(HWTYPE_ETHERNET);
    500a:	2201      	movs	r2, #1
	hdr->hwlen    = ETHARP_HWADDR_LEN;
    500c:	2306      	movs	r3, #6
	hdr->protolen = sizeof(ip_addr_t);
    500e:	2104      	movs	r1, #4
    5010:	7561      	strb	r1, [r4, #21]
	hdr->hwtype = PP_HTONS(HWTYPE_ETHERNET);
    5012:	7462      	strb	r2, [r4, #17]
	hdr->hwlen    = ETHARP_HWADDR_LEN;
    5014:	7523      	strb	r3, [r4, #20]
	hdr->proto  = PP_HTONS(ETHTYPE_IP);
    5016:	2208      	movs	r2, #8
	ethhdr->type = PP_HTONS(ETHTYPE_ARP);
    5018:	73e3      	strb	r3, [r4, #15]
	hdr->proto  = PP_HTONS(ETHTYPE_IP);
    501a:	74a2      	strb	r2, [r4, #18]
	result = netif->linkoutput(netif, p);
    501c:	69ab      	ldr	r3, [r5, #24]
	ethhdr->type = PP_HTONS(ETHTYPE_ARP);
    501e:	73a2      	strb	r2, [r4, #14]
	result = netif->linkoutput(netif, p);
    5020:	4631      	mov	r1, r6
    5022:	4628      	mov	r0, r5
    5024:	4798      	blx	r3
	pbuf_free(p);
    5026:	4b09      	ldr	r3, [pc, #36]	; (504c <etharp_request+0xa4>)
	result = netif->linkoutput(netif, p);
    5028:	4604      	mov	r4, r0
	pbuf_free(p);
    502a:	4630      	mov	r0, r6
    502c:	4798      	blx	r3
	                  (struct eth_addr *)netif->hwaddr,
	                  &netif->ip_addr,
	                  &ethzero,
	                  ipaddr,
	                  ARP_REQUEST);
}
    502e:	4620      	mov	r0, r4
    5030:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		return ERR_MEM;
    5034:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
    5038:	e7f9      	b.n	502e <etharp_request+0x86>
    503a:	bf00      	nop
    503c:	00003139 	.word	0x00003139
    5040:	00000d61 	.word	0x00000d61
    5044:	0000ca4a 	.word	0x0000ca4a
    5048:	0000ca43 	.word	0x0000ca43
    504c:	000030e1 	.word	0x000030e1

00005050 <etharp_output_to_arp_index>:
{
    5050:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	if ((arp_table[arp_idx].state == ETHARP_STATE_STABLE) && (arp_table[arp_idx].ctime >= ARP_AGE_REREQUEST_USED)) {
    5054:	f8df 804c 	ldr.w	r8, [pc, #76]	; 50a4 <etharp_output_to_arp_index+0x54>
    5058:	2414      	movs	r4, #20
    505a:	fb04 8402 	mla	r4, r4, r2, r8
    505e:	eb02 0582 	add.w	r5, r2, r2, lsl #2
    5062:	7ca3      	ldrb	r3, [r4, #18]
    5064:	2b02      	cmp	r3, #2
{
    5066:	4606      	mov	r6, r0
    5068:	460f      	mov	r7, r1
    506a:	ea4f 0585 	mov.w	r5, r5, lsl #2
	if ((arp_table[arp_idx].state == ETHARP_STATE_STABLE) && (arp_table[arp_idx].ctime >= ARP_AGE_REREQUEST_USED)) {
    506e:	d109      	bne.n	5084 <etharp_output_to_arp_index+0x34>
    5070:	7ce3      	ldrb	r3, [r4, #19]
    5072:	2be3      	cmp	r3, #227	; 0xe3
    5074:	d906      	bls.n	5084 <etharp_output_to_arp_index+0x34>
		if (etharp_request(netif, &arp_table[arp_idx].ipaddr) == ERR_OK) {
    5076:	1d29      	adds	r1, r5, #4
    5078:	4b08      	ldr	r3, [pc, #32]	; (509c <etharp_output_to_arp_index+0x4c>)
    507a:	4441      	add	r1, r8
    507c:	4798      	blx	r3
    507e:	b908      	cbnz	r0, 5084 <etharp_output_to_arp_index+0x34>
			arp_table[arp_idx].state = ETHARP_STATE_STABLE_REREQUESTING;
    5080:	2303      	movs	r3, #3
    5082:	74a3      	strb	r3, [r4, #18]
	return etharp_send_ip(netif, q, (struct eth_addr *)(netif->hwaddr), &arp_table[arp_idx].ethaddr);
    5084:	4c06      	ldr	r4, [pc, #24]	; (50a0 <etharp_output_to_arp_index+0x50>)
    5086:	350c      	adds	r5, #12
    5088:	eb08 0305 	add.w	r3, r8, r5
    508c:	f106 022b 	add.w	r2, r6, #43	; 0x2b
    5090:	4639      	mov	r1, r7
    5092:	4630      	mov	r0, r6
    5094:	46a4      	mov	ip, r4
}
    5096:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
	return etharp_send_ip(netif, q, (struct eth_addr *)(netif->hwaddr), &arp_table[arp_idx].ethaddr);
    509a:	4760      	bx	ip
    509c:	00004fa9 	.word	0x00004fa9
    50a0:	00004f15 	.word	0x00004f15
    50a4:	20011004 	.word	0x20011004

000050a8 <etharp_query>:
{
    50a8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    50ac:	4688      	mov	r8, r1
    50ae:	4606      	mov	r6, r0
	if (ip_addr_isbroadcast(ipaddr, netif) || ip_addr_ismulticast(ipaddr) || ip_addr_isany(ipaddr)) {
    50b0:	4601      	mov	r1, r0
    50b2:	4b36      	ldr	r3, [pc, #216]	; (518c <etharp_query+0xe4>)
    50b4:	f8d8 0000 	ldr.w	r0, [r8]
{
    50b8:	4615      	mov	r5, r2
	if (ip_addr_isbroadcast(ipaddr, netif) || ip_addr_ismulticast(ipaddr) || ip_addr_isany(ipaddr)) {
    50ba:	4798      	blx	r3
    50bc:	2800      	cmp	r0, #0
    50be:	d14e      	bne.n	515e <etharp_query+0xb6>
    50c0:	f8d8 3000 	ldr.w	r3, [r8]
    50c4:	f003 02f0 	and.w	r2, r3, #240	; 0xf0
    50c8:	2ae0      	cmp	r2, #224	; 0xe0
    50ca:	d048      	beq.n	515e <etharp_query+0xb6>
    50cc:	2b00      	cmp	r3, #0
    50ce:	d046      	beq.n	515e <etharp_query+0xb6>
	i = etharp_find_entry(ipaddr, ETHARP_FLAG_TRY_HARD);
    50d0:	4b2f      	ldr	r3, [pc, #188]	; (5190 <etharp_query+0xe8>)
    50d2:	2101      	movs	r1, #1
    50d4:	4640      	mov	r0, r8
    50d6:	4798      	blx	r3
	if (i < 0) {
    50d8:	1e04      	subs	r4, r0, #0
    50da:	db43      	blt.n	5164 <etharp_query+0xbc>
	if (arp_table[i].state == ETHARP_STATE_EMPTY) {
    50dc:	4f2d      	ldr	r7, [pc, #180]	; (5194 <etharp_query+0xec>)
    50de:	2314      	movs	r3, #20
    50e0:	fb03 7304 	mla	r3, r3, r4, r7
    50e4:	7c9a      	ldrb	r2, [r3, #18]
    50e6:	b942      	cbnz	r2, 50fa <etharp_query+0x52>
		arp_table[i].state = ETHARP_STATE_PENDING;
    50e8:	2201      	movs	r2, #1
    50ea:	749a      	strb	r2, [r3, #18]
		result = etharp_request(netif, ipaddr);
    50ec:	4b2a      	ldr	r3, [pc, #168]	; (5198 <etharp_query+0xf0>)
    50ee:	4641      	mov	r1, r8
    50f0:	4630      	mov	r0, r6
    50f2:	4798      	blx	r3
		if (q == NULL) {
    50f4:	b93d      	cbnz	r5, 5106 <etharp_query+0x5e>
}
    50f6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	if ((arp_table[i].state == ETHARP_STATE_PENDING) || (q == NULL)) {
    50fa:	2a01      	cmp	r2, #1
    50fc:	d0f6      	beq.n	50ec <etharp_query+0x44>
    50fe:	2d00      	cmp	r5, #0
    5100:	d0f4      	beq.n	50ec <etharp_query+0x44>
	err_t            result  = ERR_MEM;
    5102:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
	if (arp_table[i].state >= ETHARP_STATE_STABLE) {
    5106:	2314      	movs	r3, #20
    5108:	fb03 7204 	mla	r2, r3, r4, r7
    510c:	7c92      	ldrb	r2, [r2, #18]
    510e:	2a01      	cmp	r2, #1
    5110:	d90e      	bls.n	5130 <etharp_query+0x88>
		result = etharp_send_ip(netif, q, srcaddr, &(arp_table[i].ethaddr));
    5112:	200c      	movs	r0, #12
    5114:	fb13 0304 	smlabb	r3, r3, r4, r0
		ETHARP_SET_HINT(netif, i);
    5118:	f887 40c8 	strb.w	r4, [r7, #200]	; 0xc8
		result = etharp_send_ip(netif, q, srcaddr, &(arp_table[i].ethaddr));
    511c:	4c1f      	ldr	r4, [pc, #124]	; (519c <etharp_query+0xf4>)
    511e:	443b      	add	r3, r7
    5120:	f106 022b 	add.w	r2, r6, #43	; 0x2b
    5124:	4629      	mov	r1, r5
    5126:	4630      	mov	r0, r6
    5128:	46a4      	mov	ip, r4
}
    512a:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
		result = etharp_send_ip(netif, q, srcaddr, &(arp_table[i].ethaddr));
    512e:	4760      	bx	ip
	} else if (arp_table[i].state == ETHARP_STATE_PENDING) {
    5130:	d1e1      	bne.n	50f6 <etharp_query+0x4e>
    5132:	462b      	mov	r3, r5
			if (p->type != PBUF_ROM) {
    5134:	7b1a      	ldrb	r2, [r3, #12]
    5136:	2a01      	cmp	r2, #1
    5138:	d116      	bne.n	5168 <etharp_query+0xc0>
			p = p->next;
    513a:	681b      	ldr	r3, [r3, #0]
		while (p) {
    513c:	2b00      	cmp	r3, #0
    513e:	d1f9      	bne.n	5134 <etharp_query+0x8c>
			pbuf_ref(p);
    5140:	4b17      	ldr	r3, [pc, #92]	; (51a0 <etharp_query+0xf8>)
    5142:	4628      	mov	r0, r5
    5144:	4798      	blx	r3
    5146:	462e      	mov	r6, r5
			if (arp_table[i].q != NULL) {
    5148:	2314      	movs	r3, #20
    514a:	4363      	muls	r3, r4
    514c:	58f8      	ldr	r0, [r7, r3]
    514e:	b108      	cbz	r0, 5154 <etharp_query+0xac>
				pbuf_free(arp_table[i].q);
    5150:	4b14      	ldr	r3, [pc, #80]	; (51a4 <etharp_query+0xfc>)
    5152:	4798      	blx	r3
			arp_table[i].q = p;
    5154:	2314      	movs	r3, #20
    5156:	435c      	muls	r4, r3
			result = ERR_OK;
    5158:	2000      	movs	r0, #0
			arp_table[i].q = p;
    515a:	513e      	str	r6, [r7, r4]
			            ("etharp_query: queued packet %p on ARP entry %" S16_F "\n", (void *)q, (s16_t)i));
    515c:	e7cb      	b.n	50f6 <etharp_query+0x4e>
		return ERR_ARG;
    515e:	f06f 000d 	mvn.w	r0, #13
    5162:	e7c8      	b.n	50f6 <etharp_query+0x4e>
    5164:	4620      	mov	r0, r4
    5166:	e7c6      	b.n	50f6 <etharp_query+0x4e>
			p = pbuf_alloc(PBUF_RAW, p->tot_len, PBUF_RAM);
    5168:	8919      	ldrh	r1, [r3, #8]
    516a:	4b0f      	ldr	r3, [pc, #60]	; (51a8 <etharp_query+0x100>)
    516c:	2200      	movs	r2, #0
    516e:	2003      	movs	r0, #3
    5170:	4798      	blx	r3
			if (p != NULL) {
    5172:	4606      	mov	r6, r0
    5174:	b138      	cbz	r0, 5186 <etharp_query+0xde>
				if (pbuf_copy(p, q) != ERR_OK) {
    5176:	4b0d      	ldr	r3, [pc, #52]	; (51ac <etharp_query+0x104>)
    5178:	4629      	mov	r1, r5
    517a:	4798      	blx	r3
    517c:	2800      	cmp	r0, #0
    517e:	d0e3      	beq.n	5148 <etharp_query+0xa0>
					pbuf_free(p);
    5180:	4b08      	ldr	r3, [pc, #32]	; (51a4 <etharp_query+0xfc>)
    5182:	4630      	mov	r0, r6
    5184:	4798      	blx	r3
			result = ERR_MEM;
    5186:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    518a:	e7b4      	b.n	50f6 <etharp_query+0x4e>
    518c:	00008a1f 	.word	0x00008a1f
    5190:	00004e41 	.word	0x00004e41
    5194:	20011004 	.word	0x20011004
    5198:	00004fa9 	.word	0x00004fa9
    519c:	00004f15 	.word	0x00004f15
    51a0:	000032ad 	.word	0x000032ad
    51a4:	000030e1 	.word	0x000030e1
    51a8:	00003139 	.word	0x00003139
    51ac:	000032ed 	.word	0x000032ed

000051b0 <etharp_output>:
{
    51b0:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
    51b2:	460e      	mov	r6, r1
    51b4:	4604      	mov	r4, r0
	if (pbuf_header(q, sizeof(struct eth_hdr)) != 0) {
    51b6:	4b3a      	ldr	r3, [pc, #232]	; (52a0 <etharp_output+0xf0>)
    51b8:	2110      	movs	r1, #16
    51ba:	4630      	mov	r0, r6
{
    51bc:	4615      	mov	r5, r2
	if (pbuf_header(q, sizeof(struct eth_hdr)) != 0) {
    51be:	4798      	blx	r3
    51c0:	2800      	cmp	r0, #0
    51c2:	d167      	bne.n	5294 <etharp_output+0xe4>
	if (ip_addr_isbroadcast(ipaddr, netif)) {
    51c4:	6828      	ldr	r0, [r5, #0]
    51c6:	4b37      	ldr	r3, [pc, #220]	; (52a4 <etharp_output+0xf4>)
    51c8:	4621      	mov	r1, r4
    51ca:	4798      	blx	r3
    51cc:	2800      	cmp	r0, #0
    51ce:	d15f      	bne.n	5290 <etharp_output+0xe0>
	} else if (ip_addr_ismulticast(ipaddr)) {
    51d0:	682b      	ldr	r3, [r5, #0]
    51d2:	f003 02f0 	and.w	r2, r3, #240	; 0xf0
    51d6:	2ae0      	cmp	r2, #224	; 0xe0
    51d8:	d11b      	bne.n	5212 <etharp_output+0x62>
		mcastaddr.addr[0] = LL_MULTICAST_ADDR_0;
    51da:	2301      	movs	r3, #1
    51dc:	f88d 3000 	strb.w	r3, [sp]
		mcastaddr.addr[2] = LL_MULTICAST_ADDR_2;
    51e0:	235e      	movs	r3, #94	; 0x5e
    51e2:	f88d 3002 	strb.w	r3, [sp, #2]
		mcastaddr.addr[3] = ip4_addr2(ipaddr) & 0x7f;
    51e6:	786b      	ldrb	r3, [r5, #1]
		mcastaddr.addr[1] = LL_MULTICAST_ADDR_1;
    51e8:	f88d 0001 	strb.w	r0, [sp, #1]
		mcastaddr.addr[3] = ip4_addr2(ipaddr) & 0x7f;
    51ec:	f003 037f 	and.w	r3, r3, #127	; 0x7f
    51f0:	f88d 3003 	strb.w	r3, [sp, #3]
		mcastaddr.addr[4] = ip4_addr3(ipaddr);
    51f4:	78ab      	ldrb	r3, [r5, #2]
    51f6:	f88d 3004 	strb.w	r3, [sp, #4]
		mcastaddr.addr[5] = ip4_addr4(ipaddr);
    51fa:	78eb      	ldrb	r3, [r5, #3]
    51fc:	f88d 3005 	strb.w	r3, [sp, #5]
		dest = &mcastaddr;
    5200:	466b      	mov	r3, sp
	return etharp_send_ip(netif, q, (struct eth_addr *)(netif->hwaddr), dest);
    5202:	f104 022b 	add.w	r2, r4, #43	; 0x2b
    5206:	4620      	mov	r0, r4
    5208:	4631      	mov	r1, r6
    520a:	4c27      	ldr	r4, [pc, #156]	; (52a8 <etharp_output+0xf8>)
    520c:	47a0      	blx	r4
}
    520e:	b003      	add	sp, #12
    5210:	bdf0      	pop	{r4, r5, r6, r7, pc}
		if (!ip_addr_netcmp(ipaddr, &(netif->ip_addr), &(netif->netmask)) && !ip_addr_islinklocal(ipaddr)) {
    5212:	6862      	ldr	r2, [r4, #4]
    5214:	68a1      	ldr	r1, [r4, #8]
    5216:	405a      	eors	r2, r3
    5218:	420a      	tst	r2, r1
    521a:	d009      	beq.n	5230 <etharp_output+0x80>
    521c:	b29b      	uxth	r3, r3
    521e:	f64f 62a9 	movw	r2, #65193	; 0xfea9
    5222:	4293      	cmp	r3, r2
    5224:	d004      	beq.n	5230 <etharp_output+0x80>
				if (!ip_addr_isany(&netif->gw)) {
    5226:	68e3      	ldr	r3, [r4, #12]
    5228:	f104 050c 	add.w	r5, r4, #12
    522c:	2b00      	cmp	r3, #0
    522e:	d034      	beq.n	529a <etharp_output+0xea>
				if ((arp_table[etharp_cached_entry].state >= ETHARP_STATE_STABLE)
    5230:	481e      	ldr	r0, [pc, #120]	; (52ac <etharp_output+0xfc>)
    5232:	f890 20c8 	ldrb.w	r2, [r0, #200]	; 0xc8
    5236:	2314      	movs	r3, #20
    5238:	fb03 0302 	mla	r3, r3, r2, r0
    523c:	7c99      	ldrb	r1, [r3, #18]
    523e:	2901      	cmp	r1, #1
    5240:	d90a      	bls.n	5258 <etharp_output+0xa8>
				    && (ip_addr_cmp(dst_addr, &arp_table[etharp_cached_entry].ipaddr))) {
    5242:	6829      	ldr	r1, [r5, #0]
    5244:	685b      	ldr	r3, [r3, #4]
    5246:	4299      	cmp	r1, r3
    5248:	d106      	bne.n	5258 <etharp_output+0xa8>
				return etharp_output_to_arp_index(netif, q, i);
    524a:	4b19      	ldr	r3, [pc, #100]	; (52b0 <etharp_output+0x100>)
    524c:	4631      	mov	r1, r6
    524e:	4620      	mov	r0, r4
}
    5250:	b003      	add	sp, #12
    5252:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
				return etharp_output_to_arp_index(netif, q, i);
    5256:	4718      	bx	r3
    5258:	4914      	ldr	r1, [pc, #80]	; (52ac <etharp_output+0xfc>)
{
    525a:	2300      	movs	r3, #0
			if ((arp_table[i].state >= ETHARP_STATE_STABLE) && (ip_addr_cmp(dst_addr, &arp_table[i].ipaddr))) {
    525c:	7c8f      	ldrb	r7, [r1, #18]
    525e:	2f01      	cmp	r7, #1
    5260:	fa5f fc83 	uxtb.w	ip, r3
    5264:	d907      	bls.n	5276 <etharp_output+0xc6>
    5266:	684f      	ldr	r7, [r1, #4]
    5268:	682a      	ldr	r2, [r5, #0]
    526a:	42ba      	cmp	r2, r7
    526c:	d103      	bne.n	5276 <etharp_output+0xc6>
				ETHARP_SET_HINT(netif, i);
    526e:	f880 c0c8 	strb.w	ip, [r0, #200]	; 0xc8
				return etharp_output_to_arp_index(netif, q, i);
    5272:	4662      	mov	r2, ip
    5274:	e7e9      	b.n	524a <etharp_output+0x9a>
		for (i = 0; i < ARP_TABLE_SIZE; i++) {
    5276:	3301      	adds	r3, #1
    5278:	2b0a      	cmp	r3, #10
    527a:	f101 0114 	add.w	r1, r1, #20
    527e:	d1ed      	bne.n	525c <etharp_output+0xac>
		return etharp_query(netif, dst_addr, q);
    5280:	4b0c      	ldr	r3, [pc, #48]	; (52b4 <etharp_output+0x104>)
    5282:	4632      	mov	r2, r6
    5284:	4629      	mov	r1, r5
    5286:	4620      	mov	r0, r4
}
    5288:	b003      	add	sp, #12
    528a:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
		return etharp_query(netif, dst_addr, q);
    528e:	4718      	bx	r3
		dest = (struct eth_addr *)&ethbroadcast;
    5290:	4b09      	ldr	r3, [pc, #36]	; (52b8 <etharp_output+0x108>)
    5292:	e7b6      	b.n	5202 <etharp_output+0x52>
		return ERR_BUF;
    5294:	f06f 0001 	mvn.w	r0, #1
    5298:	e7b9      	b.n	520e <etharp_output+0x5e>
					return ERR_RTE;
    529a:	f06f 0003 	mvn.w	r0, #3
    529e:	e7b6      	b.n	520e <etharp_output+0x5e>
    52a0:	00003089 	.word	0x00003089
    52a4:	00008a1f 	.word	0x00008a1f
    52a8:	00004f15 	.word	0x00004f15
    52ac:	20011004 	.word	0x20011004
    52b0:	00005051 	.word	0x00005051
    52b4:	000050a9 	.word	0x000050a9
    52b8:	0000ca50 	.word	0x0000ca50

000052bc <ethernet_input>:
 *
 * @param p the recevied packet, p->payload pointing to the ethernet header
 * @param netif the network interface on which the packet was received
 */
err_t ethernet_input(struct pbuf *p, struct netif *netif)
{
    52bc:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	u16_t           type;
#if LWIP_ARP || ETHARP_SUPPORT_VLAN
	s16_t ip_hdr_offset = SIZEOF_ETH_HDR;
#endif /* LWIP_ARP || ETHARP_SUPPORT_VLAN */

	if (p->len <= SIZEOF_ETH_HDR) {
    52c0:	8947      	ldrh	r7, [r0, #10]
    52c2:	2f10      	cmp	r7, #16
{
    52c4:	b085      	sub	sp, #20
    52c6:	4606      	mov	r6, r0
    52c8:	460d      	mov	r5, r1
	if (p->len <= SIZEOF_ETH_HDR) {
    52ca:	d916      	bls.n	52fa <ethernet_input+0x3e>
		ETHARP_STATS_INC(etharp.drop);
		goto free_and_return;
	}

	/* points to packet payload, which starts with an Ethernet header */
	ethhdr = (struct eth_hdr *)p->payload;
    52cc:	6844      	ldr	r4, [r0, #4]

#if LWIP_ARP_FILTER_NETIF
	netif = LWIP_ARP_FILTER_NETIF_FN(p, netif, htons(type));
#endif /* LWIP_ARP_FILTER_NETIF*/

	if (ethhdr->dest.addr[0] & 1) {
    52ce:	78a3      	ldrb	r3, [r4, #2]
	type = ethhdr->type;
    52d0:	f8b4 800e 	ldrh.w	r8, [r4, #14]
	if (ethhdr->dest.addr[0] & 1) {
    52d4:	07d8      	lsls	r0, r3, #31
    52d6:	d50a      	bpl.n	52ee <ethernet_input+0x32>
		/* this might be a multicast or broadcast packet */
		if (ethhdr->dest.addr[0] == LL_MULTICAST_ADDR_0) {
    52d8:	2b01      	cmp	r3, #1
    52da:	d112      	bne.n	5302 <ethernet_input+0x46>
			if ((ethhdr->dest.addr[1] == LL_MULTICAST_ADDR_1) && (ethhdr->dest.addr[2] == LL_MULTICAST_ADDR_2)) {
    52dc:	78e3      	ldrb	r3, [r4, #3]
    52de:	b933      	cbnz	r3, 52ee <ethernet_input+0x32>
    52e0:	7923      	ldrb	r3, [r4, #4]
    52e2:	2b5e      	cmp	r3, #94	; 0x5e
    52e4:	d103      	bne.n	52ee <ethernet_input+0x32>
				/* mark the pbuf as link-layer multicast */
				p->flags |= PBUF_FLAG_LLMCAST;
    52e6:	7b73      	ldrb	r3, [r6, #13]
    52e8:	f043 0310 	orr.w	r3, r3, #16
			}
		} else if (eth_addr_cmp(&ethhdr->dest, &ethbroadcast)) {
			/* mark the pbuf as link-layer broadcast */
			p->flags |= PBUF_FLAG_LLBCAST;
    52ec:	7373      	strb	r3, [r6, #13]
		}
	}

	switch (type) {
    52ee:	f1b8 0f08 	cmp.w	r8, #8
    52f2:	d011      	beq.n	5318 <ethernet_input+0x5c>
    52f4:	f5b8 6fc1 	cmp.w	r8, #1544	; 0x608
    52f8:	d021      	beq.n	533e <ethernet_input+0x82>
	/* This means the pbuf is freed or consumed,
	   so the caller doesn't have to free it again */
	return ERR_OK;

free_and_return:
	pbuf_free(p);
    52fa:	4b5f      	ldr	r3, [pc, #380]	; (5478 <ethernet_input+0x1bc>)
    52fc:	4630      	mov	r0, r6
    52fe:	4798      	blx	r3
	return ERR_OK;
    5300:	e019      	b.n	5336 <ethernet_input+0x7a>
		} else if (eth_addr_cmp(&ethhdr->dest, &ethbroadcast)) {
    5302:	495e      	ldr	r1, [pc, #376]	; (547c <ethernet_input+0x1c0>)
    5304:	4b5e      	ldr	r3, [pc, #376]	; (5480 <ethernet_input+0x1c4>)
    5306:	2206      	movs	r2, #6
    5308:	1ca0      	adds	r0, r4, #2
    530a:	4798      	blx	r3
    530c:	2800      	cmp	r0, #0
    530e:	d1ee      	bne.n	52ee <ethernet_input+0x32>
			p->flags |= PBUF_FLAG_LLBCAST;
    5310:	7b73      	ldrb	r3, [r6, #13]
    5312:	f043 0308 	orr.w	r3, r3, #8
    5316:	e7e9      	b.n	52ec <ethernet_input+0x30>
		if (!(netif->flags & NETIF_FLAG_ETHARP)) {
    5318:	f895 3031 	ldrb.w	r3, [r5, #49]	; 0x31
    531c:	0699      	lsls	r1, r3, #26
    531e:	d5ec      	bpl.n	52fa <ethernet_input+0x3e>
		if (pbuf_header(p, -ip_hdr_offset)) {
    5320:	4b58      	ldr	r3, [pc, #352]	; (5484 <ethernet_input+0x1c8>)
    5322:	f06f 010f 	mvn.w	r1, #15
    5326:	4630      	mov	r0, r6
    5328:	4798      	blx	r3
    532a:	2800      	cmp	r0, #0
    532c:	d1e5      	bne.n	52fa <ethernet_input+0x3e>
			ip_input(p, netif);
    532e:	4b56      	ldr	r3, [pc, #344]	; (5488 <ethernet_input+0x1cc>)
    5330:	4629      	mov	r1, r5
    5332:	4630      	mov	r0, r6
    5334:	4798      	blx	r3
}
    5336:	2000      	movs	r0, #0
    5338:	b005      	add	sp, #20
    533a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		if (!(netif->flags & NETIF_FLAG_ETHARP)) {
    533e:	f895 3031 	ldrb.w	r3, [r5, #49]	; 0x31
    5342:	069a      	lsls	r2, r3, #26
    5344:	d5d9      	bpl.n	52fa <ethernet_input+0x3e>
	if (p->len < SIZEOF_ETHARP_PACKET) {
    5346:	2f2b      	cmp	r7, #43	; 0x2b
    5348:	f8df 912c 	ldr.w	r9, [pc, #300]	; 5478 <ethernet_input+0x1bc>
    534c:	d802      	bhi.n	5354 <ethernet_input+0x98>
	pbuf_free(p);
    534e:	4630      	mov	r0, r6
    5350:	47c8      	blx	r9
    5352:	e7f0      	b.n	5336 <ethernet_input+0x7a>
	if ((hdr->hwtype != PP_HTONS(HWTYPE_ETHERNET)) || (hdr->hwlen != ETHARP_HWADDR_LEN)
    5354:	8a23      	ldrh	r3, [r4, #16]
    5356:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
    535a:	d1f8      	bne.n	534e <ethernet_input+0x92>
    535c:	7d23      	ldrb	r3, [r4, #20]
    535e:	2b06      	cmp	r3, #6
    5360:	d1f5      	bne.n	534e <ethernet_input+0x92>
	    || (hdr->protolen != sizeof(ip_addr_t)) || (hdr->proto != PP_HTONS(ETHTYPE_IP))) {
    5362:	7d63      	ldrb	r3, [r4, #21]
    5364:	2b04      	cmp	r3, #4
    5366:	d1f2      	bne.n	534e <ethernet_input+0x92>
    5368:	8a63      	ldrh	r3, [r4, #18]
    536a:	2b08      	cmp	r3, #8
    536c:	d1ef      	bne.n	534e <ethernet_input+0x92>
	if (ip_addr_isany(&netif->ip_addr)) {
    536e:	686f      	ldr	r7, [r5, #4]
    5370:	f8d4 001e 	ldr.w	r0, [r4, #30]
    5374:	6aa3      	ldr	r3, [r4, #40]	; 0x28
	IPADDR2_COPY(&sipaddr, &hdr->sipaddr);
    5376:	9003      	str	r0, [sp, #12]
	etharp_update_arp_entry(netif, &sipaddr, &(hdr->shwaddr), for_us ? ETHARP_FLAG_TRY_HARD : ETHARP_FLAG_FIND_ONLY);
    5378:	f104 0818 	add.w	r8, r4, #24
	if (ip_addr_isany(&netif->ip_addr)) {
    537c:	2f00      	cmp	r7, #0
    537e:	d04f      	beq.n	5420 <ethernet_input+0x164>
		for_us = (u8_t)ip_addr_cmp(&dipaddr, &(netif->ip_addr));
    5380:	1bdb      	subs	r3, r3, r7
    5382:	425f      	negs	r7, r3
    5384:	415f      	adcs	r7, r3
	etharp_update_arp_entry(netif, &sipaddr, &(hdr->shwaddr), for_us ? ETHARP_FLAG_TRY_HARD : ETHARP_FLAG_FIND_ONLY);
    5386:	f1c7 0302 	rsb	r3, r7, #2
    538a:	b2db      	uxtb	r3, r3
    538c:	9301      	str	r3, [sp, #4]
		etharp_arp_input(netif, (struct eth_addr *)(netif->hwaddr), p);
    538e:	f105 0a2b 	add.w	sl, r5, #43	; 0x2b
	if (ip_addr_isany(ipaddr) || ip_addr_isbroadcast(ipaddr, netif) || ip_addr_ismulticast(ipaddr)) {
    5392:	2800      	cmp	r0, #0
    5394:	d038      	beq.n	5408 <ethernet_input+0x14c>
    5396:	4a3d      	ldr	r2, [pc, #244]	; (548c <ethernet_input+0x1d0>)
    5398:	4629      	mov	r1, r5
    539a:	4790      	blx	r2
    539c:	4683      	mov	fp, r0
    539e:	bb98      	cbnz	r0, 5408 <ethernet_input+0x14c>
    53a0:	9a03      	ldr	r2, [sp, #12]
    53a2:	f002 02f0 	and.w	r2, r2, #240	; 0xf0
    53a6:	2ae0      	cmp	r2, #224	; 0xe0
    53a8:	d02e      	beq.n	5408 <ethernet_input+0x14c>
	i = etharp_find_entry(ipaddr, flags);
    53aa:	9b01      	ldr	r3, [sp, #4]
    53ac:	a803      	add	r0, sp, #12
    53ae:	4619      	mov	r1, r3
    53b0:	4b37      	ldr	r3, [pc, #220]	; (5490 <ethernet_input+0x1d4>)
    53b2:	4798      	blx	r3
	if (i < 0) {
    53b4:	2800      	cmp	r0, #0
    53b6:	db27      	blt.n	5408 <ethernet_input+0x14c>
		arp_table[i].state = ETHARP_STATE_STABLE;
    53b8:	4b36      	ldr	r3, [pc, #216]	; (5494 <ethernet_input+0x1d8>)
    53ba:	2214      	movs	r2, #20
    53bc:	fb02 fc00 	mul.w	ip, r2, r0
    53c0:	eb03 010c 	add.w	r1, r3, ip
    53c4:	f04f 0e02 	mov.w	lr, #2
    53c8:	f881 e012 	strb.w	lr, [r1, #18]
	ETHADDR32_COPY(&arp_table[i].ethaddr, ethaddr);
    53cc:	f04f 0e0c 	mov.w	lr, #12
	arp_table[i].netif = netif;
    53d0:	608d      	str	r5, [r1, #8]
	ETHADDR32_COPY(&arp_table[i].ethaddr, ethaddr);
    53d2:	fb12 e200 	smlabb	r2, r2, r0, lr
    53d6:	69a0      	ldr	r0, [r4, #24]
    53d8:	5098      	str	r0, [r3, r2]
    53da:	eb03 0e02 	add.w	lr, r3, r2
    53de:	f8b8 2004 	ldrh.w	r2, [r8, #4]
    53e2:	f8ae 2004 	strh.w	r2, [lr, #4]
	arp_table[i].ctime = 0;
    53e6:	f881 b013 	strb.w	fp, [r1, #19]
	if (arp_table[i].q != NULL) {
    53ea:	f853 100c 	ldr.w	r1, [r3, ip]
    53ee:	b159      	cbz	r1, 5408 <ethernet_input+0x14c>
		arp_table[i].q = NULL;
    53f0:	f843 b00c 	str.w	fp, [r3, ip]
		etharp_send_ip(netif, p, (struct eth_addr *)(netif->hwaddr), ethaddr);
    53f4:	4652      	mov	r2, sl
    53f6:	f8df b0a8 	ldr.w	fp, [pc, #168]	; 54a0 <ethernet_input+0x1e4>
    53fa:	9101      	str	r1, [sp, #4]
    53fc:	4643      	mov	r3, r8
    53fe:	4628      	mov	r0, r5
    5400:	47d8      	blx	fp
		pbuf_free(p);
    5402:	9901      	ldr	r1, [sp, #4]
    5404:	4608      	mov	r0, r1
    5406:	47c8      	blx	r9
	switch (hdr->opcode) {
    5408:	8ae3      	ldrh	r3, [r4, #22]
    540a:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
    540e:	d009      	beq.n	5424 <ethernet_input+0x168>
    5410:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
    5414:	d19b      	bne.n	534e <ethernet_input+0x92>
		dhcp_arp_reply(netif, &sipaddr);
    5416:	4b20      	ldr	r3, [pc, #128]	; (5498 <ethernet_input+0x1dc>)
    5418:	a903      	add	r1, sp, #12
    541a:	4628      	mov	r0, r5
    541c:	4798      	blx	r3
		break;
    541e:	e796      	b.n	534e <ethernet_input+0x92>
	etharp_update_arp_entry(netif, &sipaddr, &(hdr->shwaddr), for_us ? ETHARP_FLAG_TRY_HARD : ETHARP_FLAG_FIND_ONLY);
    5420:	2302      	movs	r3, #2
    5422:	e7b3      	b.n	538c <ethernet_input+0xd0>
		if (for_us) {
    5424:	2f00      	cmp	r7, #0
    5426:	d092      	beq.n	534e <ethernet_input+0x92>
			hdr->opcode = htons(ARP_REPLY);
    5428:	4b1c      	ldr	r3, [pc, #112]	; (549c <ethernet_input+0x1e0>)
    542a:	2002      	movs	r0, #2
    542c:	4798      	blx	r3
			IPADDR2_COPY(&hdr->dipaddr, &hdr->sipaddr);
    542e:	f8d4 301e 	ldr.w	r3, [r4, #30]
			hdr->opcode = htons(ARP_REPLY);
    5432:	82e0      	strh	r0, [r4, #22]
			IPADDR2_COPY(&hdr->dipaddr, &hdr->sipaddr);
    5434:	62a3      	str	r3, [r4, #40]	; 0x28
			IPADDR2_COPY(&hdr->sipaddr, &netif->ip_addr);
    5436:	686b      	ldr	r3, [r5, #4]
    5438:	f8c4 301e 	str.w	r3, [r4, #30]
			ETHADDR16_COPY(&hdr->dhwaddr, &hdr->shwaddr);
    543c:	69a3      	ldr	r3, [r4, #24]
    543e:	f8c4 3022 	str.w	r3, [r4, #34]	; 0x22
    5442:	f8b8 3004 	ldrh.w	r3, [r8, #4]
    5446:	84e3      	strh	r3, [r4, #38]	; 0x26
			ETHADDR16_COPY(&ethhdr->dest, &hdr->shwaddr);
    5448:	69a3      	ldr	r3, [r4, #24]
    544a:	f8c4 3002 	str.w	r3, [r4, #2]
    544e:	f8b8 3004 	ldrh.w	r3, [r8, #4]
    5452:	80e3      	strh	r3, [r4, #6]
			ETHADDR16_COPY(&hdr->shwaddr, ethaddr);
    5454:	f8d5 302b 	ldr.w	r3, [r5, #43]	; 0x2b
    5458:	61a3      	str	r3, [r4, #24]
    545a:	f8ba 3004 	ldrh.w	r3, [sl, #4]
    545e:	f8a8 3004 	strh.w	r3, [r8, #4]
			ETHADDR16_COPY(&ethhdr->src, ethaddr);
    5462:	f8d5 302b 	ldr.w	r3, [r5, #43]	; 0x2b
    5466:	60a3      	str	r3, [r4, #8]
    5468:	f8ba 3004 	ldrh.w	r3, [sl, #4]
    546c:	81a3      	strh	r3, [r4, #12]
			netif->linkoutput(netif, p);
    546e:	69ab      	ldr	r3, [r5, #24]
    5470:	4631      	mov	r1, r6
    5472:	4628      	mov	r0, r5
    5474:	4798      	blx	r3
    5476:	e76a      	b.n	534e <ethernet_input+0x92>
    5478:	000030e1 	.word	0x000030e1
    547c:	0000ca50 	.word	0x0000ca50
    5480:	0000c05d 	.word	0x0000c05d
    5484:	00003089 	.word	0x00003089
    5488:	00006399 	.word	0x00006399
    548c:	00008a1f 	.word	0x00008a1f
    5490:	00004e41 	.word	0x00004e41
    5494:	20011004 	.word	0x20011004
    5498:	00005ecd 	.word	0x00005ecd
    549c:	00000d61 	.word	0x00000d61
    54a0:	00004f15 	.word	0x00004f15

000054a4 <dhcp_set_state>:
 *
 * If the state changed, reset the number of tries.
 */
static void dhcp_set_state(struct dhcp *dhcp, u8_t new_state)
{
	if (new_state != dhcp->state) {
    54a4:	7b03      	ldrb	r3, [r0, #12]
    54a6:	428b      	cmp	r3, r1
		dhcp->state           = new_state;
		dhcp->tries           = 0;
    54a8:	bf1f      	itttt	ne
    54aa:	2300      	movne	r3, #0
		dhcp->state           = new_state;
    54ac:	7301      	strbne	r1, [r0, #12]
		dhcp->tries           = 0;
    54ae:	7343      	strbne	r3, [r0, #13]
		dhcp->request_timeout = 0;
    54b0:	8343      	strhne	r3, [r0, #26]
	}
}
    54b2:	4770      	bx	lr

000054b4 <dhcp_option>:
 */
static void dhcp_option(struct dhcp *dhcp, u8_t option_type, u8_t option_len)
{
	LWIP_ASSERT("dhcp_option: dhcp->options_out_len + 2 + option_len <= DHCP_OPTIONS_LEN",
	            dhcp->options_out_len + 2U + option_len <= DHCP_OPTIONS_LEN);
	dhcp->msg_out->options[dhcp->options_out_len++] = option_type;
    54b4:	8b03      	ldrh	r3, [r0, #24]
{
    54b6:	b530      	push	{r4, r5, lr}
	dhcp->msg_out->options[dhcp->options_out_len++] = option_type;
    54b8:	6944      	ldr	r4, [r0, #20]
    54ba:	18e5      	adds	r5, r4, r3
    54bc:	f885 10f0 	strb.w	r1, [r5, #240]	; 0xf0
	dhcp->msg_out->options[dhcp->options_out_len++] = option_len;
    54c0:	1c99      	adds	r1, r3, #2
	dhcp->msg_out->options[dhcp->options_out_len++] = option_type;
    54c2:	3301      	adds	r3, #1
	dhcp->msg_out->options[dhcp->options_out_len++] = option_len;
    54c4:	fa14 f383 	uxtah	r3, r4, r3
    54c8:	8301      	strh	r1, [r0, #24]
    54ca:	f883 20f0 	strb.w	r2, [r3, #240]	; 0xf0
}
    54ce:	bd30      	pop	{r4, r5, pc}

000054d0 <dhcp_option_byte>:
 *
 */
static void dhcp_option_byte(struct dhcp *dhcp, u8_t value)
{
	LWIP_ASSERT("dhcp_option_byte: dhcp->options_out_len < DHCP_OPTIONS_LEN", dhcp->options_out_len < DHCP_OPTIONS_LEN);
	dhcp->msg_out->options[dhcp->options_out_len++] = value;
    54d0:	8b02      	ldrh	r2, [r0, #24]
    54d2:	6943      	ldr	r3, [r0, #20]
{
    54d4:	b510      	push	{r4, lr}
	dhcp->msg_out->options[dhcp->options_out_len++] = value;
    54d6:	4413      	add	r3, r2
    54d8:	1c54      	adds	r4, r2, #1
    54da:	8304      	strh	r4, [r0, #24]
    54dc:	f883 10f0 	strb.w	r1, [r3, #240]	; 0xf0
}
    54e0:	bd10      	pop	{r4, pc}

000054e2 <dhcp_option_short>:

static void dhcp_option_short(struct dhcp *dhcp, u16_t value)
{
	LWIP_ASSERT("dhcp_option_short: dhcp->options_out_len + 2 <= DHCP_OPTIONS_LEN",
	            dhcp->options_out_len + 2U <= DHCP_OPTIONS_LEN);
	dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t)((value & 0xff00U) >> 8);
    54e2:	8b03      	ldrh	r3, [r0, #24]
    54e4:	6942      	ldr	r2, [r0, #20]
{
    54e6:	b530      	push	{r4, r5, lr}
	dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t)((value & 0xff00U) >> 8);
    54e8:	18d4      	adds	r4, r2, r3
    54ea:	0a0d      	lsrs	r5, r1, #8
    54ec:	f884 50f0 	strb.w	r5, [r4, #240]	; 0xf0
	dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t)(value & 0x00ffU);
    54f0:	1c9c      	adds	r4, r3, #2
	dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t)((value & 0xff00U) >> 8);
    54f2:	3301      	adds	r3, #1
	dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t)(value & 0x00ffU);
    54f4:	fa12 f383 	uxtah	r3, r2, r3
    54f8:	8304      	strh	r4, [r0, #24]
    54fa:	f883 10f0 	strb.w	r1, [r3, #240]	; 0xf0
}
    54fe:	bd30      	pop	{r4, r5, pc}

00005500 <dhcp_option_long>:

static void dhcp_option_long(struct dhcp *dhcp, u32_t value)
{
	LWIP_ASSERT("dhcp_option_long: dhcp->options_out_len + 4 <= DHCP_OPTIONS_LEN",
	            dhcp->options_out_len + 4U <= DHCP_OPTIONS_LEN);
	dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t)((value & 0xff000000UL) >> 24);
    5500:	8b03      	ldrh	r3, [r0, #24]
    5502:	6942      	ldr	r2, [r0, #20]
{
    5504:	b530      	push	{r4, r5, lr}
	dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t)((value & 0xff000000UL) >> 24);
    5506:	18d4      	adds	r4, r2, r3
    5508:	0e0d      	lsrs	r5, r1, #24
    550a:	f884 50f0 	strb.w	r5, [r4, #240]	; 0xf0
    550e:	1c5c      	adds	r4, r3, #1
	dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t)((value & 0x00ff0000UL) >> 16);
    5510:	fa12 f484 	uxtah	r4, r2, r4
    5514:	0c0d      	lsrs	r5, r1, #16
    5516:	f884 50f0 	strb.w	r5, [r4, #240]	; 0xf0
    551a:	1c9c      	adds	r4, r3, #2
	dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t)((value & 0x0000ff00UL) >> 8);
    551c:	fa12 f484 	uxtah	r4, r2, r4
    5520:	0a0d      	lsrs	r5, r1, #8
    5522:	f884 50f0 	strb.w	r5, [r4, #240]	; 0xf0
	dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t)((value & 0x000000ffUL));
    5526:	1d1c      	adds	r4, r3, #4
	dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t)((value & 0x0000ff00UL) >> 8);
    5528:	3303      	adds	r3, #3
	dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t)((value & 0x000000ffUL));
    552a:	fa12 f383 	uxtah	r3, r2, r3
    552e:	8304      	strh	r4, [r0, #24]
    5530:	f883 10f0 	strb.w	r1, [r3, #240]	; 0xf0
}
    5534:	bd30      	pop	{r4, r5, pc}

00005536 <dhcp_option_trailer>:
 * necessary, up to three padding bytes.
 *
 * @param dhcp DHCP state structure
 */
static void dhcp_option_trailer(struct dhcp *dhcp)
{
    5536:	b510      	push	{r4, lr}
	LWIP_ERROR("dhcp_option_trailer: dhcp != NULL", (dhcp != NULL), return;);
    5538:	b900      	cbnz	r0, 553c <dhcp_option_trailer+0x6>
    553a:	e7fe      	b.n	553a <dhcp_option_trailer+0x4>
	LWIP_ASSERT("dhcp_option_trailer: dhcp->msg_out != NULL\n", dhcp->msg_out != NULL);
	LWIP_ASSERT("dhcp_option_trailer: dhcp->options_out_len < DHCP_OPTIONS_LEN\n",
	            dhcp->options_out_len < DHCP_OPTIONS_LEN);
	dhcp->msg_out->options[dhcp->options_out_len++] = DHCP_OPTION_END;
    553c:	8b03      	ldrh	r3, [r0, #24]
    553e:	6942      	ldr	r2, [r0, #20]
    5540:	1c59      	adds	r1, r3, #1
    5542:	4413      	add	r3, r2
    5544:	8301      	strh	r1, [r0, #24]
    5546:	21ff      	movs	r1, #255	; 0xff
    5548:	f883 10f0 	strb.w	r1, [r3, #240]	; 0xf0
	/* packet is too small, or not 4 byte aligned? */
	while (((dhcp->options_out_len < DHCP_MIN_OPTIONS_LEN) || (dhcp->options_out_len & 3))
	       && (dhcp->options_out_len < DHCP_OPTIONS_LEN)) {
		/* add a fill/padding byte */
		dhcp->msg_out->options[dhcp->options_out_len++] = 0;
    554c:	2100      	movs	r1, #0
	while (((dhcp->options_out_len < DHCP_MIN_OPTIONS_LEN) || (dhcp->options_out_len & 3))
    554e:	8b03      	ldrh	r3, [r0, #24]
    5550:	2b43      	cmp	r3, #67	; 0x43
    5552:	d900      	bls.n	5556 <dhcp_option_trailer+0x20>
	}
}
    5554:	bd10      	pop	{r4, pc}
		dhcp->msg_out->options[dhcp->options_out_len++] = 0;
    5556:	1c5c      	adds	r4, r3, #1
    5558:	4413      	add	r3, r2
    555a:	8304      	strh	r4, [r0, #24]
    555c:	f883 10f0 	strb.w	r1, [r3, #240]	; 0xf0
    5560:	e7f5      	b.n	554e <dhcp_option_trailer+0x18>
	...

00005564 <dhcp_delete_msg>:
{
    5564:	b510      	push	{r4, lr}
	LWIP_ERROR("dhcp_delete_msg: dhcp != NULL", (dhcp != NULL), return;);
    5566:	4604      	mov	r4, r0
    5568:	b900      	cbnz	r0, 556c <dhcp_delete_msg+0x8>
    556a:	e7fe      	b.n	556a <dhcp_delete_msg+0x6>
	if (dhcp->p_out != NULL) {
    556c:	6900      	ldr	r0, [r0, #16]
    556e:	b108      	cbz	r0, 5574 <dhcp_delete_msg+0x10>
		pbuf_free(dhcp->p_out);
    5570:	4b02      	ldr	r3, [pc, #8]	; (557c <dhcp_delete_msg+0x18>)
    5572:	4798      	blx	r3
	dhcp->p_out   = NULL;
    5574:	2300      	movs	r3, #0
	dhcp->msg_out = NULL;
    5576:	e9c4 3304 	strd	r3, r3, [r4, #16]
}
    557a:	bd10      	pop	{r4, pc}
    557c:	000030e1 	.word	0x000030e1

00005580 <dhcp_check>:
{
    5580:	b538      	push	{r3, r4, r5, lr}
	struct dhcp *dhcp = netif->dhcp;
    5582:	6a44      	ldr	r4, [r0, #36]	; 0x24
	dhcp_set_state(dhcp, DHCP_CHECKING);
    5584:	4b08      	ldr	r3, [pc, #32]	; (55a8 <dhcp_check+0x28>)
{
    5586:	4605      	mov	r5, r0
	dhcp_set_state(dhcp, DHCP_CHECKING);
    5588:	2108      	movs	r1, #8
    558a:	4620      	mov	r0, r4
    558c:	4798      	blx	r3
	result = etharp_query(netif, &dhcp->offered_ip_addr, NULL);
    558e:	2200      	movs	r2, #0
    5590:	4b06      	ldr	r3, [pc, #24]	; (55ac <dhcp_check+0x2c>)
    5592:	f104 0124 	add.w	r1, r4, #36	; 0x24
    5596:	4628      	mov	r0, r5
    5598:	4798      	blx	r3
	dhcp->tries++;
    559a:	7b63      	ldrb	r3, [r4, #13]
    559c:	3301      	adds	r3, #1
    559e:	7363      	strb	r3, [r4, #13]
	dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
    55a0:	2301      	movs	r3, #1
    55a2:	8363      	strh	r3, [r4, #26]
}
    55a4:	bd38      	pop	{r3, r4, r5, pc}
    55a6:	bf00      	nop
    55a8:	000054a5 	.word	0x000054a5
    55ac:	000050a9 	.word	0x000050a9

000055b0 <dhcp_bind>:
{
    55b0:	b51f      	push	{r0, r1, r2, r3, r4, lr}
	LWIP_ERROR("dhcp_bind: netif != NULL", (netif != NULL), return;);
    55b2:	b900      	cbnz	r0, 55b6 <dhcp_bind+0x6>
    55b4:	e7fe      	b.n	55b4 <dhcp_bind+0x4>
	dhcp = netif->dhcp;
    55b6:	6a44      	ldr	r4, [r0, #36]	; 0x24
	LWIP_ERROR("dhcp_bind: dhcp != NULL", (dhcp != NULL), return;);
    55b8:	b904      	cbnz	r4, 55bc <dhcp_bind+0xc>
    55ba:	e7fe      	b.n	55ba <dhcp_bind+0xa>
	if (dhcp->offered_t1_renew != 0xffffffffUL) {
    55bc:	6b63      	ldr	r3, [r4, #52]	; 0x34
    55be:	1c59      	adds	r1, r3, #1
    55c0:	d00c      	beq.n	55dc <dhcp_bind+0x2c>
		timeout = (dhcp->offered_t1_renew + DHCP_COARSE_TIMER_SECS / 2) / DHCP_COARSE_TIMER_SECS;
    55c2:	331e      	adds	r3, #30
		if (timeout > 0xffff) {
    55c4:	f5b3 1f70 	cmp.w	r3, #3932160	; 0x3c0000
			timeout = 0xffff;
    55c8:	bf2e      	itee	cs
    55ca:	f64f 73ff 	movwcs	r3, #65535	; 0xffff
		timeout = (dhcp->offered_t1_renew + DHCP_COARSE_TIMER_SECS / 2) / DHCP_COARSE_TIMER_SECS;
    55ce:	223c      	movcc	r2, #60	; 0x3c
    55d0:	fbb3 f3f2 	udivcc	r3, r3, r2
		dhcp->t1_timeout = (u16_t)timeout;
    55d4:	b29a      	uxth	r2, r3
		if (dhcp->t1_timeout == 0) {
    55d6:	2b00      	cmp	r3, #0
    55d8:	d03b      	beq.n	5652 <dhcp_bind+0xa2>
		dhcp->t1_timeout = (u16_t)timeout;
    55da:	83a2      	strh	r2, [r4, #28]
	if (dhcp->offered_t2_rebind != 0xffffffffUL) {
    55dc:	6ba3      	ldr	r3, [r4, #56]	; 0x38
    55de:	1c5a      	adds	r2, r3, #1
    55e0:	d00c      	beq.n	55fc <dhcp_bind+0x4c>
		timeout = (dhcp->offered_t2_rebind + DHCP_COARSE_TIMER_SECS / 2) / DHCP_COARSE_TIMER_SECS;
    55e2:	331e      	adds	r3, #30
		if (timeout > 0xffff) {
    55e4:	f5b3 1f70 	cmp.w	r3, #3932160	; 0x3c0000
			timeout = 0xffff;
    55e8:	bf2e      	itee	cs
    55ea:	f64f 73ff 	movwcs	r3, #65535	; 0xffff
		timeout = (dhcp->offered_t2_rebind + DHCP_COARSE_TIMER_SECS / 2) / DHCP_COARSE_TIMER_SECS;
    55ee:	223c      	movcc	r2, #60	; 0x3c
    55f0:	fbb3 f3f2 	udivcc	r3, r3, r2
		dhcp->t2_timeout = (u16_t)timeout;
    55f4:	b29a      	uxth	r2, r3
		if (dhcp->t2_timeout == 0) {
    55f6:	2b00      	cmp	r3, #0
    55f8:	d02e      	beq.n	5658 <dhcp_bind+0xa8>
		dhcp->t2_timeout = (u16_t)timeout;
    55fa:	83e2      	strh	r2, [r4, #30]
	if ((dhcp->t1_timeout >= dhcp->t2_timeout) && (dhcp->t2_timeout > 0)) {
    55fc:	8be3      	ldrh	r3, [r4, #30]
    55fe:	8ba2      	ldrh	r2, [r4, #28]
    5600:	429a      	cmp	r2, r3
    5602:	d302      	bcc.n	560a <dhcp_bind+0x5a>
    5604:	b10b      	cbz	r3, 560a <dhcp_bind+0x5a>
		dhcp->t1_timeout = 0;
    5606:	2300      	movs	r3, #0
    5608:	83a3      	strh	r3, [r4, #28]
	if (dhcp->subnet_mask_given) {
    560a:	7ba3      	ldrb	r3, [r4, #14]
    560c:	2b00      	cmp	r3, #0
    560e:	d026      	beq.n	565e <dhcp_bind+0xae>
		ip_addr_copy(sn_mask, dhcp->offered_sn_mask);
    5610:	6aa3      	ldr	r3, [r4, #40]	; 0x28
			ip4_addr_set_u32(&sn_mask, PP_HTONL(0xffff0000UL));
    5612:	9302      	str	r3, [sp, #8]
	ip_addr_copy(gw_addr, dhcp->offered_gw_addr);
    5614:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
    5616:	9303      	str	r3, [sp, #12]
	if (ip_addr_isany(&gw_addr)) {
    5618:	b92b      	cbnz	r3, 5626 <dhcp_bind+0x76>
		ip_addr_get_network(&gw_addr, &dhcp->offered_ip_addr, &sn_mask);
    561a:	6a63      	ldr	r3, [r4, #36]	; 0x24
    561c:	9a02      	ldr	r2, [sp, #8]
    561e:	4013      	ands	r3, r2
		ip4_addr_set_u32(&gw_addr, ip4_addr_get_u32(&gw_addr) | PP_HTONL(0x00000001UL));
    5620:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
    5624:	9303      	str	r3, [sp, #12]
	netif_set_ipaddr(netif, &dhcp->offered_ip_addr);
    5626:	f104 0124 	add.w	r1, r4, #36	; 0x24
    562a:	4b14      	ldr	r3, [pc, #80]	; (567c <dhcp_bind+0xcc>)
    562c:	9001      	str	r0, [sp, #4]
    562e:	4798      	blx	r3
	netif_set_netmask(netif, &sn_mask);
    5630:	9801      	ldr	r0, [sp, #4]
    5632:	4b13      	ldr	r3, [pc, #76]	; (5680 <dhcp_bind+0xd0>)
    5634:	a902      	add	r1, sp, #8
    5636:	4798      	blx	r3
	netif_set_gw(netif, &gw_addr);
    5638:	a903      	add	r1, sp, #12
    563a:	9801      	ldr	r0, [sp, #4]
    563c:	4b11      	ldr	r3, [pc, #68]	; (5684 <dhcp_bind+0xd4>)
    563e:	4798      	blx	r3
	netif_set_up(netif);
    5640:	9801      	ldr	r0, [sp, #4]
    5642:	4b11      	ldr	r3, [pc, #68]	; (5688 <dhcp_bind+0xd8>)
    5644:	4798      	blx	r3
	dhcp_set_state(dhcp, DHCP_BOUND);
    5646:	4b11      	ldr	r3, [pc, #68]	; (568c <dhcp_bind+0xdc>)
    5648:	210a      	movs	r1, #10
    564a:	4620      	mov	r0, r4
    564c:	4798      	blx	r3
}
    564e:	b004      	add	sp, #16
    5650:	bd10      	pop	{r4, pc}
			dhcp->t1_timeout = 1;
    5652:	2301      	movs	r3, #1
    5654:	83a3      	strh	r3, [r4, #28]
    5656:	e7c1      	b.n	55dc <dhcp_bind+0x2c>
			dhcp->t2_timeout = 1;
    5658:	2301      	movs	r3, #1
    565a:	83e3      	strh	r3, [r4, #30]
    565c:	e7ce      	b.n	55fc <dhcp_bind+0x4c>
		if (first_octet <= 127) {
    565e:	f994 2024 	ldrsb.w	r2, [r4, #36]	; 0x24
		u8_t first_octet = ip4_addr1(&dhcp->offered_ip_addr);
    5662:	f894 3024 	ldrb.w	r3, [r4, #36]	; 0x24
		if (first_octet <= 127) {
    5666:	2a00      	cmp	r2, #0
    5668:	db01      	blt.n	566e <dhcp_bind+0xbe>
			ip4_addr_set_u32(&sn_mask, PP_HTONL(0xff000000UL));
    566a:	23ff      	movs	r3, #255	; 0xff
    566c:	e7d1      	b.n	5612 <dhcp_bind+0x62>
		} else if (first_octet >= 192) {
    566e:	2bbf      	cmp	r3, #191	; 0xbf
			ip4_addr_set_u32(&sn_mask, PP_HTONL(0xffffff00UL));
    5670:	bf8c      	ite	hi
    5672:	f06f 437f 	mvnhi.w	r3, #4278190080	; 0xff000000
			ip4_addr_set_u32(&sn_mask, PP_HTONL(0xffff0000UL));
    5676:	f64f 73ff 	movwls	r3, #65535	; 0xffff
    567a:	e7ca      	b.n	5612 <dhcp_bind+0x62>
    567c:	00009fb9 	.word	0x00009fb9
    5680:	0000a085 	.word	0x0000a085
    5684:	0000a07d 	.word	0x0000a07d
    5688:	0000a099 	.word	0x0000a099
    568c:	000054a5 	.word	0x000054a5

00005690 <dhcp_create_msg>:
{
    5690:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    5694:	460d      	mov	r5, r1
    5696:	4690      	mov	r8, r2
	LWIP_ERROR("dhcp_create_msg: netif != NULL", (netif != NULL), return ERR_ARG;);
    5698:	4606      	mov	r6, r0
    569a:	b900      	cbnz	r0, 569e <dhcp_create_msg+0xe>
    569c:	e7fe      	b.n	569c <dhcp_create_msg+0xc>
	LWIP_ERROR("dhcp_create_msg: dhcp != NULL", (dhcp != NULL), return ERR_VAL;);
    569e:	b901      	cbnz	r1, 56a2 <dhcp_create_msg+0x12>
    56a0:	e7fe      	b.n	56a0 <dhcp_create_msg+0x10>
	dhcp->p_out = pbuf_alloc(PBUF_TRANSPORT, sizeof(struct dhcp_msg), PBUF_RAM);
    56a2:	2200      	movs	r2, #0
    56a4:	4b40      	ldr	r3, [pc, #256]	; (57a8 <dhcp_create_msg+0x118>)
    56a6:	f44f 719a 	mov.w	r1, #308	; 0x134
    56aa:	4610      	mov	r0, r2
    56ac:	4798      	blx	r3
    56ae:	6128      	str	r0, [r5, #16]
	if (dhcp->p_out == NULL) {
    56b0:	2800      	cmp	r0, #0
    56b2:	d075      	beq.n	57a0 <dhcp_create_msg+0x110>
	if (dhcp->tries == 0) {
    56b4:	7b6a      	ldrb	r2, [r5, #13]
    56b6:	4b3d      	ldr	r3, [pc, #244]	; (57ac <dhcp_create_msg+0x11c>)
    56b8:	b912      	cbnz	r2, 56c0 <dhcp_create_msg+0x30>
		xid++;
    56ba:	681a      	ldr	r2, [r3, #0]
    56bc:	3201      	adds	r2, #1
    56be:	601a      	str	r2, [r3, #0]
	dhcp->msg_out = (struct dhcp_msg *)dhcp->p_out->payload;
    56c0:	6844      	ldr	r4, [r0, #4]
	dhcp->xid = xid;
    56c2:	681b      	ldr	r3, [r3, #0]
    56c4:	602b      	str	r3, [r5, #0]
	dhcp->msg_out->op = DHCP_BOOTREQUEST;
    56c6:	2201      	movs	r2, #1
	dhcp->msg_out = (struct dhcp_msg *)dhcp->p_out->payload;
    56c8:	616c      	str	r4, [r5, #20]
	dhcp->msg_out->op = DHCP_BOOTREQUEST;
    56ca:	7022      	strb	r2, [r4, #0]
	dhcp->msg_out->htype = DHCP_HTYPE_ETH;
    56cc:	7062      	strb	r2, [r4, #1]
	dhcp->msg_out->hops  = 0;
    56ce:	2700      	movs	r7, #0
	dhcp->msg_out->hlen  = netif->hwaddr_len;
    56d0:	f896 202a 	ldrb.w	r2, [r6, #42]	; 0x2a
    56d4:	70a2      	strb	r2, [r4, #2]
	dhcp->msg_out->hops  = 0;
    56d6:	70e7      	strb	r7, [r4, #3]
	dhcp->msg_out->xid   = htonl(dhcp->xid);
    56d8:	4618      	mov	r0, r3
    56da:	4b35      	ldr	r3, [pc, #212]	; (57b0 <dhcp_create_msg+0x120>)
    56dc:	4798      	blx	r3
    56de:	6060      	str	r0, [r4, #4]
	dhcp->msg_out->secs  = 0;
    56e0:	696c      	ldr	r4, [r5, #20]
	if ((message_type == DHCP_INFORM) || (message_type == DHCP_DECLINE)
    56e2:	f1b8 0f08 	cmp.w	r8, #8
	dhcp->msg_out->secs  = 0;
    56e6:	7227      	strb	r7, [r4, #8]
    56e8:	7267      	strb	r7, [r4, #9]
	dhcp->msg_out->flags = 0;
    56ea:	72a7      	strb	r7, [r4, #10]
    56ec:	72e7      	strb	r7, [r4, #11]
	ip_addr_set_zero(&dhcp->msg_out->ciaddr);
    56ee:	7327      	strb	r7, [r4, #12]
    56f0:	7367      	strb	r7, [r4, #13]
    56f2:	73a7      	strb	r7, [r4, #14]
    56f4:	73e7      	strb	r7, [r4, #15]
	if ((message_type == DHCP_INFORM) || (message_type == DHCP_DECLINE)
    56f6:	d009      	beq.n	570c <dhcp_create_msg+0x7c>
    56f8:	f1b8 0f04 	cmp.w	r8, #4
    56fc:	d006      	beq.n	570c <dhcp_create_msg+0x7c>
	    || ((message_type == DHCP_REQUEST) && /* DHCP_BOUND not used for sending! */
    56fe:	f1b8 0f03 	cmp.w	r8, #3
    5702:	d105      	bne.n	5710 <dhcp_create_msg+0x80>
	        ((dhcp->state == DHCP_RENEWING) || dhcp->state == DHCP_REBINDING))) {
    5704:	7b2b      	ldrb	r3, [r5, #12]
	    || ((message_type == DHCP_REQUEST) && /* DHCP_BOUND not used for sending! */
    5706:	3b04      	subs	r3, #4
    5708:	2b01      	cmp	r3, #1
    570a:	d801      	bhi.n	5710 <dhcp_create_msg+0x80>
		ip_addr_copy(dhcp->msg_out->ciaddr, netif->ip_addr);
    570c:	6873      	ldr	r3, [r6, #4]
    570e:	60e3      	str	r3, [r4, #12]
	ip_addr_set_zero(&dhcp->msg_out->yiaddr);
    5710:	2300      	movs	r3, #0
    5712:	7423      	strb	r3, [r4, #16]
    5714:	7463      	strb	r3, [r4, #17]
    5716:	74a3      	strb	r3, [r4, #18]
    5718:	74e3      	strb	r3, [r4, #19]
	ip_addr_set_zero(&dhcp->msg_out->siaddr);
    571a:	7523      	strb	r3, [r4, #20]
    571c:	7563      	strb	r3, [r4, #21]
    571e:	75a3      	strb	r3, [r4, #22]
    5720:	75e3      	strb	r3, [r4, #23]
	ip_addr_set_zero(&dhcp->msg_out->giaddr);
    5722:	7623      	strb	r3, [r4, #24]
    5724:	7663      	strb	r3, [r4, #25]
    5726:	76a3      	strb	r3, [r4, #26]
    5728:	76e3      	strb	r3, [r4, #27]
		dhcp->msg_out->chaddr[i] = (i < netif->hwaddr_len) ? netif->hwaddr[i] : 0 /* pad byte*/;
    572a:	f896 002a 	ldrb.w	r0, [r6, #42]	; 0x2a
    572e:	f104 021c 	add.w	r2, r4, #28
    5732:	362b      	adds	r6, #43	; 0x2b
    5734:	b299      	uxth	r1, r3
    5736:	4288      	cmp	r0, r1
    5738:	bf88      	it	hi
    573a:	5cf1      	ldrbhi	r1, [r6, r3]
	for (i = 0; i < DHCP_CHADDR_LEN; i++) {
    573c:	f103 0301 	add.w	r3, r3, #1
		dhcp->msg_out->chaddr[i] = (i < netif->hwaddr_len) ? netif->hwaddr[i] : 0 /* pad byte*/;
    5740:	bf98      	it	ls
    5742:	2100      	movls	r1, #0
	for (i = 0; i < DHCP_CHADDR_LEN; i++) {
    5744:	2b10      	cmp	r3, #16
		dhcp->msg_out->chaddr[i] = (i < netif->hwaddr_len) ? netif->hwaddr[i] : 0 /* pad byte*/;
    5746:	f802 1b01 	strb.w	r1, [r2], #1
	for (i = 0; i < DHCP_CHADDR_LEN; i++) {
    574a:	d1f3      	bne.n	5734 <dhcp_create_msg+0xa4>
		dhcp->msg_out->sname[i] = 0;
    574c:	4e19      	ldr	r6, [pc, #100]	; (57b4 <dhcp_create_msg+0x124>)
    574e:	2240      	movs	r2, #64	; 0x40
    5750:	2100      	movs	r1, #0
    5752:	f104 002c 	add.w	r0, r4, #44	; 0x2c
    5756:	47b0      	blx	r6
		dhcp->msg_out->file[i] = 0;
    5758:	2280      	movs	r2, #128	; 0x80
    575a:	2100      	movs	r1, #0
    575c:	f104 006c 	add.w	r0, r4, #108	; 0x6c
    5760:	47b0      	blx	r6
	dhcp->msg_out->cookie = PP_HTONL(DHCP_MAGIC_COOKIE);
    5762:	f06f 017d 	mvn.w	r1, #125	; 0x7d
    5766:	f884 10ed 	strb.w	r1, [r4, #237]	; 0xed
    576a:	2263      	movs	r2, #99	; 0x63
    576c:	2300      	movs	r3, #0
    576e:	2153      	movs	r1, #83	; 0x53
    5770:	f884 20ec 	strb.w	r2, [r4, #236]	; 0xec
    5774:	f884 10ee 	strb.w	r1, [r4, #238]	; 0xee
    5778:	f884 20ef 	strb.w	r2, [r4, #239]	; 0xef
	dhcp->options_out_len = 0;
    577c:	832b      	strh	r3, [r5, #24]
	for (i = 0; i < DHCP_OPTIONS_LEN; i++) {
    577e:	34f0      	adds	r4, #240	; 0xf0
		dhcp->msg_out->options[i] = (u8_t)i; /* for debugging only, no matter if truncated */
    5780:	f804 3b01 	strb.w	r3, [r4], #1
	for (i = 0; i < DHCP_OPTIONS_LEN; i++) {
    5784:	3301      	adds	r3, #1
    5786:	2b44      	cmp	r3, #68	; 0x44
    5788:	d1fa      	bne.n	5780 <dhcp_create_msg+0xf0>
	dhcp_option(dhcp, DHCP_OPTION_MESSAGE_TYPE, DHCP_OPTION_MESSAGE_TYPE_LEN);
    578a:	4628      	mov	r0, r5
    578c:	4b0a      	ldr	r3, [pc, #40]	; (57b8 <dhcp_create_msg+0x128>)
    578e:	2201      	movs	r2, #1
    5790:	2135      	movs	r1, #53	; 0x35
    5792:	4798      	blx	r3
	dhcp_option_byte(dhcp, message_type);
    5794:	4b09      	ldr	r3, [pc, #36]	; (57bc <dhcp_create_msg+0x12c>)
    5796:	4641      	mov	r1, r8
    5798:	4798      	blx	r3
	return ERR_OK;
    579a:	2000      	movs	r0, #0
}
    579c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		return ERR_MEM;
    57a0:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    57a4:	e7fa      	b.n	579c <dhcp_create_msg+0x10c>
    57a6:	bf00      	nop
    57a8:	00003139 	.word	0x00003139
    57ac:	20000008 	.word	0x20000008
    57b0:	00000d6d 	.word	0x00000d6d
    57b4:	0000c099 	.word	0x0000c099
    57b8:	000054b5 	.word	0x000054b5
    57bc:	000054d1 	.word	0x000054d1

000057c0 <dhcp_discover>:
{
    57c0:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
	struct dhcp *dhcp   = netif->dhcp;
    57c2:	6a44      	ldr	r4, [r0, #36]	; 0x24
	ip_addr_set_any(&dhcp->offered_ip_addr);
    57c4:	2300      	movs	r3, #0
{
    57c6:	4606      	mov	r6, r0
	ip_addr_set_any(&dhcp->offered_ip_addr);
    57c8:	6263      	str	r3, [r4, #36]	; 0x24
	dhcp_set_state(dhcp, DHCP_SELECTING);
    57ca:	2106      	movs	r1, #6
    57cc:	4b23      	ldr	r3, [pc, #140]	; (585c <dhcp_discover+0x9c>)
    57ce:	4620      	mov	r0, r4
    57d0:	4798      	blx	r3
	result = dhcp_create_msg(netif, dhcp, DHCP_DISCOVER);
    57d2:	2201      	movs	r2, #1
    57d4:	4b22      	ldr	r3, [pc, #136]	; (5860 <dhcp_discover+0xa0>)
    57d6:	4621      	mov	r1, r4
    57d8:	4630      	mov	r0, r6
    57da:	4798      	blx	r3
	if (result == ERR_OK) {
    57dc:	4605      	mov	r5, r0
    57de:	bb28      	cbnz	r0, 582c <dhcp_discover+0x6c>
		dhcp_option(dhcp, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
    57e0:	4620      	mov	r0, r4
    57e2:	4f20      	ldr	r7, [pc, #128]	; (5864 <dhcp_discover+0xa4>)
    57e4:	2202      	movs	r2, #2
    57e6:	2139      	movs	r1, #57	; 0x39
    57e8:	47b8      	blx	r7
		dhcp_option_short(dhcp, DHCP_MAX_MSG_LEN(netif));
    57ea:	4b1f      	ldr	r3, [pc, #124]	; (5868 <dhcp_discover+0xa8>)
    57ec:	8d31      	ldrh	r1, [r6, #40]	; 0x28
    57ee:	4798      	blx	r3
		dhcp_option(dhcp, DHCP_OPTION_PARAMETER_REQUEST_LIST, 4 /*num options*/);
    57f0:	2204      	movs	r2, #4
    57f2:	2137      	movs	r1, #55	; 0x37
    57f4:	47b8      	blx	r7
		dhcp_option_byte(dhcp, DHCP_OPTION_SUBNET_MASK);
    57f6:	4f1d      	ldr	r7, [pc, #116]	; (586c <dhcp_discover+0xac>)
    57f8:	2101      	movs	r1, #1
    57fa:	47b8      	blx	r7
		dhcp_option_byte(dhcp, DHCP_OPTION_ROUTER);
    57fc:	2103      	movs	r1, #3
    57fe:	47b8      	blx	r7
		dhcp_option_byte(dhcp, DHCP_OPTION_BROADCAST);
    5800:	211c      	movs	r1, #28
    5802:	47b8      	blx	r7
		dhcp_option_byte(dhcp, DHCP_OPTION_DNS_SERVER);
    5804:	2106      	movs	r1, #6
    5806:	47b8      	blx	r7
		dhcp_option_trailer(dhcp);
    5808:	4b19      	ldr	r3, [pc, #100]	; (5870 <dhcp_discover+0xb0>)
    580a:	4798      	blx	r3
		pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
    580c:	8b21      	ldrh	r1, [r4, #24]
    580e:	6920      	ldr	r0, [r4, #16]
    5810:	4b18      	ldr	r3, [pc, #96]	; (5874 <dhcp_discover+0xb4>)
    5812:	31f0      	adds	r1, #240	; 0xf0
    5814:	b289      	uxth	r1, r1
    5816:	4798      	blx	r3
		udp_sendto_if(dhcp->pcb, dhcp->p_out, IP_ADDR_BROADCAST, DHCP_SERVER_PORT, netif);
    5818:	9600      	str	r6, [sp, #0]
    581a:	2343      	movs	r3, #67	; 0x43
    581c:	4a16      	ldr	r2, [pc, #88]	; (5878 <dhcp_discover+0xb8>)
    581e:	6921      	ldr	r1, [r4, #16]
    5820:	6860      	ldr	r0, [r4, #4]
    5822:	4e16      	ldr	r6, [pc, #88]	; (587c <dhcp_discover+0xbc>)
    5824:	47b0      	blx	r6
		dhcp_delete_msg(dhcp);
    5826:	4b16      	ldr	r3, [pc, #88]	; (5880 <dhcp_discover+0xc0>)
    5828:	4620      	mov	r0, r4
    582a:	4798      	blx	r3
	dhcp->tries++;
    582c:	7b63      	ldrb	r3, [r4, #13]
    582e:	3301      	adds	r3, #1
    5830:	b2da      	uxtb	r2, r3
	msecs                 = (dhcp->tries < 6 ? 1 << dhcp->tries : 60) * 1000;
    5832:	2a05      	cmp	r2, #5
    5834:	bf9d      	ittte	ls
    5836:	f44f 737a 	movls.w	r3, #1000	; 0x3e8
    583a:	4093      	lslls	r3, r2
    583c:	b29b      	uxthls	r3, r3
    583e:	f64e 2360 	movwhi	r3, #60000	; 0xea60
	dhcp->tries++;
    5842:	7362      	strb	r2, [r4, #13]
}
    5844:	4628      	mov	r0, r5
	dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
    5846:	f44f 72fa 	mov.w	r2, #500	; 0x1f4
    584a:	f203 13f3 	addw	r3, r3, #499	; 0x1f3
    584e:	b29b      	uxth	r3, r3
    5850:	fbb3 f3f2 	udiv	r3, r3, r2
    5854:	8363      	strh	r3, [r4, #26]
}
    5856:	b003      	add	sp, #12
    5858:	bdf0      	pop	{r4, r5, r6, r7, pc}
    585a:	bf00      	nop
    585c:	000054a5 	.word	0x000054a5
    5860:	00005691 	.word	0x00005691
    5864:	000054b5 	.word	0x000054b5
    5868:	000054e3 	.word	0x000054e3
    586c:	000054d1 	.word	0x000054d1
    5870:	00005537 	.word	0x00005537
    5874:	00003249 	.word	0x00003249
    5878:	0000cc8c 	.word	0x0000cc8c
    587c:	00004699 	.word	0x00004699
    5880:	00005565 	.word	0x00005565

00005884 <dhcp_reboot.isra.0>:
static err_t dhcp_reboot(struct netif *netif)
    5884:	b573      	push	{r0, r1, r4, r5, r6, lr}
	struct dhcp *dhcp = netif->dhcp;
    5886:	6a44      	ldr	r4, [r0, #36]	; 0x24
	dhcp_set_state(dhcp, DHCP_REBOOTING);
    5888:	4b24      	ldr	r3, [pc, #144]	; (591c <dhcp_reboot.isra.0+0x98>)
    588a:	2103      	movs	r1, #3
static err_t dhcp_reboot(struct netif *netif)
    588c:	4605      	mov	r5, r0
	dhcp_set_state(dhcp, DHCP_REBOOTING);
    588e:	4620      	mov	r0, r4
    5890:	4798      	blx	r3
	result = dhcp_create_msg(netif, dhcp, DHCP_REQUEST);
    5892:	460a      	mov	r2, r1
    5894:	4b22      	ldr	r3, [pc, #136]	; (5920 <dhcp_reboot.isra.0+0x9c>)
    5896:	4621      	mov	r1, r4
    5898:	4628      	mov	r0, r5
    589a:	4798      	blx	r3
	if (result == ERR_OK) {
    589c:	bb20      	cbnz	r0, 58e8 <dhcp_reboot.isra.0+0x64>
		dhcp_option(dhcp, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
    589e:	4620      	mov	r0, r4
    58a0:	2202      	movs	r2, #2
    58a2:	4e20      	ldr	r6, [pc, #128]	; (5924 <dhcp_reboot.isra.0+0xa0>)
    58a4:	2139      	movs	r1, #57	; 0x39
    58a6:	47b0      	blx	r6
		dhcp_option_short(dhcp, 576);
    58a8:	4b1f      	ldr	r3, [pc, #124]	; (5928 <dhcp_reboot.isra.0+0xa4>)
    58aa:	f44f 7110 	mov.w	r1, #576	; 0x240
    58ae:	4798      	blx	r3
		dhcp_option(dhcp, DHCP_OPTION_REQUESTED_IP, 4);
    58b0:	2204      	movs	r2, #4
    58b2:	2132      	movs	r1, #50	; 0x32
    58b4:	47b0      	blx	r6
		dhcp_option_long(dhcp, ntohl(ip4_addr_get_u32(&dhcp->offered_ip_addr)));
    58b6:	4b1d      	ldr	r3, [pc, #116]	; (592c <dhcp_reboot.isra.0+0xa8>)
    58b8:	6a60      	ldr	r0, [r4, #36]	; 0x24
    58ba:	4798      	blx	r3
    58bc:	4b1c      	ldr	r3, [pc, #112]	; (5930 <dhcp_reboot.isra.0+0xac>)
    58be:	4601      	mov	r1, r0
    58c0:	4620      	mov	r0, r4
    58c2:	4798      	blx	r3
		dhcp_option_trailer(dhcp);
    58c4:	4b1b      	ldr	r3, [pc, #108]	; (5934 <dhcp_reboot.isra.0+0xb0>)
    58c6:	4798      	blx	r3
		pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
    58c8:	8b21      	ldrh	r1, [r4, #24]
    58ca:	6920      	ldr	r0, [r4, #16]
    58cc:	4b1a      	ldr	r3, [pc, #104]	; (5938 <dhcp_reboot.isra.0+0xb4>)
    58ce:	31f0      	adds	r1, #240	; 0xf0
    58d0:	b289      	uxth	r1, r1
    58d2:	4798      	blx	r3
		udp_sendto_if(dhcp->pcb, dhcp->p_out, IP_ADDR_BROADCAST, DHCP_SERVER_PORT, netif);
    58d4:	9500      	str	r5, [sp, #0]
    58d6:	2343      	movs	r3, #67	; 0x43
    58d8:	4a18      	ldr	r2, [pc, #96]	; (593c <dhcp_reboot.isra.0+0xb8>)
    58da:	6921      	ldr	r1, [r4, #16]
    58dc:	6860      	ldr	r0, [r4, #4]
    58de:	4d18      	ldr	r5, [pc, #96]	; (5940 <dhcp_reboot.isra.0+0xbc>)
    58e0:	47a8      	blx	r5
		dhcp_delete_msg(dhcp);
    58e2:	4b18      	ldr	r3, [pc, #96]	; (5944 <dhcp_reboot.isra.0+0xc0>)
    58e4:	4620      	mov	r0, r4
    58e6:	4798      	blx	r3
	dhcp->tries++;
    58e8:	7b63      	ldrb	r3, [r4, #13]
    58ea:	3301      	adds	r3, #1
    58ec:	b2db      	uxtb	r3, r3
	msecs                 = dhcp->tries < 10 ? dhcp->tries * 1000 : 10 * 1000;
    58ee:	2b09      	cmp	r3, #9
    58f0:	bf98      	it	ls
    58f2:	ebc3 1243 	rsbls	r2, r3, r3, lsl #5
	dhcp->tries++;
    58f6:	7363      	strb	r3, [r4, #13]
	msecs                 = dhcp->tries < 10 ? dhcp->tries * 1000 : 10 * 1000;
    58f8:	bf9d      	ittte	ls
    58fa:	eb03 0382 	addls.w	r3, r3, r2, lsl #2
    58fe:	00db      	lslls	r3, r3, #3
    5900:	b29b      	uxthls	r3, r3
    5902:	f242 7310 	movwhi	r3, #10000	; 0x2710
	dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
    5906:	f44f 72fa 	mov.w	r2, #500	; 0x1f4
    590a:	f203 13f3 	addw	r3, r3, #499	; 0x1f3
    590e:	b29b      	uxth	r3, r3
    5910:	fbb3 f3f2 	udiv	r3, r3, r2
    5914:	8363      	strh	r3, [r4, #26]
}
    5916:	b002      	add	sp, #8
    5918:	bd70      	pop	{r4, r5, r6, pc}
    591a:	bf00      	nop
    591c:	000054a5 	.word	0x000054a5
    5920:	00005691 	.word	0x00005691
    5924:	000054b5 	.word	0x000054b5
    5928:	000054e3 	.word	0x000054e3
    592c:	00000d71 	.word	0x00000d71
    5930:	00005501 	.word	0x00005501
    5934:	00005537 	.word	0x00005537
    5938:	00003249 	.word	0x00003249
    593c:	0000cc8c 	.word	0x0000cc8c
    5940:	00004699 	.word	0x00004699
    5944:	00005565 	.word	0x00005565

00005948 <dhcp_rebind.isra.0>:
static err_t dhcp_rebind(struct netif *netif)
    5948:	b537      	push	{r0, r1, r2, r4, r5, lr}
	struct dhcp *dhcp = netif->dhcp;
    594a:	6a44      	ldr	r4, [r0, #36]	; 0x24
	dhcp_set_state(dhcp, DHCP_REBINDING);
    594c:	4b1e      	ldr	r3, [pc, #120]	; (59c8 <dhcp_rebind.isra.0+0x80>)
static err_t dhcp_rebind(struct netif *netif)
    594e:	4605      	mov	r5, r0
	dhcp_set_state(dhcp, DHCP_REBINDING);
    5950:	2104      	movs	r1, #4
    5952:	4620      	mov	r0, r4
    5954:	4798      	blx	r3
	result = dhcp_create_msg(netif, dhcp, DHCP_REQUEST);
    5956:	2203      	movs	r2, #3
    5958:	4b1c      	ldr	r3, [pc, #112]	; (59cc <dhcp_rebind.isra.0+0x84>)
    595a:	4621      	mov	r1, r4
    595c:	4628      	mov	r0, r5
    595e:	4798      	blx	r3
	if (result == ERR_OK) {
    5960:	b9c8      	cbnz	r0, 5996 <dhcp_rebind.isra.0+0x4e>
		dhcp_option(dhcp, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
    5962:	2202      	movs	r2, #2
    5964:	4620      	mov	r0, r4
    5966:	4b1a      	ldr	r3, [pc, #104]	; (59d0 <dhcp_rebind.isra.0+0x88>)
    5968:	2139      	movs	r1, #57	; 0x39
    596a:	4798      	blx	r3
		dhcp_option_short(dhcp, DHCP_MAX_MSG_LEN(netif));
    596c:	8d29      	ldrh	r1, [r5, #40]	; 0x28
    596e:	4b19      	ldr	r3, [pc, #100]	; (59d4 <dhcp_rebind.isra.0+0x8c>)
    5970:	4798      	blx	r3
		dhcp_option_trailer(dhcp);
    5972:	4b19      	ldr	r3, [pc, #100]	; (59d8 <dhcp_rebind.isra.0+0x90>)
    5974:	4798      	blx	r3
		pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
    5976:	8b21      	ldrh	r1, [r4, #24]
    5978:	6920      	ldr	r0, [r4, #16]
    597a:	4b18      	ldr	r3, [pc, #96]	; (59dc <dhcp_rebind.isra.0+0x94>)
    597c:	31f0      	adds	r1, #240	; 0xf0
    597e:	b289      	uxth	r1, r1
    5980:	4798      	blx	r3
		udp_sendto_if(dhcp->pcb, dhcp->p_out, IP_ADDR_BROADCAST, DHCP_SERVER_PORT, netif);
    5982:	9500      	str	r5, [sp, #0]
    5984:	2343      	movs	r3, #67	; 0x43
    5986:	4a16      	ldr	r2, [pc, #88]	; (59e0 <dhcp_rebind.isra.0+0x98>)
    5988:	6921      	ldr	r1, [r4, #16]
    598a:	6860      	ldr	r0, [r4, #4]
    598c:	4d15      	ldr	r5, [pc, #84]	; (59e4 <dhcp_rebind.isra.0+0x9c>)
    598e:	47a8      	blx	r5
		dhcp_delete_msg(dhcp);
    5990:	4b15      	ldr	r3, [pc, #84]	; (59e8 <dhcp_rebind.isra.0+0xa0>)
    5992:	4620      	mov	r0, r4
    5994:	4798      	blx	r3
	dhcp->tries++;
    5996:	7b63      	ldrb	r3, [r4, #13]
    5998:	3301      	adds	r3, #1
    599a:	b2db      	uxtb	r3, r3
	msecs                 = dhcp->tries < 10 ? dhcp->tries * 1000 : 10 * 1000;
    599c:	2b09      	cmp	r3, #9
    599e:	bf98      	it	ls
    59a0:	ebc3 1243 	rsbls	r2, r3, r3, lsl #5
	dhcp->tries++;
    59a4:	7363      	strb	r3, [r4, #13]
	msecs                 = dhcp->tries < 10 ? dhcp->tries * 1000 : 10 * 1000;
    59a6:	bf9d      	ittte	ls
    59a8:	eb03 0382 	addls.w	r3, r3, r2, lsl #2
    59ac:	00db      	lslls	r3, r3, #3
    59ae:	b29b      	uxthls	r3, r3
    59b0:	f242 7310 	movwhi	r3, #10000	; 0x2710
	dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
    59b4:	f44f 72fa 	mov.w	r2, #500	; 0x1f4
    59b8:	f203 13f3 	addw	r3, r3, #499	; 0x1f3
    59bc:	b29b      	uxth	r3, r3
    59be:	fbb3 f3f2 	udiv	r3, r3, r2
    59c2:	8363      	strh	r3, [r4, #26]
}
    59c4:	b003      	add	sp, #12
    59c6:	bd30      	pop	{r4, r5, pc}
    59c8:	000054a5 	.word	0x000054a5
    59cc:	00005691 	.word	0x00005691
    59d0:	000054b5 	.word	0x000054b5
    59d4:	000054e3 	.word	0x000054e3
    59d8:	00005537 	.word	0x00005537
    59dc:	00003249 	.word	0x00003249
    59e0:	0000cc8c 	.word	0x0000cc8c
    59e4:	00004699 	.word	0x00004699
    59e8:	00005565 	.word	0x00005565

000059ec <dhcp_select.isra.0>:
static err_t dhcp_select(struct netif *netif)
    59ec:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
	struct dhcp *dhcp = netif->dhcp;
    59f0:	6a44      	ldr	r4, [r0, #36]	; 0x24
	dhcp_set_state(dhcp, DHCP_REQUESTING);
    59f2:	4b2e      	ldr	r3, [pc, #184]	; (5aac <dhcp_select.isra.0+0xc0>)
static err_t dhcp_select(struct netif *netif)
    59f4:	4605      	mov	r5, r0
	dhcp_set_state(dhcp, DHCP_REQUESTING);
    59f6:	2101      	movs	r1, #1
    59f8:	4620      	mov	r0, r4
    59fa:	4798      	blx	r3
	result = dhcp_create_msg(netif, dhcp, DHCP_REQUEST);
    59fc:	2203      	movs	r2, #3
    59fe:	4b2c      	ldr	r3, [pc, #176]	; (5ab0 <dhcp_select.isra.0+0xc4>)
    5a00:	4621      	mov	r1, r4
    5a02:	4628      	mov	r0, r5
    5a04:	4798      	blx	r3
	if (result == ERR_OK) {
    5a06:	2800      	cmp	r0, #0
    5a08:	d138      	bne.n	5a7c <dhcp_select.isra.0+0x90>
		dhcp_option(dhcp, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
    5a0a:	4e2a      	ldr	r6, [pc, #168]	; (5ab4 <dhcp_select.isra.0+0xc8>)
		dhcp_option_long(dhcp, ntohl(ip4_addr_get_u32(&dhcp->offered_ip_addr)));
    5a0c:	f8df 80c8 	ldr.w	r8, [pc, #200]	; 5ad8 <dhcp_select.isra.0+0xec>
    5a10:	4f29      	ldr	r7, [pc, #164]	; (5ab8 <dhcp_select.isra.0+0xcc>)
		dhcp_option(dhcp, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
    5a12:	4620      	mov	r0, r4
    5a14:	2202      	movs	r2, #2
    5a16:	2139      	movs	r1, #57	; 0x39
    5a18:	47b0      	blx	r6
		dhcp_option_short(dhcp, DHCP_MAX_MSG_LEN(netif));
    5a1a:	4b28      	ldr	r3, [pc, #160]	; (5abc <dhcp_select.isra.0+0xd0>)
    5a1c:	8d29      	ldrh	r1, [r5, #40]	; 0x28
    5a1e:	4798      	blx	r3
		dhcp_option(dhcp, DHCP_OPTION_REQUESTED_IP, 4);
    5a20:	2204      	movs	r2, #4
    5a22:	2132      	movs	r1, #50	; 0x32
    5a24:	47b0      	blx	r6
		dhcp_option_long(dhcp, ntohl(ip4_addr_get_u32(&dhcp->offered_ip_addr)));
    5a26:	6a60      	ldr	r0, [r4, #36]	; 0x24
    5a28:	47c0      	blx	r8
    5a2a:	4601      	mov	r1, r0
    5a2c:	4620      	mov	r0, r4
    5a2e:	47b8      	blx	r7
		dhcp_option(dhcp, DHCP_OPTION_SERVER_ID, 4);
    5a30:	2204      	movs	r2, #4
    5a32:	2136      	movs	r1, #54	; 0x36
    5a34:	47b0      	blx	r6
		dhcp_option_long(dhcp, ntohl(ip4_addr_get_u32(&dhcp->server_ip_addr)));
    5a36:	6a20      	ldr	r0, [r4, #32]
    5a38:	47c0      	blx	r8
    5a3a:	4601      	mov	r1, r0
    5a3c:	4620      	mov	r0, r4
    5a3e:	47b8      	blx	r7
		dhcp_option(dhcp, DHCP_OPTION_PARAMETER_REQUEST_LIST, 4 /*num options*/);
    5a40:	2204      	movs	r2, #4
    5a42:	2137      	movs	r1, #55	; 0x37
    5a44:	47b0      	blx	r6
		dhcp_option_byte(dhcp, DHCP_OPTION_SUBNET_MASK);
    5a46:	4e1e      	ldr	r6, [pc, #120]	; (5ac0 <dhcp_select.isra.0+0xd4>)
    5a48:	2101      	movs	r1, #1
    5a4a:	47b0      	blx	r6
		dhcp_option_byte(dhcp, DHCP_OPTION_ROUTER);
    5a4c:	2103      	movs	r1, #3
    5a4e:	47b0      	blx	r6
		dhcp_option_byte(dhcp, DHCP_OPTION_BROADCAST);
    5a50:	211c      	movs	r1, #28
    5a52:	47b0      	blx	r6
		dhcp_option_byte(dhcp, DHCP_OPTION_DNS_SERVER);
    5a54:	2106      	movs	r1, #6
    5a56:	47b0      	blx	r6
		dhcp_option_trailer(dhcp);
    5a58:	4b1a      	ldr	r3, [pc, #104]	; (5ac4 <dhcp_select.isra.0+0xd8>)
    5a5a:	4798      	blx	r3
		pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
    5a5c:	8b21      	ldrh	r1, [r4, #24]
    5a5e:	6920      	ldr	r0, [r4, #16]
    5a60:	4b19      	ldr	r3, [pc, #100]	; (5ac8 <dhcp_select.isra.0+0xdc>)
    5a62:	31f0      	adds	r1, #240	; 0xf0
    5a64:	b289      	uxth	r1, r1
    5a66:	4798      	blx	r3
		udp_sendto_if(dhcp->pcb, dhcp->p_out, IP_ADDR_BROADCAST, DHCP_SERVER_PORT, netif);
    5a68:	9500      	str	r5, [sp, #0]
    5a6a:	2343      	movs	r3, #67	; 0x43
    5a6c:	4a17      	ldr	r2, [pc, #92]	; (5acc <dhcp_select.isra.0+0xe0>)
    5a6e:	6921      	ldr	r1, [r4, #16]
    5a70:	6860      	ldr	r0, [r4, #4]
    5a72:	4d17      	ldr	r5, [pc, #92]	; (5ad0 <dhcp_select.isra.0+0xe4>)
    5a74:	47a8      	blx	r5
		dhcp_delete_msg(dhcp);
    5a76:	4b17      	ldr	r3, [pc, #92]	; (5ad4 <dhcp_select.isra.0+0xe8>)
    5a78:	4620      	mov	r0, r4
    5a7a:	4798      	blx	r3
	dhcp->tries++;
    5a7c:	7b63      	ldrb	r3, [r4, #13]
    5a7e:	3301      	adds	r3, #1
    5a80:	b2da      	uxtb	r2, r3
	msecs                 = (dhcp->tries < 6 ? 1 << dhcp->tries : 60) * 1000;
    5a82:	2a05      	cmp	r2, #5
    5a84:	bf9d      	ittte	ls
    5a86:	f44f 737a 	movls.w	r3, #1000	; 0x3e8
    5a8a:	4093      	lslls	r3, r2
    5a8c:	b29b      	uxthls	r3, r3
    5a8e:	f64e 2360 	movwhi	r3, #60000	; 0xea60
	dhcp->tries++;
    5a92:	7362      	strb	r2, [r4, #13]
	dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
    5a94:	f203 13f3 	addw	r3, r3, #499	; 0x1f3
    5a98:	f44f 72fa 	mov.w	r2, #500	; 0x1f4
    5a9c:	b29b      	uxth	r3, r3
    5a9e:	fbb3 f3f2 	udiv	r3, r3, r2
    5aa2:	8363      	strh	r3, [r4, #26]
}
    5aa4:	b002      	add	sp, #8
    5aa6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    5aaa:	bf00      	nop
    5aac:	000054a5 	.word	0x000054a5
    5ab0:	00005691 	.word	0x00005691
    5ab4:	000054b5 	.word	0x000054b5
    5ab8:	00005501 	.word	0x00005501
    5abc:	000054e3 	.word	0x000054e3
    5ac0:	000054d1 	.word	0x000054d1
    5ac4:	00005537 	.word	0x00005537
    5ac8:	00003249 	.word	0x00003249
    5acc:	0000cc8c 	.word	0x0000cc8c
    5ad0:	00004699 	.word	0x00004699
    5ad4:	00005565 	.word	0x00005565
    5ad8:	00000d71 	.word	0x00000d71

00005adc <dhcp_recv>:
{
    5adc:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	if (p->len < DHCP_MIN_REPLY_LEN) {
    5ae0:	8953      	ldrh	r3, [r2, #10]
	struct dhcp *    dhcp      = netif->dhcp;
    5ae2:	f8d0 b024 	ldr.w	fp, [r0, #36]	; 0x24
	if (p->len < DHCP_MIN_REPLY_LEN) {
    5ae6:	2b2b      	cmp	r3, #43	; 0x2b
{
    5ae8:	b089      	sub	sp, #36	; 0x24
    5aea:	4606      	mov	r6, r0
    5aec:	4692      	mov	sl, r2
	if (p->len < DHCP_MIN_REPLY_LEN) {
    5aee:	d939      	bls.n	5b64 <dhcp_recv+0x88>
	struct dhcp_msg *reply_msg = (struct dhcp_msg *)p->payload;
    5af0:	6853      	ldr	r3, [r2, #4]
	if (reply_msg->op != DHCP_BOOTREPLY) {
    5af2:	781a      	ldrb	r2, [r3, #0]
    5af4:	2a02      	cmp	r2, #2
    5af6:	d135      	bne.n	5b64 <dhcp_recv+0x88>
	for (i = 0; i < netif->hwaddr_len; i++) {
    5af8:	f890 502a 	ldrb.w	r5, [r0, #42]	; 0x2a
    5afc:	f103 011c 	add.w	r1, r3, #28
    5b00:	302b      	adds	r0, #43	; 0x2b
    5b02:	2200      	movs	r2, #0
    5b04:	b2d4      	uxtb	r4, r2
    5b06:	42a5      	cmp	r5, r4
    5b08:	d824      	bhi.n	5b54 <dhcp_recv+0x78>
	if (ntohl(reply_msg->xid) != dhcp->xid) {
    5b0a:	6858      	ldr	r0, [r3, #4]
    5b0c:	4b97      	ldr	r3, [pc, #604]	; (5d6c <dhcp_recv+0x290>)
    5b0e:	4798      	blx	r3
    5b10:	f8db 3000 	ldr.w	r3, [fp]
    5b14:	4298      	cmp	r0, r3
    5b16:	d125      	bne.n	5b64 <dhcp_recv+0x88>
	dhcp_clear_all_options(dhcp);
    5b18:	4b95      	ldr	r3, [pc, #596]	; (5d70 <dhcp_recv+0x294>)
    5b1a:	f04f 0800 	mov.w	r8, #0
    5b1e:	f8c3 8004 	str.w	r8, [r3, #4]
    5b22:	f8a3 8008 	strh.w	r8, [r3, #8]
    5b26:	f8c3 8000 	str.w	r8, [r3]
	if (p->len < DHCP_SNAME_OFS) {
    5b2a:	f8ba 300a 	ldrh.w	r3, [sl, #10]
    5b2e:	2b2b      	cmp	r3, #43	; 0x2b
    5b30:	d918      	bls.n	5b64 <dhcp_recv+0x88>
	dhcp->msg_in = (struct dhcp_msg *)p->payload;
    5b32:	f8da 3004 	ldr.w	r3, [sl, #4]
	options_idx_max = p->tot_len;
    5b36:	f8ba 9008 	ldrh.w	r9, [sl, #8]
	dhcp->msg_in = (struct dhcp_msg *)p->payload;
    5b3a:	f8cb 3008 	str.w	r3, [fp, #8]
	options_idx = DHCP_OPTIONS_OFS;
    5b3e:	23f0      	movs	r3, #240	; 0xf0
    5b40:	f8cd a004 	str.w	sl, [sp, #4]
	while ((q != NULL) && (options_idx >= q->len)) {
    5b44:	9a01      	ldr	r2, [sp, #4]
    5b46:	8952      	ldrh	r2, [r2, #10]
    5b48:	429a      	cmp	r2, r3
    5b4a:	d914      	bls.n	5b76 <dhcp_recv+0x9a>
	options    = (u8_t *)q->payload;
    5b4c:	9a01      	ldr	r2, [sp, #4]
    5b4e:	6852      	ldr	r2, [r2, #4]
    5b50:	9203      	str	r2, [sp, #12]
	while ((q != NULL) && (options[offset] != DHCP_OPTION_END) && (offset < offset_max)) {
    5b52:	e123      	b.n	5d9c <dhcp_recv+0x2c0>
		if (netif->hwaddr[i] != reply_msg->chaddr[i]) {
    5b54:	f810 7b01 	ldrb.w	r7, [r0], #1
    5b58:	f811 4b01 	ldrb.w	r4, [r1], #1
    5b5c:	42a7      	cmp	r7, r4
    5b5e:	f102 0201 	add.w	r2, r2, #1
    5b62:	d0cf      	beq.n	5b04 <dhcp_recv+0x28>
	dhcp->msg_in = NULL;
    5b64:	2300      	movs	r3, #0
    5b66:	f8cb 3008 	str.w	r3, [fp, #8]
	pbuf_free(p);
    5b6a:	4b82      	ldr	r3, [pc, #520]	; (5d74 <dhcp_recv+0x298>)
    5b6c:	4650      	mov	r0, sl
}
    5b6e:	b009      	add	sp, #36	; 0x24
    5b70:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	pbuf_free(p);
    5b74:	4718      	bx	r3
		options_idx -= q->len;
    5b76:	1a9b      	subs	r3, r3, r2
		options_idx_max -= q->len;
    5b78:	eba9 0902 	sub.w	r9, r9, r2
		q = q->next;
    5b7c:	9a01      	ldr	r2, [sp, #4]
    5b7e:	6812      	ldr	r2, [r2, #0]
    5b80:	9201      	str	r2, [sp, #4]
		options_idx -= q->len;
    5b82:	b29b      	uxth	r3, r3
		options_idx_max -= q->len;
    5b84:	fa1f f989 	uxth.w	r9, r9
	while ((q != NULL) && (options_idx >= q->len)) {
    5b88:	2a00      	cmp	r2, #0
    5b8a:	d1db      	bne.n	5b44 <dhcp_recv+0x68>
    5b8c:	e7ea      	b.n	5b64 <dhcp_recv+0x88>
			len = (q->next != NULL ? ((u8_t *)q->next->payload)[0] : 0);
    5b8e:	9a01      	ldr	r2, [sp, #4]
    5b90:	6812      	ldr	r2, [r2, #0]
    5b92:	2a00      	cmp	r2, #0
    5b94:	f000 8111 	beq.w	5dba <dhcp_recv+0x2de>
    5b98:	6852      	ldr	r2, [r2, #4]
    5b9a:	7812      	ldrb	r2, [r2, #0]
    5b9c:	e10d      	b.n	5dba <dhcp_recv+0x2de>
		switch (op) {
    5b9e:	2c08      	cmp	r4, #8
    5ba0:	d80a      	bhi.n	5bb8 <dhcp_recv+0xdc>
    5ba2:	e8df f004 	tbb	[pc, r4]
    5ba6:	4b48      	.short	0x4b48
    5ba8:	0909514e 	.word	0x0909514e
    5bac:	5409      	.short	0x5409
    5bae:	57          	.byte	0x57
    5baf:	00          	.byte	0x00
    5bb0:	3c33      	subs	r4, #51	; 0x33
    5bb2:	b2e1      	uxtb	r1, r4
    5bb4:	2908      	cmp	r1, #8
    5bb6:	d9f2      	bls.n	5b9e <dhcp_recv+0xc2>
    5bb8:	4619      	mov	r1, r3
    5bba:	f04f 35ff 	mov.w	r5, #4294967295	; 0xffffffff
    5bbe:	2400      	movs	r4, #0
    5bc0:	e004      	b.n	5bcc <dhcp_recv+0xf0>
			offset--;
    5bc2:	1e59      	subs	r1, r3, #1
    5bc4:	b289      	uxth	r1, r1
			decode_len = len = 0;
    5bc6:	4622      	mov	r2, r4
		int   decode_idx = -1;
    5bc8:	f04f 35ff 	mov.w	r5, #4294967295	; 0xffffffff
		offset += len + 2;
    5bcc:	3102      	adds	r1, #2
    5bce:	fa12 f281 	uxtah	r2, r2, r1
    5bd2:	b292      	uxth	r2, r2
    5bd4:	9202      	str	r2, [sp, #8]
		if (decode_len > 0) {
    5bd6:	2c00      	cmp	r4, #0
    5bd8:	d07c      	beq.n	5cd4 <dhcp_recv+0x1f8>
			u32_t value = 0;
    5bda:	2200      	movs	r2, #0
    5bdc:	9207      	str	r2, [sp, #28]
    5bde:	4a64      	ldr	r2, [pc, #400]	; (5d70 <dhcp_recv+0x294>)
		u16_t val_offset = offset + 2;
    5be0:	3302      	adds	r3, #2
    5be2:	442a      	add	r2, r5
    5be4:	b29b      	uxth	r3, r3
			u32_t value = 0;
    5be6:	9204      	str	r2, [sp, #16]
			if (!dhcp_option_given(dhcp, decode_idx)) {
    5be8:	9904      	ldr	r1, [sp, #16]
    5bea:	f811 2b01 	ldrb.w	r2, [r1], #1
    5bee:	9104      	str	r1, [sp, #16]
    5bf0:	2a00      	cmp	r2, #0
    5bf2:	d16f      	bne.n	5cd4 <dhcp_recv+0x1f8>
				pbuf_copy_partial(q, &value, copy_len, val_offset);
    5bf4:	2c04      	cmp	r4, #4
    5bf6:	4622      	mov	r2, r4
    5bf8:	9801      	ldr	r0, [sp, #4]
    5bfa:	4f5f      	ldr	r7, [pc, #380]	; (5d78 <dhcp_recv+0x29c>)
    5bfc:	9305      	str	r3, [sp, #20]
    5bfe:	bf28      	it	cs
    5c00:	2204      	movcs	r2, #4
    5c02:	a907      	add	r1, sp, #28
    5c04:	47b8      	blx	r7
				if (decode_len > 4) {
    5c06:	2c04      	cmp	r4, #4
    5c08:	d958      	bls.n	5cbc <dhcp_recv+0x1e0>
					LWIP_ERROR("decode_len % 4 == 0", decode_len % 4 == 0, return ERR_VAL;);
    5c0a:	f014 0f03 	tst.w	r4, #3
    5c0e:	9b05      	ldr	r3, [sp, #20]
    5c10:	d042      	beq.n	5c98 <dhcp_recv+0x1bc>
    5c12:	e7fe      	b.n	5c12 <dhcp_recv+0x136>
			LWIP_ERROR("len == 4", len == 4, return ERR_VAL;);
    5c14:	2a04      	cmp	r2, #4
    5c16:	d020      	beq.n	5c5a <dhcp_recv+0x17e>
    5c18:	e7fe      	b.n	5c18 <dhcp_recv+0x13c>
			LWIP_ERROR("len >= decode_len", len >= decode_len, return ERR_VAL;);
    5c1a:	2a03      	cmp	r2, #3
    5c1c:	d821      	bhi.n	5c62 <dhcp_recv+0x186>
    5c1e:	e7fe      	b.n	5c1e <dhcp_recv+0x142>
			LWIP_ERROR("len % 4 == 0", len % 4 == 0, return ERR_VAL;);
    5c20:	0791      	lsls	r1, r2, #30
    5c22:	d000      	beq.n	5c26 <dhcp_recv+0x14a>
    5c24:	e7fe      	b.n	5c24 <dhcp_recv+0x148>
			decode_len = LWIP_MIN(len, 4 * DNS_MAX_SERVERS);
    5c26:	2a08      	cmp	r2, #8
    5c28:	4614      	mov	r4, r2
    5c2a:	bf28      	it	cs
    5c2c:	2408      	movcs	r4, #8
    5c2e:	b2e4      	uxtb	r4, r4
			LWIP_ERROR("len >= decode_len", len >= decode_len, return ERR_VAL;);
    5c30:	42a2      	cmp	r2, r4
    5c32:	d21a      	bcs.n	5c6a <dhcp_recv+0x18e>
    5c34:	e7fe      	b.n	5c34 <dhcp_recv+0x158>
			LWIP_ERROR("len == 4", len == 4, return ERR_VAL;);
    5c36:	2a04      	cmp	r2, #4
    5c38:	d01a      	beq.n	5c70 <dhcp_recv+0x194>
    5c3a:	e7fe      	b.n	5c3a <dhcp_recv+0x15e>
			LWIP_ERROR("len == 1", len == 1, return ERR_VAL;);
    5c3c:	2a01      	cmp	r2, #1
    5c3e:	d01b      	beq.n	5c78 <dhcp_recv+0x19c>
    5c40:	e7fe      	b.n	5c40 <dhcp_recv+0x164>
			LWIP_ERROR("len == 1", len == 1, return ERR_VAL;);
    5c42:	2a01      	cmp	r2, #1
    5c44:	d020      	beq.n	5c88 <dhcp_recv+0x1ac>
    5c46:	e7fe      	b.n	5c46 <dhcp_recv+0x16a>
			LWIP_ERROR("len == 4", len == 4, return ERR_VAL;);
    5c48:	2a04      	cmp	r2, #4
    5c4a:	d019      	beq.n	5c80 <dhcp_recv+0x1a4>
    5c4c:	e7fe      	b.n	5c4c <dhcp_recv+0x170>
			LWIP_ERROR("len == 4", len == 4, return ERR_VAL;);
    5c4e:	2a04      	cmp	r2, #4
    5c50:	d01a      	beq.n	5c88 <dhcp_recv+0x1ac>
    5c52:	e7fe      	b.n	5c52 <dhcp_recv+0x176>
			LWIP_ERROR("len == 4", len == 4, return ERR_VAL;);
    5c54:	2a04      	cmp	r2, #4
    5c56:	d01b      	beq.n	5c90 <dhcp_recv+0x1b4>
    5c58:	e7fe      	b.n	5c58 <dhcp_recv+0x17c>
    5c5a:	4614      	mov	r4, r2
    5c5c:	4619      	mov	r1, r3
			decode_idx = DHCP_OPTION_IDX_SUBNET_MASK;
    5c5e:	2506      	movs	r5, #6
    5c60:	e7b4      	b.n	5bcc <dhcp_recv+0xf0>
    5c62:	4619      	mov	r1, r3
			decode_idx = DHCP_OPTION_IDX_ROUTER;
    5c64:	2507      	movs	r5, #7
			decode_len = 4; /* only copy the first given router */
    5c66:	2404      	movs	r4, #4
    5c68:	e7b0      	b.n	5bcc <dhcp_recv+0xf0>
    5c6a:	4619      	mov	r1, r3
			decode_idx = DHCP_OPTION_IDX_DNS_SERVER;
    5c6c:	2508      	movs	r5, #8
    5c6e:	e7ad      	b.n	5bcc <dhcp_recv+0xf0>
    5c70:	4614      	mov	r4, r2
    5c72:	4619      	mov	r1, r3
			decode_idx = DHCP_OPTION_IDX_LEASE_TIME;
    5c74:	2503      	movs	r5, #3
    5c76:	e7a9      	b.n	5bcc <dhcp_recv+0xf0>
    5c78:	4614      	mov	r4, r2
    5c7a:	4619      	mov	r1, r3
			decode_idx = DHCP_OPTION_IDX_OVERLOAD;
    5c7c:	2500      	movs	r5, #0
    5c7e:	e7a5      	b.n	5bcc <dhcp_recv+0xf0>
    5c80:	4614      	mov	r4, r2
    5c82:	4619      	mov	r1, r3
			decode_idx = DHCP_OPTION_IDX_SERVER_ID;
    5c84:	2502      	movs	r5, #2
    5c86:	e7a1      	b.n	5bcc <dhcp_recv+0xf0>
    5c88:	4614      	mov	r4, r2
    5c8a:	4619      	mov	r1, r3
			decode_idx = DHCP_OPTION_IDX_T1;
    5c8c:	4615      	mov	r5, r2
    5c8e:	e79d      	b.n	5bcc <dhcp_recv+0xf0>
    5c90:	4614      	mov	r4, r2
    5c92:	4619      	mov	r1, r3
			decode_idx = DHCP_OPTION_IDX_T2;
    5c94:	2505      	movs	r5, #5
    5c96:	e799      	b.n	5bcc <dhcp_recv+0xf0>
    5c98:	9305      	str	r3, [sp, #20]
					dhcp_got_option(dhcp, decode_idx);
    5c9a:	9b04      	ldr	r3, [sp, #16]
					dhcp_set_option_value(dhcp, decode_idx, htonl(value));
    5c9c:	9807      	ldr	r0, [sp, #28]
					dhcp_got_option(dhcp, decode_idx);
    5c9e:	2201      	movs	r2, #1
    5ca0:	f803 2c01 	strb.w	r2, [r3, #-1]
					dhcp_set_option_value(dhcp, decode_idx, htonl(value));
    5ca4:	4b35      	ldr	r3, [pc, #212]	; (5d7c <dhcp_recv+0x2a0>)
    5ca6:	4798      	blx	r3
    5ca8:	4b35      	ldr	r3, [pc, #212]	; (5d80 <dhcp_recv+0x2a4>)
    5caa:	f843 0025 	str.w	r0, [r3, r5, lsl #2]
					val_offset += 4;
    5cae:	9b05      	ldr	r3, [sp, #20]
					decode_len -= 4;
    5cb0:	3c04      	subs	r4, #4
					val_offset += 4;
    5cb2:	3304      	adds	r3, #4
					decode_len -= 4;
    5cb4:	b2e4      	uxtb	r4, r4
					val_offset += 4;
    5cb6:	b29b      	uxth	r3, r3
					decode_idx++;
    5cb8:	3501      	adds	r5, #1
					goto decode_next;
    5cba:	e795      	b.n	5be8 <dhcp_recv+0x10c>
				} else if (decode_len == 4) {
    5cbc:	d152      	bne.n	5d64 <dhcp_recv+0x288>
					value = ntohl(value);
    5cbe:	9807      	ldr	r0, [sp, #28]
    5cc0:	4b2a      	ldr	r3, [pc, #168]	; (5d6c <dhcp_recv+0x290>)
    5cc2:	4798      	blx	r3
    5cc4:	9007      	str	r0, [sp, #28]
				dhcp_got_option(dhcp, decode_idx);
    5cc6:	4a2a      	ldr	r2, [pc, #168]	; (5d70 <dhcp_recv+0x294>)
    5cc8:	2301      	movs	r3, #1
    5cca:	5553      	strb	r3, [r2, r5]
				dhcp_set_option_value(dhcp, decode_idx, value);
    5ccc:	eb02 0585 	add.w	r5, r2, r5, lsl #2
    5cd0:	9b07      	ldr	r3, [sp, #28]
    5cd2:	60eb      	str	r3, [r5, #12]
		if (offset >= q->len) {
    5cd4:	9b01      	ldr	r3, [sp, #4]
    5cd6:	9a02      	ldr	r2, [sp, #8]
    5cd8:	895b      	ldrh	r3, [r3, #10]
    5cda:	429a      	cmp	r2, r3
    5cdc:	d35d      	bcc.n	5d9a <dhcp_recv+0x2be>
			offset -= q->len;
    5cde:	1ad2      	subs	r2, r2, r3
			offset_max -= q->len;
    5ce0:	eba9 0903 	sub.w	r9, r9, r3
			offset -= q->len;
    5ce4:	b292      	uxth	r2, r2
			offset_max -= q->len;
    5ce6:	fa1f f989 	uxth.w	r9, r9
			if ((offset < offset_max) && offset_max) {
    5cea:	454a      	cmp	r2, r9
			offset -= q->len;
    5cec:	9202      	str	r2, [sp, #8]
			if ((offset < offset_max) && offset_max) {
    5cee:	d34f      	bcc.n	5d90 <dhcp_recv+0x2b4>
	if (dhcp_option_given(dhcp, DHCP_OPTION_IDX_OVERLOAD)) {
    5cf0:	4c1f      	ldr	r4, [pc, #124]	; (5d70 <dhcp_recv+0x294>)
    5cf2:	7823      	ldrb	r3, [r4, #0]
    5cf4:	2b00      	cmp	r3, #0
    5cf6:	d177      	bne.n	5de8 <dhcp_recv+0x30c>
	} else if (parse_sname_as_options) {
    5cf8:	f1b8 0f00 	cmp.w	r8, #0
    5cfc:	d17b      	bne.n	5df6 <dhcp_recv+0x31a>
	if (!dhcp_option_given(dhcp, DHCP_OPTION_IDX_MSG_TYPE)) {
    5cfe:	7863      	ldrb	r3, [r4, #1]
    5d00:	2b00      	cmp	r3, #0
    5d02:	f43f af2f 	beq.w	5b64 <dhcp_recv+0x88>
	msg_type = (u8_t)dhcp_get_option_value(dhcp, DHCP_OPTION_IDX_MSG_TYPE);
    5d06:	7c23      	ldrb	r3, [r4, #16]
	if (msg_type == DHCP_ACK) {
    5d08:	2b05      	cmp	r3, #5
    5d0a:	f040 808f 	bne.w	5e2c <dhcp_recv+0x350>
		if (dhcp->state == DHCP_REQUESTING) {
    5d0e:	f89b 300c 	ldrb.w	r3, [fp, #12]
    5d12:	2b01      	cmp	r3, #1
    5d14:	f040 8083 	bne.w	5e1e <dhcp_recv+0x342>
			dhcp_handle_ack(netif);
    5d18:	6a75      	ldr	r5, [r6, #36]	; 0x24
	if (dhcp_option_given(dhcp, DHCP_OPTION_IDX_LEASE_TIME)) {
    5d1a:	78e3      	ldrb	r3, [r4, #3]
	ip_addr_set_zero(&dhcp->offered_gw_addr);
    5d1c:	e9c5 880a 	strd	r8, r8, [r5, #40]	; 0x28
	if (dhcp_option_given(dhcp, DHCP_OPTION_IDX_LEASE_TIME)) {
    5d20:	b10b      	cbz	r3, 5d26 <dhcp_recv+0x24a>
		dhcp->offered_t0_lease = dhcp_get_option_value(dhcp, DHCP_OPTION_IDX_LEASE_TIME);
    5d22:	69a3      	ldr	r3, [r4, #24]
    5d24:	632b      	str	r3, [r5, #48]	; 0x30
	if (dhcp_option_given(dhcp, DHCP_OPTION_IDX_T1)) {
    5d26:	7923      	ldrb	r3, [r4, #4]
    5d28:	2b00      	cmp	r3, #0
    5d2a:	d073      	beq.n	5e14 <dhcp_recv+0x338>
		dhcp->offered_t1_renew = dhcp_get_option_value(dhcp, DHCP_OPTION_IDX_T1);
    5d2c:	69e3      	ldr	r3, [r4, #28]
    5d2e:	636b      	str	r3, [r5, #52]	; 0x34
	if (dhcp_option_given(dhcp, DHCP_OPTION_IDX_T2)) {
    5d30:	7963      	ldrb	r3, [r4, #5]
    5d32:	2b00      	cmp	r3, #0
    5d34:	d071      	beq.n	5e1a <dhcp_recv+0x33e>
		dhcp->offered_t2_rebind = dhcp_get_option_value(dhcp, DHCP_OPTION_IDX_T2);
    5d36:	6a23      	ldr	r3, [r4, #32]
    5d38:	63ab      	str	r3, [r5, #56]	; 0x38
	ip_addr_copy(dhcp->offered_ip_addr, dhcp->msg_in->yiaddr);
    5d3a:	68ab      	ldr	r3, [r5, #8]
    5d3c:	691b      	ldr	r3, [r3, #16]
    5d3e:	626b      	str	r3, [r5, #36]	; 0x24
	if (dhcp_option_given(dhcp, DHCP_OPTION_IDX_SUBNET_MASK)) {
    5d40:	79a3      	ldrb	r3, [r4, #6]
    5d42:	b123      	cbz	r3, 5d4e <dhcp_recv+0x272>
		ip4_addr_set_u32(&dhcp->offered_sn_mask, htonl(dhcp_get_option_value(dhcp, DHCP_OPTION_IDX_SUBNET_MASK)));
    5d44:	4b0d      	ldr	r3, [pc, #52]	; (5d7c <dhcp_recv+0x2a0>)
    5d46:	6a60      	ldr	r0, [r4, #36]	; 0x24
    5d48:	4798      	blx	r3
		dhcp->subnet_mask_given = 1;
    5d4a:	2301      	movs	r3, #1
		ip4_addr_set_u32(&dhcp->offered_sn_mask, htonl(dhcp_get_option_value(dhcp, DHCP_OPTION_IDX_SUBNET_MASK)));
    5d4c:	62a8      	str	r0, [r5, #40]	; 0x28
		dhcp->subnet_mask_given = 0;
    5d4e:	73ab      	strb	r3, [r5, #14]
	if (dhcp_option_given(dhcp, DHCP_OPTION_IDX_ROUTER)) {
    5d50:	79e3      	ldrb	r3, [r4, #7]
    5d52:	b11b      	cbz	r3, 5d5c <dhcp_recv+0x280>
		ip4_addr_set_u32(&dhcp->offered_gw_addr, htonl(dhcp_get_option_value(dhcp, DHCP_OPTION_IDX_ROUTER)));
    5d54:	6aa0      	ldr	r0, [r4, #40]	; 0x28
    5d56:	4b09      	ldr	r3, [pc, #36]	; (5d7c <dhcp_recv+0x2a0>)
    5d58:	4798      	blx	r3
    5d5a:	62e8      	str	r0, [r5, #44]	; 0x2c
			dhcp_check(netif);
    5d5c:	4b09      	ldr	r3, [pc, #36]	; (5d84 <dhcp_recv+0x2a8>)
    5d5e:	4630      	mov	r0, r6
		dhcp_select(netif);
    5d60:	4798      	blx	r3
    5d62:	e6ff      	b.n	5b64 <dhcp_recv+0x88>
					LWIP_ERROR("invalid decode_len", decode_len == 1, return ERR_VAL;);
    5d64:	2c01      	cmp	r4, #1
    5d66:	d00f      	beq.n	5d88 <dhcp_recv+0x2ac>
    5d68:	e7fe      	b.n	5d68 <dhcp_recv+0x28c>
    5d6a:	bf00      	nop
    5d6c:	00000d71 	.word	0x00000d71
    5d70:	200110d0 	.word	0x200110d0
    5d74:	000030e1 	.word	0x000030e1
    5d78:	00003381 	.word	0x00003381
    5d7c:	00000d6d 	.word	0x00000d6d
    5d80:	200110dc 	.word	0x200110dc
    5d84:	00005581 	.word	0x00005581
					value = ((u8_t *)&value)[0];
    5d88:	f89d 301c 	ldrb.w	r3, [sp, #28]
    5d8c:	9307      	str	r3, [sp, #28]
    5d8e:	e79a      	b.n	5cc6 <dhcp_recv+0x1ea>
				q = q->next;
    5d90:	9b01      	ldr	r3, [sp, #4]
    5d92:	681b      	ldr	r3, [r3, #0]
    5d94:	9301      	str	r3, [sp, #4]
				options = (u8_t *)q->payload;
    5d96:	685b      	ldr	r3, [r3, #4]
    5d98:	9303      	str	r3, [sp, #12]
			decode_idx = DHCP_OPTION_IDX_T2;
    5d9a:	9b02      	ldr	r3, [sp, #8]
	while ((q != NULL) && (options[offset] != DHCP_OPTION_END) && (offset < offset_max)) {
    5d9c:	9a03      	ldr	r2, [sp, #12]
    5d9e:	5cd4      	ldrb	r4, [r2, r3]
    5da0:	2cff      	cmp	r4, #255	; 0xff
    5da2:	d0a5      	beq.n	5cf0 <dhcp_recv+0x214>
    5da4:	454b      	cmp	r3, r9
    5da6:	d2a3      	bcs.n	5cf0 <dhcp_recv+0x214>
		if (offset + 1 < q->len) {
    5da8:	9901      	ldr	r1, [sp, #4]
    5daa:	8949      	ldrh	r1, [r1, #10]
    5dac:	1c5a      	adds	r2, r3, #1
    5dae:	428a      	cmp	r2, r1
    5db0:	f6bf aeed 	bge.w	5b8e <dhcp_recv+0xb2>
			len = options[offset + 1];
    5db4:	9a03      	ldr	r2, [sp, #12]
    5db6:	441a      	add	r2, r3
    5db8:	7852      	ldrb	r2, [r2, #1]
		switch (op) {
    5dba:	2c06      	cmp	r4, #6
    5dbc:	f63f aef8 	bhi.w	5bb0 <dhcp_recv+0xd4>
    5dc0:	2c06      	cmp	r4, #6
    5dc2:	f63f aef9 	bhi.w	5bb8 <dhcp_recv+0xdc>
    5dc6:	a101      	add	r1, pc, #4	; (adr r1, 5dcc <dhcp_recv+0x2f0>)
    5dc8:	f851 f024 	ldr.w	pc, [r1, r4, lsl #2]
    5dcc:	00005bc3 	.word	0x00005bc3
    5dd0:	00005c15 	.word	0x00005c15
    5dd4:	00005bb9 	.word	0x00005bb9
    5dd8:	00005c1b 	.word	0x00005c1b
    5ddc:	00005bb9 	.word	0x00005bb9
    5de0:	00005bb9 	.word	0x00005bb9
    5de4:	00005c21 	.word	0x00005c21
		u32_t overload = dhcp_get_option_value(dhcp, DHCP_OPTION_IDX_OVERLOAD);
    5de8:	68e3      	ldr	r3, [r4, #12]
		dhcp_clear_option(dhcp, DHCP_OPTION_IDX_OVERLOAD);
    5dea:	2200      	movs	r2, #0
		if (overload == DHCP_OVERLOAD_FILE) {
    5dec:	2b01      	cmp	r3, #1
		dhcp_clear_option(dhcp, DHCP_OPTION_IDX_OVERLOAD);
    5dee:	7022      	strb	r2, [r4, #0]
		if (overload == DHCP_OVERLOAD_FILE) {
    5df0:	d00c      	beq.n	5e0c <dhcp_recv+0x330>
		} else if (overload == DHCP_OVERLOAD_SNAME) {
    5df2:	2b02      	cmp	r3, #2
    5df4:	d105      	bne.n	5e02 <dhcp_recv+0x326>
		parse_sname_as_options = 0;
    5df6:	f04f 0800 	mov.w	r8, #0
		options_idx_max        = DHCP_SNAME_OFS + DHCP_SNAME_LEN;
    5dfa:	f04f 096c 	mov.w	r9, #108	; 0x6c
		options_idx            = DHCP_SNAME_OFS;
    5dfe:	232c      	movs	r3, #44	; 0x2c
    5e00:	e69e      	b.n	5b40 <dhcp_recv+0x64>
		} else if (overload == DHCP_OVERLOAD_SNAME_FILE) {
    5e02:	2b03      	cmp	r3, #3
    5e04:	f47f af78 	bne.w	5cf8 <dhcp_recv+0x21c>
			parse_sname_as_options = 1;
    5e08:	f04f 0801 	mov.w	r8, #1
		options_idx_max       = DHCP_FILE_OFS + DHCP_FILE_LEN;
    5e0c:	f04f 09ec 	mov.w	r9, #236	; 0xec
		options_idx           = DHCP_FILE_OFS;
    5e10:	236c      	movs	r3, #108	; 0x6c
    5e12:	e695      	b.n	5b40 <dhcp_recv+0x64>
		dhcp->offered_t1_renew = dhcp->offered_t0_lease / 2;
    5e14:	6b2b      	ldr	r3, [r5, #48]	; 0x30
    5e16:	085b      	lsrs	r3, r3, #1
    5e18:	e789      	b.n	5d2e <dhcp_recv+0x252>
		dhcp->offered_t2_rebind = dhcp->offered_t0_lease;
    5e1a:	6b2b      	ldr	r3, [r5, #48]	; 0x30
    5e1c:	e78c      	b.n	5d38 <dhcp_recv+0x25c>
		else if ((dhcp->state == DHCP_REBOOTING) || (dhcp->state == DHCP_REBINDING) || (dhcp->state == DHCP_RENEWING)) {
    5e1e:	3b03      	subs	r3, #3
    5e20:	2b02      	cmp	r3, #2
    5e22:	f63f ae9f 	bhi.w	5b64 <dhcp_recv+0x88>
			dhcp_bind(netif);
    5e26:	4b1f      	ldr	r3, [pc, #124]	; (5ea4 <dhcp_recv+0x3c8>)
    5e28:	4630      	mov	r0, r6
    5e2a:	e799      	b.n	5d60 <dhcp_recv+0x284>
	else if ((msg_type == DHCP_NAK)
    5e2c:	2b06      	cmp	r3, #6
    5e2e:	d11f      	bne.n	5e70 <dhcp_recv+0x394>
	         && ((dhcp->state == DHCP_REBOOTING) || (dhcp->state == DHCP_REQUESTING) || (dhcp->state == DHCP_REBINDING)
    5e30:	f89b 300c 	ldrb.w	r3, [fp, #12]
    5e34:	1eda      	subs	r2, r3, #3
    5e36:	2a02      	cmp	r2, #2
    5e38:	d902      	bls.n	5e40 <dhcp_recv+0x364>
    5e3a:	2b01      	cmp	r3, #1
    5e3c:	f47f ae92 	bne.w	5b64 <dhcp_recv+0x88>
	netif_set_down(netif);
    5e40:	4630      	mov	r0, r6
    5e42:	4b19      	ldr	r3, [pc, #100]	; (5ea8 <dhcp_recv+0x3cc>)
	struct dhcp *dhcp = netif->dhcp;
    5e44:	6a74      	ldr	r4, [r6, #36]	; 0x24
	netif_set_down(netif);
    5e46:	4798      	blx	r3
	netif_set_ipaddr(netif, IP_ADDR_ANY);
    5e48:	4630      	mov	r0, r6
    5e4a:	4918      	ldr	r1, [pc, #96]	; (5eac <dhcp_recv+0x3d0>)
    5e4c:	4b18      	ldr	r3, [pc, #96]	; (5eb0 <dhcp_recv+0x3d4>)
    5e4e:	4798      	blx	r3
	netif_set_gw(netif, IP_ADDR_ANY);
    5e50:	4630      	mov	r0, r6
    5e52:	4916      	ldr	r1, [pc, #88]	; (5eac <dhcp_recv+0x3d0>)
    5e54:	4b17      	ldr	r3, [pc, #92]	; (5eb4 <dhcp_recv+0x3d8>)
    5e56:	4798      	blx	r3
	netif_set_netmask(netif, IP_ADDR_ANY);
    5e58:	4630      	mov	r0, r6
    5e5a:	4914      	ldr	r1, [pc, #80]	; (5eac <dhcp_recv+0x3d0>)
    5e5c:	4b16      	ldr	r3, [pc, #88]	; (5eb8 <dhcp_recv+0x3dc>)
    5e5e:	4798      	blx	r3
	dhcp_set_state(dhcp, DHCP_BACKING_OFF);
    5e60:	4620      	mov	r0, r4
    5e62:	4b16      	ldr	r3, [pc, #88]	; (5ebc <dhcp_recv+0x3e0>)
    5e64:	210c      	movs	r1, #12
    5e66:	4798      	blx	r3
	dhcp_discover(netif);
    5e68:	4b15      	ldr	r3, [pc, #84]	; (5ec0 <dhcp_recv+0x3e4>)
    5e6a:	4630      	mov	r0, r6
    5e6c:	4798      	blx	r3
}
    5e6e:	e679      	b.n	5b64 <dhcp_recv+0x88>
	else if ((msg_type == DHCP_OFFER) && (dhcp->state == DHCP_SELECTING)) {
    5e70:	2b02      	cmp	r3, #2
    5e72:	f47f ae77 	bne.w	5b64 <dhcp_recv+0x88>
    5e76:	f89b 300c 	ldrb.w	r3, [fp, #12]
    5e7a:	2b06      	cmp	r3, #6
    5e7c:	f47f ae72 	bne.w	5b64 <dhcp_recv+0x88>
	if (dhcp_option_given(dhcp, DHCP_OPTION_IDX_SERVER_ID)) {
    5e80:	78a3      	ldrb	r3, [r4, #2]
		dhcp->request_timeout = 0;
    5e82:	f8ab 801a 	strh.w	r8, [fp, #26]
	if (dhcp_option_given(dhcp, DHCP_OPTION_IDX_SERVER_ID)) {
    5e86:	2b00      	cmp	r3, #0
    5e88:	f43f ae6c 	beq.w	5b64 <dhcp_recv+0x88>
		ip4_addr_set_u32(&dhcp->server_ip_addr, htonl(dhcp_get_option_value(dhcp, DHCP_OPTION_IDX_SERVER_ID)));
    5e8c:	4b0d      	ldr	r3, [pc, #52]	; (5ec4 <dhcp_recv+0x3e8>)
    5e8e:	6960      	ldr	r0, [r4, #20]
	struct dhcp *dhcp = netif->dhcp;
    5e90:	6a75      	ldr	r5, [r6, #36]	; 0x24
		ip4_addr_set_u32(&dhcp->server_ip_addr, htonl(dhcp_get_option_value(dhcp, DHCP_OPTION_IDX_SERVER_ID)));
    5e92:	4798      	blx	r3
		ip_addr_copy(dhcp->offered_ip_addr, dhcp->msg_in->yiaddr);
    5e94:	68ab      	ldr	r3, [r5, #8]
		ip4_addr_set_u32(&dhcp->server_ip_addr, htonl(dhcp_get_option_value(dhcp, DHCP_OPTION_IDX_SERVER_ID)));
    5e96:	6228      	str	r0, [r5, #32]
		ip_addr_copy(dhcp->offered_ip_addr, dhcp->msg_in->yiaddr);
    5e98:	691b      	ldr	r3, [r3, #16]
    5e9a:	626b      	str	r3, [r5, #36]	; 0x24
		dhcp_select(netif);
    5e9c:	4630      	mov	r0, r6
    5e9e:	4b0a      	ldr	r3, [pc, #40]	; (5ec8 <dhcp_recv+0x3ec>)
    5ea0:	e75e      	b.n	5d60 <dhcp_recv+0x284>
    5ea2:	bf00      	nop
    5ea4:	000055b1 	.word	0x000055b1
    5ea8:	0000a0d1 	.word	0x0000a0d1
    5eac:	0000cc90 	.word	0x0000cc90
    5eb0:	00009fb9 	.word	0x00009fb9
    5eb4:	0000a07d 	.word	0x0000a07d
    5eb8:	0000a085 	.word	0x0000a085
    5ebc:	000054a5 	.word	0x000054a5
    5ec0:	000057c1 	.word	0x000057c1
    5ec4:	00000d6d 	.word	0x00000d6d
    5ec8:	000059ed 	.word	0x000059ed

00005ecc <dhcp_arp_reply>:
{
    5ecc:	b537      	push	{r0, r1, r2, r4, r5, lr}
	LWIP_ERROR("netif != NULL", (netif != NULL), return;);
    5ece:	4605      	mov	r5, r0
    5ed0:	b900      	cbnz	r0, 5ed4 <dhcp_arp_reply+0x8>
    5ed2:	e7fe      	b.n	5ed2 <dhcp_arp_reply+0x6>
	if ((netif->dhcp != NULL) && (netif->dhcp->state == DHCP_CHECKING)) {
    5ed4:	6a44      	ldr	r4, [r0, #36]	; 0x24
    5ed6:	2c00      	cmp	r4, #0
    5ed8:	d033      	beq.n	5f42 <dhcp_arp_reply+0x76>
    5eda:	7b23      	ldrb	r3, [r4, #12]
    5edc:	2b08      	cmp	r3, #8
    5ede:	d130      	bne.n	5f42 <dhcp_arp_reply+0x76>
		if (ip_addr_cmp(addr, &netif->dhcp->offered_ip_addr)) {
    5ee0:	680a      	ldr	r2, [r1, #0]
    5ee2:	6a63      	ldr	r3, [r4, #36]	; 0x24
    5ee4:	429a      	cmp	r2, r3
    5ee6:	d12c      	bne.n	5f42 <dhcp_arp_reply+0x76>
	dhcp_set_state(dhcp, DHCP_BACKING_OFF);
    5ee8:	4b17      	ldr	r3, [pc, #92]	; (5f48 <dhcp_arp_reply+0x7c>)
    5eea:	210c      	movs	r1, #12
    5eec:	4620      	mov	r0, r4
    5eee:	4798      	blx	r3
	result = dhcp_create_msg(netif, dhcp, DHCP_DECLINE);
    5ef0:	2204      	movs	r2, #4
    5ef2:	4b16      	ldr	r3, [pc, #88]	; (5f4c <dhcp_arp_reply+0x80>)
    5ef4:	4621      	mov	r1, r4
    5ef6:	4628      	mov	r0, r5
    5ef8:	4798      	blx	r3
	if (result == ERR_OK) {
    5efa:	b9e8      	cbnz	r0, 5f38 <dhcp_arp_reply+0x6c>
		dhcp_option(dhcp, DHCP_OPTION_REQUESTED_IP, 4);
    5efc:	2204      	movs	r2, #4
    5efe:	2132      	movs	r1, #50	; 0x32
    5f00:	4b13      	ldr	r3, [pc, #76]	; (5f50 <dhcp_arp_reply+0x84>)
    5f02:	4620      	mov	r0, r4
    5f04:	4798      	blx	r3
		dhcp_option_long(dhcp, ntohl(ip4_addr_get_u32(&dhcp->offered_ip_addr)));
    5f06:	4b13      	ldr	r3, [pc, #76]	; (5f54 <dhcp_arp_reply+0x88>)
    5f08:	6a60      	ldr	r0, [r4, #36]	; 0x24
    5f0a:	4798      	blx	r3
    5f0c:	4b12      	ldr	r3, [pc, #72]	; (5f58 <dhcp_arp_reply+0x8c>)
    5f0e:	4601      	mov	r1, r0
    5f10:	4620      	mov	r0, r4
    5f12:	4798      	blx	r3
		dhcp_option_trailer(dhcp);
    5f14:	4b11      	ldr	r3, [pc, #68]	; (5f5c <dhcp_arp_reply+0x90>)
    5f16:	4798      	blx	r3
		pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
    5f18:	8b21      	ldrh	r1, [r4, #24]
    5f1a:	6920      	ldr	r0, [r4, #16]
    5f1c:	4b10      	ldr	r3, [pc, #64]	; (5f60 <dhcp_arp_reply+0x94>)
    5f1e:	31f0      	adds	r1, #240	; 0xf0
    5f20:	b289      	uxth	r1, r1
    5f22:	4798      	blx	r3
		udp_sendto_if(dhcp->pcb, dhcp->p_out, IP_ADDR_BROADCAST, DHCP_SERVER_PORT, netif);
    5f24:	9500      	str	r5, [sp, #0]
    5f26:	2343      	movs	r3, #67	; 0x43
    5f28:	4a0e      	ldr	r2, [pc, #56]	; (5f64 <dhcp_arp_reply+0x98>)
    5f2a:	6921      	ldr	r1, [r4, #16]
    5f2c:	6860      	ldr	r0, [r4, #4]
    5f2e:	4d0e      	ldr	r5, [pc, #56]	; (5f68 <dhcp_arp_reply+0x9c>)
    5f30:	47a8      	blx	r5
		dhcp_delete_msg(dhcp);
    5f32:	4b0e      	ldr	r3, [pc, #56]	; (5f6c <dhcp_arp_reply+0xa0>)
    5f34:	4620      	mov	r0, r4
    5f36:	4798      	blx	r3
	dhcp->tries++;
    5f38:	7b63      	ldrb	r3, [r4, #13]
    5f3a:	3301      	adds	r3, #1
    5f3c:	7363      	strb	r3, [r4, #13]
	dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
    5f3e:	2314      	movs	r3, #20
    5f40:	8363      	strh	r3, [r4, #26]
}
    5f42:	b003      	add	sp, #12
    5f44:	bd30      	pop	{r4, r5, pc}
    5f46:	bf00      	nop
    5f48:	000054a5 	.word	0x000054a5
    5f4c:	00005691 	.word	0x00005691
    5f50:	000054b5 	.word	0x000054b5
    5f54:	00000d71 	.word	0x00000d71
    5f58:	00005501 	.word	0x00005501
    5f5c:	00005537 	.word	0x00005537
    5f60:	00003249 	.word	0x00003249
    5f64:	0000cc8c 	.word	0x0000cc8c
    5f68:	00004699 	.word	0x00004699
    5f6c:	00005565 	.word	0x00005565

00005f70 <dhcp_renew>:
{
    5f70:	b573      	push	{r0, r1, r4, r5, r6, lr}
	struct dhcp *dhcp = netif->dhcp;
    5f72:	6a44      	ldr	r4, [r0, #36]	; 0x24
	dhcp_set_state(dhcp, DHCP_RENEWING);
    5f74:	4b20      	ldr	r3, [pc, #128]	; (5ff8 <dhcp_renew+0x88>)
{
    5f76:	4606      	mov	r6, r0
	dhcp_set_state(dhcp, DHCP_RENEWING);
    5f78:	2105      	movs	r1, #5
    5f7a:	4620      	mov	r0, r4
    5f7c:	4798      	blx	r3
	result = dhcp_create_msg(netif, dhcp, DHCP_REQUEST);
    5f7e:	2203      	movs	r2, #3
    5f80:	4b1e      	ldr	r3, [pc, #120]	; (5ffc <dhcp_renew+0x8c>)
    5f82:	4621      	mov	r1, r4
    5f84:	4630      	mov	r0, r6
    5f86:	4798      	blx	r3
	if (result == ERR_OK) {
    5f88:	4605      	mov	r5, r0
    5f8a:	b9d0      	cbnz	r0, 5fc2 <dhcp_renew+0x52>
		dhcp_option(dhcp, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
    5f8c:	2202      	movs	r2, #2
    5f8e:	4620      	mov	r0, r4
    5f90:	4b1b      	ldr	r3, [pc, #108]	; (6000 <dhcp_renew+0x90>)
    5f92:	2139      	movs	r1, #57	; 0x39
    5f94:	4798      	blx	r3
		dhcp_option_short(dhcp, DHCP_MAX_MSG_LEN(netif));
    5f96:	8d31      	ldrh	r1, [r6, #40]	; 0x28
    5f98:	4b1a      	ldr	r3, [pc, #104]	; (6004 <dhcp_renew+0x94>)
    5f9a:	4798      	blx	r3
		dhcp_option_trailer(dhcp);
    5f9c:	4b1a      	ldr	r3, [pc, #104]	; (6008 <dhcp_renew+0x98>)
    5f9e:	4798      	blx	r3
		pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
    5fa0:	8b21      	ldrh	r1, [r4, #24]
    5fa2:	6920      	ldr	r0, [r4, #16]
    5fa4:	4b19      	ldr	r3, [pc, #100]	; (600c <dhcp_renew+0x9c>)
    5fa6:	31f0      	adds	r1, #240	; 0xf0
    5fa8:	b289      	uxth	r1, r1
    5faa:	4798      	blx	r3
		udp_sendto_if(dhcp->pcb, dhcp->p_out, &dhcp->server_ip_addr, DHCP_SERVER_PORT, netif);
    5fac:	9600      	str	r6, [sp, #0]
    5fae:	2343      	movs	r3, #67	; 0x43
    5fb0:	6921      	ldr	r1, [r4, #16]
    5fb2:	6860      	ldr	r0, [r4, #4]
    5fb4:	4e16      	ldr	r6, [pc, #88]	; (6010 <dhcp_renew+0xa0>)
    5fb6:	f104 0220 	add.w	r2, r4, #32
    5fba:	47b0      	blx	r6
		dhcp_delete_msg(dhcp);
    5fbc:	4b15      	ldr	r3, [pc, #84]	; (6014 <dhcp_renew+0xa4>)
    5fbe:	4620      	mov	r0, r4
    5fc0:	4798      	blx	r3
	dhcp->tries++;
    5fc2:	7b63      	ldrb	r3, [r4, #13]
    5fc4:	3301      	adds	r3, #1
    5fc6:	b2db      	uxtb	r3, r3
	msecs                 = dhcp->tries < 10 ? dhcp->tries * 2000 : 20 * 1000;
    5fc8:	2b09      	cmp	r3, #9
    5fca:	bf98      	it	ls
    5fcc:	ebc3 1243 	rsbls	r2, r3, r3, lsl #5
	dhcp->tries++;
    5fd0:	7363      	strb	r3, [r4, #13]
	msecs                 = dhcp->tries < 10 ? dhcp->tries * 2000 : 20 * 1000;
    5fd2:	bf9d      	ittte	ls
    5fd4:	eb03 0382 	addls.w	r3, r3, r2, lsl #2
    5fd8:	011b      	lslls	r3, r3, #4
    5fda:	b29b      	uxthls	r3, r3
    5fdc:	f644 6320 	movwhi	r3, #20000	; 0x4e20
	dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
    5fe0:	f44f 72fa 	mov.w	r2, #500	; 0x1f4
}
    5fe4:	4628      	mov	r0, r5
	dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
    5fe6:	f203 13f3 	addw	r3, r3, #499	; 0x1f3
    5fea:	b29b      	uxth	r3, r3
    5fec:	fbb3 f3f2 	udiv	r3, r3, r2
    5ff0:	8363      	strh	r3, [r4, #26]
}
    5ff2:	b002      	add	sp, #8
    5ff4:	bd70      	pop	{r4, r5, r6, pc}
    5ff6:	bf00      	nop
    5ff8:	000054a5 	.word	0x000054a5
    5ffc:	00005691 	.word	0x00005691
    6000:	000054b5 	.word	0x000054b5
    6004:	000054e3 	.word	0x000054e3
    6008:	00005537 	.word	0x00005537
    600c:	00003249 	.word	0x00003249
    6010:	00004699 	.word	0x00004699
    6014:	00005565 	.word	0x00005565

00006018 <dhcp_coarse_tmr>:
	struct netif *netif = netif_list;
    6018:	4b13      	ldr	r3, [pc, #76]	; (6068 <dhcp_coarse_tmr+0x50>)
{
    601a:	b570      	push	{r4, r5, r6, lr}
	struct netif *netif = netif_list;
    601c:	681c      	ldr	r4, [r3, #0]
		dhcp_renew(netif);
    601e:	4d13      	ldr	r5, [pc, #76]	; (606c <dhcp_coarse_tmr+0x54>)
		dhcp_rebind(netif);
    6020:	4e13      	ldr	r6, [pc, #76]	; (6070 <dhcp_coarse_tmr+0x58>)
	while (netif != NULL) {
    6022:	b904      	cbnz	r4, 6026 <dhcp_coarse_tmr+0xe>
}
    6024:	bd70      	pop	{r4, r5, r6, pc}
		if (netif->dhcp != NULL) {
    6026:	6a63      	ldr	r3, [r4, #36]	; 0x24
    6028:	b16b      	cbz	r3, 6046 <dhcp_coarse_tmr+0x2e>
			if (netif->dhcp->t2_timeout-- == 1) {
    602a:	8bda      	ldrh	r2, [r3, #30]
    602c:	1e51      	subs	r1, r2, #1
    602e:	2a01      	cmp	r2, #1
    6030:	83d9      	strh	r1, [r3, #30]
    6032:	d10a      	bne.n	604a <dhcp_coarse_tmr+0x32>
	if ((dhcp->state == DHCP_REQUESTING) || (dhcp->state == DHCP_BOUND) || (dhcp->state == DHCP_RENEWING)) {
    6034:	7b1b      	ldrb	r3, [r3, #12]
    6036:	f003 02fb 	and.w	r2, r3, #251	; 0xfb
    603a:	2a01      	cmp	r2, #1
    603c:	d001      	beq.n	6042 <dhcp_coarse_tmr+0x2a>
    603e:	2b0a      	cmp	r3, #10
    6040:	d101      	bne.n	6046 <dhcp_coarse_tmr+0x2e>
		dhcp_rebind(netif);
    6042:	4620      	mov	r0, r4
    6044:	47b0      	blx	r6
		netif = netif->next;
    6046:	6824      	ldr	r4, [r4, #0]
    6048:	e7eb      	b.n	6022 <dhcp_coarse_tmr+0xa>
			} else if (netif->dhcp->t1_timeout-- == 1) {
    604a:	8b9a      	ldrh	r2, [r3, #28]
    604c:	1e51      	subs	r1, r2, #1
    604e:	2a01      	cmp	r2, #1
    6050:	8399      	strh	r1, [r3, #28]
    6052:	d1f8      	bne.n	6046 <dhcp_coarse_tmr+0x2e>
	if ((dhcp->state == DHCP_REQUESTING) || (dhcp->state == DHCP_BOUND) || (dhcp->state == DHCP_RENEWING)) {
    6054:	7b1b      	ldrb	r3, [r3, #12]
    6056:	f003 02fb 	and.w	r2, r3, #251	; 0xfb
    605a:	2a01      	cmp	r2, #1
    605c:	d001      	beq.n	6062 <dhcp_coarse_tmr+0x4a>
    605e:	2b0a      	cmp	r3, #10
    6060:	d1f1      	bne.n	6046 <dhcp_coarse_tmr+0x2e>
		dhcp_renew(netif);
    6062:	4620      	mov	r0, r4
    6064:	47a8      	blx	r5
    6066:	e7ee      	b.n	6046 <dhcp_coarse_tmr+0x2e>
    6068:	200163e4 	.word	0x200163e4
    606c:	00005f71 	.word	0x00005f71
    6070:	00005949 	.word	0x00005949

00006074 <dhcp_release>:
{
    6074:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
	struct dhcp *dhcp = netif->dhcp;
    6076:	6a44      	ldr	r4, [r0, #36]	; 0x24
	dhcp_set_state(dhcp, DHCP_OFF);
    6078:	4b27      	ldr	r3, [pc, #156]	; (6118 <dhcp_release+0xa4>)
    607a:	2100      	movs	r1, #0
{
    607c:	4605      	mov	r5, r0
	dhcp_set_state(dhcp, DHCP_OFF);
    607e:	4620      	mov	r0, r4
    6080:	4798      	blx	r3
	result = dhcp_create_msg(netif, dhcp, DHCP_RELEASE);
    6082:	2207      	movs	r2, #7
	ip_addr_set_zero(&dhcp->offered_ip_addr);
    6084:	e9c4 1108 	strd	r1, r1, [r4, #32]
	ip_addr_set_zero(&dhcp->offered_gw_addr);
    6088:	e9c4 110a 	strd	r1, r1, [r4, #40]	; 0x28
	dhcp->offered_t0_lease = dhcp->offered_t1_renew = dhcp->offered_t2_rebind = 0;
    608c:	e9c4 110d 	strd	r1, r1, [r4, #52]	; 0x34
    6090:	6321      	str	r1, [r4, #48]	; 0x30
	result = dhcp_create_msg(netif, dhcp, DHCP_RELEASE);
    6092:	4b22      	ldr	r3, [pc, #136]	; (611c <dhcp_release+0xa8>)
    6094:	4621      	mov	r1, r4
    6096:	4628      	mov	r0, r5
    6098:	4798      	blx	r3
	if (result == ERR_OK) {
    609a:	4606      	mov	r6, r0
    609c:	b998      	cbnz	r0, 60c6 <dhcp_release+0x52>
		dhcp_option_trailer(dhcp);
    609e:	4b20      	ldr	r3, [pc, #128]	; (6120 <dhcp_release+0xac>)
		udp_sendto_if(dhcp->pcb, dhcp->p_out, &dhcp->server_ip_addr, DHCP_SERVER_PORT, netif);
    60a0:	4f20      	ldr	r7, [pc, #128]	; (6124 <dhcp_release+0xb0>)
		dhcp_option_trailer(dhcp);
    60a2:	4620      	mov	r0, r4
    60a4:	4798      	blx	r3
		pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
    60a6:	8b21      	ldrh	r1, [r4, #24]
    60a8:	6920      	ldr	r0, [r4, #16]
    60aa:	4b1f      	ldr	r3, [pc, #124]	; (6128 <dhcp_release+0xb4>)
    60ac:	31f0      	adds	r1, #240	; 0xf0
    60ae:	b289      	uxth	r1, r1
    60b0:	4798      	blx	r3
		udp_sendto_if(dhcp->pcb, dhcp->p_out, &dhcp->server_ip_addr, DHCP_SERVER_PORT, netif);
    60b2:	9500      	str	r5, [sp, #0]
    60b4:	2343      	movs	r3, #67	; 0x43
    60b6:	6921      	ldr	r1, [r4, #16]
    60b8:	6860      	ldr	r0, [r4, #4]
    60ba:	f104 0220 	add.w	r2, r4, #32
    60be:	47b8      	blx	r7
		dhcp_delete_msg(dhcp);
    60c0:	4b1a      	ldr	r3, [pc, #104]	; (612c <dhcp_release+0xb8>)
    60c2:	4620      	mov	r0, r4
    60c4:	4798      	blx	r3
	dhcp->tries++;
    60c6:	7b63      	ldrb	r3, [r4, #13]
    60c8:	3301      	adds	r3, #1
    60ca:	b2db      	uxtb	r3, r3
	msecs                 = dhcp->tries < 10 ? dhcp->tries * 1000 : 10 * 1000;
    60cc:	2b09      	cmp	r3, #9
    60ce:	bf98      	it	ls
    60d0:	ebc3 1243 	rsbls	r2, r3, r3, lsl #5
	dhcp->tries++;
    60d4:	7363      	strb	r3, [r4, #13]
	msecs                 = dhcp->tries < 10 ? dhcp->tries * 1000 : 10 * 1000;
    60d6:	bf9d      	ittte	ls
    60d8:	eb03 0382 	addls.w	r3, r3, r2, lsl #2
    60dc:	00db      	lslls	r3, r3, #3
    60de:	b29b      	uxthls	r3, r3
    60e0:	f242 7310 	movwhi	r3, #10000	; 0x2710
	dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
    60e4:	f203 13f3 	addw	r3, r3, #499	; 0x1f3
    60e8:	f44f 72fa 	mov.w	r2, #500	; 0x1f4
	netif_set_down(netif);
    60ec:	4628      	mov	r0, r5
	dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
    60ee:	b29b      	uxth	r3, r3
    60f0:	fbb3 f3f2 	udiv	r3, r3, r2
    60f4:	8363      	strh	r3, [r4, #26]
	netif_set_down(netif);
    60f6:	4b0e      	ldr	r3, [pc, #56]	; (6130 <dhcp_release+0xbc>)
    60f8:	4798      	blx	r3
	netif_set_ipaddr(netif, IP_ADDR_ANY);
    60fa:	4628      	mov	r0, r5
    60fc:	490d      	ldr	r1, [pc, #52]	; (6134 <dhcp_release+0xc0>)
    60fe:	4b0e      	ldr	r3, [pc, #56]	; (6138 <dhcp_release+0xc4>)
    6100:	4798      	blx	r3
	netif_set_gw(netif, IP_ADDR_ANY);
    6102:	4628      	mov	r0, r5
    6104:	490b      	ldr	r1, [pc, #44]	; (6134 <dhcp_release+0xc0>)
    6106:	4b0d      	ldr	r3, [pc, #52]	; (613c <dhcp_release+0xc8>)
    6108:	4798      	blx	r3
	netif_set_netmask(netif, IP_ADDR_ANY);
    610a:	4628      	mov	r0, r5
    610c:	4909      	ldr	r1, [pc, #36]	; (6134 <dhcp_release+0xc0>)
    610e:	4b0c      	ldr	r3, [pc, #48]	; (6140 <dhcp_release+0xcc>)
    6110:	4798      	blx	r3
}
    6112:	4630      	mov	r0, r6
    6114:	b003      	add	sp, #12
    6116:	bdf0      	pop	{r4, r5, r6, r7, pc}
    6118:	000054a5 	.word	0x000054a5
    611c:	00005691 	.word	0x00005691
    6120:	00005537 	.word	0x00005537
    6124:	00004699 	.word	0x00004699
    6128:	00003249 	.word	0x00003249
    612c:	00005565 	.word	0x00005565
    6130:	0000a0d1 	.word	0x0000a0d1
    6134:	0000cc90 	.word	0x0000cc90
    6138:	00009fb9 	.word	0x00009fb9
    613c:	0000a07d 	.word	0x0000a07d
    6140:	0000a085 	.word	0x0000a085

00006144 <dhcp_fine_tmr>:
{
    6144:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	struct netif *netif = netif_list;
    6146:	4b22      	ldr	r3, [pc, #136]	; (61d0 <dhcp_fine_tmr+0x8c>)
		dhcp_discover(netif);
    6148:	4d22      	ldr	r5, [pc, #136]	; (61d4 <dhcp_fine_tmr+0x90>)
	struct netif *netif = netif_list;
    614a:	681c      	ldr	r4, [r3, #0]
			dhcp_reboot(netif);
    614c:	4f22      	ldr	r7, [pc, #136]	; (61d8 <dhcp_fine_tmr+0x94>)
			dhcp_release(netif);
    614e:	4e23      	ldr	r6, [pc, #140]	; (61dc <dhcp_fine_tmr+0x98>)
	while (netif != NULL) {
    6150:	b904      	cbnz	r4, 6154 <dhcp_fine_tmr+0x10>
}
    6152:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		if (netif->dhcp != NULL) {
    6154:	6a63      	ldr	r3, [r4, #36]	; 0x24
    6156:	b123      	cbz	r3, 6162 <dhcp_fine_tmr+0x1e>
			if (netif->dhcp->request_timeout > 1) {
    6158:	8b5a      	ldrh	r2, [r3, #26]
    615a:	2a01      	cmp	r2, #1
    615c:	d903      	bls.n	6166 <dhcp_fine_tmr+0x22>
				netif->dhcp->request_timeout--;
    615e:	3a01      	subs	r2, #1
    6160:	835a      	strh	r2, [r3, #26]
		netif = netif->next;
    6162:	6824      	ldr	r4, [r4, #0]
    6164:	e7f4      	b.n	6150 <dhcp_fine_tmr+0xc>
			} else if (netif->dhcp->request_timeout == 1) {
    6166:	d1fc      	bne.n	6162 <dhcp_fine_tmr+0x1e>
				netif->dhcp->request_timeout--;
    6168:	2200      	movs	r2, #0
    616a:	835a      	strh	r2, [r3, #26]
	if ((dhcp->state == DHCP_BACKING_OFF) || (dhcp->state == DHCP_SELECTING)) {
    616c:	7b1a      	ldrb	r2, [r3, #12]
    616e:	2a0c      	cmp	r2, #12
    6170:	d001      	beq.n	6176 <dhcp_fine_tmr+0x32>
    6172:	2a06      	cmp	r2, #6
    6174:	d102      	bne.n	617c <dhcp_fine_tmr+0x38>
			dhcp_discover(netif);
    6176:	4620      	mov	r0, r4
			dhcp_discover(netif);
    6178:	47a8      	blx	r5
    617a:	e7f2      	b.n	6162 <dhcp_fine_tmr+0x1e>
	} else if (dhcp->state == DHCP_REQUESTING) {
    617c:	2a01      	cmp	r2, #1
    617e:	d106      	bne.n	618e <dhcp_fine_tmr+0x4a>
		if (dhcp->tries <= 5) {
    6180:	7b5b      	ldrb	r3, [r3, #13]
    6182:	2b05      	cmp	r3, #5
			dhcp_select(netif);
    6184:	4620      	mov	r0, r4
		if (dhcp->tries <= 5) {
    6186:	d819      	bhi.n	61bc <dhcp_fine_tmr+0x78>
			dhcp_select(netif);
    6188:	4b15      	ldr	r3, [pc, #84]	; (61e0 <dhcp_fine_tmr+0x9c>)
			dhcp_rebind(netif);
    618a:	4798      	blx	r3
    618c:	e7e9      	b.n	6162 <dhcp_fine_tmr+0x1e>
	} else if (dhcp->state == DHCP_CHECKING) {
    618e:	2a08      	cmp	r2, #8
    6190:	d106      	bne.n	61a0 <dhcp_fine_tmr+0x5c>
		if (dhcp->tries <= 1) {
    6192:	7b5b      	ldrb	r3, [r3, #13]
    6194:	2b01      	cmp	r3, #1
			dhcp_check(netif);
    6196:	bf94      	ite	ls
    6198:	4b12      	ldrls	r3, [pc, #72]	; (61e4 <dhcp_fine_tmr+0xa0>)
			dhcp_bind(netif);
    619a:	4b13      	ldrhi	r3, [pc, #76]	; (61e8 <dhcp_fine_tmr+0xa4>)
			dhcp_check(netif);
    619c:	4620      	mov	r0, r4
    619e:	e7f4      	b.n	618a <dhcp_fine_tmr+0x46>
	else if (dhcp->state == DHCP_RENEWING) {
    61a0:	2a05      	cmp	r2, #5
    61a2:	d103      	bne.n	61ac <dhcp_fine_tmr+0x68>
		dhcp_renew(netif);
    61a4:	4b11      	ldr	r3, [pc, #68]	; (61ec <dhcp_fine_tmr+0xa8>)
    61a6:	4620      	mov	r0, r4
    61a8:	4798      	blx	r3
    61aa:	e7da      	b.n	6162 <dhcp_fine_tmr+0x1e>
	} else if (dhcp->state == DHCP_REBINDING) {
    61ac:	2a04      	cmp	r2, #4
    61ae:	d107      	bne.n	61c0 <dhcp_fine_tmr+0x7c>
		if (dhcp->tries <= 8) {
    61b0:	7b5b      	ldrb	r3, [r3, #13]
    61b2:	2b08      	cmp	r3, #8
			dhcp_rebind(netif);
    61b4:	4620      	mov	r0, r4
		if (dhcp->tries <= 8) {
    61b6:	d801      	bhi.n	61bc <dhcp_fine_tmr+0x78>
			dhcp_rebind(netif);
    61b8:	4b0d      	ldr	r3, [pc, #52]	; (61f0 <dhcp_fine_tmr+0xac>)
    61ba:	e7e6      	b.n	618a <dhcp_fine_tmr+0x46>
			dhcp_release(netif);
    61bc:	47b0      	blx	r6
    61be:	e7da      	b.n	6176 <dhcp_fine_tmr+0x32>
	} else if (dhcp->state == DHCP_REBOOTING) {
    61c0:	2a03      	cmp	r2, #3
    61c2:	d1ce      	bne.n	6162 <dhcp_fine_tmr+0x1e>
		if (dhcp->tries < REBOOT_TRIES) {
    61c4:	7b5b      	ldrb	r3, [r3, #13]
    61c6:	2b01      	cmp	r3, #1
			dhcp_reboot(netif);
    61c8:	4620      	mov	r0, r4
		if (dhcp->tries < REBOOT_TRIES) {
    61ca:	d8d5      	bhi.n	6178 <dhcp_fine_tmr+0x34>
			dhcp_reboot(netif);
    61cc:	47b8      	blx	r7
    61ce:	e7c8      	b.n	6162 <dhcp_fine_tmr+0x1e>
    61d0:	200163e4 	.word	0x200163e4
    61d4:	000057c1 	.word	0x000057c1
    61d8:	00005885 	.word	0x00005885
    61dc:	00006075 	.word	0x00006075
    61e0:	000059ed 	.word	0x000059ed
    61e4:	00005581 	.word	0x00005581
    61e8:	000055b1 	.word	0x000055b1
    61ec:	00005f71 	.word	0x00005f71
    61f0:	00005949 	.word	0x00005949

000061f4 <dhcp_stop>:
{
    61f4:	b510      	push	{r4, lr}
	LWIP_ERROR("dhcp_stop: netif != NULL", (netif != NULL), return;);
    61f6:	b900      	cbnz	r0, 61fa <dhcp_stop+0x6>
    61f8:	e7fe      	b.n	61f8 <dhcp_stop+0x4>
	netif->flags &= ~NETIF_FLAG_DHCP;
    61fa:	f890 3031 	ldrb.w	r3, [r0, #49]	; 0x31
	dhcp = netif->dhcp;
    61fe:	6a44      	ldr	r4, [r0, #36]	; 0x24
	netif->flags &= ~NETIF_FLAG_DHCP;
    6200:	f023 0308 	bic.w	r3, r3, #8
    6204:	f880 3031 	strb.w	r3, [r0, #49]	; 0x31
	if (dhcp != NULL) {
    6208:	b15c      	cbz	r4, 6222 <dhcp_stop+0x2e>
		if (dhcp->pcb != NULL) {
    620a:	6860      	ldr	r0, [r4, #4]
    620c:	b118      	cbz	r0, 6216 <dhcp_stop+0x22>
			udp_remove(dhcp->pcb);
    620e:	4b05      	ldr	r3, [pc, #20]	; (6224 <dhcp_stop+0x30>)
    6210:	4798      	blx	r3
			dhcp->pcb = NULL;
    6212:	2300      	movs	r3, #0
    6214:	6063      	str	r3, [r4, #4]
		dhcp_set_state(dhcp, DHCP_OFF);
    6216:	4620      	mov	r0, r4
    6218:	4b03      	ldr	r3, [pc, #12]	; (6228 <dhcp_stop+0x34>)
}
    621a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		dhcp_set_state(dhcp, DHCP_OFF);
    621e:	2100      	movs	r1, #0
    6220:	4718      	bx	r3
}
    6222:	bd10      	pop	{r4, pc}
    6224:	00004849 	.word	0x00004849
    6228:	000054a5 	.word	0x000054a5

0000622c <dhcp_start>:
{
    622c:	b538      	push	{r3, r4, r5, lr}
	LWIP_ERROR("netif != NULL", (netif != NULL), return ERR_ARG;);
    622e:	4604      	mov	r4, r0
    6230:	b900      	cbnz	r0, 6234 <dhcp_start+0x8>
    6232:	e7fe      	b.n	6232 <dhcp_start+0x6>
	netif->flags &= ~NETIF_FLAG_DHCP;
    6234:	f890 3031 	ldrb.w	r3, [r0, #49]	; 0x31
	dhcp = netif->dhcp;
    6238:	6a45      	ldr	r5, [r0, #36]	; 0x24
	netif->flags &= ~NETIF_FLAG_DHCP;
    623a:	f023 0208 	bic.w	r2, r3, #8
	if ((netif->flags & NETIF_FLAG_ETHARP) == 0) {
    623e:	069b      	lsls	r3, r3, #26
	netif->flags &= ~NETIF_FLAG_DHCP;
    6240:	f880 2031 	strb.w	r2, [r0, #49]	; 0x31
	if ((netif->flags & NETIF_FLAG_ETHARP) == 0) {
    6244:	d540      	bpl.n	62c8 <dhcp_start+0x9c>
	if (netif->mtu < DHCP_MAX_MSG_LEN_MIN_REQUIRED) {
    6246:	8d03      	ldrh	r3, [r0, #40]	; 0x28
    6248:	f5b3 7f10 	cmp.w	r3, #576	; 0x240
    624c:	d202      	bcs.n	6254 <dhcp_start+0x28>
		return ERR_MEM;
    624e:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
}
    6252:	bd38      	pop	{r3, r4, r5, pc}
	if (dhcp == NULL) {
    6254:	2d00      	cmp	r5, #0
    6256:	d12a      	bne.n	62ae <dhcp_start+0x82>
		dhcp = (struct dhcp *)mem_malloc(sizeof(struct dhcp));
    6258:	4b1d      	ldr	r3, [pc, #116]	; (62d0 <dhcp_start+0xa4>)
    625a:	203c      	movs	r0, #60	; 0x3c
    625c:	4798      	blx	r3
		if (dhcp == NULL) {
    625e:	4605      	mov	r5, r0
    6260:	2800      	cmp	r0, #0
    6262:	d0f4      	beq.n	624e <dhcp_start+0x22>
		netif->dhcp = dhcp;
    6264:	6260      	str	r0, [r4, #36]	; 0x24
	memset(dhcp, 0, sizeof(struct dhcp));
    6266:	4b1b      	ldr	r3, [pc, #108]	; (62d4 <dhcp_start+0xa8>)
    6268:	223c      	movs	r2, #60	; 0x3c
    626a:	2100      	movs	r1, #0
    626c:	4628      	mov	r0, r5
    626e:	4798      	blx	r3
	dhcp->pcb = udp_new();
    6270:	4b19      	ldr	r3, [pc, #100]	; (62d8 <dhcp_start+0xac>)
    6272:	4798      	blx	r3
    6274:	6068      	str	r0, [r5, #4]
	if (dhcp->pcb == NULL) {
    6276:	2800      	cmp	r0, #0
    6278:	d0e9      	beq.n	624e <dhcp_start+0x22>
	ip_set_option(dhcp->pcb, SOF_BROADCAST);
    627a:	7a02      	ldrb	r2, [r0, #8]
	udp_bind(dhcp->pcb, IP_ADDR_ANY, DHCP_CLIENT_PORT);
    627c:	4917      	ldr	r1, [pc, #92]	; (62dc <dhcp_start+0xb0>)
    627e:	4b18      	ldr	r3, [pc, #96]	; (62e0 <dhcp_start+0xb4>)
	ip_set_option(dhcp->pcb, SOF_BROADCAST);
    6280:	f042 0220 	orr.w	r2, r2, #32
    6284:	7202      	strb	r2, [r0, #8]
	udp_bind(dhcp->pcb, IP_ADDR_ANY, DHCP_CLIENT_PORT);
    6286:	2244      	movs	r2, #68	; 0x44
    6288:	4798      	blx	r3
	udp_connect(dhcp->pcb, IP_ADDR_ANY, DHCP_SERVER_PORT);
    628a:	4914      	ldr	r1, [pc, #80]	; (62dc <dhcp_start+0xb0>)
    628c:	4b15      	ldr	r3, [pc, #84]	; (62e4 <dhcp_start+0xb8>)
    628e:	6868      	ldr	r0, [r5, #4]
    6290:	2243      	movs	r2, #67	; 0x43
    6292:	4798      	blx	r3
	udp_recv(dhcp->pcb, dhcp_recv, netif);
    6294:	6868      	ldr	r0, [r5, #4]
    6296:	4b14      	ldr	r3, [pc, #80]	; (62e8 <dhcp_start+0xbc>)
    6298:	4914      	ldr	r1, [pc, #80]	; (62ec <dhcp_start+0xc0>)
    629a:	4622      	mov	r2, r4
    629c:	4798      	blx	r3
	result = dhcp_discover(netif);
    629e:	4b14      	ldr	r3, [pc, #80]	; (62f0 <dhcp_start+0xc4>)
    62a0:	4620      	mov	r0, r4
    62a2:	4798      	blx	r3
	if (result != ERR_OK) {
    62a4:	b148      	cbz	r0, 62ba <dhcp_start+0x8e>
		dhcp_stop(netif);
    62a6:	4b13      	ldr	r3, [pc, #76]	; (62f4 <dhcp_start+0xc8>)
    62a8:	4620      	mov	r0, r4
    62aa:	4798      	blx	r3
    62ac:	e7cf      	b.n	624e <dhcp_start+0x22>
		if (dhcp->pcb != NULL) {
    62ae:	6868      	ldr	r0, [r5, #4]
    62b0:	2800      	cmp	r0, #0
    62b2:	d0d8      	beq.n	6266 <dhcp_start+0x3a>
			udp_remove(dhcp->pcb);
    62b4:	4b10      	ldr	r3, [pc, #64]	; (62f8 <dhcp_start+0xcc>)
    62b6:	4798      	blx	r3
    62b8:	e7d5      	b.n	6266 <dhcp_start+0x3a>
	netif->flags |= NETIF_FLAG_DHCP;
    62ba:	f894 3031 	ldrb.w	r3, [r4, #49]	; 0x31
    62be:	f043 0308 	orr.w	r3, r3, #8
    62c2:	f884 3031 	strb.w	r3, [r4, #49]	; 0x31
	return result;
    62c6:	e7c4      	b.n	6252 <dhcp_start+0x26>
		return ERR_ARG;
    62c8:	f06f 000d 	mvn.w	r0, #13
    62cc:	e7c1      	b.n	6252 <dhcp_start+0x26>
    62ce:	bf00      	nop
    62d0:	00006809 	.word	0x00006809
    62d4:	0000c099 	.word	0x0000c099
    62d8:	00004879 	.word	0x00004879
    62dc:	0000cc90 	.word	0x0000cc90
    62e0:	00004611 	.word	0x00004611
    62e4:	000047f5 	.word	0x000047f5
    62e8:	00004841 	.word	0x00004841
    62ec:	00005add 	.word	0x00005add
    62f0:	000057c1 	.word	0x000057c1
    62f4:	000061f5 	.word	0x000061f5
    62f8:	00004849 	.word	0x00004849

000062fc <io_write>:

/**
 * \brief I/O write interface
 */
int32_t io_write(struct io_descriptor *const io_descr, const uint8_t *const buf, const uint16_t length)
{
    62fc:	b570      	push	{r4, r5, r6, lr}
    62fe:	460d      	mov	r5, r1
    6300:	4616      	mov	r6, r2
	ASSERT(io_descr && buf);
    6302:	4604      	mov	r4, r0
    6304:	b110      	cbz	r0, 630c <io_write+0x10>
    6306:	1e08      	subs	r0, r1, #0
    6308:	bf18      	it	ne
    630a:	2001      	movne	r0, #1
    630c:	4905      	ldr	r1, [pc, #20]	; (6324 <io_write+0x28>)
    630e:	4b06      	ldr	r3, [pc, #24]	; (6328 <io_write+0x2c>)
    6310:	2234      	movs	r2, #52	; 0x34
    6312:	4798      	blx	r3
	return io_descr->write(io_descr, buf, length);
    6314:	6823      	ldr	r3, [r4, #0]
    6316:	4632      	mov	r2, r6
    6318:	4629      	mov	r1, r5
    631a:	4620      	mov	r0, r4
}
    631c:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	return io_descr->write(io_descr, buf, length);
    6320:	4718      	bx	r3
    6322:	bf00      	nop
    6324:	0000ca5c 	.word	0x0000ca5c
    6328:	00008a19 	.word	0x00008a19

0000632c <io_read>:

/**
 * \brief I/O read interface
 */
int32_t io_read(struct io_descriptor *const io_descr, uint8_t *const buf, const uint16_t length)
{
    632c:	b570      	push	{r4, r5, r6, lr}
    632e:	460d      	mov	r5, r1
    6330:	4616      	mov	r6, r2
	ASSERT(io_descr && buf);
    6332:	4604      	mov	r4, r0
    6334:	b110      	cbz	r0, 633c <io_read+0x10>
    6336:	1e08      	subs	r0, r1, #0
    6338:	bf18      	it	ne
    633a:	2001      	movne	r0, #1
    633c:	4905      	ldr	r1, [pc, #20]	; (6354 <io_read+0x28>)
    633e:	4b06      	ldr	r3, [pc, #24]	; (6358 <io_read+0x2c>)
    6340:	223d      	movs	r2, #61	; 0x3d
    6342:	4798      	blx	r3
	return io_descr->read(io_descr, buf, length);
    6344:	6863      	ldr	r3, [r4, #4]
    6346:	4632      	mov	r2, r6
    6348:	4629      	mov	r1, r5
    634a:	4620      	mov	r0, r4
}
    634c:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	return io_descr->read(io_descr, buf, length);
    6350:	4718      	bx	r3
    6352:	bf00      	nop
    6354:	0000ca5c 	.word	0x0000ca5c
    6358:	00008a19 	.word	0x00008a19

0000635c <ip_route>:
		return netif;
	}
#endif

	/* iterate through netifs */
	for (netif = netif_list; netif != NULL; netif = netif->next) {
    635c:	4a0c      	ldr	r2, [pc, #48]	; (6390 <ip_route+0x34>)
{
    635e:	4603      	mov	r3, r0
	for (netif = netif_list; netif != NULL; netif = netif->next) {
    6360:	6810      	ldr	r0, [r2, #0]
    6362:	b948      	cbnz	r0, 6378 <ip_route+0x1c>
				/* return netif on which to forward IP packet */
				return netif;
			}
		}
	}
	if ((netif_default == NULL) || (!netif_is_up(netif_default))) {
    6364:	4b0b      	ldr	r3, [pc, #44]	; (6394 <ip_route+0x38>)
    6366:	681b      	ldr	r3, [r3, #0]
    6368:	b12b      	cbz	r3, 6376 <ip_route+0x1a>
    636a:	f893 2031 	ldrb.w	r2, [r3, #49]	; 0x31
    636e:	f012 0f01 	tst.w	r2, #1
    6372:	bf18      	it	ne
    6374:	4618      	movne	r0, r3
		snmp_inc_ipoutnoroutes();
		return NULL;
	}
	/* no matching netif found, use default netif */
	return netif_default;
}
    6376:	4770      	bx	lr
		if (netif_is_up(netif)) {
    6378:	f890 2031 	ldrb.w	r2, [r0, #49]	; 0x31
    637c:	07d2      	lsls	r2, r2, #31
    637e:	d505      	bpl.n	638c <ip_route+0x30>
			if (ip_addr_netcmp(dest, &(netif->ip_addr), &(netif->netmask))) {
    6380:	6841      	ldr	r1, [r0, #4]
    6382:	681a      	ldr	r2, [r3, #0]
    6384:	404a      	eors	r2, r1
    6386:	6881      	ldr	r1, [r0, #8]
    6388:	420a      	tst	r2, r1
    638a:	d0f4      	beq.n	6376 <ip_route+0x1a>
	for (netif = netif_list; netif != NULL; netif = netif->next) {
    638c:	6800      	ldr	r0, [r0, #0]
    638e:	e7e8      	b.n	6362 <ip_route+0x6>
    6390:	200163e4 	.word	0x200163e4
    6394:	200163ec 	.word	0x200163ec

00006398 <ip_input>:
 * @param inp the netif on which this packet was received
 * @return ERR_OK if the packet was processed (could return ERR_* if it wasn't
 *         processed, but currently always returns ERR_OK)
 */
err_t ip_input(struct pbuf *p, struct netif *inp)
{
    6398:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}

	IP_STATS_INC(ip.recv);
	snmp_inc_ipinreceives();

	/* identify the IP header */
	iphdr = (struct ip_hdr *)p->payload;
    639c:	6846      	ldr	r6, [r0, #4]
	if (IPH_V(iphdr) != 4) {
    639e:	f896 9000 	ldrb.w	r9, [r6]
    63a2:	ea4f 1319 	mov.w	r3, r9, lsr #4
    63a6:	2b04      	cmp	r3, #4
{
    63a8:	4604      	mov	r4, r0
    63aa:	4688      	mov	r8, r1
	if (IPH_V(iphdr) != 4) {
    63ac:	d005      	beq.n	63ba <ip_input+0x22>
		LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_LEVEL_WARNING,
		            ("IP packet dropped due to bad version number %" U16_F "\n", IPH_V(iphdr)));
		ip_debug_print(p);
		pbuf_free(p);
    63ae:	4b4c      	ldr	r3, [pc, #304]	; (64e0 <ip_input+0x148>)
    63b0:	4620      	mov	r0, r4
    63b2:	4798      	blx	r3
	current_header = NULL;
	ip_addr_set_any(&current_iphdr_src);
	ip_addr_set_any(&current_iphdr_dest);

	return ERR_OK;
}
    63b4:	2000      	movs	r0, #0
    63b6:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
	iphdr_len = ntohs(IPH_LEN(iphdr));
    63ba:	4b4a      	ldr	r3, [pc, #296]	; (64e4 <ip_input+0x14c>)
    63bc:	8870      	ldrh	r0, [r6, #2]
    63be:	4798      	blx	r3
	iphdr_hlen = IPH_HL(iphdr);
    63c0:	f009 090f 	and.w	r9, r9, #15
	if ((iphdr_hlen > p->len) || (iphdr_len > p->tot_len)) {
    63c4:	8963      	ldrh	r3, [r4, #10]
	iphdr_hlen *= 4;
    63c6:	ea4f 0989 	mov.w	r9, r9, lsl #2
	if ((iphdr_hlen > p->len) || (iphdr_len > p->tot_len)) {
    63ca:	454b      	cmp	r3, r9
	iphdr_len = ntohs(IPH_LEN(iphdr));
    63cc:	4605      	mov	r5, r0
	if ((iphdr_hlen > p->len) || (iphdr_len > p->tot_len)) {
    63ce:	d3ee      	bcc.n	63ae <ip_input+0x16>
    63d0:	8923      	ldrh	r3, [r4, #8]
    63d2:	4283      	cmp	r3, r0
    63d4:	d3eb      	bcc.n	63ae <ip_input+0x16>
	if (inet_chksum(iphdr, iphdr_hlen) != 0) {
    63d6:	4b44      	ldr	r3, [pc, #272]	; (64e8 <ip_input+0x150>)
    63d8:	4649      	mov	r1, r9
    63da:	4630      	mov	r0, r6
    63dc:	4798      	blx	r3
    63de:	2800      	cmp	r0, #0
    63e0:	d1e5      	bne.n	63ae <ip_input+0x16>
	pbuf_realloc(p, iphdr_len);
    63e2:	4b42      	ldr	r3, [pc, #264]	; (64ec <ip_input+0x154>)
				netif = netif_list;
    63e4:	f8df b124 	ldr.w	fp, [pc, #292]	; 650c <ip_input+0x174>
	pbuf_realloc(p, iphdr_len);
    63e8:	4629      	mov	r1, r5
    63ea:	4620      	mov	r0, r4
	ip_addr_copy(current_iphdr_dest, iphdr->dest);
    63ec:	4d40      	ldr	r5, [pc, #256]	; (64f0 <ip_input+0x158>)
	pbuf_realloc(p, iphdr_len);
    63ee:	4798      	blx	r3
	ip_addr_copy(current_iphdr_dest, iphdr->dest);
    63f0:	6933      	ldr	r3, [r6, #16]
    63f2:	602b      	str	r3, [r5, #0]
	ip_addr_copy(current_iphdr_src, iphdr->src);
    63f4:	68f3      	ldr	r3, [r6, #12]
    63f6:	606b      	str	r3, [r5, #4]
				    ip_addr_isbroadcast(&current_iphdr_dest, netif)) {
    63f8:	4b3e      	ldr	r3, [pc, #248]	; (64f4 <ip_input+0x15c>)
	ip_addr_copy(current_iphdr_src, iphdr->src);
    63fa:	4647      	mov	r7, r8
		int first = 1;
    63fc:	f04f 0a01 	mov.w	sl, #1
			if ((netif_is_up(netif)) && (!ip_addr_isany(&(netif->ip_addr)))) {
    6400:	f897 2031 	ldrb.w	r2, [r7, #49]	; 0x31
    6404:	07d2      	lsls	r2, r2, #31
    6406:	d404      	bmi.n	6412 <ip_input+0x7a>
			if (first) {
    6408:	f1ba 0f00 	cmp.w	sl, #0
    640c:	d132      	bne.n	6474 <ip_input+0xdc>
				netif = netif->next;
    640e:	683f      	ldr	r7, [r7, #0]
    6410:	e032      	b.n	6478 <ip_input+0xe0>
			if ((netif_is_up(netif)) && (!ip_addr_isany(&(netif->ip_addr)))) {
    6412:	687a      	ldr	r2, [r7, #4]
    6414:	2a00      	cmp	r2, #0
    6416:	d0f7      	beq.n	6408 <ip_input+0x70>
				if (ip_addr_cmp(&current_iphdr_dest, &(netif->ip_addr)) ||
    6418:	6828      	ldr	r0, [r5, #0]
    641a:	4282      	cmp	r2, r0
    641c:	d004      	beq.n	6428 <ip_input+0x90>
				    ip_addr_isbroadcast(&current_iphdr_dest, netif)) {
    641e:	4639      	mov	r1, r7
    6420:	4798      	blx	r3
				if (ip_addr_cmp(&current_iphdr_dest, &(netif->ip_addr)) ||
    6422:	4b34      	ldr	r3, [pc, #208]	; (64f4 <ip_input+0x15c>)
    6424:	2800      	cmp	r0, #0
    6426:	d0ef      	beq.n	6408 <ip_input+0x70>
	if (check_ip_src && !ip_addr_isany(&current_iphdr_src))
    6428:	6868      	ldr	r0, [r5, #4]
    642a:	b148      	cbz	r0, 6440 <ip_input+0xa8>
		if ((ip_addr_isbroadcast(&current_iphdr_src, inp)) || (ip_addr_ismulticast(&current_iphdr_src))) {
    642c:	4b31      	ldr	r3, [pc, #196]	; (64f4 <ip_input+0x15c>)
    642e:	4641      	mov	r1, r8
    6430:	4798      	blx	r3
    6432:	2800      	cmp	r0, #0
    6434:	d1bb      	bne.n	63ae <ip_input+0x16>
    6436:	686b      	ldr	r3, [r5, #4]
    6438:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
    643c:	2be0      	cmp	r3, #224	; 0xe0
    643e:	d0b6      	beq.n	63ae <ip_input+0x16>
	if (netif == NULL) {
    6440:	2f00      	cmp	r7, #0
    6442:	d0b4      	beq.n	63ae <ip_input+0x16>
	if ((IPH_OFFSET(iphdr) & PP_HTONS(IP_OFFMASK | IP_MF)) != 0) {
    6444:	88f3      	ldrh	r3, [r6, #6]
    6446:	f023 03c0 	bic.w	r3, r3, #192	; 0xc0
    644a:	b133      	cbz	r3, 645a <ip_input+0xc2>
		p = ip_reass(p);
    644c:	4620      	mov	r0, r4
    644e:	4b2a      	ldr	r3, [pc, #168]	; (64f8 <ip_input+0x160>)
    6450:	4798      	blx	r3
		if (p == NULL) {
    6452:	4604      	mov	r4, r0
    6454:	2800      	cmp	r0, #0
    6456:	d0ad      	beq.n	63b4 <ip_input+0x1c>
		iphdr = (struct ip_hdr *)p->payload;
    6458:	6846      	ldr	r6, [r0, #4]
		switch (IPH_PROTO(iphdr)) {
    645a:	7a73      	ldrb	r3, [r6, #9]
    645c:	2b06      	cmp	r3, #6
	current_header = iphdr;
    645e:	e9c5 8602 	strd	r8, r6, [r5, #8]
		switch (IPH_PROTO(iphdr)) {
    6462:	d025      	beq.n	64b0 <ip_input+0x118>
    6464:	2b11      	cmp	r3, #17
    6466:	d019      	beq.n	649c <ip_input+0x104>
    6468:	2b01      	cmp	r3, #1
    646a:	d125      	bne.n	64b8 <ip_input+0x120>
			icmp_input(p, inp);
    646c:	4b23      	ldr	r3, [pc, #140]	; (64fc <ip_input+0x164>)
    646e:	4641      	mov	r1, r8
    6470:	4620      	mov	r0, r4
    6472:	e016      	b.n	64a2 <ip_input+0x10a>
				netif = netif_list;
    6474:	f8db 7000 	ldr.w	r7, [fp]
			if (netif == inp) {
    6478:	4547      	cmp	r7, r8
				netif = netif->next;
    647a:	bf08      	it	eq
    647c:	683f      	ldreq	r7, [r7, #0]
		} while (netif != NULL);
    647e:	f04f 0a00 	mov.w	sl, #0
    6482:	2f00      	cmp	r7, #0
    6484:	d1bc      	bne.n	6400 <ip_input+0x68>
		if (IPH_PROTO(iphdr) == IP_PROTO_UDP) {
    6486:	7a73      	ldrb	r3, [r6, #9]
    6488:	2b11      	cmp	r3, #17
    648a:	d1cd      	bne.n	6428 <ip_input+0x90>
			if (IP_ACCEPT_LINK_LAYER_ADDRESSED_PORT(udphdr->dest)) {
    648c:	44b1      	add	r9, r6
    648e:	f8b9 3002 	ldrh.w	r3, [r9, #2]
    6492:	f5b3 4f88 	cmp.w	r3, #17408	; 0x4400
    6496:	d1c7      	bne.n	6428 <ip_input+0x90>
    6498:	4647      	mov	r7, r8
    649a:	e7d1      	b.n	6440 <ip_input+0xa8>
			udp_input(p, inp);
    649c:	4b18      	ldr	r3, [pc, #96]	; (6500 <ip_input+0x168>)
    649e:	4641      	mov	r1, r8
    64a0:	4620      	mov	r0, r4
			tcp_input(p, inp);
    64a2:	4798      	blx	r3
	current_netif  = NULL;
    64a4:	2300      	movs	r3, #0
	current_header = NULL;
    64a6:	e9c5 3302 	strd	r3, r3, [r5, #8]
	ip_addr_set_any(&current_iphdr_dest);
    64aa:	e9c5 3300 	strd	r3, r3, [r5]
	return ERR_OK;
    64ae:	e781      	b.n	63b4 <ip_input+0x1c>
			tcp_input(p, inp);
    64b0:	4b14      	ldr	r3, [pc, #80]	; (6504 <ip_input+0x16c>)
    64b2:	4641      	mov	r1, r8
    64b4:	4620      	mov	r0, r4
    64b6:	e7f4      	b.n	64a2 <ip_input+0x10a>
			if (!ip_addr_isbroadcast(&current_iphdr_dest, inp) && !ip_addr_ismulticast(&current_iphdr_dest)) {
    64b8:	6828      	ldr	r0, [r5, #0]
    64ba:	4b0e      	ldr	r3, [pc, #56]	; (64f4 <ip_input+0x15c>)
    64bc:	4641      	mov	r1, r8
    64be:	4798      	blx	r3
    64c0:	b948      	cbnz	r0, 64d6 <ip_input+0x13e>
    64c2:	682b      	ldr	r3, [r5, #0]
    64c4:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
    64c8:	2be0      	cmp	r3, #224	; 0xe0
    64ca:	d004      	beq.n	64d6 <ip_input+0x13e>
				icmp_dest_unreach(p, ICMP_DUR_PROTO);
    64cc:	4b0e      	ldr	r3, [pc, #56]	; (6508 <ip_input+0x170>)
				p->payload = iphdr;
    64ce:	6066      	str	r6, [r4, #4]
				icmp_dest_unreach(p, ICMP_DUR_PROTO);
    64d0:	2102      	movs	r1, #2
    64d2:	4620      	mov	r0, r4
    64d4:	4798      	blx	r3
			pbuf_free(p);
    64d6:	4b02      	ldr	r3, [pc, #8]	; (64e0 <ip_input+0x148>)
    64d8:	4620      	mov	r0, r4
    64da:	4798      	blx	r3
    64dc:	e7e2      	b.n	64a4 <ip_input+0x10c>
    64de:	bf00      	nop
    64e0:	000030e1 	.word	0x000030e1
    64e4:	00000d67 	.word	0x00000d67
    64e8:	00008419 	.word	0x00008419
    64ec:	00003249 	.word	0x00003249
    64f0:	20011104 	.word	0x20011104
    64f4:	00008a1f 	.word	0x00008a1f
    64f8:	00002b49 	.word	0x00002b49
    64fc:	00000c05 	.word	0x00000c05
    6500:	0000447d 	.word	0x0000447d
    6504:	00003c55 	.word	0x00003c55
    6508:	00000d49 	.word	0x00000d49
    650c:	200163e4 	.word	0x200163e4

00006510 <ip_output_if>:
 *
 * @note ip_id: RFC791 "some host may be able to simply use
 *  unique identifiers independent of destination"
 */
err_t ip_output_if(struct pbuf *p, ip_addr_t *src, ip_addr_t *dest, u8_t ttl, u8_t tos, u8_t proto, struct netif *netif)
{
    6510:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    6514:	b085      	sub	sp, #20
    6516:	4606      	mov	r6, r0
    6518:	f89d b038 	ldrb.w	fp, [sp, #56]	; 0x38
    651c:	f89d 903c 	ldrb.w	r9, [sp, #60]	; 0x3c
    6520:	f8dd 8040 	ldr.w	r8, [sp, #64]	; 0x40
    6524:	9101      	str	r1, [sp, #4]
    6526:	461c      	mov	r4, r3
	LWIP_ASSERT("p->ref == 1", p->ref == 1);

	snmp_inc_ipoutrequests();

	/* Should the IP header be generated or is it already included in p? */
	if (dest != IP_HDRINCL) {
    6528:	4617      	mov	r7, r2
    652a:	2a00      	cmp	r2, #0
    652c:	d050      	beq.n	65d0 <ip_output_if+0xc0>
			}
#endif /* CHECKSUM_GEN_IP_INLINE */
		}
#endif /* IP_OPTIONS_SEND */
		/* generate IP header */
		if (pbuf_header(p, IP_HLEN)) {
    652e:	4b2f      	ldr	r3, [pc, #188]	; (65ec <ip_output_if+0xdc>)
    6530:	2114      	movs	r1, #20
    6532:	4798      	blx	r3
    6534:	4682      	mov	sl, r0
    6536:	2800      	cmp	r0, #0
    6538:	d155      	bne.n	65e6 <ip_output_if+0xd6>
			IP_STATS_INC(ip.err);
			snmp_inc_ipoutdiscards();
			return ERR_BUF;
		}

		iphdr = (struct ip_hdr *)p->payload;
    653a:	6875      	ldr	r5, [r6, #4]
		LWIP_ASSERT("check that first pbuf can hold struct ip_hdr", (p->len >= sizeof(struct ip_hdr)));

		IPH_TTL_SET(iphdr, ttl);
    653c:	722c      	strb	r4, [r5, #8]
		IPH_PROTO_SET(iphdr, proto);
    653e:	f885 9009 	strb.w	r9, [r5, #9]
#if CHECKSUM_GEN_IP_INLINE
		chk_sum += LWIP_MAKE_U16(proto, ttl);
#endif /* CHECKSUM_GEN_IP_INLINE */

		/* dest cannot be NULL here */
		ip_addr_copy(iphdr->dest, *dest);
    6542:	683b      	ldr	r3, [r7, #0]
		chk_sum += ip4_addr_get_u32(&iphdr->dest) & 0xFFFF;
		chk_sum += ip4_addr_get_u32(&iphdr->dest) >> 16;
#endif /* CHECKSUM_GEN_IP_INLINE */

		IPH_VHL_SET(iphdr, 4, ip_hlen / 4);
		IPH_TOS_SET(iphdr, tos);
    6544:	f885 b001 	strb.w	fp, [r5, #1]
		IPH_VHL_SET(iphdr, 4, ip_hlen / 4);
    6548:	2245      	movs	r2, #69	; 0x45
#if CHECKSUM_GEN_IP_INLINE
		chk_sum += LWIP_MAKE_U16(tos, iphdr->_v_hl);
    654a:	ea4f 2b0b 	mov.w	fp, fp, lsl #8
    654e:	ea4b 0b02 	orr.w	fp, fp, r2
		chk_sum += LWIP_MAKE_U16(proto, ttl);
    6552:	ea44 2409 	orr.w	r4, r4, r9, lsl #8
		IPH_VHL_SET(iphdr, 4, ip_hlen / 4);
    6556:	702a      	strb	r2, [r5, #0]
		chk_sum += LWIP_MAKE_U16(tos, iphdr->_v_hl);
    6558:	445c      	add	r4, fp
    655a:	fa14 f483 	uxtah	r4, r4, r3
		ip_addr_copy(iphdr->dest, *dest);
    655e:	612b      	str	r3, [r5, #16]
#endif /* CHECKSUM_GEN_IP_INLINE */
		IPH_LEN_SET(iphdr, htons(p->tot_len));
    6560:	f8df b090 	ldr.w	fp, [pc, #144]	; 65f4 <ip_output_if+0xe4>
    6564:	8930      	ldrh	r0, [r6, #8]
		chk_sum += LWIP_MAKE_U16(tos, iphdr->_v_hl);
    6566:	eb04 4413 	add.w	r4, r4, r3, lsr #16
		IPH_LEN_SET(iphdr, htons(p->tot_len));
    656a:	47d8      	blx	fp
#if CHECKSUM_GEN_IP_INLINE
		chk_sum += iphdr->_len;
#endif /* CHECKSUM_GEN_IP_INLINE */
		IPH_OFFSET_SET(iphdr, 0);
    656c:	f885 a006 	strb.w	sl, [r5, #6]
    6570:	f885 a007 	strb.w	sl, [r5, #7]
		IPH_ID_SET(iphdr, htons(ip_id));
    6574:	f8df a080 	ldr.w	sl, [pc, #128]	; 65f8 <ip_output_if+0xe8>
		IPH_LEN_SET(iphdr, htons(p->tot_len));
    6578:	8068      	strh	r0, [r5, #2]
		chk_sum += iphdr->_len;
    657a:	4404      	add	r4, r0
		IPH_ID_SET(iphdr, htons(ip_id));
    657c:	f8ba 0010 	ldrh.w	r0, [sl, #16]
    6580:	47d8      	blx	fp
#if CHECKSUM_GEN_IP_INLINE
		chk_sum += iphdr->_id;
#endif /* CHECKSUM_GEN_IP_INLINE */
		++ip_id;
    6582:	f8ba 2010 	ldrh.w	r2, [sl, #16]
		IPH_ID_SET(iphdr, htons(ip_id));
    6586:	80a8      	strh	r0, [r5, #4]
		++ip_id;
    6588:	3201      	adds	r2, #1
    658a:	f8aa 2010 	strh.w	r2, [sl, #16]

		if (ip_addr_isany(src)) {
    658e:	9a01      	ldr	r2, [sp, #4]
		chk_sum += iphdr->_id;
    6590:	1903      	adds	r3, r0, r4
		if (ip_addr_isany(src)) {
    6592:	b10a      	cbz	r2, 6598 <ip_output_if+0x88>
    6594:	6812      	ldr	r2, [r2, #0]
    6596:	b90a      	cbnz	r2, 659c <ip_output_if+0x8c>
			ip_addr_copy(iphdr->src, netif->ip_addr);
    6598:	f8d8 2004 	ldr.w	r2, [r8, #4]
    659c:	60ea      	str	r2, [r5, #12]
			/* src cannot be NULL here */
			ip_addr_copy(iphdr->src, *src);
		}

#if CHECKSUM_GEN_IP_INLINE
		chk_sum += ip4_addr_get_u32(&iphdr->src) & 0xFFFF;
    659e:	fa13 f382 	uxtah	r3, r3, r2
		chk_sum += ip4_addr_get_u32(&iphdr->src) >> 16;
    65a2:	eb03 4312 	add.w	r3, r3, r2, lsr #16
		chk_sum        = (chk_sum >> 16) + (chk_sum & 0xFFFF);
    65a6:	b29a      	uxth	r2, r3
    65a8:	eb02 4313 	add.w	r3, r2, r3, lsr #16
		chk_sum        = (chk_sum >> 16) + chk_sum;
    65ac:	eb03 4313 	add.w	r3, r3, r3, lsr #16
		chk_sum        = ~chk_sum;
    65b0:	43db      	mvns	r3, r3
		iphdr->_chksum = chk_sum; /* network order */
    65b2:	816b      	strh	r3, [r5, #10]
	}
#endif /* LWIP_IGMP */
#endif /* ENABLE_LOOPBACK */
#if IP_FRAG
	/* don't fragment if interface has mtu set to 0 [loopif] */
	if (netif->mtu && (p->tot_len > netif->mtu)) {
    65b4:	f8b8 3028 	ldrh.w	r3, [r8, #40]	; 0x28
    65b8:	b17b      	cbz	r3, 65da <ip_output_if+0xca>
    65ba:	8932      	ldrh	r2, [r6, #8]
    65bc:	429a      	cmp	r2, r3
    65be:	d90c      	bls.n	65da <ip_output_if+0xca>
		return ip_frag(p, netif, dest);
    65c0:	4b0b      	ldr	r3, [pc, #44]	; (65f0 <ip_output_if+0xe0>)
    65c2:	463a      	mov	r2, r7
    65c4:	4641      	mov	r1, r8
    65c6:	4630      	mov	r0, r6
	}
#endif /* IP_FRAG */

	LWIP_DEBUGF(IP_DEBUG, ("netif->output()"));
	return netif->output(netif, p, dest);
    65c8:	4798      	blx	r3
}
    65ca:	b005      	add	sp, #20
    65cc:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		ip_addr_copy(dest_addr, iphdr->dest);
    65d0:	6843      	ldr	r3, [r0, #4]
    65d2:	691b      	ldr	r3, [r3, #16]
    65d4:	9303      	str	r3, [sp, #12]
		dest = &dest_addr;
    65d6:	af03      	add	r7, sp, #12
    65d8:	e7ec      	b.n	65b4 <ip_output_if+0xa4>
	return netif->output(netif, p, dest);
    65da:	f8d8 3014 	ldr.w	r3, [r8, #20]
    65de:	463a      	mov	r2, r7
    65e0:	4631      	mov	r1, r6
    65e2:	4640      	mov	r0, r8
    65e4:	e7f0      	b.n	65c8 <ip_output_if+0xb8>
			return ERR_BUF;
    65e6:	f06f 0001 	mvn.w	r0, #1
    65ea:	e7ee      	b.n	65ca <ip_output_if+0xba>
    65ec:	00003089 	.word	0x00003089
    65f0:	00002e31 	.word	0x00002e31
    65f4:	00000d61 	.word	0x00000d61
    65f8:	20011104 	.word	0x20011104

000065fc <ip_output>:
 *
 * @return ERR_RTE if no route is found
 *         see ip_output_if() for more return values
 */
err_t ip_output(struct pbuf *p, ip_addr_t *src, ip_addr_t *dest, u8_t ttl, u8_t tos, u8_t proto)
{
    65fc:	b530      	push	{r4, r5, lr}
    65fe:	b089      	sub	sp, #36	; 0x24
    6600:	4605      	mov	r5, r0

	/* pbufs passed to IP must have a ref-count of 1 as their payload pointer
	   gets altered as the packet is passed down the stack */
	LWIP_ASSERT("p->ref == 1", p->ref == 1);

	if ((netif = ip_route(dest)) == NULL) {
    6602:	4c0c      	ldr	r4, [pc, #48]	; (6634 <ip_output+0x38>)
    6604:	9205      	str	r2, [sp, #20]
    6606:	4610      	mov	r0, r2
{
    6608:	e9cd 3106 	strd	r3, r1, [sp, #24]
	if ((netif = ip_route(dest)) == NULL) {
    660c:	47a0      	blx	r4
    660e:	b170      	cbz	r0, 662e <ip_output+0x32>
		             ip4_addr4_16(dest)));
		IP_STATS_INC(ip.rterr);
		return ERR_RTE;
	}

	return ip_output_if(p, src, dest, ttl, tos, proto, netif);
    6610:	9002      	str	r0, [sp, #8]
    6612:	f89d 0034 	ldrb.w	r0, [sp, #52]	; 0x34
    6616:	9001      	str	r0, [sp, #4]
    6618:	f89d 0030 	ldrb.w	r0, [sp, #48]	; 0x30
    661c:	9000      	str	r0, [sp, #0]
    661e:	e9dd 2305 	ldrd	r2, r3, [sp, #20]
    6622:	9907      	ldr	r1, [sp, #28]
    6624:	4c04      	ldr	r4, [pc, #16]	; (6638 <ip_output+0x3c>)
    6626:	4628      	mov	r0, r5
    6628:	47a0      	blx	r4
}
    662a:	b009      	add	sp, #36	; 0x24
    662c:	bd30      	pop	{r4, r5, pc}
		return ERR_RTE;
    662e:	f06f 0003 	mvn.w	r0, #3
    6632:	e7fa      	b.n	662a <ip_output+0x2e>
    6634:	0000635d 	.word	0x0000635d
    6638:	00006511 	.word	0x00006511

0000663c <mem_init>:
	struct mem *mem;

	LWIP_ASSERT("Sanity check alignment", (SIZEOF_STRUCT_MEM & (MEM_ALIGNMENT - 1)) == 0);

	/* align the heap */
	ram = (u8_t *)LWIP_MEM_ALIGN(LWIP_RAM_HEAP_POINTER);
    663c:	4b0c      	ldr	r3, [pc, #48]	; (6670 <mem_init+0x34>)
    663e:	480d      	ldr	r0, [pc, #52]	; (6674 <mem_init+0x38>)
    6640:	f023 0303 	bic.w	r3, r3, #3
	/* initialize the start of the heap */
	mem       = (struct mem *)(void *)ram;
	mem->next = MEM_SIZE_ALIGNED;
    6644:	f44f 5260 	mov.w	r2, #14336	; 0x3800
    6648:	601a      	str	r2, [r3, #0]
	mem->prev = 0;
	mem->used = 0;
    664a:	2200      	movs	r2, #0
    664c:	711a      	strb	r2, [r3, #4]
	/* initialize the end of the heap */
	ram_end       = (struct mem *)(void *)&ram[MEM_SIZE_ALIGNED];
    664e:	f503 5260 	add.w	r2, r3, #14336	; 0x3800
    6652:	6042      	str	r2, [r0, #4]
	ram_end->used = 1;
	ram_end->next = MEM_SIZE_ALIGNED;
    6654:	f503 5240 	add.w	r2, r3, #12288	; 0x3000
    6658:	f04f 2138 	mov.w	r1, #939538432	; 0x38003800
    665c:	f8c2 1800 	str.w	r1, [r2, #2048]	; 0x800
	ram_end->used = 1;
    6660:	2101      	movs	r1, #1
	ram = (u8_t *)LWIP_MEM_ALIGN(LWIP_RAM_HEAP_POINTER);
    6662:	6003      	str	r3, [r0, #0]
	ram_end->prev = MEM_SIZE_ALIGNED;

	/* initialize the lowest-free pointer to the start of the heap */
	lfree = (struct mem *)(void *)ram;
    6664:	6083      	str	r3, [r0, #8]
	ram_end->used = 1;
    6666:	f882 1804 	strb.w	r1, [r2, #2052]	; 0x804

	MEM_STATS_AVAIL(avail, MEM_SIZE_ALIGNED);

	if (sys_mutex_new(&mem_mutex) != ERR_OK) {
    666a:	4b03      	ldr	r3, [pc, #12]	; (6678 <mem_init+0x3c>)
    666c:	300c      	adds	r0, #12
    666e:	4718      	bx	r3
    6670:	2001112b 	.word	0x2001112b
    6674:	20011118 	.word	0x20011118
    6678:	000079ad 	.word	0x000079ad

0000667c <mem_free>:
 *
 * @param rmem is the data portion of a struct mem as returned by a previous
 *             call to mem_malloc()
 */
void mem_free(void *rmem)
{
    667c:	b570      	push	{r4, r5, r6, lr}
	struct mem *mem;
	LWIP_MEM_FREE_DECL_PROTECT();

	if (rmem == NULL) {
    667e:	4604      	mov	r4, r0
    6680:	2800      	cmp	r0, #0
    6682:	d041      	beq.n	6708 <mem_free+0x8c>
	}
	LWIP_ASSERT("mem_free: sanity check alignment", (((mem_ptr_t)rmem) & (MEM_ALIGNMENT - 1)) == 0);

	LWIP_ASSERT("mem_free: legal memory", (u8_t *)rmem >= (u8_t *)ram && (u8_t *)rmem < (u8_t *)ram_end);

	if ((u8_t *)rmem < (u8_t *)ram || (u8_t *)rmem >= (u8_t *)ram_end) {
    6684:	4d21      	ldr	r5, [pc, #132]	; (670c <mem_free+0x90>)
    6686:	682b      	ldr	r3, [r5, #0]
    6688:	4283      	cmp	r3, r0
    668a:	d83d      	bhi.n	6708 <mem_free+0x8c>
    668c:	686b      	ldr	r3, [r5, #4]
    668e:	4283      	cmp	r3, r0
    6690:	d93a      	bls.n	6708 <mem_free+0x8c>
		MEM_STATS_INC(illegal);
		SYS_ARCH_UNPROTECT(lev);
		return;
	}
	/* protect the heap from concurrent access */
	LWIP_MEM_FREE_PROTECT();
    6692:	4b1f      	ldr	r3, [pc, #124]	; (6710 <mem_free+0x94>)
    6694:	2100      	movs	r1, #0
    6696:	f105 000c 	add.w	r0, r5, #12
    669a:	4798      	blx	r3
	/* Get the corresponding struct mem ... */
	mem = (struct mem *)(void *)((u8_t *)rmem - SIZEOF_STRUCT_MEM);
	/* ... which has to be in a used state ... */
	LWIP_ASSERT("mem_free: mem->used", mem->used);
	/* ... and is now unused. */
	mem->used = 0;
    669c:	2300      	movs	r3, #0
    669e:	f804 3c04 	strb.w	r3, [r4, #-4]

	if (mem < lfree) {
    66a2:	68ab      	ldr	r3, [r5, #8]
	nmem = (struct mem *)(void *)&ram[mem->next];
    66a4:	f834 0c08 	ldrh.w	r0, [r4, #-8]
	mem = (struct mem *)(void *)((u8_t *)rmem - SIZEOF_STRUCT_MEM);
    66a8:	f1a4 0208 	sub.w	r2, r4, #8
	if (mem < lfree) {
    66ac:	4293      	cmp	r3, r2
	nmem = (struct mem *)(void *)&ram[mem->next];
    66ae:	682b      	ldr	r3, [r5, #0]
		/* the newly freed struct is now the lowest */
		lfree = mem;
    66b0:	bf88      	it	hi
    66b2:	60aa      	strhi	r2, [r5, #8]
	nmem = (struct mem *)(void *)&ram[mem->next];
    66b4:	1819      	adds	r1, r3, r0
	if (mem != nmem && nmem->used == 0 && (u8_t *)nmem != (u8_t *)ram_end) {
    66b6:	428a      	cmp	r2, r1
    66b8:	d00f      	beq.n	66da <mem_free+0x5e>
    66ba:	790e      	ldrb	r6, [r1, #4]
    66bc:	b96e      	cbnz	r6, 66da <mem_free+0x5e>
    66be:	686e      	ldr	r6, [r5, #4]
    66c0:	42b1      	cmp	r1, r6
    66c2:	d00a      	beq.n	66da <mem_free+0x5e>
		if (lfree == nmem) {
    66c4:	68ae      	ldr	r6, [r5, #8]
    66c6:	42b1      	cmp	r1, r6
		mem->next                                      = nmem->next;
    66c8:	5a19      	ldrh	r1, [r3, r0]
    66ca:	f824 1c08 	strh.w	r1, [r4, #-8]
		((struct mem *)(void *)&ram[nmem->next])->prev = (mem_size_t)((u8_t *)mem - ram);
    66ce:	5a19      	ldrh	r1, [r3, r0]
			lfree = mem;
    66d0:	bf08      	it	eq
    66d2:	60aa      	streq	r2, [r5, #8]
		((struct mem *)(void *)&ram[nmem->next])->prev = (mem_size_t)((u8_t *)mem - ram);
    66d4:	4419      	add	r1, r3
    66d6:	1ad0      	subs	r0, r2, r3
    66d8:	8048      	strh	r0, [r1, #2]
	pmem = (struct mem *)(void *)&ram[mem->prev];
    66da:	f834 1c06 	ldrh.w	r1, [r4, #-6]
    66de:	1858      	adds	r0, r3, r1
	if (pmem != mem && pmem->used == 0) {
    66e0:	4282      	cmp	r2, r0
    66e2:	d00c      	beq.n	66fe <mem_free+0x82>
    66e4:	7906      	ldrb	r6, [r0, #4]
    66e6:	b956      	cbnz	r6, 66fe <mem_free+0x82>
		if (lfree == mem) {
    66e8:	68ae      	ldr	r6, [r5, #8]
    66ea:	42b2      	cmp	r2, r6
		pmem->next                                    = mem->next;
    66ec:	f834 2c08 	ldrh.w	r2, [r4, #-8]
    66f0:	525a      	strh	r2, [r3, r1]
		((struct mem *)(void *)&ram[mem->next])->prev = (mem_size_t)((u8_t *)pmem - ram);
    66f2:	f834 2c08 	ldrh.w	r2, [r4, #-8]
			lfree = pmem;
    66f6:	bf08      	it	eq
    66f8:	60a8      	streq	r0, [r5, #8]
		((struct mem *)(void *)&ram[mem->next])->prev = (mem_size_t)((u8_t *)pmem - ram);
    66fa:	4413      	add	r3, r2
    66fc:	8059      	strh	r1, [r3, #2]
	plug_holes(mem);
#if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
	mem_free_count = 1;
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
	LWIP_MEM_FREE_UNPROTECT();
}
    66fe:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	LWIP_MEM_FREE_UNPROTECT();
    6702:	4804      	ldr	r0, [pc, #16]	; (6714 <mem_free+0x98>)
    6704:	4b04      	ldr	r3, [pc, #16]	; (6718 <mem_free+0x9c>)
    6706:	4718      	bx	r3
}
    6708:	bd70      	pop	{r4, r5, r6, pc}
    670a:	bf00      	nop
    670c:	20011118 	.word	0x20011118
    6710:	00007a3d 	.word	0x00007a3d
    6714:	20011124 	.word	0x20011124
    6718:	00007a1d 	.word	0x00007a1d

0000671c <mem_trim>:
 * @return for compatibility reasons: is always == rmem, at the moment
 *         or NULL if newsize is > old size, in which case rmem is NOT touched
 *         or freed!
 */
void *mem_trim(void *rmem, mem_size_t newsize)
{
    671c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	/* use the FREE_PROTECT here: it protects with sem OR SYS_ARCH_PROTECT */
	LWIP_MEM_FREE_DECL_PROTECT();

	/* Expand the size of the allocated memory region so that we can
	   adjust for alignment. */
	newsize = LWIP_MEM_ALIGN_SIZE(newsize);
    6720:	3103      	adds	r1, #3
    6722:	f64f 74fc 	movw	r4, #65532	; 0xfffc
    6726:	400c      	ands	r4, r1

	if (newsize < MIN_SIZE_ALIGNED) {
    6728:	2c0b      	cmp	r4, #11
{
    672a:	4605      	mov	r5, r0
	if (newsize < MIN_SIZE_ALIGNED) {
    672c:	d904      	bls.n	6738 <mem_trim+0x1c>
		/* every data block must be at least MIN_SIZE_ALIGNED long */
		newsize = MIN_SIZE_ALIGNED;
	}

	if (newsize > MEM_SIZE_ALIGNED) {
    672e:	f5b4 5f60 	cmp.w	r4, #14336	; 0x3800
    6732:	d902      	bls.n	673a <mem_trim+0x1e>
		return NULL;
    6734:	2500      	movs	r5, #0
    6736:	e03e      	b.n	67b6 <mem_trim+0x9a>
		newsize = MIN_SIZE_ALIGNED;
    6738:	240c      	movs	r4, #12
	}

	LWIP_ASSERT("mem_trim: legal memory", (u8_t *)rmem >= (u8_t *)ram && (u8_t *)rmem < (u8_t *)ram_end);

	if ((u8_t *)rmem < (u8_t *)ram || (u8_t *)rmem >= (u8_t *)ram_end) {
    673a:	4f2f      	ldr	r7, [pc, #188]	; (67f8 <mem_trim+0xdc>)
    673c:	683b      	ldr	r3, [r7, #0]
    673e:	42ab      	cmp	r3, r5
    6740:	d839      	bhi.n	67b6 <mem_trim+0x9a>
    6742:	687a      	ldr	r2, [r7, #4]
    6744:	42aa      	cmp	r2, r5
    6746:	d936      	bls.n	67b6 <mem_trim+0x9a>
	/* Get the corresponding struct mem ... */
	mem = (struct mem *)(void *)((u8_t *)rmem - SIZEOF_STRUCT_MEM);
	/* ... and its offset pointer */
	ptr = (mem_size_t)((u8_t *)mem - ram);

	size = mem->next - ptr - SIZEOF_STRUCT_MEM;
    6748:	f835 8c08 	ldrh.w	r8, [r5, #-8]
	mem = (struct mem *)(void *)((u8_t *)rmem - SIZEOF_STRUCT_MEM);
    674c:	f1a5 0608 	sub.w	r6, r5, #8
	ptr = (mem_size_t)((u8_t *)mem - ram);
    6750:	1af6      	subs	r6, r6, r3
    6752:	b2b6      	uxth	r6, r6
	size = mem->next - ptr - SIZEOF_STRUCT_MEM;
    6754:	f1a8 0808 	sub.w	r8, r8, #8
    6758:	eba8 0806 	sub.w	r8, r8, r6
    675c:	fa1f f888 	uxth.w	r8, r8
	LWIP_ASSERT("mem_trim can only shrink memory", newsize <= size);
	if (newsize > size) {
    6760:	45a0      	cmp	r8, r4
    6762:	d3e7      	bcc.n	6734 <mem_trim+0x18>
		/* not supported */
		return NULL;
	}
	if (newsize == size) {
    6764:	d027      	beq.n	67b6 <mem_trim+0x9a>
		/* No change in size, simply return */
		return rmem;
	}

	/* protect the heap from concurrent access */
	LWIP_MEM_FREE_PROTECT();
    6766:	4b25      	ldr	r3, [pc, #148]	; (67fc <mem_trim+0xe0>)
    6768:	2100      	movs	r1, #0
    676a:	f107 000c 	add.w	r0, r7, #12
    676e:	4798      	blx	r3

	mem2 = (struct mem *)(void *)&ram[mem->next];
    6770:	683b      	ldr	r3, [r7, #0]
    6772:	f835 1c08 	ldrh.w	r1, [r5, #-8]
    6776:	1858      	adds	r0, r3, r1
	if (mem2->used == 0) {
    6778:	7902      	ldrb	r2, [r0, #4]
    677a:	b9fa      	cbnz	r2, 67bc <mem_trim+0xa0>
		/* The next struct is unused, we can simply move it at little */
		mem_size_t next;
		/* remember the old next pointer */
		next = mem2->next;
		/* create new struct mem which is moved directly after the shrinked mem */
		ptr2 = ptr + SIZEOF_STRUCT_MEM + newsize;
    677c:	f106 0208 	add.w	r2, r6, #8
    6780:	4414      	add	r4, r2
		if (lfree == mem2) {
    6782:	68ba      	ldr	r2, [r7, #8]
		next = mem2->next;
    6784:	f833 c001 	ldrh.w	ip, [r3, r1]
		ptr2 = ptr + SIZEOF_STRUCT_MEM + newsize;
    6788:	b2a1      	uxth	r1, r4
			lfree = (struct mem *)(void *)&ram[ptr2];
    678a:	fa13 f484 	uxtah	r4, r3, r4
		if (lfree == mem2) {
    678e:	4282      	cmp	r2, r0
		}
		mem2       = (struct mem *)(void *)&ram[ptr2];
		mem2->used = 0;
    6790:	f04f 0200 	mov.w	r2, #0
    6794:	7122      	strb	r2, [r4, #4]
		/* restore the next pointer */
		mem2->next = next;
    6796:	f823 c001 	strh.w	ip, [r3, r1]
		/* link it back to mem */
		mem2->prev = ptr;
    679a:	8066      	strh	r6, [r4, #2]
		/* link mem to it */
		mem->next = ptr2;
    679c:	f825 1c08 	strh.w	r1, [r5, #-8]
		/* last thing to restore linked list: as we have moved mem2,
		 * let 'mem2->next->prev' point to mem2 again. but only if mem2->next is not
		 * the end of the heap */
		if (mem2->next != MEM_SIZE_ALIGNED) {
    67a0:	5a5a      	ldrh	r2, [r3, r1]
			lfree = (struct mem *)(void *)&ram[ptr2];
    67a2:	bf08      	it	eq
    67a4:	60bc      	streq	r4, [r7, #8]
		if (mem2->next != MEM_SIZE_ALIGNED) {
    67a6:	f5b2 5f60 	cmp.w	r2, #14336	; 0x3800
    67aa:	d001      	beq.n	67b0 <mem_trim+0x94>
			((struct mem *)(void *)&ram[mem2->next])->prev = ptr2;
    67ac:	4413      	add	r3, r2
    67ae:	8059      	strh	r1, [r3, #2]
		  -> the remaining space stays unused since it is too small
		} */
#if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
	mem_free_count = 1;
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
	LWIP_MEM_FREE_UNPROTECT();
    67b0:	4813      	ldr	r0, [pc, #76]	; (6800 <mem_trim+0xe4>)
    67b2:	4b14      	ldr	r3, [pc, #80]	; (6804 <mem_trim+0xe8>)
    67b4:	4798      	blx	r3
	return rmem;
}
    67b6:	4628      	mov	r0, r5
    67b8:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	} else if (newsize + SIZEOF_STRUCT_MEM + MIN_SIZE_ALIGNED <= size) {
    67bc:	f104 0214 	add.w	r2, r4, #20
    67c0:	b292      	uxth	r2, r2
    67c2:	4590      	cmp	r8, r2
    67c4:	d3f4      	bcc.n	67b0 <mem_trim+0x94>
		ptr2 = ptr + SIZEOF_STRUCT_MEM + newsize;
    67c6:	f106 0208 	add.w	r2, r6, #8
		if (mem2 < lfree) {
    67ca:	68b8      	ldr	r0, [r7, #8]
		ptr2 = ptr + SIZEOF_STRUCT_MEM + newsize;
    67cc:	4414      	add	r4, r2
    67ce:	b2a2      	uxth	r2, r4
		mem2 = (struct mem *)(void *)&ram[ptr2];
    67d0:	fa13 f484 	uxtah	r4, r3, r4
		if (mem2 < lfree) {
    67d4:	42a0      	cmp	r0, r4
		mem2->used = 0;
    67d6:	f04f 0000 	mov.w	r0, #0
    67da:	7120      	strb	r0, [r4, #4]
		mem2->next = mem->next;
    67dc:	5299      	strh	r1, [r3, r2]
		mem2->prev = ptr;
    67de:	8066      	strh	r6, [r4, #2]
		mem->next  = ptr2;
    67e0:	f825 2c08 	strh.w	r2, [r5, #-8]
		if (mem2->next != MEM_SIZE_ALIGNED) {
    67e4:	5a99      	ldrh	r1, [r3, r2]
			lfree = mem2;
    67e6:	bf88      	it	hi
    67e8:	60bc      	strhi	r4, [r7, #8]
		if (mem2->next != MEM_SIZE_ALIGNED) {
    67ea:	f5b1 5f60 	cmp.w	r1, #14336	; 0x3800
			((struct mem *)(void *)&ram[mem2->next])->prev = ptr2;
    67ee:	bf1c      	itt	ne
    67f0:	185b      	addne	r3, r3, r1
    67f2:	805a      	strhne	r2, [r3, #2]
    67f4:	e7dc      	b.n	67b0 <mem_trim+0x94>
    67f6:	bf00      	nop
    67f8:	20011118 	.word	0x20011118
    67fc:	00007a3d 	.word	0x00007a3d
    6800:	20011124 	.word	0x20011124
    6804:	00007a1d 	.word	0x00007a1d

00006808 <mem_malloc>:
 * @return pointer to allocated memory or NULL if no free memory was found.
 *
 * Note that the returned value will always be aligned (as defined by MEM_ALIGNMENT).
 */
void *mem_malloc(mem_size_t size)
{
    6808:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
#if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
	u8_t        local_mem_free_count = 0;
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
	LWIP_MEM_ALLOC_DECL_PROTECT();

	if (size == 0) {
    680c:	2800      	cmp	r0, #0
    680e:	d050      	beq.n	68b2 <mem_malloc+0xaa>
		return NULL;
	}

	/* Expand the size of the allocated memory region so that we can
	   adjust for alignment. */
	size = LWIP_MEM_ALIGN_SIZE(size);
    6810:	3003      	adds	r0, #3
    6812:	f64f 75fc 	movw	r5, #65532	; 0xfffc
    6816:	4005      	ands	r5, r0

	if (size < MIN_SIZE_ALIGNED) {
    6818:	2d0b      	cmp	r5, #11
    681a:	d904      	bls.n	6826 <mem_malloc+0x1e>
		/* every data block must be at least MIN_SIZE_ALIGNED long */
		size = MIN_SIZE_ALIGNED;
	}

	if (size > MEM_SIZE_ALIGNED) {
    681c:	f5b5 5f60 	cmp.w	r5, #14336	; 0x3800
    6820:	d902      	bls.n	6828 <mem_malloc+0x20>
		return NULL;
    6822:	2000      	movs	r0, #0
    6824:	e045      	b.n	68b2 <mem_malloc+0xaa>
		size = MIN_SIZE_ALIGNED;
    6826:	250c      	movs	r5, #12
		return NULL;
	}

	/* protect the heap from concurrent access */
	sys_mutex_lock(&mem_mutex);
    6828:	4e27      	ldr	r6, [pc, #156]	; (68c8 <mem_malloc+0xc0>)
    682a:	4b28      	ldr	r3, [pc, #160]	; (68cc <mem_malloc+0xc4>)
    682c:	2100      	movs	r1, #0
    682e:	f106 000c 	add.w	r0, r6, #12
    6832:	4798      	blx	r3
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */

		/* Scan through the heap searching for a free block that is big enough,
		 * beginning with the lowest free block.
		 */
		for (ptr = (mem_size_t)((u8_t *)lfree - ram); ptr < MEM_SIZE_ALIGNED - size;
    6834:	68b2      	ldr	r2, [r6, #8]
    6836:	6831      	ldr	r1, [r6, #0]
    6838:	1a53      	subs	r3, r2, r1
    683a:	b29b      	uxth	r3, r3
    683c:	f5c5 5e60 	rsb	lr, r5, #14336	; 0x3800
				local_mem_free_count = 1;
				break;
			}
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */

			if ((!mem->used) && (mem->next - (ptr + SIZEOF_STRUCT_MEM)) >= size) {
    6840:	f06f 0807 	mvn.w	r8, #7
		for (ptr = (mem_size_t)((u8_t *)lfree - ram); ptr < MEM_SIZE_ALIGNED - size;
    6844:	4573      	cmp	r3, lr
    6846:	db03      	blt.n	6850 <mem_malloc+0x48>
	} while (local_mem_free_count != 0);
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
	LWIP_DEBUGF(MEM_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("mem_malloc: could not allocate %" S16_F " bytes\n", (s16_t)size));
	MEM_STATS_INC(err);
	LWIP_MEM_ALLOC_UNPROTECT();
	sys_mutex_unlock(&mem_mutex);
    6848:	4821      	ldr	r0, [pc, #132]	; (68d0 <mem_malloc+0xc8>)
    684a:	4b22      	ldr	r3, [pc, #136]	; (68d4 <mem_malloc+0xcc>)
    684c:	4798      	blx	r3
	return NULL;
    684e:	e7e8      	b.n	6822 <mem_malloc+0x1a>
			mem            = (struct mem *)(void *)&ram[ptr];
    6850:	18cc      	adds	r4, r1, r3
			if ((!mem->used) && (mem->next - (ptr + SIZEOF_STRUCT_MEM)) >= size) {
    6852:	5ac8      	ldrh	r0, [r1, r3]
    6854:	f894 c004 	ldrb.w	ip, [r4, #4]
    6858:	f1bc 0f00 	cmp.w	ip, #0
    685c:	d131      	bne.n	68c2 <mem_malloc+0xba>
    685e:	eba8 0703 	sub.w	r7, r8, r3
    6862:	4407      	add	r7, r0
    6864:	42af      	cmp	r7, r5
    6866:	d32c      	bcc.n	68c2 <mem_malloc+0xba>
				if (mem->next - (ptr + SIZEOF_STRUCT_MEM) >= (size + SIZEOF_STRUCT_MEM + MIN_SIZE_ALIGNED)) {
    6868:	f105 0e14 	add.w	lr, r5, #20
    686c:	fa1f fe8e 	uxth.w	lr, lr
    6870:	4577      	cmp	r7, lr
    6872:	d320      	bcc.n	68b6 <mem_malloc+0xae>
					ptr2 = ptr + SIZEOF_STRUCT_MEM + size;
    6874:	3508      	adds	r5, #8
    6876:	441d      	add	r5, r3
    6878:	b2af      	uxth	r7, r5
					mem2       = (struct mem *)(void *)&ram[ptr2];
    687a:	fa11 f585 	uxtah	r5, r1, r5
					mem2->used = 0;
    687e:	f885 c004 	strb.w	ip, [r5, #4]
					mem2->next = mem->next;
    6882:	53c8      	strh	r0, [r1, r7]
					mem2->prev = ptr;
    6884:	806b      	strh	r3, [r5, #2]
					mem->used = 1;
    6886:	2301      	movs	r3, #1
					mem->next = ptr2;
    6888:	8027      	strh	r7, [r4, #0]
					mem->used = 1;
    688a:	7123      	strb	r3, [r4, #4]
					if (mem2->next != MEM_SIZE_ALIGNED) {
    688c:	5bcb      	ldrh	r3, [r1, r7]
    688e:	f5b3 5f60 	cmp.w	r3, #14336	; 0x3800
    6892:	d001      	beq.n	6898 <mem_malloc+0x90>
						((struct mem *)(void *)&ram[mem2->next])->prev = ptr2;
    6894:	440b      	add	r3, r1
    6896:	805f      	strh	r7, [r3, #2]
				if (mem == lfree) {
    6898:	42a2      	cmp	r2, r4
    689a:	d105      	bne.n	68a8 <mem_malloc+0xa0>
					while (cur->used && cur != ram_end) {
    689c:	6873      	ldr	r3, [r6, #4]
    689e:	7910      	ldrb	r0, [r2, #4]
    68a0:	b108      	cbz	r0, 68a6 <mem_malloc+0x9e>
    68a2:	4293      	cmp	r3, r2
    68a4:	d10a      	bne.n	68bc <mem_malloc+0xb4>
					lfree = cur;
    68a6:	60b2      	str	r2, [r6, #8]
				sys_mutex_unlock(&mem_mutex);
    68a8:	4809      	ldr	r0, [pc, #36]	; (68d0 <mem_malloc+0xc8>)
    68aa:	4b0a      	ldr	r3, [pc, #40]	; (68d4 <mem_malloc+0xcc>)
    68ac:	4798      	blx	r3
				return (u8_t *)mem + SIZEOF_STRUCT_MEM;
    68ae:	f104 0008 	add.w	r0, r4, #8
}
    68b2:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
					mem->used = 1;
    68b6:	2301      	movs	r3, #1
    68b8:	7123      	strb	r3, [r4, #4]
    68ba:	e7ed      	b.n	6898 <mem_malloc+0x90>
						cur = (struct mem *)(void *)&ram[cur->next];
    68bc:	8812      	ldrh	r2, [r2, #0]
    68be:	440a      	add	r2, r1
    68c0:	e7ed      	b.n	689e <mem_malloc+0x96>
    68c2:	4603      	mov	r3, r0
    68c4:	e7be      	b.n	6844 <mem_malloc+0x3c>
    68c6:	bf00      	nop
    68c8:	20011118 	.word	0x20011118
    68cc:	00007a3d 	.word	0x00007a3d
    68d0:	20011124 	.word	0x20011124
    68d4:	00007a1d 	.word	0x00007a1d

000068d8 <tcp_accept_null>:
	LWIP_UNUSED_ARG(arg);
	LWIP_UNUSED_ARG(pcb);
	LWIP_UNUSED_ARG(err);

	return ERR_ABRT;
}
    68d8:	f06f 0009 	mvn.w	r0, #9
    68dc:	4770      	bx	lr
	...

000068e0 <tcp_new_port>:
 * Allocate a new local TCP port.
 *
 * @return a new (free) local TCP port number
 */
static u16_t tcp_new_port(void)
{
    68e0:	b5f0      	push	{r4, r5, r6, r7, lr}
    68e2:	4c12      	ldr	r4, [pc, #72]	; (692c <tcp_new_port+0x4c>)
    68e4:	8823      	ldrh	r3, [r4, #0]
    68e6:	f44f 4080 	mov.w	r0, #16384	; 0x4000
	u8_t            i;
	u16_t           n = 0;
	struct tcp_pcb *pcb;

again:
	if (tcp_port++ == TCP_LOCAL_PORT_RANGE_END) {
    68ea:	f64f 76ff 	movw	r6, #65535	; 0xffff
    68ee:	42b3      	cmp	r3, r6
    68f0:	bf18      	it	ne
    68f2:	3301      	addne	r3, #1
    68f4:	4d0e      	ldr	r5, [pc, #56]	; (6930 <tcp_new_port+0x50>)
    68f6:	bf14      	ite	ne
    68f8:	b29b      	uxthne	r3, r3
		tcp_port = TCP_LOCAL_PORT_RANGE_START;
    68fa:	f44f 4340 	moveq.w	r3, #49152	; 0xc000
    68fe:	2204      	movs	r2, #4
	}
	/* Check all PCB lists. */
	for (i = 0; i < NUM_TCP_PCB_LISTS; i++) {
		for (pcb = *tcp_pcb_lists[i]; pcb != NULL; pcb = pcb->next) {
    6900:	f855 1b04 	ldr.w	r1, [r5], #4
    6904:	6809      	ldr	r1, [r1, #0]
    6906:	b931      	cbnz	r1, 6916 <tcp_new_port+0x36>
	for (i = 0; i < NUM_TCP_PCB_LISTS; i++) {
    6908:	3a01      	subs	r2, #1
    690a:	f012 02ff 	ands.w	r2, r2, #255	; 0xff
    690e:	d1f7      	bne.n	6900 <tcp_new_port+0x20>
    6910:	8023      	strh	r3, [r4, #0]
				}
				goto again;
			}
		}
	}
	return tcp_port;
    6912:	4618      	mov	r0, r3
    6914:	e007      	b.n	6926 <tcp_new_port+0x46>
			if (pcb->local_port == tcp_port) {
    6916:	8b4f      	ldrh	r7, [r1, #26]
    6918:	429f      	cmp	r7, r3
    691a:	d105      	bne.n	6928 <tcp_new_port+0x48>
				if (++n > (TCP_LOCAL_PORT_RANGE_END - TCP_LOCAL_PORT_RANGE_START)) {
    691c:	3801      	subs	r0, #1
    691e:	b280      	uxth	r0, r0
    6920:	2800      	cmp	r0, #0
    6922:	d1e4      	bne.n	68ee <tcp_new_port+0xe>
    6924:	8023      	strh	r3, [r4, #0]
}
    6926:	bdf0      	pop	{r4, r5, r6, r7, pc}
		for (pcb = *tcp_pcb_lists[i]; pcb != NULL; pcb = pcb->next) {
    6928:	68c9      	ldr	r1, [r1, #12]
    692a:	e7ec      	b.n	6906 <tcp_new_port+0x26>
    692c:	2000000c 	.word	0x2000000c
    6930:	0000cad8 	.word	0x0000cad8

00006934 <tcp_init>:
}
    6934:	4770      	bx	lr
	...

00006938 <tcp_bind>:
{
    6938:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	LWIP_ERROR("tcp_bind: can only bind in state CLOSED", pcb->state == CLOSED, return ERR_VAL);
    693a:	7e03      	ldrb	r3, [r0, #24]
{
    693c:	4604      	mov	r4, r0
    693e:	460d      	mov	r5, r1
	LWIP_ERROR("tcp_bind: can only bind in state CLOSED", pcb->state == CLOSED, return ERR_VAL);
    6940:	b103      	cbz	r3, 6944 <tcp_bind+0xc>
    6942:	e7fe      	b.n	6942 <tcp_bind+0xa>
	if (port == 0) {
    6944:	b91a      	cbnz	r2, 694e <tcp_bind+0x16>
		port = tcp_new_port();
    6946:	4b16      	ldr	r3, [pc, #88]	; (69a0 <tcp_bind+0x68>)
    6948:	4798      	blx	r3
		if (port == 0) {
    694a:	4602      	mov	r2, r0
    694c:	b308      	cbz	r0, 6992 <tcp_bind+0x5a>
	for (i = 0; i < max_pcb_list; i++) {
    694e:	4815      	ldr	r0, [pc, #84]	; (69a4 <tcp_bind+0x6c>)
    6950:	2100      	movs	r1, #0
		for (cpcb = *tcp_pcb_lists[i]; cpcb != NULL; cpcb = cpcb->next) {
    6952:	f850 3b04 	ldr.w	r3, [r0], #4
    6956:	681b      	ldr	r3, [r3, #0]
    6958:	b97b      	cbnz	r3, 697a <tcp_bind+0x42>
	for (i = 0; i < max_pcb_list; i++) {
    695a:	3101      	adds	r1, #1
    695c:	2904      	cmp	r1, #4
    695e:	d1f8      	bne.n	6952 <tcp_bind+0x1a>
	if (!ip_addr_isany(ipaddr)) {
    6960:	b115      	cbz	r5, 6968 <tcp_bind+0x30>
    6962:	682b      	ldr	r3, [r5, #0]
    6964:	b103      	cbz	r3, 6968 <tcp_bind+0x30>
		pcb->local_ip = *ipaddr;
    6966:	6023      	str	r3, [r4, #0]
	TCP_REG(&tcp_bound_pcbs, pcb);
    6968:	4b0f      	ldr	r3, [pc, #60]	; (69a8 <tcp_bind+0x70>)
	pcb->local_port = port;
    696a:	8362      	strh	r2, [r4, #26]
	TCP_REG(&tcp_bound_pcbs, pcb);
    696c:	681a      	ldr	r2, [r3, #0]
    696e:	60e2      	str	r2, [r4, #12]
    6970:	601c      	str	r4, [r3, #0]
    6972:	4b0e      	ldr	r3, [pc, #56]	; (69ac <tcp_bind+0x74>)
    6974:	4798      	blx	r3
	return ERR_OK;
    6976:	2000      	movs	r0, #0
}
    6978:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
			if (cpcb->local_port == port) {
    697a:	8b5e      	ldrh	r6, [r3, #26]
    697c:	4296      	cmp	r6, r2
    697e:	d106      	bne.n	698e <tcp_bind+0x56>
					if (ip_addr_isany(&(cpcb->local_ip)) || ip_addr_isany(ipaddr)
    6980:	681f      	ldr	r7, [r3, #0]
    6982:	b14f      	cbz	r7, 6998 <tcp_bind+0x60>
    6984:	b145      	cbz	r5, 6998 <tcp_bind+0x60>
    6986:	682e      	ldr	r6, [r5, #0]
    6988:	b136      	cbz	r6, 6998 <tcp_bind+0x60>
					    || ip_addr_cmp(&(cpcb->local_ip), ipaddr)) {
    698a:	42b7      	cmp	r7, r6
    698c:	d004      	beq.n	6998 <tcp_bind+0x60>
		for (cpcb = *tcp_pcb_lists[i]; cpcb != NULL; cpcb = cpcb->next) {
    698e:	68db      	ldr	r3, [r3, #12]
    6990:	e7e2      	b.n	6958 <tcp_bind+0x20>
			return ERR_BUF;
    6992:	f06f 0001 	mvn.w	r0, #1
    6996:	e7ef      	b.n	6978 <tcp_bind+0x40>
						return ERR_USE;
    6998:	f06f 0007 	mvn.w	r0, #7
    699c:	e7ec      	b.n	6978 <tcp_bind+0x40>
    699e:	bf00      	nop
    69a0:	000068e1 	.word	0x000068e1
    69a4:	0000cad8 	.word	0x0000cad8
    69a8:	2001493c 	.word	0x2001493c
    69ac:	000010a1 	.word	0x000010a1

000069b0 <tcp_listen_with_backlog>:
{
    69b0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	LWIP_ERROR("tcp_listen: pcb already connected", pcb->state == CLOSED, return NULL);
    69b2:	7e07      	ldrb	r7, [r0, #24]
{
    69b4:	4604      	mov	r4, r0
	LWIP_ERROR("tcp_listen: pcb already connected", pcb->state == CLOSED, return NULL);
    69b6:	b107      	cbz	r7, 69ba <tcp_listen_with_backlog+0xa>
    69b8:	e7fe      	b.n	69b8 <tcp_listen_with_backlog+0x8>
	lpcb = (struct tcp_pcb_listen *)memp_malloc(MEMP_TCP_PCB_LISTEN);
    69ba:	4b1f      	ldr	r3, [pc, #124]	; (6a38 <tcp_listen_with_backlog+0x88>)
    69bc:	2002      	movs	r0, #2
    69be:	4798      	blx	r3
	if (lpcb == NULL) {
    69c0:	4605      	mov	r5, r0
    69c2:	b328      	cbz	r0, 6a10 <tcp_listen_with_backlog+0x60>
	lpcb->callback_arg = pcb->callback_arg;
    69c4:	6923      	ldr	r3, [r4, #16]
	lpcb->local_port   = pcb->local_port;
    69c6:	8b62      	ldrh	r2, [r4, #26]
	lpcb->callback_arg = pcb->callback_arg;
    69c8:	6103      	str	r3, [r0, #16]
	lpcb->state        = LISTEN;
    69ca:	2301      	movs	r3, #1
    69cc:	7603      	strb	r3, [r0, #24]
	lpcb->local_port   = pcb->local_port;
    69ce:	8342      	strh	r2, [r0, #26]
	lpcb->prio         = pcb->prio;
    69d0:	7e63      	ldrb	r3, [r4, #25]
    69d2:	7643      	strb	r3, [r0, #25]
	ip_set_option(lpcb, SOF_ACCEPTCONN);
    69d4:	7a23      	ldrb	r3, [r4, #8]
    69d6:	4e19      	ldr	r6, [pc, #100]	; (6a3c <tcp_listen_with_backlog+0x8c>)
    69d8:	f043 0302 	orr.w	r3, r3, #2
    69dc:	7203      	strb	r3, [r0, #8]
	lpcb->ttl = pcb->ttl;
    69de:	7aa3      	ldrb	r3, [r4, #10]
    69e0:	7283      	strb	r3, [r0, #10]
	lpcb->tos = pcb->tos;
    69e2:	7a63      	ldrb	r3, [r4, #9]
    69e4:	7243      	strb	r3, [r0, #9]
	ip_addr_copy(lpcb->local_ip, pcb->local_ip);
    69e6:	6823      	ldr	r3, [r4, #0]
    69e8:	6003      	str	r3, [r0, #0]
	if (pcb->local_port != 0) {
    69ea:	b132      	cbz	r2, 69fa <tcp_listen_with_backlog+0x4a>
		TCP_RMV(&tcp_bound_pcbs, pcb);
    69ec:	6833      	ldr	r3, [r6, #0]
    69ee:	42a3      	cmp	r3, r4
    69f0:	d110      	bne.n	6a14 <tcp_listen_with_backlog+0x64>
    69f2:	68e3      	ldr	r3, [r4, #12]
    69f4:	6033      	str	r3, [r6, #0]
    69f6:	2300      	movs	r3, #0
    69f8:	60e3      	str	r3, [r4, #12]
	memp_free(MEMP_TCP_PCB, pcb);
    69fa:	4b11      	ldr	r3, [pc, #68]	; (6a40 <tcp_listen_with_backlog+0x90>)
    69fc:	4621      	mov	r1, r4
    69fe:	2001      	movs	r0, #1
    6a00:	4798      	blx	r3
	lpcb->accept = tcp_accept_null;
    6a02:	4b10      	ldr	r3, [pc, #64]	; (6a44 <tcp_listen_with_backlog+0x94>)
    6a04:	616b      	str	r3, [r5, #20]
	TCP_REG(&tcp_listen_pcbs.pcbs, (struct tcp_pcb *)lpcb);
    6a06:	68b3      	ldr	r3, [r6, #8]
    6a08:	60eb      	str	r3, [r5, #12]
    6a0a:	4b0f      	ldr	r3, [pc, #60]	; (6a48 <tcp_listen_with_backlog+0x98>)
    6a0c:	60b5      	str	r5, [r6, #8]
    6a0e:	4798      	blx	r3
}
    6a10:	4628      	mov	r0, r5
    6a12:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		TCP_RMV(&tcp_bound_pcbs, pcb);
    6a14:	6073      	str	r3, [r6, #4]
    6a16:	b91b      	cbnz	r3, 6a20 <tcp_listen_with_backlog+0x70>
    6a18:	2f00      	cmp	r7, #0
    6a1a:	d0ec      	beq.n	69f6 <tcp_listen_with_backlog+0x46>
    6a1c:	6073      	str	r3, [r6, #4]
    6a1e:	e7ea      	b.n	69f6 <tcp_listen_with_backlog+0x46>
    6a20:	68d9      	ldr	r1, [r3, #12]
    6a22:	42a1      	cmp	r1, r4
    6a24:	d104      	bne.n	6a30 <tcp_listen_with_backlog+0x80>
    6a26:	b107      	cbz	r7, 6a2a <tcp_listen_with_backlog+0x7a>
    6a28:	6073      	str	r3, [r6, #4]
    6a2a:	68e2      	ldr	r2, [r4, #12]
    6a2c:	60da      	str	r2, [r3, #12]
    6a2e:	e7e2      	b.n	69f6 <tcp_listen_with_backlog+0x46>
    6a30:	2701      	movs	r7, #1
    6a32:	460b      	mov	r3, r1
    6a34:	e7ef      	b.n	6a16 <tcp_listen_with_backlog+0x66>
    6a36:	bf00      	nop
    6a38:	00004c05 	.word	0x00004c05
    6a3c:	2001493c 	.word	0x2001493c
    6a40:	00004c21 	.word	0x00004c21
    6a44:	000068d9 	.word	0x000068d9
    6a48:	000010a1 	.word	0x000010a1

00006a4c <tcp_update_rcv_ann_wnd>:
{
    6a4c:	4602      	mov	r2, r0
    6a4e:	b5f0      	push	{r4, r5, r6, r7, lr}
	if (TCP_SEQ_GEQ(new_right_edge, pcb->rcv_ann_right_edge + LWIP_MIN((TCP_WND / 2), pcb->mss))) {
    6a50:	6b01      	ldr	r1, [r0, #48]	; 0x30
	u32_t new_right_edge = pcb->rcv_nxt + pcb->rcv_wnd;
    6a52:	8d85      	ldrh	r5, [r0, #44]	; 0x2c
	if (TCP_SEQ_GEQ(new_right_edge, pcb->rcv_ann_right_edge + LWIP_MIN((TCP_WND / 2), pcb->mss))) {
    6a54:	8ed7      	ldrh	r7, [r2, #54]	; 0x36
	u32_t new_right_edge = pcb->rcv_nxt + pcb->rcv_wnd;
    6a56:	6a84      	ldr	r4, [r0, #40]	; 0x28
	if (TCP_SEQ_GEQ(new_right_edge, pcb->rcv_ann_right_edge + LWIP_MIN((TCP_WND / 2), pcb->mss))) {
    6a58:	1a6b      	subs	r3, r5, r1
    6a5a:	f640 3668 	movw	r6, #2920	; 0xb68
    6a5e:	42b7      	cmp	r7, r6
    6a60:	eb03 0004 	add.w	r0, r3, r4
    6a64:	bf94      	ite	ls
    6a66:	1bc3      	subls	r3, r0, r7
    6a68:	1b83      	subhi	r3, r0, r6
    6a6a:	2b00      	cmp	r3, #0
    6a6c:	db01      	blt.n	6a72 <tcp_update_rcv_ann_wnd+0x26>
		pcb->rcv_ann_wnd = pcb->rcv_wnd;
    6a6e:	85d5      	strh	r5, [r2, #46]	; 0x2e
}
    6a70:	bdf0      	pop	{r4, r5, r6, r7, pc}
		if (TCP_SEQ_GT(pcb->rcv_nxt, pcb->rcv_ann_right_edge)) {
    6a72:	1a63      	subs	r3, r4, r1
    6a74:	2b00      	cmp	r3, #0
    6a76:	f04f 0000 	mov.w	r0, #0
			u32_t new_rcv_ann_wnd = pcb->rcv_ann_right_edge - pcb->rcv_nxt;
    6a7a:	bfd6      	itet	le
    6a7c:	1b09      	suble	r1, r1, r4
			pcb->rcv_ann_wnd = 0;
    6a7e:	85d0      	strhgt	r0, [r2, #46]	; 0x2e
			pcb->rcv_ann_wnd = (u16_t)new_rcv_ann_wnd;
    6a80:	85d1      	strhle	r1, [r2, #46]	; 0x2e
    6a82:	e7f5      	b.n	6a70 <tcp_update_rcv_ann_wnd+0x24>

00006a84 <tcp_recved>:
	pcb->rcv_wnd += len;
    6a84:	8d83      	ldrh	r3, [r0, #44]	; 0x2c
    6a86:	4419      	add	r1, r3
    6a88:	b289      	uxth	r1, r1
	if (pcb->rcv_wnd > TCP_WND) {
    6a8a:	f241 63d0 	movw	r3, #5840	; 0x16d0
    6a8e:	4299      	cmp	r1, r3
{
    6a90:	b510      	push	{r4, lr}
		pcb->rcv_wnd = TCP_WND;
    6a92:	bf8c      	ite	hi
    6a94:	8583      	strhhi	r3, [r0, #44]	; 0x2c
	pcb->rcv_wnd += len;
    6a96:	8581      	strhls	r1, [r0, #44]	; 0x2c
	wnd_inflation = tcp_update_rcv_ann_wnd(pcb);
    6a98:	4b08      	ldr	r3, [pc, #32]	; (6abc <tcp_recved+0x38>)
{
    6a9a:	4604      	mov	r4, r0
	wnd_inflation = tcp_update_rcv_ann_wnd(pcb);
    6a9c:	4798      	blx	r3
	if (wnd_inflation >= TCP_WND_UPDATE_THRESHOLD) {
    6a9e:	f240 53b3 	movw	r3, #1459	; 0x5b3
    6aa2:	4298      	cmp	r0, r3
    6aa4:	dd08      	ble.n	6ab8 <tcp_recved+0x34>
		tcp_ack_now(pcb);
    6aa6:	7fa3      	ldrb	r3, [r4, #30]
    6aa8:	f043 0302 	orr.w	r3, r3, #2
    6aac:	77a3      	strb	r3, [r4, #30]
		tcp_output(pcb);
    6aae:	4620      	mov	r0, r4
    6ab0:	4b03      	ldr	r3, [pc, #12]	; (6ac0 <tcp_recved+0x3c>)
}
    6ab2:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		tcp_output(pcb);
    6ab6:	4718      	bx	r3
}
    6ab8:	bd10      	pop	{r4, pc}
    6aba:	bf00      	nop
    6abc:	00006a4d 	.word	0x00006a4d
    6ac0:	000024a1 	.word	0x000024a1

00006ac4 <tcp_seg_free>:
 * Frees a TCP segment (tcp_seg structure).
 *
 * @param seg single tcp_seg to free
 */
void tcp_seg_free(struct tcp_seg *seg)
{
    6ac4:	b510      	push	{r4, lr}
	if (seg != NULL) {
    6ac6:	4604      	mov	r4, r0
    6ac8:	b148      	cbz	r0, 6ade <tcp_seg_free+0x1a>
		if (seg->p != NULL) {
    6aca:	6840      	ldr	r0, [r0, #4]
    6acc:	b108      	cbz	r0, 6ad2 <tcp_seg_free+0xe>
			pbuf_free(seg->p);
    6ace:	4b04      	ldr	r3, [pc, #16]	; (6ae0 <tcp_seg_free+0x1c>)
    6ad0:	4798      	blx	r3
#if TCP_DEBUG
			seg->p = NULL;
#endif /* TCP_DEBUG */
		}
		memp_free(MEMP_TCP_SEG, seg);
    6ad2:	4621      	mov	r1, r4
    6ad4:	4b03      	ldr	r3, [pc, #12]	; (6ae4 <tcp_seg_free+0x20>)
	}
}
    6ad6:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		memp_free(MEMP_TCP_SEG, seg);
    6ada:	2003      	movs	r0, #3
    6adc:	4718      	bx	r3
}
    6ade:	bd10      	pop	{r4, pc}
    6ae0:	000030e1 	.word	0x000030e1
    6ae4:	00004c21 	.word	0x00004c21

00006ae8 <tcp_segs_free>:
{
    6ae8:	b538      	push	{r3, r4, r5, lr}
		tcp_seg_free(seg);
    6aea:	4c03      	ldr	r4, [pc, #12]	; (6af8 <tcp_segs_free+0x10>)
	while (seg != NULL) {
    6aec:	b900      	cbnz	r0, 6af0 <tcp_segs_free+0x8>
}
    6aee:	bd38      	pop	{r3, r4, r5, pc}
		struct tcp_seg *next = seg->next;
    6af0:	6805      	ldr	r5, [r0, #0]
		tcp_seg_free(seg);
    6af2:	47a0      	blx	r4
		seg = next;
    6af4:	4628      	mov	r0, r5
    6af6:	e7f9      	b.n	6aec <tcp_segs_free+0x4>
    6af8:	00006ac5 	.word	0x00006ac5

00006afc <tcp_seg_copy>:
 *
 * @param seg the old tcp_seg
 * @return a copy of seg
 */
struct tcp_seg *tcp_seg_copy(struct tcp_seg *seg)
{
    6afc:	b538      	push	{r3, r4, r5, lr}
	struct tcp_seg *cseg;

	cseg = (struct tcp_seg *)memp_malloc(MEMP_TCP_SEG);
    6afe:	4b0a      	ldr	r3, [pc, #40]	; (6b28 <tcp_seg_copy+0x2c>)
{
    6b00:	4604      	mov	r4, r0
	cseg = (struct tcp_seg *)memp_malloc(MEMP_TCP_SEG);
    6b02:	2003      	movs	r0, #3
    6b04:	4798      	blx	r3
	if (cseg == NULL) {
    6b06:	4605      	mov	r5, r0
    6b08:	b160      	cbz	r0, 6b24 <tcp_seg_copy+0x28>
		return NULL;
	}
	SMEMCPY((u8_t *)cseg, (const u8_t *)seg, sizeof(struct tcp_seg));
    6b0a:	4623      	mov	r3, r4
    6b0c:	4602      	mov	r2, r0
    6b0e:	f104 0110 	add.w	r1, r4, #16
    6b12:	f853 0b04 	ldr.w	r0, [r3], #4
    6b16:	f842 0b04 	str.w	r0, [r2], #4
    6b1a:	428b      	cmp	r3, r1
    6b1c:	d1f9      	bne.n	6b12 <tcp_seg_copy+0x16>
	pbuf_ref(cseg->p);
    6b1e:	6868      	ldr	r0, [r5, #4]
    6b20:	4b02      	ldr	r3, [pc, #8]	; (6b2c <tcp_seg_copy+0x30>)
    6b22:	4798      	blx	r3
	return cseg;
}
    6b24:	4628      	mov	r0, r5
    6b26:	bd38      	pop	{r3, r4, r5, pc}
    6b28:	00004c05 	.word	0x00004c05
    6b2c:	000032ad 	.word	0x000032ad

00006b30 <tcp_arg>:
 */
void tcp_arg(struct tcp_pcb *pcb, void *arg)
{
	/* This function is allowed to be called for both listen pcbs and
	   connection pcbs. */
	pcb->callback_arg = arg;
    6b30:	6101      	str	r1, [r0, #16]
}
    6b32:	4770      	bx	lr

00006b34 <tcp_recv>:
 * @param recv callback function to call for this pcb when data is received
 */
void tcp_recv(struct tcp_pcb *pcb, tcp_recv_fn recv)
{
	LWIP_ASSERT("invalid socket state for recv callback", pcb->state != LISTEN);
	pcb->recv = recv;
    6b34:	f8c0 1080 	str.w	r1, [r0, #128]	; 0x80
}
    6b38:	4770      	bx	lr

00006b3a <tcp_sent>:
 * @param sent callback function to call for this pcb when data is successfully sent
 */
void tcp_sent(struct tcp_pcb *pcb, tcp_sent_fn sent)
{
	LWIP_ASSERT("invalid socket state for sent callback", pcb->state != LISTEN);
	pcb->sent = sent;
    6b3a:	67c1      	str	r1, [r0, #124]	; 0x7c
}
    6b3c:	4770      	bx	lr

00006b3e <tcp_err>:
 *        has occured on the connection
 */
void tcp_err(struct tcp_pcb *pcb, tcp_err_fn err)
{
	LWIP_ASSERT("invalid socket state for err callback", pcb->state != LISTEN);
	pcb->errf = err;
    6b3e:	f8c0 108c 	str.w	r1, [r0, #140]	; 0x8c
}
    6b42:	4770      	bx	lr

00006b44 <tcp_accept>:
 */
void tcp_accept(struct tcp_pcb *pcb, tcp_accept_fn accept)
{
	/* This function is allowed to be called for both listen pcbs and
	   connection pcbs. */
	pcb->accept = accept;
    6b44:	6141      	str	r1, [r0, #20]
}
    6b46:	4770      	bx	lr

00006b48 <tcp_poll>:
 */
void tcp_poll(struct tcp_pcb *pcb, tcp_poll_fn poll, u8_t interval)
{
	LWIP_ASSERT("invalid socket state for poll", pcb->state != LISTEN);
#if LWIP_CALLBACK_API
	pcb->poll = poll;
    6b48:	f8c0 1088 	str.w	r1, [r0, #136]	; 0x88
#else  /* LWIP_CALLBACK_API */
	LWIP_UNUSED_ARG(poll);
#endif /* LWIP_CALLBACK_API */
	pcb->pollinterval = interval;
    6b4c:	f880 2020 	strb.w	r2, [r0, #32]
}
    6b50:	4770      	bx	lr
	...

00006b54 <tcp_pcb_purge>:
 * (pcb->ooseq, pcb->unsent and pcb->unacked are freed).
 *
 * @param pcb tcp_pcb to purge. The pcb itself is not deallocated!
 */
void tcp_pcb_purge(struct tcp_pcb *pcb)
{
    6b54:	b570      	push	{r4, r5, r6, lr}
	if (pcb->state != CLOSED && pcb->state != TIME_WAIT && pcb->state != LISTEN) {
    6b56:	7e03      	ldrb	r3, [r0, #24]
    6b58:	2b01      	cmp	r3, #1
{
    6b5a:	4604      	mov	r4, r0
	if (pcb->state != CLOSED && pcb->state != TIME_WAIT && pcb->state != LISTEN) {
    6b5c:	d917      	bls.n	6b8e <tcp_pcb_purge+0x3a>
    6b5e:	2b0a      	cmp	r3, #10
    6b60:	d015      	beq.n	6b8e <tcp_pcb_purge+0x3a>
				}
			}
		}
#endif /* TCP_LISTEN_BACKLOG */

		if (pcb->refused_data != NULL) {
    6b62:	6f80      	ldr	r0, [r0, #120]	; 0x78
    6b64:	b118      	cbz	r0, 6b6e <tcp_pcb_purge+0x1a>
			LWIP_DEBUGF(TCP_DEBUG, ("tcp_pcb_purge: data left on ->refused_data\n"));
			pbuf_free(pcb->refused_data);
    6b66:	4b0a      	ldr	r3, [pc, #40]	; (6b90 <tcp_pcb_purge+0x3c>)
    6b68:	4798      	blx	r3
			pcb->refused_data = NULL;
    6b6a:	2300      	movs	r3, #0
    6b6c:	67a3      	str	r3, [r4, #120]	; 0x78
		}
#if TCP_QUEUE_OOSEQ
		if (pcb->ooseq != NULL) {
			LWIP_DEBUGF(TCP_DEBUG, ("tcp_pcb_purge: data left on ->ooseq\n"));
		}
		tcp_segs_free(pcb->ooseq);
    6b6e:	4e09      	ldr	r6, [pc, #36]	; (6b94 <tcp_pcb_purge+0x40>)
    6b70:	6f60      	ldr	r0, [r4, #116]	; 0x74
    6b72:	47b0      	blx	r6
		pcb->ooseq = NULL;
    6b74:	2500      	movs	r5, #0
#endif /* TCP_QUEUE_OOSEQ */

		/* Stop the retransmission timer as it will expect data on unacked
		   queue if it fires */
		pcb->rtime = -1;
    6b76:	f64f 73ff 	movw	r3, #65535	; 0xffff

		tcp_segs_free(pcb->unsent);
    6b7a:	6ee0      	ldr	r0, [r4, #108]	; 0x6c
		pcb->rtime = -1;
    6b7c:	86a3      	strh	r3, [r4, #52]	; 0x34
		pcb->ooseq = NULL;
    6b7e:	6765      	str	r5, [r4, #116]	; 0x74
		tcp_segs_free(pcb->unsent);
    6b80:	47b0      	blx	r6
		tcp_segs_free(pcb->unacked);
    6b82:	6f20      	ldr	r0, [r4, #112]	; 0x70
    6b84:	47b0      	blx	r6
		pcb->unacked = pcb->unsent = NULL;
    6b86:	e9c4 551b 	strd	r5, r5, [r4, #108]	; 0x6c
#if TCP_OVERSIZE
		pcb->unsent_oversize = 0;
    6b8a:	f8a4 506a 	strh.w	r5, [r4, #106]	; 0x6a
#endif /* TCP_OVERSIZE */
	}
}
    6b8e:	bd70      	pop	{r4, r5, r6, pc}
    6b90:	000030e1 	.word	0x000030e1
    6b94:	00006ae9 	.word	0x00006ae9

00006b98 <tcp_slowtmr>:
{
    6b98:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	++tcp_ticks;
    6b9c:	4ea4      	ldr	r6, [pc, #656]	; (6e30 <tcp_slowtmr+0x298>)
			tcp_pcb_purge(pcb);
    6b9e:	f8df b294 	ldr.w	fp, [pc, #660]	; 6e34 <tcp_slowtmr+0x29c>
	++tcp_ticks;
    6ba2:	68f3      	ldr	r3, [r6, #12]
			memp_free(MEMP_TCP_PCB, pcb2);
    6ba4:	f8df a2ac 	ldr.w	sl, [pc, #684]	; 6e54 <tcp_slowtmr+0x2bc>
	++tcp_ticks;
    6ba8:	3301      	adds	r3, #1
    6baa:	60f3      	str	r3, [r6, #12]
	++tcp_timer_ctr;
    6bac:	7c33      	ldrb	r3, [r6, #16]
    6bae:	3301      	adds	r3, #1
{
    6bb0:	b085      	sub	sp, #20
	++tcp_timer_ctr;
    6bb2:	7433      	strb	r3, [r6, #16]
	pcb  = tcp_active_pcbs;
    6bb4:	6974      	ldr	r4, [r6, #20]
				tcp_rst(pcb->snd_nxt, pcb->rcv_nxt, &pcb->local_ip, &pcb->remote_ip, pcb->local_port, pcb->remote_port);
    6bb6:	f8df 92a0 	ldr.w	r9, [pc, #672]	; 6e58 <tcp_slowtmr+0x2c0>
	prev = NULL;
    6bba:	f04f 0800 	mov.w	r8, #0
	while (pcb != NULL) {
    6bbe:	b94c      	cbnz	r4, 6bd4 <tcp_slowtmr+0x3c>
	pcb  = tcp_tw_pcbs;
    6bc0:	69f5      	ldr	r5, [r6, #28]
			tcp_pcb_purge(pcb);
    6bc2:	4f9c      	ldr	r7, [pc, #624]	; (6e34 <tcp_slowtmr+0x29c>)
			memp_free(MEMP_TCP_PCB, pcb2);
    6bc4:	f8df 828c 	ldr.w	r8, [pc, #652]	; 6e54 <tcp_slowtmr+0x2bc>
	while (pcb != NULL) {
    6bc8:	2d00      	cmp	r5, #0
    6bca:	f040 811b 	bne.w	6e04 <tcp_slowtmr+0x26c>
}
    6bce:	b005      	add	sp, #20
    6bd0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		if (pcb->last_timer == tcp_timer_ctr) {
    6bd4:	7c33      	ldrb	r3, [r6, #16]
    6bd6:	f894 2021 	ldrb.w	r2, [r4, #33]	; 0x21
    6bda:	429a      	cmp	r2, r3
    6bdc:	d102      	bne.n	6be4 <tcp_slowtmr+0x4c>
			pcb = pcb->next;
    6bde:	68e7      	ldr	r7, [r4, #12]
			continue;
    6be0:	463c      	mov	r4, r7
    6be2:	e7ec      	b.n	6bbe <tcp_slowtmr+0x26>
		if (pcb->state == SYN_SENT && pcb->nrtx == TCP_SYNMAXRTX) {
    6be4:	7e22      	ldrb	r2, [r4, #24]
    6be6:	f894 1046 	ldrb.w	r1, [r4, #70]	; 0x46
		pcb->last_timer = tcp_timer_ctr;
    6bea:	f884 3021 	strb.w	r3, [r4, #33]	; 0x21
		if (pcb->state == SYN_SENT && pcb->nrtx == TCP_SYNMAXRTX) {
    6bee:	2a02      	cmp	r2, #2
    6bf0:	d102      	bne.n	6bf8 <tcp_slowtmr+0x60>
    6bf2:	2906      	cmp	r1, #6
    6bf4:	f000 80ca 	beq.w	6d8c <tcp_slowtmr+0x1f4>
		} else if (pcb->nrtx == TCP_MAXRTX) {
    6bf8:	290c      	cmp	r1, #12
    6bfa:	f000 80c7 	beq.w	6d8c <tcp_slowtmr+0x1f4>
			if (pcb->persist_backoff > 0) {
    6bfe:	f894 5095 	ldrb.w	r5, [r4, #149]	; 0x95
    6c02:	2d00      	cmp	r5, #0
    6c04:	f000 8089 	beq.w	6d1a <tcp_slowtmr+0x182>
				if (pcb->persist_cnt >= tcp_persist_backoff[pcb->persist_backoff - 1]) {
    6c08:	4a8b      	ldr	r2, [pc, #556]	; (6e38 <tcp_slowtmr+0x2a0>)
				pcb->persist_cnt++;
    6c0a:	f894 3094 	ldrb.w	r3, [r4, #148]	; 0x94
				if (pcb->persist_cnt >= tcp_persist_backoff[pcb->persist_backoff - 1]) {
    6c0e:	442a      	add	r2, r5
				pcb->persist_cnt++;
    6c10:	3301      	adds	r3, #1
				if (pcb->persist_cnt >= tcp_persist_backoff[pcb->persist_backoff - 1]) {
    6c12:	7bd2      	ldrb	r2, [r2, #15]
				pcb->persist_cnt++;
    6c14:	b2db      	uxtb	r3, r3
				if (pcb->persist_cnt >= tcp_persist_backoff[pcb->persist_backoff - 1]) {
    6c16:	429a      	cmp	r2, r3
				pcb->persist_cnt++;
    6c18:	f884 3094 	strb.w	r3, [r4, #148]	; 0x94
				if (pcb->persist_cnt >= tcp_persist_backoff[pcb->persist_backoff - 1]) {
    6c1c:	d96f      	bls.n	6cfe <tcp_slowtmr+0x166>
		pcb_remove = 0;
    6c1e:	2500      	movs	r5, #0
		if (pcb->state == FIN_WAIT_2) {
    6c20:	7e21      	ldrb	r1, [r4, #24]
    6c22:	2906      	cmp	r1, #6
    6c24:	d109      	bne.n	6c3a <tcp_slowtmr+0xa2>
			if (pcb->flags & TF_RXCLOSED) {
    6c26:	7fa3      	ldrb	r3, [r4, #30]
    6c28:	06db      	lsls	r3, r3, #27
    6c2a:	d506      	bpl.n	6c3a <tcp_slowtmr+0xa2>
				if ((u32_t)(tcp_ticks - pcb->tmr) > TCP_FIN_WAIT_TIMEOUT / TCP_SLOW_INTERVAL) {
    6c2c:	68f3      	ldr	r3, [r6, #12]
    6c2e:	6a62      	ldr	r2, [r4, #36]	; 0x24
    6c30:	1a9b      	subs	r3, r3, r2
    6c32:	2b28      	cmp	r3, #40	; 0x28
					++pcb_remove;
    6c34:	bf84      	itt	hi
    6c36:	3501      	addhi	r5, #1
    6c38:	b2ed      	uxtbhi	r5, r5
		if (ip_get_option(pcb, SOF_KEEPALIVE) && ((pcb->state == ESTABLISHED) || (pcb->state == CLOSE_WAIT))) {
    6c3a:	7a27      	ldrb	r7, [r4, #8]
    6c3c:	f017 0708 	ands.w	r7, r7, #8
    6c40:	d017      	beq.n	6c72 <tcp_slowtmr+0xda>
    6c42:	2904      	cmp	r1, #4
    6c44:	d002      	beq.n	6c4c <tcp_slowtmr+0xb4>
    6c46:	2907      	cmp	r1, #7
    6c48:	f040 80b3 	bne.w	6db2 <tcp_slowtmr+0x21a>
			if ((u32_t)(tcp_ticks - pcb->tmr) > (pcb->keep_idle + TCP_KEEP_DUR(pcb)) / TCP_SLOW_INTERVAL) {
    6c4c:	6a63      	ldr	r3, [r4, #36]	; 0x24
    6c4e:	68f1      	ldr	r1, [r6, #12]
    6c50:	1ac9      	subs	r1, r1, r3
    6c52:	f8d4 3090 	ldr.w	r3, [r4, #144]	; 0x90
    6c56:	f503 2224 	add.w	r2, r3, #671744	; 0xa4000
    6c5a:	f602 42b8 	addw	r2, r2, #3256	; 0xcb8
    6c5e:	f44f 70fa 	mov.w	r0, #500	; 0x1f4
    6c62:	fbb2 f2f0 	udiv	r2, r2, r0
    6c66:	4291      	cmp	r1, r2
    6c68:	f240 8092 	bls.w	6d90 <tcp_slowtmr+0x1f8>
				++pcb_remove;
    6c6c:	3501      	adds	r5, #1
    6c6e:	b2ed      	uxtb	r5, r5
				++pcb_reset;
    6c70:	2701      	movs	r7, #1
		if (pcb->ooseq != NULL && (u32_t)tcp_ticks - pcb->tmr >= pcb->rto * TCP_OOSEQ_TIMEOUT) {
    6c72:	6f60      	ldr	r0, [r4, #116]	; 0x74
    6c74:	b168      	cbz	r0, 6c92 <tcp_slowtmr+0xfa>
    6c76:	68f3      	ldr	r3, [r6, #12]
    6c78:	6a62      	ldr	r2, [r4, #36]	; 0x24
    6c7a:	f9b4 1044 	ldrsh.w	r1, [r4, #68]	; 0x44
    6c7e:	1a9b      	subs	r3, r3, r2
    6c80:	eb01 0141 	add.w	r1, r1, r1, lsl #1
    6c84:	ebb3 0f41 	cmp.w	r3, r1, lsl #1
    6c88:	d303      	bcc.n	6c92 <tcp_slowtmr+0xfa>
			tcp_segs_free(pcb->ooseq);
    6c8a:	4b6c      	ldr	r3, [pc, #432]	; (6e3c <tcp_slowtmr+0x2a4>)
    6c8c:	4798      	blx	r3
			pcb->ooseq = NULL;
    6c8e:	2300      	movs	r3, #0
    6c90:	6763      	str	r3, [r4, #116]	; 0x74
		if (pcb->state == SYN_RCVD) {
    6c92:	7e23      	ldrb	r3, [r4, #24]
    6c94:	2b03      	cmp	r3, #3
    6c96:	f040 808e 	bne.w	6db6 <tcp_slowtmr+0x21e>
			if ((u32_t)(tcp_ticks - pcb->tmr) > TCP_SYN_RCVD_TIMEOUT / TCP_SLOW_INTERVAL) {
    6c9a:	68f3      	ldr	r3, [r6, #12]
    6c9c:	6a62      	ldr	r2, [r4, #36]	; 0x24
    6c9e:	1a9b      	subs	r3, r3, r2
    6ca0:	2b28      	cmp	r3, #40	; 0x28
			if ((u32_t)(tcp_ticks - pcb->tmr) > 2 * TCP_MSL / TCP_SLOW_INTERVAL) {
    6ca2:	d802      	bhi.n	6caa <tcp_slowtmr+0x112>
		if (pcb_remove) {
    6ca4:	2d00      	cmp	r5, #0
    6ca6:	f000 8090 	beq.w	6dca <tcp_slowtmr+0x232>
			tcp_pcb_purge(pcb);
    6caa:	4620      	mov	r0, r4
    6cac:	47d8      	blx	fp
			if (prev != NULL) {
    6cae:	68e3      	ldr	r3, [r4, #12]
    6cb0:	f1b8 0f00 	cmp.w	r8, #0
    6cb4:	f000 8087 	beq.w	6dc6 <tcp_slowtmr+0x22e>
				prev->next = pcb->next;
    6cb8:	f8c8 300c 	str.w	r3, [r8, #12]
			if (pcb_reset) {
    6cbc:	b147      	cbz	r7, 6cd0 <tcp_slowtmr+0x138>
				tcp_rst(pcb->snd_nxt, pcb->rcv_nxt, &pcb->local_ip, &pcb->remote_ip, pcb->local_port, pcb->remote_port);
    6cbe:	8ba3      	ldrh	r3, [r4, #28]
    6cc0:	9301      	str	r3, [sp, #4]
    6cc2:	8b63      	ldrh	r3, [r4, #26]
    6cc4:	9300      	str	r3, [sp, #0]
    6cc6:	6aa1      	ldr	r1, [r4, #40]	; 0x28
    6cc8:	6d20      	ldr	r0, [r4, #80]	; 0x50
    6cca:	1d23      	adds	r3, r4, #4
    6ccc:	4622      	mov	r2, r4
    6cce:	47c8      	blx	r9
			err_arg = pcb->callback_arg;
    6cd0:	6923      	ldr	r3, [r4, #16]
			err_fn  = pcb->errf;
    6cd2:	f8d4 508c 	ldr.w	r5, [r4, #140]	; 0x8c
			pcb     = pcb->next;
    6cd6:	68e7      	ldr	r7, [r4, #12]
			err_arg = pcb->callback_arg;
    6cd8:	9303      	str	r3, [sp, #12]
			memp_free(MEMP_TCP_PCB, pcb2);
    6cda:	4621      	mov	r1, r4
    6cdc:	2001      	movs	r0, #1
    6cde:	47d0      	blx	sl
			tcp_active_pcbs_changed = 0;
    6ce0:	2200      	movs	r2, #0
    6ce2:	7632      	strb	r2, [r6, #24]
			TCP_EVENT_ERR(err_fn, err_arg, ERR_ABRT);
    6ce4:	2d00      	cmp	r5, #0
    6ce6:	f43f af7b 	beq.w	6be0 <tcp_slowtmr+0x48>
    6cea:	9b03      	ldr	r3, [sp, #12]
    6cec:	f06f 0109 	mvn.w	r1, #9
    6cf0:	4618      	mov	r0, r3
    6cf2:	47a8      	blx	r5
			if (tcp_active_pcbs_changed) {
    6cf4:	7e33      	ldrb	r3, [r6, #24]
    6cf6:	2b00      	cmp	r3, #0
    6cf8:	f43f af72 	beq.w	6be0 <tcp_slowtmr+0x48>
    6cfc:	e75a      	b.n	6bb4 <tcp_slowtmr+0x1c>
					if (pcb->persist_backoff < sizeof(tcp_persist_backoff)) {
    6cfe:	2d06      	cmp	r5, #6
					pcb->persist_cnt = 0;
    6d00:	f04f 0300 	mov.w	r3, #0
						pcb->persist_backoff++;
    6d04:	bf98      	it	ls
    6d06:	3501      	addls	r5, #1
					pcb->persist_cnt = 0;
    6d08:	f884 3094 	strb.w	r3, [r4, #148]	; 0x94
						pcb->persist_backoff++;
    6d0c:	bf98      	it	ls
    6d0e:	f884 5095 	strbls.w	r5, [r4, #149]	; 0x95
					tcp_zero_window_probe(pcb);
    6d12:	4b4b      	ldr	r3, [pc, #300]	; (6e40 <tcp_slowtmr+0x2a8>)
    6d14:	4620      	mov	r0, r4
    6d16:	4798      	blx	r3
    6d18:	e781      	b.n	6c1e <tcp_slowtmr+0x86>
				if (pcb->rtime >= 0) {
    6d1a:	f9b4 3034 	ldrsh.w	r3, [r4, #52]	; 0x34
    6d1e:	2b00      	cmp	r3, #0
					++pcb->rtime;
    6d20:	bfa4      	itt	ge
    6d22:	3301      	addge	r3, #1
    6d24:	86a3      	strhge	r3, [r4, #52]	; 0x34
				if (pcb->unacked != NULL && pcb->rtime >= pcb->rto) {
    6d26:	6f23      	ldr	r3, [r4, #112]	; 0x70
    6d28:	2b00      	cmp	r3, #0
    6d2a:	f43f af78 	beq.w	6c1e <tcp_slowtmr+0x86>
    6d2e:	f9b4 0034 	ldrsh.w	r0, [r4, #52]	; 0x34
    6d32:	f9b4 3044 	ldrsh.w	r3, [r4, #68]	; 0x44
    6d36:	4298      	cmp	r0, r3
    6d38:	f6ff af71 	blt.w	6c1e <tcp_slowtmr+0x86>
					if (pcb->state != SYN_SENT) {
    6d3c:	2a02      	cmp	r2, #2
    6d3e:	d00b      	beq.n	6d58 <tcp_slowtmr+0x1c0>
						pcb->rto = ((pcb->sa >> 3) + pcb->sv) << tcp_backoff[pcb->nrtx];
    6d40:	f9b4 2040 	ldrsh.w	r2, [r4, #64]	; 0x40
    6d44:	f9b4 3042 	ldrsh.w	r3, [r4, #66]	; 0x42
    6d48:	eb03 03e2 	add.w	r3, r3, r2, asr #3
    6d4c:	4a3a      	ldr	r2, [pc, #232]	; (6e38 <tcp_slowtmr+0x2a0>)
    6d4e:	440a      	add	r2, r1
    6d50:	7dd2      	ldrb	r2, [r2, #23]
    6d52:	4093      	lsls	r3, r2
    6d54:	f8a4 3044 	strh.w	r3, [r4, #68]	; 0x44
					pcb->rtime = 0;
    6d58:	2300      	movs	r3, #0
					eff_wnd       = LWIP_MIN(pcb->cwnd, pcb->snd_wnd);
    6d5a:	f8b4 204c 	ldrh.w	r2, [r4, #76]	; 0x4c
					pcb->rtime = 0;
    6d5e:	86a3      	strh	r3, [r4, #52]	; 0x34
					eff_wnd       = LWIP_MIN(pcb->cwnd, pcb->snd_wnd);
    6d60:	f8b4 3060 	ldrh.w	r3, [r4, #96]	; 0x60
					pcb->ssthresh = eff_wnd >> 1;
    6d64:	4293      	cmp	r3, r2
    6d66:	bf28      	it	cs
    6d68:	4613      	movcs	r3, r2
					if (pcb->ssthresh < (pcb->mss << 1)) {
    6d6a:	8ee2      	ldrh	r2, [r4, #54]	; 0x36
					pcb->cwnd = pcb->mss;
    6d6c:	f8a4 204c 	strh.w	r2, [r4, #76]	; 0x4c
					pcb->ssthresh = eff_wnd >> 1;
    6d70:	085b      	lsrs	r3, r3, #1
					if (pcb->ssthresh < (pcb->mss << 1)) {
    6d72:	ebb3 0f42 	cmp.w	r3, r2, lsl #1
    6d76:	ea4f 0142 	mov.w	r1, r2, lsl #1
					pcb->ssthresh = eff_wnd >> 1;
    6d7a:	f8a4 304e 	strh.w	r3, [r4, #78]	; 0x4e
					tcp_rexmit_rto(pcb);
    6d7e:	4620      	mov	r0, r4
    6d80:	4b30      	ldr	r3, [pc, #192]	; (6e44 <tcp_slowtmr+0x2ac>)
						pcb->ssthresh = (pcb->mss << 1);
    6d82:	bfb8      	it	lt
    6d84:	f8a4 104e 	strhlt.w	r1, [r4, #78]	; 0x4e
					tcp_rexmit_rto(pcb);
    6d88:	4798      	blx	r3
    6d8a:	e749      	b.n	6c20 <tcp_slowtmr+0x88>
			++pcb_remove;
    6d8c:	2501      	movs	r5, #1
    6d8e:	e747      	b.n	6c20 <tcp_slowtmr+0x88>
			           > (pcb->keep_idle + pcb->keep_cnt_sent * TCP_KEEP_INTVL(pcb)) / TCP_SLOW_INTERVAL) {
    6d90:	f894 2096 	ldrb.w	r2, [r4, #150]	; 0x96
    6d94:	4f2c      	ldr	r7, [pc, #176]	; (6e48 <tcp_slowtmr+0x2b0>)
    6d96:	fb07 3302 	mla	r3, r7, r2, r3
    6d9a:	fbb3 f3f0 	udiv	r3, r3, r0
			} else if ((u32_t)(tcp_ticks - pcb->tmr)
    6d9e:	4299      	cmp	r1, r3
    6da0:	d907      	bls.n	6db2 <tcp_slowtmr+0x21a>
				tcp_keepalive(pcb);
    6da2:	4b2a      	ldr	r3, [pc, #168]	; (6e4c <tcp_slowtmr+0x2b4>)
    6da4:	4620      	mov	r0, r4
    6da6:	4798      	blx	r3
				pcb->keep_cnt_sent++;
    6da8:	f894 3096 	ldrb.w	r3, [r4, #150]	; 0x96
    6dac:	3301      	adds	r3, #1
    6dae:	f884 3096 	strb.w	r3, [r4, #150]	; 0x96
		pcb_reset  = 0;
    6db2:	2700      	movs	r7, #0
    6db4:	e75d      	b.n	6c72 <tcp_slowtmr+0xda>
		if (pcb->state == LAST_ACK) {
    6db6:	2b09      	cmp	r3, #9
    6db8:	f47f af74 	bne.w	6ca4 <tcp_slowtmr+0x10c>
			if ((u32_t)(tcp_ticks - pcb->tmr) > 2 * TCP_MSL / TCP_SLOW_INTERVAL) {
    6dbc:	68f3      	ldr	r3, [r6, #12]
    6dbe:	6a62      	ldr	r2, [r4, #36]	; 0x24
    6dc0:	1a9b      	subs	r3, r3, r2
    6dc2:	2bf0      	cmp	r3, #240	; 0xf0
    6dc4:	e76d      	b.n	6ca2 <tcp_slowtmr+0x10a>
				tcp_active_pcbs = pcb->next;
    6dc6:	6173      	str	r3, [r6, #20]
    6dc8:	e778      	b.n	6cbc <tcp_slowtmr+0x124>
			++prev->polltmr;
    6dca:	7fe3      	ldrb	r3, [r4, #31]
			if (prev->polltmr >= prev->pollinterval) {
    6dcc:	f894 2020 	ldrb.w	r2, [r4, #32]
			pcb  = pcb->next;
    6dd0:	68e7      	ldr	r7, [r4, #12]
			++prev->polltmr;
    6dd2:	3301      	adds	r3, #1
    6dd4:	b2db      	uxtb	r3, r3
			if (prev->polltmr >= prev->pollinterval) {
    6dd6:	429a      	cmp	r2, r3
			++prev->polltmr;
    6dd8:	77e3      	strb	r3, [r4, #31]
			if (prev->polltmr >= prev->pollinterval) {
    6dda:	d807      	bhi.n	6dec <tcp_slowtmr+0x254>
				TCP_EVENT_POLL(prev, err);
    6ddc:	f8d4 3088 	ldr.w	r3, [r4, #136]	; 0x88
				prev->polltmr = 0;
    6de0:	77e5      	strb	r5, [r4, #31]
				tcp_active_pcbs_changed = 0;
    6de2:	7635      	strb	r5, [r6, #24]
				TCP_EVENT_POLL(prev, err);
    6de4:	b923      	cbnz	r3, 6df0 <tcp_slowtmr+0x258>
					tcp_output(prev);
    6de6:	4b1a      	ldr	r3, [pc, #104]	; (6e50 <tcp_slowtmr+0x2b8>)
    6de8:	4620      	mov	r0, r4
    6dea:	4798      	blx	r3
    6dec:	46a0      	mov	r8, r4
    6dee:	e6f7      	b.n	6be0 <tcp_slowtmr+0x48>
				TCP_EVENT_POLL(prev, err);
    6df0:	6920      	ldr	r0, [r4, #16]
    6df2:	4621      	mov	r1, r4
    6df4:	4798      	blx	r3
				if (tcp_active_pcbs_changed) {
    6df6:	7e33      	ldrb	r3, [r6, #24]
    6df8:	2b00      	cmp	r3, #0
    6dfa:	f47f aedb 	bne.w	6bb4 <tcp_slowtmr+0x1c>
				if (err == ERR_OK) {
    6dfe:	2800      	cmp	r0, #0
    6e00:	d1f4      	bne.n	6dec <tcp_slowtmr+0x254>
    6e02:	e7f0      	b.n	6de6 <tcp_slowtmr+0x24e>
		if ((u32_t)(tcp_ticks - pcb->tmr) > 2 * TCP_MSL / TCP_SLOW_INTERVAL) {
    6e04:	68f3      	ldr	r3, [r6, #12]
    6e06:	6a6a      	ldr	r2, [r5, #36]	; 0x24
    6e08:	1a9b      	subs	r3, r3, r2
    6e0a:	2bf0      	cmp	r3, #240	; 0xf0
    6e0c:	d802      	bhi.n	6e14 <tcp_slowtmr+0x27c>
			pcb  = pcb->next;
    6e0e:	462c      	mov	r4, r5
    6e10:	68ed      	ldr	r5, [r5, #12]
    6e12:	e6d9      	b.n	6bc8 <tcp_slowtmr+0x30>
			tcp_pcb_purge(pcb);
    6e14:	4628      	mov	r0, r5
    6e16:	47b8      	blx	r7
			if (prev != NULL) {
    6e18:	68eb      	ldr	r3, [r5, #12]
    6e1a:	b13c      	cbz	r4, 6e2c <tcp_slowtmr+0x294>
				prev->next = pcb->next;
    6e1c:	60e3      	str	r3, [r4, #12]
			pcb  = pcb->next;
    6e1e:	f8d5 900c 	ldr.w	r9, [r5, #12]
			memp_free(MEMP_TCP_PCB, pcb2);
    6e22:	4629      	mov	r1, r5
    6e24:	2001      	movs	r0, #1
    6e26:	47c0      	blx	r8
			pcb  = pcb->next;
    6e28:	464d      	mov	r5, r9
    6e2a:	e6cd      	b.n	6bc8 <tcp_slowtmr+0x30>
				tcp_tw_pcbs = pcb->next;
    6e2c:	61f3      	str	r3, [r6, #28]
    6e2e:	e7f6      	b.n	6e1e <tcp_slowtmr+0x286>
    6e30:	2001493c 	.word	0x2001493c
    6e34:	00006b55 	.word	0x00006b55
    6e38:	0000cad8 	.word	0x0000cad8
    6e3c:	00006ae9 	.word	0x00006ae9
    6e40:	00002921 	.word	0x00002921
    6e44:	000027d5 	.word	0x000027d5
    6e48:	000124f8 	.word	0x000124f8
    6e4c:	000028b9 	.word	0x000028b9
    6e50:	000024a1 	.word	0x000024a1
    6e54:	00004c21 	.word	0x00004c21
    6e58:	00002725 	.word	0x00002725

00006e5c <tcp_pcb_remove>:
 * @param pcblist PCB list to purge.
 * @param pcb tcp_pcb to purge. The pcb itself is NOT deallocated!
 */
void tcp_pcb_remove(struct tcp_pcb **pcblist, struct tcp_pcb *pcb)
{
	TCP_RMV(pcblist, pcb);
    6e5c:	6803      	ldr	r3, [r0, #0]
    6e5e:	428b      	cmp	r3, r1
{
    6e60:	b510      	push	{r4, lr}
    6e62:	460c      	mov	r4, r1
	TCP_RMV(pcblist, pcb);
    6e64:	d117      	bne.n	6e96 <tcp_pcb_remove+0x3a>
    6e66:	68cb      	ldr	r3, [r1, #12]
    6e68:	6003      	str	r3, [r0, #0]
    6e6a:	2300      	movs	r3, #0
    6e6c:	60e3      	str	r3, [r4, #12]

	tcp_pcb_purge(pcb);
    6e6e:	4620      	mov	r0, r4
    6e70:	4b12      	ldr	r3, [pc, #72]	; (6ebc <tcp_pcb_remove+0x60>)
    6e72:	4798      	blx	r3

	/* if there is an outstanding delayed ACKs, send it */
	if (pcb->state != TIME_WAIT && pcb->state != LISTEN && pcb->flags & TF_ACK_DELAY) {
    6e74:	7e23      	ldrb	r3, [r4, #24]
    6e76:	2b0a      	cmp	r3, #10
    6e78:	d00a      	beq.n	6e90 <tcp_pcb_remove+0x34>
    6e7a:	2b01      	cmp	r3, #1
    6e7c:	d008      	beq.n	6e90 <tcp_pcb_remove+0x34>
    6e7e:	7fa3      	ldrb	r3, [r4, #30]
    6e80:	07da      	lsls	r2, r3, #31
    6e82:	d505      	bpl.n	6e90 <tcp_pcb_remove+0x34>
		pcb->flags |= TF_ACK_NOW;
    6e84:	f043 0302 	orr.w	r3, r3, #2
    6e88:	77a3      	strb	r3, [r4, #30]
		tcp_output(pcb);
    6e8a:	4620      	mov	r0, r4
    6e8c:	4b0c      	ldr	r3, [pc, #48]	; (6ec0 <tcp_pcb_remove+0x64>)
    6e8e:	4798      	blx	r3
#if TCP_QUEUE_OOSEQ
		LWIP_ASSERT("ooseq segments leaking", pcb->ooseq == NULL);
#endif /* TCP_QUEUE_OOSEQ */
	}

	pcb->state = CLOSED;
    6e90:	2300      	movs	r3, #0
    6e92:	7623      	strb	r3, [r4, #24]

	LWIP_ASSERT("tcp_pcb_remove: tcp_pcbs_sane()", tcp_pcbs_sane());
}
    6e94:	bd10      	pop	{r4, pc}
	TCP_RMV(pcblist, pcb);
    6e96:	4a0b      	ldr	r2, [pc, #44]	; (6ec4 <tcp_pcb_remove+0x68>)
    6e98:	2100      	movs	r1, #0
    6e9a:	6053      	str	r3, [r2, #4]
    6e9c:	b91b      	cbnz	r3, 6ea6 <tcp_pcb_remove+0x4a>
    6e9e:	2900      	cmp	r1, #0
    6ea0:	d0e3      	beq.n	6e6a <tcp_pcb_remove+0xe>
    6ea2:	6053      	str	r3, [r2, #4]
    6ea4:	e7e1      	b.n	6e6a <tcp_pcb_remove+0xe>
    6ea6:	68d8      	ldr	r0, [r3, #12]
    6ea8:	42a0      	cmp	r0, r4
    6eaa:	d104      	bne.n	6eb6 <tcp_pcb_remove+0x5a>
    6eac:	b101      	cbz	r1, 6eb0 <tcp_pcb_remove+0x54>
    6eae:	6053      	str	r3, [r2, #4]
    6eb0:	68e2      	ldr	r2, [r4, #12]
    6eb2:	60da      	str	r2, [r3, #12]
    6eb4:	e7d9      	b.n	6e6a <tcp_pcb_remove+0xe>
    6eb6:	2101      	movs	r1, #1
    6eb8:	4603      	mov	r3, r0
    6eba:	e7ef      	b.n	6e9c <tcp_pcb_remove+0x40>
    6ebc:	00006b55 	.word	0x00006b55
    6ec0:	000024a1 	.word	0x000024a1
    6ec4:	2001493c 	.word	0x2001493c

00006ec8 <tcp_close_shutdown>:
{
    6ec8:	b537      	push	{r0, r1, r2, r4, r5, lr}
    6eca:	4604      	mov	r4, r0
	if (rst_on_unacked_data && ((pcb->state == ESTABLISHED) || (pcb->state == CLOSE_WAIT))) {
    6ecc:	7e03      	ldrb	r3, [r0, #24]
    6ece:	2900      	cmp	r1, #0
    6ed0:	d040      	beq.n	6f54 <tcp_close_shutdown+0x8c>
    6ed2:	2b04      	cmp	r3, #4
    6ed4:	d001      	beq.n	6eda <tcp_close_shutdown+0x12>
    6ed6:	2b07      	cmp	r3, #7
    6ed8:	d13c      	bne.n	6f54 <tcp_close_shutdown+0x8c>
		if ((pcb->refused_data != NULL) || (pcb->rcv_wnd != TCP_WND)) {
    6eda:	6fa2      	ldr	r2, [r4, #120]	; 0x78
    6edc:	b922      	cbnz	r2, 6ee8 <tcp_close_shutdown+0x20>
    6ede:	8da1      	ldrh	r1, [r4, #44]	; 0x2c
    6ee0:	f241 62d0 	movw	r2, #5840	; 0x16d0
    6ee4:	4291      	cmp	r1, r2
    6ee6:	d035      	beq.n	6f54 <tcp_close_shutdown+0x8c>
			tcp_rst(pcb->snd_nxt, pcb->rcv_nxt, &pcb->local_ip, &pcb->remote_ip, pcb->local_port, pcb->remote_port);
    6ee8:	8ba3      	ldrh	r3, [r4, #28]
    6eea:	9301      	str	r3, [sp, #4]
    6eec:	8b63      	ldrh	r3, [r4, #26]
    6eee:	6aa1      	ldr	r1, [r4, #40]	; 0x28
    6ef0:	6d20      	ldr	r0, [r4, #80]	; 0x50
    6ef2:	9300      	str	r3, [sp, #0]
    6ef4:	4622      	mov	r2, r4
    6ef6:	1d23      	adds	r3, r4, #4
    6ef8:	4d43      	ldr	r5, [pc, #268]	; (7008 <tcp_close_shutdown+0x140>)
    6efa:	47a8      	blx	r5
			tcp_pcb_purge(pcb);
    6efc:	4b43      	ldr	r3, [pc, #268]	; (700c <tcp_close_shutdown+0x144>)
    6efe:	4620      	mov	r0, r4
    6f00:	4798      	blx	r3
			TCP_RMV_ACTIVE(pcb);
    6f02:	4b43      	ldr	r3, [pc, #268]	; (7010 <tcp_close_shutdown+0x148>)
    6f04:	695a      	ldr	r2, [r3, #20]
    6f06:	42a2      	cmp	r2, r4
    6f08:	d112      	bne.n	6f30 <tcp_close_shutdown+0x68>
    6f0a:	68e2      	ldr	r2, [r4, #12]
    6f0c:	615a      	str	r2, [r3, #20]
    6f0e:	2201      	movs	r2, #1
    6f10:	761a      	strb	r2, [r3, #24]
			if (pcb->state == ESTABLISHED) {
    6f12:	7e22      	ldrb	r2, [r4, #24]
			TCP_RMV_ACTIVE(pcb);
    6f14:	2500      	movs	r5, #0
			if (pcb->state == ESTABLISHED) {
    6f16:	2a04      	cmp	r2, #4
			TCP_RMV_ACTIVE(pcb);
    6f18:	60e5      	str	r5, [r4, #12]
			if (pcb->state == ESTABLISHED) {
    6f1a:	d13b      	bne.n	6f94 <tcp_close_shutdown+0xcc>
				pcb->state = TIME_WAIT;
    6f1c:	220a      	movs	r2, #10
    6f1e:	7622      	strb	r2, [r4, #24]
				TCP_REG(&tcp_tw_pcbs, pcb);
    6f20:	69da      	ldr	r2, [r3, #28]
    6f22:	60e2      	str	r2, [r4, #12]
    6f24:	61dc      	str	r4, [r3, #28]
    6f26:	4b3b      	ldr	r3, [pc, #236]	; (7014 <tcp_close_shutdown+0x14c>)
    6f28:	4798      	blx	r3
	switch (pcb->state) {
    6f2a:	2000      	movs	r0, #0
}
    6f2c:	b003      	add	sp, #12
    6f2e:	bd30      	pop	{r4, r5, pc}
			TCP_RMV_ACTIVE(pcb);
    6f30:	605a      	str	r2, [r3, #4]
    6f32:	2100      	movs	r1, #0
    6f34:	b91a      	cbnz	r2, 6f3e <tcp_close_shutdown+0x76>
    6f36:	2900      	cmp	r1, #0
    6f38:	d0e9      	beq.n	6f0e <tcp_close_shutdown+0x46>
    6f3a:	605a      	str	r2, [r3, #4]
    6f3c:	e7e7      	b.n	6f0e <tcp_close_shutdown+0x46>
    6f3e:	68d0      	ldr	r0, [r2, #12]
    6f40:	42a0      	cmp	r0, r4
    6f42:	d104      	bne.n	6f4e <tcp_close_shutdown+0x86>
    6f44:	b101      	cbz	r1, 6f48 <tcp_close_shutdown+0x80>
    6f46:	605a      	str	r2, [r3, #4]
    6f48:	68e1      	ldr	r1, [r4, #12]
    6f4a:	60d1      	str	r1, [r2, #12]
    6f4c:	e7df      	b.n	6f0e <tcp_close_shutdown+0x46>
    6f4e:	2101      	movs	r1, #1
    6f50:	4602      	mov	r2, r0
    6f52:	e7ef      	b.n	6f34 <tcp_close_shutdown+0x6c>
	switch (pcb->state) {
    6f54:	2b07      	cmp	r3, #7
    6f56:	d8e8      	bhi.n	6f2a <tcp_close_shutdown+0x62>
    6f58:	a201      	add	r2, pc, #4	; (adr r2, 6f60 <tcp_close_shutdown+0x98>)
    6f5a:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
    6f5e:	bf00      	nop
    6f60:	00006f81 	.word	0x00006f81
    6f64:	00006fc3 	.word	0x00006fc3
    6f68:	00006fd1 	.word	0x00006fd1
    6f6c:	00006fe5 	.word	0x00006fe5
    6f70:	00006fe5 	.word	0x00006fe5
    6f74:	00006f2b 	.word	0x00006f2b
    6f78:	00006f2b 	.word	0x00006f2b
    6f7c:	00006ffb 	.word	0x00006ffb
		if (pcb->local_port != 0) {
    6f80:	8b63      	ldrh	r3, [r4, #26]
    6f82:	b13b      	cbz	r3, 6f94 <tcp_close_shutdown+0xcc>
			TCP_RMV(&tcp_bound_pcbs, pcb);
    6f84:	4a22      	ldr	r2, [pc, #136]	; (7010 <tcp_close_shutdown+0x148>)
    6f86:	6813      	ldr	r3, [r2, #0]
    6f88:	42a3      	cmp	r3, r4
    6f8a:	d108      	bne.n	6f9e <tcp_close_shutdown+0xd6>
    6f8c:	68e3      	ldr	r3, [r4, #12]
    6f8e:	6013      	str	r3, [r2, #0]
    6f90:	2300      	movs	r3, #0
    6f92:	60e3      	str	r3, [r4, #12]
				memp_free(MEMP_TCP_PCB, pcb);
    6f94:	4621      	mov	r1, r4
    6f96:	2001      	movs	r0, #1
		memp_free(MEMP_TCP_PCB, pcb);
    6f98:	4b1f      	ldr	r3, [pc, #124]	; (7018 <tcp_close_shutdown+0x150>)
    6f9a:	4798      	blx	r3
	if (pcb != NULL && err == ERR_OK) {
    6f9c:	e7c5      	b.n	6f2a <tcp_close_shutdown+0x62>
			TCP_RMV(&tcp_bound_pcbs, pcb);
    6f9e:	6053      	str	r3, [r2, #4]
    6fa0:	2100      	movs	r1, #0
    6fa2:	b91b      	cbnz	r3, 6fac <tcp_close_shutdown+0xe4>
    6fa4:	2900      	cmp	r1, #0
    6fa6:	d0f3      	beq.n	6f90 <tcp_close_shutdown+0xc8>
    6fa8:	6053      	str	r3, [r2, #4]
    6faa:	e7f1      	b.n	6f90 <tcp_close_shutdown+0xc8>
    6fac:	68d8      	ldr	r0, [r3, #12]
    6fae:	42a0      	cmp	r0, r4
    6fb0:	d104      	bne.n	6fbc <tcp_close_shutdown+0xf4>
    6fb2:	b101      	cbz	r1, 6fb6 <tcp_close_shutdown+0xee>
    6fb4:	6053      	str	r3, [r2, #4]
    6fb6:	68e2      	ldr	r2, [r4, #12]
    6fb8:	60da      	str	r2, [r3, #12]
    6fba:	e7e9      	b.n	6f90 <tcp_close_shutdown+0xc8>
    6fbc:	2101      	movs	r1, #1
    6fbe:	4603      	mov	r3, r0
    6fc0:	e7ef      	b.n	6fa2 <tcp_close_shutdown+0xda>
		tcp_pcb_remove(&tcp_listen_pcbs.pcbs, pcb);
    6fc2:	4816      	ldr	r0, [pc, #88]	; (701c <tcp_close_shutdown+0x154>)
    6fc4:	4b16      	ldr	r3, [pc, #88]	; (7020 <tcp_close_shutdown+0x158>)
    6fc6:	4621      	mov	r1, r4
    6fc8:	4798      	blx	r3
		memp_free(MEMP_TCP_PCB_LISTEN, pcb);
    6fca:	4621      	mov	r1, r4
    6fcc:	2002      	movs	r0, #2
    6fce:	e7e3      	b.n	6f98 <tcp_close_shutdown+0xd0>
		TCP_PCB_REMOVE_ACTIVE(pcb);
    6fd0:	4d0f      	ldr	r5, [pc, #60]	; (7010 <tcp_close_shutdown+0x148>)
    6fd2:	4b13      	ldr	r3, [pc, #76]	; (7020 <tcp_close_shutdown+0x158>)
    6fd4:	4621      	mov	r1, r4
    6fd6:	f105 0014 	add.w	r0, r5, #20
    6fda:	4798      	blx	r3
    6fdc:	2001      	movs	r0, #1
    6fde:	7628      	strb	r0, [r5, #24]
		memp_free(MEMP_TCP_PCB, pcb);
    6fe0:	4621      	mov	r1, r4
    6fe2:	e7d9      	b.n	6f98 <tcp_close_shutdown+0xd0>
		err = tcp_send_fin(pcb);
    6fe4:	4b0f      	ldr	r3, [pc, #60]	; (7024 <tcp_close_shutdown+0x15c>)
    6fe6:	4620      	mov	r0, r4
    6fe8:	4798      	blx	r3
		if (err == ERR_OK) {
    6fea:	2800      	cmp	r0, #0
    6fec:	d19e      	bne.n	6f2c <tcp_close_shutdown+0x64>
			pcb->state = FIN_WAIT_1;
    6fee:	2305      	movs	r3, #5
			pcb->state = LAST_ACK;
    6ff0:	7623      	strb	r3, [r4, #24]
		tcp_output(pcb);
    6ff2:	4620      	mov	r0, r4
    6ff4:	4b0c      	ldr	r3, [pc, #48]	; (7028 <tcp_close_shutdown+0x160>)
    6ff6:	4798      	blx	r3
    6ff8:	e797      	b.n	6f2a <tcp_close_shutdown+0x62>
		err = tcp_send_fin(pcb);
    6ffa:	4b0a      	ldr	r3, [pc, #40]	; (7024 <tcp_close_shutdown+0x15c>)
    6ffc:	4620      	mov	r0, r4
    6ffe:	4798      	blx	r3
		if (err == ERR_OK) {
    7000:	2800      	cmp	r0, #0
    7002:	d193      	bne.n	6f2c <tcp_close_shutdown+0x64>
			pcb->state = LAST_ACK;
    7004:	2309      	movs	r3, #9
    7006:	e7f3      	b.n	6ff0 <tcp_close_shutdown+0x128>
    7008:	00002725 	.word	0x00002725
    700c:	00006b55 	.word	0x00006b55
    7010:	2001493c 	.word	0x2001493c
    7014:	000010a1 	.word	0x000010a1
    7018:	00004c21 	.word	0x00004c21
    701c:	20014944 	.word	0x20014944
    7020:	00006e5d 	.word	0x00006e5d
    7024:	000023dd 	.word	0x000023dd
    7028:	000024a1 	.word	0x000024a1

0000702c <tcp_close>:
	if (pcb->state != LISTEN) {
    702c:	7e03      	ldrb	r3, [r0, #24]
    702e:	2b01      	cmp	r3, #1
		pcb->flags |= TF_RXCLOSED;
    7030:	bf1e      	ittt	ne
    7032:	7f83      	ldrbne	r3, [r0, #30]
    7034:	f043 0310 	orrne.w	r3, r3, #16
    7038:	7783      	strbne	r3, [r0, #30]
	return tcp_close_shutdown(pcb, 1);
    703a:	2101      	movs	r1, #1
    703c:	4b00      	ldr	r3, [pc, #0]	; (7040 <tcp_close+0x14>)
    703e:	4718      	bx	r3
    7040:	00006ec9 	.word	0x00006ec9

00007044 <tcp_recv_null>:
{
    7044:	b510      	push	{r4, lr}
    7046:	4608      	mov	r0, r1
	if (p != NULL) {
    7048:	4614      	mov	r4, r2
    704a:	b13a      	cbz	r2, 705c <tcp_recv_null+0x18>
		tcp_recved(pcb, p->tot_len);
    704c:	4b06      	ldr	r3, [pc, #24]	; (7068 <tcp_recv_null+0x24>)
    704e:	8911      	ldrh	r1, [r2, #8]
    7050:	4798      	blx	r3
		pbuf_free(p);
    7052:	4b06      	ldr	r3, [pc, #24]	; (706c <tcp_recv_null+0x28>)
    7054:	4620      	mov	r0, r4
    7056:	4798      	blx	r3
}
    7058:	2000      	movs	r0, #0
    705a:	bd10      	pop	{r4, pc}
	} else if (err == ERR_OK) {
    705c:	2b00      	cmp	r3, #0
    705e:	d1fb      	bne.n	7058 <tcp_recv_null+0x14>
}
    7060:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		return tcp_close(pcb);
    7064:	4b02      	ldr	r3, [pc, #8]	; (7070 <tcp_recv_null+0x2c>)
    7066:	4718      	bx	r3
    7068:	00006a85 	.word	0x00006a85
    706c:	000030e1 	.word	0x000030e1
    7070:	0000702d 	.word	0x0000702d

00007074 <tcp_process_refused_data>:
{
    7074:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	u8_t  refused_flags = pcb->refused_data->flags;
    7076:	6f86      	ldr	r6, [r0, #120]	; 0x78
	TCP_EVENT_RECV(pcb, refused_data, ERR_OK, err);
    7078:	f8d0 5080 	ldr.w	r5, [r0, #128]	; 0x80
	u8_t  refused_flags = pcb->refused_data->flags;
    707c:	7b77      	ldrb	r7, [r6, #13]
	pcb->refused_data         = NULL;
    707e:	2300      	movs	r3, #0
{
    7080:	4604      	mov	r4, r0
	pcb->refused_data         = NULL;
    7082:	6783      	str	r3, [r0, #120]	; 0x78
	TCP_EVENT_RECV(pcb, refused_data, ERR_OK, err);
    7084:	b1e5      	cbz	r5, 70c0 <tcp_process_refused_data+0x4c>
    7086:	4601      	mov	r1, r0
    7088:	4632      	mov	r2, r6
    708a:	6900      	ldr	r0, [r0, #16]
    708c:	47a8      	blx	r5
    708e:	4605      	mov	r5, r0
	if (err == ERR_OK) {
    7090:	b9e8      	cbnz	r0, 70ce <tcp_process_refused_data+0x5a>
		if (refused_flags & PBUF_FLAG_TCP_FIN) {
    7092:	06bb      	lsls	r3, r7, #26
    7094:	d512      	bpl.n	70bc <tcp_process_refused_data+0x48>
			if (pcb->rcv_wnd != TCP_WND) {
    7096:	8da3      	ldrh	r3, [r4, #44]	; 0x2c
			TCP_EVENT_CLOSED(pcb, err);
    7098:	f8d4 6080 	ldr.w	r6, [r4, #128]	; 0x80
			if (pcb->rcv_wnd != TCP_WND) {
    709c:	f241 62d0 	movw	r2, #5840	; 0x16d0
    70a0:	4293      	cmp	r3, r2
				pcb->rcv_wnd++;
    70a2:	bf1c      	itt	ne
    70a4:	3301      	addne	r3, #1
    70a6:	85a3      	strhne	r3, [r4, #44]	; 0x2c
			TCP_EVENT_CLOSED(pcb, err);
    70a8:	b146      	cbz	r6, 70bc <tcp_process_refused_data+0x48>
    70aa:	2300      	movs	r3, #0
    70ac:	6920      	ldr	r0, [r4, #16]
    70ae:	461a      	mov	r2, r3
    70b0:	4621      	mov	r1, r4
    70b2:	47b0      	blx	r6
			if (err == ERR_ABRT) {
    70b4:	300a      	adds	r0, #10
    70b6:	d101      	bne.n	70bc <tcp_process_refused_data+0x48>
				return ERR_ABRT;
    70b8:	f06f 0509 	mvn.w	r5, #9
}
    70bc:	4628      	mov	r0, r5
    70be:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	TCP_EVENT_RECV(pcb, refused_data, ERR_OK, err);
    70c0:	462b      	mov	r3, r5
    70c2:	4601      	mov	r1, r0
    70c4:	4632      	mov	r2, r6
    70c6:	4628      	mov	r0, r5
    70c8:	4d03      	ldr	r5, [pc, #12]	; (70d8 <tcp_process_refused_data+0x64>)
    70ca:	47a8      	blx	r5
    70cc:	e7df      	b.n	708e <tcp_process_refused_data+0x1a>
	} else if (err == ERR_ABRT) {
    70ce:	350a      	adds	r5, #10
    70d0:	d0f2      	beq.n	70b8 <tcp_process_refused_data+0x44>
		pcb->refused_data = refused_data;
    70d2:	67a6      	str	r6, [r4, #120]	; 0x78
	return ERR_OK;
    70d4:	2500      	movs	r5, #0
    70d6:	e7f1      	b.n	70bc <tcp_process_refused_data+0x48>
    70d8:	00007045 	.word	0x00007045

000070dc <tcp_fasttmr>:
{
    70dc:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	++tcp_timer_ctr;
    70e0:	4d15      	ldr	r5, [pc, #84]	; (7138 <tcp_fasttmr+0x5c>)
				tcp_output(pcb);
    70e2:	4e16      	ldr	r6, [pc, #88]	; (713c <tcp_fasttmr+0x60>)
	++tcp_timer_ctr;
    70e4:	7c2b      	ldrb	r3, [r5, #16]
				tcp_process_refused_data(pcb);
    70e6:	f8df 8058 	ldr.w	r8, [pc, #88]	; 7140 <tcp_fasttmr+0x64>
	++tcp_timer_ctr;
    70ea:	3301      	adds	r3, #1
    70ec:	742b      	strb	r3, [r5, #16]
	pcb = tcp_active_pcbs;
    70ee:	696c      	ldr	r4, [r5, #20]
				tcp_active_pcbs_changed = 0;
    70f0:	2700      	movs	r7, #0
		if (pcb->last_timer != tcp_timer_ctr) {
    70f2:	7c2b      	ldrb	r3, [r5, #16]
	while (pcb != NULL) {
    70f4:	b90c      	cbnz	r4, 70fa <tcp_fasttmr+0x1e>
}
    70f6:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
		if (pcb->last_timer != tcp_timer_ctr) {
    70fa:	f894 2021 	ldrb.w	r2, [r4, #33]	; 0x21
    70fe:	429a      	cmp	r2, r3
    7100:	d0f8      	beq.n	70f4 <tcp_fasttmr+0x18>
			pcb->last_timer = tcp_timer_ctr;
    7102:	f884 3021 	strb.w	r3, [r4, #33]	; 0x21
			if (pcb->flags & TF_ACK_DELAY) {
    7106:	7fa3      	ldrb	r3, [r4, #30]
    7108:	07da      	lsls	r2, r3, #31
    710a:	d508      	bpl.n	711e <tcp_fasttmr+0x42>
				tcp_ack_now(pcb);
    710c:	f043 0302 	orr.w	r3, r3, #2
    7110:	77a3      	strb	r3, [r4, #30]
				tcp_output(pcb);
    7112:	4620      	mov	r0, r4
    7114:	47b0      	blx	r6
				pcb->flags &= ~(TF_ACK_DELAY | TF_ACK_NOW);
    7116:	7fa3      	ldrb	r3, [r4, #30]
    7118:	f023 0303 	bic.w	r3, r3, #3
    711c:	77a3      	strb	r3, [r4, #30]
			if (pcb->refused_data != NULL) {
    711e:	6fa3      	ldr	r3, [r4, #120]	; 0x78
			next = pcb->next;
    7120:	f8d4 900c 	ldr.w	r9, [r4, #12]
			if (pcb->refused_data != NULL) {
    7124:	b12b      	cbz	r3, 7132 <tcp_fasttmr+0x56>
				tcp_process_refused_data(pcb);
    7126:	4620      	mov	r0, r4
				tcp_active_pcbs_changed = 0;
    7128:	762f      	strb	r7, [r5, #24]
				tcp_process_refused_data(pcb);
    712a:	47c0      	blx	r8
				if (tcp_active_pcbs_changed) {
    712c:	7e2b      	ldrb	r3, [r5, #24]
    712e:	2b00      	cmp	r3, #0
    7130:	d1dd      	bne.n	70ee <tcp_fasttmr+0x12>
{
    7132:	464c      	mov	r4, r9
    7134:	e7dd      	b.n	70f2 <tcp_fasttmr+0x16>
    7136:	bf00      	nop
    7138:	2001493c 	.word	0x2001493c
    713c:	000024a1 	.word	0x000024a1
    7140:	00007075 	.word	0x00007075

00007144 <tcp_tmr>:
	tcp_fasttmr();
    7144:	4b08      	ldr	r3, [pc, #32]	; (7168 <tcp_tmr+0x24>)
{
    7146:	b510      	push	{r4, lr}
	tcp_fasttmr();
    7148:	4798      	blx	r3
	if (++tcp_timer & 1) {
    714a:	4a08      	ldr	r2, [pc, #32]	; (716c <tcp_tmr+0x28>)
    714c:	f892 3020 	ldrb.w	r3, [r2, #32]
    7150:	3301      	adds	r3, #1
    7152:	b2db      	uxtb	r3, r3
    7154:	f882 3020 	strb.w	r3, [r2, #32]
    7158:	07db      	lsls	r3, r3, #31
    715a:	d503      	bpl.n	7164 <tcp_tmr+0x20>
}
    715c:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		tcp_slowtmr();
    7160:	4b03      	ldr	r3, [pc, #12]	; (7170 <tcp_tmr+0x2c>)
    7162:	4718      	bx	r3
}
    7164:	bd10      	pop	{r4, pc}
    7166:	bf00      	nop
    7168:	000070dd 	.word	0x000070dd
    716c:	2001493c 	.word	0x2001493c
    7170:	00006b99 	.word	0x00006b99

00007174 <tcp_shutdown>:
{
    7174:	b570      	push	{r4, r5, r6, lr}
	if (pcb->state == LISTEN) {
    7176:	7e03      	ldrb	r3, [r0, #24]
    7178:	2b01      	cmp	r3, #1
{
    717a:	4605      	mov	r5, r0
    717c:	4614      	mov	r4, r2
	if (pcb->state == LISTEN) {
    717e:	d018      	beq.n	71b2 <tcp_shutdown+0x3e>
	if (shut_rx) {
    7180:	b189      	cbz	r1, 71a6 <tcp_shutdown+0x32>
		pcb->flags |= TF_RXCLOSED;
    7182:	7f83      	ldrb	r3, [r0, #30]
    7184:	f043 0310 	orr.w	r3, r3, #16
    7188:	7783      	strb	r3, [r0, #30]
		if (shut_tx) {
    718a:	b122      	cbz	r2, 7196 <tcp_shutdown+0x22>
			return tcp_close_shutdown(pcb, 1);
    718c:	2101      	movs	r1, #1
}
    718e:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
			return tcp_close_shutdown(pcb, shut_rx);
    7192:	4b0c      	ldr	r3, [pc, #48]	; (71c4 <tcp_shutdown+0x50>)
    7194:	4718      	bx	r3
		if (pcb->refused_data != NULL) {
    7196:	6f80      	ldr	r0, [r0, #120]	; 0x78
    7198:	b908      	cbnz	r0, 719e <tcp_shutdown+0x2a>
	return ERR_OK;
    719a:	2000      	movs	r0, #0
}
    719c:	bd70      	pop	{r4, r5, r6, pc}
			pbuf_free(pcb->refused_data);
    719e:	4b0a      	ldr	r3, [pc, #40]	; (71c8 <tcp_shutdown+0x54>)
    71a0:	4798      	blx	r3
			pcb->refused_data = NULL;
    71a2:	67ac      	str	r4, [r5, #120]	; 0x78
    71a4:	e7f9      	b.n	719a <tcp_shutdown+0x26>
	if (shut_tx) {
    71a6:	2a00      	cmp	r2, #0
    71a8:	d0f7      	beq.n	719a <tcp_shutdown+0x26>
		switch (pcb->state) {
    71aa:	2b04      	cmp	r3, #4
    71ac:	d804      	bhi.n	71b8 <tcp_shutdown+0x44>
    71ae:	2b02      	cmp	r3, #2
    71b0:	d804      	bhi.n	71bc <tcp_shutdown+0x48>
    71b2:	f06f 000c 	mvn.w	r0, #12
    71b6:	e7f1      	b.n	719c <tcp_shutdown+0x28>
    71b8:	2b07      	cmp	r3, #7
    71ba:	d1fa      	bne.n	71b2 <tcp_shutdown+0x3e>
			return tcp_close_shutdown(pcb, shut_rx);
    71bc:	2100      	movs	r1, #0
    71be:	4628      	mov	r0, r5
    71c0:	e7e5      	b.n	718e <tcp_shutdown+0x1a>
    71c2:	bf00      	nop
    71c4:	00006ec9 	.word	0x00006ec9
    71c8:	000030e1 	.word	0x000030e1

000071cc <tcp_abandon>:
{
    71cc:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
	if (pcb->state == TIME_WAIT) {
    71d0:	7e03      	ldrb	r3, [r0, #24]
    71d2:	4f23      	ldr	r7, [pc, #140]	; (7260 <tcp_abandon+0x94>)
    71d4:	2b0a      	cmp	r3, #10
{
    71d6:	4604      	mov	r4, r0
    71d8:	4b22      	ldr	r3, [pc, #136]	; (7264 <tcp_abandon+0x98>)
    71da:	460d      	mov	r5, r1
	if (pcb->state == TIME_WAIT) {
    71dc:	d109      	bne.n	71f2 <tcp_abandon+0x26>
		tcp_pcb_remove(&tcp_tw_pcbs, pcb);
    71de:	4601      	mov	r1, r0
    71e0:	4821      	ldr	r0, [pc, #132]	; (7268 <tcp_abandon+0x9c>)
    71e2:	4798      	blx	r3
		memp_free(MEMP_TCP_PCB, pcb);
    71e4:	4621      	mov	r1, r4
    71e6:	2001      	movs	r0, #1
    71e8:	463b      	mov	r3, r7
}
    71ea:	b003      	add	sp, #12
    71ec:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
		memp_free(MEMP_TCP_PCB, pcb);
    71f0:	4718      	bx	r3
		TCP_PCB_REMOVE_ACTIVE(pcb);
    71f2:	f8df b080 	ldr.w	fp, [pc, #128]	; 7274 <tcp_abandon+0xa8>
		seqno = pcb->snd_nxt;
    71f6:	f8d0 9050 	ldr.w	r9, [r0, #80]	; 0x50
		ackno = pcb->rcv_nxt;
    71fa:	f8d0 a028 	ldr.w	sl, [r0, #40]	; 0x28
		errf = pcb->errf;
    71fe:	f8d0 608c 	ldr.w	r6, [r0, #140]	; 0x8c
		errf_arg = pcb->callback_arg;
    7202:	f8d0 8010 	ldr.w	r8, [r0, #16]
		TCP_PCB_REMOVE_ACTIVE(pcb);
    7206:	4601      	mov	r1, r0
    7208:	f10b 0014 	add.w	r0, fp, #20
    720c:	4798      	blx	r3
		if (pcb->unacked != NULL) {
    720e:	6f20      	ldr	r0, [r4, #112]	; 0x70
		TCP_PCB_REMOVE_ACTIVE(pcb);
    7210:	2301      	movs	r3, #1
    7212:	f88b 3018 	strb.w	r3, [fp, #24]
		if (pcb->unacked != NULL) {
    7216:	b108      	cbz	r0, 721c <tcp_abandon+0x50>
			tcp_segs_free(pcb->unacked);
    7218:	4b14      	ldr	r3, [pc, #80]	; (726c <tcp_abandon+0xa0>)
    721a:	4798      	blx	r3
		if (pcb->unsent != NULL) {
    721c:	6ee0      	ldr	r0, [r4, #108]	; 0x6c
    721e:	b108      	cbz	r0, 7224 <tcp_abandon+0x58>
			tcp_segs_free(pcb->unsent);
    7220:	4b12      	ldr	r3, [pc, #72]	; (726c <tcp_abandon+0xa0>)
    7222:	4798      	blx	r3
		if (pcb->ooseq != NULL) {
    7224:	6f60      	ldr	r0, [r4, #116]	; 0x74
    7226:	b108      	cbz	r0, 722c <tcp_abandon+0x60>
			tcp_segs_free(pcb->ooseq);
    7228:	4b10      	ldr	r3, [pc, #64]	; (726c <tcp_abandon+0xa0>)
    722a:	4798      	blx	r3
		if (reset) {
    722c:	b14d      	cbz	r5, 7242 <tcp_abandon+0x76>
			tcp_rst(seqno, ackno, &pcb->local_ip, &pcb->remote_ip, pcb->local_port, pcb->remote_port);
    722e:	8ba3      	ldrh	r3, [r4, #28]
    7230:	9301      	str	r3, [sp, #4]
    7232:	8b63      	ldrh	r3, [r4, #26]
    7234:	9300      	str	r3, [sp, #0]
    7236:	4d0e      	ldr	r5, [pc, #56]	; (7270 <tcp_abandon+0xa4>)
    7238:	1d23      	adds	r3, r4, #4
    723a:	4622      	mov	r2, r4
    723c:	4651      	mov	r1, sl
    723e:	4648      	mov	r0, r9
    7240:	47a8      	blx	r5
		memp_free(MEMP_TCP_PCB, pcb);
    7242:	4621      	mov	r1, r4
    7244:	2001      	movs	r0, #1
    7246:	47b8      	blx	r7
		TCP_EVENT_ERR(errf, errf_arg, ERR_ABRT);
    7248:	b13e      	cbz	r6, 725a <tcp_abandon+0x8e>
    724a:	f06f 0109 	mvn.w	r1, #9
    724e:	4640      	mov	r0, r8
    7250:	4633      	mov	r3, r6
}
    7252:	b003      	add	sp, #12
    7254:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
		TCP_EVENT_ERR(errf, errf_arg, ERR_ABRT);
    7258:	4718      	bx	r3
}
    725a:	b003      	add	sp, #12
    725c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    7260:	00004c21 	.word	0x00004c21
    7264:	00006e5d 	.word	0x00006e5d
    7268:	20014958 	.word	0x20014958
    726c:	00006ae9 	.word	0x00006ae9
    7270:	00002725 	.word	0x00002725
    7274:	2001493c 	.word	0x2001493c

00007278 <tcp_abort>:
	tcp_abandon(pcb, 1);
    7278:	4b01      	ldr	r3, [pc, #4]	; (7280 <tcp_abort+0x8>)
    727a:	2101      	movs	r1, #1
    727c:	4718      	bx	r3
    727e:	bf00      	nop
    7280:	000071cd 	.word	0x000071cd

00007284 <tcp_next_iss>:
 */
u32_t tcp_next_iss(void)
{
	static u32_t iss = 6510;

	iss += tcp_ticks; /* XXX */
    7284:	4b03      	ldr	r3, [pc, #12]	; (7294 <tcp_next_iss+0x10>)
    7286:	4a04      	ldr	r2, [pc, #16]	; (7298 <tcp_next_iss+0x14>)
    7288:	6858      	ldr	r0, [r3, #4]
    728a:	68d2      	ldr	r2, [r2, #12]
    728c:	4410      	add	r0, r2
    728e:	6058      	str	r0, [r3, #4]
	return iss;
}
    7290:	4770      	bx	lr
    7292:	bf00      	nop
    7294:	2000000c 	.word	0x2000000c
    7298:	2001493c 	.word	0x2001493c

0000729c <tcp_alloc>:
{
    729c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	pcb = (struct tcp_pcb *)memp_malloc(MEMP_TCP_PCB);
    729e:	4e34      	ldr	r6, [pc, #208]	; (7370 <tcp_alloc+0xd4>)
    72a0:	4d34      	ldr	r5, [pc, #208]	; (7374 <tcp_alloc+0xd8>)
{
    72a2:	4607      	mov	r7, r0
	pcb = (struct tcp_pcb *)memp_malloc(MEMP_TCP_PCB);
    72a4:	2001      	movs	r0, #1
    72a6:	47b0      	blx	r6
	if (pcb == NULL) {
    72a8:	4604      	mov	r4, r0
    72aa:	b9d8      	cbnz	r0, 72e4 <tcp_alloc+0x48>
	for (pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
    72ac:	69eb      	ldr	r3, [r5, #28]
		if ((u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {
    72ae:	68e8      	ldr	r0, [r5, #12]
	inactivity = 0;
    72b0:	4621      	mov	r1, r4
	for (pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
    72b2:	2b00      	cmp	r3, #0
    72b4:	d145      	bne.n	7342 <tcp_alloc+0xa6>
	if (inactive != NULL) {
    72b6:	b114      	cbz	r4, 72be <tcp_alloc+0x22>
		tcp_abort(inactive);
    72b8:	4b2f      	ldr	r3, [pc, #188]	; (7378 <tcp_alloc+0xdc>)
    72ba:	4620      	mov	r0, r4
    72bc:	4798      	blx	r3
		pcb = (struct tcp_pcb *)memp_malloc(MEMP_TCP_PCB);
    72be:	2001      	movs	r0, #1
    72c0:	47b0      	blx	r6
		if (pcb == NULL) {
    72c2:	4604      	mov	r4, r0
    72c4:	b970      	cbnz	r0, 72e4 <tcp_alloc+0x48>
	for (pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
    72c6:	696b      	ldr	r3, [r5, #20]
		if (pcb->prio <= prio && pcb->prio <= mprio && (u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {
    72c8:	f8d5 e00c 	ldr.w	lr, [r5, #12]
	mprio = TCP_PRIO_MAX;
    72cc:	207f      	movs	r0, #127	; 0x7f
	inactivity = 0;
    72ce:	46a4      	mov	ip, r4
	for (pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
    72d0:	2b00      	cmp	r3, #0
    72d2:	d13e      	bne.n	7352 <tcp_alloc+0xb6>
	if (inactive != NULL) {
    72d4:	b114      	cbz	r4, 72dc <tcp_alloc+0x40>
		tcp_abort(inactive);
    72d6:	4b28      	ldr	r3, [pc, #160]	; (7378 <tcp_alloc+0xdc>)
    72d8:	4620      	mov	r0, r4
    72da:	4798      	blx	r3
			pcb = (struct tcp_pcb *)memp_malloc(MEMP_TCP_PCB);
    72dc:	2001      	movs	r0, #1
    72de:	47b0      	blx	r6
	if (pcb != NULL) {
    72e0:	4604      	mov	r4, r0
    72e2:	b360      	cbz	r0, 733e <tcp_alloc+0xa2>
		memset(pcb, 0, sizeof(struct tcp_pcb));
    72e4:	2298      	movs	r2, #152	; 0x98
    72e6:	4b25      	ldr	r3, [pc, #148]	; (737c <tcp_alloc+0xe0>)
    72e8:	2100      	movs	r1, #0
    72ea:	4620      	mov	r0, r4
    72ec:	4798      	blx	r3
		pcb->snd_buf      = TCP_SND_BUF;
    72ee:	f640 3368 	movw	r3, #2920	; 0xb68
    72f2:	f8a4 3066 	strh.w	r3, [r4, #102]	; 0x66
		pcb->rcv_wnd      = TCP_WND;
    72f6:	4b22      	ldr	r3, [pc, #136]	; (7380 <tcp_alloc+0xe4>)
    72f8:	62e3      	str	r3, [r4, #44]	; 0x2c
		pcb->ttl          = TCP_TTL;
    72fa:	23ff      	movs	r3, #255	; 0xff
    72fc:	72a3      	strb	r3, [r4, #10]
		pcb->rto        = 3000 / TCP_SLOW_INTERVAL;
    72fe:	2306      	movs	r3, #6
    7300:	f8a4 3044 	strh.w	r3, [r4, #68]	; 0x44
		pcb->sv         = 3000 / TCP_SLOW_INTERVAL;
    7304:	f8a4 3042 	strh.w	r3, [r4, #66]	; 0x42
		pcb->rtime      = -1;
    7308:	4b1e      	ldr	r3, [pc, #120]	; (7384 <tcp_alloc+0xe8>)
    730a:	6363      	str	r3, [r4, #52]	; 0x34
		pcb->cwnd       = 1;
    730c:	2301      	movs	r3, #1
    730e:	f8a4 304c 	strh.w	r3, [r4, #76]	; 0x4c
		pcb->prio         = prio;
    7312:	7667      	strb	r7, [r4, #25]
		iss             = tcp_next_iss();
    7314:	4b1c      	ldr	r3, [pc, #112]	; (7388 <tcp_alloc+0xec>)
    7316:	4798      	blx	r3
		pcb->tmr        = tcp_ticks;
    7318:	68eb      	ldr	r3, [r5, #12]
		pcb->recv = tcp_recv_null;
    731a:	4a1c      	ldr	r2, [pc, #112]	; (738c <tcp_alloc+0xf0>)
		pcb->tmr        = tcp_ticks;
    731c:	6263      	str	r3, [r4, #36]	; 0x24
		pcb->last_timer = tcp_timer_ctr;
    731e:	7c2b      	ldrb	r3, [r5, #16]
    7320:	f884 3021 	strb.w	r3, [r4, #33]	; 0x21
		pcb->recv = tcp_recv_null;
    7324:	f8c4 2080 	str.w	r2, [r4, #128]	; 0x80
		pcb->polltmr = 0;
    7328:	2300      	movs	r3, #0
		pcb->keep_idle = TCP_KEEPIDLE_DEFAULT;
    732a:	4a19      	ldr	r2, [pc, #100]	; (7390 <tcp_alloc+0xf4>)
		pcb->snd_wl2    = iss;
    732c:	65a0      	str	r0, [r4, #88]	; 0x58
		pcb->snd_nxt    = iss;
    732e:	6520      	str	r0, [r4, #80]	; 0x50
		pcb->lastack    = iss;
    7330:	64a0      	str	r0, [r4, #72]	; 0x48
		pcb->snd_lbb    = iss;
    7332:	65e0      	str	r0, [r4, #92]	; 0x5c
		pcb->polltmr = 0;
    7334:	77e3      	strb	r3, [r4, #31]
		pcb->keep_idle = TCP_KEEPIDLE_DEFAULT;
    7336:	f8c4 2090 	str.w	r2, [r4, #144]	; 0x90
		pcb->keep_cnt_sent = 0;
    733a:	f884 3096 	strb.w	r3, [r4, #150]	; 0x96
}
    733e:	4620      	mov	r0, r4
    7340:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		if ((u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {
    7342:	6a5a      	ldr	r2, [r3, #36]	; 0x24
    7344:	1a82      	subs	r2, r0, r2
    7346:	428a      	cmp	r2, r1
    7348:	bf24      	itt	cs
    734a:	461c      	movcs	r4, r3
    734c:	4611      	movcs	r1, r2
	for (pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
    734e:	68db      	ldr	r3, [r3, #12]
    7350:	e7af      	b.n	72b2 <tcp_alloc+0x16>
		if (pcb->prio <= prio && pcb->prio <= mprio && (u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {
    7352:	7e59      	ldrb	r1, [r3, #25]
    7354:	428f      	cmp	r7, r1
    7356:	d309      	bcc.n	736c <tcp_alloc+0xd0>
    7358:	4281      	cmp	r1, r0
    735a:	d807      	bhi.n	736c <tcp_alloc+0xd0>
    735c:	6a5a      	ldr	r2, [r3, #36]	; 0x24
    735e:	ebae 0202 	sub.w	r2, lr, r2
    7362:	4562      	cmp	r2, ip
    7364:	bf22      	ittt	cs
    7366:	4608      	movcs	r0, r1
    7368:	4694      	movcs	ip, r2
    736a:	461c      	movcs	r4, r3
	for (pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
    736c:	68db      	ldr	r3, [r3, #12]
    736e:	e7af      	b.n	72d0 <tcp_alloc+0x34>
    7370:	00004c05 	.word	0x00004c05
    7374:	2001493c 	.word	0x2001493c
    7378:	00007279 	.word	0x00007279
    737c:	0000c099 	.word	0x0000c099
    7380:	16d016d0 	.word	0x16d016d0
    7384:	0218ffff 	.word	0x0218ffff
    7388:	00007285 	.word	0x00007285
    738c:	00007045 	.word	0x00007045
    7390:	006ddd00 	.word	0x006ddd00

00007394 <tcp_new>:
	return tcp_alloc(TCP_PRIO_NORMAL);
    7394:	4b01      	ldr	r3, [pc, #4]	; (739c <tcp_new+0x8>)
    7396:	2040      	movs	r0, #64	; 0x40
    7398:	4718      	bx	r3
    739a:	bf00      	nop
    739c:	0000729d 	.word	0x0000729d

000073a0 <tcp_eff_send_mss>:
 * Calcluates the effective send mss that can be used for a specific IP address
 * by using ip_route to determin the netif used to send to the address and
 * calculating the minimum of TCP_MSS and that netif's mtu (if set).
 */
u16_t tcp_eff_send_mss(u16_t sendmss, ip_addr_t *addr)
{
    73a0:	b510      	push	{r4, lr}
	u16_t         mss_s;
	struct netif *outif;

	outif = ip_route(addr);
    73a2:	4b07      	ldr	r3, [pc, #28]	; (73c0 <tcp_eff_send_mss+0x20>)
{
    73a4:	4604      	mov	r4, r0
	outif = ip_route(addr);
    73a6:	4608      	mov	r0, r1
    73a8:	4798      	blx	r3
	if ((outif != NULL) && (outif->mtu != 0)) {
    73aa:	b130      	cbz	r0, 73ba <tcp_eff_send_mss+0x1a>
    73ac:	8d03      	ldrh	r3, [r0, #40]	; 0x28
    73ae:	b123      	cbz	r3, 73ba <tcp_eff_send_mss+0x1a>
		mss_s = outif->mtu - IP_HLEN - TCP_HLEN;
    73b0:	3b28      	subs	r3, #40	; 0x28
		/* RFC 1122, chap 4.2.2.6:
		 * Eff.snd.MSS = min(SendMSS+20, MMS_S) - TCPhdrsize - IPoptionsize
		 * We correct for TCP options in tcp_write(), and don't support IP options.
		 */
		sendmss = LWIP_MIN(sendmss, mss_s);
    73b2:	b29b      	uxth	r3, r3
    73b4:	429c      	cmp	r4, r3
    73b6:	bf28      	it	cs
    73b8:	461c      	movcs	r4, r3
	}
	return sendmss;
}
    73ba:	4620      	mov	r0, r4
    73bc:	bd10      	pop	{r4, pc}
    73be:	bf00      	nop
    73c0:	0000635d 	.word	0x0000635d

000073c4 <mac_low_level_init>:

/**
 * \brief Initialize the MAC hardware
 */
void mac_low_level_init(struct netif *netif)
{
    73c4:	b51f      	push	{r0, r1, r2, r3, r4, lr}
    73c6:	4603      	mov	r3, r0
	struct mac_async_filter      filter;

	mac = (struct mac_async_descriptor *)(netif->state);

	/* set MAC hardware address */
	memcpy(filter.mac, netif->hwaddr, NETIF_MAX_HWADDR_LEN);
    73c8:	f8d0 002b 	ldr.w	r0, [r0, #43]	; 0x2b
    73cc:	f8b3 202f 	ldrh.w	r2, [r3, #47]	; 0x2f
    73d0:	9001      	str	r0, [sp, #4]
    73d2:	f8ad 2008 	strh.w	r2, [sp, #8]
	filter.tid_enable = false;
    73d6:	2100      	movs	r1, #0
	mac_async_set_filter(mac, 0, &filter);
    73d8:	6a18      	ldr	r0, [r3, #32]
    73da:	4b04      	ldr	r3, [pc, #16]	; (73ec <mac_low_level_init+0x28>)
	filter.tid_enable = false;
    73dc:	f88d 100c 	strb.w	r1, [sp, #12]
	mac_async_set_filter(mac, 0, &filter);
    73e0:	aa01      	add	r2, sp, #4
    73e2:	4798      	blx	r3
}
    73e4:	b005      	add	sp, #20
    73e6:	f85d fb04 	ldr.w	pc, [sp], #4
    73ea:	bf00      	nop
    73ec:	00004d85 	.word	0x00004d85

000073f0 <mac_low_level_output>:

/**
 * \berif Transmission packet though the MAC hardware.
 */
err_t mac_low_level_output(struct netif *netif, struct pbuf *p)
{
    73f0:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    73f4:	460c      	mov	r4, r1
	struct mac_async_descriptor *mac;
	struct pbuf *                q;
	void *                       tbuf;
	uint8_t *                    pos;

	mac = (struct mac_async_descriptor *)(netif->state);
    73f6:	6a07      	ldr	r7, [r0, #32]

#if ETH_PAD_SIZE
	pbuf_header(p, -ETH_PAD_SIZE); /* drop the padding word */
    73f8:	4e1c      	ldr	r6, [pc, #112]	; (746c <mac_low_level_output+0x7c>)
    73fa:	f06f 0101 	mvn.w	r1, #1
    73fe:	4620      	mov	r0, r4
    7400:	47b0      	blx	r6
#endif

	if (p->tot_len == p->len) {
    7402:	8920      	ldrh	r0, [r4, #8]
    7404:	8962      	ldrh	r2, [r4, #10]
    7406:	4282      	cmp	r2, r0
    7408:	d109      	bne.n	741e <mac_low_level_output+0x2e>
		mac_async_write(mac, p->payload, p->tot_len);
    740a:	6861      	ldr	r1, [r4, #4]
    740c:	4b18      	ldr	r3, [pc, #96]	; (7470 <mac_low_level_output+0x80>)
    740e:	4638      	mov	r0, r7
    7410:	4798      	blx	r3
		mac_async_write(mac, tbuf, p->tot_len);
		mem_free(tbuf);
	}

#if ETH_PAD_SIZE
	pbuf_header(p, ETH_PAD_SIZE); /* reclaim the padding word */
    7412:	2102      	movs	r1, #2
    7414:	4620      	mov	r0, r4
    7416:	47b0      	blx	r6
#endif

	LINK_STATS_INC(link.xmit);

	return ERR_OK;
    7418:	2000      	movs	r0, #0
}
    741a:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
		tbuf = mem_malloc(LWIP_MEM_ALIGN_SIZE(p->tot_len));
    741e:	3003      	adds	r0, #3
    7420:	f020 0003 	bic.w	r0, r0, #3
    7424:	4b13      	ldr	r3, [pc, #76]	; (7474 <mac_low_level_output+0x84>)
    7426:	b280      	uxth	r0, r0
    7428:	4798      	blx	r3
		if (tbuf == NULL) {
    742a:	4605      	mov	r5, r0
    742c:	b1d8      	cbz	r0, 7466 <mac_low_level_output+0x76>
			memcpy(pos, q->payload, q->len);
    742e:	f8df 904c 	ldr.w	r9, [pc, #76]	; 747c <mac_low_level_output+0x8c>
    7432:	4603      	mov	r3, r0
    7434:	46a0      	mov	r8, r4
    7436:	f8b8 200a 	ldrh.w	r2, [r8, #10]
    743a:	f8d8 1004 	ldr.w	r1, [r8, #4]
    743e:	4618      	mov	r0, r3
    7440:	47c8      	blx	r9
			pos += q->len;
    7442:	f8b8 200a 	ldrh.w	r2, [r8, #10]
		for (q = p; q != NULL; q = q->next) {
    7446:	f8d8 8000 	ldr.w	r8, [r8]
			memcpy(pos, q->payload, q->len);
    744a:	4603      	mov	r3, r0
			pos += q->len;
    744c:	4413      	add	r3, r2
		for (q = p; q != NULL; q = q->next) {
    744e:	f1b8 0f00 	cmp.w	r8, #0
    7452:	d1f0      	bne.n	7436 <mac_low_level_output+0x46>
		mac_async_write(mac, tbuf, p->tot_len);
    7454:	8922      	ldrh	r2, [r4, #8]
    7456:	4b06      	ldr	r3, [pc, #24]	; (7470 <mac_low_level_output+0x80>)
    7458:	4629      	mov	r1, r5
    745a:	4638      	mov	r0, r7
    745c:	4798      	blx	r3
		mem_free(tbuf);
    745e:	4b06      	ldr	r3, [pc, #24]	; (7478 <mac_low_level_output+0x88>)
    7460:	4628      	mov	r0, r5
    7462:	4798      	blx	r3
    7464:	e7d5      	b.n	7412 <mac_low_level_output+0x22>
			return ERR_MEM;
    7466:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    746a:	e7d6      	b.n	741a <mac_low_level_output+0x2a>
    746c:	00003089 	.word	0x00003089
    7470:	00004c9d 	.word	0x00004c9d
    7474:	00006809 	.word	0x00006809
    7478:	0000667d 	.word	0x0000667d
    747c:	0000c07d 	.word	0x0000c07d

00007480 <ethernetif_mac_input>:

/**
 * \brief Process incoming ethernet packet.
 */
void ethernetif_mac_input(struct netif *netif)
{
    7480:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	len = mac_async_read_len(mac); /* Obtain the size of the packet */
    7484:	4f1e      	ldr	r7, [pc, #120]	; (7500 <ethernetif_mac_input+0x80>)
	p = pbuf_alloc(PBUF_RAW, len, PBUF_RAM);
    7486:	f8df 8088 	ldr.w	r8, [pc, #136]	; 7510 <ethernetif_mac_input+0x90>
    748a:	4e1e      	ldr	r6, [pc, #120]	; (7504 <ethernetif_mac_input+0x84>)
{
    748c:	4605      	mov	r5, r0
	struct eth_hdr *ethhdr;
	struct pbuf *   p;

	/* move received packet into a new pbuf */
	do {
		p = low_level_input(netif);
    748e:	f8d5 9020 	ldr.w	r9, [r5, #32]
	len = mac_async_read_len(mac); /* Obtain the size of the packet */
    7492:	4648      	mov	r0, r9
    7494:	47b8      	blx	r7
    7496:	b281      	uxth	r1, r0
	if (len == 0) {
    7498:	2900      	cmp	r1, #0
    749a:	d02f      	beq.n	74fc <ethernetif_mac_input+0x7c>
	len += ETH_PAD_SIZE; /* allow room for Ethernet padding */
    749c:	3102      	adds	r1, #2
	p = pbuf_alloc(PBUF_RAW, len, PBUF_RAM);
    749e:	2200      	movs	r2, #0
    74a0:	b289      	uxth	r1, r1
    74a2:	2003      	movs	r0, #3
    74a4:	47c0      	blx	r8
	if (p != NULL) {
    74a6:	4604      	mov	r4, r0
    74a8:	b1d0      	cbz	r0, 74e0 <ethernetif_mac_input+0x60>
		pbuf_header(p, -ETH_PAD_SIZE); /* drop the padding word */
    74aa:	f8df a068 	ldr.w	sl, [pc, #104]	; 7514 <ethernetif_mac_input+0x94>
    74ae:	f06f 0101 	mvn.w	r1, #1
    74b2:	47d0      	blx	sl
		mac_async_read(mac, p->payload, p->len);
    74b4:	8962      	ldrh	r2, [r4, #10]
    74b6:	6861      	ldr	r1, [r4, #4]
    74b8:	4648      	mov	r0, r9
    74ba:	47b0      	blx	r6
		pbuf_header(p, ETH_PAD_SIZE); /* reclaim the padding word */
    74bc:	2102      	movs	r1, #2
    74be:	4620      	mov	r0, r4
    74c0:	47d0      	blx	sl
			return;
		}
		/* points to packet payload, which starts with an Ethernet header */
		ethhdr = p->payload;

		switch (htons(ethhdr->type)) {
    74c2:	6863      	ldr	r3, [r4, #4]
    74c4:	89d8      	ldrh	r0, [r3, #14]
    74c6:	4b10      	ldr	r3, [pc, #64]	; (7508 <ethernetif_mac_input+0x88>)
    74c8:	4798      	blx	r3
    74ca:	f5b0 6f00 	cmp.w	r0, #2048	; 0x800
    74ce:	d00e      	beq.n	74ee <ethernetif_mac_input+0x6e>
    74d0:	f640 0306 	movw	r3, #2054	; 0x806
    74d4:	4298      	cmp	r0, r3
    74d6:	d00a      	beq.n	74ee <ethernetif_mac_input+0x6e>
				p = NULL;
			}
			break;

		default:
			pbuf_free(p);
    74d8:	4b0c      	ldr	r3, [pc, #48]	; (750c <ethernetif_mac_input+0x8c>)
    74da:	4620      	mov	r0, r4
    74dc:	4798      	blx	r3
			p = NULL;
			break;
    74de:	e7d6      	b.n	748e <ethernetif_mac_input+0xe>
		mac_async_read(mac, NULL, 0);
    74e0:	4602      	mov	r2, r0
    74e2:	4601      	mov	r1, r0
    74e4:	4633      	mov	r3, r6
    74e6:	4648      	mov	r0, r9
		}
	} while (true);
}
    74e8:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
		mac_async_read(mac, NULL, 0);
    74ec:	4718      	bx	r3
			if (netif->input(p, netif) != ERR_OK) {
    74ee:	692b      	ldr	r3, [r5, #16]
    74f0:	4629      	mov	r1, r5
    74f2:	4620      	mov	r0, r4
    74f4:	4798      	blx	r3
    74f6:	2800      	cmp	r0, #0
    74f8:	d0c9      	beq.n	748e <ethernetif_mac_input+0xe>
    74fa:	e7ed      	b.n	74d8 <ethernetif_mac_input+0x58>
}
    74fc:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    7500:	00004d09 	.word	0x00004d09
    7504:	00004cd5 	.word	0x00004cd5
    7508:	00000d61 	.word	0x00000d61
    750c:	000030e1 	.word	0x000030e1
    7510:	00003139 	.word	0x00003139
    7514:	00003089 	.word	0x00003089

00007518 <netconn_recv_data>:
 * @param new_buf pointer where a new pbuf/netbuf is stored when received data
 * @return ERR_OK if data has been received, an error code otherwise (timeout,
 *                memory error or another error)
 */
static err_t netconn_recv_data(struct netconn *conn, void **new_buf)
{
    7518:	b5f0      	push	{r4, r5, r6, r7, lr}
    751a:	b089      	sub	sp, #36	; 0x24
	void *buf = NULL;
    751c:	2600      	movs	r6, #0
{
    751e:	4604      	mov	r4, r0
	void *buf = NULL;
    7520:	9601      	str	r6, [sp, #4]
	err_t err;
#if LWIP_TCP
	struct api_msg msg;
#endif /* LWIP_TCP */

	LWIP_ERROR("netconn_recv: invalid pointer", (new_buf != NULL), return ERR_ARG;);
    7522:	460d      	mov	r5, r1
    7524:	b901      	cbnz	r1, 7528 <netconn_recv_data+0x10>
    7526:	e7fe      	b.n	7526 <netconn_recv_data+0xe>
	*new_buf = NULL;
    7528:	600e      	str	r6, [r1, #0]
	LWIP_ERROR("netconn_recv: invalid conn", (conn != NULL), return ERR_ARG;);
    752a:	b900      	cbnz	r0, 752e <netconn_recv_data+0x16>
    752c:	e7fe      	b.n	752c <netconn_recv_data+0x14>
	LWIP_ERROR("netconn_accept: invalid recvmbox", sys_mbox_valid(&conn->recvmbox), return ERR_CONN;);
    752e:	f100 0710 	add.w	r7, r0, #16
    7532:	4b20      	ldr	r3, [pc, #128]	; (75b4 <netconn_recv_data+0x9c>)
    7534:	4638      	mov	r0, r7
    7536:	4798      	blx	r3
    7538:	b900      	cbnz	r0, 753c <netconn_recv_data+0x24>
    753a:	e7fe      	b.n	753a <netconn_recv_data+0x22>

	err = conn->last_err;
    753c:	f994 0008 	ldrsb.w	r0, [r4, #8]
	if (ERR_IS_FATAL(err)) {
    7540:	f110 0f09 	cmn.w	r0, #9
    7544:	db30      	blt.n	75a8 <netconn_recv_data+0x90>
	if (sys_arch_mbox_fetch(&conn->recvmbox, &buf, conn->recv_timeout) == SYS_ARCH_TIMEOUT) {
		NETCONN_SET_SAFE_ERR(conn, ERR_TIMEOUT);
		return ERR_TIMEOUT;
	}
#else
	sys_arch_mbox_fetch(&conn->recvmbox, &buf, 0);
    7546:	4b1c      	ldr	r3, [pc, #112]	; (75b8 <netconn_recv_data+0xa0>)
    7548:	4632      	mov	r2, r6
    754a:	a901      	add	r1, sp, #4
    754c:	4638      	mov	r0, r7
    754e:	4798      	blx	r3
#endif /* LWIP_SO_RCVTIMEO*/

#if LWIP_TCP
#if (LWIP_UDP || LWIP_RAW)
	if (conn->type == NETCONN_TCP)
    7550:	7823      	ldrb	r3, [r4, #0]
    7552:	2b10      	cmp	r3, #16
    7554:	9b01      	ldr	r3, [sp, #4]
    7556:	d129      	bne.n	75ac <netconn_recv_data+0x94>
#endif /* (LWIP_UDP || LWIP_RAW) */
	{
		if (!netconn_get_noautorecved(conn) || (buf == NULL)) {
    7558:	7f22      	ldrb	r2, [r4, #28]
    755a:	0712      	lsls	r2, r2, #28
    755c:	d500      	bpl.n	7560 <netconn_recv_data+0x48>
    755e:	b943      	cbnz	r3, 7572 <netconn_recv_data+0x5a>
			/* Let the stack know that we have taken the data. */
			/* TODO: Speedup: Don't block and wait for the answer here
			   (to prevent multiple thread-switches). */
			msg.function = do_recv;
    7560:	4a16      	ldr	r2, [pc, #88]	; (75bc <netconn_recv_data+0xa4>)
			msg.msg.conn = conn;
    7562:	e9cd 2402 	strd	r2, r4, [sp, #8]
			if (buf != NULL) {
    7566:	b1a3      	cbz	r3, 7592 <netconn_recv_data+0x7a>
				msg.msg.msg.r.len = ((struct pbuf *)buf)->tot_len;
    7568:	891b      	ldrh	r3, [r3, #8]
    756a:	9305      	str	r3, [sp, #20]
			} else {
				msg.msg.msg.r.len = 1;
			}
			/* don't care for the return value of do_recv */
			TCPIP_APIMSG(&msg);
    756c:	a802      	add	r0, sp, #8
    756e:	4b14      	ldr	r3, [pc, #80]	; (75c0 <netconn_recv_data+0xa8>)
    7570:	4798      	blx	r3
		}

		/* If we are closed, we indicate that we no longer wish to use the socket */
		if (buf == NULL) {
    7572:	9a01      	ldr	r2, [sp, #4]
    7574:	b97a      	cbnz	r2, 7596 <netconn_recv_data+0x7e>
			API_EVENT(conn, NETCONN_EVT_RCVMINUS, 0);
    7576:	6aa3      	ldr	r3, [r4, #40]	; 0x28
    7578:	b113      	cbz	r3, 7580 <netconn_recv_data+0x68>
    757a:	2101      	movs	r1, #1
    757c:	4620      	mov	r0, r4
    757e:	4798      	blx	r3
			/* Avoid to lose any previous error code */
			NETCONN_SET_SAFE_ERR(conn, ERR_CLSD);
    7580:	f994 3008 	ldrsb.w	r3, [r4, #8]
    7584:	3309      	adds	r3, #9
    7586:	db01      	blt.n	758c <netconn_recv_data+0x74>
    7588:	23f4      	movs	r3, #244	; 0xf4
    758a:	7223      	strb	r3, [r4, #8]
			return ERR_CLSD;
    758c:	f06f 000b 	mvn.w	r0, #11
    7590:	e00a      	b.n	75a8 <netconn_recv_data+0x90>
				msg.msg.msg.r.len = 1;
    7592:	2301      	movs	r3, #1
    7594:	e7e9      	b.n	756a <netconn_recv_data+0x52>
		}
		len = ((struct pbuf *)buf)->tot_len;
    7596:	8912      	ldrh	r2, [r2, #8]

#if LWIP_SO_RCVBUF
	SYS_ARCH_DEC(conn->recv_avail, len);
#endif /* LWIP_SO_RCVBUF */
	/* Register event with callback */
	API_EVENT(conn, NETCONN_EVT_RCVMINUS, len);
    7598:	6aa3      	ldr	r3, [r4, #40]	; 0x28
    759a:	b113      	cbz	r3, 75a2 <netconn_recv_data+0x8a>
    759c:	2101      	movs	r1, #1
    759e:	4620      	mov	r0, r4
    75a0:	4798      	blx	r3

	LWIP_DEBUGF(API_LIB_DEBUG, ("netconn_recv_data: received %p, len=%" U16_F "\n", buf, len));

	*new_buf = buf;
    75a2:	9b01      	ldr	r3, [sp, #4]
    75a4:	602b      	str	r3, [r5, #0]
	/* don't set conn->last_err: it's only ERR_OK, anyway */
	return ERR_OK;
    75a6:	2000      	movs	r0, #0
}
    75a8:	b009      	add	sp, #36	; 0x24
    75aa:	bdf0      	pop	{r4, r5, r6, r7, pc}
		len = netbuf_len((struct netbuf *)buf);
    75ac:	681b      	ldr	r3, [r3, #0]
    75ae:	891a      	ldrh	r2, [r3, #8]
    75b0:	e7f2      	b.n	7598 <netconn_recv_data+0x80>
    75b2:	bf00      	nop
    75b4:	00007be1 	.word	0x00007be1
    75b8:	00007b55 	.word	0x00007b55
    75bc:	00001c15 	.word	0x00001c15
    75c0:	0000a255 	.word	0x0000a255

000075c4 <netconn_new_with_proto_and_callback>:
{
    75c4:	b530      	push	{r4, r5, lr}
	conn = netconn_alloc(t, callback);
    75c6:	4b10      	ldr	r3, [pc, #64]	; (7608 <netconn_new_with_proto_and_callback+0x44>)
{
    75c8:	b087      	sub	sp, #28
    75ca:	460d      	mov	r5, r1
	conn = netconn_alloc(t, callback);
    75cc:	4611      	mov	r1, r2
    75ce:	4798      	blx	r3
	if (conn != NULL) {
    75d0:	4604      	mov	r4, r0
    75d2:	b1a8      	cbz	r0, 7600 <netconn_new_with_proto_and_callback+0x3c>
		msg.function        = do_newconn;
    75d4:	4b0d      	ldr	r3, [pc, #52]	; (760c <netconn_new_with_proto_and_callback+0x48>)
    75d6:	9300      	str	r3, [sp, #0]
		msg.msg.conn        = conn;
    75d8:	9001      	str	r0, [sp, #4]
		if (TCPIP_APIMSG(&msg) != ERR_OK) {
    75da:	4b0d      	ldr	r3, [pc, #52]	; (7610 <netconn_new_with_proto_and_callback+0x4c>)
		msg.msg.msg.n.proto = proto;
    75dc:	f88d 500c 	strb.w	r5, [sp, #12]
		if (TCPIP_APIMSG(&msg) != ERR_OK) {
    75e0:	4668      	mov	r0, sp
    75e2:	4798      	blx	r3
    75e4:	b160      	cbz	r0, 7600 <netconn_new_with_proto_and_callback+0x3c>
			sys_sem_free(&conn->op_completed);
    75e6:	f104 000c 	add.w	r0, r4, #12
    75ea:	4b0a      	ldr	r3, [pc, #40]	; (7614 <netconn_new_with_proto_and_callback+0x50>)
    75ec:	4798      	blx	r3
			sys_mbox_free(&conn->recvmbox);
    75ee:	f104 0010 	add.w	r0, r4, #16
    75f2:	4b09      	ldr	r3, [pc, #36]	; (7618 <netconn_new_with_proto_and_callback+0x54>)
    75f4:	4798      	blx	r3
			memp_free(MEMP_NETCONN, conn);
    75f6:	4621      	mov	r1, r4
    75f8:	4b08      	ldr	r3, [pc, #32]	; (761c <netconn_new_with_proto_and_callback+0x58>)
    75fa:	2007      	movs	r0, #7
    75fc:	4798      	blx	r3
			return NULL;
    75fe:	2400      	movs	r4, #0
}
    7600:	4620      	mov	r0, r4
    7602:	b007      	add	sp, #28
    7604:	bd30      	pop	{r4, r5, pc}
    7606:	bf00      	nop
    7608:	000017c9 	.word	0x000017c9
    760c:	0000174d 	.word	0x0000174d
    7610:	0000a255 	.word	0x0000a255
    7614:	00007a0d 	.word	0x00007a0d
    7618:	00007ac1 	.word	0x00007ac1
    761c:	00004c21 	.word	0x00004c21

00007620 <netconn_delete>:
{
    7620:	b510      	push	{r4, lr}
	if (conn == NULL) {
    7622:	4604      	mov	r4, r0
{
    7624:	b086      	sub	sp, #24
	if (conn == NULL) {
    7626:	b140      	cbz	r0, 763a <netconn_delete+0x1a>
	msg.function = do_delconn;
    7628:	4b05      	ldr	r3, [pc, #20]	; (7640 <netconn_delete+0x20>)
	msg.msg.conn = conn;
    762a:	e9cd 3000 	strd	r3, r0, [sp]
	tcpip_apimsg(&msg);
    762e:	4b05      	ldr	r3, [pc, #20]	; (7644 <netconn_delete+0x24>)
    7630:	4668      	mov	r0, sp
    7632:	4798      	blx	r3
	netconn_free(conn);
    7634:	4b04      	ldr	r3, [pc, #16]	; (7648 <netconn_delete+0x28>)
    7636:	4620      	mov	r0, r4
    7638:	4798      	blx	r3
}
    763a:	2000      	movs	r0, #0
    763c:	b006      	add	sp, #24
    763e:	bd10      	pop	{r4, pc}
    7640:	000019fd 	.word	0x000019fd
    7644:	0000a255 	.word	0x0000a255
    7648:	00001841 	.word	0x00001841

0000764c <netconn_getaddr>:
{
    764c:	b510      	push	{r4, lr}
	LWIP_ERROR("netconn_getaddr: invalid conn", (conn != NULL), return ERR_ARG;);
    764e:	4604      	mov	r4, r0
{
    7650:	b086      	sub	sp, #24
	LWIP_ERROR("netconn_getaddr: invalid conn", (conn != NULL), return ERR_ARG;);
    7652:	b900      	cbnz	r0, 7656 <netconn_getaddr+0xa>
    7654:	e7fe      	b.n	7654 <netconn_getaddr+0x8>
	LWIP_ERROR("netconn_getaddr: invalid addr", (addr != NULL), return ERR_ARG;);
    7656:	b901      	cbnz	r1, 765a <netconn_getaddr+0xe>
    7658:	e7fe      	b.n	7658 <netconn_getaddr+0xc>
	LWIP_ERROR("netconn_getaddr: invalid port", (port != NULL), return ERR_ARG;);
    765a:	b902      	cbnz	r2, 765e <netconn_getaddr+0x12>
    765c:	e7fe      	b.n	765c <netconn_getaddr+0x10>
	msg.function          = do_getaddr;
    765e:	4808      	ldr	r0, [pc, #32]	; (7680 <netconn_getaddr+0x34>)
	msg.msg.msg.ad.local  = local;
    7660:	f88d 3014 	strb.w	r3, [sp, #20]
	msg.msg.conn          = conn;
    7664:	e9cd 0400 	strd	r0, r4, [sp]
	err                   = TCPIP_APIMSG(&msg);
    7668:	4b06      	ldr	r3, [pc, #24]	; (7684 <netconn_getaddr+0x38>)
    766a:	4668      	mov	r0, sp
	msg.msg.msg.ad.port   = port;
    766c:	e9cd 1203 	strd	r1, r2, [sp, #12]
	err                   = TCPIP_APIMSG(&msg);
    7670:	4798      	blx	r3
	NETCONN_SET_SAFE_ERR(conn, err);
    7672:	f994 3008 	ldrsb.w	r3, [r4, #8]
    7676:	3309      	adds	r3, #9
    7678:	bfa8      	it	ge
    767a:	7220      	strbge	r0, [r4, #8]
}
    767c:	b006      	add	sp, #24
    767e:	bd10      	pop	{r4, pc}
    7680:	00001ca1 	.word	0x00001ca1
    7684:	0000a255 	.word	0x0000a255

00007688 <netconn_bind>:
{
    7688:	b510      	push	{r4, lr}
	LWIP_ERROR("netconn_bind: invalid conn", (conn != NULL), return ERR_ARG;);
    768a:	4604      	mov	r4, r0
{
    768c:	b086      	sub	sp, #24
	LWIP_ERROR("netconn_bind: invalid conn", (conn != NULL), return ERR_ARG;);
    768e:	b900      	cbnz	r0, 7692 <netconn_bind+0xa>
    7690:	e7fe      	b.n	7690 <netconn_bind+0x8>
	msg.function          = do_bind;
    7692:	4b08      	ldr	r3, [pc, #32]	; (76b4 <netconn_bind+0x2c>)
	msg.msg.msg.bc.ipaddr = addr;
    7694:	9103      	str	r1, [sp, #12]
	msg.msg.conn          = conn;
    7696:	e9cd 3000 	strd	r3, r0, [sp]
	err                   = TCPIP_APIMSG(&msg);
    769a:	4b07      	ldr	r3, [pc, #28]	; (76b8 <netconn_bind+0x30>)
	msg.msg.msg.bc.port   = port;
    769c:	f8ad 2010 	strh.w	r2, [sp, #16]
	err                   = TCPIP_APIMSG(&msg);
    76a0:	4668      	mov	r0, sp
    76a2:	4798      	blx	r3
	NETCONN_SET_SAFE_ERR(conn, err);
    76a4:	f994 3008 	ldrsb.w	r3, [r4, #8]
    76a8:	3309      	adds	r3, #9
    76aa:	bfa8      	it	ge
    76ac:	7220      	strbge	r0, [r4, #8]
}
    76ae:	b006      	add	sp, #24
    76b0:	bd10      	pop	{r4, pc}
    76b2:	bf00      	nop
    76b4:	00001a95 	.word	0x00001a95
    76b8:	0000a255 	.word	0x0000a255

000076bc <netconn_listen_with_backlog>:
{
    76bc:	b510      	push	{r4, lr}
	LWIP_ERROR("netconn_listen: invalid conn", (conn != NULL), return ERR_ARG;);
    76be:	4604      	mov	r4, r0
{
    76c0:	b086      	sub	sp, #24
	LWIP_ERROR("netconn_listen: invalid conn", (conn != NULL), return ERR_ARG;);
    76c2:	b900      	cbnz	r0, 76c6 <netconn_listen_with_backlog+0xa>
    76c4:	e7fe      	b.n	76c4 <netconn_listen_with_backlog+0x8>
	msg.function = do_listen;
    76c6:	4b06      	ldr	r3, [pc, #24]	; (76e0 <netconn_listen_with_backlog+0x24>)
	msg.msg.conn = conn;
    76c8:	e9cd 3000 	strd	r3, r0, [sp]
	err = TCPIP_APIMSG(&msg);
    76cc:	4b05      	ldr	r3, [pc, #20]	; (76e4 <netconn_listen_with_backlog+0x28>)
    76ce:	4668      	mov	r0, sp
    76d0:	4798      	blx	r3
	NETCONN_SET_SAFE_ERR(conn, err);
    76d2:	f994 3008 	ldrsb.w	r3, [r4, #8]
    76d6:	3309      	adds	r3, #9
    76d8:	bfa8      	it	ge
    76da:	7220      	strbge	r0, [r4, #8]
}
    76dc:	b006      	add	sp, #24
    76de:	bd10      	pop	{r4, pc}
    76e0:	00001aed 	.word	0x00001aed
    76e4:	0000a255 	.word	0x0000a255

000076e8 <netconn_accept>:
{
    76e8:	b573      	push	{r0, r1, r4, r5, r6, lr}
    76ea:	4604      	mov	r4, r0
	LWIP_ERROR("netconn_accept: invalid pointer", (new_conn != NULL), return ERR_ARG;);
    76ec:	460d      	mov	r5, r1
    76ee:	b901      	cbnz	r1, 76f2 <netconn_accept+0xa>
    76f0:	e7fe      	b.n	76f0 <netconn_accept+0x8>
	*new_conn = NULL;
    76f2:	2200      	movs	r2, #0
    76f4:	600a      	str	r2, [r1, #0]
	LWIP_ERROR("netconn_accept: invalid conn", (conn != NULL), return ERR_ARG;);
    76f6:	b900      	cbnz	r0, 76fa <netconn_accept+0x12>
    76f8:	e7fe      	b.n	76f8 <netconn_accept+0x10>
	LWIP_ERROR("netconn_accept: invalid acceptmbox", sys_mbox_valid(&conn->acceptmbox), return ERR_ARG;);
    76fa:	f100 0614 	add.w	r6, r0, #20
    76fe:	4b12      	ldr	r3, [pc, #72]	; (7748 <netconn_accept+0x60>)
    7700:	4630      	mov	r0, r6
    7702:	4798      	blx	r3
    7704:	2200      	movs	r2, #0
    7706:	b900      	cbnz	r0, 770a <netconn_accept+0x22>
    7708:	e7fe      	b.n	7708 <netconn_accept+0x20>
	err = conn->last_err;
    770a:	f994 0008 	ldrsb.w	r0, [r4, #8]
	if (ERR_IS_FATAL(err)) {
    770e:	f110 0f09 	cmn.w	r0, #9
    7712:	db16      	blt.n	7742 <netconn_accept+0x5a>
	sys_arch_mbox_fetch(&conn->acceptmbox, (void **)&newconn, 0);
    7714:	4b0d      	ldr	r3, [pc, #52]	; (774c <netconn_accept+0x64>)
    7716:	a901      	add	r1, sp, #4
    7718:	4630      	mov	r0, r6
    771a:	4798      	blx	r3
	API_EVENT(conn, NETCONN_EVT_RCVMINUS, 0);
    771c:	6aa3      	ldr	r3, [r4, #40]	; 0x28
    771e:	b11b      	cbz	r3, 7728 <netconn_accept+0x40>
    7720:	2200      	movs	r2, #0
    7722:	2101      	movs	r1, #1
    7724:	4620      	mov	r0, r4
    7726:	4798      	blx	r3
	if (newconn == NULL) {
    7728:	9b01      	ldr	r3, [sp, #4]
    772a:	b943      	cbnz	r3, 773e <netconn_accept+0x56>
		NETCONN_SET_SAFE_ERR(conn, ERR_ABRT);
    772c:	f994 3008 	ldrsb.w	r3, [r4, #8]
    7730:	3309      	adds	r3, #9
    7732:	db01      	blt.n	7738 <netconn_accept+0x50>
    7734:	23f6      	movs	r3, #246	; 0xf6
    7736:	7223      	strb	r3, [r4, #8]
		return ERR_ABRT;
    7738:	f06f 0009 	mvn.w	r0, #9
    773c:	e001      	b.n	7742 <netconn_accept+0x5a>
	*new_conn = newconn;
    773e:	602b      	str	r3, [r5, #0]
	return ERR_OK;
    7740:	2000      	movs	r0, #0
}
    7742:	b002      	add	sp, #8
    7744:	bd70      	pop	{r4, r5, r6, pc}
    7746:	bf00      	nop
    7748:	00007be1 	.word	0x00007be1
    774c:	00007b55 	.word	0x00007b55

00007750 <netconn_recv_tcp_pbuf>:
 *                memory error or another error)
 *         ERR_ARG if conn is not a TCP netconn
 */
err_t netconn_recv_tcp_pbuf(struct netconn *conn, struct pbuf **new_buf)
{
	LWIP_ERROR("netconn_recv: invalid conn", (conn != NULL) && netconn_type(conn) == NETCONN_TCP, return ERR_ARG;);
    7750:	b110      	cbz	r0, 7758 <netconn_recv_tcp_pbuf+0x8>
    7752:	7803      	ldrb	r3, [r0, #0]
    7754:	2b10      	cmp	r3, #16
    7756:	d000      	beq.n	775a <netconn_recv_tcp_pbuf+0xa>
    7758:	e7fe      	b.n	7758 <netconn_recv_tcp_pbuf+0x8>

	return netconn_recv_data(conn, (void **)new_buf);
    775a:	4b01      	ldr	r3, [pc, #4]	; (7760 <netconn_recv_tcp_pbuf+0x10>)
    775c:	4718      	bx	r3
    775e:	bf00      	nop
    7760:	00007519 	.word	0x00007519

00007764 <netconn_recv>:
 * @param new_buf pointer where a new netbuf is stored when received data
 * @return ERR_OK if data has been received, an error code otherwise (timeout,
 *                memory error or another error)
 */
err_t netconn_recv(struct netconn *conn, struct netbuf **new_buf)
{
    7764:	b573      	push	{r0, r1, r4, r5, r6, lr}
    7766:	4604      	mov	r4, r0
#if LWIP_TCP
	struct netbuf *buf = NULL;
	err_t          err;
#endif /* LWIP_TCP */

	LWIP_ERROR("netconn_recv: invalid pointer", (new_buf != NULL), return ERR_ARG;);
    7768:	460e      	mov	r6, r1
    776a:	b901      	cbnz	r1, 776e <netconn_recv+0xa>
    776c:	e7fe      	b.n	776c <netconn_recv+0x8>
	*new_buf = NULL;
    776e:	2500      	movs	r5, #0
    7770:	600d      	str	r5, [r1, #0]
	LWIP_ERROR("netconn_recv: invalid conn", (conn != NULL), return ERR_ARG;);
    7772:	b900      	cbnz	r0, 7776 <netconn_recv+0x12>
    7774:	e7fe      	b.n	7774 <netconn_recv+0x10>
	LWIP_ERROR("netconn_accept: invalid recvmbox", sys_mbox_valid(&conn->recvmbox), return ERR_CONN;);
    7776:	4b19      	ldr	r3, [pc, #100]	; (77dc <netconn_recv+0x78>)
    7778:	3010      	adds	r0, #16
    777a:	4798      	blx	r3
    777c:	b900      	cbnz	r0, 7780 <netconn_recv+0x1c>
    777e:	e7fe      	b.n	777e <netconn_recv+0x1a>

#if LWIP_TCP
#if (LWIP_UDP || LWIP_RAW)
	if (conn->type == NETCONN_TCP)
    7780:	7823      	ldrb	r3, [r4, #0]
    7782:	2b10      	cmp	r3, #16
    7784:	d122      	bne.n	77cc <netconn_recv+0x68>
#endif /* (LWIP_UDP || LWIP_RAW) */
	{
		struct pbuf *p = NULL;
		/* This is not a listening netconn, since recvmbox is set */

		buf = (struct netbuf *)memp_malloc(MEMP_NETBUF);
    7786:	4b16      	ldr	r3, [pc, #88]	; (77e0 <netconn_recv+0x7c>)
		struct pbuf *p = NULL;
    7788:	9501      	str	r5, [sp, #4]
		buf = (struct netbuf *)memp_malloc(MEMP_NETBUF);
    778a:	2006      	movs	r0, #6
    778c:	4798      	blx	r3
		if (buf == NULL) {
    778e:	4605      	mov	r5, r0
    7790:	b940      	cbnz	r0, 77a4 <netconn_recv+0x40>
			NETCONN_SET_SAFE_ERR(conn, ERR_MEM);
    7792:	f994 3008 	ldrsb.w	r3, [r4, #8]
    7796:	3309      	adds	r3, #9
    7798:	db01      	blt.n	779e <netconn_recv+0x3a>
    779a:	23ff      	movs	r3, #255	; 0xff
    779c:	7223      	strb	r3, [r4, #8]
			return ERR_MEM;
    779e:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
    77a2:	e009      	b.n	77b8 <netconn_recv+0x54>
		}

		err = netconn_recv_data(conn, (void **)&p);
    77a4:	4620      	mov	r0, r4
    77a6:	4b0f      	ldr	r3, [pc, #60]	; (77e4 <netconn_recv+0x80>)
    77a8:	a901      	add	r1, sp, #4
    77aa:	4798      	blx	r3
		if (err != ERR_OK) {
    77ac:	4604      	mov	r4, r0
    77ae:	b130      	cbz	r0, 77be <netconn_recv+0x5a>
			memp_free(MEMP_NETBUF, buf);
    77b0:	4b0d      	ldr	r3, [pc, #52]	; (77e8 <netconn_recv+0x84>)
    77b2:	4629      	mov	r1, r5
    77b4:	2006      	movs	r0, #6
    77b6:	4798      	blx	r3
	{
#if (LWIP_UDP || LWIP_RAW)
		return netconn_recv_data(conn, (void **)new_buf);
#endif /* (LWIP_UDP || LWIP_RAW) */
	}
}
    77b8:	4620      	mov	r0, r4
    77ba:	b002      	add	sp, #8
    77bc:	bd70      	pop	{r4, r5, r6, pc}
		buf->p    = p;
    77be:	9b01      	ldr	r3, [sp, #4]
		buf->port = 0;
    77c0:	81a8      	strh	r0, [r5, #12]
		buf->ptr  = p;
    77c2:	e9c5 3300 	strd	r3, r3, [r5]
		ip_addr_set_any(&buf->addr);
    77c6:	60a8      	str	r0, [r5, #8]
		*new_buf = buf;
    77c8:	6035      	str	r5, [r6, #0]
		return ERR_OK;
    77ca:	e7f5      	b.n	77b8 <netconn_recv+0x54>
		return netconn_recv_data(conn, (void **)new_buf);
    77cc:	4b05      	ldr	r3, [pc, #20]	; (77e4 <netconn_recv+0x80>)
    77ce:	4631      	mov	r1, r6
    77d0:	4620      	mov	r0, r4
}
    77d2:	b002      	add	sp, #8
    77d4:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		return netconn_recv_data(conn, (void **)new_buf);
    77d8:	4718      	bx	r3
    77da:	bf00      	nop
    77dc:	00007be1 	.word	0x00007be1
    77e0:	00004c05 	.word	0x00004c05
    77e4:	00007519 	.word	0x00007519
    77e8:	00004c21 	.word	0x00004c21

000077ec <netconn_recved>:
 *
 * @param conn the netconn for which to update the receive window
 * @param length amount of data processed (ATTENTION: this must be accurate!)
 */
void netconn_recved(struct netconn *conn, u32_t length)
{
    77ec:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
#if LWIP_TCP
	if ((conn != NULL) && (conn->type == NETCONN_TCP) && (netconn_get_noautorecved(conn))) {
    77ee:	b160      	cbz	r0, 780a <netconn_recved+0x1e>
    77f0:	7803      	ldrb	r3, [r0, #0]
    77f2:	2b10      	cmp	r3, #16
    77f4:	d109      	bne.n	780a <netconn_recved+0x1e>
    77f6:	7f03      	ldrb	r3, [r0, #28]
    77f8:	071b      	lsls	r3, r3, #28
    77fa:	d506      	bpl.n	780a <netconn_recved+0x1e>
		struct api_msg msg;
		/* Let the stack know that we have taken the data. */
		/* TODO: Speedup: Don't block and wait for the answer here
		   (to prevent multiple thread-switches). */
		msg.function      = do_recv;
    77fc:	4b04      	ldr	r3, [pc, #16]	; (7810 <netconn_recved+0x24>)
		msg.msg.conn      = conn;
		msg.msg.msg.r.len = length;
    77fe:	9103      	str	r1, [sp, #12]
		msg.msg.conn      = conn;
    7800:	e9cd 3000 	strd	r3, r0, [sp]
		/* don't care for the return value of do_recv */
		TCPIP_APIMSG(&msg);
    7804:	4b03      	ldr	r3, [pc, #12]	; (7814 <netconn_recved+0x28>)
    7806:	4668      	mov	r0, sp
    7808:	4798      	blx	r3
	}
#else  /* LWIP_TCP */
	LWIP_UNUSED_ARG(conn);
	LWIP_UNUSED_ARG(length);
#endif /* LWIP_TCP */
}
    780a:	b007      	add	sp, #28
    780c:	f85d fb04 	ldr.w	pc, [sp], #4
    7810:	00001c15 	.word	0x00001c15
    7814:	0000a255 	.word	0x0000a255

00007818 <netconn_send>:
 * @param conn the UDP or RAW netconn over which to send data
 * @param buf a netbuf containing the data to send
 * @return ERR_OK if data was sent, any other err_t on error
 */
err_t netconn_send(struct netconn *conn, struct netbuf *buf)
{
    7818:	b510      	push	{r4, lr}
	struct api_msg msg;
	err_t          err;

	LWIP_ERROR("netconn_send: invalid conn", (conn != NULL), return ERR_ARG;);
    781a:	4604      	mov	r4, r0
{
    781c:	b086      	sub	sp, #24
	LWIP_ERROR("netconn_send: invalid conn", (conn != NULL), return ERR_ARG;);
    781e:	b900      	cbnz	r0, 7822 <netconn_send+0xa>
    7820:	e7fe      	b.n	7820 <netconn_send+0x8>

	LWIP_DEBUGF(API_LIB_DEBUG, ("netconn_send: sending %" U16_F " bytes\n", buf->p->tot_len));
	msg.function  = do_send;
    7822:	4b07      	ldr	r3, [pc, #28]	; (7840 <netconn_send+0x28>)
	msg.msg.conn  = conn;
	msg.msg.msg.b = buf;
    7824:	9103      	str	r1, [sp, #12]
	msg.msg.conn  = conn;
    7826:	e9cd 3000 	strd	r3, r0, [sp]
	err           = TCPIP_APIMSG(&msg);
    782a:	4b06      	ldr	r3, [pc, #24]	; (7844 <netconn_send+0x2c>)
    782c:	4668      	mov	r0, sp
    782e:	4798      	blx	r3

	NETCONN_SET_SAFE_ERR(conn, err);
    7830:	f994 3008 	ldrsb.w	r3, [r4, #8]
    7834:	3309      	adds	r3, #9
    7836:	bfa8      	it	ge
    7838:	7220      	strbge	r0, [r4, #8]
	return err;
}
    783a:	b006      	add	sp, #24
    783c:	bd10      	pop	{r4, pc}
    783e:	bf00      	nop
    7840:	00001bbd 	.word	0x00001bbd
    7844:	0000a255 	.word	0x0000a255

00007848 <netconn_write_partly>:
 * - NETCONN_DONTBLOCK: only write the data if all dat can be written at once
 * @param bytes_written pointer to a location that receives the number of written bytes
 * @return ERR_OK if data was sent, any other err_t on error
 */
err_t netconn_write_partly(struct netconn *conn, const void *dataptr, size_t size, u8_t apiflags, size_t *bytes_written)
{
    7848:	b5f0      	push	{r4, r5, r6, r7, lr}
    784a:	b087      	sub	sp, #28
    784c:	4616      	mov	r6, r2
    784e:	9f0c      	ldr	r7, [sp, #48]	; 0x30
	struct api_msg msg;
	err_t          err;
	u8_t           dontblock;

	LWIP_ERROR("netconn_write: invalid conn", (conn != NULL), return ERR_ARG;);
    7850:	4605      	mov	r5, r0
    7852:	b900      	cbnz	r0, 7856 <netconn_write_partly+0xe>
    7854:	e7fe      	b.n	7854 <netconn_write_partly+0xc>
	LWIP_ERROR("netconn_write: invalid conn->type", (conn->type == NETCONN_TCP), return ERR_VAL;);
    7856:	7802      	ldrb	r2, [r0, #0]
    7858:	2a10      	cmp	r2, #16
    785a:	d000      	beq.n	785e <netconn_write_partly+0x16>
    785c:	e7fe      	b.n	785c <netconn_write_partly+0x14>
	if (size == 0) {
    785e:	b306      	cbz	r6, 78a2 <netconn_write_partly+0x5a>
		return ERR_OK;
	}
	dontblock = netconn_is_nonblocking(conn) || (apiflags & NETCONN_DONTBLOCK);
	if (dontblock && !bytes_written) {
    7860:	7f04      	ldrb	r4, [r0, #28]
    7862:	f003 0204 	and.w	r2, r3, #4
    7866:	f004 0402 	and.w	r4, r4, #2
    786a:	4314      	orrs	r4, r2
    786c:	d001      	beq.n	7872 <netconn_write_partly+0x2a>
    786e:	b1d7      	cbz	r7, 78a6 <netconn_write_partly+0x5e>
    7870:	2401      	movs	r4, #1
		   it has no way to return the number of bytes written. */
		return ERR_VAL;
	}

	/* non-blocking write sends as much  */
	msg.function           = do_write;
    7872:	4a0e      	ldr	r2, [pc, #56]	; (78ac <netconn_write_partly+0x64>)
	msg.msg.conn           = conn;
	msg.msg.msg.w.dataptr  = dataptr;
	msg.msg.msg.w.apiflags = apiflags;
    7874:	f88d 3014 	strb.w	r3, [sp, #20]
#endif /* LWIP_SO_SNDTIMEO */

	/* For locking the core: this _can_ be delayed on low memory/low send buffer,
	   but if it is, this is done inside api_msg.c:do_write(), so we can use the
	   non-blocking version here. */
	err = TCPIP_APIMSG(&msg);
    7878:	4668      	mov	r0, sp
    787a:	4b0d      	ldr	r3, [pc, #52]	; (78b0 <netconn_write_partly+0x68>)
	msg.msg.msg.w.dataptr  = dataptr;
    787c:	9103      	str	r1, [sp, #12]
	msg.msg.conn           = conn;
    787e:	e9cd 2500 	strd	r2, r5, [sp]
	msg.msg.msg.w.len      = size;
    7882:	9604      	str	r6, [sp, #16]
	err = TCPIP_APIMSG(&msg);
    7884:	4798      	blx	r3
	if ((err == ERR_OK) && (bytes_written != NULL)) {
    7886:	b918      	cbnz	r0, 7890 <netconn_write_partly+0x48>
    7888:	b117      	cbz	r7, 7890 <netconn_write_partly+0x48>
		if (dontblock
    788a:	b144      	cbz	r4, 789e <netconn_write_partly+0x56>
#if LWIP_SO_SNDTIMEO
		    || (conn->send_timeout != 0)
#endif /* LWIP_SO_SNDTIMEO */
		) {
			/* nonblocking write: maybe the data has been sent partly */
			*bytes_written = msg.msg.msg.w.len;
    788c:	9b04      	ldr	r3, [sp, #16]
    788e:	603b      	str	r3, [r7, #0]
			/* blocking call succeeded: all data has been sent if it */
			*bytes_written = size;
		}
	}

	NETCONN_SET_SAFE_ERR(conn, err);
    7890:	f995 3008 	ldrsb.w	r3, [r5, #8]
    7894:	3309      	adds	r3, #9
    7896:	db00      	blt.n	789a <netconn_write_partly+0x52>
    7898:	7228      	strb	r0, [r5, #8]
	return err;
}
    789a:	b007      	add	sp, #28
    789c:	bdf0      	pop	{r4, r5, r6, r7, pc}
			*bytes_written = size;
    789e:	603e      	str	r6, [r7, #0]
    78a0:	e7f6      	b.n	7890 <netconn_write_partly+0x48>
		return ERR_OK;
    78a2:	4630      	mov	r0, r6
    78a4:	e7f9      	b.n	789a <netconn_write_partly+0x52>
		return ERR_VAL;
    78a6:	f06f 0005 	mvn.w	r0, #5
    78aa:	e7f6      	b.n	789a <netconn_write_partly+0x52>
    78ac:	00001c5d 	.word	0x00001c5d
    78b0:	0000a255 	.word	0x0000a255

000078b4 <TCPIP_STACK_INTERFACE_0_stack_init>:
 *
 * @param netif the lwip network interface structure for this ethernetif
 * @return ERR_OK  if the loopif is initialized
 */
err_t TCPIP_STACK_INTERFACE_0_stack_init(struct netif *netif)
{
    78b4:	b508      	push	{r3, lr}
	LWIP_ASSERT("netif != NULL", (netif != NULL));
	LWIP_ASSERT("netif->state != NULL", (netif->state != NULL));

	netif->output     = etharp_output;
    78b6:	4a0d      	ldr	r2, [pc, #52]	; (78ec <TCPIP_STACK_INTERFACE_0_stack_init+0x38>)
	netif->linkoutput = mac_low_level_output;

	/* device capabilities */
	TCPIP_STACK_INTERFACE_0_desc.flags = CONF_TCPIP_STACK_INTERFACE_0_FLAG;
    78b8:	4b0d      	ldr	r3, [pc, #52]	; (78f0 <TCPIP_STACK_INTERFACE_0_stack_init+0x3c>)
	netif->output     = etharp_output;
    78ba:	6142      	str	r2, [r0, #20]
	netif->linkoutput = mac_low_level_output;
    78bc:	4a0d      	ldr	r2, [pc, #52]	; (78f4 <TCPIP_STACK_INTERFACE_0_stack_init+0x40>)
    78be:	6182      	str	r2, [r0, #24]
	TCPIP_STACK_INTERFACE_0_desc.flags = CONF_TCPIP_STACK_INTERFACE_0_FLAG;
    78c0:	226a      	movs	r2, #106	; 0x6a
    78c2:	f883 2031 	strb.w	r2, [r3, #49]	; 0x31
	TCPIP_STACK_INTERFACE_0_desc.mtu   = CONF_TCPIP_STACK_INTERFACE_0_MTU;
    78c6:	f44f 62c0 	mov.w	r2, #1536	; 0x600
    78ca:	851a      	strh	r2, [r3, #40]	; 0x28

	/* set MAC hardware address length */
	memcpy(TCPIP_STACK_INTERFACE_0_desc.hwaddr, TCPIP_STACK_INTERFACE_0_hwaddr, NETIF_MAX_HWADDR_LEN);
    78cc:	6b9a      	ldr	r2, [r3, #56]	; 0x38
    78ce:	f8c3 202b 	str.w	r2, [r3, #43]	; 0x2b
    78d2:	8f9a      	ldrh	r2, [r3, #60]	; 0x3c
    78d4:	f8a3 202f 	strh.w	r2, [r3, #47]	; 0x2f
	TCPIP_STACK_INTERFACE_0_desc.hwaddr_len = ETHARP_HWADDR_LEN;
    78d8:	2206      	movs	r2, #6
    78da:	f883 202a 	strb.w	r2, [r3, #42]	; 0x2a

#if LWIP_NETIF_HOSTNAME
	/* Initialize interface hostname */
	LWIP_MACIF_desc.hostname = CONF_TCPIP_STACK_INTERFACE_0_HOSTNAME;
#endif
	memcpy(TCPIP_STACK_INTERFACE_0_desc.name, CONF_TCPIP_STACK_INTERFACE_0_HOSTNAME_ABBR, 2);
    78de:	f646 6265 	movw	r2, #28261	; 0x6e65
    78e2:	865a      	strh	r2, [r3, #50]	; 0x32

	/* initialize the mac hardware */
	mac_low_level_init(netif);
    78e4:	4b04      	ldr	r3, [pc, #16]	; (78f8 <TCPIP_STACK_INTERFACE_0_stack_init+0x44>)
    78e6:	4798      	blx	r3

	return ERR_OK;
}
    78e8:	2000      	movs	r0, #0
    78ea:	bd08      	pop	{r3, pc}
    78ec:	000051b1 	.word	0x000051b1
    78f0:	20014960 	.word	0x20014960
    78f4:	000073f1 	.word	0x000073f1
    78f8:	000073c5 	.word	0x000073c5

000078fc <TCPIP_STACK_INTERFACE_0_init>:
void TCPIP_STACK_INTERFACE_0_init(u8_t hwaddr[6])
{
    78fc:	b510      	push	{r4, lr}
    78fe:	b088      	sub	sp, #32
#else
	ipaddr_aton(CONF_TCPIP_STACK_INTERFACE_0_IP, &ip);
	ipaddr_aton(CONF_TCPIP_STACK_INTERFACE_0_NETMASK, &nm);
	ipaddr_aton(CONF_TCPIP_STACK_INTERFACE_0_GATEWAY, &gw);
#endif
	memcpy(TCPIP_STACK_INTERFACE_0_hwaddr, hwaddr, 6);
    7900:	4c0b      	ldr	r4, [pc, #44]	; (7930 <TCPIP_STACK_INTERFACE_0_init+0x34>)
	ip_addr_set_zero(&ip);
    7902:	2300      	movs	r3, #0
	ip_addr_set_zero(&nm);
    7904:	e9cd 3305 	strd	r3, r3, [sp, #20]
	ip_addr_set_zero(&gw);
    7908:	9307      	str	r3, [sp, #28]
	memcpy(TCPIP_STACK_INTERFACE_0_hwaddr, hwaddr, 6);
    790a:	6803      	ldr	r3, [r0, #0]
    790c:	63a3      	str	r3, [r4, #56]	; 0x38
    790e:	8883      	ldrh	r3, [r0, #4]
    7910:	87a3      	strh	r3, [r4, #60]	; 0x3c

	netif_add(&TCPIP_STACK_INTERFACE_0_desc,
    7912:	4b08      	ldr	r3, [pc, #32]	; (7934 <TCPIP_STACK_INTERFACE_0_init+0x38>)
    7914:	9302      	str	r3, [sp, #8]
    7916:	4b08      	ldr	r3, [pc, #32]	; (7938 <TCPIP_STACK_INTERFACE_0_init+0x3c>)
    7918:	9301      	str	r3, [sp, #4]
    791a:	4b08      	ldr	r3, [pc, #32]	; (793c <TCPIP_STACK_INTERFACE_0_init+0x40>)
    791c:	9300      	str	r3, [sp, #0]
    791e:	aa06      	add	r2, sp, #24
    7920:	ab07      	add	r3, sp, #28
    7922:	a905      	add	r1, sp, #20
    7924:	4620      	mov	r0, r4
    7926:	4c06      	ldr	r4, [pc, #24]	; (7940 <TCPIP_STACK_INTERFACE_0_init+0x44>)
    7928:	47a0      	blx	r4
	          &nm,
	          &gw,
	          (void *)&COMMUNICATION_IO,
	          TCPIP_STACK_INTERFACE_0_stack_init,
	          ethernet_input);
}
    792a:	b008      	add	sp, #32
    792c:	bd10      	pop	{r4, pc}
    792e:	bf00      	nop
    7930:	20014960 	.word	0x20014960
    7934:	000052bd 	.word	0x000052bd
    7938:	000078b5 	.word	0x000078b5
    793c:	2000a520 	.word	0x2000a520
    7940:	0000a02d 	.word	0x0000a02d

00007944 <_init_chip>:
}

static inline void hri_nvmctrl_set_CTRLA_RWS_bf(const void *const hw, hri_nvmctrl_ctrla_reg_t mask)
{
	NVMCTRL_CRITICAL_SECTION_ENTER();
	((Nvmctrl *)hw)->CTRLA.reg |= NVMCTRL_CTRLA_RWS(mask);
    7944:	4a09      	ldr	r2, [pc, #36]	; (796c <_init_chip+0x28>)
    7946:	8813      	ldrh	r3, [r2, #0]

/**
 * \brief Initialize the hardware abstraction layer
 */
void _init_chip(void)
{
    7948:	b510      	push	{r4, lr}
    794a:	b29b      	uxth	r3, r3
    794c:	8013      	strh	r3, [r2, #0]
	hri_nvmctrl_set_CTRLA_RWS_bf(NVMCTRL, CONF_NVM_WAIT_STATE);

	_osc32kctrl_init_sources();
    794e:	4b08      	ldr	r3, [pc, #32]	; (7970 <_init_chip+0x2c>)
    7950:	4798      	blx	r3
	_oscctrl_init_sources();
    7952:	4b08      	ldr	r3, [pc, #32]	; (7974 <_init_chip+0x30>)
    7954:	4798      	blx	r3
	_mclk_init();
    7956:	4b08      	ldr	r3, [pc, #32]	; (7978 <_init_chip+0x34>)
    7958:	4798      	blx	r3
#if _GCLK_INIT_1ST
	_gclk_init_generators_by_fref(_GCLK_INIT_1ST);
#endif
	_oscctrl_init_referenced_generators();
    795a:	4b08      	ldr	r3, [pc, #32]	; (797c <_init_chip+0x38>)
    795c:	4798      	blx	r3
#endif

#if CONF_CMCC_ENABLE
	cache_init();
#endif
}
    795e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	_gclk_init_generators_by_fref(_GCLK_INIT_LAST);
    7962:	4b07      	ldr	r3, [pc, #28]	; (7980 <_init_chip+0x3c>)
    7964:	f640 70ff 	movw	r0, #4095	; 0xfff
    7968:	4718      	bx	r3
    796a:	bf00      	nop
    796c:	41004000 	.word	0x41004000
    7970:	0000489d 	.word	0x0000489d
    7974:	00007985 	.word	0x00007985
    7978:	00008ae5 	.word	0x00008ae5
    797c:	0000799d 	.word	0x0000799d
    7980:	00000f91 	.word	0x00000f91

00007984 <_oscctrl_init_sources>:
}

static inline void hri_oscctrl_write_XOSCCTRL_reg(const void *const hw, uint8_t index, hri_oscctrl_xoscctrl_reg_t data)
{
	OSCCTRL_CRITICAL_SECTION_ENTER();
	((Oscctrl *)hw)->XOSCCTRL[index].reg = data;
    7984:	4b03      	ldr	r3, [pc, #12]	; (7994 <_oscctrl_init_sources+0x10>)
    7986:	4a04      	ldr	r2, [pc, #16]	; (7998 <_oscctrl_init_sources+0x14>)
    7988:	619a      	str	r2, [r3, #24]
	return (((Oscctrl *)hw)->STATUS.reg & OSCCTRL_STATUS_XOSCRDY1) >> OSCCTRL_STATUS_XOSCRDY1_Pos;
    798a:	691a      	ldr	r2, [r3, #16]
	        | (CONF_XOSC1_XTALEN << OSCCTRL_XOSCCTRL_XTALEN_Pos) | (CONF_XOSC1_ENABLE << OSCCTRL_XOSCCTRL_ENABLE_Pos));
#endif

#if CONF_XOSC1_CONFIG == 1
#if CONF_XOSC1_ENABLE == 1
	while (!hri_oscctrl_get_STATUS_XOSCRDY1_bit(hw))
    798c:	0792      	lsls	r2, r2, #30
    798e:	d5fc      	bpl.n	798a <_oscctrl_init_sources+0x6>
	hri_oscctrl_set_XOSCCTRL_ONDEMAND_bit(hw, 1);
#endif
#endif

	(void)hw;
}
    7990:	4770      	bx	lr
    7992:	bf00      	nop
    7994:	40001000 	.word	0x40001000
    7998:	03002606 	.word	0x03002606

0000799c <_oscctrl_init_referenced_generators>:
	hri_gclk_write_GENCTRL_SRC_bf(GCLK, 0, CONF_GCLK_GEN_0_SOURCE);
	while (hri_gclk_get_SYNCBUSY_GENCTRL0_bit(GCLK))
		;
#endif
	(void)hw;
}
    799c:	4770      	bx	lr
	...

000079a0 <sys_init>:
	/* Initialize the the per-thread sys_timeouts structures
	   make sure there are no valid pids in the list */
	for (i = 0; i < SYS_THREAD_MAX; i++) {
		Threads_TimeoutsList[i].pid = 0;
	}
	NbActiveThreads = 0;
    79a0:	4b01      	ldr	r3, [pc, #4]	; (79a8 <sys_init+0x8>)
    79a2:	2200      	movs	r2, #0
    79a4:	801a      	strh	r2, [r3, #0]
}
    79a6:	4770      	bx	lr
    79a8:	2001499e 	.word	0x2001499e

000079ac <sys_sem_new>:
 * \param count Initial state of the semaphore.
 *
 * \return ERR_OK for OK, other value indicates error.
 */
err_t sys_sem_new(sys_sem_t *sem, u8_t count)
{
    79ac:	b570      	push	{r4, r5, r6, lr}
    79ae:	460c      	mov	r4, r1
	err_t err_sem = ERR_MEM;

	/* Sanity check */
	if (sem != NULL) {
    79b0:	4605      	mov	r5, r0
    79b2:	b1f0      	cbz	r0, 79f2 <sys_sem_new+0x46>
		portENTER_CRITICAL();
    79b4:	4b10      	ldr	r3, [pc, #64]	; (79f8 <sys_sem_new+0x4c>)
    79b6:	4798      	blx	r3

		vSemaphoreCreateBinary( *sem );
    79b8:	4b10      	ldr	r3, [pc, #64]	; (79fc <sys_sem_new+0x50>)
    79ba:	2203      	movs	r2, #3
    79bc:	2100      	movs	r1, #0
    79be:	2001      	movs	r0, #1
    79c0:	4798      	blx	r3
    79c2:	6028      	str	r0, [r5, #0]
    79c4:	b120      	cbz	r0, 79d0 <sys_sem_new+0x24>
    79c6:	2300      	movs	r3, #0
    79c8:	4e0d      	ldr	r6, [pc, #52]	; (7a00 <sys_sem_new+0x54>)
    79ca:	461a      	mov	r2, r3
    79cc:	4619      	mov	r1, r3
    79ce:	47b0      	blx	r6
		if (*sem != SYS_SEM_NULL) {
    79d0:	6828      	ldr	r0, [r5, #0]
    79d2:	b148      	cbz	r0, 79e8 <sys_sem_new+0x3c>
				lwip_stats.sys.sem.max = lwip_stats.sys.sem.used;
			}

  #endif /* SYS_STATS */

			if (0 == count) { /* Means we want the sem to be
    79d4:	b95c      	cbnz	r4, 79ee <sys_sem_new+0x42>
			                     unavailable at init state. */
				xSemaphoreTake( *sem, 1);
    79d6:	4d0b      	ldr	r5, [pc, #44]	; (7a04 <sys_sem_new+0x58>)
    79d8:	4623      	mov	r3, r4
    79da:	2201      	movs	r2, #1
    79dc:	4621      	mov	r1, r4
    79de:	47a8      	blx	r5
			}

			err_sem = ERR_OK;
		}

		portEXIT_CRITICAL();
    79e0:	4b09      	ldr	r3, [pc, #36]	; (7a08 <sys_sem_new+0x5c>)
    79e2:	4798      	blx	r3
	}

	return err_sem;
}
    79e4:	4620      	mov	r0, r4
    79e6:	bd70      	pop	{r4, r5, r6, pc}
	err_t err_sem = ERR_MEM;
    79e8:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
    79ec:	e7f8      	b.n	79e0 <sys_sem_new+0x34>
			err_sem = ERR_OK;
    79ee:	2400      	movs	r4, #0
    79f0:	e7f6      	b.n	79e0 <sys_sem_new+0x34>
	err_t err_sem = ERR_MEM;
    79f2:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
    79f6:	e7f5      	b.n	79e4 <sys_sem_new+0x38>
    79f8:	00009d59 	.word	0x00009d59
    79fc:	0000054d 	.word	0x0000054d
    7a00:	00000611 	.word	0x00000611
    7a04:	00000951 	.word	0x00000951
    7a08:	00009d99 	.word	0x00009d99

00007a0c <sys_sem_free>:
 * \param sem Pointer to the semaphore.
 */
void sys_sem_free(sys_sem_t *sem)
{
	/* Sanity check */
	if (sem != NULL) {
    7a0c:	b118      	cbz	r0, 7a16 <sys_sem_free+0xa>
		if (SYS_SEM_NULL != *sem) {
    7a0e:	6800      	ldr	r0, [r0, #0]
    7a10:	b108      	cbz	r0, 7a16 <sys_sem_free+0xa>
  #if SYS_STATS 
			lwip_stats.sys.sem.used--;
  #endif /* SYS_STATS */
			vQueueDelete( *sem );
    7a12:	4b01      	ldr	r3, [pc, #4]	; (7a18 <sys_sem_free+0xc>)
    7a14:	4718      	bx	r3
		}
	}
}
    7a16:	4770      	bx	lr
    7a18:	00000ae5 	.word	0x00000ae5

00007a1c <sys_sem_signal>:
 * \brief Signals (or releases) a semaphore.
 *
 * \param sem Pointer to the semaphore.
 */
void sys_sem_signal(sys_sem_t *sem)
{
    7a1c:	b410      	push	{r4}
	/* Sanity check */
	if (sem != NULL) {
    7a1e:	b140      	cbz	r0, 7a32 <sys_sem_signal+0x16>
		xSemaphoreGive( *sem );
    7a20:	4c05      	ldr	r4, [pc, #20]	; (7a38 <sys_sem_signal+0x1c>)
    7a22:	6800      	ldr	r0, [r0, #0]
    7a24:	2300      	movs	r3, #0
    7a26:	46a4      	mov	ip, r4
    7a28:	461a      	mov	r2, r3
	}
}
    7a2a:	f85d 4b04 	ldr.w	r4, [sp], #4
		xSemaphoreGive( *sem );
    7a2e:	4619      	mov	r1, r3
    7a30:	4760      	bx	ip
}
    7a32:	f85d 4b04 	ldr.w	r4, [sp], #4
    7a36:	4770      	bx	lr
    7a38:	00000611 	.word	0x00000611

00007a3c <sys_arch_sem_wait>:
 *
 * \return SYS_ARCH_TIMEOUT if times out, ERR_MEM for semaphore erro otherwise
 * return the milliseconds expired while waiting for the semaphore.
 */
u32_t sys_arch_sem_wait(sys_sem_t *sem, u32_t timeout)
{
    7a3c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    7a40:	460e      	mov	r6, r1
	portTickType TickStop;
	/* Express the timeout in OS tick. */
	portTickType TickElapsed = (portTickType)(timeout / portTICK_RATE_MS);

	/* Sanity check */
	if (sem != NULL) {
    7a42:	4605      	mov	r5, r0
    7a44:	b918      	cbnz	r0, 7a4e <sys_arch_sem_wait+0x12>
			TickElapsed = portMAX_DELAY - TickStart + TickStop;
		}

		return(TickElapsed * portTICK_RATE_MS);
	} else {
		return ERR_MEM;
    7a46:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
	}
}
    7a4a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		if (0 == TickElapsed) {
    7a4e:	4f0f      	ldr	r7, [pc, #60]	; (7a8c <sys_arch_sem_wait+0x50>)
    7a50:	f8df 803c 	ldr.w	r8, [pc, #60]	; 7a90 <sys_arch_sem_wait+0x54>
    7a54:	b981      	cbnz	r1, 7a78 <sys_arch_sem_wait+0x3c>
			TickStart = xTaskGetTickCount();
    7a56:	47b8      	blx	r7
    7a58:	4604      	mov	r4, r0
			while (pdFALSE == xSemaphoreTake( *sem,	SYS_ARCH_BLOCKING_TICKTIMEOUT )) {
    7a5a:	2300      	movs	r3, #0
    7a5c:	6828      	ldr	r0, [r5, #0]
    7a5e:	f242 7210 	movw	r2, #10000	; 0x2710
    7a62:	4619      	mov	r1, r3
    7a64:	47c0      	blx	r8
    7a66:	2800      	cmp	r0, #0
    7a68:	d0f7      	beq.n	7a5a <sys_arch_sem_wait+0x1e>
		TickStop = xTaskGetTickCount();
    7a6a:	47b8      	blx	r7
		if (TickStop >= TickStart) {
    7a6c:	4284      	cmp	r4, r0
			TickElapsed = portMAX_DELAY - TickStart + TickStop;
    7a6e:	bf88      	it	hi
    7a70:	f100 30ff 	addhi.w	r0, r0, #4294967295	; 0xffffffff
    7a74:	1b00      	subs	r0, r0, r4
    7a76:	e7e8      	b.n	7a4a <sys_arch_sem_wait+0xe>
			TickStart = xTaskGetTickCount();
    7a78:	47b8      	blx	r7
			if (pdFALSE == xSemaphoreTake( *sem, TickElapsed )) {
    7a7a:	2300      	movs	r3, #0
			TickStart = xTaskGetTickCount();
    7a7c:	4604      	mov	r4, r0
			if (pdFALSE == xSemaphoreTake( *sem, TickElapsed )) {
    7a7e:	4632      	mov	r2, r6
    7a80:	6828      	ldr	r0, [r5, #0]
    7a82:	4619      	mov	r1, r3
    7a84:	47c0      	blx	r8
    7a86:	2800      	cmp	r0, #0
    7a88:	d1ef      	bne.n	7a6a <sys_arch_sem_wait+0x2e>
    7a8a:	e7dc      	b.n	7a46 <sys_arch_sem_wait+0xa>
    7a8c:	00008d9d 	.word	0x00008d9d
    7a90:	00000951 	.word	0x00000951

00007a94 <sys_sem_valid>:
 * \return Semaphore number on valid, 0 for invalid.
 */
int sys_sem_valid(sys_sem_t *sem)
{
	return ((int)(*sem));
}
    7a94:	6800      	ldr	r0, [r0, #0]
    7a96:	4770      	bx	lr

00007a98 <sys_sem_set_invalid>:
 *
 * \param sem Pointer to the semaphore.
 */
void sys_sem_set_invalid(sys_sem_t *sem)
{
	*sem = NULL;
    7a98:	2300      	movs	r3, #0
    7a9a:	6003      	str	r3, [r0, #0]
}
    7a9c:	4770      	bx	lr
	...

00007aa0 <sys_mbox_new>:
 * \param size Maximum "size" elements.
 *
 * \return ERR_OK if successfull or ERR_MEM on error.
 */
err_t sys_mbox_new(sys_mbox_t *mBoxNew, int size )
{
    7aa0:	b510      	push	{r4, lr}
    7aa2:	4604      	mov	r4, r0
    7aa4:	4608      	mov	r0, r1
	err_t err_mbox = ERR_MEM;

	/* Sanity check */
	if (mBoxNew != NULL) {
    7aa6:	b134      	cbz	r4, 7ab6 <sys_mbox_new+0x16>
		*mBoxNew = xQueueCreate( size, sizeof(void *));
    7aa8:	4b04      	ldr	r3, [pc, #16]	; (7abc <sys_mbox_new+0x1c>)
    7aaa:	2200      	movs	r2, #0
    7aac:	2104      	movs	r1, #4
    7aae:	4798      	blx	r3
    7ab0:	6020      	str	r0, [r4, #0]
				lwip_stats.sys.mbox.max	= lwip_stats.sys.mbox.used;
			}
		}

  #endif /* SYS_STATS */
		err_mbox = ERR_OK;
    7ab2:	2000      	movs	r0, #0
	}

	return(err_mbox);
}
    7ab4:	bd10      	pop	{r4, pc}
	err_t err_mbox = ERR_MEM;
    7ab6:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    7aba:	e7fb      	b.n	7ab4 <sys_mbox_new+0x14>
    7abc:	0000054d 	.word	0x0000054d

00007ac0 <sys_mbox_free>:
    7ac0:	4b00      	ldr	r3, [pc, #0]	; (7ac4 <sys_mbox_free+0x4>)
    7ac2:	4718      	bx	r3
    7ac4:	00007a0d 	.word	0x00007a0d

00007ac8 <sys_mbox_post>:
 *
 * \param mbox Pointer to the mailbox.
 * \param msg Pointer to the message to be post.
 */
void sys_mbox_post(sys_mbox_t *mbox, void *msg)
{
    7ac8:	b537      	push	{r0, r1, r2, r4, r5, lr}
	/* Sanit check */
	if (mbox != NULL) {
    7aca:	4604      	mov	r4, r0
{
    7acc:	9101      	str	r1, [sp, #4]
	if (mbox != NULL) {
    7ace:	b140      	cbz	r0, 7ae2 <sys_mbox_post+0x1a>
		while (pdTRUE != xQueueSend( *mbox, &msg, SYS_ARCH_BLOCKING_TICKTIMEOUT )) {
    7ad0:	4d05      	ldr	r5, [pc, #20]	; (7ae8 <sys_mbox_post+0x20>)
    7ad2:	6820      	ldr	r0, [r4, #0]
    7ad4:	2300      	movs	r3, #0
    7ad6:	f242 7210 	movw	r2, #10000	; 0x2710
    7ada:	a901      	add	r1, sp, #4
    7adc:	47a8      	blx	r5
    7ade:	2801      	cmp	r0, #1
    7ae0:	d1f7      	bne.n	7ad2 <sys_mbox_post+0xa>
		}
	}
}
    7ae2:	b003      	add	sp, #12
    7ae4:	bd30      	pop	{r4, r5, pc}
    7ae6:	bf00      	nop
    7ae8:	00000611 	.word	0x00000611

00007aec <sys_mbox_trypost>:
 * \param msg Pointer to the message to be post.
 *
 * \return ERR_MEM if the mailbox is full otherwise ERR_OK if the "msg" is posted.
 */
err_t sys_mbox_trypost(sys_mbox_t *mbox, void *msg)
{
    7aec:	b51f      	push	{r0, r1, r2, r3, r4, lr}
    7aee:	9101      	str	r1, [sp, #4]
	err_t err_mbox = ERR_MEM;

	/* Sanity check */
	if (mbox != NULL) {
    7af0:	b330      	cbz	r0, 7b40 <sys_mbox_trypost+0x54>
		if (SCB->ICSR & SCB_ICSR_VECTACTIVE_Msk) {
    7af2:	4b15      	ldr	r3, [pc, #84]	; (7b48 <sys_mbox_trypost+0x5c>)
			portBASE_TYPE task_woken = 0;
			if (errQUEUE_FULL != xQueueSendFromISR( *mbox, &msg, &task_woken )) {
    7af4:	6800      	ldr	r0, [r0, #0]
		if (SCB->ICSR & SCB_ICSR_VECTACTIVE_Msk) {
    7af6:	685b      	ldr	r3, [r3, #4]
    7af8:	f3c3 0308 	ubfx	r3, r3, #0, #9
    7afc:	b1bb      	cbz	r3, 7b2e <sys_mbox_trypost+0x42>
			portBASE_TYPE task_woken = 0;
    7afe:	2300      	movs	r3, #0
			if (errQUEUE_FULL != xQueueSendFromISR( *mbox, &msg, &task_woken )) {
    7b00:	4c12      	ldr	r4, [pc, #72]	; (7b4c <sys_mbox_trypost+0x60>)
			portBASE_TYPE task_woken = 0;
    7b02:	9303      	str	r3, [sp, #12]
			if (errQUEUE_FULL != xQueueSendFromISR( *mbox, &msg, &task_woken )) {
    7b04:	aa03      	add	r2, sp, #12
    7b06:	a901      	add	r1, sp, #4
    7b08:	47a0      	blx	r4
				err_mbox = ERR_OK;
			}
			portEND_SWITCHING_ISR(task_woken);
    7b0a:	9b03      	ldr	r3, [sp, #12]
			if (errQUEUE_FULL != xQueueSendFromISR( *mbox, &msg, &task_woken )) {
    7b0c:	fab0 f080 	clz	r0, r0
    7b10:	0940      	lsrs	r0, r0, #5
    7b12:	4240      	negs	r0, r0
			portEND_SWITCHING_ISR(task_woken);
    7b14:	b14b      	cbz	r3, 7b2a <sys_mbox_trypost+0x3e>
    7b16:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
    7b1a:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
    7b1e:	f8c3 2d04 	str.w	r2, [r3, #3332]	; 0xd04
    7b22:	f3bf 8f4f 	dsb	sy
    7b26:	f3bf 8f6f 	isb	sy
				err_mbox = ERR_OK;
			}
		}
	}
	return (err_mbox);
}
    7b2a:	b004      	add	sp, #16
    7b2c:	bd10      	pop	{r4, pc}
			if (errQUEUE_FULL != xQueueSend( *mbox, &msg, 0 )) {
    7b2e:	4c08      	ldr	r4, [pc, #32]	; (7b50 <sys_mbox_trypost+0x64>)
    7b30:	461a      	mov	r2, r3
    7b32:	a901      	add	r1, sp, #4
    7b34:	47a0      	blx	r4
    7b36:	fab0 f080 	clz	r0, r0
    7b3a:	0940      	lsrs	r0, r0, #5
    7b3c:	4240      	negs	r0, r0
    7b3e:	e7f4      	b.n	7b2a <sys_mbox_trypost+0x3e>
	err_t err_mbox = ERR_MEM;
    7b40:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    7b44:	e7f1      	b.n	7b2a <sys_mbox_trypost+0x3e>
    7b46:	bf00      	nop
    7b48:	e000ed00 	.word	0xe000ed00
    7b4c:	000007b1 	.word	0x000007b1
    7b50:	00000611 	.word	0x00000611

00007b54 <sys_arch_mbox_fetch>:
 *
 * \return Number of milliseconds spent waiting or SYS_ARCH_TIMEOUT if there was
 * a timeout. Or ERR_MEM if invalid pointer to message box.
 */
u32_t sys_arch_mbox_fetch(sys_mbox_t *mbox, void **msg, u32_t timeout)
{
    7b54:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
    7b58:	460d      	mov	r5, r1
    7b5a:	4617      	mov	r7, r2
	void *tempoptr;
	/* Express the timeout in OS tick. */
	portTickType TickElapsed = (portTickType)(timeout / portTICK_RATE_MS);

	/* Sanity check */
	if (mbox != NULL) {
    7b5c:	4606      	mov	r6, r0
    7b5e:	b318      	cbz	r0, 7ba8 <sys_arch_mbox_fetch+0x54>
		if (timeout && !TickElapsed) {
			TickElapsed = 1; /* Wait at least one tick */
		}

		if (msg == NULL) {
    7b60:	b901      	cbnz	r1, 7b64 <sys_arch_mbox_fetch+0x10>
			msg = &tempoptr;
    7b62:	ad01      	add	r5, sp, #4
		}

		/* NOTE: INCLUDE_xTaskGetSchedulerState must be set to 1 in
		 * FreeRTOSConfig.h for xTaskGetTickCount() to be available */
		if (0 == TickElapsed) {
    7b64:	f8df 8048 	ldr.w	r8, [pc, #72]	; 7bb0 <sys_arch_mbox_fetch+0x5c>
    7b68:	f8df 9048 	ldr.w	r9, [pc, #72]	; 7bb4 <sys_arch_mbox_fetch+0x60>
    7b6c:	b997      	cbnz	r7, 7b94 <sys_arch_mbox_fetch+0x40>
			TickStart = xTaskGetTickCount();
    7b6e:	47c0      	blx	r8
    7b70:	4604      	mov	r4, r0
			/* If "timeout" is 0, the thread should be blocked until
			 * a message arrives */
			while (pdFALSE == xQueueReceive( *mbox, &(*msg),
    7b72:	6830      	ldr	r0, [r6, #0]
    7b74:	2300      	movs	r3, #0
    7b76:	f242 7210 	movw	r2, #10000	; 0x2710
    7b7a:	4629      	mov	r1, r5
    7b7c:	47c8      	blx	r9
    7b7e:	2800      	cmp	r0, #0
    7b80:	d0f7      	beq.n	7b72 <sys_arch_mbox_fetch+0x1e>
			}
		}

		/* If the function gets a msg, it should return the number of ms
		 * spent waiting. */
		TickStop = xTaskGetTickCount();
    7b82:	47c0      	blx	r8
		/* Take care of wrap-around. */
		if (TickStop >= TickStart) {
    7b84:	4284      	cmp	r4, r0
			TickElapsed = TickStop - TickStart;
		} else {
			TickElapsed = portMAX_DELAY - TickStart + TickStop;
    7b86:	bf88      	it	hi
    7b88:	f100 30ff 	addhi.w	r0, r0, #4294967295	; 0xffffffff
    7b8c:	1b00      	subs	r0, r0, r4

		return(TickElapsed * portTICK_RATE_MS);
	} else {
		return ERR_MEM;
	}
}
    7b8e:	b003      	add	sp, #12
    7b90:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
			TickStart = xTaskGetTickCount();
    7b94:	47c0      	blx	r8
			if (pdFALSE == xQueueReceive( *mbox, &(*msg), TickElapsed )) {
    7b96:	2300      	movs	r3, #0
			TickStart = xTaskGetTickCount();
    7b98:	4604      	mov	r4, r0
			if (pdFALSE == xQueueReceive( *mbox, &(*msg), TickElapsed )) {
    7b9a:	463a      	mov	r2, r7
    7b9c:	6830      	ldr	r0, [r6, #0]
    7b9e:	4629      	mov	r1, r5
    7ba0:	47c8      	blx	r9
    7ba2:	2800      	cmp	r0, #0
    7ba4:	d1ed      	bne.n	7b82 <sys_arch_mbox_fetch+0x2e>
				*msg = NULL;
    7ba6:	6028      	str	r0, [r5, #0]
		return ERR_MEM;
    7ba8:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    7bac:	e7ef      	b.n	7b8e <sys_arch_mbox_fetch+0x3a>
    7bae:	bf00      	nop
    7bb0:	00008d9d 	.word	0x00008d9d
    7bb4:	00000951 	.word	0x00000951

00007bb8 <sys_arch_mbox_tryfetch>:
 *
 * \return Number of milliseconds spent waiting or SYS_ARCH_TIMEOUT if there was
 * a timeout. Or ERR_MEM if invalid pointer to message box.
 */
u32_t sys_arch_mbox_tryfetch(sys_mbox_t *mbox, void **msg)
{
    7bb8:	b513      	push	{r0, r1, r4, lr}
	void *tempoptr;

	/* Sanity check */
	if (mbox != NULL) {
    7bba:	b160      	cbz	r0, 7bd6 <sys_arch_mbox_tryfetch+0x1e>
		if (msg == NULL) {
    7bbc:	b901      	cbnz	r1, 7bc0 <sys_arch_mbox_tryfetch+0x8>
			msg = &tempoptr;
    7bbe:	a901      	add	r1, sp, #4
		}

		if (pdFALSE == xQueueReceive( *mbox, &(*msg), 0 )) {
    7bc0:	2300      	movs	r3, #0
    7bc2:	6800      	ldr	r0, [r0, #0]
    7bc4:	4c05      	ldr	r4, [pc, #20]	; (7bdc <sys_arch_mbox_tryfetch+0x24>)
    7bc6:	461a      	mov	r2, r3
    7bc8:	47a0      	blx	r4
    7bca:	fab0 f080 	clz	r0, r0
    7bce:	0940      	lsrs	r0, r0, #5
    7bd0:	4240      	negs	r0, r0
		/* On success 0 is returned. */
		return(0);
	} else {
		return(SYS_MBOX_EMPTY);
	}
}
    7bd2:	b002      	add	sp, #8
    7bd4:	bd10      	pop	{r4, pc}
		return(SYS_MBOX_EMPTY);
    7bd6:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    7bda:	e7fa      	b.n	7bd2 <sys_arch_mbox_tryfetch+0x1a>
    7bdc:	00000951 	.word	0x00000951

00007be0 <sys_mbox_valid>:
    7be0:	6800      	ldr	r0, [r0, #0]
    7be2:	4770      	bx	lr

00007be4 <sys_mbox_set_invalid>:
    7be4:	2300      	movs	r3, #0
    7be6:	6003      	str	r3, [r0, #0]
    7be8:	4770      	bx	lr
	...

00007bec <sys_thread_new>:
 *
 * \return The id of the new thread.
 */
sys_thread_t sys_thread_new(const char *name, lwip_thread_fn thread, void *arg,
		int stacksize, int prio)
{
    7bec:	b530      	push	{r4, r5, lr}
    7bee:	b087      	sub	sp, #28
    7bf0:	4605      	mov	r5, r0
    7bf2:	4608      	mov	r0, r1
    7bf4:	4619      	mov	r1, r3
	sys_thread_t newthread;
	portBASE_TYPE result;
	SYS_ARCH_DECL_PROTECT(protectionLevel);

	result = xTaskCreate( thread, (signed portCHAR *)name, stacksize, arg,
    7bf6:	ab05      	add	r3, sp, #20
    7bf8:	2400      	movs	r4, #0
    7bfa:	9301      	str	r3, [sp, #4]
    7bfc:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    7bfe:	9300      	str	r3, [sp, #0]
    7c00:	e9cd 4402 	strd	r4, r4, [sp, #8]
    7c04:	4613      	mov	r3, r2
    7c06:	b28a      	uxth	r2, r1
    7c08:	4629      	mov	r1, r5
    7c0a:	4d06      	ldr	r5, [pc, #24]	; (7c24 <sys_thread_new+0x38>)
    7c0c:	47a8      	blx	r5
			prio, &newthread );

	/* Need to protect this -- preemption here could be a problem! */
	SYS_ARCH_PROTECT(protectionLevel);
	if (pdPASS == result) {
    7c0e:	2801      	cmp	r0, #1
		Threads_TimeoutsList[NbActiveThreads++].pid = newthread;
    7c10:	bf0a      	itet	eq
    7c12:	4a05      	ldreq	r2, [pc, #20]	; (7c28 <sys_thread_new+0x3c>)
	} else {
		newthread = NULL;
    7c14:	9405      	strne	r4, [sp, #20]
		Threads_TimeoutsList[NbActiveThreads++].pid = newthread;
    7c16:	8813      	ldrheq	r3, [r2, #0]
	}

	SYS_ARCH_UNPROTECT(protectionLevel);

	return(newthread);
}
    7c18:	9805      	ldr	r0, [sp, #20]
		Threads_TimeoutsList[NbActiveThreads++].pid = newthread;
    7c1a:	bf04      	itt	eq
    7c1c:	3301      	addeq	r3, #1
    7c1e:	8013      	strheq	r3, [r2, #0]
}
    7c20:	b007      	add	sp, #28
    7c22:	bd30      	pop	{r4, r5, pc}
    7c24:	00008b49 	.word	0x00008b49
    7c28:	2001499e 	.word	0x2001499e

00007c2c <hri_sercomusart_wait_for_sync>:
	return ((Sercom *)hw)->SPI.SYNCBUSY.reg & reg;
}

static inline void hri_sercomusart_wait_for_sync(const void *const hw, hri_sercomusart_syncbusy_reg_t reg)
{
	while (((Sercom *)hw)->USART.SYNCBUSY.reg & reg) {
    7c2c:	69c3      	ldr	r3, [r0, #28]
    7c2e:	420b      	tst	r3, r1
    7c30:	d1fc      	bne.n	7c2c <hri_sercomusart_wait_for_sync>
	};
}
    7c32:	4770      	bx	lr

00007c34 <hri_sercomusart_clear_CTRLA_ENABLE_bit>:
}

static inline void hri_sercomusart_clear_CTRLA_ENABLE_bit(const void *const hw)
{
	SERCOM_CRITICAL_SECTION_ENTER();
	((Sercom *)hw)->USART.CTRLA.reg &= ~SERCOM_USART_CTRLA_ENABLE;
    7c34:	6802      	ldr	r2, [r0, #0]
	hri_sercomusart_wait_for_sync(hw, SERCOM_USART_SYNCBUSY_SWRST | SERCOM_USART_SYNCBUSY_ENABLE);
    7c36:	4b03      	ldr	r3, [pc, #12]	; (7c44 <hri_sercomusart_clear_CTRLA_ENABLE_bit+0x10>)
	((Sercom *)hw)->USART.CTRLA.reg &= ~SERCOM_USART_CTRLA_ENABLE;
    7c38:	f022 0202 	bic.w	r2, r2, #2
    7c3c:	6002      	str	r2, [r0, #0]
	hri_sercomusart_wait_for_sync(hw, SERCOM_USART_SYNCBUSY_SWRST | SERCOM_USART_SYNCBUSY_ENABLE);
    7c3e:	2103      	movs	r1, #3
    7c40:	4718      	bx	r3
    7c42:	bf00      	nop
    7c44:	00007c2d 	.word	0x00007c2d

00007c48 <_sercom_get_hardware_index>:

/**
 * \brief Retrieve ordinal number of the given sercom hardware instance
 */
static uint8_t _sercom_get_hardware_index(const void *const hw)
{
    7c48:	b570      	push	{r4, r5, r6, lr}
	Sercom *const sercom_modules[] = SERCOM_INSTS;
    7c4a:	4d0c      	ldr	r5, [pc, #48]	; (7c7c <_sercom_get_hardware_index+0x34>)
{
    7c4c:	4606      	mov	r6, r0
	Sercom *const sercom_modules[] = SERCOM_INSTS;
    7c4e:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
{
    7c50:	b088      	sub	sp, #32
	Sercom *const sercom_modules[] = SERCOM_INSTS;
    7c52:	466c      	mov	r4, sp
    7c54:	c40f      	stmia	r4!, {r0, r1, r2, r3}
    7c56:	e895 000f 	ldmia.w	r5, {r0, r1, r2, r3}
    7c5a:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
	/* Find index for SERCOM instance. */
	for (uint32_t i = 0; i < SERCOM_INST_NUM; i++) {
    7c5e:	466a      	mov	r2, sp
    7c60:	2300      	movs	r3, #0
		if ((uint32_t)hw == (uint32_t)sercom_modules[i]) {
    7c62:	f852 1b04 	ldr.w	r1, [r2], #4
    7c66:	42b1      	cmp	r1, r6
    7c68:	d102      	bne.n	7c70 <_sercom_get_hardware_index+0x28>
			return i;
    7c6a:	b2d8      	uxtb	r0, r3
		}
	}
	return 0;
}
    7c6c:	b008      	add	sp, #32
    7c6e:	bd70      	pop	{r4, r5, r6, pc}
	for (uint32_t i = 0; i < SERCOM_INST_NUM; i++) {
    7c70:	3301      	adds	r3, #1
    7c72:	2b08      	cmp	r3, #8
    7c74:	d1f5      	bne.n	7c62 <_sercom_get_hardware_index+0x1a>
	return 0;
    7c76:	2000      	movs	r0, #0
    7c78:	e7f8      	b.n	7c6c <_sercom_get_hardware_index+0x24>
    7c7a:	bf00      	nop
    7c7c:	0000cb44 	.word	0x0000cb44

00007c80 <_usart_init>:
 * \param[in] hw The pointer to hardware instance
 *
 * \return The status of initialization
 */
static int32_t _usart_init(void *const hw)
{
    7c80:	b538      	push	{r3, r4, r5, lr}
	uint8_t sercom_offset = _sercom_get_hardware_index(hw);
    7c82:	4b1b      	ldr	r3, [pc, #108]	; (7cf0 <_usart_init+0x70>)
{
    7c84:	4604      	mov	r4, r0
	uint8_t sercom_offset = _sercom_get_hardware_index(hw);
    7c86:	4798      	blx	r3
		if (_usarts[i].number == sercom_offset) {
    7c88:	2802      	cmp	r0, #2
    7c8a:	d005      	beq.n	7c98 <_usart_init+0x18>
	ASSERT(false);
    7c8c:	4919      	ldr	r1, [pc, #100]	; (7cf4 <_usart_init+0x74>)
    7c8e:	4b1a      	ldr	r3, [pc, #104]	; (7cf8 <_usart_init+0x78>)
    7c90:	f240 2247 	movw	r2, #583	; 0x247
    7c94:	2000      	movs	r0, #0
    7c96:	4798      	blx	r3
	return ((Sercom *)hw)->USART.SYNCBUSY.reg & reg;
    7c98:	69e3      	ldr	r3, [r4, #28]
    7c9a:	4d18      	ldr	r5, [pc, #96]	; (7cfc <_usart_init+0x7c>)
	uint8_t i = _get_sercom_index(hw);

	if (!hri_sercomusart_is_syncing(hw, SERCOM_USART_SYNCBUSY_SWRST)) {
    7c9c:	f013 0f01 	tst.w	r3, #1
    7ca0:	d10e      	bne.n	7cc0 <_usart_init+0x40>

static inline hri_sercomusart_ctrla_reg_t hri_sercomusart_get_CTRLA_reg(const void *const           hw,
                                                                        hri_sercomusart_ctrla_reg_t mask)
{
	uint32_t tmp;
	hri_sercomusart_wait_for_sync(hw, SERCOM_USART_SYNCBUSY_SWRST | SERCOM_USART_SYNCBUSY_ENABLE);
    7ca2:	2103      	movs	r1, #3
    7ca4:	4620      	mov	r0, r4
    7ca6:	47a8      	blx	r5
	tmp = ((Sercom *)hw)->USART.CTRLA.reg;
    7ca8:	6823      	ldr	r3, [r4, #0]
		uint32_t mode = _usarts[i].ctrl_a & SERCOM_USART_CTRLA_MODE_Msk;
		if (hri_sercomusart_get_CTRLA_reg(hw, SERCOM_USART_CTRLA_ENABLE)) {
    7caa:	079b      	lsls	r3, r3, #30
    7cac:	d503      	bpl.n	7cb6 <_usart_init+0x36>
			hri_sercomusart_clear_CTRLA_ENABLE_bit(hw);
    7cae:	4b14      	ldr	r3, [pc, #80]	; (7d00 <_usart_init+0x80>)
    7cb0:	4798      	blx	r3
			hri_sercomusart_wait_for_sync(hw, SERCOM_USART_SYNCBUSY_ENABLE);
    7cb2:	2102      	movs	r1, #2
    7cb4:	47a8      	blx	r5
}

static inline void hri_sercomusart_write_CTRLA_reg(const void *const hw, hri_sercomusart_ctrla_reg_t data)
{
	SERCOM_CRITICAL_SECTION_ENTER();
	((Sercom *)hw)->USART.CTRLA.reg = data;
    7cb6:	2305      	movs	r3, #5
    7cb8:	6023      	str	r3, [r4, #0]
	hri_sercomusart_wait_for_sync(hw, SERCOM_USART_SYNCBUSY_SWRST | SERCOM_USART_SYNCBUSY_ENABLE);
    7cba:	2103      	movs	r1, #3
    7cbc:	4620      	mov	r0, r4
    7cbe:	47a8      	blx	r5
		}
		hri_sercomusart_write_CTRLA_reg(hw, SERCOM_USART_CTRLA_SWRST | mode);
	}
	hri_sercomusart_wait_for_sync(hw, SERCOM_USART_SYNCBUSY_SWRST);
    7cc0:	4620      	mov	r0, r4
    7cc2:	2101      	movs	r1, #1
    7cc4:	47a8      	blx	r5
	((Sercom *)hw)->USART.CTRLA.reg = data;
    7cc6:	4b0f      	ldr	r3, [pc, #60]	; (7d04 <_usart_init+0x84>)
    7cc8:	6023      	str	r3, [r4, #0]
	hri_sercomusart_wait_for_sync(hw, SERCOM_USART_SYNCBUSY_SWRST | SERCOM_USART_SYNCBUSY_ENABLE);
    7cca:	2103      	movs	r1, #3
    7ccc:	47a8      	blx	r5
}

static inline void hri_sercomusart_write_CTRLB_reg(const void *const hw, hri_sercomusart_ctrlb_reg_t data)
{
	SERCOM_CRITICAL_SECTION_ENTER();
	((Sercom *)hw)->USART.CTRLB.reg = data;
    7cce:	f44f 3340 	mov.w	r3, #196608	; 0x30000
    7cd2:	6063      	str	r3, [r4, #4]
	hri_sercomusart_wait_for_sync(hw, SERCOM_USART_SYNCBUSY_MASK);
    7cd4:	211f      	movs	r1, #31
    7cd6:	47a8      	blx	r5
}

static inline void hri_sercomusart_write_CTRLC_reg(const void *const hw, hri_sercomusart_ctrlc_reg_t data)
{
	SERCOM_CRITICAL_SECTION_ENTER();
	((Sercom *)hw)->USART.CTRLC.reg = data;
    7cd8:	4b0b      	ldr	r3, [pc, #44]	; (7d08 <_usart_init+0x88>)
    7cda:	60a3      	str	r3, [r4, #8]
}

static inline void hri_sercomusart_write_BAUD_reg(const void *const hw, hri_sercomusart_baud_reg_t data)
{
	SERCOM_CRITICAL_SECTION_ENTER();
	((Sercom *)hw)->USART.BAUD.reg = data;
    7cdc:	f64f 43b9 	movw	r3, #64697	; 0xfcb9
    7ce0:	81a3      	strh	r3, [r4, #12]
}

static inline void hri_sercomusart_write_RXPL_reg(const void *const hw, hri_sercomusart_rxpl_reg_t data)
{
	SERCOM_CRITICAL_SECTION_ENTER();
	((Sercom *)hw)->USART.RXPL.reg = data;
    7ce2:	2300      	movs	r3, #0
    7ce4:	73a3      	strb	r3, [r4, #14]

	hri_sercomusart_write_RXPL_reg(hw, _usarts[i].rxpl);
	hri_sercomusart_write_DBGCTRL_reg(hw, _usarts[i].debug_ctrl);

	return ERR_NONE;
}
    7ce6:	4618      	mov	r0, r3
}

static inline void hri_sercomusart_write_DBGCTRL_reg(const void *const hw, hri_sercomusart_dbgctrl_reg_t data)
{
	SERCOM_CRITICAL_SECTION_ENTER();
	((Sercom *)hw)->USART.DBGCTRL.reg = data;
    7ce8:	f884 3030 	strb.w	r3, [r4, #48]	; 0x30
    7cec:	bd38      	pop	{r3, r4, r5, pc}
    7cee:	bf00      	nop
    7cf0:	00007c49 	.word	0x00007c49
    7cf4:	0000cb28 	.word	0x0000cb28
    7cf8:	00008a19 	.word	0x00008a19
    7cfc:	00007c2d 	.word	0x00007c2d
    7d00:	00007c35 	.word	0x00007c35
    7d04:	40100004 	.word	0x40100004
    7d08:	00700002 	.word	0x00700002

00007d0c <_usart_sync_init>:
{
    7d0c:	b570      	push	{r4, r5, r6, lr}
	ASSERT(device);
    7d0e:	4605      	mov	r5, r0
    7d10:	3800      	subs	r0, #0
{
    7d12:	460c      	mov	r4, r1
	ASSERT(device);
    7d14:	4b05      	ldr	r3, [pc, #20]	; (7d2c <_usart_sync_init+0x20>)
    7d16:	4906      	ldr	r1, [pc, #24]	; (7d30 <_usart_sync_init+0x24>)
    7d18:	bf18      	it	ne
    7d1a:	2001      	movne	r0, #1
    7d1c:	22bb      	movs	r2, #187	; 0xbb
    7d1e:	4798      	blx	r3
	device->hw = hw;
    7d20:	602c      	str	r4, [r5, #0]
	return _usart_init(hw);
    7d22:	4620      	mov	r0, r4
    7d24:	4b03      	ldr	r3, [pc, #12]	; (7d34 <_usart_sync_init+0x28>)
}
    7d26:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	return _usart_init(hw);
    7d2a:	4718      	bx	r3
    7d2c:	00008a19 	.word	0x00008a19
    7d30:	0000cb28 	.word	0x0000cb28
    7d34:	00007c81 	.word	0x00007c81

00007d38 <_usart_sync_enable>:
	hri_sercomusart_set_CTRLA_ENABLE_bit(device->hw);
    7d38:	6800      	ldr	r0, [r0, #0]
	((Sercom *)hw)->USART.CTRLA.reg |= SERCOM_USART_CTRLA_ENABLE;
    7d3a:	6803      	ldr	r3, [r0, #0]
    7d3c:	f043 0302 	orr.w	r3, r3, #2
    7d40:	6003      	str	r3, [r0, #0]
	hri_sercomusart_wait_for_sync(hw, SERCOM_USART_SYNCBUSY_SWRST | SERCOM_USART_SYNCBUSY_ENABLE);
    7d42:	2103      	movs	r1, #3
    7d44:	4b00      	ldr	r3, [pc, #0]	; (7d48 <_usart_sync_enable+0x10>)
    7d46:	4718      	bx	r3
    7d48:	00007c2d 	.word	0x00007c2d

00007d4c <_usart_sync_write_byte>:
	hri_sercomusart_write_DATA_reg(device->hw, data);
    7d4c:	6803      	ldr	r3, [r0, #0]
	((Sercom *)hw)->USART.DATA.reg = data;
    7d4e:	6299      	str	r1, [r3, #40]	; 0x28
}
    7d50:	4770      	bx	lr

00007d52 <_usart_sync_read_byte>:
	return hri_sercomusart_read_DATA_reg(device->hw);
    7d52:	6803      	ldr	r3, [r0, #0]
	return ((Sercom *)hw)->USART.DATA.reg;
    7d54:	6a98      	ldr	r0, [r3, #40]	; 0x28
}
    7d56:	b2c0      	uxtb	r0, r0
    7d58:	4770      	bx	lr

00007d5a <_usart_sync_is_ready_to_send>:
	return hri_sercomusart_get_interrupt_DRE_bit(device->hw);
    7d5a:	6803      	ldr	r3, [r0, #0]
	return (((Sercom *)hw)->USART.INTFLAG.reg & SERCOM_USART_INTFLAG_DRE) >> SERCOM_USART_INTFLAG_DRE_Pos;
    7d5c:	7e18      	ldrb	r0, [r3, #24]
}
    7d5e:	f000 0001 	and.w	r0, r0, #1
    7d62:	4770      	bx	lr

00007d64 <_usart_sync_is_transmit_done>:
	return hri_sercomusart_get_interrupt_TXC_bit(device->hw);
    7d64:	6803      	ldr	r3, [r0, #0]
	return (((Sercom *)hw)->USART.INTFLAG.reg & SERCOM_USART_INTFLAG_TXC) >> SERCOM_USART_INTFLAG_TXC_Pos;
    7d66:	7e18      	ldrb	r0, [r3, #24]
}
    7d68:	f3c0 0040 	ubfx	r0, r0, #1, #1
    7d6c:	4770      	bx	lr

00007d6e <_usart_sync_is_byte_received>:
	return hri_sercomusart_get_interrupt_RXC_bit(device->hw);
    7d6e:	6803      	ldr	r3, [r0, #0]
	return (((Sercom *)hw)->USART.INTFLAG.reg & SERCOM_USART_INTFLAG_RXC) >> SERCOM_USART_INTFLAG_RXC_Pos;
    7d70:	7e18      	ldrb	r0, [r3, #24]
}
    7d72:	f3c0 0080 	ubfx	r0, r0, #2, #1
    7d76:	4770      	bx	lr

00007d78 <led_task>:
	((Port *)hw)->Group[submodule_index].OUTTGL.reg = mask;
    7d78:	4e05      	ldr	r6, [pc, #20]	; (7d90 <led_task+0x18>)
static void led_task(void *p)
{
	(void)p;
	for (;;) {
		gpio_toggle_pin_level(LED_0);
		os_sleep(led_blink_rate);
    7d7a:	4d06      	ldr	r5, [pc, #24]	; (7d94 <led_task+0x1c>)
    7d7c:	4c06      	ldr	r4, [pc, #24]	; (7d98 <led_task+0x20>)
{
    7d7e:	b580      	push	{r7, lr}
    7d80:	f44f 2780 	mov.w	r7, #262144	; 0x40000
		os_sleep(led_blink_rate);
    7d84:	8828      	ldrh	r0, [r5, #0]
    7d86:	f8c6 711c 	str.w	r7, [r6, #284]	; 0x11c
    7d8a:	47a0      	blx	r4
	for (;;) {
    7d8c:	e7fa      	b.n	7d84 <led_task+0xc>
    7d8e:	bf00      	nop
    7d90:	41008000 	.word	0x41008000
    7d94:	20000014 	.word	0x20000014
    7d98:	00008f89 	.word	0x00008f89

00007d9c <gmac_task>:
/**
 * \brief Task for GMAC.
 * Waits for GMAC interrupt and begins processing of received packets
 */
void gmac_task(void *pvParameters)
{
    7d9c:	b570      	push	{r4, r5, r6, lr}
	gmac_device *ps_gmac_dev = pvParameters;

	while (1) {
		/* Wait for the counting RX notification semaphore. */
		xSemaphoreTake(ps_gmac_dev->rx_sem, portMAX_DELAY);
    7d9e:	4e06      	ldr	r6, [pc, #24]	; (7db8 <gmac_task+0x1c>)

		/* Process the incoming packet. */
		ethernetif_mac_input(ps_gmac_dev->netif);
    7da0:	4d06      	ldr	r5, [pc, #24]	; (7dbc <gmac_task+0x20>)
{
    7da2:	4604      	mov	r4, r0
		xSemaphoreTake(ps_gmac_dev->rx_sem, portMAX_DELAY);
    7da4:	2300      	movs	r3, #0
    7da6:	6860      	ldr	r0, [r4, #4]
    7da8:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
    7dac:	4619      	mov	r1, r3
    7dae:	47b0      	blx	r6
		ethernetif_mac_input(ps_gmac_dev->netif);
    7db0:	6820      	ldr	r0, [r4, #0]
    7db2:	47a8      	blx	r5
	while (1) {
    7db4:	e7f6      	b.n	7da4 <gmac_task+0x8>
    7db6:	bf00      	nop
    7db8:	00000951 	.word	0x00000951
    7dbc:	00007481 	.word	0x00007481

00007dc0 <gmac_handler_cb>:
{
    7dc0:	b507      	push	{r0, r1, r2, lr}
	portBASE_TYPE xGMACTaskWoken = pdFALSE;
    7dc2:	2300      	movs	r3, #0
    7dc4:	9301      	str	r3, [sp, #4]
	xSemaphoreGiveFromISR(gs_gmac_dev.rx_sem, &xGMACTaskWoken);
    7dc6:	4b0a      	ldr	r3, [pc, #40]	; (7df0 <gmac_handler_cb+0x30>)
    7dc8:	a901      	add	r1, sp, #4
    7dca:	6858      	ldr	r0, [r3, #4]
    7dcc:	4b09      	ldr	r3, [pc, #36]	; (7df4 <gmac_handler_cb+0x34>)
    7dce:	4798      	blx	r3
	portEND_SWITCHING_ISR(xGMACTaskWoken);
    7dd0:	9b01      	ldr	r3, [sp, #4]
    7dd2:	b14b      	cbz	r3, 7de8 <gmac_handler_cb+0x28>
    7dd4:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
    7dd8:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
    7ddc:	f8c3 2d04 	str.w	r2, [r3, #3332]	; 0xd04
    7de0:	f3bf 8f4f 	dsb	sy
    7de4:	f3bf 8f6f 	isb	sy
}
    7de8:	b003      	add	sp, #12
    7dea:	f85d fb04 	ldr.w	pc, [sp], #4
    7dee:	bf00      	nop
    7df0:	200149a0 	.word	0x200149a0
    7df4:	0000088d 	.word	0x0000088d

00007df8 <tcpip_init_done>:
{
    7df8:	b5f0      	push	{r4, r5, r6, r7, lr}
	u8_t mac[6] = {0x00, 0x00, 0x00, 0x00, 0x20, 0x76};
    7dfa:	4b27      	ldr	r3, [pc, #156]	; (7e98 <tcpip_init_done+0xa0>)
	mac_async_register_callback(&COMMUNICATION_IO, MAC_ASYNC_RECEIVE_CB, gmac_handler_cb);
    7dfc:	4c27      	ldr	r4, [pc, #156]	; (7e9c <tcpip_init_done+0xa4>)
    7dfe:	4a28      	ldr	r2, [pc, #160]	; (7ea0 <tcpip_init_done+0xa8>)
	while ((ethernet_phy_get_link_status(&ETHERNET_PHY_0_desc, &link_up)) != ERR_NONE && !(link_up)) {
    7e00:	4d28      	ldr	r5, [pc, #160]	; (7ea4 <tcpip_init_done+0xac>)
    7e02:	4f29      	ldr	r7, [pc, #164]	; (7ea8 <tcpip_init_done+0xb0>)
{
    7e04:	b085      	sub	sp, #20
    7e06:	4606      	mov	r6, r0
	u8_t mac[6] = {0x00, 0x00, 0x00, 0x00, 0x20, 0x76};
    7e08:	6818      	ldr	r0, [r3, #0]
    7e0a:	889b      	ldrh	r3, [r3, #4]
    7e0c:	9002      	str	r0, [sp, #8]
    7e0e:	f8ad 300c 	strh.w	r3, [sp, #12]
	mac_async_register_callback(&COMMUNICATION_IO, MAC_ASYNC_RECEIVE_CB, gmac_handler_cb);
    7e12:	4620      	mov	r0, r4
    7e14:	4b25      	ldr	r3, [pc, #148]	; (7eac <tcpip_init_done+0xb4>)
    7e16:	2100      	movs	r1, #0
    7e18:	4798      	blx	r3
	hri_gmac_set_IMR_RCOMP_bit(COMMUNICATION_IO.dev.hw);
    7e1a:	6823      	ldr	r3, [r4, #0]
	((Gmac *)hw)->IDR.reg = GMAC_IMR_MFS;
}

static inline void hri_gmac_set_IMR_RCOMP_bit(const void *const hw)
{
	((Gmac *)hw)->IER.reg = GMAC_IMR_RCOMP;
    7e1c:	2202      	movs	r2, #2
    7e1e:	629a      	str	r2, [r3, #40]	; 0x28
	while ((ethernet_phy_get_link_status(&ETHERNET_PHY_0_desc, &link_up)) != ERR_NONE && !(link_up)) {
    7e20:	f105 0409 	add.w	r4, r5, #9
    7e24:	4b22      	ldr	r3, [pc, #136]	; (7eb0 <tcpip_init_done+0xb8>)
    7e26:	4621      	mov	r1, r4
    7e28:	4638      	mov	r0, r7
    7e2a:	4798      	blx	r3
    7e2c:	b110      	cbz	r0, 7e34 <tcpip_init_done+0x3c>
    7e2e:	7a6b      	ldrb	r3, [r5, #9]
    7e30:	2b00      	cmp	r3, #0
    7e32:	d02c      	beq.n	7e8e <tcpip_init_done+0x96>
	printf("\r\nEthernet link up\r\n\r\n");
    7e34:	4b1f      	ldr	r3, [pc, #124]	; (7eb4 <tcpip_init_done+0xbc>)
    7e36:	4820      	ldr	r0, [pc, #128]	; (7eb8 <tcpip_init_done+0xc0>)
	TCPIP_STACK_INTERFACE_0_desc.input = tcpip_input;
    7e38:	4c20      	ldr	r4, [pc, #128]	; (7ebc <tcpip_init_done+0xc4>)
	printf("\r\nEthernet link up\r\n\r\n");
    7e3a:	4798      	blx	r3
 */
__STATIC_INLINE void __NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if ((int32_t)(IRQn) >= 0)
  {
    NVIC->IP[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
    7e3c:	4b20      	ldr	r3, [pc, #128]	; (7ec0 <tcpip_init_done+0xc8>)
	mac_async_enable(&COMMUNICATION_IO);
    7e3e:	4817      	ldr	r0, [pc, #92]	; (7e9c <tcpip_init_done+0xa4>)
    7e40:	2280      	movs	r2, #128	; 0x80
    7e42:	f883 2354 	strb.w	r2, [r3, #852]	; 0x354
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
    7e46:	f44f 1280 	mov.w	r2, #1048576	; 0x100000
    7e4a:	609a      	str	r2, [r3, #8]
    7e4c:	4b1d      	ldr	r3, [pc, #116]	; (7ec4 <tcpip_init_done+0xcc>)
    7e4e:	4798      	blx	r3
	TCPIP_STACK_INTERFACE_0_init(mac);
    7e50:	a802      	add	r0, sp, #8
    7e52:	4b1d      	ldr	r3, [pc, #116]	; (7ec8 <tcpip_init_done+0xd0>)
    7e54:	4798      	blx	r3
	TCPIP_STACK_INTERFACE_0_desc.input = tcpip_input;
    7e56:	4b1d      	ldr	r3, [pc, #116]	; (7ecc <tcpip_init_done+0xd4>)
    7e58:	6123      	str	r3, [r4, #16]
	gs_gmac_dev.rx_sem = xSemaphoreCreateCounting(CONF_GMAC_RXDESCR_NUM, 0);
    7e5a:	2100      	movs	r1, #0
    7e5c:	4b1c      	ldr	r3, [pc, #112]	; (7ed0 <tcpip_init_done+0xd8>)
	gs_gmac_dev.netif = &TCPIP_STACK_INTERFACE_0_desc;
    7e5e:	602c      	str	r4, [r5, #0]
	gs_gmac_dev.rx_sem = xSemaphoreCreateCounting(CONF_GMAC_RXDESCR_NUM, 0);
    7e60:	2010      	movs	r0, #16
    7e62:	4798      	blx	r3
	id = sys_thread_new("GMAC", gmac_task, &gs_gmac_dev, netifINTERFACE_TASK_STACK_SIZE, netifINTERFACE_TASK_PRIORITY);
    7e64:	2302      	movs	r3, #2
    7e66:	4a0f      	ldr	r2, [pc, #60]	; (7ea4 <tcpip_init_done+0xac>)
    7e68:	491a      	ldr	r1, [pc, #104]	; (7ed4 <tcpip_init_done+0xdc>)
	gs_gmac_dev.rx_sem = xSemaphoreCreateCounting(CONF_GMAC_RXDESCR_NUM, 0);
    7e6a:	6068      	str	r0, [r5, #4]
	id = sys_thread_new("GMAC", gmac_task, &gs_gmac_dev, netifINTERFACE_TASK_STACK_SIZE, netifINTERFACE_TASK_PRIORITY);
    7e6c:	9300      	str	r3, [sp, #0]
    7e6e:	4d1a      	ldr	r5, [pc, #104]	; (7ed8 <tcpip_init_done+0xe0>)
    7e70:	481a      	ldr	r0, [pc, #104]	; (7edc <tcpip_init_done+0xe4>)
    7e72:	f44f 7300 	mov.w	r3, #512	; 0x200
    7e76:	47a8      	blx	r5
	netif_set_default(&TCPIP_STACK_INTERFACE_0_desc);
    7e78:	4620      	mov	r0, r4
    7e7a:	4b19      	ldr	r3, [pc, #100]	; (7ee0 <tcpip_init_done+0xe8>)
    7e7c:	4798      	blx	r3
	if (ERR_OK != dhcp_start(&TCPIP_STACK_INTERFACE_0_desc)) {
    7e7e:	4b19      	ldr	r3, [pc, #100]	; (7ee4 <tcpip_init_done+0xec>)
    7e80:	4620      	mov	r0, r4
    7e82:	4798      	blx	r3
	sys_sem_signal(sem); /* Signal the waiting thread that the TCP/IP init is done. */
    7e84:	4b18      	ldr	r3, [pc, #96]	; (7ee8 <tcpip_init_done+0xf0>)
    7e86:	4630      	mov	r0, r6
    7e88:	4798      	blx	r3
}
    7e8a:	b005      	add	sp, #20
    7e8c:	bdf0      	pop	{r4, r5, r6, r7, pc}
		os_sleep(20);
    7e8e:	4b17      	ldr	r3, [pc, #92]	; (7eec <tcpip_init_done+0xf4>)
    7e90:	2014      	movs	r0, #20
    7e92:	4798      	blx	r3
    7e94:	e7c6      	b.n	7e24 <tcpip_init_done+0x2c>
    7e96:	bf00      	nop
    7e98:	0000cbad 	.word	0x0000cbad
    7e9c:	2000a520 	.word	0x2000a520
    7ea0:	00007dc1 	.word	0x00007dc1
    7ea4:	200149a0 	.word	0x200149a0
    7ea8:	200000a4 	.word	0x200000a4
    7eac:	00004d31 	.word	0x00004d31
    7eb0:	00001001 	.word	0x00001001
    7eb4:	0000b395 	.word	0x0000b395
    7eb8:	0000cb8d 	.word	0x0000cb8d
    7ebc:	20014960 	.word	0x20014960
    7ec0:	e000e100 	.word	0xe000e100
    7ec4:	00004c75 	.word	0x00004c75
    7ec8:	000078fd 	.word	0x000078fd
    7ecc:	0000a19d 	.word	0x0000a19d
    7ed0:	000005bd 	.word	0x000005bd
    7ed4:	00007d9d 	.word	0x00007d9d
    7ed8:	00007bed 	.word	0x00007bed
    7edc:	0000cba4 	.word	0x0000cba4
    7ee0:	0000a08d 	.word	0x0000a08d
    7ee4:	0000622d 	.word	0x0000622d
    7ee8:	00007a1d 	.word	0x00007a1d
    7eec:	00008f89 	.word	0x00008f89

00007ef0 <task_led_create>:

/**
 * \brief Create OS task for LED blinking
 */
void task_led_create(void)
{
    7ef0:	b51f      	push	{r0, r1, r2, r3, r4, lr}

	/* Create task to make led blink */
	if (xTaskCreate(led_task, "Led", TASK_LED_STACK_SIZE, NULL, TASK_LED_TASK_PRIORITY, &xLed_Task) != pdPASS) {
    7ef2:	4a08      	ldr	r2, [pc, #32]	; (7f14 <task_led_create+0x24>)
    7ef4:	9201      	str	r2, [sp, #4]
    7ef6:	2300      	movs	r3, #0
    7ef8:	2201      	movs	r2, #1
    7efa:	9200      	str	r2, [sp, #0]
    7efc:	e9cd 3302 	strd	r3, r3, [sp, #8]
    7f00:	4905      	ldr	r1, [pc, #20]	; (7f18 <task_led_create+0x28>)
    7f02:	4806      	ldr	r0, [pc, #24]	; (7f1c <task_led_create+0x2c>)
    7f04:	4c06      	ldr	r4, [pc, #24]	; (7f20 <task_led_create+0x30>)
    7f06:	2280      	movs	r2, #128	; 0x80
    7f08:	47a0      	blx	r4
    7f0a:	2801      	cmp	r0, #1
    7f0c:	d000      	beq.n	7f10 <task_led_create+0x20>
		while (1) {
    7f0e:	e7fe      	b.n	7f0e <task_led_create+0x1e>
			;
		}
	}
}
    7f10:	b004      	add	sp, #16
    7f12:	bd10      	pop	{r4, pc}
    7f14:	200149ac 	.word	0x200149ac
    7f18:	0000cba9 	.word	0x0000cba9
    7f1c:	00007d79 	.word	0x00007d79
    7f20:	00008b49 	.word	0x00008b49

00007f24 <lwip_init>:

/**
 * Perform Sanity check of user-configurable values, and initialize all modules.
 */
void lwip_init(void)
{
    7f24:	b510      	push	{r4, lr}
	/* Modules initialization */
	stats_init();
#if !NO_SYS
	sys_init();
    7f26:	4b09      	ldr	r3, [pc, #36]	; (7f4c <lwip_init+0x28>)
    7f28:	4798      	blx	r3
#endif /* !NO_SYS */
	mem_init();
    7f2a:	4b09      	ldr	r3, [pc, #36]	; (7f50 <lwip_init+0x2c>)
    7f2c:	4798      	blx	r3
	memp_init();
    7f2e:	4b09      	ldr	r3, [pc, #36]	; (7f54 <lwip_init+0x30>)
    7f30:	4798      	blx	r3
	pbuf_init();
	netif_init();
    7f32:	4b09      	ldr	r3, [pc, #36]	; (7f58 <lwip_init+0x34>)
    7f34:	4798      	blx	r3
#if LWIP_SOCKET
	lwip_socket_init();
    7f36:	4b09      	ldr	r3, [pc, #36]	; (7f5c <lwip_init+0x38>)
    7f38:	4798      	blx	r3
#endif /* LWIP_ARP */
#if LWIP_RAW
	raw_init();
#endif /* LWIP_RAW */
#if LWIP_UDP
	udp_init();
    7f3a:	4b09      	ldr	r3, [pc, #36]	; (7f60 <lwip_init+0x3c>)
    7f3c:	4798      	blx	r3
#endif /* LWIP_UDP */
#if LWIP_TCP
	tcp_init();
    7f3e:	4b09      	ldr	r3, [pc, #36]	; (7f64 <lwip_init+0x40>)
    7f40:	4798      	blx	r3
#endif /* LWIP_DNS */

#if LWIP_TIMERS
	sys_timeouts_init();
#endif /* LWIP_TIMERS */
}
    7f42:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	sys_timeouts_init();
    7f46:	4b08      	ldr	r3, [pc, #32]	; (7f68 <lwip_init+0x44>)
    7f48:	4718      	bx	r3
    7f4a:	bf00      	nop
    7f4c:	000079a1 	.word	0x000079a1
    7f50:	0000663d 	.word	0x0000663d
    7f54:	00004bb5 	.word	0x00004bb5
    7f58:	00009fb5 	.word	0x00009fb5
    7f5c:	000095fd 	.word	0x000095fd
    7f60:	00004479 	.word	0x00004479
    7f64:	00006935 	.word	0x00006935
    7f68:	00001119 	.word	0x00001119

00007f6c <prvInsertTimerInActiveList>:
	BaseType_t xProcessTimerNow = pdFALSE;

	listSET_LIST_ITEM_VALUE(&(pxTimer->xTimerListItem), xNextExpiryTime);
	listSET_LIST_ITEM_OWNER(&(pxTimer->xTimerListItem), pxTimer);

	if (xNextExpiryTime <= xTimeNow) {
    7f6c:	4291      	cmp	r1, r2
{
    7f6e:	b508      	push	{r3, lr}
	listSET_LIST_ITEM_VALUE(&(pxTimer->xTimerListItem), xNextExpiryTime);
    7f70:	6041      	str	r1, [r0, #4]
	listSET_LIST_ITEM_OWNER(&(pxTimer->xTimerListItem), pxTimer);
    7f72:	6100      	str	r0, [r0, #16]
	if (xNextExpiryTime <= xTimeNow) {
    7f74:	d80a      	bhi.n	7f8c <prvInsertTimerInActiveList+0x20>
		/* Has the expiry time elapsed between the command to start/reset a
		timer was issued, and the time the command was processed? */
		if ((xTimeNow - xCommandTime) >= pxTimer->xTimerPeriodInTicks) {
    7f76:	1ad2      	subs	r2, r2, r3
    7f78:	6983      	ldr	r3, [r0, #24]
    7f7a:	429a      	cmp	r2, r3
    7f7c:	d20e      	bcs.n	7f9c <prvInsertTimerInActiveList+0x30>
			/* The time between a command being issued and the command being
			processed actually exceeds the timers period.  */
			xProcessTimerNow = pdTRUE;
		} else {
			vListInsert(pxOverflowTimerList, &(pxTimer->xTimerListItem));
    7f7e:	4b08      	ldr	r3, [pc, #32]	; (7fa0 <prvInsertTimerInActiveList+0x34>)
    7f80:	1d01      	adds	r1, r0, #4
    7f82:	6818      	ldr	r0, [r3, #0]
			/* If, since the command was issued, the tick count has overflowed
			but the expiry time has not, then the timer must have already passed
			its expiry time and should be processed immediately. */
			xProcessTimerNow = pdTRUE;
		} else {
			vListInsert(pxCurrentTimerList, &(pxTimer->xTimerListItem));
    7f84:	4b07      	ldr	r3, [pc, #28]	; (7fa4 <prvInsertTimerInActiveList+0x38>)
    7f86:	4798      	blx	r3
	BaseType_t xProcessTimerNow = pdFALSE;
    7f88:	2000      	movs	r0, #0
		}
	}

	return xProcessTimerNow;
}
    7f8a:	bd08      	pop	{r3, pc}
		if ((xTimeNow < xCommandTime) && (xNextExpiryTime >= xCommandTime)) {
    7f8c:	429a      	cmp	r2, r3
    7f8e:	d201      	bcs.n	7f94 <prvInsertTimerInActiveList+0x28>
    7f90:	4299      	cmp	r1, r3
    7f92:	d203      	bcs.n	7f9c <prvInsertTimerInActiveList+0x30>
			vListInsert(pxCurrentTimerList, &(pxTimer->xTimerListItem));
    7f94:	4b02      	ldr	r3, [pc, #8]	; (7fa0 <prvInsertTimerInActiveList+0x34>)
    7f96:	1d01      	adds	r1, r0, #4
    7f98:	6858      	ldr	r0, [r3, #4]
    7f9a:	e7f3      	b.n	7f84 <prvInsertTimerInActiveList+0x18>
			xProcessTimerNow = pdTRUE;
    7f9c:	2001      	movs	r0, #1
	return xProcessTimerNow;
    7f9e:	e7f4      	b.n	7f8a <prvInsertTimerInActiveList+0x1e>
    7fa0:	200149b0 	.word	0x200149b0
    7fa4:	00001e2d 	.word	0x00001e2d

00007fa8 <prvCheckForValidListAndQueue>:
	pxOverflowTimerList = pxTemp;
}
/*-----------------------------------------------------------*/

static void prvCheckForValidListAndQueue(void)
{
    7fa8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	/* Check that the list from which active timers are referenced, and the
	queue used to communicate with the timer service, have been
	initialised. */
	taskENTER_CRITICAL();
	{
		if (xTimerQueue == NULL) {
    7fac:	4c12      	ldr	r4, [pc, #72]	; (7ff8 <prvCheckForValidListAndQueue+0x50>)
	taskENTER_CRITICAL();
    7fae:	4b13      	ldr	r3, [pc, #76]	; (7ffc <prvCheckForValidListAndQueue+0x54>)
    7fb0:	4798      	blx	r3
		if (xTimerQueue == NULL) {
    7fb2:	68a5      	ldr	r5, [r4, #8]
    7fb4:	b995      	cbnz	r5, 7fdc <prvCheckForValidListAndQueue+0x34>
			vListInitialise(&xActiveTimerList1);
    7fb6:	f104 070c 	add.w	r7, r4, #12
    7fba:	f8df 804c 	ldr.w	r8, [pc, #76]	; 8008 <prvCheckForValidListAndQueue+0x60>
    7fbe:	4638      	mov	r0, r7
			vListInitialise(&xActiveTimerList2);
    7fc0:	f104 0620 	add.w	r6, r4, #32
			vListInitialise(&xActiveTimerList1);
    7fc4:	47c0      	blx	r8
			vListInitialise(&xActiveTimerList2);
    7fc6:	4630      	mov	r0, r6
    7fc8:	47c0      	blx	r8
			pxCurrentTimerList  = &xActiveTimerList1;
			pxOverflowTimerList = &xActiveTimerList2;
			xTimerQueue         = xQueueCreate((UBaseType_t)configTIMER_QUEUE_LENGTH, sizeof(DaemonTaskMessage_t));
    7fca:	4b0d      	ldr	r3, [pc, #52]	; (8000 <prvCheckForValidListAndQueue+0x58>)
    7fcc:	462a      	mov	r2, r5
    7fce:	210c      	movs	r1, #12
    7fd0:	2002      	movs	r0, #2
			pxOverflowTimerList = &xActiveTimerList2;
    7fd2:	e9c4 6700 	strd	r6, r7, [r4]
			xTimerQueue         = xQueueCreate((UBaseType_t)configTIMER_QUEUE_LENGTH, sizeof(DaemonTaskMessage_t));
    7fd6:	4798      	blx	r3
			configASSERT(xTimerQueue);
    7fd8:	b120      	cbz	r0, 7fe4 <prvCheckForValidListAndQueue+0x3c>
			xTimerQueue         = xQueueCreate((UBaseType_t)configTIMER_QUEUE_LENGTH, sizeof(DaemonTaskMessage_t));
    7fda:	60a0      	str	r0, [r4, #8]
		} else {
			mtCOVERAGE_TEST_MARKER();
		}
	}
	taskEXIT_CRITICAL();
}
    7fdc:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
	taskEXIT_CRITICAL();
    7fe0:	4b08      	ldr	r3, [pc, #32]	; (8004 <prvCheckForValidListAndQueue+0x5c>)
    7fe2:	4718      	bx	r3
    7fe4:	f04f 0380 	mov.w	r3, #128	; 0x80
    7fe8:	f383 8811 	msr	BASEPRI, r3
    7fec:	f3bf 8f6f 	isb	sy
    7ff0:	f3bf 8f4f 	dsb	sy
			configASSERT(xTimerQueue);
    7ff4:	e7fe      	b.n	7ff4 <prvCheckForValidListAndQueue+0x4c>
    7ff6:	bf00      	nop
    7ff8:	200149b0 	.word	0x200149b0
    7ffc:	00009d59 	.word	0x00009d59
    8000:	0000054d 	.word	0x0000054d
    8004:	00009d99 	.word	0x00009d99
    8008:	00001df9 	.word	0x00001df9

0000800c <xTimerCreateTimerTask>:
{
    800c:	b51f      	push	{r0, r1, r2, r3, r4, lr}
	prvCheckForValidListAndQueue();
    800e:	4b0e      	ldr	r3, [pc, #56]	; (8048 <xTimerCreateTimerTask+0x3c>)
    8010:	4798      	blx	r3
	if (xTimerQueue != NULL) {
    8012:	4b0e      	ldr	r3, [pc, #56]	; (804c <xTimerCreateTimerTask+0x40>)
    8014:	689b      	ldr	r3, [r3, #8]
    8016:	b163      	cbz	r3, 8032 <xTimerCreateTimerTask+0x26>
			xReturn = xTaskCreate(prvTimerTask,
    8018:	2300      	movs	r3, #0
    801a:	2202      	movs	r2, #2
    801c:	9200      	str	r2, [sp, #0]
    801e:	e9cd 3302 	strd	r3, r3, [sp, #8]
    8022:	490b      	ldr	r1, [pc, #44]	; (8050 <xTimerCreateTimerTask+0x44>)
    8024:	480b      	ldr	r0, [pc, #44]	; (8054 <xTimerCreateTimerTask+0x48>)
    8026:	4c0c      	ldr	r4, [pc, #48]	; (8058 <xTimerCreateTimerTask+0x4c>)
    8028:	9301      	str	r3, [sp, #4]
    802a:	f44f 7280 	mov.w	r2, #256	; 0x100
    802e:	47a0      	blx	r4
	configASSERT(xReturn);
    8030:	b940      	cbnz	r0, 8044 <xTimerCreateTimerTask+0x38>
    8032:	f04f 0380 	mov.w	r3, #128	; 0x80
    8036:	f383 8811 	msr	BASEPRI, r3
    803a:	f3bf 8f6f 	isb	sy
    803e:	f3bf 8f4f 	dsb	sy
    8042:	e7fe      	b.n	8042 <xTimerCreateTimerTask+0x36>
}
    8044:	b004      	add	sp, #16
    8046:	bd10      	pop	{r4, pc}
    8048:	00007fa9 	.word	0x00007fa9
    804c:	200149b0 	.word	0x200149b0
    8050:	0000cbb3 	.word	0x0000cbb3
    8054:	00008165 	.word	0x00008165
    8058:	00008b49 	.word	0x00008b49

0000805c <xTimerGenericCommand>:
{
    805c:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
    805e:	4616      	mov	r6, r2
	configASSERT(xTimer);
    8060:	4604      	mov	r4, r0
{
    8062:	461a      	mov	r2, r3
	configASSERT(xTimer);
    8064:	b940      	cbnz	r0, 8078 <xTimerGenericCommand+0x1c>
    8066:	f04f 0380 	mov.w	r3, #128	; 0x80
    806a:	f383 8811 	msr	BASEPRI, r3
    806e:	f3bf 8f6f 	isb	sy
    8072:	f3bf 8f4f 	dsb	sy
    8076:	e7fe      	b.n	8076 <xTimerGenericCommand+0x1a>
	if (xTimerQueue != NULL) {
    8078:	4d0d      	ldr	r5, [pc, #52]	; (80b0 <xTimerGenericCommand+0x54>)
    807a:	68a8      	ldr	r0, [r5, #8]
    807c:	b188      	cbz	r0, 80a2 <xTimerGenericCommand+0x46>
		if (xCommandID < tmrFIRST_FROM_ISR_COMMAND) {
    807e:	2905      	cmp	r1, #5
		xMessage.u.xTimerParameters.xMessageValue = xOptionalValue;
    8080:	e9cd 1601 	strd	r1, r6, [sp, #4]
		xMessage.u.xTimerParameters.pxTimer       = (Timer_t *)xTimer;
    8084:	9403      	str	r4, [sp, #12]
		if (xCommandID < tmrFIRST_FROM_ISR_COMMAND) {
    8086:	dc0e      	bgt.n	80a6 <xTimerGenericCommand+0x4a>
			if (xTaskGetSchedulerState() == taskSCHEDULER_RUNNING) {
    8088:	4b0a      	ldr	r3, [pc, #40]	; (80b4 <xTimerGenericCommand+0x58>)
    808a:	4c0b      	ldr	r4, [pc, #44]	; (80b8 <xTimerGenericCommand+0x5c>)
    808c:	4798      	blx	r3
    808e:	2802      	cmp	r0, #2
				xReturn = xQueueSendToBack(xTimerQueue, &xMessage, xTicksToWait);
    8090:	f04f 0300 	mov.w	r3, #0
    8094:	bf08      	it	eq
    8096:	9a08      	ldreq	r2, [sp, #32]
				xReturn = xQueueSendToBack(xTimerQueue, &xMessage, tmrNO_DELAY);
    8098:	68a8      	ldr	r0, [r5, #8]
    809a:	bf18      	it	ne
    809c:	461a      	movne	r2, r3
    809e:	a901      	add	r1, sp, #4
			xReturn = xQueueSendToBackFromISR(xTimerQueue, &xMessage, pxHigherPriorityTaskWoken);
    80a0:	47a0      	blx	r4
}
    80a2:	b004      	add	sp, #16
    80a4:	bd70      	pop	{r4, r5, r6, pc}
			xReturn = xQueueSendToBackFromISR(xTimerQueue, &xMessage, pxHigherPriorityTaskWoken);
    80a6:	4c05      	ldr	r4, [pc, #20]	; (80bc <xTimerGenericCommand+0x60>)
    80a8:	2300      	movs	r3, #0
    80aa:	a901      	add	r1, sp, #4
    80ac:	e7f8      	b.n	80a0 <xTimerGenericCommand+0x44>
    80ae:	bf00      	nop
    80b0:	200149b0 	.word	0x200149b0
    80b4:	000092d9 	.word	0x000092d9
    80b8:	00000611 	.word	0x00000611
    80bc:	000007b1 	.word	0x000007b1

000080c0 <prvSampleTimeNow>:
{
    80c0:	e92d 47ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, lr}
	xTimeNow = xTaskGetTickCount();
    80c4:	4b22      	ldr	r3, [pc, #136]	; (8150 <prvSampleTimeNow+0x90>)
	if (xTimeNow < xLastTime) {
    80c6:	4d23      	ldr	r5, [pc, #140]	; (8154 <prvSampleTimeNow+0x94>)
{
    80c8:	4607      	mov	r7, r0
	xTimeNow = xTaskGetTickCount();
    80ca:	4798      	blx	r3
	if (xTimeNow < xLastTime) {
    80cc:	6b6b      	ldr	r3, [r5, #52]	; 0x34
    80ce:	4283      	cmp	r3, r0
	xTimeNow = xTaskGetTickCount();
    80d0:	4606      	mov	r6, r0
	if (xTimeNow < xLastTime) {
    80d2:	d93a      	bls.n	814a <prvSampleTimeNow+0x8a>
		(void)uxListRemove(&(pxTimer->xTimerListItem));
    80d4:	f8df 8084 	ldr.w	r8, [pc, #132]	; 815c <prvSampleTimeNow+0x9c>
				    = xTimerGenericCommand(pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY);
    80d8:	f8df 9084 	ldr.w	r9, [pc, #132]	; 8160 <prvSampleTimeNow+0xa0>
	while (listLIST_IS_EMPTY(pxCurrentTimerList) == pdFALSE) {
    80dc:	686b      	ldr	r3, [r5, #4]
    80de:	681a      	ldr	r2, [r3, #0]
    80e0:	b94a      	cbnz	r2, 80f6 <prvSampleTimeNow+0x36>
	pxCurrentTimerList  = pxOverflowTimerList;
    80e2:	682a      	ldr	r2, [r5, #0]
	pxOverflowTimerList = pxTemp;
    80e4:	e9c5 3200 	strd	r3, r2, [r5]
		*pxTimerListsWereSwitched = pdTRUE;
    80e8:	2301      	movs	r3, #1
}
    80ea:	4630      	mov	r0, r6
		*pxTimerListsWereSwitched = pdFALSE;
    80ec:	603b      	str	r3, [r7, #0]
	xLastTime = xTimeNow;
    80ee:	636e      	str	r6, [r5, #52]	; 0x34
}
    80f0:	b004      	add	sp, #16
    80f2:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY(pxCurrentTimerList);
    80f6:	68db      	ldr	r3, [r3, #12]
		pxTimer = (Timer_t *)listGET_OWNER_OF_HEAD_ENTRY(pxCurrentTimerList);
    80f8:	68dc      	ldr	r4, [r3, #12]
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY(pxCurrentTimerList);
    80fa:	f8d3 a000 	ldr.w	sl, [r3]
		(void)uxListRemove(&(pxTimer->xTimerListItem));
    80fe:	1d21      	adds	r1, r4, #4
    8100:	4608      	mov	r0, r1
    8102:	9103      	str	r1, [sp, #12]
    8104:	47c0      	blx	r8
		pxTimer->pxCallbackFunction((TimerHandle_t)pxTimer);
    8106:	6a63      	ldr	r3, [r4, #36]	; 0x24
    8108:	4620      	mov	r0, r4
    810a:	4798      	blx	r3
		if (pxTimer->uxAutoReload == (UBaseType_t)pdTRUE) {
    810c:	69e3      	ldr	r3, [r4, #28]
    810e:	9903      	ldr	r1, [sp, #12]
    8110:	2b01      	cmp	r3, #1
    8112:	d1e3      	bne.n	80dc <prvSampleTimeNow+0x1c>
			xReloadTime = (xNextExpireTime + pxTimer->xTimerPeriodInTicks);
    8114:	69a3      	ldr	r3, [r4, #24]
    8116:	4453      	add	r3, sl
			if (xReloadTime > xNextExpireTime) {
    8118:	459a      	cmp	sl, r3
    811a:	d205      	bcs.n	8128 <prvSampleTimeNow+0x68>
				listSET_LIST_ITEM_VALUE(&(pxTimer->xTimerListItem), xReloadTime);
    811c:	6063      	str	r3, [r4, #4]
				vListInsert(pxCurrentTimerList, &(pxTimer->xTimerListItem));
    811e:	6868      	ldr	r0, [r5, #4]
    8120:	4b0d      	ldr	r3, [pc, #52]	; (8158 <prvSampleTimeNow+0x98>)
				listSET_LIST_ITEM_OWNER(&(pxTimer->xTimerListItem), pxTimer);
    8122:	6124      	str	r4, [r4, #16]
				vListInsert(pxCurrentTimerList, &(pxTimer->xTimerListItem));
    8124:	4798      	blx	r3
    8126:	e7d9      	b.n	80dc <prvSampleTimeNow+0x1c>
				    = xTimerGenericCommand(pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY);
    8128:	2300      	movs	r3, #0
    812a:	9300      	str	r3, [sp, #0]
    812c:	4652      	mov	r2, sl
    812e:	4619      	mov	r1, r3
    8130:	4620      	mov	r0, r4
    8132:	47c8      	blx	r9
				configASSERT(xResult);
    8134:	2800      	cmp	r0, #0
    8136:	d1d1      	bne.n	80dc <prvSampleTimeNow+0x1c>
    8138:	f04f 0380 	mov.w	r3, #128	; 0x80
    813c:	f383 8811 	msr	BASEPRI, r3
    8140:	f3bf 8f6f 	isb	sy
    8144:	f3bf 8f4f 	dsb	sy
    8148:	e7fe      	b.n	8148 <prvSampleTimeNow+0x88>
		*pxTimerListsWereSwitched = pdFALSE;
    814a:	2300      	movs	r3, #0
    814c:	e7cd      	b.n	80ea <prvSampleTimeNow+0x2a>
    814e:	bf00      	nop
    8150:	00008d9d 	.word	0x00008d9d
    8154:	200149b0 	.word	0x200149b0
    8158:	00001e2d 	.word	0x00001e2d
    815c:	00001e5b 	.word	0x00001e5b
    8160:	0000805d 	.word	0x0000805d

00008164 <prvTimerTask>:
{
    8164:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	(void)uxListRemove(&(pxTimer->xTimerListItem));
    8168:	f8df a1ac 	ldr.w	sl, [pc, #428]	; 8318 <prvTimerTask+0x1b4>
{
    816c:	b087      	sub	sp, #28
	*pxListWasEmpty = listLIST_IS_EMPTY(pxCurrentTimerList);
    816e:	4f61      	ldr	r7, [pc, #388]	; (82f4 <prvTimerTask+0x190>)
    8170:	687b      	ldr	r3, [r7, #4]
    8172:	f8d3 b000 	ldr.w	fp, [r3]
	if (*pxListWasEmpty == pdFALSE) {
    8176:	f1bb 0f00 	cmp.w	fp, #0
    817a:	d035      	beq.n	81e8 <prvTimerTask+0x84>
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY(pxCurrentTimerList);
    817c:	68db      	ldr	r3, [r3, #12]
    817e:	681e      	ldr	r6, [r3, #0]
	vTaskSuspendAll();
    8180:	4b5d      	ldr	r3, [pc, #372]	; (82f8 <prvTimerTask+0x194>)
		xTimeNow = prvSampleTimeNow(&xTimerListsWereSwitched);
    8182:	4d5e      	ldr	r5, [pc, #376]	; (82fc <prvTimerTask+0x198>)
	vTaskSuspendAll();
    8184:	4798      	blx	r3
		xTimeNow = prvSampleTimeNow(&xTimerListsWereSwitched);
    8186:	a803      	add	r0, sp, #12
    8188:	47a8      	blx	r5
		if (xTimerListsWereSwitched == pdFALSE) {
    818a:	9c03      	ldr	r4, [sp, #12]
    818c:	46a9      	mov	r9, r5
		xTimeNow = prvSampleTimeNow(&xTimerListsWereSwitched);
    818e:	4680      	mov	r8, r0
		if (xTimerListsWereSwitched == pdFALSE) {
    8190:	4d5b      	ldr	r5, [pc, #364]	; (8300 <prvTimerTask+0x19c>)
    8192:	2c00      	cmp	r4, #0
    8194:	d173      	bne.n	827e <prvTimerTask+0x11a>
			if ((xListWasEmpty == pdFALSE) && (xNextExpireTime <= xTimeNow)) {
    8196:	f1bb 0f00 	cmp.w	fp, #0
    819a:	d057      	beq.n	824c <prvTimerTask+0xe8>
    819c:	42b0      	cmp	r0, r6
    819e:	d35a      	bcc.n	8256 <prvTimerTask+0xf2>
				(void)xTaskResumeAll();
    81a0:	47a8      	blx	r5
	Timer_t *const pxTimer = (Timer_t *)listGET_OWNER_OF_HEAD_ENTRY(pxCurrentTimerList);
    81a2:	687b      	ldr	r3, [r7, #4]
    81a4:	68db      	ldr	r3, [r3, #12]
    81a6:	68dd      	ldr	r5, [r3, #12]
	(void)uxListRemove(&(pxTimer->xTimerListItem));
    81a8:	1d28      	adds	r0, r5, #4
    81aa:	47d0      	blx	sl
	if (pxTimer->uxAutoReload == (UBaseType_t)pdTRUE) {
    81ac:	69eb      	ldr	r3, [r5, #28]
    81ae:	2b01      	cmp	r3, #1
    81b0:	d11c      	bne.n	81ec <prvTimerTask+0x88>
		if (prvInsertTimerInActiveList(
    81b2:	69a9      	ldr	r1, [r5, #24]
    81b4:	4642      	mov	r2, r8
    81b6:	4633      	mov	r3, r6
    81b8:	f8df 8154 	ldr.w	r8, [pc, #340]	; 8310 <prvTimerTask+0x1ac>
    81bc:	4431      	add	r1, r6
    81be:	4628      	mov	r0, r5
    81c0:	47c0      	blx	r8
    81c2:	2801      	cmp	r0, #1
    81c4:	d112      	bne.n	81ec <prvTimerTask+0x88>
			xResult = xTimerGenericCommand(pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY);
    81c6:	9400      	str	r4, [sp, #0]
    81c8:	4623      	mov	r3, r4
    81ca:	4621      	mov	r1, r4
    81cc:	4632      	mov	r2, r6
    81ce:	4c4d      	ldr	r4, [pc, #308]	; (8304 <prvTimerTask+0x1a0>)
    81d0:	4628      	mov	r0, r5
    81d2:	47a0      	blx	r4
			configASSERT(xResult);
    81d4:	b950      	cbnz	r0, 81ec <prvTimerTask+0x88>
    81d6:	f04f 0380 	mov.w	r3, #128	; 0x80
    81da:	f383 8811 	msr	BASEPRI, r3
    81de:	f3bf 8f6f 	isb	sy
    81e2:	f3bf 8f4f 	dsb	sy
    81e6:	e7fe      	b.n	81e6 <prvTimerTask+0x82>
		xNextExpireTime = (TickType_t)0U;
    81e8:	465e      	mov	r6, fp
    81ea:	e7c9      	b.n	8180 <prvTimerTask+0x1c>
	pxTimer->pxCallbackFunction((TimerHandle_t)pxTimer);
    81ec:	6a6b      	ldr	r3, [r5, #36]	; 0x24
    81ee:	4628      	mov	r0, r5
    81f0:	4798      	blx	r3
	while (xQueueReceive(xTimerQueue, &xMessage, tmrNO_DELAY)
    81f2:	4d45      	ldr	r5, [pc, #276]	; (8308 <prvTimerTask+0x1a4>)
    81f4:	68b8      	ldr	r0, [r7, #8]
    81f6:	2300      	movs	r3, #0
    81f8:	461a      	mov	r2, r3
    81fa:	a903      	add	r1, sp, #12
    81fc:	47a8      	blx	r5
    81fe:	2800      	cmp	r0, #0
    8200:	d0b5      	beq.n	816e <prvTimerTask+0xa>
		if (xMessage.xMessageID >= (BaseType_t)0) {
    8202:	9b03      	ldr	r3, [sp, #12]
    8204:	2b00      	cmp	r3, #0
    8206:	dbf5      	blt.n	81f4 <prvTimerTask+0x90>
			pxTimer = xMessage.u.xTimerParameters.pxTimer;
    8208:	9c05      	ldr	r4, [sp, #20]
			if (listIS_CONTAINED_WITHIN(NULL, &(pxTimer->xTimerListItem)) == pdFALSE) {
    820a:	6963      	ldr	r3, [r4, #20]
    820c:	b10b      	cbz	r3, 8212 <prvTimerTask+0xae>
				(void)uxListRemove(&(pxTimer->xTimerListItem));
    820e:	1d20      	adds	r0, r4, #4
    8210:	47d0      	blx	sl
			xTimeNow = prvSampleTimeNow(&xTimerListsWereSwitched);
    8212:	a802      	add	r0, sp, #8
    8214:	47c8      	blx	r9
			switch (xMessage.xMessageID) {
    8216:	9b03      	ldr	r3, [sp, #12]
			xTimeNow = prvSampleTimeNow(&xTimerListsWereSwitched);
    8218:	4602      	mov	r2, r0
			switch (xMessage.xMessageID) {
    821a:	2b09      	cmp	r3, #9
    821c:	d8ea      	bhi.n	81f4 <prvTimerTask+0x90>
    821e:	a101      	add	r1, pc, #4	; (adr r1, 8224 <prvTimerTask+0xc0>)
    8220:	f851 f023 	ldr.w	pc, [r1, r3, lsl #2]
    8224:	00008283 	.word	0x00008283
    8228:	00008283 	.word	0x00008283
    822c:	00008283 	.word	0x00008283
    8230:	000081f5 	.word	0x000081f5
    8234:	000082c7 	.word	0x000082c7
    8238:	000082eb 	.word	0x000082eb
    823c:	00008283 	.word	0x00008283
    8240:	00008283 	.word	0x00008283
    8244:	000081f5 	.word	0x000081f5
    8248:	000082c7 	.word	0x000082c7
					xListWasEmpty = listLIST_IS_EMPTY(pxOverflowTimerList);
    824c:	683b      	ldr	r3, [r7, #0]
    824e:	681c      	ldr	r4, [r3, #0]
    8250:	fab4 f484 	clz	r4, r4
    8254:	0964      	lsrs	r4, r4, #5
				vQueueWaitForMessageRestricted(xTimerQueue, (xNextExpireTime - xTimeNow), xListWasEmpty);
    8256:	68b8      	ldr	r0, [r7, #8]
    8258:	4b2c      	ldr	r3, [pc, #176]	; (830c <prvTimerTask+0x1a8>)
    825a:	4622      	mov	r2, r4
    825c:	eba6 0108 	sub.w	r1, r6, r8
    8260:	4798      	blx	r3
				if (xTaskResumeAll() == pdFALSE) {
    8262:	47a8      	blx	r5
    8264:	2800      	cmp	r0, #0
    8266:	d1c4      	bne.n	81f2 <prvTimerTask+0x8e>
					portYIELD_WITHIN_API();
    8268:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
    826c:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
    8270:	f8c3 2d04 	str.w	r2, [r3, #3332]	; 0xd04
    8274:	f3bf 8f4f 	dsb	sy
    8278:	f3bf 8f6f 	isb	sy
    827c:	e7b9      	b.n	81f2 <prvTimerTask+0x8e>
			(void)xTaskResumeAll();
    827e:	47a8      	blx	r5
    8280:	e7b7      	b.n	81f2 <prvTimerTask+0x8e>
				if (prvInsertTimerInActiveList(pxTimer,
    8282:	69a1      	ldr	r1, [r4, #24]
    8284:	9b04      	ldr	r3, [sp, #16]
    8286:	4e22      	ldr	r6, [pc, #136]	; (8310 <prvTimerTask+0x1ac>)
    8288:	4419      	add	r1, r3
    828a:	4620      	mov	r0, r4
    828c:	47b0      	blx	r6
    828e:	2801      	cmp	r0, #1
    8290:	d1b0      	bne.n	81f4 <prvTimerTask+0x90>
					pxTimer->pxCallbackFunction((TimerHandle_t)pxTimer);
    8292:	6a63      	ldr	r3, [r4, #36]	; 0x24
    8294:	4620      	mov	r0, r4
    8296:	4798      	blx	r3
					if (pxTimer->uxAutoReload == (UBaseType_t)pdTRUE) {
    8298:	69e3      	ldr	r3, [r4, #28]
    829a:	2b01      	cmp	r3, #1
    829c:	d1aa      	bne.n	81f4 <prvTimerTask+0x90>
						xResult = xTimerGenericCommand(pxTimer,
    829e:	69a2      	ldr	r2, [r4, #24]
    82a0:	9904      	ldr	r1, [sp, #16]
    82a2:	2300      	movs	r3, #0
    82a4:	440a      	add	r2, r1
    82a6:	4620      	mov	r0, r4
    82a8:	9300      	str	r3, [sp, #0]
    82aa:	4c16      	ldr	r4, [pc, #88]	; (8304 <prvTimerTask+0x1a0>)
    82ac:	4619      	mov	r1, r3
    82ae:	47a0      	blx	r4
						configASSERT(xResult);
    82b0:	2800      	cmp	r0, #0
    82b2:	d19f      	bne.n	81f4 <prvTimerTask+0x90>
    82b4:	f04f 0380 	mov.w	r3, #128	; 0x80
    82b8:	f383 8811 	msr	BASEPRI, r3
    82bc:	f3bf 8f6f 	isb	sy
    82c0:	f3bf 8f4f 	dsb	sy
    82c4:	e7fe      	b.n	82c4 <prvTimerTask+0x160>
				pxTimer->xTimerPeriodInTicks = xMessage.u.xTimerParameters.xMessageValue;
    82c6:	9904      	ldr	r1, [sp, #16]
    82c8:	61a1      	str	r1, [r4, #24]
				configASSERT((pxTimer->xTimerPeriodInTicks > 0));
    82ca:	b941      	cbnz	r1, 82de <prvTimerTask+0x17a>
    82cc:	f04f 0380 	mov.w	r3, #128	; 0x80
    82d0:	f383 8811 	msr	BASEPRI, r3
    82d4:	f3bf 8f6f 	isb	sy
    82d8:	f3bf 8f4f 	dsb	sy
    82dc:	e7fe      	b.n	82dc <prvTimerTask+0x178>
				(void)prvInsertTimerInActiveList(
    82de:	4603      	mov	r3, r0
    82e0:	4401      	add	r1, r0
    82e2:	4620      	mov	r0, r4
    82e4:	4c0a      	ldr	r4, [pc, #40]	; (8310 <prvTimerTask+0x1ac>)
    82e6:	47a0      	blx	r4
				break;
    82e8:	e784      	b.n	81f4 <prvTimerTask+0x90>
				vPortFree(pxTimer);
    82ea:	4b0a      	ldr	r3, [pc, #40]	; (8314 <prvTimerTask+0x1b0>)
    82ec:	4620      	mov	r0, r4
    82ee:	4798      	blx	r3
				break;
    82f0:	e780      	b.n	81f4 <prvTimerTask+0x90>
    82f2:	bf00      	nop
    82f4:	200149b0 	.word	0x200149b0
    82f8:	00008d89 	.word	0x00008d89
    82fc:	000080c1 	.word	0x000080c1
    8300:	00008e9d 	.word	0x00008e9d
    8304:	0000805d 	.word	0x0000805d
    8308:	00000951 	.word	0x00000951
    830c:	00000b01 	.word	0x00000b01
    8310:	00007f6d 	.word	0x00007f6d
    8314:	00001db1 	.word	0x00001db1
    8318:	00001e5b 	.word	0x00001e5b

0000831c <lwip_standard_chksum>:
 * @param len length of data to be summed
 * @return host order (!) lwip checksum (non-inverted Internet sum)
 */

static u16_t lwip_standard_chksum(void *dataptr, int len)
{
    831c:	b573      	push	{r0, r1, r4, r5, r6, lr}
	u8_t * pb = (u8_t *)dataptr;
	u16_t *ps, t = 0;
    831e:	2300      	movs	r3, #0
	u32_t  sum = 0;
	int    odd = ((mem_ptr_t)pb & 1);

	/* Get aligned to u16_t */
	if (odd && len > 0) {
    8320:	f010 0401 	ands.w	r4, r0, #1
	u16_t *ps, t = 0;
    8324:	f8ad 3006 	strh.w	r3, [sp, #6]
	if (odd && len > 0) {
    8328:	d005      	beq.n	8336 <lwip_standard_chksum+0x1a>
    832a:	b351      	cbz	r1, 8382 <lwip_standard_chksum+0x66>
		((u8_t *)&t)[1] = *pb++;
    832c:	f810 3b01 	ldrb.w	r3, [r0], #1
    8330:	f88d 3007 	strb.w	r3, [sp, #7]
		len--;
    8334:	3901      	subs	r1, #1
	}

	/* Add the bulk of the data */
	ps = (u16_t *)(void *)pb;
	while (len > 1) {
    8336:	f021 0301 	bic.w	r3, r1, #1
    833a:	084d      	lsrs	r5, r1, #1
    833c:	4403      	add	r3, r0
	u32_t  sum = 0;
    833e:	2200      	movs	r2, #0
	while (len > 1) {
    8340:	4298      	cmp	r0, r3
    8342:	d11a      	bne.n	837a <lwip_standard_chksum+0x5e>
		sum += *ps++;
		len -= 2;
	}

	/* Consume left-over byte, if any */
	if (len > 0) {
    8344:	f06f 0301 	mvn.w	r3, #1
    8348:	fb03 1105 	mla	r1, r3, r5, r1
    834c:	2901      	cmp	r1, #1
    834e:	d102      	bne.n	8356 <lwip_standard_chksum+0x3a>
		((u8_t *)&t)[0] = *(u8_t *)ps;
    8350:	7803      	ldrb	r3, [r0, #0]
    8352:	f88d 3006 	strb.w	r3, [sp, #6]
	}

	/* Add end bytes */
	sum += t;
    8356:	f8bd 3006 	ldrh.w	r3, [sp, #6]
    835a:	4413      	add	r3, r2

	/* Fold 32-bit sum to 16 bits
	   calling this twice is propably faster than if statements... */
	sum = FOLD_U32T(sum);
    835c:	b298      	uxth	r0, r3
    835e:	eb00 4313 	add.w	r3, r0, r3, lsr #16
	sum = FOLD_U32T(sum);
    8362:	b298      	uxth	r0, r3
    8364:	eb00 4013 	add.w	r0, r0, r3, lsr #16

	/* Swap if alignment was odd */
	if (odd) {
    8368:	b124      	cbz	r4, 8374 <lwip_standard_chksum+0x58>
		sum = SWAP_BYTES_IN_WORD(sum);
    836a:	0203      	lsls	r3, r0, #8
    836c:	b29b      	uxth	r3, r3
    836e:	f3c0 2007 	ubfx	r0, r0, #8, #8
    8372:	4318      	orrs	r0, r3
	}

	return (u16_t)sum;
}
    8374:	b280      	uxth	r0, r0
    8376:	b002      	add	sp, #8
    8378:	bd70      	pop	{r4, r5, r6, pc}
		sum += *ps++;
    837a:	f830 6b02 	ldrh.w	r6, [r0], #2
    837e:	4432      	add	r2, r6
		len -= 2;
    8380:	e7de      	b.n	8340 <lwip_standard_chksum+0x24>
	u32_t  sum = 0;
    8382:	460a      	mov	r2, r1
    8384:	e7e7      	b.n	8356 <lwip_standard_chksum+0x3a>
	...

00008388 <inet_chksum_pseudo>:
 * @param proto ip protocol (used for checksum of pseudo header)
 * @param proto_len length of the ip data part (used for checksum of pseudo header)
 * @return checksum (as u16_t) to be saved directly in the protocol header
 */
u16_t inet_chksum_pseudo(struct pbuf *p, ip_addr_t *src, ip_addr_t *dest, u8_t proto, u16_t proto_len)
{
    8388:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	u32_t        addr;
	struct pbuf *q;
	u8_t         swapped;

	acc     = 0;
	swapped = 0;
    838c:	2600      	movs	r6, #0
	/* iterate through all pbuf in chain */
	for (q = p; q != NULL; q = q->next) {
		LWIP_DEBUGF(INET_DEBUG,
		            ("inet_chksum_pseudo(): checksumming pbuf %p (has next %p) \n", (void *)q, (void *)q->next));
		acc += LWIP_CHKSUM(q->payload, q->len);
    838e:	f8df a084 	ldr.w	sl, [pc, #132]	; 8414 <inet_chksum_pseudo+0x8c>
{
    8392:	4605      	mov	r5, r0
    8394:	4689      	mov	r9, r1
    8396:	4690      	mov	r8, r2
    8398:	461f      	mov	r7, r3
	acc     = 0;
    839a:	4634      	mov	r4, r6
	for (q = p; q != NULL; q = q->next) {
    839c:	bb1d      	cbnz	r5, 83e6 <inet_chksum_pseudo+0x5e>
			acc     = SWAP_BYTES_IN_WORD(acc);
		}
		/*LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): wrapped lwip_chksum()=%"X32_F" \n", acc));*/
	}

	if (swapped) {
    839e:	b126      	cbz	r6, 83aa <inet_chksum_pseudo+0x22>
		acc = SWAP_BYTES_IN_WORD(acc);
    83a0:	0223      	lsls	r3, r4, #8
    83a2:	b29b      	uxth	r3, r3
    83a4:	f3c4 2407 	ubfx	r4, r4, #8, #8
    83a8:	431c      	orrs	r4, r3
	}
	addr = ip4_addr_get_u32(src);
	acc += (addr & 0xffffUL);
	acc += ((addr >> 16) & 0xffffUL);
	addr = ip4_addr_get_u32(dest);
    83aa:	f8d8 2000 	ldr.w	r2, [r8]
	addr = ip4_addr_get_u32(src);
    83ae:	f8d9 3000 	ldr.w	r3, [r9]
	acc += (addr & 0xffffUL);
	acc += ((addr >> 16) & 0xffffUL);
	acc += (u32_t)htons((u16_t)proto);
    83b2:	4d17      	ldr	r5, [pc, #92]	; (8410 <inet_chksum_pseudo+0x88>)
	acc += ((addr >> 16) & 0xffffUL);
    83b4:	0c11      	lsrs	r1, r2, #16
    83b6:	fa11 f282 	uxtah	r2, r1, r2
    83ba:	fa12 f283 	uxtah	r2, r2, r3
    83be:	eb02 4213 	add.w	r2, r2, r3, lsr #16
	acc += (u32_t)htons((u16_t)proto);
    83c2:	4638      	mov	r0, r7
	acc += ((addr >> 16) & 0xffffUL);
    83c4:	4414      	add	r4, r2
	acc += (u32_t)htons((u16_t)proto);
    83c6:	47a8      	blx	r5
    83c8:	4404      	add	r4, r0
	acc += (u32_t)htons(proto_len);
    83ca:	f8bd 0020 	ldrh.w	r0, [sp, #32]
    83ce:	47a8      	blx	r5
    83d0:	4420      	add	r0, r4

	/* Fold 32-bit sum to 16 bits
	   calling this twice is propably faster than if statements... */
	acc = FOLD_U32T(acc);
    83d2:	b284      	uxth	r4, r0
    83d4:	eb04 4410 	add.w	r4, r4, r0, lsr #16
	acc = FOLD_U32T(acc);
    83d8:	b2a0      	uxth	r0, r4
    83da:	eb00 4014 	add.w	r0, r0, r4, lsr #16
	LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): pbuf chain lwip_chksum()=%" X32_F "\n", acc));
	return (u16_t) ~(acc & 0xffffUL);
    83de:	43c0      	mvns	r0, r0
}
    83e0:	b280      	uxth	r0, r0
    83e2:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
		acc += LWIP_CHKSUM(q->payload, q->len);
    83e6:	8969      	ldrh	r1, [r5, #10]
    83e8:	6868      	ldr	r0, [r5, #4]
    83ea:	47d0      	blx	sl
    83ec:	4404      	add	r4, r0
		acc = FOLD_U32T(acc);
    83ee:	b2a3      	uxth	r3, r4
    83f0:	eb03 4414 	add.w	r4, r3, r4, lsr #16
		if (q->len % 2 != 0) {
    83f4:	896b      	ldrh	r3, [r5, #10]
    83f6:	07db      	lsls	r3, r3, #31
    83f8:	d507      	bpl.n	840a <inet_chksum_pseudo+0x82>
			acc     = SWAP_BYTES_IN_WORD(acc);
    83fa:	0223      	lsls	r3, r4, #8
			swapped = 1 - swapped;
    83fc:	f1c6 0601 	rsb	r6, r6, #1
			acc     = SWAP_BYTES_IN_WORD(acc);
    8400:	b29b      	uxth	r3, r3
    8402:	f3c4 2407 	ubfx	r4, r4, #8, #8
			swapped = 1 - swapped;
    8406:	b2f6      	uxtb	r6, r6
			acc     = SWAP_BYTES_IN_WORD(acc);
    8408:	431c      	orrs	r4, r3
	for (q = p; q != NULL; q = q->next) {
    840a:	682d      	ldr	r5, [r5, #0]
    840c:	e7c6      	b.n	839c <inet_chksum_pseudo+0x14>
    840e:	bf00      	nop
    8410:	00000d61 	.word	0x00000d61
    8414:	0000831d 	.word	0x0000831d

00008418 <inet_chksum>:
 * @param len length of the buffer to calculate the checksum
 * @return checksum (as u16_t) to be saved directly in the protocol header
 */

u16_t inet_chksum(void *dataptr, u16_t len)
{
    8418:	b508      	push	{r3, lr}
	return ~LWIP_CHKSUM(dataptr, len);
    841a:	4b02      	ldr	r3, [pc, #8]	; (8424 <inet_chksum+0xc>)
    841c:	4798      	blx	r3
    841e:	43c0      	mvns	r0, r0
}
    8420:	b280      	uxth	r0, r0
    8422:	bd08      	pop	{r3, pc}
    8424:	0000831d 	.word	0x0000831d

00008428 <inet_chksum_pbuf>:
 *
 * @param p pbuf chain over that the checksum should be calculated
 * @return checksum (as u16_t) to be saved directly in the protocol header
 */
u16_t inet_chksum_pbuf(struct pbuf *p)
{
    8428:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	u32_t        acc;
	struct pbuf *q;
	u8_t         swapped;

	acc     = 0;
	swapped = 0;
    842a:	2500      	movs	r5, #0
	for (q = p; q != NULL; q = q->next) {
		acc += LWIP_CHKSUM(q->payload, q->len);
    842c:	4f10      	ldr	r7, [pc, #64]	; (8470 <inet_chksum_pbuf+0x48>)
{
    842e:	4606      	mov	r6, r0
	acc     = 0;
    8430:	462c      	mov	r4, r5
	for (q = p; q != NULL; q = q->next) {
    8432:	b946      	cbnz	r6, 8446 <inet_chksum_pbuf+0x1e>
			swapped = 1 - swapped;
			acc     = SWAP_BYTES_IN_WORD(acc);
		}
	}

	if (swapped) {
    8434:	b125      	cbz	r5, 8440 <inet_chksum_pbuf+0x18>
		acc = SWAP_BYTES_IN_WORD(acc);
    8436:	0223      	lsls	r3, r4, #8
    8438:	b29b      	uxth	r3, r3
    843a:	f3c4 2407 	ubfx	r4, r4, #8, #8
    843e:	431c      	orrs	r4, r3
	}
	return (u16_t) ~(acc & 0xffffUL);
    8440:	43e0      	mvns	r0, r4
}
    8442:	b280      	uxth	r0, r0
    8444:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		acc += LWIP_CHKSUM(q->payload, q->len);
    8446:	8971      	ldrh	r1, [r6, #10]
    8448:	6870      	ldr	r0, [r6, #4]
    844a:	47b8      	blx	r7
		if (q->len % 2 != 0) {
    844c:	8973      	ldrh	r3, [r6, #10]
		acc += LWIP_CHKSUM(q->payload, q->len);
    844e:	4404      	add	r4, r0
		acc = FOLD_U32T(acc);
    8450:	b2a0      	uxth	r0, r4
		if (q->len % 2 != 0) {
    8452:	07db      	lsls	r3, r3, #31
		acc = FOLD_U32T(acc);
    8454:	eb00 4414 	add.w	r4, r0, r4, lsr #16
		if (q->len % 2 != 0) {
    8458:	d507      	bpl.n	846a <inet_chksum_pbuf+0x42>
			acc     = SWAP_BYTES_IN_WORD(acc);
    845a:	0223      	lsls	r3, r4, #8
			swapped = 1 - swapped;
    845c:	f1c5 0501 	rsb	r5, r5, #1
			acc     = SWAP_BYTES_IN_WORD(acc);
    8460:	b29b      	uxth	r3, r3
    8462:	f3c4 2407 	ubfx	r4, r4, #8, #8
			swapped = 1 - swapped;
    8466:	b2ed      	uxtb	r5, r5
			acc     = SWAP_BYTES_IN_WORD(acc);
    8468:	431c      	orrs	r4, r3
	for (q = p; q != NULL; q = q->next) {
    846a:	6836      	ldr	r6, [r6, #0]
    846c:	e7e1      	b.n	8432 <inet_chksum_pbuf+0xa>
    846e:	bf00      	nop
    8470:	0000831d 	.word	0x0000831d

00008474 <socket_basic_ethernet>:
	/* Start FreeRTOS scheduler */
	vTaskStartScheduler();
}

void socket_basic_ethernet(void *p)
{
    8474:	b5f0      	push	{r4, r5, r6, r7, lr}
    8476:	b08b      	sub	sp, #44	; 0x2c

	struct sockaddr_in address;
	int                s_create, new_socket;
	int                addrlen = sizeof(address);
	int                opt     = 1;
    8478:	2510      	movs	r5, #16
    847a:	2601      	movs	r6, #1
	int                socket_check;

	sys_sem_t sem;
	err_t     err_sem;
	err_sem = sys_sem_new(&sem, 0); /* Create a new semaphore. */
    847c:	4b2e      	ldr	r3, [pc, #184]	; (8538 <socket_basic_ethernet+0xc4>)
	print_ipaddress();

	/*Create a socket*/
	s_create = socket(AF_INET, 1, 0);

	setsockopt(s_create, SOL_SOCKET, SO_REUSEADDR | SO_REUSEPORT, &opt, sizeof(opt));
    847e:	4f2f      	ldr	r7, [pc, #188]	; (853c <socket_basic_ethernet+0xc8>)
	err_sem = sys_sem_new(&sem, 0); /* Create a new semaphore. */
    8480:	2100      	movs	r1, #0
    8482:	a805      	add	r0, sp, #20
	int                opt     = 1;
    8484:	e9cd 5603 	strd	r5, r6, [sp, #12]
	err_sem = sys_sem_new(&sem, 0); /* Create a new semaphore. */
    8488:	4798      	blx	r3
	tcpip_init(tcpip_init_done, &sem);
    848a:	482d      	ldr	r0, [pc, #180]	; (8540 <socket_basic_ethernet+0xcc>)
    848c:	4b2d      	ldr	r3, [pc, #180]	; (8544 <socket_basic_ethernet+0xd0>)
    848e:	a905      	add	r1, sp, #20
    8490:	4798      	blx	r3
	sys_sem_wait(&sem); /* Block until the lwIP stack is initialized. */
    8492:	2100      	movs	r1, #0
    8494:	4b2c      	ldr	r3, [pc, #176]	; (8548 <socket_basic_ethernet+0xd4>)
    8496:	a805      	add	r0, sp, #20
    8498:	4798      	blx	r3
	sys_sem_free(&sem); /* Free the semaphore. */
    849a:	a805      	add	r0, sp, #20
    849c:	4b2b      	ldr	r3, [pc, #172]	; (854c <socket_basic_ethernet+0xd8>)
    849e:	4798      	blx	r3
	print_ipaddress();
    84a0:	4b2b      	ldr	r3, [pc, #172]	; (8550 <socket_basic_ethernet+0xdc>)
    84a2:	4798      	blx	r3
	s_create = socket(AF_INET, 1, 0);
    84a4:	4631      	mov	r1, r6
    84a6:	4b2b      	ldr	r3, [pc, #172]	; (8554 <socket_basic_ethernet+0xe0>)
    84a8:	2200      	movs	r2, #0
    84aa:	2002      	movs	r0, #2
    84ac:	4798      	blx	r3
	setsockopt(s_create, SOL_SOCKET, SO_REUSEADDR | SO_REUSEPORT, &opt, sizeof(opt));
    84ae:	2304      	movs	r3, #4
    84b0:	f44f 7201 	mov.w	r2, #516	; 0x204
    84b4:	f640 71ff 	movw	r1, #4095	; 0xfff
    84b8:	9300      	str	r3, [sp, #0]
    84ba:	eb0d 0305 	add.w	r3, sp, r5
	s_create = socket(AF_INET, 1, 0);
    84be:	4606      	mov	r6, r0
	setsockopt(s_create, SOL_SOCKET, SO_REUSEADDR | SO_REUSEPORT, &opt, sizeof(opt));
    84c0:	47b8      	blx	r7

	address.sin_family      = AF_INET;
    84c2:	2302      	movs	r3, #2
    84c4:	f88d 3019 	strb.w	r3, [sp, #25]
	address.sin_addr.s_addr = htonl(IPADDR_ANY);
    84c8:	2000      	movs	r0, #0
    84ca:	4b23      	ldr	r3, [pc, #140]	; (8558 <socket_basic_ethernet+0xe4>)
    84cc:	4798      	blx	r3
	address.sin_port        = htons(HTTP_PORT);
    84ce:	4b23      	ldr	r3, [pc, #140]	; (855c <socket_basic_ethernet+0xe8>)
	address.sin_addr.s_addr = htonl(IPADDR_ANY);
    84d0:	9007      	str	r0, [sp, #28]
	address.sin_port        = htons(HTTP_PORT);
    84d2:	2050      	movs	r0, #80	; 0x50
    84d4:	4798      	blx	r3
	/* bind the connection to port */
	socket_check = bind(s_create, (struct sockaddr *)&address, sizeof(address));
    84d6:	4b22      	ldr	r3, [pc, #136]	; (8560 <socket_basic_ethernet+0xec>)
	address.sin_port        = htons(HTTP_PORT);
    84d8:	f8ad 001a 	strh.w	r0, [sp, #26]
	socket_check = bind(s_create, (struct sockaddr *)&address, sizeof(address));
    84dc:	462a      	mov	r2, r5
    84de:	a906      	add	r1, sp, #24
    84e0:	4630      	mov	r0, r6
    84e2:	4798      	blx	r3
	if (socket_check < 0) {
    84e4:	2800      	cmp	r0, #0
    84e6:	db22      	blt.n	852e <socket_basic_ethernet+0xba>
		LWIP_DEBUGF(LWIP_DBG_ON, ("Bind error=%d\n", socket_check));
		goto socket_close;
	}
	/* tell the connection to listen for incoming connection requests */
	listen(s_create, 3);
    84e8:	4b1e      	ldr	r3, [pc, #120]	; (8564 <socket_basic_ethernet+0xf0>)
    84ea:	2103      	movs	r1, #3
    84ec:	4630      	mov	r0, r6
    84ee:	4798      	blx	r3

	for (;;) {
		new_socket = accept(s_create, (struct sockaddr *)&address, (socklen_t *)&addrlen);
    84f0:	4b1d      	ldr	r3, [pc, #116]	; (8568 <socket_basic_ethernet+0xf4>)
    84f2:	aa03      	add	r2, sp, #12
    84f4:	a906      	add	r1, sp, #24
    84f6:	4630      	mov	r0, r6
    84f8:	4798      	blx	r3

		if (new_socket <= 0) {
    84fa:	1e04      	subs	r4, r0, #0
    84fc:	dd17      	ble.n	852e <socket_basic_ethernet+0xba>
			LWIP_DEBUGF(LWIP_DBG_ON, ("Connection error=%d\n", new_socket));
			goto socket_close;
		}
		socket_check = read(new_socket, buffer, 1024);
    84fe:	491b      	ldr	r1, [pc, #108]	; (856c <socket_basic_ethernet+0xf8>)
    8500:	4b1b      	ldr	r3, [pc, #108]	; (8570 <socket_basic_ethernet+0xfc>)
    8502:	f44f 6280 	mov.w	r2, #1024	; 0x400
    8506:	4798      	blx	r3
		if (socket_check <= 0) {
    8508:	2800      	cmp	r0, #0
    850a:	dd10      	ble.n	852e <socket_basic_ethernet+0xba>
			LWIP_DEBUGF(LWIP_DBG_ON, ("Read error=%d\n", socket_check));
			goto socket_close;
		}
		/* Check if the request was an HTTP "GET /\r\n". */
		if (!strncmp(buffer, "GET", 3)) {
    850c:	4919      	ldr	r1, [pc, #100]	; (8574 <socket_basic_ethernet+0x100>)
    850e:	4817      	ldr	r0, [pc, #92]	; (856c <socket_basic_ethernet+0xf8>)
    8510:	4b19      	ldr	r3, [pc, #100]	; (8578 <socket_basic_ethernet+0x104>)
    8512:	2203      	movs	r2, #3
    8514:	4798      	blx	r3
    8516:	b950      	cbnz	r0, 852e <socket_basic_ethernet+0xba>
			socket_check = write(new_socket, http_html_hdr, strlen(http_html_hdr));
    8518:	4918      	ldr	r1, [pc, #96]	; (857c <socket_basic_ethernet+0x108>)
    851a:	4d19      	ldr	r5, [pc, #100]	; (8580 <socket_basic_ethernet+0x10c>)
    851c:	222c      	movs	r2, #44	; 0x2c
    851e:	4620      	mov	r0, r4
    8520:	47a8      	blx	r5
			if (socket_check <= 0) {
    8522:	2800      	cmp	r0, #0
    8524:	dd03      	ble.n	852e <socket_basic_ethernet+0xba>
				LWIP_DEBUGF(LWIP_DBG_ON, ("Write error=%d\n", socket_check));
				goto socket_close;
			}

			/*Send the actual webpage*/
			socket_check = write(new_socket, socket_webpage, strlen(socket_webpage));
    8526:	4917      	ldr	r1, [pc, #92]	; (8584 <socket_basic_ethernet+0x110>)
    8528:	2277      	movs	r2, #119	; 0x77
    852a:	4620      	mov	r0, r4
    852c:	47a8      	blx	r5
				goto socket_close;
			}
		}
	/*Close connection*/
	socket_close:
		close(new_socket);
    852e:	4b16      	ldr	r3, [pc, #88]	; (8588 <socket_basic_ethernet+0x114>)
    8530:	4620      	mov	r0, r4
    8532:	4798      	blx	r3
		new_socket = accept(s_create, (struct sockaddr *)&address, (socklen_t *)&addrlen);
    8534:	e7dc      	b.n	84f0 <socket_basic_ethernet+0x7c>
    8536:	bf00      	nop
    8538:	000079ad 	.word	0x000079ad
    853c:	00009bd9 	.word	0x00009bd9
    8540:	00007df9 	.word	0x00007df9
    8544:	0000a29d 	.word	0x0000a29d
    8548:	00007a3d 	.word	0x00007a3d
    854c:	00007a0d 	.word	0x00007a0d
    8550:	00004b2d 	.word	0x00004b2d
    8554:	00009b49 	.word	0x00009b49
    8558:	00000d6d 	.word	0x00000d6d
    855c:	00000d61 	.word	0x00000d61
    8560:	00009711 	.word	0x00009711
    8564:	000097cd 	.word	0x000097cd
    8568:	00009601 	.word	0x00009601
    856c:	200149e8 	.word	0x200149e8
    8570:	000099f1 	.word	0x000099f1
    8574:	0000cbbb 	.word	0x0000cbbb
    8578:	0000c245 	.word	0x0000c245
    857c:	0000cbce 	.word	0x0000cbce
    8580:	00009bc5 	.word	0x00009bc5
    8584:	0000cbfb 	.word	0x0000cbfb
    8588:	00009771 	.word	0x00009771

0000858c <basic_socket>:
{
    858c:	b51f      	push	{r0, r1, r2, r3, r4, lr}
	task_led_create();
    858e:	4b0b      	ldr	r3, [pc, #44]	; (85bc <basic_socket+0x30>)
	if (xTaskCreate(socket_basic_ethernet,
    8590:	4c0b      	ldr	r4, [pc, #44]	; (85c0 <basic_socket+0x34>)
	task_led_create();
    8592:	4798      	blx	r3
	if (xTaskCreate(socket_basic_ethernet,
    8594:	4a0b      	ldr	r2, [pc, #44]	; (85c4 <basic_socket+0x38>)
    8596:	9201      	str	r2, [sp, #4]
    8598:	2300      	movs	r3, #0
    859a:	2201      	movs	r2, #1
    859c:	9200      	str	r2, [sp, #0]
    859e:	e9cd 3302 	strd	r3, r3, [sp, #8]
    85a2:	4909      	ldr	r1, [pc, #36]	; (85c8 <basic_socket+0x3c>)
    85a4:	4809      	ldr	r0, [pc, #36]	; (85cc <basic_socket+0x40>)
    85a6:	f44f 7280 	mov.w	r2, #256	; 0x100
    85aa:	47a0      	blx	r4
    85ac:	2801      	cmp	r0, #1
    85ae:	d000      	beq.n	85b2 <basic_socket+0x26>
		while (1)
    85b0:	e7fe      	b.n	85b0 <basic_socket+0x24>
	vTaskStartScheduler();
    85b2:	4b07      	ldr	r3, [pc, #28]	; (85d0 <basic_socket+0x44>)
}
    85b4:	b004      	add	sp, #16
    85b6:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	vTaskStartScheduler();
    85ba:	4718      	bx	r3
    85bc:	00007ef1 	.word	0x00007ef1
    85c0:	00008b49 	.word	0x00008b49
    85c4:	20014de8 	.word	0x20014de8
    85c8:	0000cbbf 	.word	0x0000cbbf
    85cc:	00008475 	.word	0x00008475
    85d0:	00008d09 	.word	0x00008d09

000085d4 <GMAC_Handler>:

/*
 * \internal GMAC interrupt handler
 */
void GMAC_Handler(void)
{
    85d4:	b513      	push	{r0, r1, r4, lr}
	volatile uint32_t tsr;
	volatile uint32_t rsr;

	tsr = hri_gmac_read_TSR_reg(_gmac_dev->hw);
    85d6:	4c11      	ldr	r4, [pc, #68]	; (861c <GMAC_Handler+0x48>)
    85d8:	6820      	ldr	r0, [r4, #0]
    85da:	6803      	ldr	r3, [r0, #0]
	GMAC_CRITICAL_SECTION_LEAVE();
}

static inline hri_gmac_tsr_reg_t hri_gmac_read_TSR_reg(const void *const hw)
{
	return ((Gmac *)hw)->TSR.reg;
    85dc:	695a      	ldr	r2, [r3, #20]
    85de:	9200      	str	r2, [sp, #0]
	GMAC_CRITICAL_SECTION_LEAVE();
}

static inline hri_gmac_rsr_reg_t hri_gmac_read_RSR_reg(const void *const hw)
{
	return ((Gmac *)hw)->RSR.reg;
    85e0:	6a1a      	ldr	r2, [r3, #32]
	rsr = hri_gmac_read_RSR_reg(_gmac_dev->hw);
    85e2:	9201      	str	r2, [sp, #4]
	GMAC_CRITICAL_SECTION_LEAVE();
}

static inline hri_gmac_isr_reg_t hri_gmac_read_ISR_reg(const void *const hw)
{
	return ((Gmac *)hw)->ISR.reg;
    85e4:	6a5a      	ldr	r2, [r3, #36]	; 0x24
	/* Must be Clear ISR (Clear on read) */
	hri_gmac_read_ISR_reg(_gmac_dev->hw);

	/* Frame transmited */
	if (tsr & GMAC_TSR_TXCOMP) {
    85e6:	9a00      	ldr	r2, [sp, #0]
    85e8:	0692      	lsls	r2, r2, #26
    85ea:	d50a      	bpl.n	8602 <GMAC_Handler+0x2e>
		hri_gmac_write_TSR_reg(_gmac_dev->hw, tsr);
    85ec:	9a00      	ldr	r2, [sp, #0]
	((Gmac *)hw)->TSR.reg = data;
    85ee:	615a      	str	r2, [r3, #20]
		if ((_txbuf_descrs[_txbuf_index].status.bm.used) && (_gmac_dev->cb.transmited != NULL)) {
    85f0:	6863      	ldr	r3, [r4, #4]
    85f2:	eb04 03c3 	add.w	r3, r4, r3, lsl #3
    85f6:	7bdb      	ldrb	r3, [r3, #15]
    85f8:	09db      	lsrs	r3, r3, #7
    85fa:	d002      	beq.n	8602 <GMAC_Handler+0x2e>
    85fc:	6843      	ldr	r3, [r0, #4]
    85fe:	b103      	cbz	r3, 8602 <GMAC_Handler+0x2e>
			_gmac_dev->cb.transmited(_gmac_dev);
    8600:	4798      	blx	r3
		}
	}

	/* Frame received */
	if (rsr & GMAC_RSR_REC) {
    8602:	9b01      	ldr	r3, [sp, #4]
    8604:	079b      	lsls	r3, r3, #30
    8606:	d503      	bpl.n	8610 <GMAC_Handler+0x3c>
		if (_gmac_dev->cb.received != NULL) {
    8608:	6820      	ldr	r0, [r4, #0]
    860a:	6883      	ldr	r3, [r0, #8]
    860c:	b103      	cbz	r3, 8610 <GMAC_Handler+0x3c>
			_gmac_dev->cb.received(_gmac_dev);
    860e:	4798      	blx	r3
		}
	}
	hri_gmac_write_RSR_reg(_gmac_dev->hw, rsr);
    8610:	6823      	ldr	r3, [r4, #0]
    8612:	9a01      	ldr	r2, [sp, #4]
    8614:	681b      	ldr	r3, [r3, #0]
	((Gmac *)hw)->RSR.reg = data;
    8616:	621a      	str	r2, [r3, #32]
}
    8618:	b002      	add	sp, #8
    861a:	bd10      	pop	{r4, pc}
    861c:	20014e00 	.word	0x20014e00

00008620 <_mac_async_init>:
	((Gmac *)hw)->NCR.reg = data;
    8620:	2310      	movs	r3, #16

int32_t _mac_async_init(struct _mac_async_device *const dev, void *const hw)
{
    8622:	b5f0      	push	{r4, r5, r6, r7, lr}
	dev->hw = hw;
    8624:	6001      	str	r1, [r0, #0]
    8626:	600b      	str	r3, [r1, #0]
	((Gmac *)hw)->NCFGR.reg = data;
    8628:	4b22      	ldr	r3, [pc, #136]	; (86b4 <_mac_async_init+0x94>)
    862a:	604b      	str	r3, [r1, #4]
	((Gmac *)hw)->UR.reg = data;
    862c:	2200      	movs	r2, #0
	((Gmac *)hw)->DCFGR.reg = data;
    862e:	4b22      	ldr	r3, [pc, #136]	; (86b8 <_mac_async_init+0x98>)
	((Gmac *)hw)->UR.reg = data;
    8630:	60ca      	str	r2, [r1, #12]
	((Gmac *)hw)->DCFGR.reg = data;
    8632:	610b      	str	r3, [r1, #16]
}

static inline void hri_gmac_write_IPGS_reg(const void *const hw, hri_gmac_ipgs_reg_t data)
{
	GMAC_CRITICAL_SECTION_ENTER();
	((Gmac *)hw)->IPGS.reg = data;
    8634:	f240 1301 	movw	r3, #257	; 0x101
	((Gmac *)hw)->WOL.reg = data;
    8638:	f8c1 20b8 	str.w	r2, [r1, #184]	; 0xb8
	((Gmac *)hw)->IPGS.reg = data;
    863c:	f8c1 30bc 	str.w	r3, [r1, #188]	; 0xbc
		_txbuf_descrs[i].address        = (uint32_t)_txbuf[i];
    8640:	4b1e      	ldr	r3, [pc, #120]	; (86bc <_mac_async_init+0x9c>)
    8642:	4e1f      	ldr	r6, [pc, #124]	; (86c0 <_mac_async_init+0xa0>)
	_txbuf_index                                            = 0;
    8644:	605a      	str	r2, [r3, #4]
		_txbuf_descrs[i].address        = (uint32_t)_txbuf[i];
    8646:	f103 0420 	add.w	r4, r3, #32
    864a:	609c      	str	r4, [r3, #8]
		_txbuf_descrs[i].status.val     = 0;
    864c:	f04f 4400 	mov.w	r4, #2147483648	; 0x80000000
    8650:	60dc      	str	r4, [r3, #12]
		_txbuf_descrs[i].address        = (uint32_t)_txbuf[i];
    8652:	f203 54fc 	addw	r4, r3, #1532	; 0x5fc
    8656:	611c      	str	r4, [r3, #16]
		_txbuf_descrs[i].status.val     = 0;
    8658:	f04f 4440 	mov.w	r4, #3221225472	; 0xc0000000
    865c:	615c      	str	r4, [r3, #20]
	_last_txbuf_index                                       = 0;
    865e:	f8c3 2bd8 	str.w	r2, [r3, #3032]	; 0xbd8
	for (i = 0; i < CONF_GMAC_RXDESCR_NUM; i++) {
    8662:	f503 653e 	add.w	r5, r3, #3040	; 0xbe0
	_last_txbuf_index                                       = 0;
    8666:	4634      	mov	r4, r6
		_rxbuf_descrs[i].status.val  = 0;
    8668:	4617      	mov	r7, r2
	for (i = 0; i < CONF_GMAC_RXDESCR_NUM; i++) {
    866a:	3201      	adds	r2, #1
    866c:	2a10      	cmp	r2, #16
		_rxbuf_descrs[i].status.val  = 0;
    866e:	e9c4 5700 	strd	r5, r7, [r4]
	for (i = 0; i < CONF_GMAC_RXDESCR_NUM; i++) {
    8672:	f105 0580 	add.w	r5, r5, #128	; 0x80
    8676:	f104 0408 	add.w	r4, r4, #8
    867a:	d1f6      	bne.n	866a <_mac_async_init+0x4a>
	_rxbuf_descrs[CONF_GMAC_RXDESCR_NUM - 1].address.bm.wrap = 1;
    867c:	4a11      	ldr	r2, [pc, #68]	; (86c4 <_mac_async_init+0xa4>)
	        | GMAC_DCFGR_DRBS(CONF_GMAC_DCFGR_DRBS) | (CONF_GMAC_DCFGR_DDRP ? GMAC_DCFGR_DDRP : 0));
	hri_gmac_write_WOL_reg(dev->hw, 0);
	hri_gmac_write_IPGS_reg(dev->hw, GMAC_IPGS_FL((CONF_GMAC_IPGS_FL_MUL << 8) | CONF_GMAC_IPGS_FL_DIV));
	_mac_init_bufdescr(dev);

	_gmac_dev = dev;
    867e:	6018      	str	r0, [r3, #0]
	_rxbuf_descrs[CONF_GMAC_RXDESCR_NUM - 1].address.bm.wrap = 1;
    8680:	f892 4360 	ldrb.w	r4, [r2, #864]	; 0x360
	_rxbuf_index                                             = 0;
    8684:	f8c2 7368 	str.w	r7, [r2, #872]	; 0x368
	_rxbuf_descrs[CONF_GMAC_RXDESCR_NUM - 1].address.bm.wrap = 1;
    8688:	f044 0402 	orr.w	r4, r4, #2
    868c:	f882 4360 	strb.w	r4, [r2, #864]	; 0x360
    NVIC->ICER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
    8690:	4b0d      	ldr	r3, [pc, #52]	; (86c8 <_mac_async_init+0xa8>)
	hri_gmac_write_TBQB_reg(dev->hw, (uint32_t)_txbuf_descrs);
    8692:	4a0e      	ldr	r2, [pc, #56]	; (86cc <_mac_async_init+0xac>)
	((Gmac *)hw)->TBQB.reg = data;
    8694:	61ca      	str	r2, [r1, #28]
    8696:	f44f 1280 	mov.w	r2, #1048576	; 0x100000
	((Gmac *)hw)->RBQB.reg = data;
    869a:	618e      	str	r6, [r1, #24]
    869c:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88
  __ASM volatile ("dsb 0xF":::"memory");
    86a0:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
    86a4:	f3bf 8f6f 	isb	sy
	NVIC_DisableIRQ(GMAC_IRQn);
	NVIC_ClearPendingIRQ(GMAC_IRQn);
	NVIC_EnableIRQ(GMAC_IRQn);

	return ERR_NONE;
}
    86a8:	2000      	movs	r0, #0
    NVIC->ICPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
    86aa:	f8c3 2188 	str.w	r2, [r3, #392]	; 0x188
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
    86ae:	609a      	str	r2, [r3, #8]
    86b0:	bdf0      	pop	{r4, r5, r6, r7, pc}
    86b2:	bf00      	nop
    86b4:	00100103 	.word	0x00100103
    86b8:	00020704 	.word	0x00020704
    86bc:	20014e00 	.word	0x20014e00
    86c0:	200161e0 	.word	0x200161e0
    86c4:	20015ef8 	.word	0x20015ef8
    86c8:	e000e100 	.word	0xe000e100
    86cc:	20014e08 	.word	0x20014e08

000086d0 <_mac_async_enable>:
	return ERR_NONE;
}

int32_t _mac_async_enable(struct _mac_async_device *const dev)
{
	hri_gmac_set_NCR_reg(dev->hw, GMAC_NCR_RXEN | GMAC_NCR_TXEN);
    86d0:	6802      	ldr	r2, [r0, #0]
	((Gmac *)hw)->NCR.reg |= mask;
    86d2:	6813      	ldr	r3, [r2, #0]
    86d4:	f043 030c 	orr.w	r3, r3, #12
    86d8:	6013      	str	r3, [r2, #0]
	return ERR_NONE;
}
    86da:	2000      	movs	r0, #0
    86dc:	4770      	bx	lr
	...

000086e0 <_mac_async_write>:
	hri_gmac_clear_NCR_reg(dev->hw, GMAC_NCR_RXEN | GMAC_NCR_TXEN);
	return ERR_NONE;
}

int32_t _mac_async_write(struct _mac_async_device *const dev, uint8_t *buf, uint32_t len)
{
    86e0:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
	uint32_t pos;
	uint32_t blen;
	uint32_t i;

	if (_txbuf_descrs[_last_txbuf_index].status.bm.used && !_txbuf_descrs[_last_txbuf_index].status.bm.last_buf) {
    86e4:	4c3a      	ldr	r4, [pc, #232]	; (87d0 <_mac_async_write+0xf0>)
    86e6:	f8d4 3bd8 	ldr.w	r3, [r4, #3032]	; 0xbd8
    86ea:	eb04 03c3 	add.w	r3, r4, r3, lsl #3
{
    86ee:	4680      	mov	r8, r0
	if (_txbuf_descrs[_last_txbuf_index].status.bm.used && !_txbuf_descrs[_last_txbuf_index].status.bm.last_buf) {
    86f0:	7bdb      	ldrb	r3, [r3, #15]
    86f2:	09db      	lsrs	r3, r3, #7
{
    86f4:	4616      	mov	r6, r2
	if (_txbuf_descrs[_last_txbuf_index].status.bm.used && !_txbuf_descrs[_last_txbuf_index].status.bm.last_buf) {
    86f6:	d012      	beq.n	871e <_mac_async_write+0x3e>
    86f8:	f8d4 3bd8 	ldr.w	r3, [r4, #3032]	; 0xbd8
    86fc:	eb04 03c3 	add.w	r3, r4, r3, lsl #3
    8700:	7b5b      	ldrb	r3, [r3, #13]
    8702:	09db      	lsrs	r3, r3, #7
    8704:	d10b      	bne.n	871e <_mac_async_write+0x3e>
		/* Set used flag from first descriptor to last descriptor,
		 * as DMA olny set the first used flag */
		for (i = 1; i < CONF_GMAC_TXDESCR_NUM; i++) {
			pos = _last_txbuf_index + i;
    8706:	f8d4 2bd8 	ldr.w	r2, [r4, #3032]	; 0xbd8
    870a:	1c53      	adds	r3, r2, #1
			if (pos >= CONF_GMAC_TXDESCR_NUM) {
    870c:	2b01      	cmp	r3, #1
    870e:	d900      	bls.n	8712 <_mac_async_write+0x32>
				pos -= CONF_GMAC_TXDESCR_NUM;
    8710:	1e53      	subs	r3, r2, #1
			}
			_txbuf_descrs[pos].status.bm.used = 1;
    8712:	eb04 03c3 	add.w	r3, r4, r3, lsl #3
    8716:	7bda      	ldrb	r2, [r3, #15]
    8718:	f042 0280 	orr.w	r2, r2, #128	; 0x80
    871c:	73da      	strb	r2, [r3, #15]
				break;
			}
		}
	}

	if (!_txbuf_descrs[_txbuf_index].status.bm.used) {
    871e:	6863      	ldr	r3, [r4, #4]
    8720:	eb04 03c3 	add.w	r3, r4, r3, lsl #3
    8724:	7bdb      	ldrb	r3, [r3, #15]
    8726:	09db      	lsrs	r3, r3, #7
    8728:	d04e      	beq.n	87c8 <_mac_async_write+0xe8>
		return ERR_NO_RESOURCE;
	}

	/* Check if have enough buffers, the first buffer already checked */
	if (len > CONF_GMAC_TXBUF_SIZE) {
    872a:	f240 53dc 	movw	r3, #1500	; 0x5dc
    872e:	429e      	cmp	r6, r3
    8730:	d90a      	bls.n	8748 <_mac_async_write+0x68>
		for (i = 1; i < CONF_GMAC_TXDESCR_NUM; i++) {
			pos = _txbuf_index + i;
    8732:	6862      	ldr	r2, [r4, #4]
    8734:	1c53      	adds	r3, r2, #1
			if (pos >= CONF_GMAC_TXDESCR_NUM) {
    8736:	2b01      	cmp	r3, #1
				pos -= CONF_GMAC_TXDESCR_NUM;
    8738:	bf88      	it	hi
    873a:	f102 33ff 	addhi.w	r3, r2, #4294967295	; 0xffffffff
			}

			if (!_txbuf_descrs[pos].status.bm.used) {
    873e:	eb04 03c3 	add.w	r3, r4, r3, lsl #3
    8742:	7bdb      	ldrb	r3, [r3, #15]
    8744:	09db      	lsrs	r3, r3, #7
    8746:	d03f      	beq.n	87c8 <_mac_async_write+0xe8>
			if ((len - (CONF_GMAC_TXBUF_SIZE * i)) < CONF_GMAC_TXBUF_SIZE) {
				break;
			}
		}
	}
	_last_txbuf_index = _txbuf_index;
    8748:	6863      	ldr	r3, [r4, #4]
    874a:	f8c4 3bd8 	str.w	r3, [r4, #3032]	; 0xbd8

	/* Write data to transmit buffer */
	for (i = 0; i < CONF_GMAC_TXDESCR_NUM; i++) {
		blen = min(len, CONF_GMAC_TXBUF_SIZE);
		memcpy(_txbuf[_txbuf_index], buf + (i * CONF_GMAC_TXBUF_SIZE), blen);
    874e:	f8df b088 	ldr.w	fp, [pc, #136]	; 87d8 <_mac_async_write+0xf8>
    8752:	4b20      	ldr	r3, [pc, #128]	; (87d4 <_mac_async_write+0xf4>)
    8754:	460d      	mov	r5, r1
    8756:	f601 3ab8 	addw	sl, r1, #3000	; 0xbb8
		blen = min(len, CONF_GMAC_TXBUF_SIZE);
    875a:	f240 59dc 	movw	r9, #1500	; 0x5dc
    875e:	454e      	cmp	r6, r9
		memcpy(_txbuf[_txbuf_index], buf + (i * CONF_GMAC_TXBUF_SIZE), blen);
    8760:	6860      	ldr	r0, [r4, #4]
		blen = min(len, CONF_GMAC_TXBUF_SIZE);
    8762:	4637      	mov	r7, r6
    8764:	bf28      	it	cs
    8766:	464f      	movcs	r7, r9
		memcpy(_txbuf[_txbuf_index], buf + (i * CONF_GMAC_TXBUF_SIZE), blen);
    8768:	4629      	mov	r1, r5
    876a:	463a      	mov	r2, r7
    876c:	fb09 b000 	mla	r0, r9, r0, fp
    8770:	4798      	blx	r3
		len -= blen;

		if (len > 0) {
			/* Here the Used flag be set to zero */
			_txbuf_descrs[_txbuf_index].status.val = blen;
    8772:	6862      	ldr	r2, [r4, #4]
		if (len > 0) {
    8774:	4b17      	ldr	r3, [pc, #92]	; (87d4 <_mac_async_write+0xf4>)
			_txbuf_descrs[_txbuf_index].status.val = blen;
    8776:	eb04 02c2 	add.w	r2, r4, r2, lsl #3
		if (len > 0) {
    877a:	1bf6      	subs	r6, r6, r7
			_txbuf_descrs[_txbuf_index].status.val = blen;
    877c:	60d7      	str	r7, [r2, #12]
		} else {
			_txbuf_descrs[_txbuf_index].status.val         = blen;
			_txbuf_descrs[_txbuf_index].status.bm.last_buf = 1;
    877e:	bf01      	itttt	eq
    8780:	6862      	ldreq	r2, [r4, #4]
    8782:	eb04 02c2 	addeq.w	r2, r4, r2, lsl #3
    8786:	7b51      	ldrbeq	r1, [r2, #13]
    8788:	f041 0180 	orreq.w	r1, r1, #128	; 0x80
    878c:	bf08      	it	eq
    878e:	7351      	strbeq	r1, [r2, #13]
		}
		_txbuf_index++;
    8790:	6862      	ldr	r2, [r4, #4]
    8792:	3201      	adds	r2, #1
    8794:	6062      	str	r2, [r4, #4]
		if (_txbuf_index == CONF_GMAC_TXDESCR_NUM) {
    8796:	6862      	ldr	r2, [r4, #4]
    8798:	2a02      	cmp	r2, #2
    879a:	d105      	bne.n	87a8 <_mac_async_write+0xc8>
			_txbuf_index                                            = 0;
    879c:	2200      	movs	r2, #0
    879e:	6062      	str	r2, [r4, #4]
			_txbuf_descrs[CONF_GMAC_TXDESCR_NUM - 1].status.bm.wrap = 1;
    87a0:	7de2      	ldrb	r2, [r4, #23]
    87a2:	f042 0240 	orr.w	r2, r2, #64	; 0x40
    87a6:	75e2      	strb	r2, [r4, #23]
		}
		if (len == 0) {
    87a8:	b11e      	cbz	r6, 87b2 <_mac_async_write+0xd2>
	for (i = 0; i < CONF_GMAC_TXDESCR_NUM; i++) {
    87aa:	f205 55dc 	addw	r5, r5, #1500	; 0x5dc
    87ae:	45aa      	cmp	sl, r5
    87b0:	d1d5      	bne.n	875e <_mac_async_write+0x7e>
  __ASM volatile ("dsb 0xF":::"memory");
    87b2:	f3bf 8f4f 	dsb	sy

	/* Data synchronization barrier */
	__DSB();

	/* Active Transmit */
	hri_gmac_set_NCR_reg(dev->hw, GMAC_NCR_TSTART);
    87b6:	f8d8 2000 	ldr.w	r2, [r8]
    87ba:	6813      	ldr	r3, [r2, #0]
    87bc:	f443 7300 	orr.w	r3, r3, #512	; 0x200
    87c0:	6013      	str	r3, [r2, #0]

	return ERR_NONE;
    87c2:	2000      	movs	r0, #0
}
    87c4:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
		return ERR_NO_RESOURCE;
    87c8:	f06f 001b 	mvn.w	r0, #27
    87cc:	e7fa      	b.n	87c4 <_mac_async_write+0xe4>
    87ce:	bf00      	nop
    87d0:	20014e00 	.word	0x20014e00
    87d4:	0000c07d 	.word	0x0000c07d
    87d8:	20014e20 	.word	0x20014e20

000087dc <_mac_async_read>:

uint32_t _mac_async_read(struct _mac_async_device *const dev, uint8_t *buf, uint32_t len)
{
    87dc:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
	uint32_t eof       = 0xFFFFFFFF; /* End of Frame index */
	uint32_t total_len = 0;          /* Total length of received package */

	(void)dev;
	for (i = 0; i < CONF_GMAC_RXDESCR_NUM; i++) {
		pos = _rxbuf_index + i;
    87e0:	4d35      	ldr	r5, [pc, #212]	; (88b8 <_mac_async_read+0xdc>)
{
    87e2:	460b      	mov	r3, r1
    87e4:	4616      	mov	r6, r2
	uint32_t sof       = 0xFFFFFFFF; /* Start of Frame index */
    87e6:	f04f 37ff 	mov.w	r7, #4294967295	; 0xffffffff
	for (i = 0; i < CONF_GMAC_RXDESCR_NUM; i++) {
    87ea:	2400      	movs	r4, #0
		pos = _rxbuf_index + i;
    87ec:	f8d5 2368 	ldr.w	r2, [r5, #872]	; 0x368
    87f0:	4422      	add	r2, r4

		if (pos >= CONF_GMAC_RXDESCR_NUM) {
    87f2:	2a0f      	cmp	r2, #15
			pos -= CONF_GMAC_RXDESCR_NUM;
    87f4:	bf88      	it	hi
    87f6:	3a10      	subhi	r2, #16
		}

		/* No more data for Ethernet package */
		if (!_rxbuf_descrs[pos].address.bm.ownership) {
    87f8:	eb05 02c2 	add.w	r2, r5, r2, lsl #3
    87fc:	f892 12e8 	ldrb.w	r1, [r2, #744]	; 0x2e8
    8800:	07c9      	lsls	r1, r1, #31
    8802:	d51f      	bpl.n	8844 <_mac_async_read+0x68>
			break;
		}

		if (_rxbuf_descrs[pos].status.bm.sof) {
    8804:	f892 12ed 	ldrb.w	r1, [r2, #749]	; 0x2ed
    8808:	f011 0f40 	tst.w	r1, #64	; 0x40
    880c:	bf18      	it	ne
    880e:	4627      	movne	r7, r4
			sof = i;
		}

		if ((_rxbuf_descrs[pos].status.bm.eof) && (sof != 0xFFFFFFFF)) {
    8810:	09c9      	lsrs	r1, r1, #7
    8812:	f104 0801 	add.w	r8, r4, #1
    8816:	d012      	beq.n	883e <_mac_async_read+0x62>
    8818:	1c78      	adds	r0, r7, #1
    881a:	d010      	beq.n	883e <_mac_async_read+0x62>
			/* eof now indicate the number of bufs the frame used */
			eof = i;
			n   = _rxbuf_descrs[pos].status.bm.len;
    881c:	f8b2 22ec 	ldrh.w	r2, [r2, #748]	; 0x2ec
    8820:	f3c2 020c 	ubfx	r2, r2, #0, #13
			len = min(n, len);
    8824:	4296      	cmp	r6, r2
    8826:	bf28      	it	cs
    8828:	4616      	movcs	r6, r2
	uint32_t total_len = 0;          /* Total length of received package */
    882a:	f04f 0900 	mov.w	r9, #0
	} else {
		j = i;
	}

	/* Copy data to user buffer */
	for (i = 0; i < j; i++) {
    882e:	46ca      	mov	sl, r9

		_rxbuf_descrs[_rxbuf_index].address.bm.ownership = 0;
		_rxbuf_index++;

		if (_rxbuf_index == CONF_GMAC_RXDESCR_NUM) {
			_rxbuf_index = 0;
    8830:	46cb      	mov	fp, r9
	for (i = 0; i < j; i++) {
    8832:	45c2      	cmp	sl, r8
    8834:	d10e      	bne.n	8854 <_mac_async_read+0x78>
		}
	}

	return total_len;
}
    8836:	4648      	mov	r0, r9
    8838:	b003      	add	sp, #12
    883a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	for (i = 0; i < CONF_GMAC_RXDESCR_NUM; i++) {
    883e:	4644      	mov	r4, r8
    8840:	2c10      	cmp	r4, #16
    8842:	d1d3      	bne.n	87ec <_mac_async_read+0x10>
	} else if (sof != 0xFFFFFFFF) {
    8844:	1c7a      	adds	r2, r7, #1
    8846:	d101      	bne.n	884c <_mac_async_read+0x70>
    8848:	46a0      	mov	r8, r4
    884a:	e000      	b.n	884e <_mac_async_read+0x72>
    884c:	46b8      	mov	r8, r7
    884e:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
    8852:	e7ea      	b.n	882a <_mac_async_read+0x4e>
		if (eof != 0xFFFFFFFF && i >= sof && i <= eof && len > 0) {
    8854:	1c61      	adds	r1, r4, #1
    8856:	d016      	beq.n	8886 <_mac_async_read+0xaa>
    8858:	45ba      	cmp	sl, r7
    885a:	d314      	bcc.n	8886 <_mac_async_read+0xaa>
    885c:	45a2      	cmp	sl, r4
    885e:	d812      	bhi.n	8886 <_mac_async_read+0xaa>
    8860:	b18e      	cbz	r6, 8886 <_mac_async_read+0xaa>
			memcpy(buf, _rxbuf[_rxbuf_index], n);
    8862:	f8d5 1368 	ldr.w	r1, [r5, #872]	; 0x368
    8866:	4815      	ldr	r0, [pc, #84]	; (88bc <_mac_async_read+0xe0>)
			n = min(len, CONF_GMAC_RXBUF_SIZE);
    8868:	2e80      	cmp	r6, #128	; 0x80
    886a:	4632      	mov	r2, r6
			memcpy(buf, _rxbuf[_rxbuf_index], n);
    886c:	eb00 11c1 	add.w	r1, r0, r1, lsl #7
			n = min(len, CONF_GMAC_RXBUF_SIZE);
    8870:	bf28      	it	cs
    8872:	2280      	movcs	r2, #128	; 0x80
			memcpy(buf, _rxbuf[_rxbuf_index], n);
    8874:	4618      	mov	r0, r3
    8876:	4b12      	ldr	r3, [pc, #72]	; (88c0 <_mac_async_read+0xe4>)
    8878:	9201      	str	r2, [sp, #4]
    887a:	4798      	blx	r3
			buf += n;
    887c:	9a01      	ldr	r2, [sp, #4]
			memcpy(buf, _rxbuf[_rxbuf_index], n);
    887e:	4603      	mov	r3, r0
			buf += n;
    8880:	4413      	add	r3, r2
			total_len += n;
    8882:	4491      	add	r9, r2
			len -= n;
    8884:	1ab6      	subs	r6, r6, r2
		_rxbuf_descrs[_rxbuf_index].address.bm.ownership = 0;
    8886:	f8d5 2368 	ldr.w	r2, [r5, #872]	; 0x368
    888a:	eb05 02c2 	add.w	r2, r5, r2, lsl #3
	for (i = 0; i < j; i++) {
    888e:	f10a 0a01 	add.w	sl, sl, #1
		_rxbuf_descrs[_rxbuf_index].address.bm.ownership = 0;
    8892:	f892 12e8 	ldrb.w	r1, [r2, #744]	; 0x2e8
    8896:	f36f 0100 	bfc	r1, #0, #1
    889a:	f882 12e8 	strb.w	r1, [r2, #744]	; 0x2e8
		_rxbuf_index++;
    889e:	f8d5 2368 	ldr.w	r2, [r5, #872]	; 0x368
    88a2:	3201      	adds	r2, #1
    88a4:	f8c5 2368 	str.w	r2, [r5, #872]	; 0x368
		if (_rxbuf_index == CONF_GMAC_RXDESCR_NUM) {
    88a8:	f8d5 2368 	ldr.w	r2, [r5, #872]	; 0x368
    88ac:	2a10      	cmp	r2, #16
			_rxbuf_index = 0;
    88ae:	bf08      	it	eq
    88b0:	f8c5 b368 	streq.w	fp, [r5, #872]	; 0x368
	for (i = 0; i < j; i++) {
    88b4:	e7bd      	b.n	8832 <_mac_async_read+0x56>
    88b6:	bf00      	nop
    88b8:	20015ef8 	.word	0x20015ef8
    88bc:	200159e0 	.word	0x200159e0
    88c0:	0000c07d 	.word	0x0000c07d

000088c4 <_mac_async_read_len>:
uint32_t _mac_async_read_len(struct _mac_async_device *const dev)
{
	uint32_t i;
	uint32_t pos;
	bool     sof       = false; /* Start of Frame */
	uint32_t total_len = 0;     /* Total length of received package */
    88c4:	2000      	movs	r0, #0

	(void)dev;

	for (i = 0; i < CONF_GMAC_RXDESCR_NUM; i++) {
		pos = _rxbuf_index + i;
    88c6:	4913      	ldr	r1, [pc, #76]	; (8914 <_mac_async_read_len+0x50>)
{
    88c8:	b570      	push	{r4, r5, r6, lr}
	for (i = 0; i < CONF_GMAC_RXDESCR_NUM; i++) {
    88ca:	4602      	mov	r2, r0
	bool     sof       = false; /* Start of Frame */
    88cc:	4606      	mov	r6, r0
		pos = _rxbuf_index + i;
    88ce:	f8d1 3368 	ldr.w	r3, [r1, #872]	; 0x368
    88d2:	4413      	add	r3, r2

		if (pos >= CONF_GMAC_RXDESCR_NUM) {
    88d4:	2b0f      	cmp	r3, #15
			pos -= CONF_GMAC_RXDESCR_NUM;
    88d6:	bf88      	it	hi
    88d8:	3b10      	subhi	r3, #16
		}

		/* No more data for Ethernet package */
		if (!(_rxbuf_descrs[pos].address.bm.ownership)) {
    88da:	00dc      	lsls	r4, r3, #3
    88dc:	eb01 03c3 	add.w	r3, r1, r3, lsl #3
    88e0:	f893 52e8 	ldrb.w	r5, [r3, #744]	; 0x2e8
    88e4:	f015 0501 	ands.w	r5, r5, #1
    88e8:	d013      	beq.n	8912 <_mac_async_read_len+0x4e>
			break;
		}

		if (_rxbuf_descrs[pos].status.bm.sof) {
    88ea:	f893 32ed 	ldrb.w	r3, [r3, #749]	; 0x2ed
    88ee:	065b      	lsls	r3, r3, #25
    88f0:	d400      	bmi.n	88f4 <_mac_async_read_len+0x30>
			sof = true;
		}
		if (sof == true) {
    88f2:	b136      	cbz	r6, 8902 <_mac_async_read_len+0x3e>
			total_len += _rxbuf_descrs[pos].status.bm.len;
    88f4:	190b      	adds	r3, r1, r4
    88f6:	462e      	mov	r6, r5
    88f8:	f8b3 32ec 	ldrh.w	r3, [r3, #748]	; 0x2ec
    88fc:	f3c3 030c 	ubfx	r3, r3, #0, #13
    8900:	4418      	add	r0, r3
		}

		if (_rxbuf_descrs[pos].status.bm.eof) {
    8902:	440c      	add	r4, r1
    8904:	f894 32ed 	ldrb.w	r3, [r4, #749]	; 0x2ed
    8908:	09db      	lsrs	r3, r3, #7
    890a:	d102      	bne.n	8912 <_mac_async_read_len+0x4e>
	for (i = 0; i < CONF_GMAC_RXDESCR_NUM; i++) {
    890c:	3201      	adds	r2, #1
    890e:	2a10      	cmp	r2, #16
    8910:	d1dd      	bne.n	88ce <_mac_async_read_len+0xa>
			break;
		}
	}

	return total_len;
}
    8912:	bd70      	pop	{r4, r5, r6, pc}
    8914:	20015ef8 	.word	0x20015ef8

00008918 <_mac_async_register_callback>:
}

int32_t _mac_async_register_callback(struct _mac_async_device *const dev, const enum mac_async_cb_type type,
                                     const FUNC_PTR func)
{
	switch (type) {
    8918:	b151      	cbz	r1, 8930 <_mac_async_register_callback+0x18>
    891a:	2901      	cmp	r1, #1
    891c:	d10d      	bne.n	893a <_mac_async_register_callback+0x22>
	case MAC_ASYNC_TRANSMIT_CB:
		dev->cb.transmited = (_mac_async_cb_t)func;
		if (func) {
			hri_gmac_set_IMR_TCOMP_bit(dev->hw);
    891e:	6803      	ldr	r3, [r0, #0]
		dev->cb.transmited = (_mac_async_cb_t)func;
    8920:	6042      	str	r2, [r0, #4]
		if (func) {
    8922:	2180      	movs	r1, #128	; 0x80
    8924:	b112      	cbz	r2, 892c <_mac_async_register_callback+0x14>
	((Gmac *)hw)->IER.reg = GMAC_IMR_TCOMP;
    8926:	6299      	str	r1, [r3, #40]	; 0x28
		}
		break;
	default:
		return ERR_INVALID_ARG;
	}
	return ERR_NONE;
    8928:	2000      	movs	r0, #0
}
    892a:	4770      	bx	lr
	((Gmac *)hw)->IDR.reg = GMAC_IMR_TCOMP;
    892c:	62d9      	str	r1, [r3, #44]	; 0x2c
    892e:	e7fb      	b.n	8928 <_mac_async_register_callback+0x10>
			hri_gmac_set_IMR_TCOMP_bit(dev->hw);
    8930:	6803      	ldr	r3, [r0, #0]
		dev->cb.received = (_mac_async_cb_t)func;
    8932:	6082      	str	r2, [r0, #8]
		if (func) {
    8934:	2002      	movs	r0, #2
	((Gmac *)hw)->IER.reg = GMAC_IMR_RCOMP;
    8936:	6298      	str	r0, [r3, #40]	; 0x28
    8938:	e7f6      	b.n	8928 <_mac_async_register_callback+0x10>
	switch (type) {
    893a:	f06f 000c 	mvn.w	r0, #12
}
    893e:	4770      	bx	lr

00008940 <_mac_async_set_filter>:

int32_t _mac_async_set_filter(struct _mac_async_device *const dev, uint8_t index, struct mac_async_filter *filter)
{
    8940:	b570      	push	{r4, r5, r6, lr}
    8942:	460c      	mov	r4, r1
    8944:	4606      	mov	r6, r0
	ASSERT(index < 4);
    8946:	2c03      	cmp	r4, #3
{
    8948:	4615      	mov	r5, r2
	ASSERT(index < 4);
    894a:	bf8c      	ite	hi
    894c:	2000      	movhi	r0, #0
    894e:	2001      	movls	r0, #1
    8950:	4909      	ldr	r1, [pc, #36]	; (8978 <_mac_async_set_filter+0x38>)
    8952:	4b0a      	ldr	r3, [pc, #40]	; (897c <_mac_async_set_filter+0x3c>)
    8954:	f240 12cf 	movw	r2, #463	; 0x1cf
    8958:	4798      	blx	r3

	hri_gmac_write_SAB_reg(dev->hw, index, *((uint32_t *)(filter->mac)));
    895a:	6833      	ldr	r3, [r6, #0]
    895c:	6829      	ldr	r1, [r5, #0]
	((Gmac *)hw)->Sa[submodule_index].SAB.reg = data;
    895e:	eb03 02c4 	add.w	r2, r3, r4, lsl #3
	((Gmac *)hw)->TIDM[index].reg = data;
    8962:	342a      	adds	r4, #42	; 0x2a
	((Gmac *)hw)->Sa[submodule_index].SAB.reg = data;
    8964:	f8c2 1088 	str.w	r1, [r2, #136]	; 0x88
	hri_gmac_write_SAT_reg(dev->hw, index, *((uint16_t *)(filter->mac + 4)));
    8968:	88a9      	ldrh	r1, [r5, #4]
	((Gmac *)hw)->Sa[submodule_index].SAT.reg = data;
    896a:	f8c2 108c 	str.w	r1, [r2, #140]	; 0x8c

	hri_gmac_write_TIDM_reg(dev->hw, index, GMAC_TIDM_TID(*((uint16_t *)(filter->tid)) | filter->tid_enable << 31));
    896e:	88ea      	ldrh	r2, [r5, #6]
	((Gmac *)hw)->TIDM[index].reg = data;
    8970:	f843 2024 	str.w	r2, [r3, r4, lsl #2]
	return ERR_NONE;
}
    8974:	2000      	movs	r0, #0
    8976:	bd70      	pop	{r4, r5, r6, pc}
    8978:	0000cc73 	.word	0x0000cc73
    897c:	00008a19 	.word	0x00008a19

00008980 <_mac_async_read_phy_reg>:
	return ERR_NONE;
}

int32_t _mac_async_read_phy_reg(struct _mac_async_device *const dev, uint16_t addr, uint16_t reg, uint16_t *data)
{
	hri_gmac_set_NCR_reg(dev->hw, GMAC_NCR_MPE);
    8980:	6800      	ldr	r0, [r0, #0]
	hri_gmac_write_MAN_reg(dev->hw,
	                       GMAC_MAN_OP(2) |            /* 0x02 read operation */
	                           CONF_GMAC_CLTTO << 30 | /* Clause 22/45 operation */
	                           GMAC_MAN_WTN(0x2) |     /* Must be written to 0x2 */
	                           GMAC_MAN_PHYA(addr) | GMAC_MAN_REGA(reg));
    8982:	05c9      	lsls	r1, r1, #23
    8984:	0492      	lsls	r2, r2, #18
    8986:	f001 6178 	and.w	r1, r1, #260046848	; 0xf800000
    898a:	f402 02f8 	and.w	r2, r2, #8126464	; 0x7c0000
{
    898e:	b510      	push	{r4, lr}
	                           GMAC_MAN_PHYA(addr) | GMAC_MAN_REGA(reg));
    8990:	4311      	orrs	r1, r2
	((Gmac *)hw)->NCR.reg |= mask;
    8992:	6804      	ldr	r4, [r0, #0]
    8994:	f041 41c0 	orr.w	r1, r1, #1610612736	; 0x60000000
    8998:	f044 0410 	orr.w	r4, r4, #16
    899c:	f441 3100 	orr.w	r1, r1, #131072	; 0x20000
    89a0:	6004      	str	r4, [r0, #0]
	((Gmac *)hw)->MAN.reg = data;
    89a2:	6341      	str	r1, [r0, #52]	; 0x34
	return (((Gmac *)hw)->NSR.reg & GMAC_NSR_IDLE) >> GMAC_NSR_IDLE_Pos;
    89a4:	6882      	ldr	r2, [r0, #8]

	/* Wait for the read operation complete */
	while (!hri_gmac_get_NSR_IDLE_bit(dev->hw)) {
    89a6:	0752      	lsls	r2, r2, #29
    89a8:	d5fc      	bpl.n	89a4 <_mac_async_read_phy_reg+0x24>
	return ((Gmac *)hw)->MAN.reg;
    89aa:	6b42      	ldr	r2, [r0, #52]	; 0x34
	}

	*data = GMAC_MAN_DATA(hri_gmac_read_MAN_reg(dev->hw));
    89ac:	801a      	strh	r2, [r3, #0]
	((Gmac *)hw)->NCR.reg &= ~mask;
    89ae:	6803      	ldr	r3, [r0, #0]
    89b0:	f023 0310 	bic.w	r3, r3, #16
    89b4:	6003      	str	r3, [r0, #0]
	hri_gmac_clear_NCR_reg(dev->hw, GMAC_NCR_MPE);

	return ERR_NONE;
}
    89b6:	2000      	movs	r0, #0
    89b8:	bd10      	pop	{r4, pc}
	...

000089bc <_write>:
#include <stdio.h>

int __attribute__((weak)) _write(int file, char *ptr, int len); /* Remove GCC compiler warning */

int __attribute__((weak)) _write(int file, char *ptr, int len)
{
    89bc:	b508      	push	{r3, lr}
    89be:	4603      	mov	r3, r0
	int n = 0;

	if ((file != 1) && (file != 2) && (file != 3)) {
    89c0:	3b01      	subs	r3, #1
    89c2:	2b02      	cmp	r3, #2
{
    89c4:	4608      	mov	r0, r1
    89c6:	4611      	mov	r1, r2
	if ((file != 1) && (file != 2) && (file != 3)) {
    89c8:	d804      	bhi.n	89d4 <_write+0x18>
		return -1;
	}

	n = stdio_io_write((const uint8_t *)ptr, len);
    89ca:	4b04      	ldr	r3, [pc, #16]	; (89dc <_write+0x20>)
    89cc:	4798      	blx	r3
	if (n < 0) {
    89ce:	ea40 70e0 	orr.w	r0, r0, r0, asr #31
		return -1;
	}

	return n;
}
    89d2:	bd08      	pop	{r3, pc}
		return -1;
    89d4:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    89d8:	e7fb      	b.n	89d2 <_write+0x16>
    89da:	bf00      	nop
    89dc:	000002ed 	.word	0x000002ed

000089e0 <RAMECC_Handler>:
	return tmp;
}

static inline hri_ramecc_intflag_reg_t hri_ramecc_read_INTFLAG_reg(const void *const hw)
{
	return ((Ramecc *)hw)->INTFLAG.reg;
    89e0:	4a0b      	ldr	r2, [pc, #44]	; (8a10 <RAMECC_Handler+0x30>)
    89e2:	7893      	ldrb	r3, [r2, #2]

/**
 * \internal RAMECC interrupt handler
 */
void RAMECC_Handler(void)
{
    89e4:	b082      	sub	sp, #8
    89e6:	b2db      	uxtb	r3, r3
	struct _ramecc_device *dev      = (struct _ramecc_device *)&device;
	volatile uint32_t      int_mask = hri_ramecc_read_INTFLAG_reg(RAMECC);
    89e8:	9301      	str	r3, [sp, #4]

	if (int_mask & RAMECC_INTFLAG_DUALE && dev->ramecc_cb.dual_bit_err) {
    89ea:	9b01      	ldr	r3, [sp, #4]
    89ec:	0799      	lsls	r1, r3, #30
    89ee:	d505      	bpl.n	89fc <RAMECC_Handler+0x1c>
    89f0:	4b08      	ldr	r3, [pc, #32]	; (8a14 <RAMECC_Handler+0x34>)
    89f2:	681b      	ldr	r3, [r3, #0]
    89f4:	b113      	cbz	r3, 89fc <RAMECC_Handler+0x1c>
	return tmp;
}

static inline hri_ramecc_erraddr_reg_t hri_ramecc_read_ERRADDR_reg(const void *const hw)
{
	return ((Ramecc *)hw)->ERRADDR.reg;
    89f6:	6850      	ldr	r0, [r2, #4]
	} else if (int_mask & RAMECC_INTFLAG_SINGLEE && dev->ramecc_cb.single_bit_err) {
		dev->ramecc_cb.single_bit_err((uint32_t)hri_ramecc_read_ERRADDR_reg(RAMECC));
	} else {
		return;
	}
}
    89f8:	b002      	add	sp, #8
		dev->ramecc_cb.single_bit_err((uint32_t)hri_ramecc_read_ERRADDR_reg(RAMECC));
    89fa:	4718      	bx	r3
	} else if (int_mask & RAMECC_INTFLAG_SINGLEE && dev->ramecc_cb.single_bit_err) {
    89fc:	9b01      	ldr	r3, [sp, #4]
    89fe:	07db      	lsls	r3, r3, #31
    8a00:	d504      	bpl.n	8a0c <RAMECC_Handler+0x2c>
    8a02:	4b04      	ldr	r3, [pc, #16]	; (8a14 <RAMECC_Handler+0x34>)
    8a04:	685b      	ldr	r3, [r3, #4]
    8a06:	b10b      	cbz	r3, 8a0c <RAMECC_Handler+0x2c>
    8a08:	4a01      	ldr	r2, [pc, #4]	; (8a10 <RAMECC_Handler+0x30>)
    8a0a:	e7f4      	b.n	89f6 <RAMECC_Handler+0x16>
}
    8a0c:	b002      	add	sp, #8
    8a0e:	4770      	bx	lr
    8a10:	41020000 	.word	0x41020000
    8a14:	20016264 	.word	0x20016264

00008a18 <assert>:
/**
 * \brief Assert function
 */
void assert(const bool condition, const char *const file, const int line)
{
	if (!(condition)) {
    8a18:	b900      	cbnz	r0, 8a1c <assert+0x4>
		__asm("BKPT #0");
    8a1a:	be00      	bkpt	0x0000
	}
	(void)file;
	(void)line;
}
    8a1c:	4770      	bx	lr

00008a1e <ip4_addr_isbroadcast>:
{
	ip_addr_t ipaddr;
	ip4_addr_set_u32(&ipaddr, addr);

	/* all ones (broadcast) or all zeroes (old skool broadcast) */
	if ((~addr == IPADDR_ANY) || (addr == IPADDR_ANY)) {
    8a1e:	1e43      	subs	r3, r0, #1
    8a20:	3303      	adds	r3, #3
{
    8a22:	4602      	mov	r2, r0
	if ((~addr == IPADDR_ANY) || (addr == IPADDR_ANY)) {
    8a24:	d812      	bhi.n	8a4c <ip4_addr_isbroadcast+0x2e>
		return 1;
		/* no broadcast support on this network interface? */
	} else if ((netif->flags & NETIF_FLAG_BROADCAST) == 0) {
    8a26:	f891 3031 	ldrb.w	r3, [r1, #49]	; 0x31
    8a2a:	f013 0002 	ands.w	r0, r3, #2
    8a2e:	d010      	beq.n	8a52 <ip4_addr_isbroadcast+0x34>
		/* the given address cannot be a broadcast address
		 * nor can we check against any broadcast addresses */
		return 0;
		/* address matches network interface address exactly? => no broadcast */
	} else if (addr == ip4_addr_get_u32(&netif->ip_addr)) {
    8a30:	684b      	ldr	r3, [r1, #4]
    8a32:	4293      	cmp	r3, r2
    8a34:	d00c      	beq.n	8a50 <ip4_addr_isbroadcast+0x32>
		return 0;
		/*  on the same (sub) network... */
	} else if (ip_addr_netcmp(&ipaddr, &(netif->ip_addr), &(netif->netmask))
    8a36:	6888      	ldr	r0, [r1, #8]
    8a38:	4053      	eors	r3, r2
    8a3a:	4203      	tst	r3, r0
    8a3c:	d108      	bne.n	8a50 <ip4_addr_isbroadcast+0x32>
	           /* ...and host identifier bits are all ones? =>... */
	           && ((addr & ~ip4_addr_get_u32(&netif->netmask))
    8a3e:	43c3      	mvns	r3, r0
    8a40:	ea22 0000 	bic.w	r0, r2, r0
	               == (IPADDR_BROADCAST & ~ip4_addr_get_u32(&netif->netmask)))) {
		/* => network broadcast address */
		return 1;
	} else {
		return 0;
    8a44:	1ac3      	subs	r3, r0, r3
    8a46:	4258      	negs	r0, r3
    8a48:	4158      	adcs	r0, r3
    8a4a:	4770      	bx	lr
		return 1;
    8a4c:	2001      	movs	r0, #1
    8a4e:	4770      	bx	lr
		return 0;
    8a50:	2000      	movs	r0, #0
	}
}
    8a52:	4770      	bx	lr

00008a54 <ipaddr_ntoa_r>:
 * @param buflen length of buf
 * @return either pointer to buf which now holds the ASCII
 *         representation of addr or NULL if buf was too small
 */
char *ipaddr_ntoa_r(const ip_addr_t *addr, char *buf, int buflen)
{
    8a54:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
	u8_t  rem;
	u8_t  n;
	u8_t  i;
	int   len = 0;

	s_addr = ip4_addr_get_u32(addr);
    8a58:	6803      	ldr	r3, [r0, #0]
    8a5a:	9301      	str	r3, [sp, #4]

	rp = buf;
	ap = (u8_t *)&s_addr;
	for (n = 0; n < 4; n++) {
    8a5c:	f10d 0c04 	add.w	ip, sp, #4
	rp = buf;
    8a60:	460d      	mov	r5, r1
	s_addr = ip4_addr_get_u32(addr);
    8a62:	2004      	movs	r0, #4
	int   len = 0;
    8a64:	2600      	movs	r6, #0
		i = 0;
		do {
			rem = *ap % (u8_t)10;
    8a66:	f04f 0e0a 	mov.w	lr, #10
			*rp++ = inv[i];
		}
		if (len++ >= buflen) {
			return NULL;
		}
		*rp++ = '.';
    8a6a:	f04f 082e 	mov.w	r8, #46	; 0x2e
    8a6e:	f81c 4b01 	ldrb.w	r4, [ip], #1
		i = 0;
    8a72:	2700      	movs	r7, #0
			rem = *ap % (u8_t)10;
    8a74:	fbb4 f3fe 	udiv	r3, r4, lr
    8a78:	46a2      	mov	sl, r4
    8a7a:	fb0e 4913 	mls	r9, lr, r3, r4
			*ap /= (u8_t)10;
    8a7e:	b2dc      	uxtb	r4, r3
			inv[i++] = '0' + rem;
    8a80:	463b      	mov	r3, r7
    8a82:	f103 0b08 	add.w	fp, r3, #8
    8a86:	44eb      	add	fp, sp
    8a88:	3701      	adds	r7, #1
    8a8a:	f109 0930 	add.w	r9, r9, #48	; 0x30
		} while (*ap);
    8a8e:	f1ba 0f09 	cmp.w	sl, #9
			inv[i++] = '0' + rem;
    8a92:	b2ff      	uxtb	r7, r7
    8a94:	f80b 9c08 	strb.w	r9, [fp, #-8]
		} while (*ap);
    8a98:	d8ec      	bhi.n	8a74 <ipaddr_ntoa_r+0x20>
    8a9a:	f80c 4c01 	strb.w	r4, [ip, #-1]
    8a9e:	4637      	mov	r7, r6
    8aa0:	462c      	mov	r4, r5
		while (i--) {
    8aa2:	2bff      	cmp	r3, #255	; 0xff
			if (len++ >= buflen) {
    8aa4:	f106 0601 	add.w	r6, r6, #1
		while (i--) {
    8aa8:	d10d      	bne.n	8ac6 <ipaddr_ntoa_r+0x72>
		if (len++ >= buflen) {
    8aaa:	4297      	cmp	r7, r2
    8aac:	da18      	bge.n	8ae0 <ipaddr_ntoa_r+0x8c>
		*rp++ = '.';
    8aae:	4625      	mov	r5, r4
	for (n = 0; n < 4; n++) {
    8ab0:	3801      	subs	r0, #1
    8ab2:	f010 00ff 	ands.w	r0, r0, #255	; 0xff
		*rp++ = '.';
    8ab6:	f805 8b01 	strb.w	r8, [r5], #1
	for (n = 0; n < 4; n++) {
    8aba:	d1d8      	bne.n	8a6e <ipaddr_ntoa_r+0x1a>
		ap++;
	}
	*--rp = 0;
    8abc:	7020      	strb	r0, [r4, #0]
	return buf;
    8abe:	4608      	mov	r0, r1
}
    8ac0:	b003      	add	sp, #12
    8ac2:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
			if (len++ >= buflen) {
    8ac6:	1e5d      	subs	r5, r3, #1
    8ac8:	4297      	cmp	r7, r2
    8aca:	b2ed      	uxtb	r5, r5
    8acc:	da08      	bge.n	8ae0 <ipaddr_ntoa_r+0x8c>
			*rp++ = inv[i];
    8ace:	3308      	adds	r3, #8
    8ad0:	446b      	add	r3, sp
			if (len++ >= buflen) {
    8ad2:	4637      	mov	r7, r6
			*rp++ = inv[i];
    8ad4:	f813 3c08 	ldrb.w	r3, [r3, #-8]
    8ad8:	f804 3b01 	strb.w	r3, [r4], #1
    8adc:	462b      	mov	r3, r5
    8ade:	e7e0      	b.n	8aa2 <ipaddr_ntoa_r+0x4e>
				return NULL;
    8ae0:	2000      	movs	r0, #0
    8ae2:	e7ed      	b.n	8ac0 <ipaddr_ntoa_r+0x6c>

00008ae4 <_mclk_init>:
	((Mclk *)hw)->CPUDIV.reg = data;
    8ae4:	4b01      	ldr	r3, [pc, #4]	; (8aec <_mclk_init+0x8>)
    8ae6:	2201      	movs	r2, #1
    8ae8:	715a      	strb	r2, [r3, #5]
 */
void _mclk_init(void)
{
	void *hw = (void *)MCLK;
	hri_mclk_write_CPUDIV_reg(hw, MCLK_CPUDIV_DIV(CONF_MCLK_CPUDIV));
}
    8aea:	4770      	bx	lr
    8aec:	40000800 	.word	0x40000800

00008af0 <prvResetNextTaskUnblockTime>:

static void prvResetNextTaskUnblockTime(void)
{
	TCB_t *pxTCB;

	if (listLIST_IS_EMPTY(pxDelayedTaskList) != pdFALSE) {
    8af0:	4b06      	ldr	r3, [pc, #24]	; (8b0c <prvResetNextTaskUnblockTime+0x1c>)
    8af2:	6a9a      	ldr	r2, [r3, #40]	; 0x28
    8af4:	6812      	ldr	r2, [r2, #0]
    8af6:	b91a      	cbnz	r2, 8b00 <prvResetNextTaskUnblockTime+0x10>
		/* The new current delayed list is empty.  Set xNextTaskUnblockTime to
		the maximum possible value so it is	extremely unlikely that the
		if( xTickCount >= xNextTaskUnblockTime ) test will pass until
		there is an item in the delayed list. */
		xNextTaskUnblockTime = portMAX_DELAY;
    8af8:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
		/* The new current delayed list is not empty, get the value of
		the item at the head of the delayed list.  This is the time at
		which the task at the head of the delayed list should be removed
		from the Blocked state. */
		(pxTCB)              = (TCB_t *)listGET_OWNER_OF_HEAD_ENTRY(pxDelayedTaskList);
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE(&((pxTCB)->xGenericListItem));
    8afc:	62da      	str	r2, [r3, #44]	; 0x2c
	}
}
    8afe:	4770      	bx	lr
		(pxTCB)              = (TCB_t *)listGET_OWNER_OF_HEAD_ENTRY(pxDelayedTaskList);
    8b00:	6a9a      	ldr	r2, [r3, #40]	; 0x28
    8b02:	68d2      	ldr	r2, [r2, #12]
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE(&((pxTCB)->xGenericListItem));
    8b04:	68d2      	ldr	r2, [r2, #12]
    8b06:	6852      	ldr	r2, [r2, #4]
    8b08:	e7f8      	b.n	8afc <prvResetNextTaskUnblockTime+0xc>
    8b0a:	bf00      	nop
    8b0c:	20016274 	.word	0x20016274

00008b10 <prvAddCurrentTaskToDelayedList>:
{
    8b10:	b570      	push	{r4, r5, r6, lr}
	listSET_LIST_ITEM_VALUE(&(pxCurrentTCB->xGenericListItem), xTimeToWake);
    8b12:	4c0b      	ldr	r4, [pc, #44]	; (8b40 <prvAddCurrentTaskToDelayedList+0x30>)
    8b14:	6b23      	ldr	r3, [r4, #48]	; 0x30
    8b16:	6058      	str	r0, [r3, #4]
	if (xTimeToWake < xTickCount) {
    8b18:	6b63      	ldr	r3, [r4, #52]	; 0x34
    8b1a:	4283      	cmp	r3, r0
{
    8b1c:	4605      	mov	r5, r0
    8b1e:	4b09      	ldr	r3, [pc, #36]	; (8b44 <prvAddCurrentTaskToDelayedList+0x34>)
	if (xTimeToWake < xTickCount) {
    8b20:	d905      	bls.n	8b2e <prvAddCurrentTaskToDelayedList+0x1e>
		vListInsert(pxOverflowDelayedTaskList, &(pxCurrentTCB->xGenericListItem));
    8b22:	6ba0      	ldr	r0, [r4, #56]	; 0x38
    8b24:	6b21      	ldr	r1, [r4, #48]	; 0x30
}
    8b26:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		vListInsert(pxOverflowDelayedTaskList, &(pxCurrentTCB->xGenericListItem));
    8b2a:	3104      	adds	r1, #4
    8b2c:	4718      	bx	r3
		vListInsert(pxDelayedTaskList, &(pxCurrentTCB->xGenericListItem));
    8b2e:	6aa0      	ldr	r0, [r4, #40]	; 0x28
    8b30:	6b21      	ldr	r1, [r4, #48]	; 0x30
    8b32:	3104      	adds	r1, #4
    8b34:	4798      	blx	r3
		if (xTimeToWake < xNextTaskUnblockTime) {
    8b36:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
    8b38:	429d      	cmp	r5, r3
			xNextTaskUnblockTime = xTimeToWake;
    8b3a:	bf38      	it	cc
    8b3c:	62e5      	strcc	r5, [r4, #44]	; 0x2c
}
    8b3e:	bd70      	pop	{r4, r5, r6, pc}
    8b40:	20016274 	.word	0x20016274
    8b44:	00001e2d 	.word	0x00001e2d

00008b48 <xTaskGenericCreate>:
{
    8b48:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    8b4c:	9f0a      	ldr	r7, [sp, #40]	; 0x28
    8b4e:	9e0c      	ldr	r6, [sp, #48]	; 0x30
    8b50:	4688      	mov	r8, r1
    8b52:	4615      	mov	r5, r2
    8b54:	469a      	mov	sl, r3
	configASSERT(pxTaskCode);
    8b56:	4681      	mov	r9, r0
    8b58:	b940      	cbnz	r0, 8b6c <xTaskGenericCreate+0x24>
    8b5a:	f04f 0380 	mov.w	r3, #128	; 0x80
    8b5e:	f383 8811 	msr	BASEPRI, r3
    8b62:	f3bf 8f6f 	isb	sy
    8b66:	f3bf 8f4f 	dsb	sy
    8b6a:	e7fe      	b.n	8b6a <xTaskGenericCreate+0x22>
	configASSERT(((uxPriority & (UBaseType_t)(~portPRIVILEGE_BIT)) < (UBaseType_t)configMAX_PRIORITIES));
    8b6c:	2f04      	cmp	r7, #4
    8b6e:	d908      	bls.n	8b82 <xTaskGenericCreate+0x3a>
    8b70:	f04f 0380 	mov.w	r3, #128	; 0x80
    8b74:	f383 8811 	msr	BASEPRI, r3
    8b78:	f3bf 8f6f 	isb	sy
    8b7c:	f3bf 8f4f 	dsb	sy
    8b80:	e7fe      	b.n	8b80 <xTaskGenericCreate+0x38>
		pxStack = (StackType_t *)pvPortMallocAligned(
    8b82:	4c56      	ldr	r4, [pc, #344]	; (8cdc <xTaskGenericCreate+0x194>)
    8b84:	b92e      	cbnz	r6, 8b92 <xTaskGenericCreate+0x4a>
    8b86:	0090      	lsls	r0, r2, #2
    8b88:	47a0      	blx	r4
		if (pxStack != NULL) {
    8b8a:	4606      	mov	r6, r0
    8b8c:	2800      	cmp	r0, #0
    8b8e:	f000 8096 	beq.w	8cbe <xTaskGenericCreate+0x176>
			pxNewTCB = (TCB_t *)pvPortMalloc(sizeof(TCB_t));
    8b92:	2054      	movs	r0, #84	; 0x54
    8b94:	47a0      	blx	r4
			if (pxNewTCB != NULL) {
    8b96:	4604      	mov	r4, r0
    8b98:	2800      	cmp	r0, #0
    8b9a:	f000 808d 	beq.w	8cb8 <xTaskGenericCreate+0x170>
			(void)memset(pxNewTCB->pxStack, (int)tskSTACK_FILL_BYTE, (size_t)usStackDepth * sizeof(StackType_t));
    8b9e:	00ad      	lsls	r5, r5, #2
    8ba0:	462a      	mov	r2, r5
    8ba2:	4b4f      	ldr	r3, [pc, #316]	; (8ce0 <xTaskGenericCreate+0x198>)
				pxNewTCB->pxStack = pxStack;
    8ba4:	6306      	str	r6, [r0, #48]	; 0x30
			(void)memset(pxNewTCB->pxStack, (int)tskSTACK_FILL_BYTE, (size_t)usStackDepth * sizeof(StackType_t));
    8ba6:	21a5      	movs	r1, #165	; 0xa5
    8ba8:	4630      	mov	r0, r6
    8baa:	4798      	blx	r3
			pxTopOfStack = pxNewTCB->pxStack + (usStackDepth - (uint16_t)1);
    8bac:	6b22      	ldr	r2, [r4, #48]	; 0x30
    8bae:	3d04      	subs	r5, #4
    8bb0:	4415      	add	r5, r2
    8bb2:	f108 33ff 	add.w	r3, r8, #4294967295	; 0xffffffff
			                      & (~((portPOINTER_SIZE_TYPE)
    8bb6:	f025 0507 	bic.w	r5, r5, #7
	for (x = (UBaseType_t)0; x < (UBaseType_t)configMAX_TASK_NAME_LEN; x++) {
    8bba:	f104 0234 	add.w	r2, r4, #52	; 0x34
    8bbe:	f108 0807 	add.w	r8, r8, #7
		pxTCB->pcTaskName[x] = pcName[x];
    8bc2:	f813 1f01 	ldrb.w	r1, [r3, #1]!
    8bc6:	f802 1b01 	strb.w	r1, [r2], #1
		if (pcName[x] == 0x00) {
    8bca:	b109      	cbz	r1, 8bd0 <xTaskGenericCreate+0x88>
	for (x = (UBaseType_t)0; x < (UBaseType_t)configMAX_TASK_NAME_LEN; x++) {
    8bcc:	4598      	cmp	r8, r3
    8bce:	d1f8      	bne.n	8bc2 <xTaskGenericCreate+0x7a>
	pxTCB->pcTaskName[configMAX_TASK_NAME_LEN - 1] = '\0';
    8bd0:	2600      	movs	r6, #0
	vListInitialiseItem(&(pxTCB->xGenericListItem));
    8bd2:	f104 0804 	add.w	r8, r4, #4
    8bd6:	f8df b128 	ldr.w	fp, [pc, #296]	; 8d00 <xTaskGenericCreate+0x1b8>
	pxTCB->pcTaskName[configMAX_TASK_NAME_LEN - 1] = '\0';
    8bda:	f884 603b 	strb.w	r6, [r4, #59]	; 0x3b
	vListInitialiseItem(&(pxTCB->xGenericListItem));
    8bde:	4640      	mov	r0, r8
		pxTCB->uxMutexesHeld  = 0;
    8be0:	e9c4 7611 	strd	r7, r6, [r4, #68]	; 0x44
	pxTCB->uxPriority = uxPriority;
    8be4:	62e7      	str	r7, [r4, #44]	; 0x2c
	vListInitialiseItem(&(pxTCB->xGenericListItem));
    8be6:	47d8      	blx	fp
	vListInitialiseItem(&(pxTCB->xEventListItem));
    8be8:	f104 0018 	add.w	r0, r4, #24
    8bec:	47d8      	blx	fp
	listSET_LIST_ITEM_VALUE(
    8bee:	f1c7 0305 	rsb	r3, r7, #5
    8bf2:	61a3      	str	r3, [r4, #24]
		pxTCB->ulNotifiedValue = 0;
    8bf4:	64e6      	str	r6, [r4, #76]	; 0x4c
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack(pxTopOfStack, pxTaskCode, pvParameters);
    8bf6:	4b3b      	ldr	r3, [pc, #236]	; (8ce4 <xTaskGenericCreate+0x19c>)
	listSET_LIST_ITEM_OWNER(&(pxTCB->xGenericListItem), pxTCB);
    8bf8:	6124      	str	r4, [r4, #16]
	listSET_LIST_ITEM_OWNER(&(pxTCB->xEventListItem), pxTCB);
    8bfa:	6264      	str	r4, [r4, #36]	; 0x24
		pxTCB->eNotifyState    = eNotWaitingNotification;
    8bfc:	f884 6050 	strb.w	r6, [r4, #80]	; 0x50
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack(pxTopOfStack, pxTaskCode, pvParameters);
    8c00:	4652      	mov	r2, sl
    8c02:	4649      	mov	r1, r9
    8c04:	4628      	mov	r0, r5
    8c06:	4798      	blx	r3
		if ((void *)pxCreatedTask != NULL) {
    8c08:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack(pxTopOfStack, pxTaskCode, pvParameters);
    8c0a:	6020      	str	r0, [r4, #0]
		if ((void *)pxCreatedTask != NULL) {
    8c0c:	b103      	cbz	r3, 8c10 <xTaskGenericCreate+0xc8>
			*pxCreatedTask = (TaskHandle_t)pxNewTCB;
    8c0e:	601c      	str	r4, [r3, #0]
			uxCurrentNumberOfTasks++;
    8c10:	4d35      	ldr	r5, [pc, #212]	; (8ce8 <xTaskGenericCreate+0x1a0>)
		taskENTER_CRITICAL();
    8c12:	4b36      	ldr	r3, [pc, #216]	; (8cec <xTaskGenericCreate+0x1a4>)
    8c14:	4798      	blx	r3
			uxCurrentNumberOfTasks++;
    8c16:	6beb      	ldr	r3, [r5, #60]	; 0x3c
    8c18:	3301      	adds	r3, #1
    8c1a:	63eb      	str	r3, [r5, #60]	; 0x3c
			if (pxCurrentTCB == NULL) {
    8c1c:	6b2e      	ldr	r6, [r5, #48]	; 0x30
    8c1e:	f105 0a40 	add.w	sl, r5, #64	; 0x40
    8c22:	2e00      	cmp	r6, #0
    8c24:	d14f      	bne.n	8cc6 <xTaskGenericCreate+0x17e>
				pxCurrentTCB = pxNewTCB;
    8c26:	632c      	str	r4, [r5, #48]	; 0x30
				if (uxCurrentNumberOfTasks == (UBaseType_t)1) {
    8c28:	6beb      	ldr	r3, [r5, #60]	; 0x3c
    8c2a:	2b01      	cmp	r3, #1
    8c2c:	d11c      	bne.n	8c68 <xTaskGenericCreate+0x120>
		vListInitialise(&(pxReadyTasksLists[uxPriority]));
    8c2e:	f8df 90d4 	ldr.w	r9, [pc, #212]	; 8d04 <xTaskGenericCreate+0x1bc>
    8c32:	46d3      	mov	fp, sl
    8c34:	4658      	mov	r0, fp
	for (uxPriority = (UBaseType_t)0U; uxPriority < (UBaseType_t)configMAX_PRIORITIES; uxPriority++) {
    8c36:	3601      	adds	r6, #1
		vListInitialise(&(pxReadyTasksLists[uxPriority]));
    8c38:	47c8      	blx	r9
	for (uxPriority = (UBaseType_t)0U; uxPriority < (UBaseType_t)configMAX_PRIORITIES; uxPriority++) {
    8c3a:	2e05      	cmp	r6, #5
    8c3c:	f10b 0b14 	add.w	fp, fp, #20
    8c40:	d1f8      	bne.n	8c34 <xTaskGenericCreate+0xec>
	vListInitialise(&xDelayedTaskList1);
    8c42:	4e2b      	ldr	r6, [pc, #172]	; (8cf0 <xTaskGenericCreate+0x1a8>)
    8c44:	4630      	mov	r0, r6
	vListInitialise(&xDelayedTaskList2);
    8c46:	f106 0b14 	add.w	fp, r6, #20
	vListInitialise(&xDelayedTaskList1);
    8c4a:	47c8      	blx	r9
	vListInitialise(&xDelayedTaskList2);
    8c4c:	4658      	mov	r0, fp
    8c4e:	47c8      	blx	r9
	vListInitialise(&xPendingReadyList);
    8c50:	f1a6 0090 	sub.w	r0, r6, #144	; 0x90
    8c54:	47c8      	blx	r9
		vListInitialise(&xTasksWaitingTermination);
    8c56:	f106 0028 	add.w	r0, r6, #40	; 0x28
    8c5a:	47c8      	blx	r9
		vListInitialise(&xSuspendedTaskList);
    8c5c:	f1a6 00a4 	sub.w	r0, r6, #164	; 0xa4
    8c60:	47c8      	blx	r9
	pxDelayedTaskList         = &xDelayedTaskList1;
    8c62:	62ae      	str	r6, [r5, #40]	; 0x28
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
    8c64:	f8c5 b038 	str.w	fp, [r5, #56]	; 0x38
			uxTaskNumber++;
    8c68:	f8d5 30e4 	ldr.w	r3, [r5, #228]	; 0xe4
			prvAddTaskToReadyList(pxNewTCB);
    8c6c:	f8d5 20e8 	ldr.w	r2, [r5, #232]	; 0xe8
			uxTaskNumber++;
    8c70:	3301      	adds	r3, #1
    8c72:	f8c5 30e4 	str.w	r3, [r5, #228]	; 0xe4
				pxNewTCB->uxTCBNumber = uxTaskNumber;
    8c76:	63e3      	str	r3, [r4, #60]	; 0x3c
			prvAddTaskToReadyList(pxNewTCB);
    8c78:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
    8c7a:	2014      	movs	r0, #20
    8c7c:	4293      	cmp	r3, r2
    8c7e:	bf88      	it	hi
    8c80:	f8c5 30e8 	strhi.w	r3, [r5, #232]	; 0xe8
    8c84:	fb00 a003 	mla	r0, r0, r3, sl
    8c88:	4641      	mov	r1, r8
    8c8a:	4b1a      	ldr	r3, [pc, #104]	; (8cf4 <xTaskGenericCreate+0x1ac>)
    8c8c:	4798      	blx	r3
		taskEXIT_CRITICAL();
    8c8e:	4b1a      	ldr	r3, [pc, #104]	; (8cf8 <xTaskGenericCreate+0x1b0>)
    8c90:	4798      	blx	r3
		if (xSchedulerRunning != pdFALSE) {
    8c92:	f8d5 30e0 	ldr.w	r3, [r5, #224]	; 0xe0
    8c96:	b16b      	cbz	r3, 8cb4 <xTaskGenericCreate+0x16c>
			if (pxCurrentTCB->uxPriority < uxPriority) {
    8c98:	6b2b      	ldr	r3, [r5, #48]	; 0x30
    8c9a:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    8c9c:	42bb      	cmp	r3, r7
    8c9e:	d209      	bcs.n	8cb4 <xTaskGenericCreate+0x16c>
				taskYIELD_IF_USING_PREEMPTION();
    8ca0:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
    8ca4:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
    8ca8:	f8c3 2d04 	str.w	r2, [r3, #3332]	; 0xd04
    8cac:	f3bf 8f4f 	dsb	sy
    8cb0:	f3bf 8f6f 	isb	sy
			xReturn = pdPASS;
    8cb4:	2001      	movs	r0, #1
	return xReturn;
    8cb6:	e004      	b.n	8cc2 <xTaskGenericCreate+0x17a>
				vPortFree(pxStack);
    8cb8:	4b10      	ldr	r3, [pc, #64]	; (8cfc <xTaskGenericCreate+0x1b4>)
    8cba:	4630      	mov	r0, r6
    8cbc:	4798      	blx	r3
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    8cbe:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
}
    8cc2:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
				if (xSchedulerRunning == pdFALSE) {
    8cc6:	f8d5 30e0 	ldr.w	r3, [r5, #224]	; 0xe0
    8cca:	2b00      	cmp	r3, #0
    8ccc:	d1cc      	bne.n	8c68 <xTaskGenericCreate+0x120>
					if (pxCurrentTCB->uxPriority <= uxPriority) {
    8cce:	6b2b      	ldr	r3, [r5, #48]	; 0x30
    8cd0:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    8cd2:	42bb      	cmp	r3, r7
						pxCurrentTCB = pxNewTCB;
    8cd4:	bf98      	it	ls
    8cd6:	632c      	strls	r4, [r5, #48]	; 0x30
    8cd8:	e7c6      	b.n	8c68 <xTaskGenericCreate+0x120>
    8cda:	bf00      	nop
    8cdc:	00001cfd 	.word	0x00001cfd
    8ce0:	0000c099 	.word	0x0000c099
    8ce4:	00009d15 	.word	0x00009d15
    8ce8:	20016274 	.word	0x20016274
    8cec:	00009d59 	.word	0x00009d59
    8cf0:	20016318 	.word	0x20016318
    8cf4:	00001e15 	.word	0x00001e15
    8cf8:	00009d99 	.word	0x00009d99
    8cfc:	00001db1 	.word	0x00001db1
    8d00:	00001e0f 	.word	0x00001e0f
    8d04:	00001df9 	.word	0x00001df9

00008d08 <vTaskStartScheduler>:
{
    8d08:	b530      	push	{r4, r5, lr}
		xReturn = xTaskCreate(prvIdleTask,
    8d0a:	2400      	movs	r4, #0
{
    8d0c:	b085      	sub	sp, #20
		xReturn = xTaskCreate(prvIdleTask,
    8d0e:	e9cd 4402 	strd	r4, r4, [sp, #8]
    8d12:	e9cd 4400 	strd	r4, r4, [sp]
    8d16:	4916      	ldr	r1, [pc, #88]	; (8d70 <vTaskStartScheduler+0x68>)
    8d18:	4816      	ldr	r0, [pc, #88]	; (8d74 <vTaskStartScheduler+0x6c>)
    8d1a:	4d17      	ldr	r5, [pc, #92]	; (8d78 <vTaskStartScheduler+0x70>)
    8d1c:	4623      	mov	r3, r4
    8d1e:	2240      	movs	r2, #64	; 0x40
    8d20:	47a8      	blx	r5
		if (xReturn == pdPASS) {
    8d22:	2801      	cmp	r0, #1
    8d24:	d117      	bne.n	8d56 <vTaskStartScheduler+0x4e>
			xReturn = xTimerCreateTimerTask();
    8d26:	4b15      	ldr	r3, [pc, #84]	; (8d7c <vTaskStartScheduler+0x74>)
    8d28:	4798      	blx	r3
	if (xReturn == pdPASS) {
    8d2a:	2801      	cmp	r0, #1
    8d2c:	d113      	bne.n	8d56 <vTaskStartScheduler+0x4e>
    8d2e:	f04f 0380 	mov.w	r3, #128	; 0x80
    8d32:	f383 8811 	msr	BASEPRI, r3
    8d36:	f3bf 8f6f 	isb	sy
    8d3a:	f3bf 8f4f 	dsb	sy
		xNextTaskUnblockTime = portMAX_DELAY;
    8d3e:	4b10      	ldr	r3, [pc, #64]	; (8d80 <vTaskStartScheduler+0x78>)
    8d40:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
    8d44:	62da      	str	r2, [r3, #44]	; 0x2c
		xSchedulerRunning    = pdTRUE;
    8d46:	f8c3 00e0 	str.w	r0, [r3, #224]	; 0xe0
		xTickCount           = (TickType_t)0U;
    8d4a:	635c      	str	r4, [r3, #52]	; 0x34
		if (xPortStartScheduler() != pdFALSE) {
    8d4c:	4b0d      	ldr	r3, [pc, #52]	; (8d84 <vTaskStartScheduler+0x7c>)
}
    8d4e:	b005      	add	sp, #20
    8d50:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
		if (xPortStartScheduler() != pdFALSE) {
    8d54:	4718      	bx	r3
		configASSERT(xReturn);
    8d56:	b940      	cbnz	r0, 8d6a <vTaskStartScheduler+0x62>
    8d58:	f04f 0380 	mov.w	r3, #128	; 0x80
    8d5c:	f383 8811 	msr	BASEPRI, r3
    8d60:	f3bf 8f6f 	isb	sy
    8d64:	f3bf 8f4f 	dsb	sy
    8d68:	e7fe      	b.n	8d68 <vTaskStartScheduler+0x60>
}
    8d6a:	b005      	add	sp, #20
    8d6c:	bd30      	pop	{r4, r5, pc}
    8d6e:	bf00      	nop
    8d70:	0000cc94 	.word	0x0000cc94
    8d74:	00008ff1 	.word	0x00008ff1
    8d78:	00008b49 	.word	0x00008b49
    8d7c:	0000800d 	.word	0x0000800d
    8d80:	20016274 	.word	0x20016274
    8d84:	00009e65 	.word	0x00009e65

00008d88 <vTaskSuspendAll>:
	++uxSchedulerSuspended;
    8d88:	4a03      	ldr	r2, [pc, #12]	; (8d98 <vTaskSuspendAll+0x10>)
    8d8a:	f8d2 30f0 	ldr.w	r3, [r2, #240]	; 0xf0
    8d8e:	3301      	adds	r3, #1
    8d90:	f8c2 30f0 	str.w	r3, [r2, #240]	; 0xf0
}
    8d94:	4770      	bx	lr
    8d96:	bf00      	nop
    8d98:	20016274 	.word	0x20016274

00008d9c <xTaskGetTickCount>:
		xTicks = xTickCount;
    8d9c:	4b01      	ldr	r3, [pc, #4]	; (8da4 <xTaskGetTickCount+0x8>)
    8d9e:	6b58      	ldr	r0, [r3, #52]	; 0x34
}
    8da0:	4770      	bx	lr
    8da2:	bf00      	nop
    8da4:	20016274 	.word	0x20016274

00008da8 <xTaskIncrementTick>:
{
    8da8:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
	if (uxSchedulerSuspended == (UBaseType_t)pdFALSE) {
    8dac:	4c36      	ldr	r4, [pc, #216]	; (8e88 <xTaskIncrementTick+0xe0>)
    8dae:	f8d4 30f0 	ldr.w	r3, [r4, #240]	; 0xf0
    8db2:	2b00      	cmp	r3, #0
    8db4:	d160      	bne.n	8e78 <xTaskIncrementTick+0xd0>
		++xTickCount;
    8db6:	6b63      	ldr	r3, [r4, #52]	; 0x34
    8db8:	3301      	adds	r3, #1
    8dba:	6363      	str	r3, [r4, #52]	; 0x34
			const TickType_t xConstTickCount = xTickCount;
    8dbc:	6b67      	ldr	r7, [r4, #52]	; 0x34
			if (xConstTickCount == (TickType_t)0U) {
    8dbe:	b9b7      	cbnz	r7, 8dee <xTaskIncrementTick+0x46>
				taskSWITCH_DELAYED_LISTS();
    8dc0:	6aa3      	ldr	r3, [r4, #40]	; 0x28
    8dc2:	681b      	ldr	r3, [r3, #0]
    8dc4:	b143      	cbz	r3, 8dd8 <xTaskIncrementTick+0x30>
    8dc6:	f04f 0380 	mov.w	r3, #128	; 0x80
    8dca:	f383 8811 	msr	BASEPRI, r3
    8dce:	f3bf 8f6f 	isb	sy
    8dd2:	f3bf 8f4f 	dsb	sy
    8dd6:	e7fe      	b.n	8dd6 <xTaskIncrementTick+0x2e>
    8dd8:	6aa3      	ldr	r3, [r4, #40]	; 0x28
    8dda:	6ba2      	ldr	r2, [r4, #56]	; 0x38
    8ddc:	62a2      	str	r2, [r4, #40]	; 0x28
    8dde:	63a3      	str	r3, [r4, #56]	; 0x38
    8de0:	f8d4 30f4 	ldr.w	r3, [r4, #244]	; 0xf4
    8de4:	3301      	adds	r3, #1
    8de6:	f8c4 30f4 	str.w	r3, [r4, #244]	; 0xf4
    8dea:	4b28      	ldr	r3, [pc, #160]	; (8e8c <xTaskIncrementTick+0xe4>)
    8dec:	4798      	blx	r3
			if (xConstTickCount >= xNextTaskUnblockTime) {
    8dee:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
    8df0:	42bb      	cmp	r3, r7
	BaseType_t xSwitchRequired = pdFALSE;
    8df2:	f04f 0500 	mov.w	r5, #0
			if (xConstTickCount >= xNextTaskUnblockTime) {
    8df6:	d910      	bls.n	8e1a <xTaskIncrementTick+0x72>
			if (listCURRENT_LIST_LENGTH(&(pxReadyTasksLists[pxCurrentTCB->uxPriority])) > (UBaseType_t)1) {
    8df8:	6b23      	ldr	r3, [r4, #48]	; 0x30
    8dfa:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    8dfc:	2214      	movs	r2, #20
    8dfe:	fb02 4303 	mla	r3, r2, r3, r4
    8e02:	6c1b      	ldr	r3, [r3, #64]	; 0x40
				xSwitchRequired = pdTRUE;
    8e04:	2b02      	cmp	r3, #2
    8e06:	bf28      	it	cs
    8e08:	2501      	movcs	r5, #1
		if (xYieldPending != pdFALSE) {
    8e0a:	f8d4 30fc 	ldr.w	r3, [r4, #252]	; 0xfc
			xSwitchRequired = pdTRUE;
    8e0e:	2b00      	cmp	r3, #0
}
    8e10:	bf0c      	ite	eq
    8e12:	4628      	moveq	r0, r5
    8e14:	2001      	movne	r0, #1
    8e16:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
						(void)uxListRemove(&(pxTCB->xGenericListItem));
    8e1a:	f8df 8074 	ldr.w	r8, [pc, #116]	; 8e90 <xTaskIncrementTick+0xe8>
						prvAddTaskToReadyList(pxTCB);
    8e1e:	f8df a074 	ldr.w	sl, [pc, #116]	; 8e94 <xTaskIncrementTick+0xec>
    8e22:	f8df 9074 	ldr.w	r9, [pc, #116]	; 8e98 <xTaskIncrementTick+0xf0>
					if (listLIST_IS_EMPTY(pxDelayedTaskList) != pdFALSE) {
    8e26:	6aa3      	ldr	r3, [r4, #40]	; 0x28
    8e28:	681b      	ldr	r3, [r3, #0]
    8e2a:	b91b      	cbnz	r3, 8e34 <xTaskIncrementTick+0x8c>
						xNextTaskUnblockTime = portMAX_DELAY;
    8e2c:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
							xNextTaskUnblockTime = xItemValue;
    8e30:	62e3      	str	r3, [r4, #44]	; 0x2c
							break;
    8e32:	e7e1      	b.n	8df8 <xTaskIncrementTick+0x50>
						pxTCB      = (TCB_t *)listGET_OWNER_OF_HEAD_ENTRY(pxDelayedTaskList);
    8e34:	6aa3      	ldr	r3, [r4, #40]	; 0x28
    8e36:	68db      	ldr	r3, [r3, #12]
    8e38:	68de      	ldr	r6, [r3, #12]
						xItemValue = listGET_LIST_ITEM_VALUE(&(pxTCB->xGenericListItem));
    8e3a:	6873      	ldr	r3, [r6, #4]
						if (xConstTickCount < xItemValue) {
    8e3c:	429f      	cmp	r7, r3
    8e3e:	d3f7      	bcc.n	8e30 <xTaskIncrementTick+0x88>
						(void)uxListRemove(&(pxTCB->xGenericListItem));
    8e40:	f106 0b04 	add.w	fp, r6, #4
    8e44:	4658      	mov	r0, fp
    8e46:	47c0      	blx	r8
						if (listLIST_ITEM_CONTAINER(&(pxTCB->xEventListItem)) != NULL) {
    8e48:	6ab3      	ldr	r3, [r6, #40]	; 0x28
    8e4a:	b113      	cbz	r3, 8e52 <xTaskIncrementTick+0xaa>
							(void)uxListRemove(&(pxTCB->xEventListItem));
    8e4c:	f106 0018 	add.w	r0, r6, #24
    8e50:	47c0      	blx	r8
						prvAddTaskToReadyList(pxTCB);
    8e52:	6af3      	ldr	r3, [r6, #44]	; 0x2c
    8e54:	f8d4 20e8 	ldr.w	r2, [r4, #232]	; 0xe8
    8e58:	2014      	movs	r0, #20
    8e5a:	4293      	cmp	r3, r2
    8e5c:	fb00 a003 	mla	r0, r0, r3, sl
    8e60:	4659      	mov	r1, fp
    8e62:	bf88      	it	hi
    8e64:	f8c4 30e8 	strhi.w	r3, [r4, #232]	; 0xe8
    8e68:	47c8      	blx	r9
							if (pxTCB->uxPriority >= pxCurrentTCB->uxPriority) {
    8e6a:	6b23      	ldr	r3, [r4, #48]	; 0x30
    8e6c:	6af2      	ldr	r2, [r6, #44]	; 0x2c
    8e6e:	6adb      	ldr	r3, [r3, #44]	; 0x2c
								xSwitchRequired = pdTRUE;
    8e70:	429a      	cmp	r2, r3
    8e72:	bf28      	it	cs
    8e74:	2501      	movcs	r5, #1
    8e76:	e7d6      	b.n	8e26 <xTaskIncrementTick+0x7e>
		++uxPendedTicks;
    8e78:	f8d4 30f8 	ldr.w	r3, [r4, #248]	; 0xf8
    8e7c:	3301      	adds	r3, #1
    8e7e:	f8c4 30f8 	str.w	r3, [r4, #248]	; 0xf8
	BaseType_t xSwitchRequired = pdFALSE;
    8e82:	2500      	movs	r5, #0
    8e84:	e7c1      	b.n	8e0a <xTaskIncrementTick+0x62>
    8e86:	bf00      	nop
    8e88:	20016274 	.word	0x20016274
    8e8c:	00008af1 	.word	0x00008af1
    8e90:	00001e5b 	.word	0x00001e5b
    8e94:	200162b4 	.word	0x200162b4
    8e98:	00001e15 	.word	0x00001e15

00008e9c <xTaskResumeAll>:
{
    8e9c:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
	configASSERT(uxSchedulerSuspended);
    8ea0:	4c33      	ldr	r4, [pc, #204]	; (8f70 <xTaskResumeAll+0xd4>)
    8ea2:	f8d4 30f0 	ldr.w	r3, [r4, #240]	; 0xf0
    8ea6:	b943      	cbnz	r3, 8eba <xTaskResumeAll+0x1e>
    8ea8:	f04f 0380 	mov.w	r3, #128	; 0x80
    8eac:	f383 8811 	msr	BASEPRI, r3
    8eb0:	f3bf 8f6f 	isb	sy
    8eb4:	f3bf 8f4f 	dsb	sy
    8eb8:	e7fe      	b.n	8eb8 <xTaskResumeAll+0x1c>
	taskENTER_CRITICAL();
    8eba:	4b2e      	ldr	r3, [pc, #184]	; (8f74 <xTaskResumeAll+0xd8>)
    8ebc:	4798      	blx	r3
		--uxSchedulerSuspended;
    8ebe:	f8d4 30f0 	ldr.w	r3, [r4, #240]	; 0xf0
    8ec2:	3b01      	subs	r3, #1
    8ec4:	f8c4 30f0 	str.w	r3, [r4, #240]	; 0xf0
		if (uxSchedulerSuspended == (UBaseType_t)pdFALSE) {
    8ec8:	f8d4 30f0 	ldr.w	r3, [r4, #240]	; 0xf0
    8ecc:	b133      	cbz	r3, 8edc <xTaskResumeAll+0x40>
	BaseType_t xAlreadyYielded = pdFALSE;
    8ece:	2400      	movs	r4, #0
	taskEXIT_CRITICAL();
    8ed0:	4b29      	ldr	r3, [pc, #164]	; (8f78 <xTaskResumeAll+0xdc>)
    8ed2:	4798      	blx	r3
}
    8ed4:	4620      	mov	r0, r4
    8ed6:	b002      	add	sp, #8
    8ed8:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
			if (uxCurrentNumberOfTasks > (UBaseType_t)0U) {
    8edc:	6be3      	ldr	r3, [r4, #60]	; 0x3c
    8ede:	2b00      	cmp	r3, #0
    8ee0:	d0f5      	beq.n	8ece <xTaskResumeAll+0x32>
					(void)uxListRemove(&(pxTCB->xEventListItem));
    8ee2:	4e26      	ldr	r6, [pc, #152]	; (8f7c <xTaskResumeAll+0xe0>)
					prvAddTaskToReadyList(pxTCB);
    8ee4:	f104 0740 	add.w	r7, r4, #64	; 0x40
    8ee8:	f8df 8098 	ldr.w	r8, [pc, #152]	; 8f84 <xTaskResumeAll+0xe8>
				while (listLIST_IS_EMPTY(&xPendingReadyList) == pdFALSE) {
    8eec:	6963      	ldr	r3, [r4, #20]
    8eee:	b9b3      	cbnz	r3, 8f1e <xTaskResumeAll+0x82>
				if (uxPendedTicks > (UBaseType_t)0U) {
    8ef0:	f8d4 30f8 	ldr.w	r3, [r4, #248]	; 0xf8
    8ef4:	b123      	cbz	r3, 8f00 <xTaskResumeAll+0x64>
						if (xTaskIncrementTick() != pdFALSE) {
    8ef6:	4d22      	ldr	r5, [pc, #136]	; (8f80 <xTaskResumeAll+0xe4>)
							xYieldPending = pdTRUE;
    8ef8:	2601      	movs	r6, #1
					while (uxPendedTicks > (UBaseType_t)0U) {
    8efa:	f8d4 30f8 	ldr.w	r3, [r4, #248]	; 0xf8
    8efe:	bb63      	cbnz	r3, 8f5a <xTaskResumeAll+0xbe>
				if (xYieldPending == pdTRUE) {
    8f00:	f8d4 40fc 	ldr.w	r4, [r4, #252]	; 0xfc
    8f04:	2c01      	cmp	r4, #1
    8f06:	d1e2      	bne.n	8ece <xTaskResumeAll+0x32>
					taskYIELD_IF_USING_PREEMPTION();
    8f08:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
    8f0c:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
    8f10:	f8c3 2d04 	str.w	r2, [r3, #3332]	; 0xd04
    8f14:	f3bf 8f4f 	dsb	sy
    8f18:	f3bf 8f6f 	isb	sy
    8f1c:	e7d8      	b.n	8ed0 <xTaskResumeAll+0x34>
					pxTCB = (TCB_t *)listGET_OWNER_OF_HEAD_ENTRY((&xPendingReadyList));
    8f1e:	6a23      	ldr	r3, [r4, #32]
    8f20:	68dd      	ldr	r5, [r3, #12]
					(void)uxListRemove(&(pxTCB->xEventListItem));
    8f22:	f105 0018 	add.w	r0, r5, #24
    8f26:	47b0      	blx	r6
					(void)uxListRemove(&(pxTCB->xGenericListItem));
    8f28:	1d29      	adds	r1, r5, #4
    8f2a:	4608      	mov	r0, r1
    8f2c:	9101      	str	r1, [sp, #4]
    8f2e:	47b0      	blx	r6
					prvAddTaskToReadyList(pxTCB);
    8f30:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
    8f32:	f8d4 20e8 	ldr.w	r2, [r4, #232]	; 0xe8
    8f36:	9901      	ldr	r1, [sp, #4]
    8f38:	2014      	movs	r0, #20
    8f3a:	4293      	cmp	r3, r2
    8f3c:	fb00 7003 	mla	r0, r0, r3, r7
    8f40:	bf88      	it	hi
    8f42:	f8c4 30e8 	strhi.w	r3, [r4, #232]	; 0xe8
    8f46:	47c0      	blx	r8
					if (pxTCB->uxPriority >= pxCurrentTCB->uxPriority) {
    8f48:	6b23      	ldr	r3, [r4, #48]	; 0x30
    8f4a:	6aea      	ldr	r2, [r5, #44]	; 0x2c
    8f4c:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    8f4e:	429a      	cmp	r2, r3
    8f50:	d3cc      	bcc.n	8eec <xTaskResumeAll+0x50>
						xYieldPending = pdTRUE;
    8f52:	2301      	movs	r3, #1
    8f54:	f8c4 30fc 	str.w	r3, [r4, #252]	; 0xfc
    8f58:	e7c6      	b.n	8ee8 <xTaskResumeAll+0x4c>
						if (xTaskIncrementTick() != pdFALSE) {
    8f5a:	47a8      	blx	r5
    8f5c:	b108      	cbz	r0, 8f62 <xTaskResumeAll+0xc6>
							xYieldPending = pdTRUE;
    8f5e:	f8c4 60fc 	str.w	r6, [r4, #252]	; 0xfc
						--uxPendedTicks;
    8f62:	f8d4 30f8 	ldr.w	r3, [r4, #248]	; 0xf8
    8f66:	3b01      	subs	r3, #1
    8f68:	f8c4 30f8 	str.w	r3, [r4, #248]	; 0xf8
    8f6c:	e7c5      	b.n	8efa <xTaskResumeAll+0x5e>
    8f6e:	bf00      	nop
    8f70:	20016274 	.word	0x20016274
    8f74:	00009d59 	.word	0x00009d59
    8f78:	00009d99 	.word	0x00009d99
    8f7c:	00001e5b 	.word	0x00001e5b
    8f80:	00008da9 	.word	0x00008da9
    8f84:	00001e15 	.word	0x00001e15

00008f88 <vTaskDelay>:
{
    8f88:	b510      	push	{r4, lr}
	if (xTicksToDelay > (TickType_t)0U) {
    8f8a:	b950      	cbnz	r0, 8fa2 <vTaskDelay+0x1a>
		portYIELD_WITHIN_API();
    8f8c:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
    8f90:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
    8f94:	f8c3 2d04 	str.w	r2, [r3, #3332]	; 0xd04
    8f98:	f3bf 8f4f 	dsb	sy
    8f9c:	f3bf 8f6f 	isb	sy
}
    8fa0:	bd10      	pop	{r4, pc}
		configASSERT(uxSchedulerSuspended == 0);
    8fa2:	490e      	ldr	r1, [pc, #56]	; (8fdc <vTaskDelay+0x54>)
    8fa4:	f8d1 30f0 	ldr.w	r3, [r1, #240]	; 0xf0
    8fa8:	b143      	cbz	r3, 8fbc <vTaskDelay+0x34>
    8faa:	f04f 0380 	mov.w	r3, #128	; 0x80
    8fae:	f383 8811 	msr	BASEPRI, r3
    8fb2:	f3bf 8f6f 	isb	sy
    8fb6:	f3bf 8f4f 	dsb	sy
    8fba:	e7fe      	b.n	8fba <vTaskDelay+0x32>
		vTaskSuspendAll();
    8fbc:	4b08      	ldr	r3, [pc, #32]	; (8fe0 <vTaskDelay+0x58>)
    8fbe:	4798      	blx	r3
			xTimeToWake = xTickCount + xTicksToDelay;
    8fc0:	6b4c      	ldr	r4, [r1, #52]	; 0x34
			if (uxListRemove(&(pxCurrentTCB->xGenericListItem)) == (UBaseType_t)0) {
    8fc2:	4b08      	ldr	r3, [pc, #32]	; (8fe4 <vTaskDelay+0x5c>)
			xTimeToWake = xTickCount + xTicksToDelay;
    8fc4:	4404      	add	r4, r0
			if (uxListRemove(&(pxCurrentTCB->xGenericListItem)) == (UBaseType_t)0) {
    8fc6:	6b08      	ldr	r0, [r1, #48]	; 0x30
    8fc8:	3004      	adds	r0, #4
    8fca:	4798      	blx	r3
			prvAddCurrentTaskToDelayedList(xTimeToWake);
    8fcc:	4b06      	ldr	r3, [pc, #24]	; (8fe8 <vTaskDelay+0x60>)
    8fce:	4620      	mov	r0, r4
    8fd0:	4798      	blx	r3
		xAlreadyYielded = xTaskResumeAll();
    8fd2:	4b06      	ldr	r3, [pc, #24]	; (8fec <vTaskDelay+0x64>)
    8fd4:	4798      	blx	r3
	if (xAlreadyYielded == pdFALSE) {
    8fd6:	2800      	cmp	r0, #0
    8fd8:	d0d8      	beq.n	8f8c <vTaskDelay+0x4>
    8fda:	e7e1      	b.n	8fa0 <vTaskDelay+0x18>
    8fdc:	20016274 	.word	0x20016274
    8fe0:	00008d89 	.word	0x00008d89
    8fe4:	00001e5b 	.word	0x00001e5b
    8fe8:	00008b11 	.word	0x00008b11
    8fec:	00008e9d 	.word	0x00008e9d

00008ff0 <prvIdleTask>:
{
    8ff0:	b580      	push	{r7, lr}
		while (uxTasksDeleted > (UBaseType_t)0U) {
    8ff2:	4c19      	ldr	r4, [pc, #100]	; (9058 <prvIdleTask+0x68>)
			vTaskSuspendAll();
    8ff4:	4f19      	ldr	r7, [pc, #100]	; (905c <prvIdleTask+0x6c>)
			(void)xTaskResumeAll();
    8ff6:	4d1a      	ldr	r5, [pc, #104]	; (9060 <prvIdleTask+0x70>)
		while (uxTasksDeleted > (UBaseType_t)0U) {
    8ff8:	f8d4 30ec 	ldr.w	r3, [r4, #236]	; 0xec
    8ffc:	b96b      	cbnz	r3, 901a <prvIdleTask+0x2a>
			if (listCURRENT_LIST_LENGTH(&(pxReadyTasksLists[tskIDLE_PRIORITY])) > (UBaseType_t)1) {
    8ffe:	6c23      	ldr	r3, [r4, #64]	; 0x40
    9000:	2b01      	cmp	r3, #1
    9002:	d9f8      	bls.n	8ff6 <prvIdleTask+0x6>
				taskYIELD();
    9004:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
    9008:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
    900c:	f8c3 2d04 	str.w	r2, [r3, #3332]	; 0xd04
    9010:	f3bf 8f4f 	dsb	sy
    9014:	f3bf 8f6f 	isb	sy
    9018:	e7ed      	b.n	8ff6 <prvIdleTask+0x6>
			vTaskSuspendAll();
    901a:	47b8      	blx	r7
				xListIsEmpty = listLIST_IS_EMPTY(&xTasksWaitingTermination);
    901c:	f8d4 60cc 	ldr.w	r6, [r4, #204]	; 0xcc
			(void)xTaskResumeAll();
    9020:	47a8      	blx	r5
			if (xListIsEmpty == pdFALSE) {
    9022:	2e00      	cmp	r6, #0
    9024:	d0e8      	beq.n	8ff8 <prvIdleTask+0x8>
				taskENTER_CRITICAL();
    9026:	4b0f      	ldr	r3, [pc, #60]	; (9064 <prvIdleTask+0x74>)
		vPortFreeAligned(pxTCB->pxStack);
    9028:	4e0f      	ldr	r6, [pc, #60]	; (9068 <prvIdleTask+0x78>)
				taskENTER_CRITICAL();
    902a:	4798      	blx	r3
					pxTCB = (TCB_t *)listGET_OWNER_OF_HEAD_ENTRY((&xTasksWaitingTermination));
    902c:	f8d4 30d8 	ldr.w	r3, [r4, #216]	; 0xd8
    9030:	68dd      	ldr	r5, [r3, #12]
					(void)uxListRemove(&(pxTCB->xGenericListItem));
    9032:	4b0e      	ldr	r3, [pc, #56]	; (906c <prvIdleTask+0x7c>)
    9034:	1d28      	adds	r0, r5, #4
    9036:	4798      	blx	r3
					--uxCurrentNumberOfTasks;
    9038:	6be3      	ldr	r3, [r4, #60]	; 0x3c
    903a:	3b01      	subs	r3, #1
    903c:	63e3      	str	r3, [r4, #60]	; 0x3c
					--uxTasksDeleted;
    903e:	f8d4 30ec 	ldr.w	r3, [r4, #236]	; 0xec
    9042:	3b01      	subs	r3, #1
    9044:	f8c4 30ec 	str.w	r3, [r4, #236]	; 0xec
				taskEXIT_CRITICAL();
    9048:	4b09      	ldr	r3, [pc, #36]	; (9070 <prvIdleTask+0x80>)
    904a:	4798      	blx	r3
		vPortFreeAligned(pxTCB->pxStack);
    904c:	6b28      	ldr	r0, [r5, #48]	; 0x30
    904e:	47b0      	blx	r6
	vPortFree(pxTCB);
    9050:	4628      	mov	r0, r5
    9052:	47b0      	blx	r6
}
    9054:	e7cf      	b.n	8ff6 <prvIdleTask+0x6>
    9056:	bf00      	nop
    9058:	20016274 	.word	0x20016274
    905c:	00008d89 	.word	0x00008d89
    9060:	00008e9d 	.word	0x00008e9d
    9064:	00009d59 	.word	0x00009d59
    9068:	00001db1 	.word	0x00001db1
    906c:	00001e5b 	.word	0x00001e5b
    9070:	00009d99 	.word	0x00009d99

00009074 <vTaskSwitchContext>:
	if (uxSchedulerSuspended != (UBaseType_t)pdFALSE) {
    9074:	4b1b      	ldr	r3, [pc, #108]	; (90e4 <vTaskSwitchContext+0x70>)
    9076:	f8d3 20f0 	ldr.w	r2, [r3, #240]	; 0xf0
{
    907a:	b530      	push	{r4, r5, lr}
	if (uxSchedulerSuspended != (UBaseType_t)pdFALSE) {
    907c:	b11a      	cbz	r2, 9086 <vTaskSwitchContext+0x12>
		xYieldPending = pdTRUE;
    907e:	2201      	movs	r2, #1
    9080:	f8c3 20fc 	str.w	r2, [r3, #252]	; 0xfc
}
    9084:	bd30      	pop	{r4, r5, pc}
		xYieldPending = pdFALSE;
    9086:	f8c3 20fc 	str.w	r2, [r3, #252]	; 0xfc
		taskSELECT_HIGHEST_PRIORITY_TASK();
    908a:	2214      	movs	r2, #20
    908c:	f8d3 10e8 	ldr.w	r1, [r3, #232]	; 0xe8
    9090:	fb02 3101 	mla	r1, r2, r1, r3
    9094:	6c09      	ldr	r1, [r1, #64]	; 0x40
    9096:	b199      	cbz	r1, 90c0 <vTaskSwitchContext+0x4c>
    9098:	f8d3 10e8 	ldr.w	r1, [r3, #232]	; 0xe8
    909c:	4d12      	ldr	r5, [pc, #72]	; (90e8 <vTaskSwitchContext+0x74>)
    909e:	434a      	muls	r2, r1
    90a0:	1898      	adds	r0, r3, r2
    90a2:	442a      	add	r2, r5
    90a4:	6c44      	ldr	r4, [r0, #68]	; 0x44
    90a6:	6864      	ldr	r4, [r4, #4]
    90a8:	6444      	str	r4, [r0, #68]	; 0x44
    90aa:	4294      	cmp	r4, r2
    90ac:	bf04      	itt	eq
    90ae:	6862      	ldreq	r2, [r4, #4]
    90b0:	6442      	streq	r2, [r0, #68]	; 0x44
    90b2:	2214      	movs	r2, #20
    90b4:	fb02 3101 	mla	r1, r2, r1, r3
    90b8:	6c4a      	ldr	r2, [r1, #68]	; 0x44
    90ba:	68d2      	ldr	r2, [r2, #12]
    90bc:	631a      	str	r2, [r3, #48]	; 0x30
}
    90be:	e7e1      	b.n	9084 <vTaskSwitchContext+0x10>
		taskSELECT_HIGHEST_PRIORITY_TASK();
    90c0:	f8d3 10e8 	ldr.w	r1, [r3, #232]	; 0xe8
    90c4:	b941      	cbnz	r1, 90d8 <vTaskSwitchContext+0x64>
    90c6:	f04f 0380 	mov.w	r3, #128	; 0x80
    90ca:	f383 8811 	msr	BASEPRI, r3
    90ce:	f3bf 8f6f 	isb	sy
    90d2:	f3bf 8f4f 	dsb	sy
    90d6:	e7fe      	b.n	90d6 <vTaskSwitchContext+0x62>
    90d8:	f8d3 10e8 	ldr.w	r1, [r3, #232]	; 0xe8
    90dc:	3901      	subs	r1, #1
    90de:	f8c3 10e8 	str.w	r1, [r3, #232]	; 0xe8
    90e2:	e7d3      	b.n	908c <vTaskSwitchContext+0x18>
    90e4:	20016274 	.word	0x20016274
    90e8:	200162bc 	.word	0x200162bc

000090ec <vTaskPlaceOnEventList>:
{
    90ec:	b570      	push	{r4, r5, r6, lr}
    90ee:	460d      	mov	r5, r1
	configASSERT(pxEventList);
    90f0:	b940      	cbnz	r0, 9104 <vTaskPlaceOnEventList+0x18>
    90f2:	f04f 0380 	mov.w	r3, #128	; 0x80
    90f6:	f383 8811 	msr	BASEPRI, r3
    90fa:	f3bf 8f6f 	isb	sy
    90fe:	f3bf 8f4f 	dsb	sy
    9102:	e7fe      	b.n	9102 <vTaskPlaceOnEventList+0x16>
	vListInsert(pxEventList, &(pxCurrentTCB->xEventListItem));
    9104:	4c0b      	ldr	r4, [pc, #44]	; (9134 <vTaskPlaceOnEventList+0x48>)
    9106:	4b0c      	ldr	r3, [pc, #48]	; (9138 <vTaskPlaceOnEventList+0x4c>)
    9108:	6b21      	ldr	r1, [r4, #48]	; 0x30
    910a:	3118      	adds	r1, #24
    910c:	4798      	blx	r3
	if (uxListRemove(&(pxCurrentTCB->xGenericListItem)) == (UBaseType_t)0) {
    910e:	6b20      	ldr	r0, [r4, #48]	; 0x30
    9110:	4b0a      	ldr	r3, [pc, #40]	; (913c <vTaskPlaceOnEventList+0x50>)
    9112:	3004      	adds	r0, #4
    9114:	4798      	blx	r3
		if (xTicksToWait == portMAX_DELAY) {
    9116:	1c6b      	adds	r3, r5, #1
    9118:	d106      	bne.n	9128 <vTaskPlaceOnEventList+0x3c>
			vListInsertEnd(&xSuspendedTaskList, &(pxCurrentTCB->xGenericListItem));
    911a:	6b21      	ldr	r1, [r4, #48]	; 0x30
    911c:	4b08      	ldr	r3, [pc, #32]	; (9140 <vTaskPlaceOnEventList+0x54>)
    911e:	4620      	mov	r0, r4
    9120:	3104      	adds	r1, #4
}
    9122:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
			vListInsertEnd(&xSuspendedTaskList, &(pxCurrentTCB->xGenericListItem));
    9126:	4718      	bx	r3
			xTimeToWake = xTickCount + xTicksToWait;
    9128:	6b60      	ldr	r0, [r4, #52]	; 0x34
			prvAddCurrentTaskToDelayedList(xTimeToWake);
    912a:	4b06      	ldr	r3, [pc, #24]	; (9144 <vTaskPlaceOnEventList+0x58>)
    912c:	4428      	add	r0, r5
}
    912e:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
			prvAddCurrentTaskToDelayedList(xTimeToWake);
    9132:	4718      	bx	r3
    9134:	20016274 	.word	0x20016274
    9138:	00001e2d 	.word	0x00001e2d
    913c:	00001e5b 	.word	0x00001e5b
    9140:	00001e15 	.word	0x00001e15
    9144:	00008b11 	.word	0x00008b11

00009148 <vTaskPlaceOnEventListRestricted>:
{
    9148:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    914c:	460d      	mov	r5, r1
    914e:	4616      	mov	r6, r2
	configASSERT(pxEventList);
    9150:	b940      	cbnz	r0, 9164 <vTaskPlaceOnEventListRestricted+0x1c>
    9152:	f04f 0380 	mov.w	r3, #128	; 0x80
    9156:	f383 8811 	msr	BASEPRI, r3
    915a:	f3bf 8f6f 	isb	sy
    915e:	f3bf 8f4f 	dsb	sy
    9162:	e7fe      	b.n	9162 <vTaskPlaceOnEventListRestricted+0x1a>
	vListInsertEnd(pxEventList, &(pxCurrentTCB->xEventListItem));
    9164:	4c0b      	ldr	r4, [pc, #44]	; (9194 <vTaskPlaceOnEventListRestricted+0x4c>)
    9166:	4f0c      	ldr	r7, [pc, #48]	; (9198 <vTaskPlaceOnEventListRestricted+0x50>)
    9168:	6b21      	ldr	r1, [r4, #48]	; 0x30
    916a:	3118      	adds	r1, #24
    916c:	47b8      	blx	r7
	if (uxListRemove(&(pxCurrentTCB->xGenericListItem)) == (UBaseType_t)0) {
    916e:	6b20      	ldr	r0, [r4, #48]	; 0x30
    9170:	4b0a      	ldr	r3, [pc, #40]	; (919c <vTaskPlaceOnEventListRestricted+0x54>)
    9172:	3004      	adds	r0, #4
    9174:	4798      	blx	r3
		if (xWaitIndefinitely == pdTRUE) {
    9176:	2e01      	cmp	r6, #1
    9178:	d106      	bne.n	9188 <vTaskPlaceOnEventListRestricted+0x40>
			vListInsertEnd(&xSuspendedTaskList, &(pxCurrentTCB->xGenericListItem));
    917a:	6b21      	ldr	r1, [r4, #48]	; 0x30
    917c:	4620      	mov	r0, r4
    917e:	463b      	mov	r3, r7
    9180:	3104      	adds	r1, #4
}
    9182:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
			vListInsertEnd(&xSuspendedTaskList, &(pxCurrentTCB->xGenericListItem));
    9186:	4718      	bx	r3
			xTimeToWake = xTickCount + xTicksToWait;
    9188:	6b60      	ldr	r0, [r4, #52]	; 0x34
			prvAddCurrentTaskToDelayedList(xTimeToWake);
    918a:	4b05      	ldr	r3, [pc, #20]	; (91a0 <vTaskPlaceOnEventListRestricted+0x58>)
    918c:	4428      	add	r0, r5
}
    918e:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
			prvAddCurrentTaskToDelayedList(xTimeToWake);
    9192:	4718      	bx	r3
    9194:	20016274 	.word	0x20016274
    9198:	00001e15 	.word	0x00001e15
    919c:	00001e5b 	.word	0x00001e5b
    91a0:	00008b11 	.word	0x00008b11

000091a4 <xTaskRemoveFromEventList>:
	pxUnblockedTCB = (TCB_t *)listGET_OWNER_OF_HEAD_ENTRY(pxEventList);
    91a4:	68c3      	ldr	r3, [r0, #12]
{
    91a6:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
	pxUnblockedTCB = (TCB_t *)listGET_OWNER_OF_HEAD_ENTRY(pxEventList);
    91a8:	68dd      	ldr	r5, [r3, #12]
	configASSERT(pxUnblockedTCB);
    91aa:	b945      	cbnz	r5, 91be <xTaskRemoveFromEventList+0x1a>
    91ac:	f04f 0380 	mov.w	r3, #128	; 0x80
    91b0:	f383 8811 	msr	BASEPRI, r3
    91b4:	f3bf 8f6f 	isb	sy
    91b8:	f3bf 8f4f 	dsb	sy
    91bc:	e7fe      	b.n	91bc <xTaskRemoveFromEventList+0x18>
	(void)uxListRemove(&(pxUnblockedTCB->xEventListItem));
    91be:	f105 0118 	add.w	r1, r5, #24
	if (uxSchedulerSuspended == (UBaseType_t)pdFALSE) {
    91c2:	4c14      	ldr	r4, [pc, #80]	; (9214 <xTaskRemoveFromEventList+0x70>)
	(void)uxListRemove(&(pxUnblockedTCB->xEventListItem));
    91c4:	4f14      	ldr	r7, [pc, #80]	; (9218 <xTaskRemoveFromEventList+0x74>)
    91c6:	9101      	str	r1, [sp, #4]
    91c8:	4608      	mov	r0, r1
    91ca:	47b8      	blx	r7
	if (uxSchedulerSuspended == (UBaseType_t)pdFALSE) {
    91cc:	f8d4 30f0 	ldr.w	r3, [r4, #240]	; 0xf0
    91d0:	4e12      	ldr	r6, [pc, #72]	; (921c <xTaskRemoveFromEventList+0x78>)
    91d2:	9901      	ldr	r1, [sp, #4]
    91d4:	b9db      	cbnz	r3, 920e <xTaskRemoveFromEventList+0x6a>
		(void)uxListRemove(&(pxUnblockedTCB->xGenericListItem));
    91d6:	1d29      	adds	r1, r5, #4
    91d8:	4608      	mov	r0, r1
    91da:	9101      	str	r1, [sp, #4]
    91dc:	47b8      	blx	r7
		prvAddTaskToReadyList(pxUnblockedTCB);
    91de:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
    91e0:	f8d4 20e8 	ldr.w	r2, [r4, #232]	; 0xe8
    91e4:	9901      	ldr	r1, [sp, #4]
    91e6:	4293      	cmp	r3, r2
    91e8:	4a0d      	ldr	r2, [pc, #52]	; (9220 <xTaskRemoveFromEventList+0x7c>)
    91ea:	bf88      	it	hi
    91ec:	f8c4 30e8 	strhi.w	r3, [r4, #232]	; 0xe8
    91f0:	2014      	movs	r0, #20
    91f2:	fb00 2003 	mla	r0, r0, r3, r2
		vListInsertEnd(&(xPendingReadyList), &(pxUnblockedTCB->xEventListItem));
    91f6:	47b0      	blx	r6
	if (pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority) {
    91f8:	6b23      	ldr	r3, [r4, #48]	; 0x30
    91fa:	6aea      	ldr	r2, [r5, #44]	; 0x2c
    91fc:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    91fe:	429a      	cmp	r2, r3
		xYieldPending = pdTRUE;
    9200:	bf8a      	itet	hi
    9202:	2001      	movhi	r0, #1
		xReturn = pdFALSE;
    9204:	2000      	movls	r0, #0
		xYieldPending = pdTRUE;
    9206:	f8c4 00fc 	strhi.w	r0, [r4, #252]	; 0xfc
}
    920a:	b003      	add	sp, #12
    920c:	bdf0      	pop	{r4, r5, r6, r7, pc}
		vListInsertEnd(&(xPendingReadyList), &(pxUnblockedTCB->xEventListItem));
    920e:	f104 0014 	add.w	r0, r4, #20
    9212:	e7f0      	b.n	91f6 <xTaskRemoveFromEventList+0x52>
    9214:	20016274 	.word	0x20016274
    9218:	00001e5b 	.word	0x00001e5b
    921c:	00001e15 	.word	0x00001e15
    9220:	200162b4 	.word	0x200162b4

00009224 <vTaskSetTimeOutState>:
	configASSERT(pxTimeOut);
    9224:	b940      	cbnz	r0, 9238 <vTaskSetTimeOutState+0x14>
    9226:	f04f 0380 	mov.w	r3, #128	; 0x80
    922a:	f383 8811 	msr	BASEPRI, r3
    922e:	f3bf 8f6f 	isb	sy
    9232:	f3bf 8f4f 	dsb	sy
    9236:	e7fe      	b.n	9236 <vTaskSetTimeOutState+0x12>
	pxTimeOut->xOverflowCount  = xNumOfOverflows;
    9238:	4b03      	ldr	r3, [pc, #12]	; (9248 <vTaskSetTimeOutState+0x24>)
    923a:	f8d3 20f4 	ldr.w	r2, [r3, #244]	; 0xf4
	pxTimeOut->xTimeOnEntering = xTickCount;
    923e:	6b5b      	ldr	r3, [r3, #52]	; 0x34
	pxTimeOut->xOverflowCount  = xNumOfOverflows;
    9240:	6002      	str	r2, [r0, #0]
	pxTimeOut->xTimeOnEntering = xTickCount;
    9242:	6043      	str	r3, [r0, #4]
}
    9244:	4770      	bx	lr
    9246:	bf00      	nop
    9248:	20016274 	.word	0x20016274

0000924c <xTaskCheckForTimeOut>:
{
    924c:	b570      	push	{r4, r5, r6, lr}
    924e:	460d      	mov	r5, r1
	configASSERT(pxTimeOut);
    9250:	4604      	mov	r4, r0
    9252:	b940      	cbnz	r0, 9266 <xTaskCheckForTimeOut+0x1a>
    9254:	f04f 0380 	mov.w	r3, #128	; 0x80
    9258:	f383 8811 	msr	BASEPRI, r3
    925c:	f3bf 8f6f 	isb	sy
    9260:	f3bf 8f4f 	dsb	sy
    9264:	e7fe      	b.n	9264 <xTaskCheckForTimeOut+0x18>
	configASSERT(pxTicksToWait);
    9266:	b941      	cbnz	r1, 927a <xTaskCheckForTimeOut+0x2e>
    9268:	f04f 0380 	mov.w	r3, #128	; 0x80
    926c:	f383 8811 	msr	BASEPRI, r3
    9270:	f3bf 8f6f 	isb	sy
    9274:	f3bf 8f4f 	dsb	sy
    9278:	e7fe      	b.n	9278 <xTaskCheckForTimeOut+0x2c>
	taskENTER_CRITICAL();
    927a:	4b0f      	ldr	r3, [pc, #60]	; (92b8 <xTaskCheckForTimeOut+0x6c>)
    927c:	4798      	blx	r3
		if (*pxTicksToWait == portMAX_DELAY) {
    927e:	682b      	ldr	r3, [r5, #0]
		const TickType_t xConstTickCount = xTickCount;
    9280:	4a0e      	ldr	r2, [pc, #56]	; (92bc <xTaskCheckForTimeOut+0x70>)
		if (*pxTicksToWait == portMAX_DELAY) {
    9282:	1c58      	adds	r0, r3, #1
		const TickType_t xConstTickCount = xTickCount;
    9284:	6b51      	ldr	r1, [r2, #52]	; 0x34
		if (*pxTicksToWait == portMAX_DELAY) {
    9286:	d010      	beq.n	92aa <xTaskCheckForTimeOut+0x5e>
		    if ((xNumOfOverflows != pxTimeOut->xOverflowCount)
    9288:	f8d2 00f4 	ldr.w	r0, [r2, #244]	; 0xf4
    928c:	e9d4 6200 	ldrd	r6, r2, [r4]
    9290:	4286      	cmp	r6, r0
    9292:	d001      	beq.n	9298 <xTaskCheckForTimeOut+0x4c>
		        && (xConstTickCount >= pxTimeOut->xTimeOnEntering)) /*lint !e525 Indentation preferred as is to make
    9294:	4291      	cmp	r1, r2
    9296:	d20d      	bcs.n	92b4 <xTaskCheckForTimeOut+0x68>
		} else if ((xConstTickCount - pxTimeOut->xTimeOnEntering) < *pxTicksToWait) {
    9298:	1a88      	subs	r0, r1, r2
    929a:	4283      	cmp	r3, r0
    929c:	d90a      	bls.n	92b4 <xTaskCheckForTimeOut+0x68>
			*pxTicksToWait -= (xConstTickCount - pxTimeOut->xTimeOnEntering);
    929e:	1a5b      	subs	r3, r3, r1
    92a0:	4413      	add	r3, r2
    92a2:	602b      	str	r3, [r5, #0]
			vTaskSetTimeOutState(pxTimeOut);
    92a4:	4620      	mov	r0, r4
    92a6:	4b06      	ldr	r3, [pc, #24]	; (92c0 <xTaskCheckForTimeOut+0x74>)
    92a8:	4798      	blx	r3
			xReturn = pdFALSE;
    92aa:	2400      	movs	r4, #0
	taskEXIT_CRITICAL();
    92ac:	4b05      	ldr	r3, [pc, #20]	; (92c4 <xTaskCheckForTimeOut+0x78>)
    92ae:	4798      	blx	r3
}
    92b0:	4620      	mov	r0, r4
    92b2:	bd70      	pop	{r4, r5, r6, pc}
			xReturn = pdTRUE;
    92b4:	2401      	movs	r4, #1
    92b6:	e7f9      	b.n	92ac <xTaskCheckForTimeOut+0x60>
    92b8:	00009d59 	.word	0x00009d59
    92bc:	20016274 	.word	0x20016274
    92c0:	00009225 	.word	0x00009225
    92c4:	00009d99 	.word	0x00009d99

000092c8 <vTaskMissedYield>:
	xYieldPending = pdTRUE;
    92c8:	4b02      	ldr	r3, [pc, #8]	; (92d4 <vTaskMissedYield+0xc>)
    92ca:	2201      	movs	r2, #1
    92cc:	f8c3 20fc 	str.w	r2, [r3, #252]	; 0xfc
}
    92d0:	4770      	bx	lr
    92d2:	bf00      	nop
    92d4:	20016274 	.word	0x20016274

000092d8 <xTaskGetSchedulerState>:

BaseType_t xTaskGetSchedulerState(void)
{
	BaseType_t xReturn;

	if (xSchedulerRunning == pdFALSE) {
    92d8:	4b06      	ldr	r3, [pc, #24]	; (92f4 <xTaskGetSchedulerState+0x1c>)
    92da:	f8d3 20e0 	ldr.w	r2, [r3, #224]	; 0xe0
    92de:	b132      	cbz	r2, 92ee <xTaskGetSchedulerState+0x16>
		xReturn = taskSCHEDULER_NOT_STARTED;
	} else {
		if (uxSchedulerSuspended == (UBaseType_t)pdFALSE) {
    92e0:	f8d3 30f0 	ldr.w	r3, [r3, #240]	; 0xf0
			xReturn = taskSCHEDULER_RUNNING;
		} else {
			xReturn = taskSCHEDULER_SUSPENDED;
    92e4:	2b00      	cmp	r3, #0
    92e6:	bf0c      	ite	eq
    92e8:	2002      	moveq	r0, #2
    92ea:	2000      	movne	r0, #0
    92ec:	4770      	bx	lr
		xReturn = taskSCHEDULER_NOT_STARTED;
    92ee:	2001      	movs	r0, #1
		}
	}

	return xReturn;
}
    92f0:	4770      	bx	lr
    92f2:	bf00      	nop
    92f4:	20016274 	.word	0x20016274

000092f8 <vTaskPriorityInherit>:
	/*-----------------------------------------------------------*/

#if (configUSE_MUTEXES == 1)

void vTaskPriorityInherit(TaskHandle_t const pxMutexHolder)
{
    92f8:	b573      	push	{r0, r1, r4, r5, r6, lr}
	TCB_t *const pxTCB = (TCB_t *)pxMutexHolder;

	/* If the mutex was given back by an interrupt while the queue was
	locked then the mutex holder might now be NULL. */
	if (pxMutexHolder != NULL) {
    92fa:	4604      	mov	r4, r0
    92fc:	2800      	cmp	r0, #0
    92fe:	d02c      	beq.n	935a <vTaskPriorityInherit+0x62>
		/* If the holder of the mutex has a priority below the priority of
		the task attempting to obtain the mutex then it will temporarily
		inherit the priority of the task attempting to obtain the mutex. */
		if (pxTCB->uxPriority < pxCurrentTCB->uxPriority) {
    9300:	4d18      	ldr	r5, [pc, #96]	; (9364 <vTaskPriorityInherit+0x6c>)
    9302:	6ac3      	ldr	r3, [r0, #44]	; 0x2c
    9304:	6b2a      	ldr	r2, [r5, #48]	; 0x30
    9306:	6ad2      	ldr	r2, [r2, #44]	; 0x2c
    9308:	4293      	cmp	r3, r2
    930a:	d226      	bcs.n	935a <vTaskPriorityInherit+0x62>
			/* Adjust the mutex holder state to account for its new
			priority.  Only reset the event list item value if the value is
			not	being used for anything else. */
			if ((listGET_LIST_ITEM_VALUE(&(pxTCB->xEventListItem)) & taskEVENT_LIST_ITEM_VALUE_IN_USE) == 0UL) {
    930c:	6982      	ldr	r2, [r0, #24]
				mtCOVERAGE_TEST_MARKER();
			}

			/* If the task being modified is in the ready state it will need
			to be moved into a new list. */
			if (listIS_CONTAINED_WITHIN(&(pxReadyTasksLists[pxTCB->uxPriority]), &(pxTCB->xGenericListItem))
    930e:	4e16      	ldr	r6, [pc, #88]	; (9368 <vTaskPriorityInherit+0x70>)
			if ((listGET_LIST_ITEM_VALUE(&(pxTCB->xEventListItem)) & taskEVENT_LIST_ITEM_VALUE_IN_USE) == 0UL) {
    9310:	2a00      	cmp	r2, #0
				listSET_LIST_ITEM_VALUE(
    9312:	bfa1      	itttt	ge
    9314:	6b2a      	ldrge	r2, [r5, #48]	; 0x30
    9316:	6ad2      	ldrge	r2, [r2, #44]	; 0x2c
    9318:	f1c2 0205 	rsbge	r2, r2, #5
    931c:	6182      	strge	r2, [r0, #24]
			if (listIS_CONTAINED_WITHIN(&(pxReadyTasksLists[pxTCB->uxPriority]), &(pxTCB->xGenericListItem))
    931e:	2214      	movs	r2, #20
    9320:	fb02 6303 	mla	r3, r2, r3, r6
			    != pdFALSE) {
    9324:	6942      	ldr	r2, [r0, #20]
    9326:	429a      	cmp	r2, r3
    9328:	d114      	bne.n	9354 <vTaskPriorityInherit+0x5c>
				if (uxListRemove(&(pxTCB->xGenericListItem)) == (UBaseType_t)0) {
    932a:	1d01      	adds	r1, r0, #4
    932c:	4b0f      	ldr	r3, [pc, #60]	; (936c <vTaskPriorityInherit+0x74>)
    932e:	9101      	str	r1, [sp, #4]
    9330:	4608      	mov	r0, r1
    9332:	4798      	blx	r3
				} else {
					mtCOVERAGE_TEST_MARKER();
				}

				/* Inherit the priority before being moved into the new list. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
    9334:	6b2b      	ldr	r3, [r5, #48]	; 0x30
				prvAddTaskToReadyList(pxTCB);
    9336:	f8d5 20e8 	ldr.w	r2, [r5, #232]	; 0xe8
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
    933a:	6adb      	ldr	r3, [r3, #44]	; 0x2c
				prvAddTaskToReadyList(pxTCB);
    933c:	9901      	ldr	r1, [sp, #4]
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
    933e:	62e3      	str	r3, [r4, #44]	; 0x2c
				prvAddTaskToReadyList(pxTCB);
    9340:	4293      	cmp	r3, r2
    9342:	d80c      	bhi.n	935e <vTaskPriorityInherit+0x66>
    9344:	2014      	movs	r0, #20
    9346:	fb00 6003 	mla	r0, r0, r3, r6
    934a:	4b09      	ldr	r3, [pc, #36]	; (9370 <vTaskPriorityInherit+0x78>)
			mtCOVERAGE_TEST_MARKER();
		}
	} else {
		mtCOVERAGE_TEST_MARKER();
	}
}
    934c:	b002      	add	sp, #8
    934e:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
				prvAddTaskToReadyList(pxTCB);
    9352:	4718      	bx	r3
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
    9354:	6b2b      	ldr	r3, [r5, #48]	; 0x30
    9356:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    9358:	62c3      	str	r3, [r0, #44]	; 0x2c
}
    935a:	b002      	add	sp, #8
    935c:	bd70      	pop	{r4, r5, r6, pc}
				prvAddTaskToReadyList(pxTCB);
    935e:	f8c5 30e8 	str.w	r3, [r5, #232]	; 0xe8
    9362:	e7ef      	b.n	9344 <vTaskPriorityInherit+0x4c>
    9364:	20016274 	.word	0x20016274
    9368:	200162b4 	.word	0x200162b4
    936c:	00001e5b 	.word	0x00001e5b
    9370:	00001e15 	.word	0x00001e15

00009374 <xTaskPriorityDisinherit>:
	/*-----------------------------------------------------------*/

#if (configUSE_MUTEXES == 1)

BaseType_t xTaskPriorityDisinherit(TaskHandle_t const pxMutexHolder)
{
    9374:	b537      	push	{r0, r1, r2, r4, r5, lr}
	TCB_t *const pxTCB   = (TCB_t *)pxMutexHolder;
	BaseType_t   xReturn = pdFALSE;

	if (pxMutexHolder != NULL) {
    9376:	b910      	cbnz	r0, 937e <xTaskPriorityDisinherit+0xa>
	BaseType_t   xReturn = pdFALSE;
    9378:	2000      	movs	r0, #0
	} else {
		mtCOVERAGE_TEST_MARKER();
	}

	return xReturn;
}
    937a:	b003      	add	sp, #12
    937c:	bd30      	pop	{r4, r5, pc}
		configASSERT(pxTCB == pxCurrentTCB);
    937e:	4d1c      	ldr	r5, [pc, #112]	; (93f0 <xTaskPriorityDisinherit+0x7c>)
    9380:	6b2c      	ldr	r4, [r5, #48]	; 0x30
    9382:	4284      	cmp	r4, r0
    9384:	d008      	beq.n	9398 <xTaskPriorityDisinherit+0x24>
    9386:	f04f 0380 	mov.w	r3, #128	; 0x80
    938a:	f383 8811 	msr	BASEPRI, r3
    938e:	f3bf 8f6f 	isb	sy
    9392:	f3bf 8f4f 	dsb	sy
    9396:	e7fe      	b.n	9396 <xTaskPriorityDisinherit+0x22>
		configASSERT(pxTCB->uxMutexesHeld);
    9398:	6ca3      	ldr	r3, [r4, #72]	; 0x48
    939a:	b943      	cbnz	r3, 93ae <xTaskPriorityDisinherit+0x3a>
    939c:	f04f 0380 	mov.w	r3, #128	; 0x80
    93a0:	f383 8811 	msr	BASEPRI, r3
    93a4:	f3bf 8f6f 	isb	sy
    93a8:	f3bf 8f4f 	dsb	sy
    93ac:	e7fe      	b.n	93ac <xTaskPriorityDisinherit+0x38>
		if (pxTCB->uxPriority != pxTCB->uxBasePriority) {
    93ae:	6ae1      	ldr	r1, [r4, #44]	; 0x2c
    93b0:	6c62      	ldr	r2, [r4, #68]	; 0x44
		(pxTCB->uxMutexesHeld)--;
    93b2:	3b01      	subs	r3, #1
		if (pxTCB->uxPriority != pxTCB->uxBasePriority) {
    93b4:	4291      	cmp	r1, r2
		(pxTCB->uxMutexesHeld)--;
    93b6:	64a3      	str	r3, [r4, #72]	; 0x48
		if (pxTCB->uxPriority != pxTCB->uxBasePriority) {
    93b8:	d0de      	beq.n	9378 <xTaskPriorityDisinherit+0x4>
			if (pxTCB->uxMutexesHeld == (UBaseType_t)0) {
    93ba:	2b00      	cmp	r3, #0
    93bc:	d1dc      	bne.n	9378 <xTaskPriorityDisinherit+0x4>
				if (uxListRemove(&(pxTCB->xGenericListItem)) == (UBaseType_t)0) {
    93be:	1d21      	adds	r1, r4, #4
    93c0:	4b0c      	ldr	r3, [pc, #48]	; (93f4 <xTaskPriorityDisinherit+0x80>)
    93c2:	9101      	str	r1, [sp, #4]
    93c4:	4608      	mov	r0, r1
    93c6:	4798      	blx	r3
				pxTCB->uxPriority = pxTCB->uxBasePriority;
    93c8:	6c63      	ldr	r3, [r4, #68]	; 0x44
    93ca:	62e3      	str	r3, [r4, #44]	; 0x2c
				listSET_LIST_ITEM_VALUE(
    93cc:	f1c3 0205 	rsb	r2, r3, #5
    93d0:	61a2      	str	r2, [r4, #24]
				prvAddTaskToReadyList(pxTCB);
    93d2:	f8d5 20e8 	ldr.w	r2, [r5, #232]	; 0xe8
    93d6:	9901      	ldr	r1, [sp, #4]
    93d8:	4293      	cmp	r3, r2
    93da:	4a07      	ldr	r2, [pc, #28]	; (93f8 <xTaskPriorityDisinherit+0x84>)
    93dc:	bf88      	it	hi
    93de:	f8c5 30e8 	strhi.w	r3, [r5, #232]	; 0xe8
    93e2:	2014      	movs	r0, #20
    93e4:	fb00 2003 	mla	r0, r0, r3, r2
    93e8:	4b04      	ldr	r3, [pc, #16]	; (93fc <xTaskPriorityDisinherit+0x88>)
    93ea:	4798      	blx	r3
				xReturn = pdTRUE;
    93ec:	2001      	movs	r0, #1
	return xReturn;
    93ee:	e7c4      	b.n	937a <xTaskPriorityDisinherit+0x6>
    93f0:	20016274 	.word	0x20016274
    93f4:	00001e5b 	.word	0x00001e5b
    93f8:	200162b4 	.word	0x200162b4
    93fc:	00001e15 	.word	0x00001e15

00009400 <pvTaskIncrementMutexHeldCount>:

void *pvTaskIncrementMutexHeldCount(void)
{
	/* If xSemaphoreCreateMutex() is called before any tasks have been created
	then pxCurrentTCB will be NULL. */
	if (pxCurrentTCB != NULL) {
    9400:	4b04      	ldr	r3, [pc, #16]	; (9414 <pvTaskIncrementMutexHeldCount+0x14>)
    9402:	6b1a      	ldr	r2, [r3, #48]	; 0x30
    9404:	b11a      	cbz	r2, 940e <pvTaskIncrementMutexHeldCount+0xe>
		(pxCurrentTCB->uxMutexesHeld)++;
    9406:	6b19      	ldr	r1, [r3, #48]	; 0x30
    9408:	6c8a      	ldr	r2, [r1, #72]	; 0x48
    940a:	3201      	adds	r2, #1
    940c:	648a      	str	r2, [r1, #72]	; 0x48
	}

	return pxCurrentTCB;
    940e:	6b18      	ldr	r0, [r3, #48]	; 0x30
}
    9410:	4770      	bx	lr
    9412:	bf00      	nop
    9414:	20016274 	.word	0x20016274

00009418 <get_socket>:
 */
static struct lwip_sock *get_socket(int s)
{
	struct lwip_sock *sock;

	if ((s < 0) || (s >= NUM_SOCKETS)) {
    9418:	2803      	cmp	r0, #3
    941a:	d808      	bhi.n	942e <get_socket+0x16>
		LWIP_DEBUGF(SOCKETS_DEBUG, ("get_socket(%d): invalid\n", s));
		set_errno(EBADF);
		return NULL;
	}

	sock = &sockets[s];
    941c:	2318      	movs	r3, #24
    941e:	4a05      	ldr	r2, [pc, #20]	; (9434 <get_socket+0x1c>)
    9420:	4343      	muls	r3, r0
    9422:	18d0      	adds	r0, r2, r3

	if (!sock->conn) {
    9424:	58d3      	ldr	r3, [r2, r3]
		return NULL;
    9426:	2b00      	cmp	r3, #0
    9428:	bf08      	it	eq
    942a:	2000      	moveq	r0, #0
    942c:	4770      	bx	lr
    942e:	2000      	movs	r0, #0
		set_errno(EBADF);
		return NULL;
	}

	return sock;
}
    9430:	4770      	bx	lr
    9432:	bf00      	nop
    9434:	20016374 	.word	0x20016374

00009438 <alloc_socket>:

	/* allocate a new socket identifier */
	for (i = 0; i < NUM_SOCKETS; ++i) {
		/* Protect socket array */
		SYS_ARCH_PROTECT(lev);
		if (!sockets[i].conn) {
    9438:	4b0d      	ldr	r3, [pc, #52]	; (9470 <alloc_socket+0x38>)
{
    943a:	b570      	push	{r4, r5, r6, lr}
    943c:	4604      	mov	r4, r0
		if (!sockets[i].conn) {
    943e:	2618      	movs	r6, #24
	for (i = 0; i < NUM_SOCKETS; ++i) {
    9440:	2000      	movs	r0, #0
		if (!sockets[i].conn) {
    9442:	fb06 f500 	mul.w	r5, r6, r0
    9446:	58ea      	ldr	r2, [r5, r3]
    9448:	b962      	cbnz	r2, 9464 <alloc_socket+0x2c>
			sockets[i].conn = newconn;
    944a:	195e      	adds	r6, r3, r5
    944c:	515c      	str	r4, [r3, r5]
			/* The socket is not yet known to anyone, so no need to protect
			   after having marked it as used. */
			SYS_ARCH_UNPROTECT(lev);
			sockets[i].lastdata   = NULL;
			sockets[i].lastoffset = 0;
    944e:	e9c6 2201 	strd	r2, r2, [r6, #4]
			sockets[i].rcvevent   = 0;
			/* TCP sendbuf is empty, but the socket is not yet writable until connected
			 * (unless it has been created by accept()). */
			sockets[i].sendevent      = (newconn->type == NETCONN_TCP ? (accepted != 0) : 1);
    9452:	7824      	ldrb	r4, [r4, #0]
			sockets[i].errevent       = 0;
    9454:	81f2      	strh	r2, [r6, #14]
			sockets[i].sendevent      = (newconn->type == NETCONN_TCP ? (accepted != 0) : 1);
    9456:	2c10      	cmp	r4, #16
			sockets[i].err            = 0;
			sockets[i].select_waiting = 0;
    9458:	e9c6 2204 	strd	r2, r2, [r6, #16]
			sockets[i].sendevent      = (newconn->type == NETCONN_TCP ? (accepted != 0) : 1);
    945c:	bf18      	it	ne
    945e:	2101      	movne	r1, #1
    9460:	81b1      	strh	r1, [r6, #12]
			return i;
		}
		SYS_ARCH_UNPROTECT(lev);
	}
	return -1;
}
    9462:	bd70      	pop	{r4, r5, r6, pc}
	for (i = 0; i < NUM_SOCKETS; ++i) {
    9464:	3001      	adds	r0, #1
    9466:	2804      	cmp	r0, #4
    9468:	d1eb      	bne.n	9442 <alloc_socket+0xa>
	return -1;
    946a:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    946e:	e7f8      	b.n	9462 <alloc_socket+0x2a>
    9470:	20016374 	.word	0x20016374

00009474 <event_callback>:
/**
 * Callback registered in the netconn layer for each socket-netconn.
 * Processes recvevent (data available) and wakes up tasks waiting for select.
 */
static void event_callback(struct netconn *conn, enum netconn_evt evt, u16_t len)
{
    9474:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
	SYS_ARCH_DECL_PROTECT(lev);

	LWIP_UNUSED_ARG(len);

	/* Get socket */
	if (conn) {
    9478:	b128      	cbz	r0, 9486 <event_callback+0x12>
		s = conn->socket;
    947a:	6985      	ldr	r5, [r0, #24]
		if (s < 0) {
    947c:	2d00      	cmp	r5, #0
    947e:	da04      	bge.n	948a <event_callback+0x16>
			 * Just count down (or up) if that's the case and we
			 * will use the data later. Note that only receive events
			 * can happen before the new socket is set up. */
			SYS_ARCH_PROTECT(lev);
			if (conn->socket < 0) {
				if (evt == NETCONN_EVT_RCVPLUS) {
    9480:	b909      	cbnz	r1, 9486 <event_callback+0x12>
					conn->socket--;
    9482:	3d01      	subs	r5, #1
    9484:	6185      	str	r5, [r0, #24]
			/* someone has changed select_cb_list, restart at the beginning */
			goto again;
		}
	}
	SYS_ARCH_UNPROTECT(lev);
}
    9486:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
		sock = get_socket(s);
    948a:	4b30      	ldr	r3, [pc, #192]	; (954c <event_callback+0xd8>)
    948c:	4628      	mov	r0, r5
    948e:	4798      	blx	r3
		if (!sock) {
    9490:	4604      	mov	r4, r0
    9492:	2800      	cmp	r0, #0
    9494:	d0f7      	beq.n	9486 <event_callback+0x12>
	switch (evt) {
    9496:	2904      	cmp	r1, #4
    9498:	d807      	bhi.n	94aa <event_callback+0x36>
    949a:	e8df f001 	tbb	[pc, r1]
    949e:	4303      	.short	0x4303
    94a0:	4946      	.short	0x4946
    94a2:	4b          	.byte	0x4b
    94a3:	00          	.byte	0x00
		sock->rcvevent++;
    94a4:	8943      	ldrh	r3, [r0, #10]
    94a6:	3301      	adds	r3, #1
		sock->rcvevent--;
    94a8:	8163      	strh	r3, [r4, #10]
	if (sock->select_waiting == 0) {
    94aa:	6963      	ldr	r3, [r4, #20]
    94ac:	2b00      	cmp	r3, #0
    94ae:	d0ea      	beq.n	9486 <event_callback+0x12>
				if (scb->readset && FD_ISSET(s, scb->readset)) {
    94b0:	116f      	asrs	r7, r5, #5
    94b2:	f04f 0801 	mov.w	r8, #1
				if (!do_signal && scb->exceptset && FD_ISSET(s, scb->exceptset)) {
    94b6:	f005 051f 	and.w	r5, r5, #31
	for (scb = select_cb_list; scb != NULL; scb = scb->next) {
    94ba:	f8df 9094 	ldr.w	r9, [pc, #148]	; 9550 <event_callback+0xdc>
				sys_sem_signal(&scb->sem);
    94be:	f8df b094 	ldr.w	fp, [pc, #148]	; 9554 <event_callback+0xe0>
    94c2:	fa08 f805 	lsl.w	r8, r8, r5
	for (scb = select_cb_list; scb != NULL; scb = scb->next) {
    94c6:	f8d9 6060 	ldr.w	r6, [r9, #96]	; 0x60
				scb->sem_signalled = 1;
    94ca:	f04f 0a01 	mov.w	sl, #1
	for (scb = select_cb_list; scb != NULL; scb = scb->next) {
    94ce:	2e00      	cmp	r6, #0
    94d0:	d0d9      	beq.n	9486 <event_callback+0x12>
		if (scb->sem_signalled == 0) {
    94d2:	6973      	ldr	r3, [r6, #20]
    94d4:	b9f3      	cbnz	r3, 9514 <event_callback+0xa0>
			if (sock->rcvevent > 0) {
    94d6:	f9b4 200a 	ldrsh.w	r2, [r4, #10]
    94da:	2a00      	cmp	r2, #0
    94dc:	dd06      	ble.n	94ec <event_callback+0x78>
				if (scb->readset && FD_ISSET(s, scb->readset)) {
    94de:	68b2      	ldr	r2, [r6, #8]
    94e0:	b122      	cbz	r2, 94ec <event_callback+0x78>
    94e2:	f852 3027 	ldr.w	r3, [r2, r7, lsl #2]
    94e6:	40eb      	lsrs	r3, r5
    94e8:	f003 0301 	and.w	r3, r3, #1
			if (sock->sendevent != 0) {
    94ec:	89a2      	ldrh	r2, [r4, #12]
    94ee:	b13a      	cbz	r2, 9500 <event_callback+0x8c>
				if (!do_signal && scb->writeset && FD_ISSET(s, scb->writeset)) {
    94f0:	b933      	cbnz	r3, 9500 <event_callback+0x8c>
    94f2:	68f2      	ldr	r2, [r6, #12]
    94f4:	b122      	cbz	r2, 9500 <event_callback+0x8c>
    94f6:	f852 3027 	ldr.w	r3, [r2, r7, lsl #2]
    94fa:	40eb      	lsrs	r3, r5
    94fc:	f003 0301 	and.w	r3, r3, #1
			if (sock->errevent != 0) {
    9500:	89e2      	ldrh	r2, [r4, #14]
    9502:	b1d2      	cbz	r2, 953a <event_callback+0xc6>
				if (!do_signal && scb->exceptset && FD_ISSET(s, scb->exceptset)) {
    9504:	b9db      	cbnz	r3, 953e <event_callback+0xca>
    9506:	6933      	ldr	r3, [r6, #16]
    9508:	b123      	cbz	r3, 9514 <event_callback+0xa0>
    950a:	f853 3027 	ldr.w	r3, [r3, r7, lsl #2]
    950e:	ea18 0f03 	tst.w	r8, r3
    9512:	d114      	bne.n	953e <event_callback+0xca>
		last_select_cb_ctr = select_cb_ctr;
    9514:	f8d9 3064 	ldr.w	r3, [r9, #100]	; 0x64
		if (last_select_cb_ctr != select_cb_ctr) {
    9518:	f8d9 2064 	ldr.w	r2, [r9, #100]	; 0x64
    951c:	429a      	cmp	r2, r3
    951e:	d1d2      	bne.n	94c6 <event_callback+0x52>
	for (scb = select_cb_list; scb != NULL; scb = scb->next) {
    9520:	6836      	ldr	r6, [r6, #0]
    9522:	e7d4      	b.n	94ce <event_callback+0x5a>
		sock->rcvevent--;
    9524:	8943      	ldrh	r3, [r0, #10]
    9526:	3b01      	subs	r3, #1
    9528:	e7be      	b.n	94a8 <event_callback+0x34>
		sock->sendevent = 1;
    952a:	2301      	movs	r3, #1
		sock->sendevent = 0;
    952c:	81a3      	strh	r3, [r4, #12]
		break;
    952e:	e7bc      	b.n	94aa <event_callback+0x36>
		sock->sendevent = 0;
    9530:	2300      	movs	r3, #0
    9532:	e7fb      	b.n	952c <event_callback+0xb8>
		sock->errevent = 1;
    9534:	2301      	movs	r3, #1
    9536:	81c3      	strh	r3, [r0, #14]
		break;
    9538:	e7b7      	b.n	94aa <event_callback+0x36>
			if (do_signal) {
    953a:	2b00      	cmp	r3, #0
    953c:	d0ea      	beq.n	9514 <event_callback+0xa0>
				scb->sem_signalled = 1;
    953e:	f8c6 a014 	str.w	sl, [r6, #20]
				sys_sem_signal(&scb->sem);
    9542:	f106 0018 	add.w	r0, r6, #24
    9546:	47d8      	blx	fp
    9548:	e7e4      	b.n	9514 <event_callback+0xa0>
    954a:	bf00      	nop
    954c:	00009419 	.word	0x00009419
    9550:	20016374 	.word	0x20016374
    9554:	00007a1d 	.word	0x00007a1d

00009558 <lwip_setsockopt_internal>:
	sock = data->sock;
#ifdef LWIP_DEBUG
	s = data->s;
#endif /* LWIP_DEBUG */
	level   = data->level;
	optname = data->optname;
    9558:	e9d0 1301 	ldrd	r1, r3, [r0, #4]
	optval  = data->optval;
    955c:	68c2      	ldr	r2, [r0, #12]
		case SO_REUSEADDR:
		case SO_REUSEPORT:
#endif      /* SO_REUSE */
			/* UNIMPL case SO_USELOOPBACK: */
			if (*(int *)optval) {
				ip_set_option(sock->conn->pcb.ip, optname);
    955e:	6800      	ldr	r0, [r0, #0]
	switch (level) {
    9560:	2906      	cmp	r1, #6
{
    9562:	b410      	push	{r4}
				ip_set_option(sock->conn->pcb.ip, optname);
    9564:	6800      	ldr	r0, [r0, #0]
	switch (level) {
    9566:	d032      	beq.n	95ce <lwip_setsockopt_internal+0x76>
    9568:	f640 74ff 	movw	r4, #4095	; 0xfff
    956c:	42a1      	cmp	r1, r4
    956e:	d008      	beq.n	9582 <lwip_setsockopt_internal+0x2a>
    9570:	b9b1      	cbnz	r1, 95a0 <lwip_setsockopt_internal+0x48>
		} /* switch (optname) */
		break;

		/* Level: IPPROTO_IP */
	case IPPROTO_IP:
		switch (optname) {
    9572:	2b01      	cmp	r3, #1
    9574:	d027      	beq.n	95c6 <lwip_setsockopt_internal+0x6e>
    9576:	2b02      	cmp	r3, #2
    9578:	d112      	bne.n	95a0 <lwip_setsockopt_internal+0x48>
		case IP_TTL:
			sock->conn->pcb.ip->ttl = (u8_t)(*(int *)optval);
    957a:	6843      	ldr	r3, [r0, #4]
    957c:	6812      	ldr	r2, [r2, #0]
    957e:	729a      	strb	r2, [r3, #10]
			LWIP_DEBUGF(SOCKETS_DEBUG,
			            ("lwip_setsockopt(%d, IPPROTO_IP, IP_TTL, ..) -> %d\n", s, sock->conn->pcb.ip->ttl));
			break;
    9580:	e00e      	b.n	95a0 <lwip_setsockopt_internal+0x48>
		switch (optname) {
    9582:	2b20      	cmp	r3, #32
    9584:	d005      	beq.n	9592 <lwip_setsockopt_internal+0x3a>
    9586:	f241 010a 	movw	r1, #4106	; 0x100a
    958a:	428b      	cmp	r3, r1
    958c:	d010      	beq.n	95b0 <lwip_setsockopt_internal+0x58>
    958e:	2b08      	cmp	r3, #8
    9590:	d106      	bne.n	95a0 <lwip_setsockopt_internal+0x48>
				ip_set_option(sock->conn->pcb.ip, optname);
    9592:	6841      	ldr	r1, [r0, #4]
			if (*(int *)optval) {
    9594:	6814      	ldr	r4, [r2, #0]
    9596:	7a0a      	ldrb	r2, [r1, #8]
				ip_set_option(sock->conn->pcb.ip, optname);
    9598:	b25b      	sxtb	r3, r3
			if (*(int *)optval) {
    959a:	b134      	cbz	r4, 95aa <lwip_setsockopt_internal+0x52>
				ip_set_option(sock->conn->pcb.ip, optname);
    959c:	4313      	orrs	r3, r2
				ip_reset_option(sock->conn->pcb.ip, optname);
    959e:	720b      	strb	r3, [r1, #8]
#endif /* LWIP_UDP */
	default:
		LWIP_ASSERT("unhandled level", 0);
		break;
	} /* switch (level) */
	sys_sem_signal(&sock->conn->op_completed);
    95a0:	4b15      	ldr	r3, [pc, #84]	; (95f8 <lwip_setsockopt_internal+0xa0>)
}
    95a2:	f85d 4b04 	ldr.w	r4, [sp], #4
	sys_sem_signal(&sock->conn->op_completed);
    95a6:	300c      	adds	r0, #12
    95a8:	4718      	bx	r3
				ip_reset_option(sock->conn->pcb.ip, optname);
    95aa:	ea22 0303 	bic.w	r3, r2, r3
    95ae:	e7f6      	b.n	959e <lwip_setsockopt_internal+0x46>
				ip_set_option(sock->conn->pcb.ip, optname);
    95b0:	6841      	ldr	r1, [r0, #4]
			if (*(int *)optval) {
    95b2:	6812      	ldr	r2, [r2, #0]
				udp_setflags(sock->conn->pcb.udp, udp_flags(sock->conn->pcb.udp) | UDP_FLAGS_NOCHKSUM);
    95b4:	7c0b      	ldrb	r3, [r1, #16]
			if (*(int *)optval) {
    95b6:	b11a      	cbz	r2, 95c0 <lwip_setsockopt_internal+0x68>
				udp_setflags(sock->conn->pcb.udp, udp_flags(sock->conn->pcb.udp) | UDP_FLAGS_NOCHKSUM);
    95b8:	f043 0301 	orr.w	r3, r3, #1
				udp_setflags(sock->conn->pcb.udp, udp_flags(sock->conn->pcb.udp) & ~UDP_FLAGS_NOCHKSUM);
    95bc:	740b      	strb	r3, [r1, #16]
    95be:	e7ef      	b.n	95a0 <lwip_setsockopt_internal+0x48>
    95c0:	f023 0301 	bic.w	r3, r3, #1
    95c4:	e7fa      	b.n	95bc <lwip_setsockopt_internal+0x64>
			sock->conn->pcb.ip->tos = (u8_t)(*(int *)optval);
    95c6:	6843      	ldr	r3, [r0, #4]
    95c8:	6812      	ldr	r2, [r2, #0]
    95ca:	725a      	strb	r2, [r3, #9]
			break;
    95cc:	e7e8      	b.n	95a0 <lwip_setsockopt_internal+0x48>
		switch (optname) {
    95ce:	2b01      	cmp	r3, #1
    95d0:	d006      	beq.n	95e0 <lwip_setsockopt_internal+0x88>
    95d2:	2b02      	cmp	r3, #2
    95d4:	d1e4      	bne.n	95a0 <lwip_setsockopt_internal+0x48>
			sock->conn->pcb.tcp->keep_idle = (u32_t)(*(int *)optval);
    95d6:	6843      	ldr	r3, [r0, #4]
    95d8:	6812      	ldr	r2, [r2, #0]
    95da:	f8c3 2090 	str.w	r2, [r3, #144]	; 0x90
			break;
    95de:	e7df      	b.n	95a0 <lwip_setsockopt_internal+0x48>
				ip_set_option(sock->conn->pcb.ip, optname);
    95e0:	6841      	ldr	r1, [r0, #4]
			if (*(int *)optval) {
    95e2:	6812      	ldr	r2, [r2, #0]
				tcp_nagle_disable(sock->conn->pcb.tcp);
    95e4:	7f8b      	ldrb	r3, [r1, #30]
			if (*(int *)optval) {
    95e6:	b11a      	cbz	r2, 95f0 <lwip_setsockopt_internal+0x98>
				tcp_nagle_disable(sock->conn->pcb.tcp);
    95e8:	f043 0340 	orr.w	r3, r3, #64	; 0x40
				tcp_nagle_enable(sock->conn->pcb.tcp);
    95ec:	778b      	strb	r3, [r1, #30]
    95ee:	e7d7      	b.n	95a0 <lwip_setsockopt_internal+0x48>
    95f0:	f023 0340 	bic.w	r3, r3, #64	; 0x40
    95f4:	e7fa      	b.n	95ec <lwip_setsockopt_internal+0x94>
    95f6:	bf00      	nop
    95f8:	00007a1d 	.word	0x00007a1d

000095fc <lwip_socket_init>:
}
    95fc:	4770      	bx	lr
	...

00009600 <lwip_accept>:
{
    9600:	b5f0      	push	{r4, r5, r6, r7, lr}
	sock = get_socket(s);
    9602:	4b3a      	ldr	r3, [pc, #232]	; (96ec <lwip_accept+0xec>)
{
    9604:	b089      	sub	sp, #36	; 0x24
    9606:	4616      	mov	r6, r2
	sock = get_socket(s);
    9608:	4798      	blx	r3
{
    960a:	460f      	mov	r7, r1
	if (!sock) {
    960c:	4605      	mov	r5, r0
    960e:	b148      	cbz	r0, 9624 <lwip_accept+0x24>
	if (netconn_is_nonblocking(sock->conn) && (sock->rcvevent <= 0)) {
    9610:	6800      	ldr	r0, [r0, #0]
    9612:	7f03      	ldrb	r3, [r0, #28]
    9614:	079a      	lsls	r2, r3, #30
    9616:	d508      	bpl.n	962a <lwip_accept+0x2a>
    9618:	f9b5 300a 	ldrsh.w	r3, [r5, #10]
    961c:	2b00      	cmp	r3, #0
    961e:	dc04      	bgt.n	962a <lwip_accept+0x2a>
		sock_set_errno(sock, EWOULDBLOCK);
    9620:	230b      	movs	r3, #11
		sock_set_errno(sock, err_to_errno(err));
    9622:	612b      	str	r3, [r5, #16]
		return -1;
    9624:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
    9628:	e00a      	b.n	9640 <lwip_accept+0x40>
	err = netconn_accept(sock->conn, &newconn);
    962a:	4b31      	ldr	r3, [pc, #196]	; (96f0 <lwip_accept+0xf0>)
    962c:	a902      	add	r1, sp, #8
    962e:	4798      	blx	r3
	if (err != ERR_OK) {
    9630:	4603      	mov	r3, r0
    9632:	b178      	cbz	r0, 9654 <lwip_accept+0x54>
		if (netconn_type(sock->conn) != NETCONN_TCP) {
    9634:	682a      	ldr	r2, [r5, #0]
    9636:	7812      	ldrb	r2, [r2, #0]
    9638:	2a10      	cmp	r2, #16
    963a:	d004      	beq.n	9646 <lwip_accept+0x46>
			sock_set_errno(sock, EOPNOTSUPP);
    963c:	245f      	movs	r4, #95	; 0x5f
    963e:	612c      	str	r4, [r5, #16]
}
    9640:	4620      	mov	r0, r4
    9642:	b009      	add	sp, #36	; 0x24
    9644:	bdf0      	pop	{r4, r5, r6, r7, pc}
		sock_set_errno(sock, err_to_errno(err));
    9646:	4243      	negs	r3, r0
    9648:	2b0f      	cmp	r3, #15
    964a:	d819      	bhi.n	9680 <lwip_accept+0x80>
    964c:	4a29      	ldr	r2, [pc, #164]	; (96f4 <lwip_accept+0xf4>)
    964e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    9652:	e7e6      	b.n	9622 <lwip_accept+0x22>
	netconn_set_noautorecved(newconn, 1);
    9654:	9802      	ldr	r0, [sp, #8]
	err = netconn_peer(newconn, &naddr, &port);
    9656:	4c28      	ldr	r4, [pc, #160]	; (96f8 <lwip_accept+0xf8>)
	netconn_set_noautorecved(newconn, 1);
    9658:	7f02      	ldrb	r2, [r0, #28]
    965a:	f042 0208 	orr.w	r2, r2, #8
    965e:	7702      	strb	r2, [r0, #28]
	err = netconn_peer(newconn, &naddr, &port);
    9660:	a903      	add	r1, sp, #12
    9662:	f10d 0206 	add.w	r2, sp, #6
    9666:	47a0      	blx	r4
	if (err != ERR_OK) {
    9668:	4604      	mov	r4, r0
    966a:	b158      	cbz	r0, 9684 <lwip_accept+0x84>
		netconn_delete(newconn);
    966c:	9802      	ldr	r0, [sp, #8]
    966e:	4b23      	ldr	r3, [pc, #140]	; (96fc <lwip_accept+0xfc>)
		sock_set_errno(sock, err_to_errno(err));
    9670:	4264      	negs	r4, r4
		netconn_delete(newconn);
    9672:	4798      	blx	r3
		sock_set_errno(sock, err_to_errno(err));
    9674:	2c0f      	cmp	r4, #15
    9676:	d803      	bhi.n	9680 <lwip_accept+0x80>
    9678:	4b1e      	ldr	r3, [pc, #120]	; (96f4 <lwip_accept+0xf4>)
    967a:	f853 3024 	ldr.w	r3, [r3, r4, lsl #2]
    967e:	e7d0      	b.n	9622 <lwip_accept+0x22>
    9680:	2305      	movs	r3, #5
    9682:	e7ce      	b.n	9622 <lwip_accept+0x22>
	if (NULL != addr) {
    9684:	b1bf      	cbz	r7, 96b6 <lwip_accept+0xb6>
		sin.sin_len    = sizeof(sin);
    9686:	f44f 7304 	mov.w	r3, #528	; 0x210
		memset(&sin, 0, sizeof(sin));
    968a:	e9cd 0006 	strd	r0, r0, [sp, #24]
		sin.sin_len    = sizeof(sin);
    968e:	f8ad 3010 	strh.w	r3, [sp, #16]
		sin.sin_port   = htons(port);
    9692:	f8bd 0006 	ldrh.w	r0, [sp, #6]
    9696:	4b1a      	ldr	r3, [pc, #104]	; (9700 <lwip_accept+0x100>)
    9698:	4798      	blx	r3
		inet_addr_from_ipaddr(&sin.sin_addr, &naddr);
    969a:	9b03      	ldr	r3, [sp, #12]
    969c:	9305      	str	r3, [sp, #20]
		if (*addrlen > sizeof(sin))
    969e:	6833      	ldr	r3, [r6, #0]
		sin.sin_port   = htons(port);
    96a0:	f8ad 0012 	strh.w	r0, [sp, #18]
		if (*addrlen > sizeof(sin))
    96a4:	2b10      	cmp	r3, #16
			*addrlen = sizeof(sin);
    96a6:	bf84      	itt	hi
    96a8:	2310      	movhi	r3, #16
    96aa:	6033      	strhi	r3, [r6, #0]
		MEMCPY(addr, &sin, *addrlen);
    96ac:	6832      	ldr	r2, [r6, #0]
    96ae:	4b15      	ldr	r3, [pc, #84]	; (9704 <lwip_accept+0x104>)
    96b0:	a904      	add	r1, sp, #16
    96b2:	4638      	mov	r0, r7
    96b4:	4798      	blx	r3
	newsock = alloc_socket(newconn, 1);
    96b6:	4b14      	ldr	r3, [pc, #80]	; (9708 <lwip_accept+0x108>)
    96b8:	9802      	ldr	r0, [sp, #8]
    96ba:	2101      	movs	r1, #1
    96bc:	4798      	blx	r3
	if (newsock == -1) {
    96be:	1c43      	adds	r3, r0, #1
	newsock = alloc_socket(newconn, 1);
    96c0:	4604      	mov	r4, r0
	if (newsock == -1) {
    96c2:	d105      	bne.n	96d0 <lwip_accept+0xd0>
		netconn_delete(newconn);
    96c4:	4b0d      	ldr	r3, [pc, #52]	; (96fc <lwip_accept+0xfc>)
    96c6:	9802      	ldr	r0, [sp, #8]
    96c8:	4798      	blx	r3
		sock_set_errno(sock, ENFILE);
    96ca:	2317      	movs	r3, #23
	sock_set_errno(sock, 0);
    96cc:	612b      	str	r3, [r5, #16]
	return newsock;
    96ce:	e7b7      	b.n	9640 <lwip_accept+0x40>
	nsock->rcvevent += (s16_t)(-1 - newconn->socket);
    96d0:	4a0e      	ldr	r2, [pc, #56]	; (970c <lwip_accept+0x10c>)
    96d2:	9902      	ldr	r1, [sp, #8]
    96d4:	2318      	movs	r3, #24
    96d6:	fb03 2200 	mla	r2, r3, r0, r2
    96da:	698b      	ldr	r3, [r1, #24]
    96dc:	8950      	ldrh	r0, [r2, #10]
    96de:	43db      	mvns	r3, r3
    96e0:	4403      	add	r3, r0
    96e2:	8153      	strh	r3, [r2, #10]
	newconn->socket = newsock;
    96e4:	618c      	str	r4, [r1, #24]
	sock_set_errno(sock, 0);
    96e6:	2300      	movs	r3, #0
    96e8:	e7f0      	b.n	96cc <lwip_accept+0xcc>
    96ea:	bf00      	nop
    96ec:	00009419 	.word	0x00009419
    96f0:	000076e9 	.word	0x000076e9
    96f4:	0000cca8 	.word	0x0000cca8
    96f8:	0000764d 	.word	0x0000764d
    96fc:	00007621 	.word	0x00007621
    9700:	00000d61 	.word	0x00000d61
    9704:	0000c07d 	.word	0x0000c07d
    9708:	00009439 	.word	0x00009439
    970c:	20016374 	.word	0x20016374

00009710 <lwip_bind>:
{
    9710:	b537      	push	{r0, r1, r2, r4, r5, lr}
	sock = get_socket(s);
    9712:	4b13      	ldr	r3, [pc, #76]	; (9760 <lwip_bind+0x50>)
{
    9714:	4615      	mov	r5, r2
	sock = get_socket(s);
    9716:	4798      	blx	r3
	if (!sock) {
    9718:	4604      	mov	r4, r0
    971a:	b1d8      	cbz	r0, 9754 <lwip_bind+0x44>
	LWIP_ERROR(
    971c:	2d10      	cmp	r5, #16
    971e:	d104      	bne.n	972a <lwip_bind+0x1a>
    9720:	784b      	ldrb	r3, [r1, #1]
    9722:	2b02      	cmp	r3, #2
    9724:	d101      	bne.n	972a <lwip_bind+0x1a>
    9726:	078b      	lsls	r3, r1, #30
    9728:	d000      	beq.n	972c <lwip_bind+0x1c>
    972a:	e7fe      	b.n	972a <lwip_bind+0x1a>
	inet_addr_to_ipaddr(&local_addr, &name_in->sin_addr);
    972c:	684b      	ldr	r3, [r1, #4]
	err = netconn_bind(sock->conn, &local_addr, ntohs(local_port));
    972e:	6805      	ldr	r5, [r0, #0]
	inet_addr_to_ipaddr(&local_addr, &name_in->sin_addr);
    9730:	9301      	str	r3, [sp, #4]
	err = netconn_bind(sock->conn, &local_addr, ntohs(local_port));
    9732:	8848      	ldrh	r0, [r1, #2]
    9734:	4b0b      	ldr	r3, [pc, #44]	; (9764 <lwip_bind+0x54>)
    9736:	4798      	blx	r3
    9738:	4b0b      	ldr	r3, [pc, #44]	; (9768 <lwip_bind+0x58>)
    973a:	4602      	mov	r2, r0
    973c:	a901      	add	r1, sp, #4
    973e:	4628      	mov	r0, r5
    9740:	4798      	blx	r3
	if (err != ERR_OK) {
    9742:	b150      	cbz	r0, 975a <lwip_bind+0x4a>
		sock_set_errno(sock, err_to_errno(err));
    9744:	4243      	negs	r3, r0
    9746:	2b0f      	cmp	r3, #15
    9748:	bf96      	itet	ls
    974a:	4a08      	ldrls	r2, [pc, #32]	; (976c <lwip_bind+0x5c>)
    974c:	2305      	movhi	r3, #5
    974e:	f852 3023 	ldrls.w	r3, [r2, r3, lsl #2]
    9752:	6123      	str	r3, [r4, #16]
		return -1;
    9754:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    9758:	e000      	b.n	975c <lwip_bind+0x4c>
	sock_set_errno(sock, 0);
    975a:	6120      	str	r0, [r4, #16]
}
    975c:	b003      	add	sp, #12
    975e:	bd30      	pop	{r4, r5, pc}
    9760:	00009419 	.word	0x00009419
    9764:	00000d67 	.word	0x00000d67
    9768:	00007689 	.word	0x00007689
    976c:	0000cca8 	.word	0x0000cca8

00009770 <lwip_close>:
{
    9770:	b570      	push	{r4, r5, r6, lr}
	sock = get_socket(s);
    9772:	4b12      	ldr	r3, [pc, #72]	; (97bc <lwip_close+0x4c>)
    9774:	4798      	blx	r3
	if (!sock) {
    9776:	4604      	mov	r4, r0
    9778:	b1d0      	cbz	r0, 97b0 <lwip_close+0x40>
	if (sock->conn != NULL) {
    977a:	6800      	ldr	r0, [r0, #0]
    977c:	b198      	cbz	r0, 97a6 <lwip_close+0x36>
		is_tcp = netconn_type(sock->conn) == NETCONN_TCP;
    977e:	7805      	ldrb	r5, [r0, #0]
    9780:	f1a5 0310 	sub.w	r3, r5, #16
    9784:	425d      	negs	r5, r3
    9786:	415d      	adcs	r5, r3
	netconn_delete(sock->conn);
    9788:	4b0d      	ldr	r3, [pc, #52]	; (97c0 <lwip_close+0x50>)
    978a:	4798      	blx	r3
	lastdata         = sock->lastdata;
    978c:	6860      	ldr	r0, [r4, #4]
	sock->lastdata   = NULL;
    978e:	2600      	movs	r6, #0
    9790:	6066      	str	r6, [r4, #4]
	sock->lastoffset = 0;
    9792:	8126      	strh	r6, [r4, #8]
	sock->err        = 0;
    9794:	6126      	str	r6, [r4, #16]
	sock->conn = NULL;
    9796:	6026      	str	r6, [r4, #0]
	if (lastdata != NULL) {
    9798:	b168      	cbz	r0, 97b6 <lwip_close+0x46>
		if (is_tcp) {
    979a:	b135      	cbz	r5, 97aa <lwip_close+0x3a>
			pbuf_free((struct pbuf *)lastdata);
    979c:	4b09      	ldr	r3, [pc, #36]	; (97c4 <lwip_close+0x54>)
    979e:	4798      	blx	r3
	return 0;
    97a0:	4635      	mov	r5, r6
}
    97a2:	4628      	mov	r0, r5
    97a4:	bd70      	pop	{r4, r5, r6, pc}
	int               is_tcp = 0;
    97a6:	4605      	mov	r5, r0
    97a8:	e7ee      	b.n	9788 <lwip_close+0x18>
			netbuf_delete((struct netbuf *)lastdata);
    97aa:	4b07      	ldr	r3, [pc, #28]	; (97c8 <lwip_close+0x58>)
    97ac:	4798      	blx	r3
    97ae:	e7f8      	b.n	97a2 <lwip_close+0x32>
		return -1;
    97b0:	f04f 35ff 	mov.w	r5, #4294967295	; 0xffffffff
    97b4:	e7f5      	b.n	97a2 <lwip_close+0x32>
	return 0;
    97b6:	4605      	mov	r5, r0
    97b8:	e7f3      	b.n	97a2 <lwip_close+0x32>
    97ba:	bf00      	nop
    97bc:	00009419 	.word	0x00009419
    97c0:	00007621 	.word	0x00007621
    97c4:	000030e1 	.word	0x000030e1
    97c8:	00000d79 	.word	0x00000d79

000097cc <lwip_listen>:
{
    97cc:	b510      	push	{r4, lr}
	sock = get_socket(s);
    97ce:	4b0e      	ldr	r3, [pc, #56]	; (9808 <lwip_listen+0x3c>)
    97d0:	4798      	blx	r3
	if (!sock) {
    97d2:	4604      	mov	r4, r0
    97d4:	b1a8      	cbz	r0, 9802 <lwip_listen+0x36>
	err = netconn_listen_with_backlog(sock->conn, (u8_t)backlog);
    97d6:	f381 0108 	usat	r1, #8, r1
    97da:	6800      	ldr	r0, [r0, #0]
    97dc:	4b0b      	ldr	r3, [pc, #44]	; (980c <lwip_listen+0x40>)
    97de:	b2c9      	uxtb	r1, r1
    97e0:	4798      	blx	r3
	if (err != ERR_OK) {
    97e2:	b120      	cbz	r0, 97ee <lwip_listen+0x22>
		if (netconn_type(sock->conn) != NETCONN_TCP) {
    97e4:	6823      	ldr	r3, [r4, #0]
    97e6:	781b      	ldrb	r3, [r3, #0]
    97e8:	2b10      	cmp	r3, #16
    97ea:	d002      	beq.n	97f2 <lwip_listen+0x26>
			sock_set_errno(sock, EOPNOTSUPP);
    97ec:	205f      	movs	r0, #95	; 0x5f
	sock_set_errno(sock, 0);
    97ee:	6120      	str	r0, [r4, #16]
}
    97f0:	bd10      	pop	{r4, pc}
		sock_set_errno(sock, err_to_errno(err));
    97f2:	4243      	negs	r3, r0
    97f4:	2b0f      	cmp	r3, #15
    97f6:	bf96      	itet	ls
    97f8:	4a05      	ldrls	r2, [pc, #20]	; (9810 <lwip_listen+0x44>)
    97fa:	2305      	movhi	r3, #5
    97fc:	f852 3023 	ldrls.w	r3, [r2, r3, lsl #2]
    9800:	6123      	str	r3, [r4, #16]
		return -1;
    9802:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    9806:	e7f3      	b.n	97f0 <lwip_listen+0x24>
    9808:	00009419 	.word	0x00009419
    980c:	000076bd 	.word	0x000076bd
    9810:	0000cca8 	.word	0x0000cca8

00009814 <lwip_recvfrom>:
{
    9814:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    9818:	b08b      	sub	sp, #44	; 0x2c
    981a:	469b      	mov	fp, r3
	void *            buf = NULL;
    981c:	2500      	movs	r5, #0
	sock = get_socket(s);
    981e:	4b69      	ldr	r3, [pc, #420]	; (99c4 <lwip_recvfrom+0x1b0>)
{
    9820:	9101      	str	r1, [sp, #4]
    9822:	4690      	mov	r8, r2
	void *            buf = NULL;
    9824:	9504      	str	r5, [sp, #16]
	sock = get_socket(s);
    9826:	4798      	blx	r3
{
    9828:	f8dd 9054 	ldr.w	r9, [sp, #84]	; 0x54
	if (!sock) {
    982c:	4604      	mov	r4, r0
    982e:	2800      	cmp	r0, #0
    9830:	d05b      	beq.n	98ea <lwip_recvfrom+0xd6>
		if (sock->lastdata) {
    9832:	6863      	ldr	r3, [r4, #4]
    9834:	2b00      	cmp	r3, #0
    9836:	d045      	beq.n	98c4 <lwip_recvfrom+0xb0>
			buf = sock->lastdata;
    9838:	9304      	str	r3, [sp, #16]
		if (netconn_type(sock->conn) == NETCONN_TCP) {
    983a:	6823      	ldr	r3, [r4, #0]
			p = (struct pbuf *)buf;
    983c:	f8dd a010 	ldr.w	sl, [sp, #16]
		if (netconn_type(sock->conn) == NETCONN_TCP) {
    9840:	781b      	ldrb	r3, [r3, #0]
		pbuf_copy_partial(p, (u8_t *)mem + off, copylen, sock->lastoffset);
    9842:	9901      	ldr	r1, [sp, #4]
		if (netconn_type(sock->conn) == NETCONN_TCP) {
    9844:	2b10      	cmp	r3, #16
			p = ((struct netbuf *)buf)->p;
    9846:	bf18      	it	ne
    9848:	f8da a000 	ldrne.w	sl, [sl]
		buflen -= sock->lastoffset;
    984c:	8923      	ldrh	r3, [r4, #8]
		buflen = p->tot_len;
    984e:	f8ba 6008 	ldrh.w	r6, [sl, #8]
		buflen -= sock->lastoffset;
    9852:	1af6      	subs	r6, r6, r3
    9854:	b2b2      	uxth	r2, r6
		if (len > buflen) {
    9856:	4542      	cmp	r2, r8
		buflen -= sock->lastoffset;
    9858:	9200      	str	r2, [sp, #0]
			copylen = buflen;
    985a:	bf38      	it	cc
    985c:	9f00      	ldrcc	r7, [sp, #0]
		pbuf_copy_partial(p, (u8_t *)mem + off, copylen, sock->lastoffset);
    985e:	4e5a      	ldr	r6, [pc, #360]	; (99c8 <lwip_recvfrom+0x1b4>)
			copylen = (u16_t)len;
    9860:	bf28      	it	cs
    9862:	fa1f f788 	uxthcs.w	r7, r8
		pbuf_copy_partial(p, (u8_t *)mem + off, copylen, sock->lastoffset);
    9866:	463a      	mov	r2, r7
    9868:	4429      	add	r1, r5
    986a:	4650      	mov	r0, sl
    986c:	47b0      	blx	r6
		if (netconn_type(sock->conn) == NETCONN_TCP) {
    986e:	6820      	ldr	r0, [r4, #0]
    9870:	7803      	ldrb	r3, [r0, #0]
			if ((len <= 0) || (p->flags & PBUF_FLAG_PUSH) || (sock->rcvevent <= 0) || ((flags & MSG_PEEK) != 0)) {
    9872:	f00b 0201 	and.w	r2, fp, #1
		if (netconn_type(sock->conn) == NETCONN_TCP) {
    9876:	2b10      	cmp	r3, #16
		off += copylen;
    9878:	443d      	add	r5, r7
			if ((len <= 0) || (p->flags & PBUF_FLAG_PUSH) || (sock->rcvevent <= 0) || ((flags & MSG_PEEK) != 0)) {
    987a:	4616      	mov	r6, r2
		if (netconn_type(sock->conn) == NETCONN_TCP) {
    987c:	d156      	bne.n	992c <lwip_recvfrom+0x118>
			if ((len <= 0) || (p->flags & PBUF_FLAG_PUSH) || (sock->rcvevent <= 0) || ((flags & MSG_PEEK) != 0)) {
    987e:	ebb8 0807 	subs.w	r8, r8, r7
    9882:	d053      	beq.n	992c <lwip_recvfrom+0x118>
    9884:	f89a a00d 	ldrb.w	sl, [sl, #13]
    9888:	f01a 0a01 	ands.w	sl, sl, #1
    988c:	d14e      	bne.n	992c <lwip_recvfrom+0x118>
    988e:	f9b4 200a 	ldrsh.w	r2, [r4, #10]
    9892:	2a00      	cmp	r2, #0
    9894:	dd4a      	ble.n	992c <lwip_recvfrom+0x118>
    9896:	2e00      	cmp	r6, #0
    9898:	f040 808c 	bne.w	99b4 <lwip_recvfrom+0x1a0>
			if ((netconn_type(sock->conn) == NETCONN_TCP) && (buflen - copylen > 0)) {
    989c:	6823      	ldr	r3, [r4, #0]
				sock->lastdata = buf;
    989e:	9804      	ldr	r0, [sp, #16]
			if ((netconn_type(sock->conn) == NETCONN_TCP) && (buflen - copylen > 0)) {
    98a0:	781b      	ldrb	r3, [r3, #0]
    98a2:	2b10      	cmp	r3, #16
    98a4:	d17b      	bne.n	999e <lwip_recvfrom+0x18a>
    98a6:	9a00      	ldr	r2, [sp, #0]
    98a8:	1bd6      	subs	r6, r2, r7
    98aa:	2e00      	cmp	r6, #0
    98ac:	dd77      	ble.n	999e <lwip_recvfrom+0x18a>
				sock->lastoffset += copylen;
    98ae:	8923      	ldrh	r3, [r4, #8]
				sock->lastdata = buf;
    98b0:	6060      	str	r0, [r4, #4]
				sock->lastoffset += copylen;
    98b2:	441f      	add	r7, r3
    98b4:	8127      	strh	r7, [r4, #8]
	} while (!done);
    98b6:	f1ba 0f00 	cmp.w	sl, #0
    98ba:	d0ba      	beq.n	9832 <lwip_recvfrom+0x1e>
	if (off > 0) {
    98bc:	b975      	cbnz	r5, 98dc <lwip_recvfrom+0xc8>
	sock_set_errno(sock, 0);
    98be:	2300      	movs	r3, #0
    98c0:	6123      	str	r3, [r4, #16]
	return off;
    98c2:	e02c      	b.n	991e <lwip_recvfrom+0x10a>
			if (((flags & MSG_DONTWAIT) || netconn_is_nonblocking(sock->conn)) && (sock->rcvevent <= 0)) {
    98c4:	f01b 0f08 	tst.w	fp, #8
    98c8:	d103      	bne.n	98d2 <lwip_recvfrom+0xbe>
    98ca:	6823      	ldr	r3, [r4, #0]
    98cc:	7f1b      	ldrb	r3, [r3, #28]
    98ce:	079b      	lsls	r3, r3, #30
    98d0:	d50e      	bpl.n	98f0 <lwip_recvfrom+0xdc>
    98d2:	f9b4 300a 	ldrsh.w	r3, [r4, #10]
    98d6:	2b00      	cmp	r3, #0
    98d8:	dc0a      	bgt.n	98f0 <lwip_recvfrom+0xdc>
				if (off > 0) {
    98da:	b125      	cbz	r5, 98e6 <lwip_recvfrom+0xd2>
		netconn_recved(sock->conn, (u32_t)off);
    98dc:	6820      	ldr	r0, [r4, #0]
    98de:	4b3b      	ldr	r3, [pc, #236]	; (99cc <lwip_recvfrom+0x1b8>)
    98e0:	4629      	mov	r1, r5
    98e2:	4798      	blx	r3
    98e4:	e7eb      	b.n	98be <lwip_recvfrom+0xaa>
				sock_set_errno(sock, EWOULDBLOCK);
    98e6:	230b      	movs	r3, #11
    98e8:	6123      	str	r3, [r4, #16]
		return -1;
    98ea:	f04f 35ff 	mov.w	r5, #4294967295	; 0xffffffff
    98ee:	e016      	b.n	991e <lwip_recvfrom+0x10a>
			if (netconn_type(sock->conn) == NETCONN_TCP) {
    98f0:	6820      	ldr	r0, [r4, #0]
    98f2:	7803      	ldrb	r3, [r0, #0]
    98f4:	2b10      	cmp	r3, #16
				err = netconn_recv_tcp_pbuf(sock->conn, (struct pbuf **)&buf);
    98f6:	bf0c      	ite	eq
    98f8:	4b35      	ldreq	r3, [pc, #212]	; (99d0 <lwip_recvfrom+0x1bc>)
				err = netconn_recv(sock->conn, (struct netbuf **)&buf);
    98fa:	4b36      	ldrne	r3, [pc, #216]	; (99d4 <lwip_recvfrom+0x1c0>)
				err = netconn_recv_tcp_pbuf(sock->conn, (struct pbuf **)&buf);
    98fc:	a904      	add	r1, sp, #16
				err = netconn_recv(sock->conn, (struct netbuf **)&buf);
    98fe:	4798      	blx	r3
			if (err != ERR_OK) {
    9900:	b188      	cbz	r0, 9926 <lwip_recvfrom+0x112>
				if (off > 0) {
    9902:	2d00      	cmp	r5, #0
    9904:	d1ea      	bne.n	98dc <lwip_recvfrom+0xc8>
				sock_set_errno(sock, err_to_errno(err));
    9906:	4243      	negs	r3, r0
    9908:	2b0f      	cmp	r3, #15
    990a:	bf96      	itet	ls
    990c:	4a32      	ldrls	r2, [pc, #200]	; (99d8 <lwip_recvfrom+0x1c4>)
    990e:	2305      	movhi	r3, #5
    9910:	f852 3023 	ldrls.w	r3, [r2, r3, lsl #2]
    9914:	6123      	str	r3, [r4, #16]
				if (err == ERR_CLSD) {
    9916:	300c      	adds	r0, #12
    9918:	bf18      	it	ne
    991a:	2001      	movne	r0, #1
    991c:	4245      	negs	r5, r0
}
    991e:	4628      	mov	r0, r5
    9920:	b00b      	add	sp, #44	; 0x2c
    9922:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
			sock->lastdata = buf;
    9926:	9b04      	ldr	r3, [sp, #16]
    9928:	6063      	str	r3, [r4, #4]
    992a:	e786      	b.n	983a <lwip_recvfrom+0x26>
			if (from && fromlen) {
    992c:	9a14      	ldr	r2, [sp, #80]	; 0x50
    992e:	b352      	cbz	r2, 9986 <lwip_recvfrom+0x172>
    9930:	f1b9 0f00 	cmp.w	r9, #0
    9934:	d027      	beq.n	9986 <lwip_recvfrom+0x172>
				if (netconn_type(sock->conn) == NETCONN_TCP) {
    9936:	2b10      	cmp	r3, #16
    9938:	d12a      	bne.n	9990 <lwip_recvfrom+0x17c>
					netconn_getaddr(sock->conn, addr, &port, 0);
    993a:	f8df a0b0 	ldr.w	sl, [pc, #176]	; 99ec <lwip_recvfrom+0x1d8>
    993e:	2300      	movs	r3, #0
    9940:	f10d 020e 	add.w	r2, sp, #14
    9944:	a905      	add	r1, sp, #20
    9946:	47d0      	blx	sl
					addr = &fromaddr;
    9948:	f10d 0a14 	add.w	sl, sp, #20
				memset(&sin, 0, sizeof(sin));
    994c:	2300      	movs	r3, #0
    994e:	e9cd 3308 	strd	r3, r3, [sp, #32]
				sin.sin_len    = sizeof(sin);
    9952:	f44f 7304 	mov.w	r3, #528	; 0x210
    9956:	f8ad 3018 	strh.w	r3, [sp, #24]
				sin.sin_port   = htons(port);
    995a:	f8bd 000e 	ldrh.w	r0, [sp, #14]
    995e:	4b1f      	ldr	r3, [pc, #124]	; (99dc <lwip_recvfrom+0x1c8>)
    9960:	4798      	blx	r3
				inet_addr_from_ipaddr(&sin.sin_addr, addr);
    9962:	f8da 3000 	ldr.w	r3, [sl]
    9966:	9307      	str	r3, [sp, #28]
				if (*fromlen > sizeof(sin)) {
    9968:	f8d9 3000 	ldr.w	r3, [r9]
				sin.sin_port   = htons(port);
    996c:	f8ad 001a 	strh.w	r0, [sp, #26]
				if (*fromlen > sizeof(sin)) {
    9970:	2b10      	cmp	r3, #16
					*fromlen = sizeof(sin);
    9972:	bf84      	itt	hi
    9974:	2310      	movhi	r3, #16
    9976:	f8c9 3000 	strhi.w	r3, [r9]
				MEMCPY(from, &sin, *fromlen);
    997a:	f8d9 2000 	ldr.w	r2, [r9]
    997e:	9814      	ldr	r0, [sp, #80]	; 0x50
    9980:	4b17      	ldr	r3, [pc, #92]	; (99e0 <lwip_recvfrom+0x1cc>)
    9982:	a906      	add	r1, sp, #24
    9984:	4798      	blx	r3
		if ((flags & MSG_PEEK) == 0) {
    9986:	2e00      	cmp	r6, #0
    9988:	d198      	bne.n	98bc <lwip_recvfrom+0xa8>
    998a:	f04f 0a01 	mov.w	sl, #1
    998e:	e785      	b.n	989c <lwip_recvfrom+0x88>
					addr = netbuf_fromaddr((struct netbuf *)buf);
    9990:	9b04      	ldr	r3, [sp, #16]
    9992:	f103 0a08 	add.w	sl, r3, #8
					port = netbuf_fromport((struct netbuf *)buf);
    9996:	899b      	ldrh	r3, [r3, #12]
    9998:	f8ad 300e 	strh.w	r3, [sp, #14]
    999c:	e7d6      	b.n	994c <lwip_recvfrom+0x138>
				sock->lastdata   = NULL;
    999e:	2200      	movs	r2, #0
				if (netconn_type(sock->conn) == NETCONN_TCP) {
    99a0:	2b10      	cmp	r3, #16
				sock->lastdata   = NULL;
    99a2:	6062      	str	r2, [r4, #4]
				sock->lastoffset = 0;
    99a4:	8122      	strh	r2, [r4, #8]
				if (netconn_type(sock->conn) == NETCONN_TCP) {
    99a6:	d102      	bne.n	99ae <lwip_recvfrom+0x19a>
					pbuf_free((struct pbuf *)buf);
    99a8:	4b0e      	ldr	r3, [pc, #56]	; (99e4 <lwip_recvfrom+0x1d0>)
    99aa:	4798      	blx	r3
    99ac:	e783      	b.n	98b6 <lwip_recvfrom+0xa2>
					netbuf_delete((struct netbuf *)buf);
    99ae:	4b0e      	ldr	r3, [pc, #56]	; (99e8 <lwip_recvfrom+0x1d4>)
    99b0:	4798      	blx	r3
    99b2:	e780      	b.n	98b6 <lwip_recvfrom+0xa2>
			if (from && fromlen) {
    99b4:	9b14      	ldr	r3, [sp, #80]	; 0x50
    99b6:	2b00      	cmp	r3, #0
    99b8:	d080      	beq.n	98bc <lwip_recvfrom+0xa8>
    99ba:	f1b9 0f00 	cmp.w	r9, #0
    99be:	d1bc      	bne.n	993a <lwip_recvfrom+0x126>
    99c0:	e7e1      	b.n	9986 <lwip_recvfrom+0x172>
    99c2:	bf00      	nop
    99c4:	00009419 	.word	0x00009419
    99c8:	00003381 	.word	0x00003381
    99cc:	000077ed 	.word	0x000077ed
    99d0:	00007751 	.word	0x00007751
    99d4:	00007765 	.word	0x00007765
    99d8:	0000cca8 	.word	0x0000cca8
    99dc:	00000d61 	.word	0x00000d61
    99e0:	0000c07d 	.word	0x0000c07d
    99e4:	000030e1 	.word	0x000030e1
    99e8:	00000d79 	.word	0x00000d79
    99ec:	0000764d 	.word	0x0000764d

000099f0 <lwip_read>:
{
    99f0:	b513      	push	{r0, r1, r4, lr}
	return lwip_recvfrom(s, mem, len, 0, NULL, NULL);
    99f2:	2300      	movs	r3, #0
    99f4:	e9cd 3300 	strd	r3, r3, [sp]
    99f8:	4c01      	ldr	r4, [pc, #4]	; (9a00 <lwip_read+0x10>)
    99fa:	47a0      	blx	r4
}
    99fc:	b002      	add	sp, #8
    99fe:	bd10      	pop	{r4, pc}
    9a00:	00009815 	.word	0x00009815

00009a04 <lwip_sendto>:
{
    9a04:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
    9a08:	b087      	sub	sp, #28
    9a0a:	4614      	mov	r4, r2
	sock = get_socket(s);
    9a0c:	4a28      	ldr	r2, [pc, #160]	; (9ab0 <lwip_sendto+0xac>)
{
    9a0e:	9301      	str	r3, [sp, #4]
    9a10:	4680      	mov	r8, r0
	sock = get_socket(s);
    9a12:	4790      	blx	r2
{
    9a14:	e9dd 590e 	ldrd	r5, r9, [sp, #56]	; 0x38
	if (!sock) {
    9a18:	9b01      	ldr	r3, [sp, #4]
{
    9a1a:	460f      	mov	r7, r1
	if (!sock) {
    9a1c:	4606      	mov	r6, r0
    9a1e:	b920      	cbnz	r0, 9a2a <lwip_sendto+0x26>
		return -1;
    9a20:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
}
    9a24:	b007      	add	sp, #28
    9a26:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
	if (sock->conn->type == NETCONN_TCP) {
    9a2a:	6802      	ldr	r2, [r0, #0]
    9a2c:	7812      	ldrb	r2, [r2, #0]
    9a2e:	2a10      	cmp	r2, #16
    9a30:	d107      	bne.n	9a42 <lwip_sendto+0x3e>
		return lwip_send(s, data, size, flags);
    9a32:	4622      	mov	r2, r4
    9a34:	4c1f      	ldr	r4, [pc, #124]	; (9ab4 <lwip_sendto+0xb0>)
    9a36:	4640      	mov	r0, r8
    9a38:	46a4      	mov	ip, r4
}
    9a3a:	b007      	add	sp, #28
    9a3c:	e8bd 43f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, lr}
		return lwip_send(s, data, size, flags);
    9a40:	4760      	bx	ip
	LWIP_ERROR(
    9a42:	b915      	cbnz	r5, 9a4a <lwip_sendto+0x46>
    9a44:	f1b9 0f00 	cmp.w	r9, #0
    9a48:	d008      	beq.n	9a5c <lwip_sendto+0x58>
    9a4a:	f1b9 0f10 	cmp.w	r9, #16
    9a4e:	d104      	bne.n	9a5a <lwip_sendto+0x56>
    9a50:	786b      	ldrb	r3, [r5, #1]
    9a52:	2b02      	cmp	r3, #2
    9a54:	d101      	bne.n	9a5a <lwip_sendto+0x56>
    9a56:	07ab      	lsls	r3, r5, #30
    9a58:	d000      	beq.n	9a5c <lwip_sendto+0x58>
    9a5a:	e7fe      	b.n	9a5a <lwip_sendto+0x56>
	buf.p = buf.ptr = NULL;
    9a5c:	2300      	movs	r3, #0
    9a5e:	e9cd 3302 	strd	r3, r3, [sp, #8]
	if (to) {
    9a62:	b30d      	cbz	r5, 9aa8 <lwip_sendto+0xa4>
		inet_addr_to_ipaddr(&buf.addr, &to_in->sin_addr);
    9a64:	686b      	ldr	r3, [r5, #4]
    9a66:	9304      	str	r3, [sp, #16]
		remote_port = ntohs(to_in->sin_port);
    9a68:	8868      	ldrh	r0, [r5, #2]
    9a6a:	4b13      	ldr	r3, [pc, #76]	; (9ab8 <lwip_sendto+0xb4>)
    9a6c:	4798      	blx	r3
		netbuf_fromport(&buf) = remote_port;
    9a6e:	f8ad 0014 	strh.w	r0, [sp, #20]
	err = netbuf_ref(&buf, data, short_size);
    9a72:	4b12      	ldr	r3, [pc, #72]	; (9abc <lwip_sendto+0xb8>)
    9a74:	b2a2      	uxth	r2, r4
    9a76:	4639      	mov	r1, r7
    9a78:	a802      	add	r0, sp, #8
    9a7a:	4798      	blx	r3
	if (err == ERR_OK) {
    9a7c:	4605      	mov	r5, r0
    9a7e:	b920      	cbnz	r0, 9a8a <lwip_sendto+0x86>
		err = netconn_send(sock->conn, &buf);
    9a80:	6830      	ldr	r0, [r6, #0]
    9a82:	4b0f      	ldr	r3, [pc, #60]	; (9ac0 <lwip_sendto+0xbc>)
    9a84:	a902      	add	r1, sp, #8
    9a86:	4798      	blx	r3
    9a88:	4605      	mov	r5, r0
	netbuf_free(&buf);
    9a8a:	4b0e      	ldr	r3, [pc, #56]	; (9ac4 <lwip_sendto+0xc0>)
    9a8c:	a802      	add	r0, sp, #8
    9a8e:	4798      	blx	r3
	sock_set_errno(sock, err_to_errno(err));
    9a90:	426b      	negs	r3, r5
    9a92:	2b0f      	cmp	r3, #15
    9a94:	bf96      	itet	ls
    9a96:	4a0c      	ldrls	r2, [pc, #48]	; (9ac8 <lwip_sendto+0xc4>)
    9a98:	2305      	movhi	r3, #5
    9a9a:	f852 3023 	ldrls.w	r3, [r2, r3, lsl #2]
    9a9e:	6133      	str	r3, [r6, #16]
	return (err == ERR_OK ? short_size : -1);
    9aa0:	2d00      	cmp	r5, #0
    9aa2:	d1bd      	bne.n	9a20 <lwip_sendto+0x1c>
    9aa4:	b2a0      	uxth	r0, r4
    9aa6:	e7bd      	b.n	9a24 <lwip_sendto+0x20>
		ip_addr_set_any(&buf.addr);
    9aa8:	9504      	str	r5, [sp, #16]
		netbuf_fromport(&buf) = 0;
    9aaa:	f8ad 5014 	strh.w	r5, [sp, #20]
    9aae:	e7e0      	b.n	9a72 <lwip_sendto+0x6e>
    9ab0:	00009419 	.word	0x00009419
    9ab4:	00009acd 	.word	0x00009acd
    9ab8:	00000d67 	.word	0x00000d67
    9abc:	00000dc1 	.word	0x00000dc1
    9ac0:	00007819 	.word	0x00007819
    9ac4:	00000da5 	.word	0x00000da5
    9ac8:	0000cca8 	.word	0x0000cca8

00009acc <lwip_send>:
{
    9acc:	b570      	push	{r4, r5, r6, lr}
    9ace:	b086      	sub	sp, #24
    9ad0:	461c      	mov	r4, r3
	sock = get_socket(s);
    9ad2:	4b19      	ldr	r3, [pc, #100]	; (9b38 <lwip_send+0x6c>)
{
    9ad4:	9203      	str	r2, [sp, #12]
    9ad6:	4606      	mov	r6, r0
	sock = get_socket(s);
    9ad8:	4798      	blx	r3
	if (!sock) {
    9ada:	9a03      	ldr	r2, [sp, #12]
    9adc:	4605      	mov	r5, r0
    9ade:	b918      	cbnz	r0, 9ae8 <lwip_send+0x1c>
		return -1;
    9ae0:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
}
    9ae4:	b006      	add	sp, #24
    9ae6:	bd70      	pop	{r4, r5, r6, pc}
	if (sock->conn->type != NETCONN_TCP) {
    9ae8:	6800      	ldr	r0, [r0, #0]
    9aea:	7803      	ldrb	r3, [r0, #0]
    9aec:	2b10      	cmp	r3, #16
    9aee:	f04f 0300 	mov.w	r3, #0
    9af2:	d006      	beq.n	9b02 <lwip_send+0x36>
		return lwip_sendto(s, data, size, flags, NULL, 0);
    9af4:	e9cd 3300 	strd	r3, r3, [sp]
    9af8:	4630      	mov	r0, r6
    9afa:	4623      	mov	r3, r4
    9afc:	4c0f      	ldr	r4, [pc, #60]	; (9b3c <lwip_send+0x70>)
    9afe:	47a0      	blx	r4
    9b00:	e7f0      	b.n	9ae4 <lwip_send+0x18>
	written = 0;
    9b02:	9305      	str	r3, [sp, #20]
	    = NETCONN_COPY | ((flags & MSG_MORE) ? NETCONN_MORE : 0) | ((flags & MSG_DONTWAIT) ? NETCONN_DONTBLOCK : 0);
    9b04:	10e6      	asrs	r6, r4, #3
    9b06:	1063      	asrs	r3, r4, #1
    9b08:	f006 0602 	and.w	r6, r6, #2
    9b0c:	f003 0304 	and.w	r3, r3, #4
	err     = netconn_write_partly(sock->conn, data, size, write_flags, &written);
    9b10:	ac05      	add	r4, sp, #20
	    = NETCONN_COPY | ((flags & MSG_MORE) ? NETCONN_MORE : 0) | ((flags & MSG_DONTWAIT) ? NETCONN_DONTBLOCK : 0);
    9b12:	4333      	orrs	r3, r6
	err     = netconn_write_partly(sock->conn, data, size, write_flags, &written);
    9b14:	9400      	str	r4, [sp, #0]
    9b16:	f043 0301 	orr.w	r3, r3, #1
    9b1a:	4c09      	ldr	r4, [pc, #36]	; (9b40 <lwip_send+0x74>)
    9b1c:	47a0      	blx	r4
	sock_set_errno(sock, err_to_errno(err));
    9b1e:	4243      	negs	r3, r0
    9b20:	2b0f      	cmp	r3, #15
    9b22:	bf96      	itet	ls
    9b24:	4a07      	ldrls	r2, [pc, #28]	; (9b44 <lwip_send+0x78>)
    9b26:	2305      	movhi	r3, #5
    9b28:	f852 3023 	ldrls.w	r3, [r2, r3, lsl #2]
    9b2c:	612b      	str	r3, [r5, #16]
	return (err == ERR_OK ? (int)written : -1);
    9b2e:	2800      	cmp	r0, #0
    9b30:	d1d6      	bne.n	9ae0 <lwip_send+0x14>
    9b32:	9805      	ldr	r0, [sp, #20]
    9b34:	e7d6      	b.n	9ae4 <lwip_send+0x18>
    9b36:	bf00      	nop
    9b38:	00009419 	.word	0x00009419
    9b3c:	00009a05 	.word	0x00009a05
    9b40:	00007849 	.word	0x00007849
    9b44:	0000cca8 	.word	0x0000cca8

00009b48 <lwip_socket>:
	switch (type) {
    9b48:	2902      	cmp	r1, #2
{
    9b4a:	b538      	push	{r3, r4, r5, lr}
    9b4c:	4613      	mov	r3, r2
	switch (type) {
    9b4e:	d01a      	beq.n	9b86 <lwip_socket+0x3e>
    9b50:	2903      	cmp	r1, #3
    9b52:	d005      	beq.n	9b60 <lwip_socket+0x18>
    9b54:	2901      	cmp	r1, #1
    9b56:	d01e      	beq.n	9b96 <lwip_socket+0x4e>
		return -1;
    9b58:	f04f 35ff 	mov.w	r5, #4294967295	; 0xffffffff
}
    9b5c:	4628      	mov	r0, r5
    9b5e:	bd38      	pop	{r3, r4, r5, pc}
		conn = netconn_new_with_proto_and_callback(NETCONN_RAW, (u8_t)protocol, event_callback);
    9b60:	4a14      	ldr	r2, [pc, #80]	; (9bb4 <lwip_socket+0x6c>)
    9b62:	b2d9      	uxtb	r1, r3
    9b64:	2040      	movs	r0, #64	; 0x40
		conn = netconn_new_with_callback((protocol == IPPROTO_UDPLITE) ? NETCONN_UDPLITE : NETCONN_UDP, event_callback);
    9b66:	4b14      	ldr	r3, [pc, #80]	; (9bb8 <lwip_socket+0x70>)
    9b68:	4798      	blx	r3
    9b6a:	4604      	mov	r4, r0
	if (!conn) {
    9b6c:	2800      	cmp	r0, #0
    9b6e:	d0f3      	beq.n	9b58 <lwip_socket+0x10>
	i = alloc_socket(conn, 0);
    9b70:	4b12      	ldr	r3, [pc, #72]	; (9bbc <lwip_socket+0x74>)
    9b72:	2100      	movs	r1, #0
    9b74:	4620      	mov	r0, r4
    9b76:	4798      	blx	r3
	if (i == -1) {
    9b78:	1c43      	adds	r3, r0, #1
	i = alloc_socket(conn, 0);
    9b7a:	4605      	mov	r5, r0
	if (i == -1) {
    9b7c:	d118      	bne.n	9bb0 <lwip_socket+0x68>
		netconn_delete(conn);
    9b7e:	4b10      	ldr	r3, [pc, #64]	; (9bc0 <lwip_socket+0x78>)
    9b80:	4620      	mov	r0, r4
    9b82:	4798      	blx	r3
		return -1;
    9b84:	e7ea      	b.n	9b5c <lwip_socket+0x14>
		conn = netconn_new_with_callback((protocol == IPPROTO_UDPLITE) ? NETCONN_UDPLITE : NETCONN_UDP, event_callback);
    9b86:	2a88      	cmp	r2, #136	; 0x88
    9b88:	f04f 0100 	mov.w	r1, #0
    9b8c:	4a09      	ldr	r2, [pc, #36]	; (9bb4 <lwip_socket+0x6c>)
    9b8e:	bf0c      	ite	eq
    9b90:	2021      	moveq	r0, #33	; 0x21
    9b92:	2020      	movne	r0, #32
    9b94:	e7e7      	b.n	9b66 <lwip_socket+0x1e>
		conn = netconn_new_with_callback(NETCONN_TCP, event_callback);
    9b96:	4a07      	ldr	r2, [pc, #28]	; (9bb4 <lwip_socket+0x6c>)
    9b98:	4b07      	ldr	r3, [pc, #28]	; (9bb8 <lwip_socket+0x70>)
    9b9a:	2100      	movs	r1, #0
    9b9c:	2010      	movs	r0, #16
    9b9e:	4798      	blx	r3
		if (conn != NULL) {
    9ba0:	4604      	mov	r4, r0
    9ba2:	2800      	cmp	r0, #0
    9ba4:	d0d8      	beq.n	9b58 <lwip_socket+0x10>
			netconn_set_noautorecved(conn, 1);
    9ba6:	7f03      	ldrb	r3, [r0, #28]
    9ba8:	f043 0308 	orr.w	r3, r3, #8
    9bac:	7703      	strb	r3, [r0, #28]
	if (!conn) {
    9bae:	e7df      	b.n	9b70 <lwip_socket+0x28>
	conn->socket = i;
    9bb0:	61a0      	str	r0, [r4, #24]
	return i;
    9bb2:	e7d3      	b.n	9b5c <lwip_socket+0x14>
    9bb4:	00009475 	.word	0x00009475
    9bb8:	000075c5 	.word	0x000075c5
    9bbc:	00009439 	.word	0x00009439
    9bc0:	00007621 	.word	0x00007621

00009bc4 <lwip_write>:
{
    9bc4:	b410      	push	{r4}
	return lwip_send(s, data, size, 0);
    9bc6:	4c03      	ldr	r4, [pc, #12]	; (9bd4 <lwip_write+0x10>)
    9bc8:	2300      	movs	r3, #0
    9bca:	46a4      	mov	ip, r4
}
    9bcc:	f85d 4b04 	ldr.w	r4, [sp], #4
	return lwip_send(s, data, size, 0);
    9bd0:	4760      	bx	ip
    9bd2:	bf00      	nop
    9bd4:	00009acd 	.word	0x00009acd

00009bd8 <lwip_setsockopt>:
{
    9bd8:	b570      	push	{r4, r5, r6, lr}
    9bda:	461e      	mov	r6, r3
    9bdc:	b086      	sub	sp, #24
	struct lwip_sock *             sock = get_socket(s);
    9bde:	4b30      	ldr	r3, [pc, #192]	; (9ca0 <lwip_setsockopt+0xc8>)
{
    9be0:	4615      	mov	r5, r2
	struct lwip_sock *             sock = get_socket(s);
    9be2:	4798      	blx	r3
	if (!sock) {
    9be4:	4604      	mov	r4, r0
    9be6:	b110      	cbz	r0, 9bee <lwip_setsockopt+0x16>
	if (NULL == optval) {
    9be8:	b92e      	cbnz	r6, 9bf6 <lwip_setsockopt+0x1e>
		sock_set_errno(sock, EFAULT);
    9bea:	230e      	movs	r3, #14
    9bec:	6103      	str	r3, [r0, #16]
		return -1;
    9bee:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
}
    9bf2:	b006      	add	sp, #24
    9bf4:	bd70      	pop	{r4, r5, r6, pc}
	switch (level) {
    9bf6:	2906      	cmp	r1, #6
    9bf8:	d026      	beq.n	9c48 <lwip_setsockopt+0x70>
    9bfa:	f640 73ff 	movw	r3, #4095	; 0xfff
    9bfe:	4299      	cmp	r1, r3
    9c00:	d002      	beq.n	9c08 <lwip_setsockopt+0x30>
    9c02:	b1e9      	cbz	r1, 9c40 <lwip_setsockopt+0x68>
    9c04:	205c      	movs	r0, #92	; 0x5c
    9c06:	e046      	b.n	9c96 <lwip_setsockopt+0xbe>
		switch (optname) {
    9c08:	2d20      	cmp	r5, #32
    9c0a:	d005      	beq.n	9c18 <lwip_setsockopt+0x40>
    9c0c:	f241 030a 	movw	r3, #4106	; 0x100a
    9c10:	429d      	cmp	r5, r3
    9c12:	d006      	beq.n	9c22 <lwip_setsockopt+0x4a>
    9c14:	2d08      	cmp	r5, #8
    9c16:	d1f5      	bne.n	9c04 <lwip_setsockopt+0x2c>
			if (optlen < sizeof(int)) {
    9c18:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    9c1a:	2b03      	cmp	r3, #3
    9c1c:	d81e      	bhi.n	9c5c <lwip_setsockopt+0x84>
				err = EINVAL;
    9c1e:	2016      	movs	r0, #22
    9c20:	e039      	b.n	9c96 <lwip_setsockopt+0xbe>
			if (optlen < sizeof(int)) {
    9c22:	9b0a      	ldr	r3, [sp, #40]	; 0x28
				err = EINVAL;
    9c24:	2b03      	cmp	r3, #3
			if ((sock->conn->type != NETCONN_UDP) || ((udp_flags(sock->conn->pcb.udp) & UDP_FLAGS_UDPLITE) != 0)) {
    9c26:	6823      	ldr	r3, [r4, #0]
    9c28:	781a      	ldrb	r2, [r3, #0]
				err = EINVAL;
    9c2a:	bf8c      	ite	hi
    9c2c:	2000      	movhi	r0, #0
    9c2e:	2016      	movls	r0, #22
			if ((sock->conn->type != NETCONN_UDP) || ((udp_flags(sock->conn->pcb.udp) & UDP_FLAGS_UDPLITE) != 0)) {
    9c30:	2a20      	cmp	r2, #32
    9c32:	d103      	bne.n	9c3c <lwip_setsockopt+0x64>
    9c34:	685b      	ldr	r3, [r3, #4]
    9c36:	7c1b      	ldrb	r3, [r3, #16]
    9c38:	079b      	lsls	r3, r3, #30
    9c3a:	d52a      	bpl.n	9c92 <lwip_setsockopt+0xba>
				err = EAFNOSUPPORT;
    9c3c:	2061      	movs	r0, #97	; 0x61
    9c3e:	e02a      	b.n	9c96 <lwip_setsockopt+0xbe>
		switch (optname) {
    9c40:	1e6b      	subs	r3, r5, #1
    9c42:	2b01      	cmp	r3, #1
    9c44:	d9e8      	bls.n	9c18 <lwip_setsockopt+0x40>
    9c46:	e7dd      	b.n	9c04 <lwip_setsockopt+0x2c>
		if (optlen < sizeof(int)) {
    9c48:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    9c4a:	2b03      	cmp	r3, #3
    9c4c:	d9e7      	bls.n	9c1e <lwip_setsockopt+0x46>
		if (sock->conn->type != NETCONN_TCP)
    9c4e:	6803      	ldr	r3, [r0, #0]
    9c50:	781b      	ldrb	r3, [r3, #0]
    9c52:	2b10      	cmp	r3, #16
    9c54:	d121      	bne.n	9c9a <lwip_setsockopt+0xc2>
		switch (optname) {
    9c56:	1e6b      	subs	r3, r5, #1
    9c58:	2b01      	cmp	r3, #1
    9c5a:	d8d3      	bhi.n	9c04 <lwip_setsockopt+0x2c>
	data.optlen  = &optlen;
    9c5c:	ab0a      	add	r3, sp, #40	; 0x28
	data.level   = level;
    9c5e:	e9cd 4100 	strd	r4, r1, [sp]
	data.optval  = (void *)optval;
    9c62:	e9cd 5602 	strd	r5, r6, [sp, #8]
	data.optlen  = &optlen;
    9c66:	9304      	str	r3, [sp, #16]
	data.err     = err;
    9c68:	2500      	movs	r5, #0
	tcpip_callback(lwip_setsockopt_internal, &data);
    9c6a:	4b0e      	ldr	r3, [pc, #56]	; (9ca4 <lwip_setsockopt+0xcc>)
    9c6c:	480e      	ldr	r0, [pc, #56]	; (9ca8 <lwip_setsockopt+0xd0>)
	data.err     = err;
    9c6e:	f88d 5014 	strb.w	r5, [sp, #20]
	tcpip_callback(lwip_setsockopt_internal, &data);
    9c72:	2201      	movs	r2, #1
    9c74:	4669      	mov	r1, sp
    9c76:	4798      	blx	r3
	sys_arch_sem_wait(&sock->conn->op_completed, 0);
    9c78:	6820      	ldr	r0, [r4, #0]
    9c7a:	4b0c      	ldr	r3, [pc, #48]	; (9cac <lwip_setsockopt+0xd4>)
    9c7c:	4629      	mov	r1, r5
    9c7e:	300c      	adds	r0, #12
    9c80:	4798      	blx	r3
	err = data.err;
    9c82:	f99d 0014 	ldrsb.w	r0, [sp, #20]
	sock_set_errno(sock, err);
    9c86:	6120      	str	r0, [r4, #16]
	return err ? -1 : 0;
    9c88:	1b40      	subs	r0, r0, r5
    9c8a:	bf18      	it	ne
    9c8c:	2001      	movne	r0, #1
    9c8e:	4240      	negs	r0, r0
    9c90:	e7af      	b.n	9bf2 <lwip_setsockopt+0x1a>
	if (err != ERR_OK) {
    9c92:	2800      	cmp	r0, #0
    9c94:	d0e2      	beq.n	9c5c <lwip_setsockopt+0x84>
		sock_set_errno(sock, err);
    9c96:	6120      	str	r0, [r4, #16]
    9c98:	e7a9      	b.n	9bee <lwip_setsockopt+0x16>
			return 0;
    9c9a:	2000      	movs	r0, #0
    9c9c:	e7a9      	b.n	9bf2 <lwip_setsockopt+0x1a>
    9c9e:	bf00      	nop
    9ca0:	00009419 	.word	0x00009419
    9ca4:	0000a1f1 	.word	0x0000a1f1
    9ca8:	00009559 	.word	0x00009559
    9cac:	00007a3d 	.word	0x00007a3d

00009cb0 <prvTaskExitError>:
	its caller as there is nothing to return to.  If a task wants to exit it
	should instead call vTaskDelete( NULL ).

	Artificially force an assert() to be triggered if configASSERT() is
	defined, then stop here so application writers can catch the error. */
	configASSERT(uxCriticalNesting == ~0UL);
    9cb0:	4b0a      	ldr	r3, [pc, #40]	; (9cdc <prvTaskExitError+0x2c>)
    9cb2:	681b      	ldr	r3, [r3, #0]
    9cb4:	3301      	adds	r3, #1
    9cb6:	d008      	beq.n	9cca <prvTaskExitError+0x1a>
    9cb8:	f04f 0380 	mov.w	r3, #128	; 0x80
    9cbc:	f383 8811 	msr	BASEPRI, r3
    9cc0:	f3bf 8f6f 	isb	sy
    9cc4:	f3bf 8f4f 	dsb	sy
    9cc8:	e7fe      	b.n	9cc8 <prvTaskExitError+0x18>
    9cca:	f04f 0380 	mov.w	r3, #128	; 0x80
    9cce:	f383 8811 	msr	BASEPRI, r3
    9cd2:	f3bf 8f6f 	isb	sy
    9cd6:	f3bf 8f4f 	dsb	sy
	portDISABLE_INTERRUPTS();
	for (;;)
    9cda:	e7fe      	b.n	9cda <prvTaskExitError+0x2a>
    9cdc:	20000018 	.word	0x20000018

00009ce0 <prvPortStartFirstTask>:
}
/*-----------------------------------------------------------*/

static void prvPortStartFirstTask(void)
{
	__asm volatile(" ldr r0, =0xE000ED08 	\n" /* Use the NVIC offset register to locate the stack. */
    9ce0:	4806      	ldr	r0, [pc, #24]	; (9cfc <prvPortStartFirstTask+0x1c>)
    9ce2:	6800      	ldr	r0, [r0, #0]
    9ce4:	6800      	ldr	r0, [r0, #0]
    9ce6:	f380 8808 	msr	MSP, r0
    9cea:	b662      	cpsie	i
    9cec:	b661      	cpsie	f
    9cee:	f3bf 8f4f 	dsb	sy
    9cf2:	f3bf 8f6f 	isb	sy
    9cf6:	df00      	svc	0
    9cf8:	bf00      	nop
	               " cpsie f				\n"
	               " dsb					\n"
	               " isb					\n"
	               " svc 0					\n" /* System call to start first task. */
	               " nop					\n");
}
    9cfa:	0000      	.short	0x0000
    9cfc:	e000ed08 	.word	0xe000ed08

00009d00 <vPortEnableVFP>:
/*-----------------------------------------------------------*/

/* This is a naked function. */
static void vPortEnableVFP(void)
{
	__asm volatile("	ldr.w r0, =0xE000ED88		\n" /* The FPU enable bits are in the CPACR. */
    9d00:	f8df 000c 	ldr.w	r0, [pc, #12]	; 9d10 <vPortEnableVFP+0x10>
    9d04:	6801      	ldr	r1, [r0, #0]
    9d06:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
    9d0a:	6001      	str	r1, [r0, #0]
    9d0c:	4770      	bx	lr
	               "	ldr r1, [r0]				\n"
	               "								\n"
	               "	orr r1, r1, #( 0xf << 20 )	\n" /* Enable CP10 and CP11 coprocessors, then save back. */
	               "	str r1, [r0]				\n"
	               "	bx r14						");
}
    9d0e:	0000      	.short	0x0000
    9d10:	e000ed88 	.word	0xe000ed88

00009d14 <pxPortInitialiseStack>:
	*pxTopOfStack = portINITIAL_XPSR; /* xPSR */
    9d14:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
	*pxTopOfStack = (StackType_t)pxCode; /* PC */
    9d18:	e940 1302 	strd	r1, r3, [r0, #-8]
	*pxTopOfStack = (StackType_t)portTASK_RETURN_ADDRESS; /* LR */
    9d1c:	4b05      	ldr	r3, [pc, #20]	; (9d34 <pxPortInitialiseStack+0x20>)
    9d1e:	f840 3c0c 	str.w	r3, [r0, #-12]
	*pxTopOfStack = portINITIAL_EXEC_RETURN;
    9d22:	f06f 0302 	mvn.w	r3, #2
	*pxTopOfStack = (StackType_t)pvParameters; /* R0 */
    9d26:	f840 2c20 	str.w	r2, [r0, #-32]
	*pxTopOfStack = portINITIAL_EXEC_RETURN;
    9d2a:	f840 3c24 	str.w	r3, [r0, #-36]
}
    9d2e:	3844      	subs	r0, #68	; 0x44
    9d30:	4770      	bx	lr
    9d32:	bf00      	nop
    9d34:	00009cb1 	.word	0x00009cb1

00009d38 <SVCall_Handler>:
	__asm volatile("	ldr	r3, pxCurrentTCBConst2		\n" /* Restore the context. */
    9d38:	4b06      	ldr	r3, [pc, #24]	; (9d54 <pxCurrentTCBConst2>)
    9d3a:	6819      	ldr	r1, [r3, #0]
    9d3c:	6808      	ldr	r0, [r1, #0]
    9d3e:	e8b0 4ff0 	ldmia.w	r0!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    9d42:	f380 8809 	msr	PSP, r0
    9d46:	f3bf 8f6f 	isb	sy
    9d4a:	f04f 0000 	mov.w	r0, #0
    9d4e:	f380 8811 	msr	BASEPRI, r0
    9d52:	4770      	bx	lr

00009d54 <pxCurrentTCBConst2>:
    9d54:	200162a4 	.word	0x200162a4

00009d58 <vPortEnterCritical>:
    9d58:	f04f 0380 	mov.w	r3, #128	; 0x80
    9d5c:	f383 8811 	msr	BASEPRI, r3
    9d60:	f3bf 8f6f 	isb	sy
    9d64:	f3bf 8f4f 	dsb	sy
	uxCriticalNesting++;
    9d68:	4a0a      	ldr	r2, [pc, #40]	; (9d94 <vPortEnterCritical+0x3c>)
    9d6a:	6813      	ldr	r3, [r2, #0]
    9d6c:	3301      	adds	r3, #1
	if (uxCriticalNesting == 1) {
    9d6e:	2b01      	cmp	r3, #1
	uxCriticalNesting++;
    9d70:	6013      	str	r3, [r2, #0]
	if (uxCriticalNesting == 1) {
    9d72:	d10e      	bne.n	9d92 <vPortEnterCritical+0x3a>
		configASSERT((portNVIC_INT_CTRL_REG & portVECTACTIVE_MASK) == 0);
    9d74:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
    9d78:	f8d3 3d04 	ldr.w	r3, [r3, #3332]	; 0xd04
    9d7c:	b2db      	uxtb	r3, r3
    9d7e:	b143      	cbz	r3, 9d92 <vPortEnterCritical+0x3a>
    9d80:	f04f 0380 	mov.w	r3, #128	; 0x80
    9d84:	f383 8811 	msr	BASEPRI, r3
    9d88:	f3bf 8f6f 	isb	sy
    9d8c:	f3bf 8f4f 	dsb	sy
    9d90:	e7fe      	b.n	9d90 <vPortEnterCritical+0x38>
}
    9d92:	4770      	bx	lr
    9d94:	20000018 	.word	0x20000018

00009d98 <vPortExitCritical>:
	configASSERT(uxCriticalNesting);
    9d98:	4a08      	ldr	r2, [pc, #32]	; (9dbc <vPortExitCritical+0x24>)
    9d9a:	6813      	ldr	r3, [r2, #0]
    9d9c:	b943      	cbnz	r3, 9db0 <vPortExitCritical+0x18>
    9d9e:	f04f 0380 	mov.w	r3, #128	; 0x80
    9da2:	f383 8811 	msr	BASEPRI, r3
    9da6:	f3bf 8f6f 	isb	sy
    9daa:	f3bf 8f4f 	dsb	sy
    9dae:	e7fe      	b.n	9dae <vPortExitCritical+0x16>
	uxCriticalNesting--;
    9db0:	3b01      	subs	r3, #1
    9db2:	6013      	str	r3, [r2, #0]
	if (uxCriticalNesting == 0) {
    9db4:	b90b      	cbnz	r3, 9dba <vPortExitCritical+0x22>
	__asm volatile("	msr basepri, %0	" ::"r"(ulNewMaskValue));
    9db6:	f383 8811 	msr	BASEPRI, r3
}
    9dba:	4770      	bx	lr
    9dbc:	20000018 	.word	0x20000018

00009dc0 <PendSV_Handler>:
	__asm volatile(
    9dc0:	f3ef 8009 	mrs	r0, PSP
    9dc4:	f3bf 8f6f 	isb	sy
    9dc8:	4b14      	ldr	r3, [pc, #80]	; (9e1c <pxCurrentTCBConst>)
    9dca:	681a      	ldr	r2, [r3, #0]
    9dcc:	f01e 0f10 	tst.w	lr, #16
    9dd0:	bf08      	it	eq
    9dd2:	ed20 8a10 	vstmdbeq	r0!, {s16-s31}
    9dd6:	e920 4ff0 	stmdb	r0!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    9dda:	6010      	str	r0, [r2, #0]
    9ddc:	f84d 3d04 	str.w	r3, [sp, #-4]!
    9de0:	f04f 0080 	mov.w	r0, #128	; 0x80
    9de4:	f380 8811 	msr	BASEPRI, r0
    9de8:	f3bf 8f4f 	dsb	sy
    9dec:	f3bf 8f6f 	isb	sy
    9df0:	f7ff f940 	bl	9074 <vTaskSwitchContext>
    9df4:	f04f 0000 	mov.w	r0, #0
    9df8:	f380 8811 	msr	BASEPRI, r0
    9dfc:	bc08      	pop	{r3}
    9dfe:	6819      	ldr	r1, [r3, #0]
    9e00:	6808      	ldr	r0, [r1, #0]
    9e02:	e8b0 4ff0 	ldmia.w	r0!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    9e06:	f01e 0f10 	tst.w	lr, #16
    9e0a:	bf08      	it	eq
    9e0c:	ecb0 8a10 	vldmiaeq	r0!, {s16-s31}
    9e10:	f380 8809 	msr	PSP, r0
    9e14:	f3bf 8f6f 	isb	sy
    9e18:	4770      	bx	lr
    9e1a:	bf00      	nop

00009e1c <pxCurrentTCBConst>:
    9e1c:	200162a4 	.word	0x200162a4

00009e20 <SysTick_Handler>:
{
    9e20:	b508      	push	{r3, lr}
	__asm volatile("	mrs %0, basepri											\n"
    9e22:	f3ef 8311 	mrs	r3, BASEPRI
    9e26:	f04f 0280 	mov.w	r2, #128	; 0x80
    9e2a:	f382 8811 	msr	BASEPRI, r2
    9e2e:	f3bf 8f6f 	isb	sy
    9e32:	f3bf 8f4f 	dsb	sy
		if (xTaskIncrementTick() != pdFALSE) {
    9e36:	4b06      	ldr	r3, [pc, #24]	; (9e50 <SysTick_Handler+0x30>)
    9e38:	4798      	blx	r3
    9e3a:	b128      	cbz	r0, 9e48 <SysTick_Handler+0x28>
			portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT;
    9e3c:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
    9e40:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
    9e44:	f8c3 2d04 	str.w	r2, [r3, #3332]	; 0xd04
	__asm volatile("	msr basepri, %0	" ::"r"(ulNewMaskValue));
    9e48:	2300      	movs	r3, #0
    9e4a:	f383 8811 	msr	BASEPRI, r3
}
    9e4e:	bd08      	pop	{r3, pc}
    9e50:	00008da9 	.word	0x00008da9

00009e54 <vPortSetupTimerInterrupt>:
	portNVIC_SYSTICK_LOAD_REG = (configSYSTICK_CLOCK_HZ / configTICK_RATE_HZ) - 1UL;
    9e54:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
    9e58:	f642 62df 	movw	r2, #11999	; 0x2edf
    9e5c:	615a      	str	r2, [r3, #20]
	portNVIC_SYSTICK_CTRL_REG = (portNVIC_SYSTICK_CLK_BIT | portNVIC_SYSTICK_INT_BIT | portNVIC_SYSTICK_ENABLE_BIT);
    9e5e:	2207      	movs	r2, #7
    9e60:	611a      	str	r2, [r3, #16]
}
    9e62:	4770      	bx	lr

00009e64 <xPortStartScheduler>:
	configASSERT(portCPUID != portCORTEX_M7_r0p1_ID);
    9e64:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
{
    9e68:	b513      	push	{r0, r1, r4, lr}
	configASSERT(portCPUID != portCORTEX_M7_r0p1_ID);
    9e6a:	4a34      	ldr	r2, [pc, #208]	; (9f3c <xPortStartScheduler+0xd8>)
    9e6c:	f8d3 1d00 	ldr.w	r1, [r3, #3328]	; 0xd00
    9e70:	4291      	cmp	r1, r2
    9e72:	d108      	bne.n	9e86 <xPortStartScheduler+0x22>
	__asm volatile("	mov %0, %1												\n"
    9e74:	f04f 0380 	mov.w	r3, #128	; 0x80
    9e78:	f383 8811 	msr	BASEPRI, r3
    9e7c:	f3bf 8f6f 	isb	sy
    9e80:	f3bf 8f4f 	dsb	sy
    9e84:	e7fe      	b.n	9e84 <xPortStartScheduler+0x20>
	configASSERT(portCPUID != portCORTEX_M7_r0p0_ID);
    9e86:	f8d3 2d00 	ldr.w	r2, [r3, #3328]	; 0xd00
    9e8a:	4b2d      	ldr	r3, [pc, #180]	; (9f40 <xPortStartScheduler+0xdc>)
    9e8c:	429a      	cmp	r2, r3
    9e8e:	d108      	bne.n	9ea2 <xPortStartScheduler+0x3e>
    9e90:	f04f 0380 	mov.w	r3, #128	; 0x80
    9e94:	f383 8811 	msr	BASEPRI, r3
    9e98:	f3bf 8f6f 	isb	sy
    9e9c:	f3bf 8f4f 	dsb	sy
    9ea0:	e7fe      	b.n	9ea0 <xPortStartScheduler+0x3c>
		ulOriginalPriority = *pucFirstUserPriorityRegister;
    9ea2:	4b28      	ldr	r3, [pc, #160]	; (9f44 <xPortStartScheduler+0xe0>)
    9ea4:	781a      	ldrb	r2, [r3, #0]
    9ea6:	b2d2      	uxtb	r2, r2
    9ea8:	9201      	str	r2, [sp, #4]
		*pucFirstUserPriorityRegister = portMAX_8_BIT_VALUE;
    9eaa:	22ff      	movs	r2, #255	; 0xff
    9eac:	701a      	strb	r2, [r3, #0]
		ucMaxPriorityValue = *pucFirstUserPriorityRegister;
    9eae:	781b      	ldrb	r3, [r3, #0]
		ucMaxSysCallPriority = configMAX_SYSCALL_INTERRUPT_PRIORITY & ucMaxPriorityValue;
    9eb0:	4a25      	ldr	r2, [pc, #148]	; (9f48 <xPortStartScheduler+0xe4>)
		ucMaxPriorityValue = *pucFirstUserPriorityRegister;
    9eb2:	b2db      	uxtb	r3, r3
    9eb4:	f88d 3003 	strb.w	r3, [sp, #3]
		ucMaxSysCallPriority = configMAX_SYSCALL_INTERRUPT_PRIORITY & ucMaxPriorityValue;
    9eb8:	f89d 3003 	ldrb.w	r3, [sp, #3]
    9ebc:	f003 0380 	and.w	r3, r3, #128	; 0x80
    9ec0:	7013      	strb	r3, [r2, #0]
		ulMaxPRIGROUPValue = portMAX_PRIGROUP_BITS;
    9ec2:	2307      	movs	r3, #7
    9ec4:	6053      	str	r3, [r2, #4]
		while ((ucMaxPriorityValue & portTOP_BIT_OF_BYTE) == portTOP_BIT_OF_BYTE) {
    9ec6:	2100      	movs	r1, #0
    9ec8:	f89d 0003 	ldrb.w	r0, [sp, #3]
    9ecc:	0600      	lsls	r0, r0, #24
    9ece:	f103 34ff 	add.w	r4, r3, #4294967295	; 0xffffffff
    9ed2:	d429      	bmi.n	9f28 <xPortStartScheduler+0xc4>
    9ed4:	b101      	cbz	r1, 9ed8 <xPortStartScheduler+0x74>
    9ed6:	6053      	str	r3, [r2, #4]
		ulMaxPRIGROUPValue <<= portPRIGROUP_SHIFT;
    9ed8:	6853      	ldr	r3, [r2, #4]
    9eda:	021b      	lsls	r3, r3, #8
		ulMaxPRIGROUPValue &= portPRIORITY_GROUP_MASK;
    9edc:	f403 63e0 	and.w	r3, r3, #1792	; 0x700
    9ee0:	6053      	str	r3, [r2, #4]
		*pucFirstUserPriorityRegister = ulOriginalPriority;
    9ee2:	9b01      	ldr	r3, [sp, #4]
    9ee4:	4a17      	ldr	r2, [pc, #92]	; (9f44 <xPortStartScheduler+0xe0>)
	portNVIC_SYSPRI2_REG |= portNVIC_PENDSV_PRI;
    9ee6:	f04f 24e0 	mov.w	r4, #3758153728	; 0xe000e000
		*pucFirstUserPriorityRegister = ulOriginalPriority;
    9eea:	b2db      	uxtb	r3, r3
    9eec:	7013      	strb	r3, [r2, #0]
	portNVIC_SYSPRI2_REG |= portNVIC_PENDSV_PRI;
    9eee:	f8d4 3d20 	ldr.w	r3, [r4, #3360]	; 0xd20
    9ef2:	f443 0360 	orr.w	r3, r3, #14680064	; 0xe00000
    9ef6:	f8c4 3d20 	str.w	r3, [r4, #3360]	; 0xd20
	portNVIC_SYSPRI2_REG |= portNVIC_SYSTICK_PRI;
    9efa:	f8d4 3d20 	ldr.w	r3, [r4, #3360]	; 0xd20
    9efe:	f043 4360 	orr.w	r3, r3, #3758096384	; 0xe0000000
    9f02:	f8c4 3d20 	str.w	r3, [r4, #3360]	; 0xd20
	vPortSetupTimerInterrupt();
    9f06:	4b11      	ldr	r3, [pc, #68]	; (9f4c <xPortStartScheduler+0xe8>)
    9f08:	4798      	blx	r3
	uxCriticalNesting = 0;
    9f0a:	4b11      	ldr	r3, [pc, #68]	; (9f50 <xPortStartScheduler+0xec>)
    9f0c:	2200      	movs	r2, #0
    9f0e:	601a      	str	r2, [r3, #0]
	vPortEnableVFP();
    9f10:	4b10      	ldr	r3, [pc, #64]	; (9f54 <xPortStartScheduler+0xf0>)
    9f12:	4798      	blx	r3
	*(portFPCCR) |= portASPEN_AND_LSPEN_BITS;
    9f14:	f8d4 3f34 	ldr.w	r3, [r4, #3892]	; 0xf34
    9f18:	f043 4340 	orr.w	r3, r3, #3221225472	; 0xc0000000
    9f1c:	f8c4 3f34 	str.w	r3, [r4, #3892]	; 0xf34
	prvPortStartFirstTask();
    9f20:	4b0d      	ldr	r3, [pc, #52]	; (9f58 <xPortStartScheduler+0xf4>)
    9f22:	4798      	blx	r3
	prvTaskExitError();
    9f24:	4b0d      	ldr	r3, [pc, #52]	; (9f5c <xPortStartScheduler+0xf8>)
    9f26:	4798      	blx	r3
			ucMaxPriorityValue <<= (uint8_t)0x01;
    9f28:	f89d 3003 	ldrb.w	r3, [sp, #3]
    9f2c:	005b      	lsls	r3, r3, #1
    9f2e:	b2db      	uxtb	r3, r3
    9f30:	f88d 3003 	strb.w	r3, [sp, #3]
    9f34:	2101      	movs	r1, #1
    9f36:	4623      	mov	r3, r4
    9f38:	e7c6      	b.n	9ec8 <xPortStartScheduler+0x64>
    9f3a:	bf00      	nop
    9f3c:	410fc271 	.word	0x410fc271
    9f40:	410fc270 	.word	0x410fc270
    9f44:	e000e400 	.word	0xe000e400
    9f48:	200163dc 	.word	0x200163dc
    9f4c:	00009e55 	.word	0x00009e55
    9f50:	20000018 	.word	0x20000018
    9f54:	00009d01 	.word	0x00009d01
    9f58:	00009ce1 	.word	0x00009ce1
    9f5c:	00009cb1 	.word	0x00009cb1

00009f60 <vPortValidateInterruptPriority>:
{
	uint32_t ulCurrentInterrupt;
	uint8_t  ucCurrentPriority;

	/* Obtain the number of the currently executing interrupt. */
	__asm volatile("mrs %0, ipsr" : "=r"(ulCurrentInterrupt));
    9f60:	f3ef 8305 	mrs	r3, IPSR

	/* Is the interrupt number a user defined interrupt? */
	if (ulCurrentInterrupt >= portFIRST_USER_INTERRUPT_NUMBER) {
    9f64:	2b0f      	cmp	r3, #15
    9f66:	4a11      	ldr	r2, [pc, #68]	; (9fac <vPortValidateInterruptPriority+0x4c>)
    9f68:	d90d      	bls.n	9f86 <vPortValidateInterruptPriority+0x26>
		/* Look up the interrupt's priority. */
		ucCurrentPriority = pcInterruptPriorityRegisters[ulCurrentInterrupt];
    9f6a:	4911      	ldr	r1, [pc, #68]	; (9fb0 <vPortValidateInterruptPriority+0x50>)
    9f6c:	5c5b      	ldrb	r3, [r3, r1]
		interrupt entry is as fast and simple as possible.

		The following links provide detailed information:
		http://www.freertos.org/RTOS-Cortex-M3-M4.html
		http://www.freertos.org/FAQHelp.html */
		configASSERT(ucCurrentPriority >= ucMaxSysCallPriority);
    9f6e:	7811      	ldrb	r1, [r2, #0]
    9f70:	4299      	cmp	r1, r3
    9f72:	d908      	bls.n	9f86 <vPortValidateInterruptPriority+0x26>
    9f74:	f04f 0380 	mov.w	r3, #128	; 0x80
    9f78:	f383 8811 	msr	BASEPRI, r3
    9f7c:	f3bf 8f6f 	isb	sy
    9f80:	f3bf 8f4f 	dsb	sy
    9f84:	e7fe      	b.n	9f84 <vPortValidateInterruptPriority+0x24>
	configuration then the correct setting can be achieved on all Cortex-M
	devices by calling NVIC_SetPriorityGrouping( 0 ); before starting the
	scheduler.  Note however that some vendor specific peripheral libraries
	assume a non-zero priority group setting, in which cases using a value
	of zero will result in unpredicable behaviour. */
	configASSERT((portAIRCR_REG & portPRIORITY_GROUP_MASK) <= ulMaxPRIGROUPValue);
    9f86:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
    9f8a:	6852      	ldr	r2, [r2, #4]
    9f8c:	f8d3 3d0c 	ldr.w	r3, [r3, #3340]	; 0xd0c
    9f90:	f403 63e0 	and.w	r3, r3, #1792	; 0x700
    9f94:	4293      	cmp	r3, r2
    9f96:	d908      	bls.n	9faa <vPortValidateInterruptPriority+0x4a>
    9f98:	f04f 0380 	mov.w	r3, #128	; 0x80
    9f9c:	f383 8811 	msr	BASEPRI, r3
    9fa0:	f3bf 8f6f 	isb	sy
    9fa4:	f3bf 8f4f 	dsb	sy
    9fa8:	e7fe      	b.n	9fa8 <vPortValidateInterruptPriority+0x48>
}
    9faa:	4770      	bx	lr
    9fac:	200163dc 	.word	0x200163dc
    9fb0:	e000e3f0 	.word	0xe000e3f0

00009fb4 <netif_init>:
	netif_add(&loop_netif, &loop_ipaddr, &loop_netmask, &loop_gw, NULL, netif_loopif_init, tcpip_input);
#endif /* NO_SYS */
	netif_set_up(&loop_netif);

#endif /* LWIP_HAVE_LOOPIF */
}
    9fb4:	4770      	bx	lr
	...

00009fb8 <netif_set_ipaddr>:
 *
 * @note call netif_set_addr() if you also want to change netmask and
 * default gateway
 */
void netif_set_ipaddr(struct netif *netif, ip_addr_t *ipaddr)
{
    9fb8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    9fba:	4605      	mov	r5, r0
#if LWIP_TCP
	struct tcp_pcb *       pcb;
	struct tcp_pcb_listen *lpcb;

	/* address is actually being changed? */
	if (ipaddr && (ip_addr_cmp(ipaddr, &(netif->ip_addr))) == 0) {
    9fbc:	460c      	mov	r4, r1
    9fbe:	b159      	cbz	r1, 9fd8 <netif_set_ipaddr+0x20>
    9fc0:	680a      	ldr	r2, [r1, #0]
    9fc2:	6843      	ldr	r3, [r0, #4]
    9fc4:	429a      	cmp	r2, r3
    9fc6:	d006      	beq.n	9fd6 <netif_set_ipaddr+0x1e>
		/* extern struct tcp_pcb *tcp_active_pcbs; defined by tcp.h */
		LWIP_DEBUGF(NETIF_DEBUG | LWIP_DBG_STATE, ("netif_set_ipaddr: netif address being changed\n"));
		pcb = tcp_active_pcbs;
    9fc8:	4b0d      	ldr	r3, [pc, #52]	; (a000 <netif_set_ipaddr+0x48>)
#endif /* LWIP_AUTOIP */
			) {
				/* this connection must be aborted */
				struct tcp_pcb *next = pcb->next;
				LWIP_DEBUGF(NETIF_DEBUG | LWIP_DBG_STATE, ("netif_set_ipaddr: aborting TCP pcb %p\n", (void *)pcb));
				tcp_abort(pcb);
    9fca:	4e0e      	ldr	r6, [pc, #56]	; (a004 <netif_set_ipaddr+0x4c>)
		pcb = tcp_active_pcbs;
    9fcc:	6818      	ldr	r0, [r3, #0]
		while (pcb != NULL) {
    9fce:	b928      	cbnz	r0, 9fdc <netif_set_ipaddr+0x24>
				pcb = next;
			} else {
				pcb = pcb->next;
			}
		}
		for (lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
    9fd0:	4b0d      	ldr	r3, [pc, #52]	; (a008 <netif_set_ipaddr+0x50>)
    9fd2:	681b      	ldr	r3, [r3, #0]
    9fd4:	b953      	cbnz	r3, 9fec <netif_set_ipaddr+0x34>
	}
#endif
	snmp_delete_ipaddridx_tree(netif);
	snmp_delete_iprteidx_tree(0, netif);
	/* set new IP address to netif */
	ip_addr_set(&(netif->ip_addr), ipaddr);
    9fd6:	6824      	ldr	r4, [r4, #0]
    9fd8:	606c      	str	r4, [r5, #4]
	             netif->name[1],
	             ip4_addr1_16(&netif->ip_addr),
	             ip4_addr2_16(&netif->ip_addr),
	             ip4_addr3_16(&netif->ip_addr),
	             ip4_addr4_16(&netif->ip_addr)));
}
    9fda:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
			if (ip_addr_cmp(&(pcb->local_ip), &(netif->ip_addr))
    9fdc:	6802      	ldr	r2, [r0, #0]
    9fde:	686b      	ldr	r3, [r5, #4]
				struct tcp_pcb *next = pcb->next;
    9fe0:	68c7      	ldr	r7, [r0, #12]
			if (ip_addr_cmp(&(pcb->local_ip), &(netif->ip_addr))
    9fe2:	429a      	cmp	r2, r3
    9fe4:	d100      	bne.n	9fe8 <netif_set_ipaddr+0x30>
				tcp_abort(pcb);
    9fe6:	47b0      	blx	r6
{
    9fe8:	4638      	mov	r0, r7
    9fea:	e7f0      	b.n	9fce <netif_set_ipaddr+0x16>
			if ((!(ip_addr_isany(&(lpcb->local_ip)))) && (ip_addr_cmp(&(lpcb->local_ip), &(netif->ip_addr)))) {
    9fec:	681a      	ldr	r2, [r3, #0]
    9fee:	b122      	cbz	r2, 9ffa <netif_set_ipaddr+0x42>
    9ff0:	6869      	ldr	r1, [r5, #4]
    9ff2:	428a      	cmp	r2, r1
				ip_addr_set(&(lpcb->local_ip), ipaddr);
    9ff4:	bf04      	itt	eq
    9ff6:	6822      	ldreq	r2, [r4, #0]
    9ff8:	601a      	streq	r2, [r3, #0]
		for (lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
    9ffa:	68db      	ldr	r3, [r3, #12]
    9ffc:	e7ea      	b.n	9fd4 <netif_set_ipaddr+0x1c>
    9ffe:	bf00      	nop
    a000:	20014950 	.word	0x20014950
    a004:	00007279 	.word	0x00007279
    a008:	20014944 	.word	0x20014944

0000a00c <netif_set_addr>:
{
    a00c:	b570      	push	{r4, r5, r6, lr}
    a00e:	4615      	mov	r5, r2
    a010:	461c      	mov	r4, r3
	netif_set_ipaddr(netif, ipaddr);
    a012:	4b05      	ldr	r3, [pc, #20]	; (a028 <netif_set_addr+0x1c>)
{
    a014:	4606      	mov	r6, r0
	netif_set_ipaddr(netif, ipaddr);
    a016:	4798      	blx	r3
 */
void netif_set_netmask(struct netif *netif, ip_addr_t *netmask)
{
	snmp_delete_iprteidx_tree(0, netif);
	/* set new netmask to netif */
	ip_addr_set(&(netif->netmask), netmask);
    a018:	b105      	cbz	r5, a01c <netif_set_addr+0x10>
    a01a:	682d      	ldr	r5, [r5, #0]
    a01c:	60b5      	str	r5, [r6, #8]
	ip_addr_set(&(netif->gw), gw);
    a01e:	b104      	cbz	r4, a022 <netif_set_addr+0x16>
    a020:	6824      	ldr	r4, [r4, #0]
    a022:	60f4      	str	r4, [r6, #12]
}
    a024:	bd70      	pop	{r4, r5, r6, pc}
    a026:	bf00      	nop
    a028:	00009fb9 	.word	0x00009fb9

0000a02c <netif_add>:
{
    a02c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	netif->state = state;
    a02e:	9e06      	ldr	r6, [sp, #24]
    a030:	6206      	str	r6, [r0, #32]
	netif->num   = netif_num++;
    a032:	4e10      	ldr	r6, [pc, #64]	; (a074 <netif_add+0x48>)
    a034:	7937      	ldrb	r7, [r6, #4]
    a036:	f880 7034 	strb.w	r7, [r0, #52]	; 0x34
	ip_addr_set_zero(&netif->ip_addr);
    a03a:	2500      	movs	r5, #0
	netif->num   = netif_num++;
    a03c:	f107 0c01 	add.w	ip, r7, #1
	netif->input = input;
    a040:	9f08      	ldr	r7, [sp, #32]
    a042:	6107      	str	r7, [r0, #16]
	ip_addr_set_zero(&netif->netmask);
    a044:	e9c0 5501 	strd	r5, r5, [r0, #4]
{
    a048:	4604      	mov	r4, r0
	ip_addr_set_zero(&netif->gw);
    a04a:	60c5      	str	r5, [r0, #12]
	netif->flags = 0;
    a04c:	f880 5031 	strb.w	r5, [r0, #49]	; 0x31
	netif->dhcp = NULL;
    a050:	6245      	str	r5, [r0, #36]	; 0x24
	netif->status_callback = NULL;
    a052:	61c5      	str	r5, [r0, #28]
	netif_set_addr(netif, ipaddr, netmask, gw);
    a054:	4f08      	ldr	r7, [pc, #32]	; (a078 <netif_add+0x4c>)
	netif->num   = netif_num++;
    a056:	f886 c004 	strb.w	ip, [r6, #4]
	netif_set_addr(netif, ipaddr, netmask, gw);
    a05a:	47b8      	blx	r7
	if (init(netif) != ERR_OK) {
    a05c:	9b07      	ldr	r3, [sp, #28]
    a05e:	4620      	mov	r0, r4
    a060:	4798      	blx	r3
    a062:	b920      	cbnz	r0, a06e <netif_add+0x42>
	netif->next = netif_list;
    a064:	6833      	ldr	r3, [r6, #0]
    a066:	6023      	str	r3, [r4, #0]
	netif_list  = netif;
    a068:	6034      	str	r4, [r6, #0]
}
    a06a:	4620      	mov	r0, r4
    a06c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		return NULL;
    a06e:	462c      	mov	r4, r5
    a070:	e7fb      	b.n	a06a <netif_add+0x3e>
    a072:	bf00      	nop
    a074:	200163e4 	.word	0x200163e4
    a078:	0000a00d 	.word	0x0000a00d

0000a07c <netif_set_gw>:
	ip_addr_set(&(netif->gw), gw);
    a07c:	b101      	cbz	r1, a080 <netif_set_gw+0x4>
    a07e:	6809      	ldr	r1, [r1, #0]
    a080:	60c1      	str	r1, [r0, #12]
}
    a082:	4770      	bx	lr

0000a084 <netif_set_netmask>:
	ip_addr_set(&(netif->netmask), netmask);
    a084:	b101      	cbz	r1, a088 <netif_set_netmask+0x4>
    a086:	6809      	ldr	r1, [r1, #0]
    a088:	6081      	str	r1, [r0, #8]
	             netif->name[1],
	             ip4_addr1_16(&netif->netmask),
	             ip4_addr2_16(&netif->netmask),
	             ip4_addr3_16(&netif->netmask),
	             ip4_addr4_16(&netif->netmask)));
}
    a08a:	4770      	bx	lr

0000a08c <netif_set_default>:
		snmp_delete_iprteidx_tree(1, netif);
	} else {
		/* install default route */
		snmp_insert_iprteidx_tree(1, netif);
	}
	netif_default = netif;
    a08c:	4b01      	ldr	r3, [pc, #4]	; (a094 <netif_set_default+0x8>)
    a08e:	6098      	str	r0, [r3, #8]
	LWIP_DEBUGF(
	    NETIF_DEBUG,
	    ("netif: setting default interface %c%c\n", netif ? netif->name[0] : '\'', netif ? netif->name[1] : '\''));
}
    a090:	4770      	bx	lr
    a092:	bf00      	nop
    a094:	200163e4 	.word	0x200163e4

0000a098 <netif_set_up>:
 * up once configured.
 *
 * @see dhcp_start()
 */
void netif_set_up(struct netif *netif)
{
    a098:	b510      	push	{r4, lr}
	if (!(netif->flags & NETIF_FLAG_UP)) {
    a09a:	f890 3031 	ldrb.w	r3, [r0, #49]	; 0x31
    a09e:	07da      	lsls	r2, r3, #31
{
    a0a0:	4604      	mov	r4, r0
	if (!(netif->flags & NETIF_FLAG_UP)) {
    a0a2:	d412      	bmi.n	a0ca <netif_set_up+0x32>
		netif->flags |= NETIF_FLAG_UP;
    a0a4:	f043 0301 	orr.w	r3, r3, #1
    a0a8:	f880 3031 	strb.w	r3, [r0, #49]	; 0x31

#if LWIP_SNMP
		snmp_get_sysuptime(&netif->ts);
#endif /* LWIP_SNMP */

		NETIF_STATUS_CALLBACK(netif);
    a0ac:	69c3      	ldr	r3, [r0, #28]
    a0ae:	b103      	cbz	r3, a0b2 <netif_set_up+0x1a>
    a0b0:	4798      	blx	r3

		if (netif->flags & NETIF_FLAG_LINK_UP) {
#if LWIP_ARP
			/* For Ethernet network interfaces, we would like to send a "gratuitous ARP" */
			if (netif->flags & (NETIF_FLAG_ETHARP)) {
    a0b2:	f894 3031 	ldrb.w	r3, [r4, #49]	; 0x31
    a0b6:	f003 0330 	and.w	r3, r3, #48	; 0x30
    a0ba:	2b30      	cmp	r3, #48	; 0x30
    a0bc:	d105      	bne.n	a0ca <netif_set_up+0x32>
				etharp_gratuitous(netif);
    a0be:	1d21      	adds	r1, r4, #4
    a0c0:	4620      	mov	r0, r4
    a0c2:	4b02      	ldr	r3, [pc, #8]	; (a0cc <netif_set_up+0x34>)
				igmp_report_groups(netif);
			}
#endif /* LWIP_IGMP */
		}
	}
}
    a0c4:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
				etharp_gratuitous(netif);
    a0c8:	4718      	bx	r3
}
    a0ca:	bd10      	pop	{r4, pc}
    a0cc:	00004fa9 	.word	0x00004fa9

0000a0d0 <netif_set_down>:
 * up once configured.
 *
 * @see dhcp_start()
 */
void netif_set_down(struct netif *netif)
{
    a0d0:	b510      	push	{r4, lr}
	if (netif->flags & NETIF_FLAG_UP) {
    a0d2:	f890 3031 	ldrb.w	r3, [r0, #49]	; 0x31
    a0d6:	07da      	lsls	r2, r3, #31
{
    a0d8:	4604      	mov	r4, r0
	if (netif->flags & NETIF_FLAG_UP) {
    a0da:	d50d      	bpl.n	a0f8 <netif_set_down+0x28>
		netif->flags &= ~NETIF_FLAG_UP;
    a0dc:	f023 0201 	bic.w	r2, r3, #1
#if LWIP_SNMP
		snmp_get_sysuptime(&netif->ts);
#endif

#if LWIP_ARP
		if (netif->flags & NETIF_FLAG_ETHARP) {
    a0e0:	069b      	lsls	r3, r3, #26
		netif->flags &= ~NETIF_FLAG_UP;
    a0e2:	f880 2031 	strb.w	r2, [r0, #49]	; 0x31
		if (netif->flags & NETIF_FLAG_ETHARP) {
    a0e6:	d501      	bpl.n	a0ec <netif_set_down+0x1c>
			etharp_cleanup_netif(netif);
    a0e8:	4b04      	ldr	r3, [pc, #16]	; (a0fc <netif_set_down+0x2c>)
    a0ea:	4798      	blx	r3
		}
#endif /* LWIP_ARP */
		NETIF_STATUS_CALLBACK(netif);
    a0ec:	69e3      	ldr	r3, [r4, #28]
    a0ee:	b11b      	cbz	r3, a0f8 <netif_set_down+0x28>
    a0f0:	4620      	mov	r0, r4
	}
}
    a0f2:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		NETIF_STATUS_CALLBACK(netif);
    a0f6:	4718      	bx	r3
}
    a0f8:	bd10      	pop	{r4, pc}
    a0fa:	bf00      	nop
    a0fc:	00004f7d 	.word	0x00004f7d

0000a100 <tcpip_thread>:
 * thread context.
 *
 * @param arg unused argument
 */
static void tcpip_thread(void *arg)
{
    a100:	b507      	push	{r0, r1, r2, lr}
	struct tcpip_msg *msg;
	LWIP_UNUSED_ARG(arg);

	if (tcpip_init_done != NULL) {
    a102:	4a1e      	ldr	r2, [pc, #120]	; (a17c <tcpip_thread+0x7c>)
    a104:	6813      	ldr	r3, [r2, #0]
    a106:	b10b      	cbz	r3, a10c <tcpip_thread+0xc>
		tcpip_init_done(tcpip_init_done_arg);
    a108:	6850      	ldr	r0, [r2, #4]
    a10a:	4798      	blx	r3
	LOCK_TCPIP_CORE();
	while (1) { /* MAIN Loop */
		UNLOCK_TCPIP_CORE();
		LWIP_TCPIP_THREAD_ALIVE();
		/* wait for a message, timeouts are processed while waiting */
		sys_timeouts_mbox_fetch(&mbox, (void **)&msg);
    a10c:	4e1c      	ldr	r6, [pc, #112]	; (a180 <tcpip_thread+0x80>)
    a10e:	4d1d      	ldr	r5, [pc, #116]	; (a184 <tcpip_thread+0x84>)
#endif /* LWIP_TCPIP_TIMEOUT */

		case TCPIP_MSG_CALLBACK:
			LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip_thread: CALLBACK %p\n", (void *)msg));
			msg->msg.cb.function(msg->msg.cb.ctx);
			memp_free(MEMP_TCPIP_MSG_API, msg);
    a110:	4c1d      	ldr	r4, [pc, #116]	; (a188 <tcpip_thread+0x88>)
		sys_timeouts_mbox_fetch(&mbox, (void **)&msg);
    a112:	a901      	add	r1, sp, #4
    a114:	4630      	mov	r0, r6
    a116:	47a8      	blx	r5
		switch (msg->type) {
    a118:	9b01      	ldr	r3, [sp, #4]
    a11a:	781a      	ldrb	r2, [r3, #0]
    a11c:	2a05      	cmp	r2, #5
    a11e:	d8f8      	bhi.n	a112 <tcpip_thread+0x12>
    a120:	e8df f002 	tbb	[pc, r2]
    a124:	1e160803 	.word	0x1e160803
    a128:	2723      	.short	0x2723
			msg->msg.apimsg->function(&(msg->msg.apimsg->msg));
    a12a:	6898      	ldr	r0, [r3, #8]
    a12c:	f850 3b04 	ldr.w	r3, [r0], #4
    a130:	4798      	blx	r3
			break;
    a132:	e7ee      	b.n	a112 <tcpip_thread+0x12>
			msg->msg.apimsg->function(&(msg->msg.apimsg->msg));
    a134:	e9d3 0102 	ldrd	r0, r1, [r3, #8]
			if (msg->msg.inp.netif->flags & (NETIF_FLAG_ETHARP | NETIF_FLAG_ETHERNET)) {
    a138:	f891 3031 	ldrb.w	r3, [r1, #49]	; 0x31
    a13c:	f013 0f60 	tst.w	r3, #96	; 0x60
				ethernet_input(msg->msg.inp.p, msg->msg.inp.netif);
    a140:	bf14      	ite	ne
    a142:	4b12      	ldrne	r3, [pc, #72]	; (a18c <tcpip_thread+0x8c>)
				ip_input(msg->msg.inp.p, msg->msg.inp.netif);
    a144:	4b12      	ldreq	r3, [pc, #72]	; (a190 <tcpip_thread+0x90>)
    a146:	4798      	blx	r3
			memp_free(MEMP_TCPIP_MSG_INPKT, msg);
    a148:	9901      	ldr	r1, [sp, #4]
    a14a:	2009      	movs	r0, #9
			memp_free(MEMP_TCPIP_MSG_API, msg);
    a14c:	47a0      	blx	r4
			break;
    a14e:	e7e0      	b.n	a112 <tcpip_thread+0x12>
			sys_timeout(msg->msg.tmo.msecs, msg->msg.tmo.h, msg->msg.tmo.arg);
    a150:	e9d3 1203 	ldrd	r1, r2, [r3, #12]
    a154:	6898      	ldr	r0, [r3, #8]
    a156:	4b0f      	ldr	r3, [pc, #60]	; (a194 <tcpip_thread+0x94>)
    a158:	4798      	blx	r3
			memp_free(MEMP_TCPIP_MSG_API, msg);
    a15a:	9901      	ldr	r1, [sp, #4]
    a15c:	2008      	movs	r0, #8
    a15e:	e7f5      	b.n	a14c <tcpip_thread+0x4c>
			sys_untimeout(msg->msg.tmo.h, msg->msg.tmo.arg);
    a160:	e9d3 0103 	ldrd	r0, r1, [r3, #12]
    a164:	4b0c      	ldr	r3, [pc, #48]	; (a198 <tcpip_thread+0x98>)
    a166:	4798      	blx	r3
			memp_free(MEMP_TCPIP_MSG_API, msg);
    a168:	e7f7      	b.n	a15a <tcpip_thread+0x5a>
			msg->msg.cb.function(msg->msg.cb.ctx);
    a16a:	e9d3 2002 	ldrd	r2, r0, [r3, #8]
    a16e:	4790      	blx	r2
			memp_free(MEMP_TCPIP_MSG_API, msg);
    a170:	e7f3      	b.n	a15a <tcpip_thread+0x5a>
			break;

		case TCPIP_MSG_CALLBACK_STATIC:
			LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip_thread: CALLBACK_STATIC %p\n", (void *)msg));
			msg->msg.cb.function(msg->msg.cb.ctx);
    a172:	e9d3 2002 	ldrd	r2, r0, [r3, #8]
    a176:	4790      	blx	r2
			break;
    a178:	e7cb      	b.n	a112 <tcpip_thread+0x12>
    a17a:	bf00      	nop
    a17c:	200163f0 	.word	0x200163f0
    a180:	200163f8 	.word	0x200163f8
    a184:	0000123d 	.word	0x0000123d
    a188:	00004c21 	.word	0x00004c21
    a18c:	000052bd 	.word	0x000052bd
    a190:	00006399 	.word	0x00006399
    a194:	00001045 	.word	0x00001045
    a198:	000011f1 	.word	0x000011f1

0000a19c <tcpip_input>:
 *          to an IP header (if inp doesn't have NETIF_FLAG_ETHARP or
 *          NETIF_FLAG_ETHERNET flags)
 * @param inp the network interface on which the packet was received
 */
err_t tcpip_input(struct pbuf *p, struct netif *inp)
{
    a19c:	b570      	push	{r4, r5, r6, lr}
	UNLOCK_TCPIP_CORE();
	return ret;
#else  /* LWIP_TCPIP_CORE_LOCKING_INPUT */
	struct tcpip_msg *msg;

	if (!sys_mbox_valid(&mbox)) {
    a19e:	4b0f      	ldr	r3, [pc, #60]	; (a1dc <tcpip_input+0x40>)
{
    a1a0:	4606      	mov	r6, r0
	if (!sys_mbox_valid(&mbox)) {
    a1a2:	480f      	ldr	r0, [pc, #60]	; (a1e0 <tcpip_input+0x44>)
{
    a1a4:	460d      	mov	r5, r1
	if (!sys_mbox_valid(&mbox)) {
    a1a6:	4798      	blx	r3
    a1a8:	b1a0      	cbz	r0, a1d4 <tcpip_input+0x38>
		return ERR_VAL;
	}
	msg = (struct tcpip_msg *)memp_malloc(MEMP_TCPIP_MSG_INPKT);
    a1aa:	4b0e      	ldr	r3, [pc, #56]	; (a1e4 <tcpip_input+0x48>)
    a1ac:	2009      	movs	r0, #9
    a1ae:	4798      	blx	r3
	if (msg == NULL) {
    a1b0:	4604      	mov	r4, r0
    a1b2:	b160      	cbz	r0, a1ce <tcpip_input+0x32>
		return ERR_MEM;
	}

	msg->type          = TCPIP_MSG_INPKT;
    a1b4:	2301      	movs	r3, #1
    a1b6:	7003      	strb	r3, [r0, #0]
	msg->msg.inp.p     = p;
	msg->msg.inp.netif = inp;
    a1b8:	e9c0 6502 	strd	r6, r5, [r0, #8]
	if (sys_mbox_trypost(&mbox, msg) != ERR_OK) {
    a1bc:	4601      	mov	r1, r0
    a1be:	4b0a      	ldr	r3, [pc, #40]	; (a1e8 <tcpip_input+0x4c>)
    a1c0:	4807      	ldr	r0, [pc, #28]	; (a1e0 <tcpip_input+0x44>)
    a1c2:	4798      	blx	r3
    a1c4:	b140      	cbz	r0, a1d8 <tcpip_input+0x3c>
		memp_free(MEMP_TCPIP_MSG_INPKT, msg);
    a1c6:	4b09      	ldr	r3, [pc, #36]	; (a1ec <tcpip_input+0x50>)
    a1c8:	4621      	mov	r1, r4
    a1ca:	2009      	movs	r0, #9
    a1cc:	4798      	blx	r3
		return ERR_MEM;
    a1ce:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    a1d2:	e001      	b.n	a1d8 <tcpip_input+0x3c>
		return ERR_VAL;
    a1d4:	f06f 0005 	mvn.w	r0, #5
		return ERR_MEM;
	}
	return ERR_OK;
#endif /* LWIP_TCPIP_CORE_LOCKING_INPUT */
}
    a1d8:	bd70      	pop	{r4, r5, r6, pc}
    a1da:	bf00      	nop
    a1dc:	00007be1 	.word	0x00007be1
    a1e0:	200163f8 	.word	0x200163f8
    a1e4:	00004c05 	.word	0x00004c05
    a1e8:	00007aed 	.word	0x00007aed
    a1ec:	00004c21 	.word	0x00004c21

0000a1f0 <tcpip_callback_with_block>:
 * @param ctx parameter passed to f
 * @param block 1 to block until the request is posted, 0 to non-blocking mode
 * @return ERR_OK if the function was called, another err_t if not
 */
err_t tcpip_callback_with_block(tcpip_callback_fn function, void *ctx, u8_t block)
{
    a1f0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    a1f2:	4607      	mov	r7, r0
	struct tcpip_msg *msg;

	if (sys_mbox_valid(&mbox)) {
    a1f4:	4b11      	ldr	r3, [pc, #68]	; (a23c <tcpip_callback_with_block+0x4c>)
    a1f6:	4812      	ldr	r0, [pc, #72]	; (a240 <tcpip_callback_with_block+0x50>)
{
    a1f8:	460e      	mov	r6, r1
    a1fa:	4615      	mov	r5, r2
	if (sys_mbox_valid(&mbox)) {
    a1fc:	4798      	blx	r3
    a1fe:	b1d0      	cbz	r0, a236 <tcpip_callback_with_block+0x46>
		msg = (struct tcpip_msg *)memp_malloc(MEMP_TCPIP_MSG_API);
    a200:	4b10      	ldr	r3, [pc, #64]	; (a244 <tcpip_callback_with_block+0x54>)
    a202:	2008      	movs	r0, #8
    a204:	4798      	blx	r3
		if (msg == NULL) {
    a206:	4604      	mov	r4, r0
    a208:	b190      	cbz	r0, a230 <tcpip_callback_with_block+0x40>
			return ERR_MEM;
		}

		msg->type            = TCPIP_MSG_CALLBACK;
    a20a:	2304      	movs	r3, #4
		msg->msg.cb.function = function;
		msg->msg.cb.ctx      = ctx;
    a20c:	e9c0 7602 	strd	r7, r6, [r0, #8]
		msg->type            = TCPIP_MSG_CALLBACK;
    a210:	7003      	strb	r3, [r0, #0]
		if (block) {
			sys_mbox_post(&mbox, msg);
    a212:	4601      	mov	r1, r0
    a214:	480a      	ldr	r0, [pc, #40]	; (a240 <tcpip_callback_with_block+0x50>)
		if (block) {
    a216:	b11d      	cbz	r5, a220 <tcpip_callback_with_block+0x30>
			sys_mbox_post(&mbox, msg);
    a218:	4b0b      	ldr	r3, [pc, #44]	; (a248 <tcpip_callback_with_block+0x58>)
    a21a:	4798      	blx	r3
			if (sys_mbox_trypost(&mbox, msg) != ERR_OK) {
				memp_free(MEMP_TCPIP_MSG_API, msg);
				return ERR_MEM;
			}
		}
		return ERR_OK;
    a21c:	2000      	movs	r0, #0
	}
	return ERR_VAL;
}
    a21e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
			if (sys_mbox_trypost(&mbox, msg) != ERR_OK) {
    a220:	4b0a      	ldr	r3, [pc, #40]	; (a24c <tcpip_callback_with_block+0x5c>)
    a222:	4798      	blx	r3
    a224:	2800      	cmp	r0, #0
    a226:	d0fa      	beq.n	a21e <tcpip_callback_with_block+0x2e>
				memp_free(MEMP_TCPIP_MSG_API, msg);
    a228:	4b09      	ldr	r3, [pc, #36]	; (a250 <tcpip_callback_with_block+0x60>)
    a22a:	4621      	mov	r1, r4
    a22c:	2008      	movs	r0, #8
    a22e:	4798      	blx	r3
			return ERR_MEM;
    a230:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    a234:	e7f3      	b.n	a21e <tcpip_callback_with_block+0x2e>
	return ERR_VAL;
    a236:	f06f 0005 	mvn.w	r0, #5
    a23a:	e7f0      	b.n	a21e <tcpip_callback_with_block+0x2e>
    a23c:	00007be1 	.word	0x00007be1
    a240:	200163f8 	.word	0x200163f8
    a244:	00004c05 	.word	0x00004c05
    a248:	00007ac9 	.word	0x00007ac9
    a24c:	00007aed 	.word	0x00007aed
    a250:	00004c21 	.word	0x00004c21

0000a254 <tcpip_apimsg>:
 *
 * @param apimsg a struct containing the function to call and its parameters
 * @return ERR_OK if the function was called, another err_t if not
 */
err_t tcpip_apimsg(struct api_msg *apimsg)
{
    a254:	b530      	push	{r4, r5, lr}
#ifdef LWIP_DEBUG
	/* catch functions that don't set err */
	apimsg->msg.err = ERR_VAL;
#endif

	if (sys_mbox_valid(&mbox)) {
    a256:	4b0d      	ldr	r3, [pc, #52]	; (a28c <tcpip_apimsg+0x38>)
{
    a258:	b087      	sub	sp, #28
    a25a:	4604      	mov	r4, r0
	if (sys_mbox_valid(&mbox)) {
    a25c:	480c      	ldr	r0, [pc, #48]	; (a290 <tcpip_apimsg+0x3c>)
    a25e:	4798      	blx	r3
    a260:	b180      	cbz	r0, a284 <tcpip_apimsg+0x30>
		msg.type       = TCPIP_MSG_API;
		msg.msg.apimsg = apimsg;
		sys_mbox_post(&mbox, &msg);
    a262:	480b      	ldr	r0, [pc, #44]	; (a290 <tcpip_apimsg+0x3c>)
    a264:	4b0b      	ldr	r3, [pc, #44]	; (a294 <tcpip_apimsg+0x40>)
		msg.msg.apimsg = apimsg;
    a266:	9403      	str	r4, [sp, #12]
		msg.type       = TCPIP_MSG_API;
    a268:	2500      	movs	r5, #0
		sys_mbox_post(&mbox, &msg);
    a26a:	a901      	add	r1, sp, #4
		msg.type       = TCPIP_MSG_API;
    a26c:	f88d 5004 	strb.w	r5, [sp, #4]
		sys_mbox_post(&mbox, &msg);
    a270:	4798      	blx	r3
		sys_arch_sem_wait(&apimsg->msg.conn->op_completed, 0);
    a272:	6860      	ldr	r0, [r4, #4]
    a274:	4b08      	ldr	r3, [pc, #32]	; (a298 <tcpip_apimsg+0x44>)
    a276:	4629      	mov	r1, r5
    a278:	300c      	adds	r0, #12
    a27a:	4798      	blx	r3
		return apimsg->msg.err;
    a27c:	f994 0008 	ldrsb.w	r0, [r4, #8]
	}
	return ERR_VAL;
}
    a280:	b007      	add	sp, #28
    a282:	bd30      	pop	{r4, r5, pc}
	return ERR_VAL;
    a284:	f06f 0005 	mvn.w	r0, #5
    a288:	e7fa      	b.n	a280 <tcpip_apimsg+0x2c>
    a28a:	bf00      	nop
    a28c:	00007be1 	.word	0x00007be1
    a290:	200163f8 	.word	0x200163f8
    a294:	00007ac9 	.word	0x00007ac9
    a298:	00007a3d 	.word	0x00007a3d

0000a29c <tcpip_init>:
 *
 * @param initfunc a function to call when tcpip_thread is running and finished initializing
 * @param arg argument to pass to initfunc
 */
void tcpip_init(tcpip_init_done_fn initfunc, void *arg)
{
    a29c:	b537      	push	{r0, r1, r2, r4, r5, lr}
	lwip_init();
    a29e:	4b0b      	ldr	r3, [pc, #44]	; (a2cc <tcpip_init+0x30>)
{
    a2a0:	4605      	mov	r5, r0
    a2a2:	460c      	mov	r4, r1
	lwip_init();
    a2a4:	4798      	blx	r3

	tcpip_init_done     = initfunc;
    a2a6:	480a      	ldr	r0, [pc, #40]	; (a2d0 <tcpip_init+0x34>)
	tcpip_init_done_arg = arg;
	if (sys_mbox_new(&mbox, TCPIP_MBOX_SIZE) != ERR_OK) {
    a2a8:	4b0a      	ldr	r3, [pc, #40]	; (a2d4 <tcpip_init+0x38>)
	tcpip_init_done_arg = arg;
    a2aa:	e9c0 5400 	strd	r5, r4, [r0]
	if (sys_mbox_new(&mbox, TCPIP_MBOX_SIZE) != ERR_OK) {
    a2ae:	2110      	movs	r1, #16
    a2b0:	3008      	adds	r0, #8
    a2b2:	4798      	blx	r3
	if (sys_mutex_new(&lock_tcpip_core) != ERR_OK) {
		LWIP_ASSERT("failed to create lock_tcpip_core", 0);
	}
#endif /* LWIP_TCPIP_CORE_LOCKING */

	sys_thread_new(TCPIP_THREAD_NAME, tcpip_thread, NULL, TCPIP_THREAD_STACKSIZE, TCPIP_THREAD_PRIO);
    a2b4:	2301      	movs	r3, #1
    a2b6:	9300      	str	r3, [sp, #0]
    a2b8:	4907      	ldr	r1, [pc, #28]	; (a2d8 <tcpip_init+0x3c>)
    a2ba:	4c08      	ldr	r4, [pc, #32]	; (a2dc <tcpip_init+0x40>)
    a2bc:	4808      	ldr	r0, [pc, #32]	; (a2e0 <tcpip_init+0x44>)
    a2be:	f44f 6383 	mov.w	r3, #1048	; 0x418
    a2c2:	2200      	movs	r2, #0
    a2c4:	47a0      	blx	r4
}
    a2c6:	b003      	add	sp, #12
    a2c8:	bd30      	pop	{r4, r5, pc}
    a2ca:	bf00      	nop
    a2cc:	00007f25 	.word	0x00007f25
    a2d0:	200163f0 	.word	0x200163f0
    a2d4:	00007aa1 	.word	0x00007aa1
    a2d8:	0000a101 	.word	0x0000a101
    a2dc:	00007bed 	.word	0x00007bed
    a2e0:	0000cce8 	.word	0x0000cce8

0000a2e4 <_DoInit>:
  unsigned i;
  //
  // Initialize control block
  //
  p                     = (volatile SEGGER_RTT_CB*)((uintptr_t)&_SEGGER_RTT + SEGGER_RTT_UNCACHED_OFF);  // Access control block uncached so that nothing in the cache ever becomes dirty and all changes are visible in HW directly
  memset((SEGGER_RTT_CB*)p, 0, sizeof(_SEGGER_RTT));         // Make sure that the RTT CB is always zero initialized.
    a2e4:	4b15      	ldr	r3, [pc, #84]	; (a33c <_DoInit+0x58>)
static void _DoInit(void) {
    a2e6:	b510      	push	{r4, lr}
  memset((SEGGER_RTT_CB*)p, 0, sizeof(_SEGGER_RTT));         // Make sure that the RTT CB is always zero initialized.
    a2e8:	22a8      	movs	r2, #168	; 0xa8
    a2ea:	4c15      	ldr	r4, [pc, #84]	; (a340 <_DoInit+0x5c>)
    a2ec:	2100      	movs	r1, #0
    a2ee:	4618      	mov	r0, r3
    a2f0:	47a0      	blx	r4
  p->MaxNumUpBuffers    = SEGGER_RTT_MAX_NUM_UP_BUFFERS;
    a2f2:	2203      	movs	r2, #3
    a2f4:	6102      	str	r2, [r0, #16]
  p->MaxNumDownBuffers  = SEGGER_RTT_MAX_NUM_DOWN_BUFFERS;
  //
  // Initialize up buffer 0
  //
  p->aUp[0].sName         = "Terminal";
    a2f6:	4913      	ldr	r1, [pc, #76]	; (a344 <_DoInit+0x60>)
  p->MaxNumDownBuffers  = SEGGER_RTT_MAX_NUM_DOWN_BUFFERS;
    a2f8:	6142      	str	r2, [r0, #20]
  p->aUp[0].pBuffer       = _acUpBuffer;
    a2fa:	f100 02a8 	add.w	r2, r0, #168	; 0xa8
  p->aUp[0].sName         = "Terminal";
    a2fe:	6181      	str	r1, [r0, #24]
  p->aUp[0].pBuffer       = _acUpBuffer;
    a300:	61c2      	str	r2, [r0, #28]
  p->aUp[0].SizeOfBuffer  = BUFFER_SIZE_UP;
    a302:	f44f 6280 	mov.w	r2, #1024	; 0x400
    a306:	6202      	str	r2, [r0, #32]
  p->aUp[0].RdOff         = 0u;
    a308:	2200      	movs	r2, #0
    a30a:	6282      	str	r2, [r0, #40]	; 0x28
  p->aUp[0].WrOff         = 0u;
    a30c:	6242      	str	r2, [r0, #36]	; 0x24
  p->aUp[0].Flags         = SEGGER_RTT_MODE_DEFAULT;
    a30e:	62c2      	str	r2, [r0, #44]	; 0x2c
  //
  // Initialize down buffer 0
  //
  p->aDown[0].sName         = "Terminal";
    a310:	6601      	str	r1, [r0, #96]	; 0x60
  p->aDown[0].pBuffer       = _acDownBuffer;
    a312:	f500 6195 	add.w	r1, r0, #1192	; 0x4a8
    a316:	6641      	str	r1, [r0, #100]	; 0x64
  p->aDown[0].SizeOfBuffer  = BUFFER_SIZE_DOWN;
    a318:	2110      	movs	r1, #16
    a31a:	6681      	str	r1, [r0, #104]	; 0x68
  memset((SEGGER_RTT_CB*)p, 0, sizeof(_SEGGER_RTT));         // Make sure that the RTT CB is always zero initialized.
    a31c:	4603      	mov	r3, r0
  p->aDown[0].RdOff         = 0u;
    a31e:	6702      	str	r2, [r0, #112]	; 0x70
  p->aDown[0].WrOff         = 0u;
    a320:	66c2      	str	r2, [r0, #108]	; 0x6c
  p->aDown[0].Flags         = SEGGER_RTT_MODE_DEFAULT;
    a322:	6742      	str	r2, [r0, #116]	; 0x74
  //
  // Finish initialization of the control block.
  // Copy Id string backwards to make sure that "SEGGER RTT" is not found in initializer memory (usually flash),
  // as this would cause J-Link to "find" the control block at a wrong address.
  //
  RTT__DMB();                       // Force order of memory accesses for cores that may perform out-of-order memory accesses
    a324:	f3bf 8f5f 	dmb	sy
  for (i = 0; i < sizeof(_aInitStr) - 1; ++i) {
    a328:	4907      	ldr	r1, [pc, #28]	; (a348 <_DoInit+0x64>)
    p->acID[i] = _aInitStr[sizeof(_aInitStr) - 2 - i];  // Skip terminating \0 at the end of the array
    a32a:	f811 0901 	ldrb.w	r0, [r1], #-1
    a32e:	5498      	strb	r0, [r3, r2]
  for (i = 0; i < sizeof(_aInitStr) - 1; ++i) {
    a330:	3201      	adds	r2, #1
    a332:	2a10      	cmp	r2, #16
    a334:	d1f9      	bne.n	a32a <_DoInit+0x46>
  }
  RTT__DMB();                       // Force order of memory accesses for cores that may perform out-of-order memory accesses
    a336:	f3bf 8f5f 	dmb	sy
}
    a33a:	bd10      	pop	{r4, pc}
    a33c:	200163fc 	.word	0x200163fc
    a340:	0000c099 	.word	0x0000c099
    a344:	0000ccf5 	.word	0x0000ccf5
    a348:	0000cd0d 	.word	0x0000cd0d

0000a34c <SEGGER_RTT_PutChar>:
*
*  Notes
*    (1) Data is stored according to buffer flags.
*/

unsigned SEGGER_RTT_PutChar(unsigned BufferIndex, char c) {
    a34c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  unsigned              Status;
  volatile char*        pDst;
  //
  // Prepare
  //
  INIT();
    a34e:	4c19      	ldr	r4, [pc, #100]	; (a3b4 <SEGGER_RTT_PutChar+0x68>)
    a350:	7823      	ldrb	r3, [r4, #0]
    a352:	2b53      	cmp	r3, #83	; 0x53
unsigned SEGGER_RTT_PutChar(unsigned BufferIndex, char c) {
    a354:	4605      	mov	r5, r0
    a356:	460e      	mov	r6, r1
  INIT();
    a358:	d001      	beq.n	a35e <SEGGER_RTT_PutChar+0x12>
    a35a:	4b17      	ldr	r3, [pc, #92]	; (a3b8 <SEGGER_RTT_PutChar+0x6c>)
    a35c:	4798      	blx	r3
  SEGGER_RTT_LOCK();
    a35e:	f3ef 8711 	mrs	r7, BASEPRI
    a362:	f04f 0120 	mov.w	r1, #32
    a366:	f381 8811 	msr	BASEPRI, r1
  //
  pRing = (SEGGER_RTT_BUFFER_UP*)((uintptr_t)&_SEGGER_RTT.aUp[BufferIndex] + SEGGER_RTT_UNCACHED_OFF);  // Access uncached to make sure we see changes made by the J-Link side and all of our changes go into HW directly
  //
  // Get write position and handle wrap-around if necessary
  //
  WrOff = pRing->WrOff + 1;
    a36a:	2218      	movs	r2, #24
    a36c:	fb02 4205 	mla	r2, r2, r5, r4
    a370:	6a50      	ldr	r0, [r2, #36]	; 0x24
  if (WrOff == pRing->SizeOfBuffer) {
    a372:	6a11      	ldr	r1, [r2, #32]
  WrOff = pRing->WrOff + 1;
    a374:	1c43      	adds	r3, r0, #1
    WrOff = 0;
    a376:	4299      	cmp	r1, r3
    a378:	bf08      	it	eq
    a37a:	2300      	moveq	r3, #0
  }
  //
  // Wait for free space if mode is set to blocking
  //
  if (pRing->Flags == SEGGER_RTT_MODE_BLOCK_IF_FIFO_FULL) {
    a37c:	6ad1      	ldr	r1, [r2, #44]	; 0x2c
    a37e:	2902      	cmp	r1, #2
    a380:	d102      	bne.n	a388 <SEGGER_RTT_PutChar+0x3c>
    while (WrOff == pRing->RdOff) {
    a382:	6a91      	ldr	r1, [r2, #40]	; 0x28
    a384:	4299      	cmp	r1, r3
    a386:	e7fb      	b.n	a380 <SEGGER_RTT_PutChar+0x34>
    }
  }
  //
  // Output byte if free space is available
  //
  if (WrOff != pRing->RdOff) {
    a388:	2218      	movs	r2, #24
    a38a:	fb02 4105 	mla	r1, r2, r5, r4
    a38e:	f8d1 c028 	ldr.w	ip, [r1, #40]	; 0x28
    a392:	459c      	cmp	ip, r3
    a394:	d00b      	beq.n	a3ae <SEGGER_RTT_PutChar+0x62>
    pDst  = (pRing->pBuffer + pRing->WrOff) + SEGGER_RTT_UNCACHED_OFF;
    a396:	fb05 2202 	mla	r2, r5, r2, r2
    a39a:	4414      	add	r4, r2
    a39c:	6862      	ldr	r2, [r4, #4]
    *pDst = c;
    a39e:	5416      	strb	r6, [r2, r0]
    RTT__DMB();                     // Force data write to be complete before writing the <WrOff>, in case CPU is allowed to change the order of memory accesses
    a3a0:	f3bf 8f5f 	dmb	sy
    pRing->WrOff = WrOff;
    Status = 1;
    a3a4:	2001      	movs	r0, #1
    pRing->WrOff = WrOff;
    a3a6:	624b      	str	r3, [r1, #36]	; 0x24
    Status = 0;
  }
  //
  // Finish up.
  //
  SEGGER_RTT_UNLOCK();
    a3a8:	f387 8811 	msr	BASEPRI, r7
  return Status;
}
    a3ac:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    Status = 0;
    a3ae:	2000      	movs	r0, #0
    a3b0:	e7fa      	b.n	a3a8 <SEGGER_RTT_PutChar+0x5c>
    a3b2:	bf00      	nop
    a3b4:	200163fc 	.word	0x200163fc
    a3b8:	0000a2e5 	.word	0x0000a2e5

0000a3bc <SEGGER_RTT_Init>:
*    Initializes the RTT Control Block.
*    Should be used in RAM targets, at start of the application.
*
*/
void SEGGER_RTT_Init (void) {
  _DoInit();
    a3bc:	4b00      	ldr	r3, [pc, #0]	; (a3c0 <SEGGER_RTT_Init+0x4>)
    a3be:	4718      	bx	r3
    a3c0:	0000a2e5 	.word	0x0000a2e5

0000a3c4 <_out_null>:

// internal null output
static inline void _out_null(char character, void* buffer, size_t idx, size_t maxlen)
{
  (void)character; (void)buffer; (void)idx; (void)maxlen;
}
    a3c4:	4770      	bx	lr

0000a3c6 <_out_rev>:
}


// output the specified string in reverse, taking care of any zero-padding
static size_t _out_rev(out_fct_type out, char* buffer, size_t idx, size_t maxlen, const char* buf, size_t len, unsigned int width, unsigned int flags)
{
    a3c6:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    a3ca:	4699      	mov	r9, r3
  const size_t start_idx = idx;

  // pad spaces up to given width
  if (!(flags & FLAGS_LEFT) && !(flags & FLAGS_ZEROPAD)) {
    a3cc:	9b0d      	ldr	r3, [sp, #52]	; 0x34
{
    a3ce:	4615      	mov	r5, r2
  if (!(flags & FLAGS_LEFT) && !(flags & FLAGS_ZEROPAD)) {
    a3d0:	079a      	lsls	r2, r3, #30
{
    a3d2:	e9dd 470b 	ldrd	r4, r7, [sp, #44]	; 0x2c
    a3d6:	4606      	mov	r6, r0
    a3d8:	468b      	mov	fp, r1
  if (!(flags & FLAGS_LEFT) && !(flags & FLAGS_ZEROPAD)) {
    a3da:	d022      	beq.n	a422 <_out_rev+0x5c>
    a3dc:	462a      	mov	r2, r5
    a3de:	990a      	ldr	r1, [sp, #40]	; 0x28
    a3e0:	eb01 0804 	add.w	r8, r1, r4
    a3e4:	4414      	add	r4, r2
      out(' ', buffer, idx++, maxlen);
    }
  }

  // reverse string
  while (len) {
    a3e6:	42a2      	cmp	r2, r4
    a3e8:	d11f      	bne.n	a42a <_out_rev+0x64>
    out(buf[--len], buffer, idx++, maxlen);
  }

  // append pad spaces up to given width
  if (flags & FLAGS_LEFT) {
    a3ea:	9b0d      	ldr	r3, [sp, #52]	; 0x34
    a3ec:	079b      	lsls	r3, r3, #30
    a3ee:	d505      	bpl.n	a3fc <_out_rev+0x36>
    a3f0:	eba2 0805 	sub.w	r8, r2, r5
    while (idx - start_idx < width) {
    a3f4:	4547      	cmp	r7, r8
    a3f6:	eb05 0408 	add.w	r4, r5, r8
    a3fa:	d81f      	bhi.n	a43c <_out_rev+0x76>
      out(' ', buffer, idx++, maxlen);
    }
  }

  return idx;
}
    a3fc:	4620      	mov	r0, r4
    a3fe:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
      out(' ', buffer, idx++, maxlen);
    a402:	464b      	mov	r3, r9
    a404:	4659      	mov	r1, fp
    a406:	2020      	movs	r0, #32
    a408:	47b0      	blx	r6
    for (size_t i = len; i < width; i++) {
    a40a:	f108 0801 	add.w	r8, r8, #1
    a40e:	45b8      	cmp	r8, r7
    a410:	eb0a 0208 	add.w	r2, sl, r8
    a414:	d3f5      	bcc.n	a402 <_out_rev+0x3c>
    a416:	1b3a      	subs	r2, r7, r4
    a418:	42bc      	cmp	r4, r7
    a41a:	bf88      	it	hi
    a41c:	2200      	movhi	r2, #0
    a41e:	442a      	add	r2, r5
    a420:	e7dd      	b.n	a3de <_out_rev+0x18>
    a422:	46a0      	mov	r8, r4
    a424:	eba5 0a04 	sub.w	sl, r5, r4
    a428:	e7f1      	b.n	a40e <_out_rev+0x48>
    out(buf[--len], buffer, idx++, maxlen);
    a42a:	f102 0a01 	add.w	sl, r2, #1
    a42e:	f818 0d01 	ldrb.w	r0, [r8, #-1]!
    a432:	464b      	mov	r3, r9
    a434:	4659      	mov	r1, fp
    a436:	47b0      	blx	r6
    a438:	4652      	mov	r2, sl
    a43a:	e7d4      	b.n	a3e6 <_out_rev+0x20>
      out(' ', buffer, idx++, maxlen);
    a43c:	464b      	mov	r3, r9
    a43e:	4622      	mov	r2, r4
    a440:	4659      	mov	r1, fp
    a442:	2020      	movs	r0, #32
    a444:	47b0      	blx	r6
    a446:	f108 0801 	add.w	r8, r8, #1
    a44a:	e7d3      	b.n	a3f4 <_out_rev+0x2e>

0000a44c <_ntoa_format>:


// internal itoa format
static size_t _ntoa_format(out_fct_type out, char* buffer, size_t idx, size_t maxlen, char* buf, size_t len, bool negative, unsigned int base, unsigned int prec, unsigned int width, unsigned int flags)
{
    a44c:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    a450:	e9dd 760d 	ldrd	r7, r6, [sp, #52]	; 0x34
  // pad leading zeros
  if (!(flags & FLAGS_LEFT)) {
    a454:	f016 0f02 	tst.w	r6, #2
{
    a458:	e9dd 5408 	ldrd	r5, r4, [sp, #32]
    a45c:	e9dd c80b 	ldrd	ip, r8, [sp, #44]	; 0x2c
    a460:	f89d e028 	ldrb.w	lr, [sp, #40]	; 0x28
  if (!(flags & FLAGS_LEFT)) {
    a464:	d11f      	bne.n	a4a6 <_ntoa_format+0x5a>
    if (width && (flags & FLAGS_ZEROPAD) && (negative || (flags & (FLAGS_PLUS | FLAGS_SPACE)))) {
    a466:	f006 0901 	and.w	r9, r6, #1
    a46a:	b14f      	cbz	r7, a480 <_ntoa_format+0x34>
    a46c:	f1b9 0f00 	cmp.w	r9, #0
    a470:	d006      	beq.n	a480 <_ntoa_format+0x34>
    a472:	f1be 0f00 	cmp.w	lr, #0
    a476:	d102      	bne.n	a47e <_ntoa_format+0x32>
    a478:	f016 0f0c 	tst.w	r6, #12
    a47c:	d000      	beq.n	a480 <_ntoa_format+0x34>
      width--;
    a47e:	3f01      	subs	r7, #1
    }
    while ((len < prec) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
      buf[len++] = '0';
    a480:	f04f 0a30 	mov.w	sl, #48	; 0x30
    a484:	e004      	b.n	a490 <_ntoa_format+0x44>
    while ((len < prec) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
    a486:	2c20      	cmp	r4, #32
    a488:	d004      	beq.n	a494 <_ntoa_format+0x48>
      buf[len++] = '0';
    a48a:	f805 a004 	strb.w	sl, [r5, r4]
    a48e:	3401      	adds	r4, #1
    while ((len < prec) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
    a490:	45a0      	cmp	r8, r4
    a492:	d8f8      	bhi.n	a486 <_ntoa_format+0x3a>
    }
    while ((flags & FLAGS_ZEROPAD) && (len < width) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
      buf[len++] = '0';
    a494:	f04f 0a30 	mov.w	sl, #48	; 0x30
    while ((flags & FLAGS_ZEROPAD) && (len < width) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
    a498:	f1b9 0f00 	cmp.w	r9, #0
    a49c:	d003      	beq.n	a4a6 <_ntoa_format+0x5a>
    a49e:	42bc      	cmp	r4, r7
    a4a0:	d201      	bcs.n	a4a6 <_ntoa_format+0x5a>
    a4a2:	2c1f      	cmp	r4, #31
    a4a4:	d935      	bls.n	a512 <_ntoa_format+0xc6>
    }
  }

  // handle hash
  if (flags & FLAGS_HASH) {
    a4a6:	f016 0f10 	tst.w	r6, #16
    a4aa:	d01f      	beq.n	a4ec <_ntoa_format+0xa0>
    if (!(flags & FLAGS_PRECISION) && len && ((len == prec) || (len == width))) {
    a4ac:	f416 6f80 	tst.w	r6, #1024	; 0x400
    a4b0:	d134      	bne.n	a51c <_ntoa_format+0xd0>
    a4b2:	b39c      	cbz	r4, a51c <_ntoa_format+0xd0>
    a4b4:	4544      	cmp	r4, r8
    a4b6:	d001      	beq.n	a4bc <_ntoa_format+0x70>
    a4b8:	42bc      	cmp	r4, r7
    a4ba:	d12f      	bne.n	a51c <_ntoa_format+0xd0>
      len--;
      if (len && (base == 16U)) {
    a4bc:	f1b4 0801 	subs.w	r8, r4, #1
    a4c0:	d02b      	beq.n	a51a <_ntoa_format+0xce>
    a4c2:	f1bc 0f10 	cmp.w	ip, #16
    a4c6:	d134      	bne.n	a532 <_ntoa_format+0xe6>
        len--;
    a4c8:	3c02      	subs	r4, #2
      }
    }
    if ((base == 16U) && !(flags & FLAGS_UPPERCASE) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
    a4ca:	f016 0f20 	tst.w	r6, #32
    a4ce:	d132      	bne.n	a536 <_ntoa_format+0xea>
    a4d0:	2c1f      	cmp	r4, #31
    a4d2:	d815      	bhi.n	a500 <_ntoa_format+0xb4>
      buf[len++] = 'x';
    a4d4:	f04f 0c78 	mov.w	ip, #120	; 0x78
    }
    else if ((base == 16U) && (flags & FLAGS_UPPERCASE) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
      buf[len++] = 'X';
    }
    else if ((base == 2U) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
      buf[len++] = 'b';
    a4d8:	f805 c004 	strb.w	ip, [r5, r4]
    a4dc:	3401      	adds	r4, #1
    }
    if (len < PRINTF_NTOA_BUFFER_SIZE) {
    a4de:	2c1f      	cmp	r4, #31
    a4e0:	d80e      	bhi.n	a500 <_ntoa_format+0xb4>
      buf[len++] = '0';
    a4e2:	f04f 0c30 	mov.w	ip, #48	; 0x30
    a4e6:	f805 c004 	strb.w	ip, [r5, r4]
    a4ea:	3401      	adds	r4, #1
    }
  }

  if (len < PRINTF_NTOA_BUFFER_SIZE) {
    a4ec:	2c1f      	cmp	r4, #31
    a4ee:	d807      	bhi.n	a500 <_ntoa_format+0xb4>
    if (negative) {
    a4f0:	f1be 0f00 	cmp.w	lr, #0
    a4f4:	d024      	beq.n	a540 <_ntoa_format+0xf4>
      buf[len++] = '-';
    a4f6:	f04f 0c2d 	mov.w	ip, #45	; 0x2d
    }
    else if (flags & FLAGS_PLUS) {
      buf[len++] = '+';  // ignore the space if the '+' exists
    }
    else if (flags & FLAGS_SPACE) {
      buf[len++] = ' ';
    a4fa:	f805 c004 	strb.w	ip, [r5, r4]
    a4fe:	3401      	adds	r4, #1
    }
  }

  return _out_rev(out, buffer, idx, maxlen, buf, len, width, flags);
    a500:	e9cd 5408 	strd	r5, r4, [sp, #32]
    a504:	4c14      	ldr	r4, [pc, #80]	; (a558 <_ntoa_format+0x10c>)
    a506:	e9cd 760a 	strd	r7, r6, [sp, #40]	; 0x28
    a50a:	46a4      	mov	ip, r4
}
    a50c:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  return _out_rev(out, buffer, idx, maxlen, buf, len, width, flags);
    a510:	4760      	bx	ip
      buf[len++] = '0';
    a512:	f805 a004 	strb.w	sl, [r5, r4]
    a516:	3401      	adds	r4, #1
    a518:	e7be      	b.n	a498 <_ntoa_format+0x4c>
    a51a:	4644      	mov	r4, r8
    if ((base == 16U) && !(flags & FLAGS_UPPERCASE) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
    a51c:	f1bc 0f10 	cmp.w	ip, #16
    a520:	d0d3      	beq.n	a4ca <_ntoa_format+0x7e>
    else if ((base == 2U) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
    a522:	f1bc 0f02 	cmp.w	ip, #2
    a526:	d1da      	bne.n	a4de <_ntoa_format+0x92>
    a528:	2c1f      	cmp	r4, #31
    a52a:	d8e9      	bhi.n	a500 <_ntoa_format+0xb4>
      buf[len++] = 'b';
    a52c:	f04f 0c62 	mov.w	ip, #98	; 0x62
    a530:	e7d2      	b.n	a4d8 <_ntoa_format+0x8c>
    a532:	4644      	mov	r4, r8
    a534:	e7f5      	b.n	a522 <_ntoa_format+0xd6>
    else if ((base == 16U) && (flags & FLAGS_UPPERCASE) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
    a536:	2c1f      	cmp	r4, #31
    a538:	d8e2      	bhi.n	a500 <_ntoa_format+0xb4>
      buf[len++] = 'X';
    a53a:	f04f 0c58 	mov.w	ip, #88	; 0x58
    a53e:	e7cb      	b.n	a4d8 <_ntoa_format+0x8c>
    else if (flags & FLAGS_PLUS) {
    a540:	f016 0f04 	tst.w	r6, #4
    a544:	d002      	beq.n	a54c <_ntoa_format+0x100>
      buf[len++] = '+';  // ignore the space if the '+' exists
    a546:	f04f 0c2b 	mov.w	ip, #43	; 0x2b
    a54a:	e7d6      	b.n	a4fa <_ntoa_format+0xae>
    else if (flags & FLAGS_SPACE) {
    a54c:	f016 0f08 	tst.w	r6, #8
    a550:	d0d6      	beq.n	a500 <_ntoa_format+0xb4>
      buf[len++] = ' ';
    a552:	f04f 0c20 	mov.w	ip, #32
    a556:	e7d0      	b.n	a4fa <_ntoa_format+0xae>
    a558:	0000a3c7 	.word	0x0000a3c7

0000a55c <_ntoa_long>:


// internal itoa for 'long' type
static size_t _ntoa_long(out_fct_type out, char* buffer, size_t idx, size_t maxlen, unsigned long value, bool negative, unsigned long base, unsigned int prec, unsigned int width, unsigned int flags)
{
    a55c:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
    a560:	b091      	sub	sp, #68	; 0x44
    a562:	9d18      	ldr	r5, [sp, #96]	; 0x60
    a564:	9e1a      	ldr	r6, [sp, #104]	; 0x68
    a566:	9f1d      	ldr	r7, [sp, #116]	; 0x74
  char buf[PRINTF_NTOA_BUFFER_SIZE];
  size_t len = 0U;

  // no hash for 0 values
  if (!value) {
    a568:	b90d      	cbnz	r5, a56e <_ntoa_long+0x12>
    flags &= ~FLAGS_HASH;
    a56a:	f027 0710 	bic.w	r7, r7, #16
  }

  // write if precision != 0 and value is != 0
  if (!(flags & FLAGS_PRECISION) || value) {
    a56e:	057c      	lsls	r4, r7, #21
    a570:	d500      	bpl.n	a574 <_ntoa_long+0x18>
    a572:	b315      	cbz	r5, a5ba <_ntoa_long+0x5e>
    a574:	f017 0f20 	tst.w	r7, #32
    a578:	bf14      	ite	ne
    a57a:	f04f 0e41 	movne.w	lr, #65	; 0x41
    a57e:	f04f 0e61 	moveq.w	lr, #97	; 0x61
    do {
      const char digit = (char)(value % base);
      buf[len++] = digit < 10 ? '0' + digit : (flags & FLAGS_UPPERCASE ? 'A' : 'a') + digit - 10;
    a582:	46ac      	mov	ip, r5
    a584:	f10d 0820 	add.w	r8, sp, #32
    a588:	2500      	movs	r5, #0
    a58a:	f1ae 0e0a 	sub.w	lr, lr, #10
      const char digit = (char)(value % base);
    a58e:	fbbc f9f6 	udiv	r9, ip, r6
    a592:	fb06 c919 	mls	r9, r6, r9, ip
    a596:	fa5f f489 	uxtb.w	r4, r9
      buf[len++] = digit < 10 ? '0' + digit : (flags & FLAGS_UPPERCASE ? 'A' : 'a') + digit - 10;
    a59a:	f1b9 0f09 	cmp.w	r9, #9
    a59e:	bf94      	ite	ls
    a5a0:	3430      	addls	r4, #48	; 0x30
    a5a2:	4474      	addhi	r4, lr
    a5a4:	b2e4      	uxtb	r4, r4
      value /= base;
    } while (value && (len < PRINTF_NTOA_BUFFER_SIZE));
    a5a6:	45b4      	cmp	ip, r6
      buf[len++] = digit < 10 ? '0' + digit : (flags & FLAGS_UPPERCASE ? 'A' : 'a') + digit - 10;
    a5a8:	f808 4b01 	strb.w	r4, [r8], #1
      value /= base;
    a5ac:	fbbc f4f6 	udiv	r4, ip, r6
      buf[len++] = digit < 10 ? '0' + digit : (flags & FLAGS_UPPERCASE ? 'A' : 'a') + digit - 10;
    a5b0:	f105 0501 	add.w	r5, r5, #1
    } while (value && (len < PRINTF_NTOA_BUFFER_SIZE));
    a5b4:	d301      	bcc.n	a5ba <_ntoa_long+0x5e>
    a5b6:	2d20      	cmp	r5, #32
    a5b8:	d110      	bne.n	a5dc <_ntoa_long+0x80>
  }

  return _ntoa_format(out, buffer, idx, maxlen, buf, len, negative, (unsigned int)base, prec, width, flags);
    a5ba:	9c1c      	ldr	r4, [sp, #112]	; 0x70
    a5bc:	9405      	str	r4, [sp, #20]
    a5be:	9c1b      	ldr	r4, [sp, #108]	; 0x6c
    a5c0:	9706      	str	r7, [sp, #24]
    a5c2:	e9cd 6403 	strd	r6, r4, [sp, #12]
    a5c6:	f89d 4064 	ldrb.w	r4, [sp, #100]	; 0x64
    a5ca:	e9cd 5401 	strd	r5, r4, [sp, #4]
    a5ce:	ac08      	add	r4, sp, #32
    a5d0:	9400      	str	r4, [sp, #0]
    a5d2:	4c03      	ldr	r4, [pc, #12]	; (a5e0 <_ntoa_long+0x84>)
    a5d4:	47a0      	blx	r4
}
    a5d6:	b011      	add	sp, #68	; 0x44
    a5d8:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
      value /= base;
    a5dc:	46a4      	mov	ip, r4
    a5de:	e7d6      	b.n	a58e <_ntoa_long+0x32>
    a5e0:	0000a44d 	.word	0x0000a44d

0000a5e4 <_ntoa_long_long>:


// internal itoa for 'long long' type
#if defined(PRINTF_SUPPORT_LONG_LONG)
static size_t _ntoa_long_long(out_fct_type out, char* buffer, size_t idx, size_t maxlen, unsigned long long value, bool negative, unsigned long long base, unsigned int prec, unsigned int width, unsigned int flags)
{
    a5e4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    a5e8:	ed2d 8b04 	vpush	{d8-d9}
    a5ec:	b093      	sub	sp, #76	; 0x4c
    a5ee:	e9dd 6520 	ldrd	r6, r5, [sp, #128]	; 0x80
    a5f2:	469a      	mov	sl, r3
  char buf[PRINTF_NTOA_BUFFER_SIZE];
  size_t len = 0U;

  // no hash for 0 values
  if (!value) {
    a5f4:	ea56 0305 	orrs.w	r3, r6, r5
    flags &= ~FLAGS_HASH;
    a5f8:	bf02      	ittt	eq
    a5fa:	9b28      	ldreq	r3, [sp, #160]	; 0xa0
    a5fc:	f023 0310 	biceq.w	r3, r3, #16
    a600:	9328      	streq	r3, [sp, #160]	; 0xa0
  }

  // write if precision != 0 and value is != 0
  if (!(flags & FLAGS_PRECISION) || value) {
    a602:	9b28      	ldr	r3, [sp, #160]	; 0xa0
    a604:	055b      	lsls	r3, r3, #21
{
    a606:	e9dd b924 	ldrd	fp, r9, [sp, #144]	; 0x90
    a60a:	ee08 0a10 	vmov	s16, r0
    a60e:	ee08 1a90 	vmov	s17, r1
    a612:	ee09 2a10 	vmov	s18, r2
  if (!(flags & FLAGS_PRECISION) || value) {
    a616:	d502      	bpl.n	a61e <_ntoa_long_long+0x3a>
    a618:	ea56 0305 	orrs.w	r3, r6, r5
    a61c:	d03f      	beq.n	a69e <_ntoa_long_long+0xba>
    a61e:	9b28      	ldr	r3, [sp, #160]	; 0xa0
    a620:	f013 0f20 	tst.w	r3, #32
    a624:	bf14      	ite	ne
    a626:	2341      	movne	r3, #65	; 0x41
    a628:	2361      	moveq	r3, #97	; 0x61
    do {
      const char digit = (char)(value % base);
      buf[len++] = digit < 10 ? '0' + digit : (flags & FLAGS_UPPERCASE ? 'A' : 'a') + digit - 10;
    a62a:	3b0a      	subs	r3, #10
    a62c:	f10d 0828 	add.w	r8, sp, #40	; 0x28
    a630:	2400      	movs	r4, #0
    a632:	9309      	str	r3, [sp, #36]	; 0x24
      const char digit = (char)(value % base);
    a634:	4f1b      	ldr	r7, [pc, #108]	; (a6a4 <_ntoa_long_long+0xc0>)
    a636:	465a      	mov	r2, fp
    a638:	464b      	mov	r3, r9
    a63a:	4630      	mov	r0, r6
    a63c:	4629      	mov	r1, r5
    a63e:	47b8      	blx	r7
    a640:	b2d2      	uxtb	r2, r2
      buf[len++] = digit < 10 ? '0' + digit : (flags & FLAGS_UPPERCASE ? 'A' : 'a') + digit - 10;
    a642:	2a09      	cmp	r2, #9
    a644:	bf8a      	itet	hi
    a646:	9b09      	ldrhi	r3, [sp, #36]	; 0x24
    a648:	3230      	addls	r2, #48	; 0x30
    a64a:	18d2      	addhi	r2, r2, r3
      value /= base;
    } while (value && (len < PRINTF_NTOA_BUFFER_SIZE));
    a64c:	455e      	cmp	r6, fp
      buf[len++] = digit < 10 ? '0' + digit : (flags & FLAGS_UPPERCASE ? 'A' : 'a') + digit - 10;
    a64e:	b2d2      	uxtb	r2, r2
    } while (value && (len < PRINTF_NTOA_BUFFER_SIZE));
    a650:	eb75 0309 	sbcs.w	r3, r5, r9
      buf[len++] = digit < 10 ? '0' + digit : (flags & FLAGS_UPPERCASE ? 'A' : 'a') + digit - 10;
    a654:	f808 2b01 	strb.w	r2, [r8], #1
    a658:	f104 0401 	add.w	r4, r4, #1
    } while (value && (len < PRINTF_NTOA_BUFFER_SIZE));
    a65c:	d301      	bcc.n	a662 <_ntoa_long_long+0x7e>
    a65e:	2c20      	cmp	r4, #32
    a660:	d11a      	bne.n	a698 <_ntoa_long_long+0xb4>
  }

  return _ntoa_format(out, buffer, idx, maxlen, buf, len, negative, (unsigned int)base, prec, width, flags);
    a662:	9b28      	ldr	r3, [sp, #160]	; 0xa0
    a664:	9306      	str	r3, [sp, #24]
    a666:	9b27      	ldr	r3, [sp, #156]	; 0x9c
    a668:	9305      	str	r3, [sp, #20]
    a66a:	9b26      	ldr	r3, [sp, #152]	; 0x98
    a66c:	e9cd b303 	strd	fp, r3, [sp, #12]
    a670:	f89d 3088 	ldrb.w	r3, [sp, #136]	; 0x88
    a674:	e9cd 4301 	strd	r4, r3, [sp, #4]
    a678:	ab0a      	add	r3, sp, #40	; 0x28
    a67a:	9300      	str	r3, [sp, #0]
    a67c:	ee19 2a10 	vmov	r2, s18
    a680:	ee18 1a90 	vmov	r1, s17
    a684:	ee18 0a10 	vmov	r0, s16
    a688:	4c07      	ldr	r4, [pc, #28]	; (a6a8 <_ntoa_long_long+0xc4>)
    a68a:	4653      	mov	r3, sl
    a68c:	47a0      	blx	r4
}
    a68e:	b013      	add	sp, #76	; 0x4c
    a690:	ecbd 8b04 	vpop	{d8-d9}
    a694:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
      value /= base;
    a698:	4606      	mov	r6, r0
    a69a:	460d      	mov	r5, r1
    a69c:	e7ca      	b.n	a634 <_ntoa_long_long+0x50>
  size_t len = 0U;
    a69e:	2400      	movs	r4, #0
    a6a0:	e7df      	b.n	a662 <_ntoa_long_long+0x7e>
    a6a2:	bf00      	nop
    a6a4:	0000bd11 	.word	0x0000bd11
    a6a8:	0000a44d 	.word	0x0000a44d
    a6ac:	00000000 	.word	0x00000000

0000a6b0 <_etoa>:


#if defined(PRINTF_SUPPORT_EXPONENTIAL)
// internal ftoa variant for exponential floating-point type, contributed by Martijn Jasperse <m.jasperse@gmail.com>
static size_t _etoa(out_fct_type out, char* buffer, size_t idx, size_t maxlen, double value, unsigned int prec, unsigned int width, unsigned int flags)
{
    a6b0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    a6b4:	ed2d 8b06 	vpush	{d8-d10}
    a6b8:	b08f      	sub	sp, #60	; 0x3c
    a6ba:	ed9d 7b1e 	vldr	d7, [sp, #120]	; 0x78
    a6be:	ee09 3a90 	vmov	s19, r3
    a6c2:	eeb0 8a47 	vmov.f32	s16, s14
    a6c6:	eef0 8a67 	vmov.f32	s17, s15
    a6ca:	9b20      	ldr	r3, [sp, #128]	; 0x80
    a6cc:	9308      	str	r3, [sp, #32]
    a6ce:	9b21      	ldr	r3, [sp, #132]	; 0x84
    a6d0:	930b      	str	r3, [sp, #44]	; 0x2c
    a6d2:	9b22      	ldr	r3, [sp, #136]	; 0x88
    a6d4:	920a      	str	r2, [sp, #40]	; 0x28
    a6d6:	ee09 0a10 	vmov	s18, r0
    a6da:	468a      	mov	sl, r1
    a6dc:	9309      	str	r3, [sp, #36]	; 0x24
  // check for NaN and special values
  if ((value != value) || (value > DBL_MAX) || (value < -DBL_MAX)) {
    a6de:	ec51 0b17 	vmov	r0, r1, d7
    a6e2:	ec53 2b17 	vmov	r2, r3, d7
    a6e6:	4d15      	ldr	r5, [pc, #84]	; (a73c <_etoa+0x8c>)
    a6e8:	47a8      	blx	r5
    a6ea:	b180      	cbz	r0, a70e <_etoa+0x5e>
    a6ec:	4b14      	ldr	r3, [pc, #80]	; (a740 <_etoa+0x90>)
    a6ee:	4d15      	ldr	r5, [pc, #84]	; (a744 <_etoa+0x94>)
    a6f0:	ec51 0b18 	vmov	r0, r1, d8
    a6f4:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
    a6f8:	47a8      	blx	r5
    a6fa:	b940      	cbnz	r0, a70e <_etoa+0x5e>
    a6fc:	4d12      	ldr	r5, [pc, #72]	; (a748 <_etoa+0x98>)
    a6fe:	ec51 0b18 	vmov	r0, r1, d8
    a702:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
    a706:	f46f 1380 	mvn.w	r3, #1048576	; 0x100000
    a70a:	47a8      	blx	r5
    a70c:	b300      	cbz	r0, a750 <_etoa+0xa0>
    return _ftoa(out, buffer, idx, maxlen, value, prec, width, flags);
    a70e:	9b09      	ldr	r3, [sp, #36]	; 0x24
    a710:	9322      	str	r3, [sp, #136]	; 0x88
    a712:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    a714:	4c0d      	ldr	r4, [pc, #52]	; (a74c <_etoa+0x9c>)
    a716:	9321      	str	r3, [sp, #132]	; 0x84
    a718:	9b08      	ldr	r3, [sp, #32]
    a71a:	9320      	str	r3, [sp, #128]	; 0x80
    a71c:	9a0a      	ldr	r2, [sp, #40]	; 0x28
    a71e:	ee19 3a90 	vmov	r3, s19
    a722:	ee19 0a10 	vmov	r0, s18
    a726:	4651      	mov	r1, sl
    a728:	46a4      	mov	ip, r4
    a72a:	ed8d 8b1e 	vstr	d8, [sp, #120]	; 0x78
    if (flags & FLAGS_LEFT) {
      while (idx - start_idx < width) out(' ', buffer, idx++, maxlen);
    }
  }
  return idx;
}
    a72e:	b00f      	add	sp, #60	; 0x3c
    a730:	ecbd 8b06 	vpop	{d8-d10}
    a734:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    return _ftoa(out, buffer, idx, maxlen, value, prec, width, flags);
    a738:	4760      	bx	ip
    a73a:	bf00      	nop
    a73c:	0000bc1d 	.word	0x0000bc1d
    a740:	7fefffff 	.word	0x7fefffff
    a744:	0000bc6d 	.word	0x0000bc6d
    a748:	0000bc31 	.word	0x0000bc31
    a74c:	0000aab9 	.word	0x0000aab9
  if (negative) {
    a750:	ec51 0b18 	vmov	r0, r1, d8
    a754:	2200      	movs	r2, #0
    a756:	2300      	movs	r3, #0
    a758:	47a8      	blx	r5
    a75a:	2800      	cmp	r0, #0
    a75c:	f000 8147 	beq.w	a9ee <_etoa+0x33e>
    value = -value;
    a760:	ee18 3a90 	vmov	r3, s17
    a764:	f103 4300 	add.w	r3, r3, #2147483648	; 0x80000000
    a768:	ed8d 8a06 	vstr	s16, [sp, #24]
    a76c:	9307      	str	r3, [sp, #28]
  conv.F = value;
    a76e:	e9dd 9806 	ldrd	r9, r8, [sp, #24]
    prec = PRINTF_DEFAULT_FLOAT_PRECISION;
    a772:	9b09      	ldr	r3, [sp, #36]	; 0x24
  int expval = (int)(0.1760912590558 + exp2 * 0.301029995663981 + (conv.F - 1.5) * 0.289529654602168);
    a774:	4db4      	ldr	r5, [pc, #720]	; (aa48 <_etoa+0x398>)
    a776:	4cb5      	ldr	r4, [pc, #724]	; (aa4c <_etoa+0x39c>)
    a778:	4eb5      	ldr	r6, [pc, #724]	; (aa50 <_etoa+0x3a0>)
    a77a:	4fb6      	ldr	r7, [pc, #728]	; (aa54 <_etoa+0x3a4>)
    prec = PRINTF_DEFAULT_FLOAT_PRECISION;
    a77c:	f413 6380 	ands.w	r3, r3, #1024	; 0x400
    a780:	930d      	str	r3, [sp, #52]	; 0x34
  int exp2 = (int)((conv.U >> 52U) & 0x07FFU) - 1023;           // effectively log2
    a782:	f3c8 500a 	ubfx	r0, r8, #20, #11
    prec = PRINTF_DEFAULT_FLOAT_PRECISION;
    a786:	9b08      	ldr	r3, [sp, #32]
    a788:	bf08      	it	eq
    a78a:	2306      	moveq	r3, #6
    a78c:	9308      	str	r3, [sp, #32]
  int expval = (int)(0.1760912590558 + exp2 * 0.301029995663981 + (conv.F - 1.5) * 0.289529654602168);
    a78e:	f2a0 30ff 	subw	r0, r0, #1023	; 0x3ff
    a792:	47a8      	blx	r5
    a794:	a39c      	add	r3, pc, #624	; (adr r3, aa08 <_etoa+0x358>)
    a796:	e9d3 2300 	ldrd	r2, r3, [r3]
    a79a:	47a0      	blx	r4
    a79c:	a39c      	add	r3, pc, #624	; (adr r3, aa10 <_etoa+0x360>)
    a79e:	e9d3 2300 	ldrd	r2, r3, [r3]
    a7a2:	47b0      	blx	r6
  conv.U = (conv.U & ((1ULL << 52U) - 1U)) | (1023ULL << 52U);  // drop the exponent so conv.F is now in [1,2)
    a7a4:	f3c8 0813 	ubfx	r8, r8, #0, #20
  int expval = (int)(0.1760912590558 + exp2 * 0.301029995663981 + (conv.F - 1.5) * 0.289529654602168);
    a7a8:	ec41 0b1a 	vmov	d10, r0, r1
  conv.U = (conv.U & ((1ULL << 52U) - 1U)) | (1023ULL << 52U);  // drop the exponent so conv.F is now in [1,2)
    a7ac:	f048 517f 	orr.w	r1, r8, #1069547520	; 0x3fc00000
  int expval = (int)(0.1760912590558 + exp2 * 0.301029995663981 + (conv.F - 1.5) * 0.289529654602168);
    a7b0:	4ba9      	ldr	r3, [pc, #676]	; (aa58 <_etoa+0x3a8>)
    a7b2:	f8df 82d0 	ldr.w	r8, [pc, #720]	; aa84 <_etoa+0x3d4>
  conv.U = (conv.U & ((1ULL << 52U) - 1U)) | (1023ULL << 52U);  // drop the exponent so conv.F is now in [1,2)
    a7b6:	4648      	mov	r0, r9
  int expval = (int)(0.1760912590558 + exp2 * 0.301029995663981 + (conv.F - 1.5) * 0.289529654602168);
    a7b8:	2200      	movs	r2, #0
  conv.U = (conv.U & ((1ULL << 52U) - 1U)) | (1023ULL << 52U);  // drop the exponent so conv.F is now in [1,2)
    a7ba:	f441 1140 	orr.w	r1, r1, #3145728	; 0x300000
  int expval = (int)(0.1760912590558 + exp2 * 0.301029995663981 + (conv.F - 1.5) * 0.289529654602168);
    a7be:	47b8      	blx	r7
    a7c0:	a395      	add	r3, pc, #596	; (adr r3, aa18 <_etoa+0x368>)
    a7c2:	e9d3 2300 	ldrd	r2, r3, [r3]
    a7c6:	47a0      	blx	r4
    a7c8:	4602      	mov	r2, r0
    a7ca:	460b      	mov	r3, r1
    a7cc:	ec51 0b1a 	vmov	r0, r1, d10
    a7d0:	47b0      	blx	r6
    a7d2:	47c0      	blx	r8
    a7d4:	4683      	mov	fp, r0
  exp2 = (int)(expval * 3.321928094887362 + 0.5);
    a7d6:	47a8      	blx	r5
    a7d8:	a391      	add	r3, pc, #580	; (adr r3, aa20 <_etoa+0x370>)
    a7da:	e9d3 2300 	ldrd	r2, r3, [r3]
    a7de:	4606      	mov	r6, r0
    a7e0:	460f      	mov	r7, r1
    a7e2:	47a0      	blx	r4
    a7e4:	4b9d      	ldr	r3, [pc, #628]	; (aa5c <_etoa+0x3ac>)
    a7e6:	4c9a      	ldr	r4, [pc, #616]	; (aa50 <_etoa+0x3a0>)
    a7e8:	2200      	movs	r2, #0
    a7ea:	47a0      	blx	r4
    a7ec:	47c0      	blx	r8
  const double z  = expval * 2.302585092994046 - exp2 * 0.6931471805599453;
    a7ee:	a38e      	add	r3, pc, #568	; (adr r3, aa28 <_etoa+0x378>)
    a7f0:	e9d3 2300 	ldrd	r2, r3, [r3]
  exp2 = (int)(expval * 3.321928094887362 + 0.5);
    a7f4:	900c      	str	r0, [sp, #48]	; 0x30
  const double z  = expval * 2.302585092994046 - exp2 * 0.6931471805599453;
    a7f6:	4639      	mov	r1, r7
    a7f8:	4630      	mov	r0, r6
    a7fa:	4f94      	ldr	r7, [pc, #592]	; (aa4c <_etoa+0x39c>)
    a7fc:	47b8      	blx	r7
    a7fe:	4606      	mov	r6, r0
    a800:	980c      	ldr	r0, [sp, #48]	; 0x30
    a802:	463c      	mov	r4, r7
    a804:	460f      	mov	r7, r1
    a806:	47a8      	blx	r5
    a808:	a389      	add	r3, pc, #548	; (adr r3, aa30 <_etoa+0x380>)
    a80a:	e9d3 2300 	ldrd	r2, r3, [r3]
    a80e:	47a0      	blx	r4
    a810:	4602      	mov	r2, r0
    a812:	460b      	mov	r3, r1
    a814:	4630      	mov	r0, r6
    a816:	4639      	mov	r1, r7
    a818:	4f8e      	ldr	r7, [pc, #568]	; (aa54 <_etoa+0x3a4>)
  conv.F *= 1 + 2 * z / (2 - z + (z2 / (6 + (z2 / (10 + z2 / 14)))));
    a81a:	4d91      	ldr	r5, [pc, #580]	; (aa60 <_etoa+0x3b0>)
  const double z  = expval * 2.302585092994046 - exp2 * 0.6931471805599453;
    a81c:	47b8      	blx	r7
  const double z2 = z * z;
    a81e:	4602      	mov	r2, r0
    a820:	460b      	mov	r3, r1
  const double z  = expval * 2.302585092994046 - exp2 * 0.6931471805599453;
    a822:	4606      	mov	r6, r0
    a824:	460f      	mov	r7, r1
  const double z2 = z * z;
    a826:	47a0      	blx	r4
  conv.F *= 1 + 2 * z / (2 - z + (z2 / (6 + (z2 / (10 + z2 / 14)))));
    a828:	4c89      	ldr	r4, [pc, #548]	; (aa50 <_etoa+0x3a0>)
  const double z2 = z * z;
    a82a:	4680      	mov	r8, r0
    a82c:	4689      	mov	r9, r1
  conv.F *= 1 + 2 * z / (2 - z + (z2 / (6 + (z2 / (10 + z2 / 14)))));
    a82e:	4632      	mov	r2, r6
    a830:	463b      	mov	r3, r7
    a832:	4630      	mov	r0, r6
    a834:	4639      	mov	r1, r7
    a836:	47a0      	blx	r4
    a838:	4b8a      	ldr	r3, [pc, #552]	; (aa64 <_etoa+0x3b4>)
    a83a:	ec41 0b1a 	vmov	d10, r0, r1
    a83e:	2200      	movs	r2, #0
    a840:	4640      	mov	r0, r8
    a842:	4649      	mov	r1, r9
    a844:	47a8      	blx	r5
    a846:	4b88      	ldr	r3, [pc, #544]	; (aa68 <_etoa+0x3b8>)
    a848:	2200      	movs	r2, #0
    a84a:	47a0      	blx	r4
    a84c:	4602      	mov	r2, r0
    a84e:	460b      	mov	r3, r1
    a850:	4640      	mov	r0, r8
    a852:	4649      	mov	r1, r9
    a854:	47a8      	blx	r5
    a856:	4b85      	ldr	r3, [pc, #532]	; (aa6c <_etoa+0x3bc>)
    a858:	2200      	movs	r2, #0
    a85a:	47a0      	blx	r4
    a85c:	4602      	mov	r2, r0
    a85e:	460b      	mov	r3, r1
    a860:	4640      	mov	r0, r8
    a862:	4649      	mov	r1, r9
    a864:	47a8      	blx	r5
    a866:	4632      	mov	r2, r6
    a868:	4680      	mov	r8, r0
    a86a:	463b      	mov	r3, r7
    a86c:	4689      	mov	r9, r1
    a86e:	4f79      	ldr	r7, [pc, #484]	; (aa54 <_etoa+0x3a4>)
    a870:	2000      	movs	r0, #0
    a872:	f04f 4180 	mov.w	r1, #1073741824	; 0x40000000
    a876:	47b8      	blx	r7
    a878:	4602      	mov	r2, r0
    a87a:	460b      	mov	r3, r1
    a87c:	4640      	mov	r0, r8
    a87e:	4649      	mov	r1, r9
    a880:	47a0      	blx	r4
    a882:	4602      	mov	r2, r0
    a884:	460b      	mov	r3, r1
    a886:	ec51 0b1a 	vmov	r0, r1, d10
    a88a:	47a8      	blx	r5
    a88c:	4b78      	ldr	r3, [pc, #480]	; (aa70 <_etoa+0x3c0>)
  if (value < conv.F) {
    a88e:	f8df 81f8 	ldr.w	r8, [pc, #504]	; aa88 <_etoa+0x3d8>
  conv.F *= 1 + 2 * z / (2 - z + (z2 / (6 + (z2 / (10 + z2 / 14)))));
    a892:	2200      	movs	r2, #0
    a894:	47a0      	blx	r4
  conv.U = (uint64_t)(exp2 + 1023) << 52U;
    a896:	9b0c      	ldr	r3, [sp, #48]	; 0x30
  conv.F *= 1 + 2 * z / (2 - z + (z2 / (6 + (z2 / (10 + z2 / 14)))));
    a898:	4c6c      	ldr	r4, [pc, #432]	; (aa4c <_etoa+0x39c>)
  conv.U = (uint64_t)(exp2 + 1023) << 52U;
    a89a:	f203 36ff 	addw	r6, r3, #1023	; 0x3ff
    a89e:	0533      	lsls	r3, r6, #20
    a8a0:	2200      	movs	r2, #0
  conv.F *= 1 + 2 * z / (2 - z + (z2 / (6 + (z2 / (10 + z2 / 14)))));
    a8a2:	47a0      	blx	r4
  if (value < conv.F) {
    a8a4:	e9dd 2306 	ldrd	r2, r3, [sp, #24]
  conv.F *= 1 + 2 * z / (2 - z + (z2 / (6 + (z2 / (10 + z2 / 14)))));
    a8a8:	4606      	mov	r6, r0
    a8aa:	460f      	mov	r7, r1
  if (value < conv.F) {
    a8ac:	47c0      	blx	r8
    a8ae:	2800      	cmp	r0, #0
    a8b0:	f040 80a0 	bne.w	a9f4 <_etoa+0x344>
  conv.F *= 1 + 2 * z / (2 - z + (z2 / (6 + (z2 / (10 + z2 / 14)))));
    a8b4:	46b0      	mov	r8, r6
    a8b6:	46b9      	mov	r9, r7
  unsigned int minwidth = ((expval < 100) && (expval > -100)) ? 4U : 5U;
    a8b8:	f10b 0363 	add.w	r3, fp, #99	; 0x63
    a8bc:	2bc7      	cmp	r3, #199	; 0xc7
  if (flags & FLAGS_ADAPT_EXP) {
    a8be:	9b09      	ldr	r3, [sp, #36]	; 0x24
  unsigned int minwidth = ((expval < 100) && (expval > -100)) ? 4U : 5U;
    a8c0:	bf34      	ite	cc
    a8c2:	2504      	movcc	r5, #4
    a8c4:	2505      	movcs	r5, #5
  if (flags & FLAGS_ADAPT_EXP) {
    a8c6:	0519      	lsls	r1, r3, #20
    a8c8:	d522      	bpl.n	a910 <_etoa+0x260>
    if ((value >= 1e-4) && (value < 1e6)) {
    a8ca:	a35b      	add	r3, pc, #364	; (adr r3, aa38 <_etoa+0x388>)
    a8cc:	e9d3 2300 	ldrd	r2, r3, [r3]
    a8d0:	e9dd 0106 	ldrd	r0, r1, [sp, #24]
    a8d4:	4e67      	ldr	r6, [pc, #412]	; (aa74 <_etoa+0x3c4>)
    a8d6:	47b0      	blx	r6
    a8d8:	2800      	cmp	r0, #0
    a8da:	f000 80d7 	beq.w	aa8c <_etoa+0x3dc>
    a8de:	a358      	add	r3, pc, #352	; (adr r3, aa40 <_etoa+0x390>)
    a8e0:	e9d3 2300 	ldrd	r2, r3, [r3]
    a8e4:	e9dd 0106 	ldrd	r0, r1, [sp, #24]
    a8e8:	4e63      	ldr	r6, [pc, #396]	; (aa78 <_etoa+0x3c8>)
    a8ea:	47b0      	blx	r6
    a8ec:	2800      	cmp	r0, #0
    a8ee:	f000 80cd 	beq.w	aa8c <_etoa+0x3dc>
      if ((int)prec > expval) {
    a8f2:	9b08      	ldr	r3, [sp, #32]
    a8f4:	455b      	cmp	r3, fp
        prec = (unsigned)((int)prec - expval - 1);
    a8f6:	bfc6      	itte	gt
    a8f8:	eba3 000b 	subgt.w	r0, r3, fp
    a8fc:	f100 33ff 	addgt.w	r3, r0, #4294967295	; 0xffffffff
        prec = 0;
    a900:	2300      	movle	r3, #0
    a902:	9308      	str	r3, [sp, #32]
      flags |= FLAGS_PRECISION;   // make sure _ftoa respects precision
    a904:	9b09      	ldr	r3, [sp, #36]	; 0x24
      minwidth = 0U;
    a906:	2500      	movs	r5, #0
      flags |= FLAGS_PRECISION;   // make sure _ftoa respects precision
    a908:	f443 6380 	orr.w	r3, r3, #1024	; 0x400
    a90c:	9309      	str	r3, [sp, #36]	; 0x24
      expval   = 0;
    a90e:	46ab      	mov	fp, r5
  if (width > minwidth) {
    a910:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    a912:	429d      	cmp	r5, r3
    fwidth -= minwidth;
    a914:	bf38      	it	cc
    a916:	1b5e      	subcc	r6, r3, r5
  if ((flags & FLAGS_LEFT) && minwidth) {
    a918:	9b09      	ldr	r3, [sp, #36]	; 0x24
    fwidth = 0U;
    a91a:	bf28      	it	cs
    a91c:	2600      	movcs	r6, #0
  if ((flags & FLAGS_LEFT) && minwidth) {
    a91e:	f013 0702 	ands.w	r7, r3, #2
    a922:	d002      	beq.n	a92a <_etoa+0x27a>
    fwidth = 0U;
    a924:	2d00      	cmp	r5, #0
    a926:	bf18      	it	ne
    a928:	2600      	movne	r6, #0
  if (expval) {
    a92a:	f1bb 0f00 	cmp.w	fp, #0
    a92e:	d008      	beq.n	a942 <_etoa+0x292>
    value /= conv.F;
    a930:	e9dd 0106 	ldrd	r0, r1, [sp, #24]
    a934:	4642      	mov	r2, r8
    a936:	464b      	mov	r3, r9
    a938:	f8df 8124 	ldr.w	r8, [pc, #292]	; aa60 <_etoa+0x3b0>
    a93c:	47c0      	blx	r8
    a93e:	e9cd 0106 	strd	r0, r1, [sp, #24]
  idx = _ftoa(out, buffer, idx, maxlen, negative ? -value : value, prec, fwidth, flags & ~FLAGS_ADAPT_EXP);
    a942:	ec51 0b18 	vmov	r0, r1, d8
    a946:	f8df 8130 	ldr.w	r8, [pc, #304]	; aa78 <_etoa+0x3c8>
    a94a:	2200      	movs	r2, #0
    a94c:	2300      	movs	r3, #0
    a94e:	47c0      	blx	r8
    a950:	b128      	cbz	r0, a95e <_etoa+0x2ae>
    a952:	e9dd 2106 	ldrd	r2, r1, [sp, #24]
    a956:	f101 4300 	add.w	r3, r1, #2147483648	; 0x80000000
    a95a:	e9cd 2306 	strd	r2, r3, [sp, #24]
    a95e:	9b09      	ldr	r3, [sp, #36]	; 0x24
    a960:	9a0a      	ldr	r2, [sp, #40]	; 0x28
    a962:	ed9d 7b06 	vldr	d7, [sp, #24]
    a966:	f423 6300 	bic.w	r3, r3, #2048	; 0x800
    a96a:	e9cd 6303 	strd	r6, r3, [sp, #12]
    a96e:	9b08      	ldr	r3, [sp, #32]
    a970:	9302      	str	r3, [sp, #8]
    a972:	ed8d 7b00 	vstr	d7, [sp]
    a976:	ee19 3a90 	vmov	r3, s19
    a97a:	ee19 0a10 	vmov	r0, s18
    a97e:	4e3f      	ldr	r6, [pc, #252]	; (aa7c <_etoa+0x3cc>)
    a980:	4651      	mov	r1, sl
    a982:	47b0      	blx	r6
  if (minwidth) {
    a984:	b375      	cbz	r5, a9e4 <_etoa+0x334>
    out((flags & FLAGS_UPPERCASE) ? 'E' : 'e', buffer, idx++, maxlen);
    a986:	9b09      	ldr	r3, [sp, #36]	; 0x24
    a988:	f013 0f20 	tst.w	r3, #32
    a98c:	f100 0601 	add.w	r6, r0, #1
    a990:	4602      	mov	r2, r0
    a992:	ee19 3a90 	vmov	r3, s19
    a996:	bf14      	ite	ne
    a998:	2045      	movne	r0, #69	; 0x45
    a99a:	2065      	moveq	r0, #101	; 0x65
    a99c:	4651      	mov	r1, sl
    a99e:	ee19 4a10 	vmov	r4, s18
    a9a2:	47a0      	blx	r4
    idx = _ntoa_long(out, buffer, idx, maxlen, (expval < 0) ? -expval : expval, expval < 0, 10, 0, minwidth-1, FLAGS_ZEROPAD | FLAGS_PLUS);
    a9a4:	2305      	movs	r3, #5
    a9a6:	2200      	movs	r2, #0
    a9a8:	9305      	str	r3, [sp, #20]
    a9aa:	ea8b 70eb 	eor.w	r0, fp, fp, asr #31
    a9ae:	230a      	movs	r3, #10
    a9b0:	e9cd 3202 	strd	r3, r2, [sp, #8]
    a9b4:	3d01      	subs	r5, #1
    a9b6:	ea4f 73db 	mov.w	r3, fp, lsr #31
    a9ba:	eba0 70eb 	sub.w	r0, r0, fp, asr #31
    a9be:	9504      	str	r5, [sp, #16]
    a9c0:	9301      	str	r3, [sp, #4]
    a9c2:	9000      	str	r0, [sp, #0]
    a9c4:	ee19 3a90 	vmov	r3, s19
    a9c8:	ee19 0a10 	vmov	r0, s18
    a9cc:	4d2c      	ldr	r5, [pc, #176]	; (aa80 <_etoa+0x3d0>)
    a9ce:	4632      	mov	r2, r6
    a9d0:	4651      	mov	r1, sl
    a9d2:	47a8      	blx	r5
    if (flags & FLAGS_LEFT) {
    a9d4:	b137      	cbz	r7, a9e4 <_etoa+0x334>
    a9d6:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    a9d8:	1ac5      	subs	r5, r0, r3
    a9da:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    a9dc:	1958      	adds	r0, r3, r5
      while (idx - start_idx < width) out(' ', buffer, idx++, maxlen);
    a9de:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    a9e0:	42ab      	cmp	r3, r5
    a9e2:	d85f      	bhi.n	aaa4 <_etoa+0x3f4>
}
    a9e4:	b00f      	add	sp, #60	; 0x3c
    a9e6:	ecbd 8b06 	vpop	{d8-d10}
    a9ea:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    a9ee:	ed8d 8b06 	vstr	d8, [sp, #24]
    a9f2:	e6bc      	b.n	a76e <_etoa+0xbe>
    conv.F /= 10;
    a9f4:	4b1c      	ldr	r3, [pc, #112]	; (aa68 <_etoa+0x3b8>)
    a9f6:	2200      	movs	r2, #0
    a9f8:	4630      	mov	r0, r6
    a9fa:	4639      	mov	r1, r7
    a9fc:	47a8      	blx	r5
    expval--;
    a9fe:	f10b 3bff 	add.w	fp, fp, #4294967295	; 0xffffffff
    conv.F /= 10;
    aa02:	4680      	mov	r8, r0
    aa04:	4689      	mov	r9, r1
    aa06:	e757      	b.n	a8b8 <_etoa+0x208>
    aa08:	509f79fb 	.word	0x509f79fb
    aa0c:	3fd34413 	.word	0x3fd34413
    aa10:	8b60c8b3 	.word	0x8b60c8b3
    aa14:	3fc68a28 	.word	0x3fc68a28
    aa18:	636f4361 	.word	0x636f4361
    aa1c:	3fd287a7 	.word	0x3fd287a7
    aa20:	0979a371 	.word	0x0979a371
    aa24:	400a934f 	.word	0x400a934f
    aa28:	bbb55516 	.word	0xbbb55516
    aa2c:	40026bb1 	.word	0x40026bb1
    aa30:	fefa39ef 	.word	0xfefa39ef
    aa34:	3fe62e42 	.word	0x3fe62e42
    aa38:	eb1c432d 	.word	0xeb1c432d
    aa3c:	3f1a36e2 	.word	0x3f1a36e2
    aa40:	00000000 	.word	0x00000000
    aa44:	412e8480 	.word	0x412e8480
    aa48:	0000b679 	.word	0x0000b679
    aa4c:	0000b74d 	.word	0x0000b74d
    aa50:	0000b3e1 	.word	0x0000b3e1
    aa54:	0000b3dd 	.word	0x0000b3dd
    aa58:	3ff80000 	.word	0x3ff80000
    aa5c:	3fe00000 	.word	0x3fe00000
    aa60:	0000b9a1 	.word	0x0000b9a1
    aa64:	402c0000 	.word	0x402c0000
    aa68:	40240000 	.word	0x40240000
    aa6c:	40180000 	.word	0x40180000
    aa70:	3ff00000 	.word	0x3ff00000
    aa74:	0000bc59 	.word	0x0000bc59
    aa78:	0000bc31 	.word	0x0000bc31
    aa7c:	0000aab9 	.word	0x0000aab9
    aa80:	0000a55d 	.word	0x0000a55d
    aa84:	0000bc81 	.word	0x0000bc81
    aa88:	0000bc6d 	.word	0x0000bc6d
      if ((prec > 0) && (flags & FLAGS_PRECISION)) {
    aa8c:	9b08      	ldr	r3, [sp, #32]
    aa8e:	2b00      	cmp	r3, #0
    aa90:	f43f af3e 	beq.w	a910 <_etoa+0x260>
    aa94:	9b0d      	ldr	r3, [sp, #52]	; 0x34
    aa96:	2b00      	cmp	r3, #0
    aa98:	f43f af3a 	beq.w	a910 <_etoa+0x260>
        --prec;
    aa9c:	9b08      	ldr	r3, [sp, #32]
    aa9e:	3b01      	subs	r3, #1
    aaa0:	9308      	str	r3, [sp, #32]
    aaa2:	e735      	b.n	a910 <_etoa+0x260>
      while (idx - start_idx < width) out(' ', buffer, idx++, maxlen);
    aaa4:	4602      	mov	r2, r0
    aaa6:	ee19 3a90 	vmov	r3, s19
    aaaa:	ee19 4a10 	vmov	r4, s18
    aaae:	4651      	mov	r1, sl
    aab0:	2020      	movs	r0, #32
    aab2:	47a0      	blx	r4
    aab4:	3501      	adds	r5, #1
    aab6:	e790      	b.n	a9da <_etoa+0x32a>

0000aab8 <_ftoa>:
{
    aab8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    aabc:	ed2d 8b08 	vpush	{d8-d11}
    aac0:	b091      	sub	sp, #68	; 0x44
    aac2:	e9dd ab22 	ldrd	sl, fp, [sp, #136]	; 0x88
    aac6:	ee09 3a10 	vmov	s18, r3
    aaca:	e9dd 5324 	ldrd	r5, r3, [sp, #144]	; 0x90
    aace:	ee08 0a10 	vmov	s16, r0
    aad2:	ee08 1a90 	vmov	s17, r1
    aad6:	4617      	mov	r7, r2
    aad8:	9306      	str	r3, [sp, #24]
  if (value != value)
    aada:	4cab      	ldr	r4, [pc, #684]	; (ad88 <_ftoa+0x2d0>)
{
    aadc:	9e26      	ldr	r6, [sp, #152]	; 0x98
  if (value != value)
    aade:	4652      	mov	r2, sl
    aae0:	465b      	mov	r3, fp
    aae2:	4650      	mov	r0, sl
    aae4:	4659      	mov	r1, fp
    aae6:	47a0      	blx	r4
    aae8:	b9a8      	cbnz	r0, ab16 <_ftoa+0x5e>
    return _out_rev(out, buffer, idx, maxlen, "nan", 3, width, flags);
    aaea:	9b06      	ldr	r3, [sp, #24]
    aaec:	9324      	str	r3, [sp, #144]	; 0x90
    aaee:	2303      	movs	r3, #3
    aaf0:	9323      	str	r3, [sp, #140]	; 0x8c
    aaf2:	4ba6      	ldr	r3, [pc, #664]	; (ad8c <_ftoa+0x2d4>)
    aaf4:	9625      	str	r6, [sp, #148]	; 0x94
    return _out_rev(out, buffer, idx, maxlen, "fni-", 4, width, flags);
    aaf6:	4ca6      	ldr	r4, [pc, #664]	; (ad90 <_ftoa+0x2d8>)
    aaf8:	9322      	str	r3, [sp, #136]	; 0x88
    aafa:	ee18 1a90 	vmov	r1, s17
    aafe:	ee19 3a10 	vmov	r3, s18
    ab02:	ee18 0a10 	vmov	r0, s16
    ab06:	463a      	mov	r2, r7
    ab08:	46a4      	mov	ip, r4
}
    ab0a:	b011      	add	sp, #68	; 0x44
    ab0c:	ecbd 8b08 	vpop	{d8-d11}
    ab10:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    return _out_rev(out, buffer, idx, maxlen, "fni-", 4, width, flags);
    ab14:	4760      	bx	ip
  if (value < -DBL_MAX)
    ab16:	4c9f      	ldr	r4, [pc, #636]	; (ad94 <_ftoa+0x2dc>)
    ab18:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
    ab1c:	f46f 1380 	mvn.w	r3, #1048576	; 0x100000
    ab20:	4650      	mov	r0, sl
    ab22:	4659      	mov	r1, fp
    ab24:	47a0      	blx	r4
    ab26:	b130      	cbz	r0, ab36 <_ftoa+0x7e>
    return _out_rev(out, buffer, idx, maxlen, "fni-", 4, width, flags);
    ab28:	9b06      	ldr	r3, [sp, #24]
    ab2a:	9324      	str	r3, [sp, #144]	; 0x90
    ab2c:	2304      	movs	r3, #4
    ab2e:	9323      	str	r3, [sp, #140]	; 0x8c
    ab30:	9625      	str	r6, [sp, #148]	; 0x94
    ab32:	4b99      	ldr	r3, [pc, #612]	; (ad98 <_ftoa+0x2e0>)
    ab34:	e7df      	b.n	aaf6 <_ftoa+0x3e>
  if (value > DBL_MAX)
    ab36:	f8df 9290 	ldr.w	r9, [pc, #656]	; adc8 <_ftoa+0x310>
    ab3a:	4b98      	ldr	r3, [pc, #608]	; (ad9c <_ftoa+0x2e4>)
    ab3c:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
    ab40:	4650      	mov	r0, sl
    ab42:	4659      	mov	r1, fp
    ab44:	47c8      	blx	r9
    ab46:	b170      	cbz	r0, ab66 <_ftoa+0xae>
    return _out_rev(out, buffer, idx, maxlen, (flags & FLAGS_PLUS) ? "fni+" : "fni", (flags & FLAGS_PLUS) ? 4U : 3U, width, flags);
    ab48:	4a95      	ldr	r2, [pc, #596]	; (ada0 <_ftoa+0x2e8>)
    ab4a:	9906      	ldr	r1, [sp, #24]
    ab4c:	9625      	str	r6, [sp, #148]	; 0x94
    ab4e:	f006 0304 	and.w	r3, r6, #4
    ab52:	2b00      	cmp	r3, #0
    ab54:	bf08      	it	eq
    ab56:	2203      	moveq	r2, #3
    ab58:	4b92      	ldr	r3, [pc, #584]	; (ada4 <_ftoa+0x2ec>)
    ab5a:	bf1c      	itt	ne
    ab5c:	4613      	movne	r3, r2
    ab5e:	2204      	movne	r2, #4
    ab60:	e9cd 2123 	strd	r2, r1, [sp, #140]	; 0x8c
    ab64:	e7c7      	b.n	aaf6 <_ftoa+0x3e>
  if ((value > PRINTF_MAX_FLOAT) || (value < -PRINTF_MAX_FLOAT)) {
    ab66:	a384      	add	r3, pc, #528	; (adr r3, ad78 <_ftoa+0x2c0>)
    ab68:	e9d3 2300 	ldrd	r2, r3, [r3]
    ab6c:	4650      	mov	r0, sl
    ab6e:	4659      	mov	r1, fp
    ab70:	47c8      	blx	r9
    ab72:	b930      	cbnz	r0, ab82 <_ftoa+0xca>
    ab74:	a382      	add	r3, pc, #520	; (adr r3, ad80 <_ftoa+0x2c8>)
    ab76:	e9d3 2300 	ldrd	r2, r3, [r3]
    ab7a:	4650      	mov	r0, sl
    ab7c:	4659      	mov	r1, fp
    ab7e:	47a0      	blx	r4
    ab80:	b1a0      	cbz	r0, abac <_ftoa+0xf4>
    return _etoa(out, buffer, idx, maxlen, value, prec, width, flags);
    ab82:	9b06      	ldr	r3, [sp, #24]
    ab84:	4c88      	ldr	r4, [pc, #544]	; (ada8 <_ftoa+0x2f0>)
    ab86:	9626      	str	r6, [sp, #152]	; 0x98
    ab88:	e9cd 5324 	strd	r5, r3, [sp, #144]	; 0x90
    ab8c:	ee18 1a90 	vmov	r1, s17
    ab90:	ee19 3a10 	vmov	r3, s18
    ab94:	ee18 0a10 	vmov	r0, s16
    ab98:	463a      	mov	r2, r7
    ab9a:	46a4      	mov	ip, r4
    ab9c:	e9cd ab22 	strd	sl, fp, [sp, #136]	; 0x88
}
    aba0:	b011      	add	sp, #68	; 0x44
    aba2:	ecbd 8b08 	vpop	{d8-d11}
    aba6:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    return _etoa(out, buffer, idx, maxlen, value, prec, width, flags);
    abaa:	4760      	bx	ip
  if (value < 0) {
    abac:	2200      	movs	r2, #0
    abae:	2300      	movs	r3, #0
    abb0:	4650      	mov	r0, sl
    abb2:	4659      	mov	r1, fp
    abb4:	47a0      	blx	r4
    abb6:	2800      	cmp	r0, #0
    abb8:	f000 808a 	beq.w	acd0 <_ftoa+0x218>
    value = 0 - value;
    abbc:	465b      	mov	r3, fp
    abbe:	4652      	mov	r2, sl
    abc0:	4c7a      	ldr	r4, [pc, #488]	; (adac <_ftoa+0x2f4>)
    abc2:	2000      	movs	r0, #0
    abc4:	2100      	movs	r1, #0
    abc6:	47a0      	blx	r4
    negative = true;
    abc8:	2301      	movs	r3, #1
    value = 0 - value;
    abca:	4682      	mov	sl, r0
    abcc:	468b      	mov	fp, r1
    negative = true;
    abce:	9307      	str	r3, [sp, #28]
    prec = PRINTF_DEFAULT_FLOAT_PRECISION;
    abd0:	f416 6f80 	tst.w	r6, #1024	; 0x400
    abd4:	bf08      	it	eq
    abd6:	2506      	moveq	r5, #6
    abd8:	ab08      	add	r3, sp, #32
    abda:	f1a5 0220 	sub.w	r2, r5, #32
    abde:	9505      	str	r5, [sp, #20]
    buf[len++] = '0';
    abe0:	2130      	movs	r1, #48	; 0x30
    abe2:	9805      	ldr	r0, [sp, #20]
  while ((len < PRINTF_FTOA_BUFFER_SIZE) && (prec > 9U)) {
    abe4:	2809      	cmp	r0, #9
    abe6:	eba5 0400 	sub.w	r4, r5, r0
    abea:	d907      	bls.n	abfc <_ftoa+0x144>
    prec--;
    abec:	9805      	ldr	r0, [sp, #20]
    buf[len++] = '0';
    abee:	f803 1b01 	strb.w	r1, [r3], #1
    prec--;
    abf2:	3801      	subs	r0, #1
  while ((len < PRINTF_FTOA_BUFFER_SIZE) && (prec > 9U)) {
    abf4:	4282      	cmp	r2, r0
    prec--;
    abf6:	9005      	str	r0, [sp, #20]
  while ((len < PRINTF_FTOA_BUFFER_SIZE) && (prec > 9U)) {
    abf8:	d1f3      	bne.n	abe2 <_ftoa+0x12a>
    abfa:	2420      	movs	r4, #32
  int whole = (int)value;
    abfc:	4b6c      	ldr	r3, [pc, #432]	; (adb0 <_ftoa+0x2f8>)
  double tmp = (value - whole) * pow10[prec];
    abfe:	f8df 91ac 	ldr.w	r9, [pc, #428]	; adac <_ftoa+0x2f4>
    ac02:	f8df 81c8 	ldr.w	r8, [pc, #456]	; adcc <_ftoa+0x314>
  int whole = (int)value;
    ac06:	4659      	mov	r1, fp
    ac08:	4650      	mov	r0, sl
    ac0a:	4798      	blx	r3
  double tmp = (value - whole) * pow10[prec];
    ac0c:	9a05      	ldr	r2, [sp, #20]
    ac0e:	4b69      	ldr	r3, [pc, #420]	; (adb4 <_ftoa+0x2fc>)
    ac10:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
    ac14:	ed93 7b00 	vldr	d7, [r3]
    ac18:	4b67      	ldr	r3, [pc, #412]	; (adb8 <_ftoa+0x300>)
    ac1a:	eeb0 aa47 	vmov.f32	s20, s14
    ac1e:	eef0 aa67 	vmov.f32	s21, s15
  int whole = (int)value;
    ac22:	4605      	mov	r5, r0
  double tmp = (value - whole) * pow10[prec];
    ac24:	4798      	blx	r3
    ac26:	4602      	mov	r2, r0
    ac28:	460b      	mov	r3, r1
    ac2a:	4650      	mov	r0, sl
    ac2c:	4659      	mov	r1, fp
    ac2e:	47c8      	blx	r9
    ac30:	ec53 2b1a 	vmov	r2, r3, d10
    ac34:	47c0      	blx	r8
    ac36:	4602      	mov	r2, r0
    ac38:	460b      	mov	r3, r1
    ac3a:	ec43 2b1b 	vmov	d11, r2, r3
  unsigned long frac = (unsigned long)tmp;
    ac3e:	4b5f      	ldr	r3, [pc, #380]	; (adbc <_ftoa+0x304>)
    ac40:	4798      	blx	r3
  diff = tmp - frac;
    ac42:	4b5f      	ldr	r3, [pc, #380]	; (adc0 <_ftoa+0x308>)
  unsigned long frac = (unsigned long)tmp;
    ac44:	4680      	mov	r8, r0
  diff = tmp - frac;
    ac46:	4798      	blx	r3
    ac48:	4602      	mov	r2, r0
    ac4a:	460b      	mov	r3, r1
    ac4c:	ec51 0b1b 	vmov	r0, r1, d11
    ac50:	47c8      	blx	r9
    ac52:	4602      	mov	r2, r0
    ac54:	460b      	mov	r3, r1
    ac56:	ec43 2b1b 	vmov	d11, r2, r3
  if (diff > 0.5) {
    ac5a:	f8df 916c 	ldr.w	r9, [pc, #364]	; adc8 <_ftoa+0x310>
    ac5e:	4b59      	ldr	r3, [pc, #356]	; (adc4 <_ftoa+0x30c>)
    ac60:	2200      	movs	r2, #0
    ac62:	47c8      	blx	r9
    ac64:	2800      	cmp	r0, #0
    ac66:	d035      	beq.n	acd4 <_ftoa+0x21c>
    ++frac;
    ac68:	f108 0801 	add.w	r8, r8, #1
    if (frac >= pow10[prec]) {
    ac6c:	4b54      	ldr	r3, [pc, #336]	; (adc0 <_ftoa+0x308>)
    ac6e:	f8df 9160 	ldr.w	r9, [pc, #352]	; add0 <_ftoa+0x318>
    ac72:	4640      	mov	r0, r8
    ac74:	4798      	blx	r3
    ac76:	4602      	mov	r2, r0
    ac78:	460b      	mov	r3, r1
    ac7a:	ec51 0b1a 	vmov	r0, r1, d10
    ac7e:	47c8      	blx	r9
    ac80:	b110      	cbz	r0, ac88 <_ftoa+0x1d0>
      ++whole;
    ac82:	3501      	adds	r5, #1
      frac = 0;
    ac84:	f04f 0800 	mov.w	r8, #0
  if (prec == 0U) {
    ac88:	9b05      	ldr	r3, [sp, #20]
    ac8a:	2b00      	cmp	r3, #0
    ac8c:	d157      	bne.n	ad3e <_ftoa+0x286>
    diff = value - (double)whole;
    ac8e:	4b4a      	ldr	r3, [pc, #296]	; (adb8 <_ftoa+0x300>)
    ac90:	f8df 8118 	ldr.w	r8, [pc, #280]	; adac <_ftoa+0x2f4>
    ac94:	4628      	mov	r0, r5
    ac96:	4798      	blx	r3
    ac98:	4602      	mov	r2, r0
    ac9a:	460b      	mov	r3, r1
    ac9c:	4650      	mov	r0, sl
    ac9e:	4659      	mov	r1, fp
    aca0:	47c0      	blx	r8
    if ((!(diff < 0.5) || (diff > 0.5)) && (whole & 1)) {
    aca2:	f8df b0f0 	ldr.w	fp, [pc, #240]	; ad94 <_ftoa+0x2dc>
    aca6:	4b47      	ldr	r3, [pc, #284]	; (adc4 <_ftoa+0x30c>)
    aca8:	2200      	movs	r2, #0
    diff = value - (double)whole;
    acaa:	4680      	mov	r8, r0
    acac:	4689      	mov	r9, r1
    if ((!(diff < 0.5) || (diff > 0.5)) && (whole & 1)) {
    acae:	47d8      	blx	fp
    acb0:	b138      	cbz	r0, acc2 <_ftoa+0x20a>
    acb2:	4640      	mov	r0, r8
    acb4:	4b43      	ldr	r3, [pc, #268]	; (adc4 <_ftoa+0x30c>)
    acb6:	f8df 8110 	ldr.w	r8, [pc, #272]	; adc8 <_ftoa+0x310>
    acba:	2200      	movs	r2, #0
    acbc:	4649      	mov	r1, r9
    acbe:	47c0      	blx	r8
    acc0:	b110      	cbz	r0, acc8 <_ftoa+0x210>
    acc2:	07e8      	lsls	r0, r5, #31
    acc4:	d500      	bpl.n	acc8 <_ftoa+0x210>
      ++whole;
    acc6:	3501      	adds	r5, #1
    acc8:	ab08      	add	r3, sp, #32
    acca:	4423      	add	r3, r4
    buf[len++] = (char)(48 + (whole % 10));
    accc:	220a      	movs	r2, #10
    acce:	e08c      	b.n	adea <_ftoa+0x332>
  bool negative = false;
    acd0:	9007      	str	r0, [sp, #28]
    acd2:	e77d      	b.n	abd0 <_ftoa+0x118>
  else if (diff < 0.5) {
    acd4:	4b3b      	ldr	r3, [pc, #236]	; (adc4 <_ftoa+0x30c>)
    acd6:	f8df 90bc 	ldr.w	r9, [pc, #188]	; ad94 <_ftoa+0x2dc>
    acda:	ec51 0b1b 	vmov	r0, r1, d11
    acde:	2200      	movs	r2, #0
    ace0:	47c8      	blx	r9
    ace2:	2800      	cmp	r0, #0
    ace4:	d1d0      	bne.n	ac88 <_ftoa+0x1d0>
  else if ((frac == 0U) || (frac & 1U)) {
    ace6:	f1b8 0f00 	cmp.w	r8, #0
    acea:	d002      	beq.n	acf2 <_ftoa+0x23a>
    acec:	f018 0f01 	tst.w	r8, #1
    acf0:	d0ca      	beq.n	ac88 <_ftoa+0x1d0>
    ++frac;
    acf2:	f108 0801 	add.w	r8, r8, #1
    acf6:	e7c7      	b.n	ac88 <_ftoa+0x1d0>
      --count;
    acf8:	9a05      	ldr	r2, [sp, #20]
      buf[len++] = (char)(48U + (frac % 10U));
    acfa:	fbb8 f0f1 	udiv	r0, r8, r1
      --count;
    acfe:	3a01      	subs	r2, #1
    ad00:	9205      	str	r2, [sp, #20]
      buf[len++] = (char)(48U + (frac % 10U));
    ad02:	fb01 8210 	mls	r2, r1, r0, r8
    ad06:	3230      	adds	r2, #48	; 0x30
      if (!(frac /= 10U)) {
    ad08:	f1b8 0f09 	cmp.w	r8, #9
      buf[len++] = (char)(48U + (frac % 10U));
    ad0c:	f803 2b01 	strb.w	r2, [r3], #1
    ad10:	f104 0401 	add.w	r4, r4, #1
      if (!(frac /= 10U)) {
    ad14:	d82a      	bhi.n	ad6c <_ftoa+0x2b4>
    ad16:	9b05      	ldr	r3, [sp, #20]
    ad18:	4423      	add	r3, r4
    ad1a:	469b      	mov	fp, r3
      buf[len++] = '0';
    ad1c:	aa08      	add	r2, sp, #32
    ad1e:	2130      	movs	r1, #48	; 0x30
    while ((len < PRINTF_FTOA_BUFFER_SIZE) && (count-- > 0U)) {
    ad20:	2c20      	cmp	r4, #32
    ad22:	d011      	beq.n	ad48 <_ftoa+0x290>
    ad24:	455c      	cmp	r4, fp
    ad26:	f104 0301 	add.w	r3, r4, #1
    ad2a:	d121      	bne.n	ad70 <_ftoa+0x2b8>
      buf[len++] = '.';
    ad2c:	f104 0240 	add.w	r2, r4, #64	; 0x40
    ad30:	eb0d 0402 	add.w	r4, sp, r2
    ad34:	222e      	movs	r2, #46	; 0x2e
    ad36:	f804 2c20 	strb.w	r2, [r4, #-32]
    ad3a:	461c      	mov	r4, r3
    ad3c:	e7c4      	b.n	acc8 <_ftoa+0x210>
    ad3e:	ab08      	add	r3, sp, #32
    ad40:	4423      	add	r3, r4
      buf[len++] = (char)(48U + (frac % 10U));
    ad42:	210a      	movs	r1, #10
    while (len < PRINTF_FTOA_BUFFER_SIZE) {
    ad44:	2c20      	cmp	r4, #32
    ad46:	d1d7      	bne.n	acf8 <_ftoa+0x240>
  if (!(flags & FLAGS_LEFT) && (flags & FLAGS_ZEROPAD)) {
    ad48:	f006 0303 	and.w	r3, r6, #3
    ad4c:	2b01      	cmp	r3, #1
    ad4e:	ab08      	add	r3, sp, #32
    ad50:	d168      	bne.n	ae24 <_ftoa+0x36c>
    if (width && (negative || (flags & (FLAGS_PLUS | FLAGS_SPACE)))) {
    ad52:	9a06      	ldr	r2, [sp, #24]
    ad54:	2a00      	cmp	r2, #0
    ad56:	d065      	beq.n	ae24 <_ftoa+0x36c>
    ad58:	9a07      	ldr	r2, [sp, #28]
    ad5a:	b912      	cbnz	r2, ad62 <_ftoa+0x2aa>
    ad5c:	f016 0f0c 	tst.w	r6, #12
    ad60:	d002      	beq.n	ad68 <_ftoa+0x2b0>
      width--;
    ad62:	9a06      	ldr	r2, [sp, #24]
    ad64:	3a01      	subs	r2, #1
    ad66:	9206      	str	r2, [sp, #24]
      buf[len++] = '0';
    ad68:	2230      	movs	r2, #48	; 0x30
    ad6a:	e043      	b.n	adf4 <_ftoa+0x33c>
      if (!(frac /= 10U)) {
    ad6c:	4680      	mov	r8, r0
    ad6e:	e7e9      	b.n	ad44 <_ftoa+0x28c>
      buf[len++] = '0';
    ad70:	54a1      	strb	r1, [r4, r2]
    ad72:	461c      	mov	r4, r3
    ad74:	e7d4      	b.n	ad20 <_ftoa+0x268>
    ad76:	bf00      	nop
    ad78:	00000000 	.word	0x00000000
    ad7c:	41cdcd65 	.word	0x41cdcd65
    ad80:	00000000 	.word	0x00000000
    ad84:	c1cdcd65 	.word	0xc1cdcd65
    ad88:	0000bc1d 	.word	0x0000bc1d
    ad8c:	0000cd28 	.word	0x0000cd28
    ad90:	0000a3c7 	.word	0x0000a3c7
    ad94:	0000bc31 	.word	0x0000bc31
    ad98:	0000cd2c 	.word	0x0000cd2c
    ad9c:	7fefffff 	.word	0x7fefffff
    ada0:	0000cd23 	.word	0x0000cd23
    ada4:	0000cd1f 	.word	0x0000cd1f
    ada8:	0000a6b1 	.word	0x0000a6b1
    adac:	0000b3dd 	.word	0x0000b3dd
    adb0:	0000bc81 	.word	0x0000bc81
    adb4:	0000cd38 	.word	0x0000cd38
    adb8:	0000b679 	.word	0x0000b679
    adbc:	0000bcd1 	.word	0x0000bcd1
    adc0:	0000b659 	.word	0x0000b659
    adc4:	3fe00000 	.word	0x3fe00000
    adc8:	0000bc6d 	.word	0x0000bc6d
    adcc:	0000b74d 	.word	0x0000b74d
    add0:	0000bc45 	.word	0x0000bc45
    buf[len++] = (char)(48 + (whole % 10));
    add4:	fb95 f1f2 	sdiv	r1, r5, r2
    add8:	fb02 5011 	mls	r0, r2, r1, r5
    addc:	3030      	adds	r0, #48	; 0x30
    adde:	f803 0b01 	strb.w	r0, [r3], #1
    ade2:	3401      	adds	r4, #1
    if (!(whole /= 10)) {
    ade4:	460d      	mov	r5, r1
    ade6:	2900      	cmp	r1, #0
    ade8:	d0ae      	beq.n	ad48 <_ftoa+0x290>
  while (len < PRINTF_FTOA_BUFFER_SIZE) {
    adea:	2c20      	cmp	r4, #32
    adec:	d1f2      	bne.n	add4 <_ftoa+0x31c>
    adee:	e7ab      	b.n	ad48 <_ftoa+0x290>
      buf[len++] = '0';
    adf0:	551a      	strb	r2, [r3, r4]
    adf2:	3401      	adds	r4, #1
    while ((len < width) && (len < PRINTF_FTOA_BUFFER_SIZE)) {
    adf4:	9906      	ldr	r1, [sp, #24]
    adf6:	42a1      	cmp	r1, r4
    adf8:	d914      	bls.n	ae24 <_ftoa+0x36c>
    adfa:	2c20      	cmp	r4, #32
    adfc:	d1f8      	bne.n	adf0 <_ftoa+0x338>
  return _out_rev(out, buffer, idx, maxlen, buf, len, width, flags);
    adfe:	9a06      	ldr	r2, [sp, #24]
    ae00:	9300      	str	r3, [sp, #0]
    ae02:	e9cd 4201 	strd	r4, r2, [sp, #4]
    ae06:	ee19 3a10 	vmov	r3, s18
    ae0a:	ee18 1a90 	vmov	r1, s17
    ae0e:	ee18 0a10 	vmov	r0, s16
    ae12:	4c11      	ldr	r4, [pc, #68]	; (ae58 <_ftoa+0x3a0>)
    ae14:	9603      	str	r6, [sp, #12]
    ae16:	463a      	mov	r2, r7
    ae18:	47a0      	blx	r4
}
    ae1a:	b011      	add	sp, #68	; 0x44
    ae1c:	ecbd 8b08 	vpop	{d8-d11}
    ae20:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  if (len < PRINTF_FTOA_BUFFER_SIZE) {
    ae24:	2c20      	cmp	r4, #32
    ae26:	d0ea      	beq.n	adfe <_ftoa+0x346>
    if (negative) {
    ae28:	9a07      	ldr	r2, [sp, #28]
    ae2a:	b13a      	cbz	r2, ae3c <_ftoa+0x384>
      buf[len++] = '-';
    ae2c:	f104 0240 	add.w	r2, r4, #64	; 0x40
    ae30:	446a      	add	r2, sp
    ae32:	212d      	movs	r1, #45	; 0x2d
      buf[len++] = ' ';
    ae34:	f802 1c20 	strb.w	r1, [r2, #-32]
    ae38:	3401      	adds	r4, #1
    ae3a:	e7e0      	b.n	adfe <_ftoa+0x346>
    else if (flags & FLAGS_PLUS) {
    ae3c:	0771      	lsls	r1, r6, #29
    ae3e:	d504      	bpl.n	ae4a <_ftoa+0x392>
      buf[len++] = '+';  // ignore the space if the '+' exists
    ae40:	f104 0240 	add.w	r2, r4, #64	; 0x40
    ae44:	446a      	add	r2, sp
    ae46:	212b      	movs	r1, #43	; 0x2b
    ae48:	e7f4      	b.n	ae34 <_ftoa+0x37c>
    else if (flags & FLAGS_SPACE) {
    ae4a:	0732      	lsls	r2, r6, #28
    ae4c:	d5d7      	bpl.n	adfe <_ftoa+0x346>
      buf[len++] = ' ';
    ae4e:	f104 0240 	add.w	r2, r4, #64	; 0x40
    ae52:	446a      	add	r2, sp
    ae54:	2120      	movs	r1, #32
    ae56:	e7ed      	b.n	ae34 <_ftoa+0x37c>
    ae58:	0000a3c7 	.word	0x0000a3c7

0000ae5c <_out_char>:
  if (character) {
    ae5c:	b108      	cbz	r0, ae62 <_out_char+0x6>
    _putchar(character);
    ae5e:	4b01      	ldr	r3, [pc, #4]	; (ae64 <_out_char+0x8>)
    ae60:	4718      	bx	r3
}
    ae62:	4770      	bx	lr
    ae64:	0000b3c9 	.word	0x0000b3c9

0000ae68 <_vsnprintf>:
#endif  // PRINTF_SUPPORT_FLOAT


// internal vsnprintf
static int _vsnprintf(out_fct_type out, char* buffer, const size_t maxlen, const char* format, va_list va)
{
    ae68:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    ae6c:	b091      	sub	sp, #68	; 0x44
  unsigned int flags, width, precision, n;
  size_t idx = 0U;

  if (!buffer) {
    // use null output function
    out = _out_null;
    ae6e:	2900      	cmp	r1, #0
{
    ae70:	930a      	str	r3, [sp, #40]	; 0x28
    out = _out_null;
    ae72:	4bb6      	ldr	r3, [pc, #728]	; (b14c <_vsnprintf+0x2e4>)
    ae74:	9f1a      	ldr	r7, [sp, #104]	; 0x68
{
    ae76:	4691      	mov	r9, r2
    out = _out_null;
    ae78:	bf14      	ite	ne
    ae7a:	4682      	movne	sl, r0
    ae7c:	469a      	moveq	sl, r3
        out('%', buffer, idx++, maxlen);
        format++;
        break;

      default :
        out(*format, buffer, idx++, maxlen);
    ae7e:	2500      	movs	r5, #0
  while (*format)
    ae80:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    ae82:	7818      	ldrb	r0, [r3, #0]
    ae84:	b958      	cbnz	r0, ae9e <_vsnprintf+0x36>
        break;
    }
  }

  // termination
  out((char)0, buffer, idx < maxlen ? idx : maxlen - 1U, maxlen);
    ae86:	454d      	cmp	r5, r9
    ae88:	bf2c      	ite	cs
    ae8a:	f109 32ff 	addcs.w	r2, r9, #4294967295	; 0xffffffff
    ae8e:	462a      	movcc	r2, r5
    ae90:	464b      	mov	r3, r9
    ae92:	2000      	movs	r0, #0
    ae94:	47d0      	blx	sl

  // return written chars without terminating \0
  return (int)idx;
}
    ae96:	4628      	mov	r0, r5
    ae98:	b011      	add	sp, #68	; 0x44
    ae9a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
      format++;
    ae9e:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    if (*format != '%') {
    aea0:	2825      	cmp	r0, #37	; 0x25
      format++;
    aea2:	f103 0301 	add.w	r3, r3, #1
    aea6:	930a      	str	r3, [sp, #40]	; 0x28
    if (*format != '%') {
    aea8:	d006      	beq.n	aeb8 <_vsnprintf+0x50>
        out(*format, buffer, idx++, maxlen);
    aeaa:	462a      	mov	r2, r5
    aeac:	1c6c      	adds	r4, r5, #1
    aeae:	464b      	mov	r3, r9
    aeb0:	910b      	str	r1, [sp, #44]	; 0x2c
    aeb2:	47d0      	blx	sl
    aeb4:	4625      	mov	r5, r4
    aeb6:	e1af      	b.n	b218 <_vsnprintf+0x3b0>
    flags = 0U;
    aeb8:	2400      	movs	r4, #0
    aeba:	e006      	b.n	aeca <_vsnprintf+0x62>
      switch (*format) {
    aebc:	2b2d      	cmp	r3, #45	; 0x2d
    aebe:	d016      	beq.n	aeee <_vsnprintf+0x86>
    aec0:	2b30      	cmp	r3, #48	; 0x30
    aec2:	d10c      	bne.n	aede <_vsnprintf+0x76>
        case '0': flags |= FLAGS_ZEROPAD; format++; n = 1U; break;
    aec4:	f044 0401 	orr.w	r4, r4, #1
      format++;
    aec8:	920a      	str	r2, [sp, #40]	; 0x28
      switch (*format) {
    aeca:	9a0a      	ldr	r2, [sp, #40]	; 0x28
    aecc:	f812 3b01 	ldrb.w	r3, [r2], #1
    aed0:	2b2b      	cmp	r3, #43	; 0x2b
    aed2:	d00f      	beq.n	aef4 <_vsnprintf+0x8c>
    aed4:	d8f2      	bhi.n	aebc <_vsnprintf+0x54>
    aed6:	2b20      	cmp	r3, #32
    aed8:	d00f      	beq.n	aefa <_vsnprintf+0x92>
    aeda:	2b23      	cmp	r3, #35	; 0x23
    aedc:	d010      	beq.n	af00 <_vsnprintf+0x98>
    if (_is_digit(*format)) {
    aede:	f1a3 0030 	sub.w	r0, r3, #48	; 0x30
    aee2:	2809      	cmp	r0, #9
    aee4:	d82c      	bhi.n	af40 <_vsnprintf+0xd8>
  unsigned int i = 0U;
    aee6:	f04f 0800 	mov.w	r8, #0
    i = i * 10U + (unsigned int)(*((*str)++) - '0');
    aeea:	200a      	movs	r0, #10
    aeec:	e010      	b.n	af10 <_vsnprintf+0xa8>
        case '-': flags |= FLAGS_LEFT;    format++; n = 1U; break;
    aeee:	f044 0402 	orr.w	r4, r4, #2
    } while (n);
    aef2:	e7e9      	b.n	aec8 <_vsnprintf+0x60>
        case '+': flags |= FLAGS_PLUS;    format++; n = 1U; break;
    aef4:	f044 0404 	orr.w	r4, r4, #4
    } while (n);
    aef8:	e7e6      	b.n	aec8 <_vsnprintf+0x60>
        case ' ': flags |= FLAGS_SPACE;   format++; n = 1U; break;
    aefa:	f044 0408 	orr.w	r4, r4, #8
    } while (n);
    aefe:	e7e3      	b.n	aec8 <_vsnprintf+0x60>
        case '#': flags |= FLAGS_HASH;    format++; n = 1U; break;
    af00:	f044 0410 	orr.w	r4, r4, #16
    } while (n);
    af04:	e7e0      	b.n	aec8 <_vsnprintf+0x60>
    i = i * 10U + (unsigned int)(*((*str)++) - '0');
    af06:	fb00 3808 	mla	r8, r0, r8, r3
    af0a:	f1a8 0830 	sub.w	r8, r8, #48	; 0x30
    af0e:	920a      	str	r2, [sp, #40]	; 0x28
  while (_is_digit(**str)) {
    af10:	9a0a      	ldr	r2, [sp, #40]	; 0x28
    af12:	f812 3b01 	ldrb.w	r3, [r2], #1
    af16:	f1a3 0630 	sub.w	r6, r3, #48	; 0x30
    af1a:	2e09      	cmp	r6, #9
    af1c:	d9f3      	bls.n	af06 <_vsnprintf+0x9e>
    if (*format == '.') {
    af1e:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    af20:	781b      	ldrb	r3, [r3, #0]
    af22:	2b2e      	cmp	r3, #46	; 0x2e
    af24:	d168      	bne.n	aff8 <_vsnprintf+0x190>
      format++;
    af26:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    af28:	1c5a      	adds	r2, r3, #1
      if (_is_digit(*format)) {
    af2a:	785b      	ldrb	r3, [r3, #1]
    af2c:	f1a3 0030 	sub.w	r0, r3, #48	; 0x30
    af30:	2809      	cmp	r0, #9
      flags |= FLAGS_PRECISION;
    af32:	f444 6480 	orr.w	r4, r4, #1024	; 0x400
      if (_is_digit(*format)) {
    af36:	d856      	bhi.n	afe6 <_vsnprintf+0x17e>
  unsigned int i = 0U;
    af38:	2600      	movs	r6, #0
    i = i * 10U + (unsigned int)(*((*str)++) - '0');
    af3a:	f04f 0e0a 	mov.w	lr, #10
    af3e:	e013      	b.n	af68 <_vsnprintf+0x100>
    else if (*format == '*') {
    af40:	2b2a      	cmp	r3, #42	; 0x2a
    af42:	d10a      	bne.n	af5a <_vsnprintf+0xf2>
      const int w = va_arg(va, int);
    af44:	f857 8b04 	ldr.w	r8, [r7], #4
    af48:	920a      	str	r2, [sp, #40]	; 0x28
      if (w < 0) {
    af4a:	f1b8 0f00 	cmp.w	r8, #0
        flags |= FLAGS_LEFT;    // reverse padding
    af4e:	bfbc      	itt	lt
    af50:	f044 0402 	orrlt.w	r4, r4, #2
        width = (unsigned int)-w;
    af54:	f1c8 0800 	rsblt	r8, r8, #0
      format++;
    af58:	e7e1      	b.n	af1e <_vsnprintf+0xb6>
    width = 0U;
    af5a:	f04f 0800 	mov.w	r8, #0
    af5e:	e7de      	b.n	af1e <_vsnprintf+0xb6>
    i = i * 10U + (unsigned int)(*((*str)++) - '0');
    af60:	fb0e 3606 	mla	r6, lr, r6, r3
    af64:	3e30      	subs	r6, #48	; 0x30
    af66:	4602      	mov	r2, r0
  while (_is_digit(**str)) {
    af68:	4610      	mov	r0, r2
    af6a:	f810 3b01 	ldrb.w	r3, [r0], #1
    af6e:	f1a3 0c30 	sub.w	ip, r3, #48	; 0x30
    af72:	f1bc 0f09 	cmp.w	ip, #9
    af76:	d9f3      	bls.n	af60 <_vsnprintf+0xf8>
    switch (*format) {
    af78:	4613      	mov	r3, r2
    af7a:	f813 0b01 	ldrb.w	r0, [r3], #1
    af7e:	286c      	cmp	r0, #108	; 0x6c
    af80:	d044      	beq.n	b00c <_vsnprintf+0x1a4>
    af82:	d83c      	bhi.n	affe <_vsnprintf+0x196>
    af84:	2868      	cmp	r0, #104	; 0x68
    af86:	d048      	beq.n	b01a <_vsnprintf+0x1b2>
    af88:	286a      	cmp	r0, #106	; 0x6a
    af8a:	d04f      	beq.n	b02c <_vsnprintf+0x1c4>
    af8c:	4613      	mov	r3, r2
    switch (*format) {
    af8e:	f813 0b01 	ldrb.w	r0, [r3], #1
    af92:	930a      	str	r3, [sp, #40]	; 0x28
    af94:	2878      	cmp	r0, #120	; 0x78
    af96:	d888      	bhi.n	aeaa <_vsnprintf+0x42>
    af98:	2857      	cmp	r0, #87	; 0x57
    af9a:	d84a      	bhi.n	b032 <_vsnprintf+0x1ca>
    af9c:	2845      	cmp	r0, #69	; 0x45
    af9e:	d006      	beq.n	afae <_vsnprintf+0x146>
    afa0:	d983      	bls.n	aeaa <_vsnprintf+0x42>
    afa2:	2846      	cmp	r0, #70	; 0x46
    afa4:	f000 8125 	beq.w	b1f2 <_vsnprintf+0x38a>
    afa8:	2847      	cmp	r0, #71	; 0x47
    afaa:	f47f af7e 	bne.w	aeaa <_vsnprintf+0x42>
        if ((*format == 'g')||(*format == 'G')) flags |= FLAGS_ADAPT_EXP;
    afae:	f000 03df 	and.w	r3, r0, #223	; 0xdf
    afb2:	2b47      	cmp	r3, #71	; 0x47
        if ((*format == 'E')||(*format == 'G')) flags |= FLAGS_UPPERCASE;
    afb4:	bf04      	itt	eq
    afb6:	f000 00fd 	andeq.w	r0, r0, #253	; 0xfd
        if ((*format == 'g')||(*format == 'G')) flags |= FLAGS_ADAPT_EXP;
    afba:	f444 6400 	orreq.w	r4, r4, #2048	; 0x800
        if ((*format == 'E')||(*format == 'G')) flags |= FLAGS_UPPERCASE;
    afbe:	2845      	cmp	r0, #69	; 0x45
    afc0:	bf08      	it	eq
    afc2:	f044 0420 	orreq.w	r4, r4, #32
        idx = _etoa(out, buffer, idx, maxlen, va_arg(va, double), precision, width, flags);
    afc6:	e9cd 8403 	strd	r8, r4, [sp, #12]
    afca:	3707      	adds	r7, #7
    afcc:	f027 0707 	bic.w	r7, r7, #7
    afd0:	9602      	str	r6, [sp, #8]
    afd2:	e8f7 2302 	ldrd	r2, r3, [r7], #8
    afd6:	4c5e      	ldr	r4, [pc, #376]	; (b150 <_vsnprintf+0x2e8>)
    afd8:	910b      	str	r1, [sp, #44]	; 0x2c
    afda:	e9cd 2300 	strd	r2, r3, [sp]
    afde:	4650      	mov	r0, sl
    afe0:	464b      	mov	r3, r9
    afe2:	462a      	mov	r2, r5
    afe4:	e116      	b.n	b214 <_vsnprintf+0x3ac>
      else if (*format == '*') {
    afe6:	2b2a      	cmp	r3, #42	; 0x2a
    afe8:	d107      	bne.n	affa <_vsnprintf+0x192>
        precision = prec > 0 ? (unsigned int)prec : 0U;
    afea:	f857 6b04 	ldr.w	r6, [r7], #4
        format++;
    afee:	9a0a      	ldr	r2, [sp, #40]	; 0x28
        precision = prec > 0 ? (unsigned int)prec : 0U;
    aff0:	ea26 76e6 	bic.w	r6, r6, r6, asr #31
        format++;
    aff4:	3202      	adds	r2, #2
    aff6:	e7bf      	b.n	af78 <_vsnprintf+0x110>
    aff8:	9a0a      	ldr	r2, [sp, #40]	; 0x28
    precision = 0U;
    affa:	2600      	movs	r6, #0
    affc:	e7bc      	b.n	af78 <_vsnprintf+0x110>
    switch (*format) {
    affe:	2874      	cmp	r0, #116	; 0x74
    b000:	d001      	beq.n	b006 <_vsnprintf+0x19e>
    b002:	287a      	cmp	r0, #122	; 0x7a
    b004:	d1c2      	bne.n	af8c <_vsnprintf+0x124>
        flags |= (sizeof(size_t) == sizeof(long) ? FLAGS_LONG : FLAGS_LONG_LONG);
    b006:	f444 7480 	orr.w	r4, r4, #256	; 0x100
        break;
    b00a:	e7c0      	b.n	af8e <_vsnprintf+0x126>
        if (*format == 'l') {
    b00c:	7850      	ldrb	r0, [r2, #1]
    b00e:	286c      	cmp	r0, #108	; 0x6c
    b010:	d1f9      	bne.n	b006 <_vsnprintf+0x19e>
          flags |= FLAGS_LONG_LONG;
    b012:	f444 7440 	orr.w	r4, r4, #768	; 0x300
          format++;
    b016:	1c93      	adds	r3, r2, #2
    b018:	e7b9      	b.n	af8e <_vsnprintf+0x126>
        if (*format == 'h') {
    b01a:	7850      	ldrb	r0, [r2, #1]
    b01c:	2868      	cmp	r0, #104	; 0x68
    b01e:	d002      	beq.n	b026 <_vsnprintf+0x1be>
        flags |= FLAGS_SHORT;
    b020:	f044 0480 	orr.w	r4, r4, #128	; 0x80
    b024:	e7b3      	b.n	af8e <_vsnprintf+0x126>
          flags |= FLAGS_CHAR;
    b026:	f044 04c0 	orr.w	r4, r4, #192	; 0xc0
    b02a:	e7f4      	b.n	b016 <_vsnprintf+0x1ae>
        flags |= (sizeof(intmax_t) == sizeof(long) ? FLAGS_LONG : FLAGS_LONG_LONG);
    b02c:	f444 7400 	orr.w	r4, r4, #512	; 0x200
        break;
    b030:	e7ad      	b.n	af8e <_vsnprintf+0x126>
    switch (*format) {
    b032:	f1a0 0358 	sub.w	r3, r0, #88	; 0x58
    b036:	2b20      	cmp	r3, #32
    b038:	f63f af37 	bhi.w	aeaa <_vsnprintf+0x42>
    b03c:	a201      	add	r2, pc, #4	; (adr r2, b044 <_vsnprintf+0x1dc>)
    b03e:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
    b042:	bf00      	nop
    b044:	0000b0c9 	.word	0x0000b0c9
    b048:	0000aeab 	.word	0x0000aeab
    b04c:	0000aeab 	.word	0x0000aeab
    b050:	0000aeab 	.word	0x0000aeab
    b054:	0000aeab 	.word	0x0000aeab
    b058:	0000aeab 	.word	0x0000aeab
    b05c:	0000aeab 	.word	0x0000aeab
    b060:	0000aeab 	.word	0x0000aeab
    b064:	0000aeab 	.word	0x0000aeab
    b068:	0000aeab 	.word	0x0000aeab
    b06c:	0000b0c9 	.word	0x0000b0c9
    b070:	0000b21d 	.word	0x0000b21d
    b074:	0000b0c9 	.word	0x0000b0c9
    b078:	0000afaf 	.word	0x0000afaf
    b07c:	0000b1f7 	.word	0x0000b1f7
    b080:	0000afaf 	.word	0x0000afaf
    b084:	0000aeab 	.word	0x0000aeab
    b088:	0000b0c9 	.word	0x0000b0c9
    b08c:	0000aeab 	.word	0x0000aeab
    b090:	0000aeab 	.word	0x0000aeab
    b094:	0000aeab 	.word	0x0000aeab
    b098:	0000aeab 	.word	0x0000aeab
    b09c:	0000aeab 	.word	0x0000aeab
    b0a0:	0000b0c9 	.word	0x0000b0c9
    b0a4:	0000b355 	.word	0x0000b355
    b0a8:	0000aeab 	.word	0x0000aeab
    b0ac:	0000aeab 	.word	0x0000aeab
    b0b0:	0000b293 	.word	0x0000b293
    b0b4:	0000aeab 	.word	0x0000aeab
    b0b8:	0000b0c9 	.word	0x0000b0c9
    b0bc:	0000aeab 	.word	0x0000aeab
    b0c0:	0000aeab 	.word	0x0000aeab
    b0c4:	0000b0c9 	.word	0x0000b0c9
        if (*format == 'x' || *format == 'X') {
    b0c8:	2878      	cmp	r0, #120	; 0x78
    b0ca:	f000 8159 	beq.w	b380 <_vsnprintf+0x518>
    b0ce:	2858      	cmp	r0, #88	; 0x58
    b0d0:	f000 8154 	beq.w	b37c <_vsnprintf+0x514>
        else if (*format == 'o') {
    b0d4:	286f      	cmp	r0, #111	; 0x6f
    b0d6:	f000 8155 	beq.w	b384 <_vsnprintf+0x51c>
        else if (*format == 'b') {
    b0da:	2862      	cmp	r0, #98	; 0x62
    b0dc:	f000 8154 	beq.w	b388 <_vsnprintf+0x520>
        if ((*format != 'i') && (*format != 'd')) {
    b0e0:	2869      	cmp	r0, #105	; 0x69
          flags &= ~FLAGS_HASH;   // no hash for dec format
    b0e2:	f024 0410 	bic.w	r4, r4, #16
          base = 10U;
    b0e6:	f04f 030a 	mov.w	r3, #10
        if ((*format != 'i') && (*format != 'd')) {
    b0ea:	d003      	beq.n	b0f4 <_vsnprintf+0x28c>
    b0ec:	2864      	cmp	r0, #100	; 0x64
    b0ee:	d001      	beq.n	b0f4 <_vsnprintf+0x28c>
          flags &= ~(FLAGS_PLUS | FLAGS_SPACE);
    b0f0:	f024 040c 	bic.w	r4, r4, #12
        if (flags & FLAGS_PRECISION) {
    b0f4:	0562      	lsls	r2, r4, #21
          flags &= ~FLAGS_ZEROPAD;
    b0f6:	bf48      	it	mi
    b0f8:	f024 0401 	bicmi.w	r4, r4, #1
        if ((*format == 'i') || (*format == 'd')) {
    b0fc:	2869      	cmp	r0, #105	; 0x69
          if (flags & FLAGS_LONG_LONG) {
    b0fe:	f404 7200 	and.w	r2, r4, #512	; 0x200
        if ((*format == 'i') || (*format == 'd')) {
    b102:	d001      	beq.n	b108 <_vsnprintf+0x2a0>
    b104:	2864      	cmp	r0, #100	; 0x64
    b106:	d142      	bne.n	b18e <_vsnprintf+0x326>
          if (flags & FLAGS_LONG_LONG) {
    b108:	b332      	cbz	r2, b158 <_vsnprintf+0x2f0>
            const long long value = va_arg(va, long long);
    b10a:	3707      	adds	r7, #7
    b10c:	f027 0707 	bic.w	r7, r7, #7
    b110:	46bb      	mov	fp, r7
    b112:	6878      	ldr	r0, [r7, #4]
    b114:	f85b 2b08 	ldr.w	r2, [fp], #8
            idx = _ntoa_long_long(out, buffer, idx, maxlen, (unsigned long long)(value > 0 ? value : 0 - value), value < 0, base, precision, width, flags);
    b118:	9304      	str	r3, [sp, #16]
    b11a:	2300      	movs	r3, #0
    b11c:	9305      	str	r3, [sp, #20]
    b11e:	0fc3      	lsrs	r3, r0, #31
    b120:	2800      	cmp	r0, #0
    b122:	9302      	str	r3, [sp, #8]
    b124:	e9cd 8407 	strd	r8, r4, [sp, #28]
    b128:	9606      	str	r6, [sp, #24]
    b12a:	4613      	mov	r3, r2
    b12c:	da02      	bge.n	b134 <_vsnprintf+0x2cc>
    b12e:	4253      	negs	r3, r2
    b130:	eb60 0040 	sbc.w	r0, r0, r0, lsl #1
    b134:	e9cd 3000 	strd	r3, r0, [sp]
            idx = _ntoa_long_long(out, buffer, idx, maxlen, va_arg(va, unsigned long long), false, base, precision, width, flags);
    b138:	4c06      	ldr	r4, [pc, #24]	; (b154 <_vsnprintf+0x2ec>)
    b13a:	910b      	str	r1, [sp, #44]	; 0x2c
    b13c:	464b      	mov	r3, r9
    b13e:	462a      	mov	r2, r5
    b140:	4650      	mov	r0, sl
    b142:	47a0      	blx	r4
            idx = _ntoa_long(out, buffer, idx, maxlen, value, false, base, precision, width, flags);
    b144:	990b      	ldr	r1, [sp, #44]	; 0x2c
    b146:	4605      	mov	r5, r0
        break;
    b148:	465f      	mov	r7, fp
    b14a:	e699      	b.n	ae80 <_vsnprintf+0x18>
    b14c:	0000a3c5 	.word	0x0000a3c5
    b150:	0000a6b1 	.word	0x0000a6b1
    b154:	0000a5e5 	.word	0x0000a5e5
          else if (flags & FLAGS_LONG) {
    b158:	05e2      	lsls	r2, r4, #23
            idx = _ntoa_long(out, buffer, idx, maxlen, va_arg(va, unsigned long), false, base, precision, width, flags);
    b15a:	f107 0b04 	add.w	fp, r7, #4
          else if (flags & FLAGS_LONG) {
    b15e:	d50c      	bpl.n	b17a <_vsnprintf+0x312>
            const long value = va_arg(va, long);
    b160:	683a      	ldr	r2, [r7, #0]
            idx = _ntoa_long(out, buffer, idx, maxlen, (unsigned int)(value > 0 ? value : 0 - value), value < 0, base, precision, width, flags);
    b162:	e9cd 8404 	strd	r8, r4, [sp, #16]
    b166:	e9cd 3602 	strd	r3, r6, [sp, #8]
    b16a:	2a00      	cmp	r2, #0
    b16c:	ea4f 73d2 	mov.w	r3, r2, lsr #31
    b170:	9301      	str	r3, [sp, #4]
    b172:	bfb8      	it	lt
    b174:	4252      	neglt	r2, r2
            idx = _ntoa_long(out, buffer, idx, maxlen, value, false, base, precision, width, flags);
    b176:	9200      	str	r2, [sp, #0]
    b178:	e024      	b.n	b1c4 <_vsnprintf+0x35c>
            const int value = (flags & FLAGS_CHAR) ? (char)va_arg(va, int) : (flags & FLAGS_SHORT) ? (short int)va_arg(va, int) : va_arg(va, int);
    b17a:	f014 0f40 	tst.w	r4, #64	; 0x40
    b17e:	683a      	ldr	r2, [r7, #0]
    b180:	d001      	beq.n	b186 <_vsnprintf+0x31e>
    b182:	b2d2      	uxtb	r2, r2
    b184:	e7ed      	b.n	b162 <_vsnprintf+0x2fa>
    b186:	0627      	lsls	r7, r4, #24
    b188:	bf48      	it	mi
    b18a:	b212      	sxthmi	r2, r2
    b18c:	e7e9      	b.n	b162 <_vsnprintf+0x2fa>
          if (flags & FLAGS_LONG_LONG) {
    b18e:	b172      	cbz	r2, b1ae <_vsnprintf+0x346>
            idx = _ntoa_long_long(out, buffer, idx, maxlen, va_arg(va, unsigned long long), false, base, precision, width, flags);
    b190:	2200      	movs	r2, #0
    b192:	e9cd 8407 	strd	r8, r4, [sp, #28]
    b196:	e9cd 3204 	strd	r3, r2, [sp, #16]
    b19a:	3707      	adds	r7, #7
    b19c:	f027 0b07 	bic.w	fp, r7, #7
    b1a0:	9606      	str	r6, [sp, #24]
    b1a2:	9202      	str	r2, [sp, #8]
    b1a4:	e8fb 2302 	ldrd	r2, r3, [fp], #8
    b1a8:	e9cd 2300 	strd	r2, r3, [sp]
    b1ac:	e7c4      	b.n	b138 <_vsnprintf+0x2d0>
          else if (flags & FLAGS_LONG) {
    b1ae:	05e0      	lsls	r0, r4, #23
            idx = _ntoa_long(out, buffer, idx, maxlen, va_arg(va, unsigned long), false, base, precision, width, flags);
    b1b0:	f107 0b04 	add.w	fp, r7, #4
          else if (flags & FLAGS_LONG) {
    b1b4:	d50d      	bpl.n	b1d2 <_vsnprintf+0x36a>
            idx = _ntoa_long(out, buffer, idx, maxlen, va_arg(va, unsigned long), false, base, precision, width, flags);
    b1b6:	e9cd 8404 	strd	r8, r4, [sp, #16]
    b1ba:	e9cd 3602 	strd	r3, r6, [sp, #8]
    b1be:	9201      	str	r2, [sp, #4]
    b1c0:	683b      	ldr	r3, [r7, #0]
    b1c2:	9300      	str	r3, [sp, #0]
            idx = _ntoa_long(out, buffer, idx, maxlen, value, false, base, precision, width, flags);
    b1c4:	4c71      	ldr	r4, [pc, #452]	; (b38c <_vsnprintf+0x524>)
    b1c6:	910b      	str	r1, [sp, #44]	; 0x2c
    b1c8:	464b      	mov	r3, r9
    b1ca:	462a      	mov	r2, r5
    b1cc:	4650      	mov	r0, sl
    b1ce:	47a0      	blx	r4
    b1d0:	e7b8      	b.n	b144 <_vsnprintf+0x2dc>
            const unsigned int value = (flags & FLAGS_CHAR) ? (unsigned char)va_arg(va, unsigned int) : (flags & FLAGS_SHORT) ? (unsigned short int)va_arg(va, unsigned int) : va_arg(va, unsigned int);
    b1d2:	f014 0f40 	tst.w	r4, #64	; 0x40
    b1d6:	683a      	ldr	r2, [r7, #0]
    b1d8:	d007      	beq.n	b1ea <_vsnprintf+0x382>
    b1da:	b2d2      	uxtb	r2, r2
            idx = _ntoa_long(out, buffer, idx, maxlen, value, false, base, precision, width, flags);
    b1dc:	e9cd 3602 	strd	r3, r6, [sp, #8]
    b1e0:	2300      	movs	r3, #0
    b1e2:	e9cd 8404 	strd	r8, r4, [sp, #16]
    b1e6:	9301      	str	r3, [sp, #4]
    b1e8:	e7c5      	b.n	b176 <_vsnprintf+0x30e>
            const unsigned int value = (flags & FLAGS_CHAR) ? (unsigned char)va_arg(va, unsigned int) : (flags & FLAGS_SHORT) ? (unsigned short int)va_arg(va, unsigned int) : va_arg(va, unsigned int);
    b1ea:	0620      	lsls	r0, r4, #24
    b1ec:	bf48      	it	mi
    b1ee:	b292      	uxthmi	r2, r2
    b1f0:	e7f4      	b.n	b1dc <_vsnprintf+0x374>
        if (*format == 'F') flags |= FLAGS_UPPERCASE;
    b1f2:	f044 0420 	orr.w	r4, r4, #32
        idx = _ftoa(out, buffer, idx, maxlen, va_arg(va, double), precision, width, flags);
    b1f6:	e9cd 8403 	strd	r8, r4, [sp, #12]
    b1fa:	3707      	adds	r7, #7
    b1fc:	f027 0707 	bic.w	r7, r7, #7
    b200:	9602      	str	r6, [sp, #8]
    b202:	e8f7 2302 	ldrd	r2, r3, [r7], #8
    b206:	4c62      	ldr	r4, [pc, #392]	; (b390 <_vsnprintf+0x528>)
    b208:	910b      	str	r1, [sp, #44]	; 0x2c
    b20a:	e9cd 2300 	strd	r2, r3, [sp]
    b20e:	4650      	mov	r0, sl
    b210:	464b      	mov	r3, r9
    b212:	462a      	mov	r2, r5
        idx = _etoa(out, buffer, idx, maxlen, va_arg(va, double), precision, width, flags);
    b214:	47a0      	blx	r4
          idx = _ntoa_long(out, buffer, idx, maxlen, (unsigned long)((uintptr_t)va_arg(va, void*)), false, 16U, precision, width, flags);
    b216:	4605      	mov	r5, r0
        out(*format, buffer, idx++, maxlen);
    b218:	990b      	ldr	r1, [sp, #44]	; 0x2c
        break;
    b21a:	e631      	b.n	ae80 <_vsnprintf+0x18>
        if (!(flags & FLAGS_LEFT)) {
    b21c:	f014 0402 	ands.w	r4, r4, #2
    b220:	d023      	beq.n	b26a <_vsnprintf+0x402>
        unsigned int l = 1U;
    b222:	2601      	movs	r6, #1
        out((char)va_arg(va, int), buffer, idx++, maxlen);
    b224:	f857 0b04 	ldr.w	r0, [r7], #4
    b228:	910b      	str	r1, [sp, #44]	; 0x2c
    b22a:	464b      	mov	r3, r9
    b22c:	462a      	mov	r2, r5
    b22e:	b2c0      	uxtb	r0, r0
    b230:	47d0      	blx	sl
    b232:	f105 0b01 	add.w	fp, r5, #1
        if (flags & FLAGS_LEFT) {
    b236:	990b      	ldr	r1, [sp, #44]	; 0x2c
    b238:	b34c      	cbz	r4, b28e <_vsnprintf+0x426>
    b23a:	4634      	mov	r4, r6
        out((char)va_arg(va, int), buffer, idx++, maxlen);
    b23c:	465a      	mov	r2, fp
    b23e:	e01e      	b.n	b27e <_vsnprintf+0x416>
            out(' ', buffer, idx++, maxlen);
    b240:	910b      	str	r1, [sp, #44]	; 0x2c
    b242:	464b      	mov	r3, r9
    b244:	2020      	movs	r0, #32
    b246:	47d0      	blx	sl
    b248:	990b      	ldr	r1, [sp, #44]	; 0x2c
    b24a:	1972      	adds	r2, r6, r5
          while (l++ < width) {
    b24c:	3601      	adds	r6, #1
    b24e:	45b0      	cmp	r8, r6
    b250:	d8f6      	bhi.n	b240 <_vsnprintf+0x3d8>
    b252:	f1b8 0f00 	cmp.w	r8, #0
    b256:	f108 33ff 	add.w	r3, r8, #4294967295	; 0xffffffff
    b25a:	bf08      	it	eq
    b25c:	2300      	moveq	r3, #0
    b25e:	f108 0601 	add.w	r6, r8, #1
    b262:	441d      	add	r5, r3
    b264:	bf08      	it	eq
    b266:	2602      	moveq	r6, #2
    b268:	e7dc      	b.n	b224 <_vsnprintf+0x3bc>
    b26a:	4626      	mov	r6, r4
    b26c:	e7ed      	b.n	b24a <_vsnprintf+0x3e2>
            out(' ', buffer, idx++, maxlen);
    b26e:	910b      	str	r1, [sp, #44]	; 0x2c
    b270:	464b      	mov	r3, r9
    b272:	2020      	movs	r0, #32
    b274:	1c55      	adds	r5, r2, #1
    b276:	47d0      	blx	sl
    b278:	990b      	ldr	r1, [sp, #44]	; 0x2c
    b27a:	3401      	adds	r4, #1
    b27c:	462a      	mov	r2, r5
          while (l++ < width) {
    b27e:	4544      	cmp	r4, r8
    b280:	d3f5      	bcc.n	b26e <_vsnprintf+0x406>
    b282:	eba8 0306 	sub.w	r3, r8, r6
    b286:	45b0      	cmp	r8, r6
    b288:	bf38      	it	cc
    b28a:	2300      	movcc	r3, #0
    b28c:	449b      	add	fp, r3
        break;
    b28e:	465d      	mov	r5, fp
    b290:	e5f6      	b.n	ae80 <_vsnprintf+0x18>
        const char* p = va_arg(va, char*);
    b292:	463b      	mov	r3, r7
        unsigned int l = _strnlen_s(p, precision ? precision : (size_t)-1);
    b294:	2e00      	cmp	r6, #0
        const char* p = va_arg(va, char*);
    b296:	f853 bb04 	ldr.w	fp, [r3], #4
    b29a:	930b      	str	r3, [sp, #44]	; 0x2c
        unsigned int l = _strnlen_s(p, precision ? precision : (size_t)-1);
    b29c:	bf14      	ite	ne
    b29e:	4633      	movne	r3, r6
    b2a0:	f04f 33ff 	moveq.w	r3, #4294967295	; 0xffffffff
    b2a4:	445b      	add	r3, fp
    b2a6:	465f      	mov	r7, fp
  for (s = str; *s && maxsize--; ++s);
    b2a8:	783a      	ldrb	r2, [r7, #0]
    b2aa:	b10a      	cbz	r2, b2b0 <_vsnprintf+0x448>
    b2ac:	429f      	cmp	r7, r3
    b2ae:	d110      	bne.n	b2d2 <_vsnprintf+0x46a>
        if (flags & FLAGS_PRECISION) {
    b2b0:	f414 6380 	ands.w	r3, r4, #1024	; 0x400
  return (unsigned int)(s - str);
    b2b4:	eba7 070b 	sub.w	r7, r7, fp
        if (flags & FLAGS_PRECISION) {
    b2b8:	930c      	str	r3, [sp, #48]	; 0x30
    b2ba:	d002      	beq.n	b2c2 <_vsnprintf+0x45a>
          l = (l < precision ? l : precision);
    b2bc:	42b7      	cmp	r7, r6
    b2be:	bf28      	it	cs
    b2c0:	4637      	movcs	r7, r6
        if (!(flags & FLAGS_LEFT)) {
    b2c2:	f014 0302 	ands.w	r3, r4, #2
    b2c6:	930d      	str	r3, [sp, #52]	; 0x34
    b2c8:	d118      	bne.n	b2fc <_vsnprintf+0x494>
    b2ca:	1b7b      	subs	r3, r7, r5
    b2cc:	462a      	mov	r2, r5
    b2ce:	930e      	str	r3, [sp, #56]	; 0x38
    b2d0:	e008      	b.n	b2e4 <_vsnprintf+0x47c>
  for (s = str; *s && maxsize--; ++s);
    b2d2:	3701      	adds	r7, #1
    b2d4:	e7e8      	b.n	b2a8 <_vsnprintf+0x440>
            out(' ', buffer, idx++, maxlen);
    b2d6:	910f      	str	r1, [sp, #60]	; 0x3c
    b2d8:	464b      	mov	r3, r9
    b2da:	2020      	movs	r0, #32
    b2dc:	1c54      	adds	r4, r2, #1
    b2de:	47d0      	blx	sl
    b2e0:	990f      	ldr	r1, [sp, #60]	; 0x3c
    b2e2:	4622      	mov	r2, r4
          while (l++ < width) {
    b2e4:	9b0e      	ldr	r3, [sp, #56]	; 0x38
    b2e6:	18d3      	adds	r3, r2, r3
    b2e8:	4598      	cmp	r8, r3
    b2ea:	d8f4      	bhi.n	b2d6 <_vsnprintf+0x46e>
    b2ec:	eba8 0307 	sub.w	r3, r8, r7
    b2f0:	45b8      	cmp	r8, r7
    b2f2:	bf38      	it	cc
    b2f4:	2300      	movcc	r3, #0
    b2f6:	3701      	adds	r7, #1
    b2f8:	441d      	add	r5, r3
    b2fa:	441f      	add	r7, r3
    b2fc:	465c      	mov	r4, fp
    b2fe:	eba5 0b0b 	sub.w	fp, r5, fp
    b302:	e005      	b.n	b310 <_vsnprintf+0x4a8>
    b304:	461e      	mov	r6, r3
          out(*(p++), buffer, idx++, maxlen);
    b306:	910e      	str	r1, [sp, #56]	; 0x38
    b308:	464b      	mov	r3, r9
    b30a:	462a      	mov	r2, r5
    b30c:	47d0      	blx	sl
    b30e:	990e      	ldr	r1, [sp, #56]	; 0x38
    b310:	eb0b 0504 	add.w	r5, fp, r4
        while ((*p != 0) && (!(flags & FLAGS_PRECISION) || precision--)) {
    b314:	f814 0b01 	ldrb.w	r0, [r4], #1
    b318:	b128      	cbz	r0, b326 <_vsnprintf+0x4be>
    b31a:	9b0c      	ldr	r3, [sp, #48]	; 0x30
    b31c:	2b00      	cmp	r3, #0
    b31e:	d0f2      	beq.n	b306 <_vsnprintf+0x49e>
    b320:	1e73      	subs	r3, r6, #1
    b322:	2e00      	cmp	r6, #0
    b324:	d1ee      	bne.n	b304 <_vsnprintf+0x49c>
        if (flags & FLAGS_LEFT) {
    b326:	9b0d      	ldr	r3, [sp, #52]	; 0x34
    b328:	b193      	cbz	r3, b350 <_vsnprintf+0x4e8>
    b32a:	462a      	mov	r2, r5
    b32c:	1b7c      	subs	r4, r7, r5
    b32e:	e006      	b.n	b33e <_vsnprintf+0x4d6>
            out(' ', buffer, idx++, maxlen);
    b330:	910c      	str	r1, [sp, #48]	; 0x30
    b332:	464b      	mov	r3, r9
    b334:	2020      	movs	r0, #32
    b336:	1c56      	adds	r6, r2, #1
    b338:	47d0      	blx	sl
    b33a:	990c      	ldr	r1, [sp, #48]	; 0x30
    b33c:	4632      	mov	r2, r6
          while (l++ < width) {
    b33e:	1913      	adds	r3, r2, r4
    b340:	4543      	cmp	r3, r8
    b342:	d3f5      	bcc.n	b330 <_vsnprintf+0x4c8>
    b344:	eba8 0307 	sub.w	r3, r8, r7
    b348:	45b8      	cmp	r8, r7
    b34a:	bf38      	it	cc
    b34c:	2300      	movcc	r3, #0
    b34e:	441d      	add	r5, r3
        const char* p = va_arg(va, char*);
    b350:	9f0b      	ldr	r7, [sp, #44]	; 0x2c
        break;
    b352:	e595      	b.n	ae80 <_vsnprintf+0x18>
          idx = _ntoa_long(out, buffer, idx, maxlen, (unsigned long)((uintptr_t)va_arg(va, void*)), false, 16U, precision, width, flags);
    b354:	2308      	movs	r3, #8
    b356:	e9cd 6303 	strd	r6, r3, [sp, #12]
    b35a:	2210      	movs	r2, #16
    b35c:	2300      	movs	r3, #0
    b35e:	e9cd 3201 	strd	r3, r2, [sp, #4]
        flags |= FLAGS_ZEROPAD | FLAGS_UPPERCASE;
    b362:	f044 0421 	orr.w	r4, r4, #33	; 0x21
          idx = _ntoa_long(out, buffer, idx, maxlen, (unsigned long)((uintptr_t)va_arg(va, void*)), false, 16U, precision, width, flags);
    b366:	9405      	str	r4, [sp, #20]
    b368:	f857 3b04 	ldr.w	r3, [r7], #4
    b36c:	9300      	str	r3, [sp, #0]
    b36e:	4c07      	ldr	r4, [pc, #28]	; (b38c <_vsnprintf+0x524>)
    b370:	910b      	str	r1, [sp, #44]	; 0x2c
    b372:	464b      	mov	r3, r9
    b374:	462a      	mov	r2, r5
    b376:	4650      	mov	r0, sl
    b378:	47a0      	blx	r4
    b37a:	e74c      	b.n	b216 <_vsnprintf+0x3ae>
          flags |= FLAGS_UPPERCASE;
    b37c:	f044 0420 	orr.w	r4, r4, #32
          base = 16U;
    b380:	2310      	movs	r3, #16
    b382:	e6b5      	b.n	b0f0 <_vsnprintf+0x288>
          base =  8U;
    b384:	2308      	movs	r3, #8
    b386:	e6b3      	b.n	b0f0 <_vsnprintf+0x288>
          base =  2U;
    b388:	2302      	movs	r3, #2
        if ((*format != 'i') && (*format != 'd')) {
    b38a:	e6b1      	b.n	b0f0 <_vsnprintf+0x288>
    b38c:	0000a55d 	.word	0x0000a55d
    b390:	0000aab9 	.word	0x0000aab9

0000b394 <printf_>:


///////////////////////////////////////////////////////////////////////////////

int printf_(const char* format, ...)
{
    b394:	b40f      	push	{r0, r1, r2, r3}
    b396:	b51f      	push	{r0, r1, r2, r3, r4, lr}
    b398:	aa06      	add	r2, sp, #24
  va_list va;
  va_start(va, format);
  char buffer[1];
  const int ret = _vsnprintf(_out_char, buffer, (size_t)-1, format, va);
    b39a:	4c07      	ldr	r4, [pc, #28]	; (b3b8 <printf_+0x24>)
{
    b39c:	f852 3b04 	ldr.w	r3, [r2], #4
  va_start(va, format);
    b3a0:	9203      	str	r2, [sp, #12]
  const int ret = _vsnprintf(_out_char, buffer, (size_t)-1, format, va);
    b3a2:	9200      	str	r2, [sp, #0]
    b3a4:	a902      	add	r1, sp, #8
    b3a6:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
    b3aa:	4804      	ldr	r0, [pc, #16]	; (b3bc <printf_+0x28>)
    b3ac:	47a0      	blx	r4
  va_end(va);
  return ret;
}
    b3ae:	b004      	add	sp, #16
    b3b0:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    b3b4:	b004      	add	sp, #16
    b3b6:	4770      	bx	lr
    b3b8:	0000ae69 	.word	0x0000ae69
    b3bc:	0000ae5d 	.word	0x0000ae5d

0000b3c0 <rtt_printf_init>:
 * This function must be called before using any printf functions.
 * It initializes the RTT buffers for communication with the debugger.
 */
void rtt_printf_init(void)
{
    SEGGER_RTT_Init();
    b3c0:	4b00      	ldr	r3, [pc, #0]	; (b3c4 <rtt_printf_init+0x4>)
    b3c2:	4718      	bx	r3
    b3c4:	0000a3bd 	.word	0x0000a3bd

0000b3c8 <_putchar>:
 * It sends the character to RTT buffer 0 (default terminal buffer).
 * 
 * \param character Character to output
 */
void _putchar(char character)
{
    b3c8:	4601      	mov	r1, r0
    SEGGER_RTT_PutChar(0, character);
    b3ca:	4b01      	ldr	r3, [pc, #4]	; (b3d0 <_putchar+0x8>)
    b3cc:	2000      	movs	r0, #0
    b3ce:	4718      	bx	r3
    b3d0:	0000a34d 	.word	0x0000a34d

0000b3d4 <__aeabi_drsub>:
    b3d4:	f081 4100 	eor.w	r1, r1, #2147483648	; 0x80000000
    b3d8:	e002      	b.n	b3e0 <__adddf3>
    b3da:	bf00      	nop

0000b3dc <__aeabi_dsub>:
    b3dc:	f083 4300 	eor.w	r3, r3, #2147483648	; 0x80000000

0000b3e0 <__adddf3>:
    b3e0:	b530      	push	{r4, r5, lr}
    b3e2:	ea4f 0441 	mov.w	r4, r1, lsl #1
    b3e6:	ea4f 0543 	mov.w	r5, r3, lsl #1
    b3ea:	ea94 0f05 	teq	r4, r5
    b3ee:	bf08      	it	eq
    b3f0:	ea90 0f02 	teqeq	r0, r2
    b3f4:	bf1f      	itttt	ne
    b3f6:	ea54 0c00 	orrsne.w	ip, r4, r0
    b3fa:	ea55 0c02 	orrsne.w	ip, r5, r2
    b3fe:	ea7f 5c64 	mvnsne.w	ip, r4, asr #21
    b402:	ea7f 5c65 	mvnsne.w	ip, r5, asr #21
    b406:	f000 80e2 	beq.w	b5ce <__adddf3+0x1ee>
    b40a:	ea4f 5454 	mov.w	r4, r4, lsr #21
    b40e:	ebd4 5555 	rsbs	r5, r4, r5, lsr #21
    b412:	bfb8      	it	lt
    b414:	426d      	neglt	r5, r5
    b416:	dd0c      	ble.n	b432 <__adddf3+0x52>
    b418:	442c      	add	r4, r5
    b41a:	ea80 0202 	eor.w	r2, r0, r2
    b41e:	ea81 0303 	eor.w	r3, r1, r3
    b422:	ea82 0000 	eor.w	r0, r2, r0
    b426:	ea83 0101 	eor.w	r1, r3, r1
    b42a:	ea80 0202 	eor.w	r2, r0, r2
    b42e:	ea81 0303 	eor.w	r3, r1, r3
    b432:	2d36      	cmp	r5, #54	; 0x36
    b434:	bf88      	it	hi
    b436:	bd30      	pophi	{r4, r5, pc}
    b438:	f011 4f00 	tst.w	r1, #2147483648	; 0x80000000
    b43c:	ea4f 3101 	mov.w	r1, r1, lsl #12
    b440:	f44f 1c80 	mov.w	ip, #1048576	; 0x100000
    b444:	ea4c 3111 	orr.w	r1, ip, r1, lsr #12
    b448:	d002      	beq.n	b450 <__adddf3+0x70>
    b44a:	4240      	negs	r0, r0
    b44c:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
    b450:	f013 4f00 	tst.w	r3, #2147483648	; 0x80000000
    b454:	ea4f 3303 	mov.w	r3, r3, lsl #12
    b458:	ea4c 3313 	orr.w	r3, ip, r3, lsr #12
    b45c:	d002      	beq.n	b464 <__adddf3+0x84>
    b45e:	4252      	negs	r2, r2
    b460:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
    b464:	ea94 0f05 	teq	r4, r5
    b468:	f000 80a7 	beq.w	b5ba <__adddf3+0x1da>
    b46c:	f1a4 0401 	sub.w	r4, r4, #1
    b470:	f1d5 0e20 	rsbs	lr, r5, #32
    b474:	db0d      	blt.n	b492 <__adddf3+0xb2>
    b476:	fa02 fc0e 	lsl.w	ip, r2, lr
    b47a:	fa22 f205 	lsr.w	r2, r2, r5
    b47e:	1880      	adds	r0, r0, r2
    b480:	f141 0100 	adc.w	r1, r1, #0
    b484:	fa03 f20e 	lsl.w	r2, r3, lr
    b488:	1880      	adds	r0, r0, r2
    b48a:	fa43 f305 	asr.w	r3, r3, r5
    b48e:	4159      	adcs	r1, r3
    b490:	e00e      	b.n	b4b0 <__adddf3+0xd0>
    b492:	f1a5 0520 	sub.w	r5, r5, #32
    b496:	f10e 0e20 	add.w	lr, lr, #32
    b49a:	2a01      	cmp	r2, #1
    b49c:	fa03 fc0e 	lsl.w	ip, r3, lr
    b4a0:	bf28      	it	cs
    b4a2:	f04c 0c02 	orrcs.w	ip, ip, #2
    b4a6:	fa43 f305 	asr.w	r3, r3, r5
    b4aa:	18c0      	adds	r0, r0, r3
    b4ac:	eb51 71e3 	adcs.w	r1, r1, r3, asr #31
    b4b0:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
    b4b4:	d507      	bpl.n	b4c6 <__adddf3+0xe6>
    b4b6:	f04f 0e00 	mov.w	lr, #0
    b4ba:	f1dc 0c00 	rsbs	ip, ip, #0
    b4be:	eb7e 0000 	sbcs.w	r0, lr, r0
    b4c2:	eb6e 0101 	sbc.w	r1, lr, r1
    b4c6:	f5b1 1f80 	cmp.w	r1, #1048576	; 0x100000
    b4ca:	d31b      	bcc.n	b504 <__adddf3+0x124>
    b4cc:	f5b1 1f00 	cmp.w	r1, #2097152	; 0x200000
    b4d0:	d30c      	bcc.n	b4ec <__adddf3+0x10c>
    b4d2:	0849      	lsrs	r1, r1, #1
    b4d4:	ea5f 0030 	movs.w	r0, r0, rrx
    b4d8:	ea4f 0c3c 	mov.w	ip, ip, rrx
    b4dc:	f104 0401 	add.w	r4, r4, #1
    b4e0:	ea4f 5244 	mov.w	r2, r4, lsl #21
    b4e4:	f512 0f80 	cmn.w	r2, #4194304	; 0x400000
    b4e8:	f080 809a 	bcs.w	b620 <__adddf3+0x240>
    b4ec:	f1bc 4f00 	cmp.w	ip, #2147483648	; 0x80000000
    b4f0:	bf08      	it	eq
    b4f2:	ea5f 0c50 	movseq.w	ip, r0, lsr #1
    b4f6:	f150 0000 	adcs.w	r0, r0, #0
    b4fa:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
    b4fe:	ea41 0105 	orr.w	r1, r1, r5
    b502:	bd30      	pop	{r4, r5, pc}
    b504:	ea5f 0c4c 	movs.w	ip, ip, lsl #1
    b508:	4140      	adcs	r0, r0
    b50a:	eb41 0101 	adc.w	r1, r1, r1
    b50e:	3c01      	subs	r4, #1
    b510:	bf28      	it	cs
    b512:	f5b1 1f80 	cmpcs.w	r1, #1048576	; 0x100000
    b516:	d2e9      	bcs.n	b4ec <__adddf3+0x10c>
    b518:	f091 0f00 	teq	r1, #0
    b51c:	bf04      	itt	eq
    b51e:	4601      	moveq	r1, r0
    b520:	2000      	moveq	r0, #0
    b522:	fab1 f381 	clz	r3, r1
    b526:	bf08      	it	eq
    b528:	3320      	addeq	r3, #32
    b52a:	f1a3 030b 	sub.w	r3, r3, #11
    b52e:	f1b3 0220 	subs.w	r2, r3, #32
    b532:	da0c      	bge.n	b54e <__adddf3+0x16e>
    b534:	320c      	adds	r2, #12
    b536:	dd08      	ble.n	b54a <__adddf3+0x16a>
    b538:	f102 0c14 	add.w	ip, r2, #20
    b53c:	f1c2 020c 	rsb	r2, r2, #12
    b540:	fa01 f00c 	lsl.w	r0, r1, ip
    b544:	fa21 f102 	lsr.w	r1, r1, r2
    b548:	e00c      	b.n	b564 <__adddf3+0x184>
    b54a:	f102 0214 	add.w	r2, r2, #20
    b54e:	bfd8      	it	le
    b550:	f1c2 0c20 	rsble	ip, r2, #32
    b554:	fa01 f102 	lsl.w	r1, r1, r2
    b558:	fa20 fc0c 	lsr.w	ip, r0, ip
    b55c:	bfdc      	itt	le
    b55e:	ea41 010c 	orrle.w	r1, r1, ip
    b562:	4090      	lslle	r0, r2
    b564:	1ae4      	subs	r4, r4, r3
    b566:	bfa2      	ittt	ge
    b568:	eb01 5104 	addge.w	r1, r1, r4, lsl #20
    b56c:	4329      	orrge	r1, r5
    b56e:	bd30      	popge	{r4, r5, pc}
    b570:	ea6f 0404 	mvn.w	r4, r4
    b574:	3c1f      	subs	r4, #31
    b576:	da1c      	bge.n	b5b2 <__adddf3+0x1d2>
    b578:	340c      	adds	r4, #12
    b57a:	dc0e      	bgt.n	b59a <__adddf3+0x1ba>
    b57c:	f104 0414 	add.w	r4, r4, #20
    b580:	f1c4 0220 	rsb	r2, r4, #32
    b584:	fa20 f004 	lsr.w	r0, r0, r4
    b588:	fa01 f302 	lsl.w	r3, r1, r2
    b58c:	ea40 0003 	orr.w	r0, r0, r3
    b590:	fa21 f304 	lsr.w	r3, r1, r4
    b594:	ea45 0103 	orr.w	r1, r5, r3
    b598:	bd30      	pop	{r4, r5, pc}
    b59a:	f1c4 040c 	rsb	r4, r4, #12
    b59e:	f1c4 0220 	rsb	r2, r4, #32
    b5a2:	fa20 f002 	lsr.w	r0, r0, r2
    b5a6:	fa01 f304 	lsl.w	r3, r1, r4
    b5aa:	ea40 0003 	orr.w	r0, r0, r3
    b5ae:	4629      	mov	r1, r5
    b5b0:	bd30      	pop	{r4, r5, pc}
    b5b2:	fa21 f004 	lsr.w	r0, r1, r4
    b5b6:	4629      	mov	r1, r5
    b5b8:	bd30      	pop	{r4, r5, pc}
    b5ba:	f094 0f00 	teq	r4, #0
    b5be:	f483 1380 	eor.w	r3, r3, #1048576	; 0x100000
    b5c2:	bf06      	itte	eq
    b5c4:	f481 1180 	eoreq.w	r1, r1, #1048576	; 0x100000
    b5c8:	3401      	addeq	r4, #1
    b5ca:	3d01      	subne	r5, #1
    b5cc:	e74e      	b.n	b46c <__adddf3+0x8c>
    b5ce:	ea7f 5c64 	mvns.w	ip, r4, asr #21
    b5d2:	bf18      	it	ne
    b5d4:	ea7f 5c65 	mvnsne.w	ip, r5, asr #21
    b5d8:	d029      	beq.n	b62e <__adddf3+0x24e>
    b5da:	ea94 0f05 	teq	r4, r5
    b5de:	bf08      	it	eq
    b5e0:	ea90 0f02 	teqeq	r0, r2
    b5e4:	d005      	beq.n	b5f2 <__adddf3+0x212>
    b5e6:	ea54 0c00 	orrs.w	ip, r4, r0
    b5ea:	bf04      	itt	eq
    b5ec:	4619      	moveq	r1, r3
    b5ee:	4610      	moveq	r0, r2
    b5f0:	bd30      	pop	{r4, r5, pc}
    b5f2:	ea91 0f03 	teq	r1, r3
    b5f6:	bf1e      	ittt	ne
    b5f8:	2100      	movne	r1, #0
    b5fa:	2000      	movne	r0, #0
    b5fc:	bd30      	popne	{r4, r5, pc}
    b5fe:	ea5f 5c54 	movs.w	ip, r4, lsr #21
    b602:	d105      	bne.n	b610 <__adddf3+0x230>
    b604:	0040      	lsls	r0, r0, #1
    b606:	4149      	adcs	r1, r1
    b608:	bf28      	it	cs
    b60a:	f041 4100 	orrcs.w	r1, r1, #2147483648	; 0x80000000
    b60e:	bd30      	pop	{r4, r5, pc}
    b610:	f514 0480 	adds.w	r4, r4, #4194304	; 0x400000
    b614:	bf3c      	itt	cc
    b616:	f501 1180 	addcc.w	r1, r1, #1048576	; 0x100000
    b61a:	bd30      	popcc	{r4, r5, pc}
    b61c:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
    b620:	f045 41fe 	orr.w	r1, r5, #2130706432	; 0x7f000000
    b624:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
    b628:	f04f 0000 	mov.w	r0, #0
    b62c:	bd30      	pop	{r4, r5, pc}
    b62e:	ea7f 5c64 	mvns.w	ip, r4, asr #21
    b632:	bf1a      	itte	ne
    b634:	4619      	movne	r1, r3
    b636:	4610      	movne	r0, r2
    b638:	ea7f 5c65 	mvnseq.w	ip, r5, asr #21
    b63c:	bf1c      	itt	ne
    b63e:	460b      	movne	r3, r1
    b640:	4602      	movne	r2, r0
    b642:	ea50 3401 	orrs.w	r4, r0, r1, lsl #12
    b646:	bf06      	itte	eq
    b648:	ea52 3503 	orrseq.w	r5, r2, r3, lsl #12
    b64c:	ea91 0f03 	teqeq	r1, r3
    b650:	f441 2100 	orrne.w	r1, r1, #524288	; 0x80000
    b654:	bd30      	pop	{r4, r5, pc}
    b656:	bf00      	nop

0000b658 <__aeabi_ui2d>:
    b658:	f090 0f00 	teq	r0, #0
    b65c:	bf04      	itt	eq
    b65e:	2100      	moveq	r1, #0
    b660:	4770      	bxeq	lr
    b662:	b530      	push	{r4, r5, lr}
    b664:	f44f 6480 	mov.w	r4, #1024	; 0x400
    b668:	f104 0432 	add.w	r4, r4, #50	; 0x32
    b66c:	f04f 0500 	mov.w	r5, #0
    b670:	f04f 0100 	mov.w	r1, #0
    b674:	e750      	b.n	b518 <__adddf3+0x138>
    b676:	bf00      	nop

0000b678 <__aeabi_i2d>:
    b678:	f090 0f00 	teq	r0, #0
    b67c:	bf04      	itt	eq
    b67e:	2100      	moveq	r1, #0
    b680:	4770      	bxeq	lr
    b682:	b530      	push	{r4, r5, lr}
    b684:	f44f 6480 	mov.w	r4, #1024	; 0x400
    b688:	f104 0432 	add.w	r4, r4, #50	; 0x32
    b68c:	f010 4500 	ands.w	r5, r0, #2147483648	; 0x80000000
    b690:	bf48      	it	mi
    b692:	4240      	negmi	r0, r0
    b694:	f04f 0100 	mov.w	r1, #0
    b698:	e73e      	b.n	b518 <__adddf3+0x138>
    b69a:	bf00      	nop

0000b69c <__aeabi_f2d>:
    b69c:	0042      	lsls	r2, r0, #1
    b69e:	ea4f 01e2 	mov.w	r1, r2, asr #3
    b6a2:	ea4f 0131 	mov.w	r1, r1, rrx
    b6a6:	ea4f 7002 	mov.w	r0, r2, lsl #28
    b6aa:	bf1f      	itttt	ne
    b6ac:	f012 437f 	andsne.w	r3, r2, #4278190080	; 0xff000000
    b6b0:	f093 4f7f 	teqne	r3, #4278190080	; 0xff000000
    b6b4:	f081 5160 	eorne.w	r1, r1, #939524096	; 0x38000000
    b6b8:	4770      	bxne	lr
    b6ba:	f032 427f 	bics.w	r2, r2, #4278190080	; 0xff000000
    b6be:	bf08      	it	eq
    b6c0:	4770      	bxeq	lr
    b6c2:	f093 4f7f 	teq	r3, #4278190080	; 0xff000000
    b6c6:	bf04      	itt	eq
    b6c8:	f441 2100 	orreq.w	r1, r1, #524288	; 0x80000
    b6cc:	4770      	bxeq	lr
    b6ce:	b530      	push	{r4, r5, lr}
    b6d0:	f44f 7460 	mov.w	r4, #896	; 0x380
    b6d4:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
    b6d8:	f021 4100 	bic.w	r1, r1, #2147483648	; 0x80000000
    b6dc:	e71c      	b.n	b518 <__adddf3+0x138>
    b6de:	bf00      	nop

0000b6e0 <__aeabi_ul2d>:
    b6e0:	ea50 0201 	orrs.w	r2, r0, r1
    b6e4:	bf08      	it	eq
    b6e6:	4770      	bxeq	lr
    b6e8:	b530      	push	{r4, r5, lr}
    b6ea:	f04f 0500 	mov.w	r5, #0
    b6ee:	e00a      	b.n	b706 <__aeabi_l2d+0x16>

0000b6f0 <__aeabi_l2d>:
    b6f0:	ea50 0201 	orrs.w	r2, r0, r1
    b6f4:	bf08      	it	eq
    b6f6:	4770      	bxeq	lr
    b6f8:	b530      	push	{r4, r5, lr}
    b6fa:	f011 4500 	ands.w	r5, r1, #2147483648	; 0x80000000
    b6fe:	d502      	bpl.n	b706 <__aeabi_l2d+0x16>
    b700:	4240      	negs	r0, r0
    b702:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
    b706:	f44f 6480 	mov.w	r4, #1024	; 0x400
    b70a:	f104 0432 	add.w	r4, r4, #50	; 0x32
    b70e:	ea5f 5c91 	movs.w	ip, r1, lsr #22
    b712:	f43f aed8 	beq.w	b4c6 <__adddf3+0xe6>
    b716:	f04f 0203 	mov.w	r2, #3
    b71a:	ea5f 0cdc 	movs.w	ip, ip, lsr #3
    b71e:	bf18      	it	ne
    b720:	3203      	addne	r2, #3
    b722:	ea5f 0cdc 	movs.w	ip, ip, lsr #3
    b726:	bf18      	it	ne
    b728:	3203      	addne	r2, #3
    b72a:	eb02 02dc 	add.w	r2, r2, ip, lsr #3
    b72e:	f1c2 0320 	rsb	r3, r2, #32
    b732:	fa00 fc03 	lsl.w	ip, r0, r3
    b736:	fa20 f002 	lsr.w	r0, r0, r2
    b73a:	fa01 fe03 	lsl.w	lr, r1, r3
    b73e:	ea40 000e 	orr.w	r0, r0, lr
    b742:	fa21 f102 	lsr.w	r1, r1, r2
    b746:	4414      	add	r4, r2
    b748:	e6bd      	b.n	b4c6 <__adddf3+0xe6>
    b74a:	bf00      	nop

0000b74c <__aeabi_dmul>:
    b74c:	b570      	push	{r4, r5, r6, lr}
    b74e:	f04f 0cff 	mov.w	ip, #255	; 0xff
    b752:	f44c 6ce0 	orr.w	ip, ip, #1792	; 0x700
    b756:	ea1c 5411 	ands.w	r4, ip, r1, lsr #20
    b75a:	bf1d      	ittte	ne
    b75c:	ea1c 5513 	andsne.w	r5, ip, r3, lsr #20
    b760:	ea94 0f0c 	teqne	r4, ip
    b764:	ea95 0f0c 	teqne	r5, ip
    b768:	f000 f8de 	bleq	b928 <__aeabi_dmul+0x1dc>
    b76c:	442c      	add	r4, r5
    b76e:	ea81 0603 	eor.w	r6, r1, r3
    b772:	ea21 514c 	bic.w	r1, r1, ip, lsl #21
    b776:	ea23 534c 	bic.w	r3, r3, ip, lsl #21
    b77a:	ea50 3501 	orrs.w	r5, r0, r1, lsl #12
    b77e:	bf18      	it	ne
    b780:	ea52 3503 	orrsne.w	r5, r2, r3, lsl #12
    b784:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
    b788:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
    b78c:	d038      	beq.n	b800 <__aeabi_dmul+0xb4>
    b78e:	fba0 ce02 	umull	ip, lr, r0, r2
    b792:	f04f 0500 	mov.w	r5, #0
    b796:	fbe1 e502 	umlal	lr, r5, r1, r2
    b79a:	f006 4200 	and.w	r2, r6, #2147483648	; 0x80000000
    b79e:	fbe0 e503 	umlal	lr, r5, r0, r3
    b7a2:	f04f 0600 	mov.w	r6, #0
    b7a6:	fbe1 5603 	umlal	r5, r6, r1, r3
    b7aa:	f09c 0f00 	teq	ip, #0
    b7ae:	bf18      	it	ne
    b7b0:	f04e 0e01 	orrne.w	lr, lr, #1
    b7b4:	f1a4 04ff 	sub.w	r4, r4, #255	; 0xff
    b7b8:	f5b6 7f00 	cmp.w	r6, #512	; 0x200
    b7bc:	f564 7440 	sbc.w	r4, r4, #768	; 0x300
    b7c0:	d204      	bcs.n	b7cc <__aeabi_dmul+0x80>
    b7c2:	ea5f 0e4e 	movs.w	lr, lr, lsl #1
    b7c6:	416d      	adcs	r5, r5
    b7c8:	eb46 0606 	adc.w	r6, r6, r6
    b7cc:	ea42 21c6 	orr.w	r1, r2, r6, lsl #11
    b7d0:	ea41 5155 	orr.w	r1, r1, r5, lsr #21
    b7d4:	ea4f 20c5 	mov.w	r0, r5, lsl #11
    b7d8:	ea40 505e 	orr.w	r0, r0, lr, lsr #21
    b7dc:	ea4f 2ece 	mov.w	lr, lr, lsl #11
    b7e0:	f1b4 0cfd 	subs.w	ip, r4, #253	; 0xfd
    b7e4:	bf88      	it	hi
    b7e6:	f5bc 6fe0 	cmphi.w	ip, #1792	; 0x700
    b7ea:	d81e      	bhi.n	b82a <__aeabi_dmul+0xde>
    b7ec:	f1be 4f00 	cmp.w	lr, #2147483648	; 0x80000000
    b7f0:	bf08      	it	eq
    b7f2:	ea5f 0e50 	movseq.w	lr, r0, lsr #1
    b7f6:	f150 0000 	adcs.w	r0, r0, #0
    b7fa:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
    b7fe:	bd70      	pop	{r4, r5, r6, pc}
    b800:	f006 4600 	and.w	r6, r6, #2147483648	; 0x80000000
    b804:	ea46 0101 	orr.w	r1, r6, r1
    b808:	ea40 0002 	orr.w	r0, r0, r2
    b80c:	ea81 0103 	eor.w	r1, r1, r3
    b810:	ebb4 045c 	subs.w	r4, r4, ip, lsr #1
    b814:	bfc2      	ittt	gt
    b816:	ebd4 050c 	rsbsgt	r5, r4, ip
    b81a:	ea41 5104 	orrgt.w	r1, r1, r4, lsl #20
    b81e:	bd70      	popgt	{r4, r5, r6, pc}
    b820:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
    b824:	f04f 0e00 	mov.w	lr, #0
    b828:	3c01      	subs	r4, #1
    b82a:	f300 80ab 	bgt.w	b984 <__aeabi_dmul+0x238>
    b82e:	f114 0f36 	cmn.w	r4, #54	; 0x36
    b832:	bfde      	ittt	le
    b834:	2000      	movle	r0, #0
    b836:	f001 4100 	andle.w	r1, r1, #2147483648	; 0x80000000
    b83a:	bd70      	pople	{r4, r5, r6, pc}
    b83c:	f1c4 0400 	rsb	r4, r4, #0
    b840:	3c20      	subs	r4, #32
    b842:	da35      	bge.n	b8b0 <__aeabi_dmul+0x164>
    b844:	340c      	adds	r4, #12
    b846:	dc1b      	bgt.n	b880 <__aeabi_dmul+0x134>
    b848:	f104 0414 	add.w	r4, r4, #20
    b84c:	f1c4 0520 	rsb	r5, r4, #32
    b850:	fa00 f305 	lsl.w	r3, r0, r5
    b854:	fa20 f004 	lsr.w	r0, r0, r4
    b858:	fa01 f205 	lsl.w	r2, r1, r5
    b85c:	ea40 0002 	orr.w	r0, r0, r2
    b860:	f001 4200 	and.w	r2, r1, #2147483648	; 0x80000000
    b864:	f021 4100 	bic.w	r1, r1, #2147483648	; 0x80000000
    b868:	eb10 70d3 	adds.w	r0, r0, r3, lsr #31
    b86c:	fa21 f604 	lsr.w	r6, r1, r4
    b870:	eb42 0106 	adc.w	r1, r2, r6
    b874:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
    b878:	bf08      	it	eq
    b87a:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
    b87e:	bd70      	pop	{r4, r5, r6, pc}
    b880:	f1c4 040c 	rsb	r4, r4, #12
    b884:	f1c4 0520 	rsb	r5, r4, #32
    b888:	fa00 f304 	lsl.w	r3, r0, r4
    b88c:	fa20 f005 	lsr.w	r0, r0, r5
    b890:	fa01 f204 	lsl.w	r2, r1, r4
    b894:	ea40 0002 	orr.w	r0, r0, r2
    b898:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
    b89c:	eb10 70d3 	adds.w	r0, r0, r3, lsr #31
    b8a0:	f141 0100 	adc.w	r1, r1, #0
    b8a4:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
    b8a8:	bf08      	it	eq
    b8aa:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
    b8ae:	bd70      	pop	{r4, r5, r6, pc}
    b8b0:	f1c4 0520 	rsb	r5, r4, #32
    b8b4:	fa00 f205 	lsl.w	r2, r0, r5
    b8b8:	ea4e 0e02 	orr.w	lr, lr, r2
    b8bc:	fa20 f304 	lsr.w	r3, r0, r4
    b8c0:	fa01 f205 	lsl.w	r2, r1, r5
    b8c4:	ea43 0302 	orr.w	r3, r3, r2
    b8c8:	fa21 f004 	lsr.w	r0, r1, r4
    b8cc:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
    b8d0:	fa21 f204 	lsr.w	r2, r1, r4
    b8d4:	ea20 0002 	bic.w	r0, r0, r2
    b8d8:	eb00 70d3 	add.w	r0, r0, r3, lsr #31
    b8dc:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
    b8e0:	bf08      	it	eq
    b8e2:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
    b8e6:	bd70      	pop	{r4, r5, r6, pc}
    b8e8:	f094 0f00 	teq	r4, #0
    b8ec:	d10f      	bne.n	b90e <__aeabi_dmul+0x1c2>
    b8ee:	f001 4600 	and.w	r6, r1, #2147483648	; 0x80000000
    b8f2:	0040      	lsls	r0, r0, #1
    b8f4:	eb41 0101 	adc.w	r1, r1, r1
    b8f8:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
    b8fc:	bf08      	it	eq
    b8fe:	3c01      	subeq	r4, #1
    b900:	d0f7      	beq.n	b8f2 <__aeabi_dmul+0x1a6>
    b902:	ea41 0106 	orr.w	r1, r1, r6
    b906:	f095 0f00 	teq	r5, #0
    b90a:	bf18      	it	ne
    b90c:	4770      	bxne	lr
    b90e:	f003 4600 	and.w	r6, r3, #2147483648	; 0x80000000
    b912:	0052      	lsls	r2, r2, #1
    b914:	eb43 0303 	adc.w	r3, r3, r3
    b918:	f413 1f80 	tst.w	r3, #1048576	; 0x100000
    b91c:	bf08      	it	eq
    b91e:	3d01      	subeq	r5, #1
    b920:	d0f7      	beq.n	b912 <__aeabi_dmul+0x1c6>
    b922:	ea43 0306 	orr.w	r3, r3, r6
    b926:	4770      	bx	lr
    b928:	ea94 0f0c 	teq	r4, ip
    b92c:	ea0c 5513 	and.w	r5, ip, r3, lsr #20
    b930:	bf18      	it	ne
    b932:	ea95 0f0c 	teqne	r5, ip
    b936:	d00c      	beq.n	b952 <__aeabi_dmul+0x206>
    b938:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
    b93c:	bf18      	it	ne
    b93e:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
    b942:	d1d1      	bne.n	b8e8 <__aeabi_dmul+0x19c>
    b944:	ea81 0103 	eor.w	r1, r1, r3
    b948:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
    b94c:	f04f 0000 	mov.w	r0, #0
    b950:	bd70      	pop	{r4, r5, r6, pc}
    b952:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
    b956:	bf06      	itte	eq
    b958:	4610      	moveq	r0, r2
    b95a:	4619      	moveq	r1, r3
    b95c:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
    b960:	d019      	beq.n	b996 <__aeabi_dmul+0x24a>
    b962:	ea94 0f0c 	teq	r4, ip
    b966:	d102      	bne.n	b96e <__aeabi_dmul+0x222>
    b968:	ea50 3601 	orrs.w	r6, r0, r1, lsl #12
    b96c:	d113      	bne.n	b996 <__aeabi_dmul+0x24a>
    b96e:	ea95 0f0c 	teq	r5, ip
    b972:	d105      	bne.n	b980 <__aeabi_dmul+0x234>
    b974:	ea52 3603 	orrs.w	r6, r2, r3, lsl #12
    b978:	bf1c      	itt	ne
    b97a:	4610      	movne	r0, r2
    b97c:	4619      	movne	r1, r3
    b97e:	d10a      	bne.n	b996 <__aeabi_dmul+0x24a>
    b980:	ea81 0103 	eor.w	r1, r1, r3
    b984:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
    b988:	f041 41fe 	orr.w	r1, r1, #2130706432	; 0x7f000000
    b98c:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
    b990:	f04f 0000 	mov.w	r0, #0
    b994:	bd70      	pop	{r4, r5, r6, pc}
    b996:	f041 41fe 	orr.w	r1, r1, #2130706432	; 0x7f000000
    b99a:	f441 0178 	orr.w	r1, r1, #16252928	; 0xf80000
    b99e:	bd70      	pop	{r4, r5, r6, pc}

0000b9a0 <__aeabi_ddiv>:
    b9a0:	b570      	push	{r4, r5, r6, lr}
    b9a2:	f04f 0cff 	mov.w	ip, #255	; 0xff
    b9a6:	f44c 6ce0 	orr.w	ip, ip, #1792	; 0x700
    b9aa:	ea1c 5411 	ands.w	r4, ip, r1, lsr #20
    b9ae:	bf1d      	ittte	ne
    b9b0:	ea1c 5513 	andsne.w	r5, ip, r3, lsr #20
    b9b4:	ea94 0f0c 	teqne	r4, ip
    b9b8:	ea95 0f0c 	teqne	r5, ip
    b9bc:	f000 f8a7 	bleq	bb0e <__aeabi_ddiv+0x16e>
    b9c0:	eba4 0405 	sub.w	r4, r4, r5
    b9c4:	ea81 0e03 	eor.w	lr, r1, r3
    b9c8:	ea52 3503 	orrs.w	r5, r2, r3, lsl #12
    b9cc:	ea4f 3101 	mov.w	r1, r1, lsl #12
    b9d0:	f000 8088 	beq.w	bae4 <__aeabi_ddiv+0x144>
    b9d4:	ea4f 3303 	mov.w	r3, r3, lsl #12
    b9d8:	f04f 5580 	mov.w	r5, #268435456	; 0x10000000
    b9dc:	ea45 1313 	orr.w	r3, r5, r3, lsr #4
    b9e0:	ea43 6312 	orr.w	r3, r3, r2, lsr #24
    b9e4:	ea4f 2202 	mov.w	r2, r2, lsl #8
    b9e8:	ea45 1511 	orr.w	r5, r5, r1, lsr #4
    b9ec:	ea45 6510 	orr.w	r5, r5, r0, lsr #24
    b9f0:	ea4f 2600 	mov.w	r6, r0, lsl #8
    b9f4:	f00e 4100 	and.w	r1, lr, #2147483648	; 0x80000000
    b9f8:	429d      	cmp	r5, r3
    b9fa:	bf08      	it	eq
    b9fc:	4296      	cmpeq	r6, r2
    b9fe:	f144 04fd 	adc.w	r4, r4, #253	; 0xfd
    ba02:	f504 7440 	add.w	r4, r4, #768	; 0x300
    ba06:	d202      	bcs.n	ba0e <__aeabi_ddiv+0x6e>
    ba08:	085b      	lsrs	r3, r3, #1
    ba0a:	ea4f 0232 	mov.w	r2, r2, rrx
    ba0e:	1ab6      	subs	r6, r6, r2
    ba10:	eb65 0503 	sbc.w	r5, r5, r3
    ba14:	085b      	lsrs	r3, r3, #1
    ba16:	ea4f 0232 	mov.w	r2, r2, rrx
    ba1a:	f44f 1080 	mov.w	r0, #1048576	; 0x100000
    ba1e:	f44f 2c00 	mov.w	ip, #524288	; 0x80000
    ba22:	ebb6 0e02 	subs.w	lr, r6, r2
    ba26:	eb75 0e03 	sbcs.w	lr, r5, r3
    ba2a:	bf22      	ittt	cs
    ba2c:	1ab6      	subcs	r6, r6, r2
    ba2e:	4675      	movcs	r5, lr
    ba30:	ea40 000c 	orrcs.w	r0, r0, ip
    ba34:	085b      	lsrs	r3, r3, #1
    ba36:	ea4f 0232 	mov.w	r2, r2, rrx
    ba3a:	ebb6 0e02 	subs.w	lr, r6, r2
    ba3e:	eb75 0e03 	sbcs.w	lr, r5, r3
    ba42:	bf22      	ittt	cs
    ba44:	1ab6      	subcs	r6, r6, r2
    ba46:	4675      	movcs	r5, lr
    ba48:	ea40 005c 	orrcs.w	r0, r0, ip, lsr #1
    ba4c:	085b      	lsrs	r3, r3, #1
    ba4e:	ea4f 0232 	mov.w	r2, r2, rrx
    ba52:	ebb6 0e02 	subs.w	lr, r6, r2
    ba56:	eb75 0e03 	sbcs.w	lr, r5, r3
    ba5a:	bf22      	ittt	cs
    ba5c:	1ab6      	subcs	r6, r6, r2
    ba5e:	4675      	movcs	r5, lr
    ba60:	ea40 009c 	orrcs.w	r0, r0, ip, lsr #2
    ba64:	085b      	lsrs	r3, r3, #1
    ba66:	ea4f 0232 	mov.w	r2, r2, rrx
    ba6a:	ebb6 0e02 	subs.w	lr, r6, r2
    ba6e:	eb75 0e03 	sbcs.w	lr, r5, r3
    ba72:	bf22      	ittt	cs
    ba74:	1ab6      	subcs	r6, r6, r2
    ba76:	4675      	movcs	r5, lr
    ba78:	ea40 00dc 	orrcs.w	r0, r0, ip, lsr #3
    ba7c:	ea55 0e06 	orrs.w	lr, r5, r6
    ba80:	d018      	beq.n	bab4 <__aeabi_ddiv+0x114>
    ba82:	ea4f 1505 	mov.w	r5, r5, lsl #4
    ba86:	ea45 7516 	orr.w	r5, r5, r6, lsr #28
    ba8a:	ea4f 1606 	mov.w	r6, r6, lsl #4
    ba8e:	ea4f 03c3 	mov.w	r3, r3, lsl #3
    ba92:	ea43 7352 	orr.w	r3, r3, r2, lsr #29
    ba96:	ea4f 02c2 	mov.w	r2, r2, lsl #3
    ba9a:	ea5f 1c1c 	movs.w	ip, ip, lsr #4
    ba9e:	d1c0      	bne.n	ba22 <__aeabi_ddiv+0x82>
    baa0:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
    baa4:	d10b      	bne.n	babe <__aeabi_ddiv+0x11e>
    baa6:	ea41 0100 	orr.w	r1, r1, r0
    baaa:	f04f 0000 	mov.w	r0, #0
    baae:	f04f 4c00 	mov.w	ip, #2147483648	; 0x80000000
    bab2:	e7b6      	b.n	ba22 <__aeabi_ddiv+0x82>
    bab4:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
    bab8:	bf04      	itt	eq
    baba:	4301      	orreq	r1, r0
    babc:	2000      	moveq	r0, #0
    babe:	f1b4 0cfd 	subs.w	ip, r4, #253	; 0xfd
    bac2:	bf88      	it	hi
    bac4:	f5bc 6fe0 	cmphi.w	ip, #1792	; 0x700
    bac8:	f63f aeaf 	bhi.w	b82a <__aeabi_dmul+0xde>
    bacc:	ebb5 0c03 	subs.w	ip, r5, r3
    bad0:	bf04      	itt	eq
    bad2:	ebb6 0c02 	subseq.w	ip, r6, r2
    bad6:	ea5f 0c50 	movseq.w	ip, r0, lsr #1
    bada:	f150 0000 	adcs.w	r0, r0, #0
    bade:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
    bae2:	bd70      	pop	{r4, r5, r6, pc}
    bae4:	f00e 4e00 	and.w	lr, lr, #2147483648	; 0x80000000
    bae8:	ea4e 3111 	orr.w	r1, lr, r1, lsr #12
    baec:	eb14 045c 	adds.w	r4, r4, ip, lsr #1
    baf0:	bfc2      	ittt	gt
    baf2:	ebd4 050c 	rsbsgt	r5, r4, ip
    baf6:	ea41 5104 	orrgt.w	r1, r1, r4, lsl #20
    bafa:	bd70      	popgt	{r4, r5, r6, pc}
    bafc:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
    bb00:	f04f 0e00 	mov.w	lr, #0
    bb04:	3c01      	subs	r4, #1
    bb06:	e690      	b.n	b82a <__aeabi_dmul+0xde>
    bb08:	ea45 0e06 	orr.w	lr, r5, r6
    bb0c:	e68d      	b.n	b82a <__aeabi_dmul+0xde>
    bb0e:	ea0c 5513 	and.w	r5, ip, r3, lsr #20
    bb12:	ea94 0f0c 	teq	r4, ip
    bb16:	bf08      	it	eq
    bb18:	ea95 0f0c 	teqeq	r5, ip
    bb1c:	f43f af3b 	beq.w	b996 <__aeabi_dmul+0x24a>
    bb20:	ea94 0f0c 	teq	r4, ip
    bb24:	d10a      	bne.n	bb3c <__aeabi_ddiv+0x19c>
    bb26:	ea50 3401 	orrs.w	r4, r0, r1, lsl #12
    bb2a:	f47f af34 	bne.w	b996 <__aeabi_dmul+0x24a>
    bb2e:	ea95 0f0c 	teq	r5, ip
    bb32:	f47f af25 	bne.w	b980 <__aeabi_dmul+0x234>
    bb36:	4610      	mov	r0, r2
    bb38:	4619      	mov	r1, r3
    bb3a:	e72c      	b.n	b996 <__aeabi_dmul+0x24a>
    bb3c:	ea95 0f0c 	teq	r5, ip
    bb40:	d106      	bne.n	bb50 <__aeabi_ddiv+0x1b0>
    bb42:	ea52 3503 	orrs.w	r5, r2, r3, lsl #12
    bb46:	f43f aefd 	beq.w	b944 <__aeabi_dmul+0x1f8>
    bb4a:	4610      	mov	r0, r2
    bb4c:	4619      	mov	r1, r3
    bb4e:	e722      	b.n	b996 <__aeabi_dmul+0x24a>
    bb50:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
    bb54:	bf18      	it	ne
    bb56:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
    bb5a:	f47f aec5 	bne.w	b8e8 <__aeabi_dmul+0x19c>
    bb5e:	ea50 0441 	orrs.w	r4, r0, r1, lsl #1
    bb62:	f47f af0d 	bne.w	b980 <__aeabi_dmul+0x234>
    bb66:	ea52 0543 	orrs.w	r5, r2, r3, lsl #1
    bb6a:	f47f aeeb 	bne.w	b944 <__aeabi_dmul+0x1f8>
    bb6e:	e712      	b.n	b996 <__aeabi_dmul+0x24a>

0000bb70 <__gedf2>:
    bb70:	f04f 3cff 	mov.w	ip, #4294967295	; 0xffffffff
    bb74:	e006      	b.n	bb84 <__cmpdf2+0x4>
    bb76:	bf00      	nop

0000bb78 <__ledf2>:
    bb78:	f04f 0c01 	mov.w	ip, #1
    bb7c:	e002      	b.n	bb84 <__cmpdf2+0x4>
    bb7e:	bf00      	nop

0000bb80 <__cmpdf2>:
    bb80:	f04f 0c01 	mov.w	ip, #1
    bb84:	f84d cd04 	str.w	ip, [sp, #-4]!
    bb88:	ea4f 0c41 	mov.w	ip, r1, lsl #1
    bb8c:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
    bb90:	ea4f 0c43 	mov.w	ip, r3, lsl #1
    bb94:	bf18      	it	ne
    bb96:	ea7f 5c6c 	mvnsne.w	ip, ip, asr #21
    bb9a:	d01b      	beq.n	bbd4 <__cmpdf2+0x54>
    bb9c:	b001      	add	sp, #4
    bb9e:	ea50 0c41 	orrs.w	ip, r0, r1, lsl #1
    bba2:	bf0c      	ite	eq
    bba4:	ea52 0c43 	orrseq.w	ip, r2, r3, lsl #1
    bba8:	ea91 0f03 	teqne	r1, r3
    bbac:	bf02      	ittt	eq
    bbae:	ea90 0f02 	teqeq	r0, r2
    bbb2:	2000      	moveq	r0, #0
    bbb4:	4770      	bxeq	lr
    bbb6:	f110 0f00 	cmn.w	r0, #0
    bbba:	ea91 0f03 	teq	r1, r3
    bbbe:	bf58      	it	pl
    bbc0:	4299      	cmppl	r1, r3
    bbc2:	bf08      	it	eq
    bbc4:	4290      	cmpeq	r0, r2
    bbc6:	bf2c      	ite	cs
    bbc8:	17d8      	asrcs	r0, r3, #31
    bbca:	ea6f 70e3 	mvncc.w	r0, r3, asr #31
    bbce:	f040 0001 	orr.w	r0, r0, #1
    bbd2:	4770      	bx	lr
    bbd4:	ea4f 0c41 	mov.w	ip, r1, lsl #1
    bbd8:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
    bbdc:	d102      	bne.n	bbe4 <__cmpdf2+0x64>
    bbde:	ea50 3c01 	orrs.w	ip, r0, r1, lsl #12
    bbe2:	d107      	bne.n	bbf4 <__cmpdf2+0x74>
    bbe4:	ea4f 0c43 	mov.w	ip, r3, lsl #1
    bbe8:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
    bbec:	d1d6      	bne.n	bb9c <__cmpdf2+0x1c>
    bbee:	ea52 3c03 	orrs.w	ip, r2, r3, lsl #12
    bbf2:	d0d3      	beq.n	bb9c <__cmpdf2+0x1c>
    bbf4:	f85d 0b04 	ldr.w	r0, [sp], #4
    bbf8:	4770      	bx	lr
    bbfa:	bf00      	nop

0000bbfc <__aeabi_cdrcmple>:
    bbfc:	4684      	mov	ip, r0
    bbfe:	4610      	mov	r0, r2
    bc00:	4662      	mov	r2, ip
    bc02:	468c      	mov	ip, r1
    bc04:	4619      	mov	r1, r3
    bc06:	4663      	mov	r3, ip
    bc08:	e000      	b.n	bc0c <__aeabi_cdcmpeq>
    bc0a:	bf00      	nop

0000bc0c <__aeabi_cdcmpeq>:
    bc0c:	b501      	push	{r0, lr}
    bc0e:	f7ff ffb7 	bl	bb80 <__cmpdf2>
    bc12:	2800      	cmp	r0, #0
    bc14:	bf48      	it	mi
    bc16:	f110 0f00 	cmnmi.w	r0, #0
    bc1a:	bd01      	pop	{r0, pc}

0000bc1c <__aeabi_dcmpeq>:
    bc1c:	f84d ed08 	str.w	lr, [sp, #-8]!
    bc20:	f7ff fff4 	bl	bc0c <__aeabi_cdcmpeq>
    bc24:	bf0c      	ite	eq
    bc26:	2001      	moveq	r0, #1
    bc28:	2000      	movne	r0, #0
    bc2a:	f85d fb08 	ldr.w	pc, [sp], #8
    bc2e:	bf00      	nop

0000bc30 <__aeabi_dcmplt>:
    bc30:	f84d ed08 	str.w	lr, [sp, #-8]!
    bc34:	f7ff ffea 	bl	bc0c <__aeabi_cdcmpeq>
    bc38:	bf34      	ite	cc
    bc3a:	2001      	movcc	r0, #1
    bc3c:	2000      	movcs	r0, #0
    bc3e:	f85d fb08 	ldr.w	pc, [sp], #8
    bc42:	bf00      	nop

0000bc44 <__aeabi_dcmple>:
    bc44:	f84d ed08 	str.w	lr, [sp, #-8]!
    bc48:	f7ff ffe0 	bl	bc0c <__aeabi_cdcmpeq>
    bc4c:	bf94      	ite	ls
    bc4e:	2001      	movls	r0, #1
    bc50:	2000      	movhi	r0, #0
    bc52:	f85d fb08 	ldr.w	pc, [sp], #8
    bc56:	bf00      	nop

0000bc58 <__aeabi_dcmpge>:
    bc58:	f84d ed08 	str.w	lr, [sp, #-8]!
    bc5c:	f7ff ffce 	bl	bbfc <__aeabi_cdrcmple>
    bc60:	bf94      	ite	ls
    bc62:	2001      	movls	r0, #1
    bc64:	2000      	movhi	r0, #0
    bc66:	f85d fb08 	ldr.w	pc, [sp], #8
    bc6a:	bf00      	nop

0000bc6c <__aeabi_dcmpgt>:
    bc6c:	f84d ed08 	str.w	lr, [sp, #-8]!
    bc70:	f7ff ffc4 	bl	bbfc <__aeabi_cdrcmple>
    bc74:	bf34      	ite	cc
    bc76:	2001      	movcc	r0, #1
    bc78:	2000      	movcs	r0, #0
    bc7a:	f85d fb08 	ldr.w	pc, [sp], #8
    bc7e:	bf00      	nop

0000bc80 <__aeabi_d2iz>:
    bc80:	ea4f 0241 	mov.w	r2, r1, lsl #1
    bc84:	f512 1200 	adds.w	r2, r2, #2097152	; 0x200000
    bc88:	d215      	bcs.n	bcb6 <__aeabi_d2iz+0x36>
    bc8a:	d511      	bpl.n	bcb0 <__aeabi_d2iz+0x30>
    bc8c:	f46f 7378 	mvn.w	r3, #992	; 0x3e0
    bc90:	ebb3 5262 	subs.w	r2, r3, r2, asr #21
    bc94:	d912      	bls.n	bcbc <__aeabi_d2iz+0x3c>
    bc96:	ea4f 23c1 	mov.w	r3, r1, lsl #11
    bc9a:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
    bc9e:	ea43 5350 	orr.w	r3, r3, r0, lsr #21
    bca2:	f011 4f00 	tst.w	r1, #2147483648	; 0x80000000
    bca6:	fa23 f002 	lsr.w	r0, r3, r2
    bcaa:	bf18      	it	ne
    bcac:	4240      	negne	r0, r0
    bcae:	4770      	bx	lr
    bcb0:	f04f 0000 	mov.w	r0, #0
    bcb4:	4770      	bx	lr
    bcb6:	ea50 3001 	orrs.w	r0, r0, r1, lsl #12
    bcba:	d105      	bne.n	bcc8 <__aeabi_d2iz+0x48>
    bcbc:	f011 4000 	ands.w	r0, r1, #2147483648	; 0x80000000
    bcc0:	bf08      	it	eq
    bcc2:	f06f 4000 	mvneq.w	r0, #2147483648	; 0x80000000
    bcc6:	4770      	bx	lr
    bcc8:	f04f 0000 	mov.w	r0, #0
    bccc:	4770      	bx	lr
    bcce:	bf00      	nop

0000bcd0 <__aeabi_d2uiz>:
    bcd0:	004a      	lsls	r2, r1, #1
    bcd2:	d211      	bcs.n	bcf8 <__aeabi_d2uiz+0x28>
    bcd4:	f512 1200 	adds.w	r2, r2, #2097152	; 0x200000
    bcd8:	d211      	bcs.n	bcfe <__aeabi_d2uiz+0x2e>
    bcda:	d50d      	bpl.n	bcf8 <__aeabi_d2uiz+0x28>
    bcdc:	f46f 7378 	mvn.w	r3, #992	; 0x3e0
    bce0:	ebb3 5262 	subs.w	r2, r3, r2, asr #21
    bce4:	d40e      	bmi.n	bd04 <__aeabi_d2uiz+0x34>
    bce6:	ea4f 23c1 	mov.w	r3, r1, lsl #11
    bcea:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
    bcee:	ea43 5350 	orr.w	r3, r3, r0, lsr #21
    bcf2:	fa23 f002 	lsr.w	r0, r3, r2
    bcf6:	4770      	bx	lr
    bcf8:	f04f 0000 	mov.w	r0, #0
    bcfc:	4770      	bx	lr
    bcfe:	ea50 3001 	orrs.w	r0, r0, r1, lsl #12
    bd02:	d102      	bne.n	bd0a <__aeabi_d2uiz+0x3a>
    bd04:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    bd08:	4770      	bx	lr
    bd0a:	f04f 0000 	mov.w	r0, #0
    bd0e:	4770      	bx	lr

0000bd10 <__aeabi_uldivmod>:
    bd10:	b953      	cbnz	r3, bd28 <__aeabi_uldivmod+0x18>
    bd12:	b94a      	cbnz	r2, bd28 <__aeabi_uldivmod+0x18>
    bd14:	2900      	cmp	r1, #0
    bd16:	bf08      	it	eq
    bd18:	2800      	cmpeq	r0, #0
    bd1a:	bf1c      	itt	ne
    bd1c:	f04f 31ff 	movne.w	r1, #4294967295	; 0xffffffff
    bd20:	f04f 30ff 	movne.w	r0, #4294967295	; 0xffffffff
    bd24:	f000 b974 	b.w	c010 <__aeabi_idiv0>
    bd28:	f1ad 0c08 	sub.w	ip, sp, #8
    bd2c:	e96d ce04 	strd	ip, lr, [sp, #-16]!
    bd30:	f000 f806 	bl	bd40 <__udivmoddi4>
    bd34:	f8dd e004 	ldr.w	lr, [sp, #4]
    bd38:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
    bd3c:	b004      	add	sp, #16
    bd3e:	4770      	bx	lr

0000bd40 <__udivmoddi4>:
    bd40:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    bd44:	9e08      	ldr	r6, [sp, #32]
    bd46:	460d      	mov	r5, r1
    bd48:	4604      	mov	r4, r0
    bd4a:	4688      	mov	r8, r1
    bd4c:	2b00      	cmp	r3, #0
    bd4e:	d14d      	bne.n	bdec <__udivmoddi4+0xac>
    bd50:	428a      	cmp	r2, r1
    bd52:	4694      	mov	ip, r2
    bd54:	d968      	bls.n	be28 <__udivmoddi4+0xe8>
    bd56:	fab2 f282 	clz	r2, r2
    bd5a:	b152      	cbz	r2, bd72 <__udivmoddi4+0x32>
    bd5c:	fa01 f302 	lsl.w	r3, r1, r2
    bd60:	f1c2 0120 	rsb	r1, r2, #32
    bd64:	fa20 f101 	lsr.w	r1, r0, r1
    bd68:	fa0c fc02 	lsl.w	ip, ip, r2
    bd6c:	ea41 0803 	orr.w	r8, r1, r3
    bd70:	4094      	lsls	r4, r2
    bd72:	ea4f 451c 	mov.w	r5, ip, lsr #16
    bd76:	0c21      	lsrs	r1, r4, #16
    bd78:	fbb8 fef5 	udiv	lr, r8, r5
    bd7c:	fa1f f78c 	uxth.w	r7, ip
    bd80:	fb05 831e 	mls	r3, r5, lr, r8
    bd84:	ea41 4303 	orr.w	r3, r1, r3, lsl #16
    bd88:	fb0e f107 	mul.w	r1, lr, r7
    bd8c:	4299      	cmp	r1, r3
    bd8e:	d90b      	bls.n	bda8 <__udivmoddi4+0x68>
    bd90:	eb1c 0303 	adds.w	r3, ip, r3
    bd94:	f10e 30ff 	add.w	r0, lr, #4294967295	; 0xffffffff
    bd98:	f080 811e 	bcs.w	bfd8 <__udivmoddi4+0x298>
    bd9c:	4299      	cmp	r1, r3
    bd9e:	f240 811b 	bls.w	bfd8 <__udivmoddi4+0x298>
    bda2:	f1ae 0e02 	sub.w	lr, lr, #2
    bda6:	4463      	add	r3, ip
    bda8:	1a5b      	subs	r3, r3, r1
    bdaa:	b2a4      	uxth	r4, r4
    bdac:	fbb3 f0f5 	udiv	r0, r3, r5
    bdb0:	fb05 3310 	mls	r3, r5, r0, r3
    bdb4:	ea44 4403 	orr.w	r4, r4, r3, lsl #16
    bdb8:	fb00 f707 	mul.w	r7, r0, r7
    bdbc:	42a7      	cmp	r7, r4
    bdbe:	d90a      	bls.n	bdd6 <__udivmoddi4+0x96>
    bdc0:	eb1c 0404 	adds.w	r4, ip, r4
    bdc4:	f100 33ff 	add.w	r3, r0, #4294967295	; 0xffffffff
    bdc8:	f080 8108 	bcs.w	bfdc <__udivmoddi4+0x29c>
    bdcc:	42a7      	cmp	r7, r4
    bdce:	f240 8105 	bls.w	bfdc <__udivmoddi4+0x29c>
    bdd2:	4464      	add	r4, ip
    bdd4:	3802      	subs	r0, #2
    bdd6:	1be4      	subs	r4, r4, r7
    bdd8:	ea40 400e 	orr.w	r0, r0, lr, lsl #16
    bddc:	2100      	movs	r1, #0
    bdde:	b11e      	cbz	r6, bde8 <__udivmoddi4+0xa8>
    bde0:	40d4      	lsrs	r4, r2
    bde2:	2300      	movs	r3, #0
    bde4:	e9c6 4300 	strd	r4, r3, [r6]
    bde8:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    bdec:	428b      	cmp	r3, r1
    bdee:	d908      	bls.n	be02 <__udivmoddi4+0xc2>
    bdf0:	2e00      	cmp	r6, #0
    bdf2:	f000 80ee 	beq.w	bfd2 <__udivmoddi4+0x292>
    bdf6:	2100      	movs	r1, #0
    bdf8:	e9c6 0500 	strd	r0, r5, [r6]
    bdfc:	4608      	mov	r0, r1
    bdfe:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    be02:	fab3 f183 	clz	r1, r3
    be06:	2900      	cmp	r1, #0
    be08:	d14a      	bne.n	bea0 <__udivmoddi4+0x160>
    be0a:	42ab      	cmp	r3, r5
    be0c:	d302      	bcc.n	be14 <__udivmoddi4+0xd4>
    be0e:	4282      	cmp	r2, r0
    be10:	f200 80f9 	bhi.w	c006 <__udivmoddi4+0x2c6>
    be14:	1a84      	subs	r4, r0, r2
    be16:	eb65 0303 	sbc.w	r3, r5, r3
    be1a:	2001      	movs	r0, #1
    be1c:	4698      	mov	r8, r3
    be1e:	2e00      	cmp	r6, #0
    be20:	d0e2      	beq.n	bde8 <__udivmoddi4+0xa8>
    be22:	e9c6 4800 	strd	r4, r8, [r6]
    be26:	e7df      	b.n	bde8 <__udivmoddi4+0xa8>
    be28:	b902      	cbnz	r2, be2c <__udivmoddi4+0xec>
    be2a:	deff      	udf	#255	; 0xff
    be2c:	fab2 f282 	clz	r2, r2
    be30:	2a00      	cmp	r2, #0
    be32:	f040 8091 	bne.w	bf58 <__udivmoddi4+0x218>
    be36:	eba1 050c 	sub.w	r5, r1, ip
    be3a:	ea4f 471c 	mov.w	r7, ip, lsr #16
    be3e:	fa1f fe8c 	uxth.w	lr, ip
    be42:	2101      	movs	r1, #1
    be44:	fbb5 f3f7 	udiv	r3, r5, r7
    be48:	fb07 5013 	mls	r0, r7, r3, r5
    be4c:	0c25      	lsrs	r5, r4, #16
    be4e:	ea45 4500 	orr.w	r5, r5, r0, lsl #16
    be52:	fb0e f003 	mul.w	r0, lr, r3
    be56:	42a8      	cmp	r0, r5
    be58:	d908      	bls.n	be6c <__udivmoddi4+0x12c>
    be5a:	eb1c 0505 	adds.w	r5, ip, r5
    be5e:	f103 38ff 	add.w	r8, r3, #4294967295	; 0xffffffff
    be62:	d202      	bcs.n	be6a <__udivmoddi4+0x12a>
    be64:	42a8      	cmp	r0, r5
    be66:	f200 80cb 	bhi.w	c000 <__udivmoddi4+0x2c0>
    be6a:	4643      	mov	r3, r8
    be6c:	1a2d      	subs	r5, r5, r0
    be6e:	b2a4      	uxth	r4, r4
    be70:	fbb5 f0f7 	udiv	r0, r5, r7
    be74:	fb07 5510 	mls	r5, r7, r0, r5
    be78:	ea44 4405 	orr.w	r4, r4, r5, lsl #16
    be7c:	fb0e fe00 	mul.w	lr, lr, r0
    be80:	45a6      	cmp	lr, r4
    be82:	d908      	bls.n	be96 <__udivmoddi4+0x156>
    be84:	eb1c 0404 	adds.w	r4, ip, r4
    be88:	f100 35ff 	add.w	r5, r0, #4294967295	; 0xffffffff
    be8c:	d202      	bcs.n	be94 <__udivmoddi4+0x154>
    be8e:	45a6      	cmp	lr, r4
    be90:	f200 80bb 	bhi.w	c00a <__udivmoddi4+0x2ca>
    be94:	4628      	mov	r0, r5
    be96:	eba4 040e 	sub.w	r4, r4, lr
    be9a:	ea40 4003 	orr.w	r0, r0, r3, lsl #16
    be9e:	e79e      	b.n	bdde <__udivmoddi4+0x9e>
    bea0:	f1c1 0720 	rsb	r7, r1, #32
    bea4:	408b      	lsls	r3, r1
    bea6:	fa22 fc07 	lsr.w	ip, r2, r7
    beaa:	ea4c 0c03 	orr.w	ip, ip, r3
    beae:	fa20 f407 	lsr.w	r4, r0, r7
    beb2:	fa05 f301 	lsl.w	r3, r5, r1
    beb6:	431c      	orrs	r4, r3
    beb8:	40fd      	lsrs	r5, r7
    beba:	ea4f 491c 	mov.w	r9, ip, lsr #16
    bebe:	fa00 f301 	lsl.w	r3, r0, r1
    bec2:	fbb5 f8f9 	udiv	r8, r5, r9
    bec6:	0c20      	lsrs	r0, r4, #16
    bec8:	fa1f fe8c 	uxth.w	lr, ip
    becc:	fb09 5518 	mls	r5, r9, r8, r5
    bed0:	ea40 4505 	orr.w	r5, r0, r5, lsl #16
    bed4:	fb08 f00e 	mul.w	r0, r8, lr
    bed8:	42a8      	cmp	r0, r5
    beda:	fa02 f201 	lsl.w	r2, r2, r1
    bede:	d90b      	bls.n	bef8 <__udivmoddi4+0x1b8>
    bee0:	eb1c 0505 	adds.w	r5, ip, r5
    bee4:	f108 3aff 	add.w	sl, r8, #4294967295	; 0xffffffff
    bee8:	f080 8088 	bcs.w	bffc <__udivmoddi4+0x2bc>
    beec:	42a8      	cmp	r0, r5
    beee:	f240 8085 	bls.w	bffc <__udivmoddi4+0x2bc>
    bef2:	f1a8 0802 	sub.w	r8, r8, #2
    bef6:	4465      	add	r5, ip
    bef8:	1a2d      	subs	r5, r5, r0
    befa:	b2a4      	uxth	r4, r4
    befc:	fbb5 f0f9 	udiv	r0, r5, r9
    bf00:	fb09 5510 	mls	r5, r9, r0, r5
    bf04:	ea44 4505 	orr.w	r5, r4, r5, lsl #16
    bf08:	fb00 fe0e 	mul.w	lr, r0, lr
    bf0c:	45ae      	cmp	lr, r5
    bf0e:	d908      	bls.n	bf22 <__udivmoddi4+0x1e2>
    bf10:	eb1c 0505 	adds.w	r5, ip, r5
    bf14:	f100 34ff 	add.w	r4, r0, #4294967295	; 0xffffffff
    bf18:	d26c      	bcs.n	bff4 <__udivmoddi4+0x2b4>
    bf1a:	45ae      	cmp	lr, r5
    bf1c:	d96a      	bls.n	bff4 <__udivmoddi4+0x2b4>
    bf1e:	3802      	subs	r0, #2
    bf20:	4465      	add	r5, ip
    bf22:	ea40 4008 	orr.w	r0, r0, r8, lsl #16
    bf26:	fba0 9402 	umull	r9, r4, r0, r2
    bf2a:	eba5 050e 	sub.w	r5, r5, lr
    bf2e:	42a5      	cmp	r5, r4
    bf30:	46c8      	mov	r8, r9
    bf32:	46a6      	mov	lr, r4
    bf34:	d356      	bcc.n	bfe4 <__udivmoddi4+0x2a4>
    bf36:	d053      	beq.n	bfe0 <__udivmoddi4+0x2a0>
    bf38:	b15e      	cbz	r6, bf52 <__udivmoddi4+0x212>
    bf3a:	ebb3 0208 	subs.w	r2, r3, r8
    bf3e:	eb65 050e 	sbc.w	r5, r5, lr
    bf42:	fa05 f707 	lsl.w	r7, r5, r7
    bf46:	fa22 f301 	lsr.w	r3, r2, r1
    bf4a:	40cd      	lsrs	r5, r1
    bf4c:	431f      	orrs	r7, r3
    bf4e:	e9c6 7500 	strd	r7, r5, [r6]
    bf52:	2100      	movs	r1, #0
    bf54:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    bf58:	f1c2 0320 	rsb	r3, r2, #32
    bf5c:	fa20 f103 	lsr.w	r1, r0, r3
    bf60:	fa0c fc02 	lsl.w	ip, ip, r2
    bf64:	fa25 f303 	lsr.w	r3, r5, r3
    bf68:	4095      	lsls	r5, r2
    bf6a:	430d      	orrs	r5, r1
    bf6c:	ea4f 471c 	mov.w	r7, ip, lsr #16
    bf70:	fa1f fe8c 	uxth.w	lr, ip
    bf74:	fbb3 f1f7 	udiv	r1, r3, r7
    bf78:	fb07 3011 	mls	r0, r7, r1, r3
    bf7c:	0c2b      	lsrs	r3, r5, #16
    bf7e:	ea43 4300 	orr.w	r3, r3, r0, lsl #16
    bf82:	fb01 f00e 	mul.w	r0, r1, lr
    bf86:	4298      	cmp	r0, r3
    bf88:	fa04 f402 	lsl.w	r4, r4, r2
    bf8c:	d908      	bls.n	bfa0 <__udivmoddi4+0x260>
    bf8e:	eb1c 0303 	adds.w	r3, ip, r3
    bf92:	f101 38ff 	add.w	r8, r1, #4294967295	; 0xffffffff
    bf96:	d22f      	bcs.n	bff8 <__udivmoddi4+0x2b8>
    bf98:	4298      	cmp	r0, r3
    bf9a:	d92d      	bls.n	bff8 <__udivmoddi4+0x2b8>
    bf9c:	3902      	subs	r1, #2
    bf9e:	4463      	add	r3, ip
    bfa0:	1a1b      	subs	r3, r3, r0
    bfa2:	b2ad      	uxth	r5, r5
    bfa4:	fbb3 f0f7 	udiv	r0, r3, r7
    bfa8:	fb07 3310 	mls	r3, r7, r0, r3
    bfac:	ea45 4503 	orr.w	r5, r5, r3, lsl #16
    bfb0:	fb00 f30e 	mul.w	r3, r0, lr
    bfb4:	42ab      	cmp	r3, r5
    bfb6:	d908      	bls.n	bfca <__udivmoddi4+0x28a>
    bfb8:	eb1c 0505 	adds.w	r5, ip, r5
    bfbc:	f100 38ff 	add.w	r8, r0, #4294967295	; 0xffffffff
    bfc0:	d216      	bcs.n	bff0 <__udivmoddi4+0x2b0>
    bfc2:	42ab      	cmp	r3, r5
    bfc4:	d914      	bls.n	bff0 <__udivmoddi4+0x2b0>
    bfc6:	3802      	subs	r0, #2
    bfc8:	4465      	add	r5, ip
    bfca:	1aed      	subs	r5, r5, r3
    bfcc:	ea40 4101 	orr.w	r1, r0, r1, lsl #16
    bfd0:	e738      	b.n	be44 <__udivmoddi4+0x104>
    bfd2:	4631      	mov	r1, r6
    bfd4:	4630      	mov	r0, r6
    bfd6:	e707      	b.n	bde8 <__udivmoddi4+0xa8>
    bfd8:	4686      	mov	lr, r0
    bfda:	e6e5      	b.n	bda8 <__udivmoddi4+0x68>
    bfdc:	4618      	mov	r0, r3
    bfde:	e6fa      	b.n	bdd6 <__udivmoddi4+0x96>
    bfe0:	454b      	cmp	r3, r9
    bfe2:	d2a9      	bcs.n	bf38 <__udivmoddi4+0x1f8>
    bfe4:	ebb9 0802 	subs.w	r8, r9, r2
    bfe8:	eb64 0e0c 	sbc.w	lr, r4, ip
    bfec:	3801      	subs	r0, #1
    bfee:	e7a3      	b.n	bf38 <__udivmoddi4+0x1f8>
    bff0:	4640      	mov	r0, r8
    bff2:	e7ea      	b.n	bfca <__udivmoddi4+0x28a>
    bff4:	4620      	mov	r0, r4
    bff6:	e794      	b.n	bf22 <__udivmoddi4+0x1e2>
    bff8:	4641      	mov	r1, r8
    bffa:	e7d1      	b.n	bfa0 <__udivmoddi4+0x260>
    bffc:	46d0      	mov	r8, sl
    bffe:	e77b      	b.n	bef8 <__udivmoddi4+0x1b8>
    c000:	3b02      	subs	r3, #2
    c002:	4465      	add	r5, ip
    c004:	e732      	b.n	be6c <__udivmoddi4+0x12c>
    c006:	4608      	mov	r0, r1
    c008:	e709      	b.n	be1e <__udivmoddi4+0xde>
    c00a:	4464      	add	r4, ip
    c00c:	3802      	subs	r0, #2
    c00e:	e742      	b.n	be96 <__udivmoddi4+0x156>

0000c010 <__aeabi_idiv0>:
    c010:	4770      	bx	lr
    c012:	bf00      	nop

0000c014 <__libc_init_array>:
    c014:	b570      	push	{r4, r5, r6, lr}
    c016:	4d0d      	ldr	r5, [pc, #52]	; (c04c <__libc_init_array+0x38>)
    c018:	4c0d      	ldr	r4, [pc, #52]	; (c050 <__libc_init_array+0x3c>)
    c01a:	1b64      	subs	r4, r4, r5
    c01c:	10a4      	asrs	r4, r4, #2
    c01e:	2600      	movs	r6, #0
    c020:	42a6      	cmp	r6, r4
    c022:	d109      	bne.n	c038 <__libc_init_array+0x24>
    c024:	4d0b      	ldr	r5, [pc, #44]	; (c054 <__libc_init_array+0x40>)
    c026:	4c0c      	ldr	r4, [pc, #48]	; (c058 <__libc_init_array+0x44>)
    c028:	f000 fee0 	bl	cdec <_init>
    c02c:	1b64      	subs	r4, r4, r5
    c02e:	10a4      	asrs	r4, r4, #2
    c030:	2600      	movs	r6, #0
    c032:	42a6      	cmp	r6, r4
    c034:	d105      	bne.n	c042 <__libc_init_array+0x2e>
    c036:	bd70      	pop	{r4, r5, r6, pc}
    c038:	f855 3b04 	ldr.w	r3, [r5], #4
    c03c:	4798      	blx	r3
    c03e:	3601      	adds	r6, #1
    c040:	e7ee      	b.n	c020 <__libc_init_array+0xc>
    c042:	f855 3b04 	ldr.w	r3, [r5], #4
    c046:	4798      	blx	r3
    c048:	3601      	adds	r6, #1
    c04a:	e7f2      	b.n	c032 <__libc_init_array+0x1e>
    c04c:	0000cdf8 	.word	0x0000cdf8
    c050:	0000cdf8 	.word	0x0000cdf8
    c054:	0000cdf8 	.word	0x0000cdf8
    c058:	0000cdfc 	.word	0x0000cdfc

0000c05c <memcmp>:
    c05c:	b510      	push	{r4, lr}
    c05e:	3901      	subs	r1, #1
    c060:	4402      	add	r2, r0
    c062:	4290      	cmp	r0, r2
    c064:	d101      	bne.n	c06a <memcmp+0xe>
    c066:	2000      	movs	r0, #0
    c068:	e005      	b.n	c076 <memcmp+0x1a>
    c06a:	7803      	ldrb	r3, [r0, #0]
    c06c:	f811 4f01 	ldrb.w	r4, [r1, #1]!
    c070:	42a3      	cmp	r3, r4
    c072:	d001      	beq.n	c078 <memcmp+0x1c>
    c074:	1b18      	subs	r0, r3, r4
    c076:	bd10      	pop	{r4, pc}
    c078:	3001      	adds	r0, #1
    c07a:	e7f2      	b.n	c062 <memcmp+0x6>

0000c07c <memcpy>:
    c07c:	440a      	add	r2, r1
    c07e:	4291      	cmp	r1, r2
    c080:	f100 33ff 	add.w	r3, r0, #4294967295	; 0xffffffff
    c084:	d100      	bne.n	c088 <memcpy+0xc>
    c086:	4770      	bx	lr
    c088:	b510      	push	{r4, lr}
    c08a:	f811 4b01 	ldrb.w	r4, [r1], #1
    c08e:	f803 4f01 	strb.w	r4, [r3, #1]!
    c092:	4291      	cmp	r1, r2
    c094:	d1f9      	bne.n	c08a <memcpy+0xe>
    c096:	bd10      	pop	{r4, pc}

0000c098 <memset>:
    c098:	4402      	add	r2, r0
    c09a:	4603      	mov	r3, r0
    c09c:	4293      	cmp	r3, r2
    c09e:	d100      	bne.n	c0a2 <memset+0xa>
    c0a0:	4770      	bx	lr
    c0a2:	f803 1b01 	strb.w	r1, [r3], #1
    c0a6:	e7f9      	b.n	c09c <memset+0x4>

0000c0a8 <setbuf>:
    c0a8:	2900      	cmp	r1, #0
    c0aa:	f44f 6380 	mov.w	r3, #1024	; 0x400
    c0ae:	bf0c      	ite	eq
    c0b0:	2202      	moveq	r2, #2
    c0b2:	2200      	movne	r2, #0
    c0b4:	f000 b800 	b.w	c0b8 <setvbuf>

0000c0b8 <setvbuf>:
    c0b8:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
    c0bc:	461d      	mov	r5, r3
    c0be:	4b5d      	ldr	r3, [pc, #372]	; (c234 <setvbuf+0x17c>)
    c0c0:	681f      	ldr	r7, [r3, #0]
    c0c2:	4604      	mov	r4, r0
    c0c4:	460e      	mov	r6, r1
    c0c6:	4690      	mov	r8, r2
    c0c8:	b127      	cbz	r7, c0d4 <setvbuf+0x1c>
    c0ca:	69bb      	ldr	r3, [r7, #24]
    c0cc:	b913      	cbnz	r3, c0d4 <setvbuf+0x1c>
    c0ce:	4638      	mov	r0, r7
    c0d0:	f000 f9e2 	bl	c498 <__sinit>
    c0d4:	4b58      	ldr	r3, [pc, #352]	; (c238 <setvbuf+0x180>)
    c0d6:	429c      	cmp	r4, r3
    c0d8:	d167      	bne.n	c1aa <setvbuf+0xf2>
    c0da:	687c      	ldr	r4, [r7, #4]
    c0dc:	f1b8 0f02 	cmp.w	r8, #2
    c0e0:	d006      	beq.n	c0f0 <setvbuf+0x38>
    c0e2:	f1b8 0f01 	cmp.w	r8, #1
    c0e6:	f200 809f 	bhi.w	c228 <setvbuf+0x170>
    c0ea:	2d00      	cmp	r5, #0
    c0ec:	f2c0 809c 	blt.w	c228 <setvbuf+0x170>
    c0f0:	6e63      	ldr	r3, [r4, #100]	; 0x64
    c0f2:	07db      	lsls	r3, r3, #31
    c0f4:	d405      	bmi.n	c102 <setvbuf+0x4a>
    c0f6:	89a3      	ldrh	r3, [r4, #12]
    c0f8:	0598      	lsls	r0, r3, #22
    c0fa:	d402      	bmi.n	c102 <setvbuf+0x4a>
    c0fc:	6da0      	ldr	r0, [r4, #88]	; 0x58
    c0fe:	f000 fa69 	bl	c5d4 <__retarget_lock_acquire_recursive>
    c102:	4621      	mov	r1, r4
    c104:	4638      	mov	r0, r7
    c106:	f000 f933 	bl	c370 <_fflush_r>
    c10a:	6b61      	ldr	r1, [r4, #52]	; 0x34
    c10c:	b141      	cbz	r1, c120 <setvbuf+0x68>
    c10e:	f104 0344 	add.w	r3, r4, #68	; 0x44
    c112:	4299      	cmp	r1, r3
    c114:	d002      	beq.n	c11c <setvbuf+0x64>
    c116:	4638      	mov	r0, r7
    c118:	f000 fa8c 	bl	c634 <_free_r>
    c11c:	2300      	movs	r3, #0
    c11e:	6363      	str	r3, [r4, #52]	; 0x34
    c120:	2300      	movs	r3, #0
    c122:	61a3      	str	r3, [r4, #24]
    c124:	6063      	str	r3, [r4, #4]
    c126:	89a3      	ldrh	r3, [r4, #12]
    c128:	0619      	lsls	r1, r3, #24
    c12a:	d503      	bpl.n	c134 <setvbuf+0x7c>
    c12c:	6921      	ldr	r1, [r4, #16]
    c12e:	4638      	mov	r0, r7
    c130:	f000 fa80 	bl	c634 <_free_r>
    c134:	89a3      	ldrh	r3, [r4, #12]
    c136:	f423 634a 	bic.w	r3, r3, #3232	; 0xca0
    c13a:	f023 0303 	bic.w	r3, r3, #3
    c13e:	f1b8 0f02 	cmp.w	r8, #2
    c142:	81a3      	strh	r3, [r4, #12]
    c144:	d06c      	beq.n	c220 <setvbuf+0x168>
    c146:	ab01      	add	r3, sp, #4
    c148:	466a      	mov	r2, sp
    c14a:	4621      	mov	r1, r4
    c14c:	4638      	mov	r0, r7
    c14e:	f000 fa43 	bl	c5d8 <__swhatbuf_r>
    c152:	89a3      	ldrh	r3, [r4, #12]
    c154:	4318      	orrs	r0, r3
    c156:	81a0      	strh	r0, [r4, #12]
    c158:	2d00      	cmp	r5, #0
    c15a:	d130      	bne.n	c1be <setvbuf+0x106>
    c15c:	9d00      	ldr	r5, [sp, #0]
    c15e:	4628      	mov	r0, r5
    c160:	f000 fa60 	bl	c624 <malloc>
    c164:	4606      	mov	r6, r0
    c166:	2800      	cmp	r0, #0
    c168:	d155      	bne.n	c216 <setvbuf+0x15e>
    c16a:	f8dd 9000 	ldr.w	r9, [sp]
    c16e:	45a9      	cmp	r9, r5
    c170:	d14a      	bne.n	c208 <setvbuf+0x150>
    c172:	f04f 35ff 	mov.w	r5, #4294967295	; 0xffffffff
    c176:	2200      	movs	r2, #0
    c178:	60a2      	str	r2, [r4, #8]
    c17a:	f104 0247 	add.w	r2, r4, #71	; 0x47
    c17e:	6022      	str	r2, [r4, #0]
    c180:	6122      	str	r2, [r4, #16]
    c182:	2201      	movs	r2, #1
    c184:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
    c188:	6162      	str	r2, [r4, #20]
    c18a:	6e62      	ldr	r2, [r4, #100]	; 0x64
    c18c:	f043 0302 	orr.w	r3, r3, #2
    c190:	07d2      	lsls	r2, r2, #31
    c192:	81a3      	strh	r3, [r4, #12]
    c194:	d405      	bmi.n	c1a2 <setvbuf+0xea>
    c196:	f413 7f00 	tst.w	r3, #512	; 0x200
    c19a:	d102      	bne.n	c1a2 <setvbuf+0xea>
    c19c:	6da0      	ldr	r0, [r4, #88]	; 0x58
    c19e:	f000 fa1a 	bl	c5d6 <__retarget_lock_release_recursive>
    c1a2:	4628      	mov	r0, r5
    c1a4:	b003      	add	sp, #12
    c1a6:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    c1aa:	4b24      	ldr	r3, [pc, #144]	; (c23c <setvbuf+0x184>)
    c1ac:	429c      	cmp	r4, r3
    c1ae:	d101      	bne.n	c1b4 <setvbuf+0xfc>
    c1b0:	68bc      	ldr	r4, [r7, #8]
    c1b2:	e793      	b.n	c0dc <setvbuf+0x24>
    c1b4:	4b22      	ldr	r3, [pc, #136]	; (c240 <setvbuf+0x188>)
    c1b6:	429c      	cmp	r4, r3
    c1b8:	bf08      	it	eq
    c1ba:	68fc      	ldreq	r4, [r7, #12]
    c1bc:	e78e      	b.n	c0dc <setvbuf+0x24>
    c1be:	2e00      	cmp	r6, #0
    c1c0:	d0cd      	beq.n	c15e <setvbuf+0xa6>
    c1c2:	69bb      	ldr	r3, [r7, #24]
    c1c4:	b913      	cbnz	r3, c1cc <setvbuf+0x114>
    c1c6:	4638      	mov	r0, r7
    c1c8:	f000 f966 	bl	c498 <__sinit>
    c1cc:	f1b8 0f01 	cmp.w	r8, #1
    c1d0:	bf08      	it	eq
    c1d2:	89a3      	ldrheq	r3, [r4, #12]
    c1d4:	6026      	str	r6, [r4, #0]
    c1d6:	bf04      	itt	eq
    c1d8:	f043 0301 	orreq.w	r3, r3, #1
    c1dc:	81a3      	strheq	r3, [r4, #12]
    c1de:	89a2      	ldrh	r2, [r4, #12]
    c1e0:	f012 0308 	ands.w	r3, r2, #8
    c1e4:	e9c4 6504 	strd	r6, r5, [r4, #16]
    c1e8:	d01c      	beq.n	c224 <setvbuf+0x16c>
    c1ea:	07d3      	lsls	r3, r2, #31
    c1ec:	bf41      	itttt	mi
    c1ee:	2300      	movmi	r3, #0
    c1f0:	426d      	negmi	r5, r5
    c1f2:	60a3      	strmi	r3, [r4, #8]
    c1f4:	61a5      	strmi	r5, [r4, #24]
    c1f6:	bf58      	it	pl
    c1f8:	60a5      	strpl	r5, [r4, #8]
    c1fa:	6e65      	ldr	r5, [r4, #100]	; 0x64
    c1fc:	f015 0501 	ands.w	r5, r5, #1
    c200:	d115      	bne.n	c22e <setvbuf+0x176>
    c202:	f412 7f00 	tst.w	r2, #512	; 0x200
    c206:	e7c8      	b.n	c19a <setvbuf+0xe2>
    c208:	4648      	mov	r0, r9
    c20a:	f000 fa0b 	bl	c624 <malloc>
    c20e:	4606      	mov	r6, r0
    c210:	2800      	cmp	r0, #0
    c212:	d0ae      	beq.n	c172 <setvbuf+0xba>
    c214:	464d      	mov	r5, r9
    c216:	89a3      	ldrh	r3, [r4, #12]
    c218:	f043 0380 	orr.w	r3, r3, #128	; 0x80
    c21c:	81a3      	strh	r3, [r4, #12]
    c21e:	e7d0      	b.n	c1c2 <setvbuf+0x10a>
    c220:	2500      	movs	r5, #0
    c222:	e7a8      	b.n	c176 <setvbuf+0xbe>
    c224:	60a3      	str	r3, [r4, #8]
    c226:	e7e8      	b.n	c1fa <setvbuf+0x142>
    c228:	f04f 35ff 	mov.w	r5, #4294967295	; 0xffffffff
    c22c:	e7b9      	b.n	c1a2 <setvbuf+0xea>
    c22e:	2500      	movs	r5, #0
    c230:	e7b7      	b.n	c1a2 <setvbuf+0xea>
    c232:	bf00      	nop
    c234:	2000001c 	.word	0x2000001c
    c238:	0000cdac 	.word	0x0000cdac
    c23c:	0000cdcc 	.word	0x0000cdcc
    c240:	0000cd8c 	.word	0x0000cd8c

0000c244 <strncmp>:
    c244:	b510      	push	{r4, lr}
    c246:	4603      	mov	r3, r0
    c248:	b172      	cbz	r2, c268 <strncmp+0x24>
    c24a:	3901      	subs	r1, #1
    c24c:	1884      	adds	r4, r0, r2
    c24e:	f813 0b01 	ldrb.w	r0, [r3], #1
    c252:	f811 2f01 	ldrb.w	r2, [r1, #1]!
    c256:	4290      	cmp	r0, r2
    c258:	d101      	bne.n	c25e <strncmp+0x1a>
    c25a:	42a3      	cmp	r3, r4
    c25c:	d101      	bne.n	c262 <strncmp+0x1e>
    c25e:	1a80      	subs	r0, r0, r2
    c260:	bd10      	pop	{r4, pc}
    c262:	2800      	cmp	r0, #0
    c264:	d1f3      	bne.n	c24e <strncmp+0xa>
    c266:	e7fa      	b.n	c25e <strncmp+0x1a>
    c268:	4610      	mov	r0, r2
    c26a:	e7f9      	b.n	c260 <strncmp+0x1c>

0000c26c <__sflush_r>:
    c26c:	898a      	ldrh	r2, [r1, #12]
    c26e:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    c270:	4605      	mov	r5, r0
    c272:	0710      	lsls	r0, r2, #28
    c274:	460c      	mov	r4, r1
    c276:	d457      	bmi.n	c328 <__sflush_r+0xbc>
    c278:	684b      	ldr	r3, [r1, #4]
    c27a:	2b00      	cmp	r3, #0
    c27c:	dc04      	bgt.n	c288 <__sflush_r+0x1c>
    c27e:	6c0b      	ldr	r3, [r1, #64]	; 0x40
    c280:	2b00      	cmp	r3, #0
    c282:	dc01      	bgt.n	c288 <__sflush_r+0x1c>
    c284:	2000      	movs	r0, #0
    c286:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    c288:	6ae6      	ldr	r6, [r4, #44]	; 0x2c
    c28a:	2e00      	cmp	r6, #0
    c28c:	d0fa      	beq.n	c284 <__sflush_r+0x18>
    c28e:	2300      	movs	r3, #0
    c290:	f412 5280 	ands.w	r2, r2, #4096	; 0x1000
    c294:	682f      	ldr	r7, [r5, #0]
    c296:	602b      	str	r3, [r5, #0]
    c298:	d032      	beq.n	c300 <__sflush_r+0x94>
    c29a:	6d60      	ldr	r0, [r4, #84]	; 0x54
    c29c:	89a3      	ldrh	r3, [r4, #12]
    c29e:	075a      	lsls	r2, r3, #29
    c2a0:	d505      	bpl.n	c2ae <__sflush_r+0x42>
    c2a2:	6863      	ldr	r3, [r4, #4]
    c2a4:	1ac0      	subs	r0, r0, r3
    c2a6:	6b63      	ldr	r3, [r4, #52]	; 0x34
    c2a8:	b10b      	cbz	r3, c2ae <__sflush_r+0x42>
    c2aa:	6c23      	ldr	r3, [r4, #64]	; 0x40
    c2ac:	1ac0      	subs	r0, r0, r3
    c2ae:	2300      	movs	r3, #0
    c2b0:	4602      	mov	r2, r0
    c2b2:	6ae6      	ldr	r6, [r4, #44]	; 0x2c
    c2b4:	6a21      	ldr	r1, [r4, #32]
    c2b6:	4628      	mov	r0, r5
    c2b8:	47b0      	blx	r6
    c2ba:	1c43      	adds	r3, r0, #1
    c2bc:	89a3      	ldrh	r3, [r4, #12]
    c2be:	d106      	bne.n	c2ce <__sflush_r+0x62>
    c2c0:	6829      	ldr	r1, [r5, #0]
    c2c2:	291d      	cmp	r1, #29
    c2c4:	d82c      	bhi.n	c320 <__sflush_r+0xb4>
    c2c6:	4a29      	ldr	r2, [pc, #164]	; (c36c <__sflush_r+0x100>)
    c2c8:	40ca      	lsrs	r2, r1
    c2ca:	07d6      	lsls	r6, r2, #31
    c2cc:	d528      	bpl.n	c320 <__sflush_r+0xb4>
    c2ce:	2200      	movs	r2, #0
    c2d0:	6062      	str	r2, [r4, #4]
    c2d2:	04d9      	lsls	r1, r3, #19
    c2d4:	6922      	ldr	r2, [r4, #16]
    c2d6:	6022      	str	r2, [r4, #0]
    c2d8:	d504      	bpl.n	c2e4 <__sflush_r+0x78>
    c2da:	1c42      	adds	r2, r0, #1
    c2dc:	d101      	bne.n	c2e2 <__sflush_r+0x76>
    c2de:	682b      	ldr	r3, [r5, #0]
    c2e0:	b903      	cbnz	r3, c2e4 <__sflush_r+0x78>
    c2e2:	6560      	str	r0, [r4, #84]	; 0x54
    c2e4:	6b61      	ldr	r1, [r4, #52]	; 0x34
    c2e6:	602f      	str	r7, [r5, #0]
    c2e8:	2900      	cmp	r1, #0
    c2ea:	d0cb      	beq.n	c284 <__sflush_r+0x18>
    c2ec:	f104 0344 	add.w	r3, r4, #68	; 0x44
    c2f0:	4299      	cmp	r1, r3
    c2f2:	d002      	beq.n	c2fa <__sflush_r+0x8e>
    c2f4:	4628      	mov	r0, r5
    c2f6:	f000 f99d 	bl	c634 <_free_r>
    c2fa:	2000      	movs	r0, #0
    c2fc:	6360      	str	r0, [r4, #52]	; 0x34
    c2fe:	e7c2      	b.n	c286 <__sflush_r+0x1a>
    c300:	6a21      	ldr	r1, [r4, #32]
    c302:	2301      	movs	r3, #1
    c304:	4628      	mov	r0, r5
    c306:	47b0      	blx	r6
    c308:	1c41      	adds	r1, r0, #1
    c30a:	d1c7      	bne.n	c29c <__sflush_r+0x30>
    c30c:	682b      	ldr	r3, [r5, #0]
    c30e:	2b00      	cmp	r3, #0
    c310:	d0c4      	beq.n	c29c <__sflush_r+0x30>
    c312:	2b1d      	cmp	r3, #29
    c314:	d001      	beq.n	c31a <__sflush_r+0xae>
    c316:	2b16      	cmp	r3, #22
    c318:	d101      	bne.n	c31e <__sflush_r+0xb2>
    c31a:	602f      	str	r7, [r5, #0]
    c31c:	e7b2      	b.n	c284 <__sflush_r+0x18>
    c31e:	89a3      	ldrh	r3, [r4, #12]
    c320:	f043 0340 	orr.w	r3, r3, #64	; 0x40
    c324:	81a3      	strh	r3, [r4, #12]
    c326:	e7ae      	b.n	c286 <__sflush_r+0x1a>
    c328:	690f      	ldr	r7, [r1, #16]
    c32a:	2f00      	cmp	r7, #0
    c32c:	d0aa      	beq.n	c284 <__sflush_r+0x18>
    c32e:	0793      	lsls	r3, r2, #30
    c330:	680e      	ldr	r6, [r1, #0]
    c332:	bf08      	it	eq
    c334:	694b      	ldreq	r3, [r1, #20]
    c336:	600f      	str	r7, [r1, #0]
    c338:	bf18      	it	ne
    c33a:	2300      	movne	r3, #0
    c33c:	1bf6      	subs	r6, r6, r7
    c33e:	608b      	str	r3, [r1, #8]
    c340:	2e00      	cmp	r6, #0
    c342:	dd9f      	ble.n	c284 <__sflush_r+0x18>
    c344:	6a21      	ldr	r1, [r4, #32]
    c346:	f8d4 c028 	ldr.w	ip, [r4, #40]	; 0x28
    c34a:	4633      	mov	r3, r6
    c34c:	463a      	mov	r2, r7
    c34e:	4628      	mov	r0, r5
    c350:	47e0      	blx	ip
    c352:	2800      	cmp	r0, #0
    c354:	dc06      	bgt.n	c364 <__sflush_r+0xf8>
    c356:	89a3      	ldrh	r3, [r4, #12]
    c358:	f043 0340 	orr.w	r3, r3, #64	; 0x40
    c35c:	81a3      	strh	r3, [r4, #12]
    c35e:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    c362:	e790      	b.n	c286 <__sflush_r+0x1a>
    c364:	4407      	add	r7, r0
    c366:	1a36      	subs	r6, r6, r0
    c368:	e7ea      	b.n	c340 <__sflush_r+0xd4>
    c36a:	bf00      	nop
    c36c:	20400001 	.word	0x20400001

0000c370 <_fflush_r>:
    c370:	b538      	push	{r3, r4, r5, lr}
    c372:	690b      	ldr	r3, [r1, #16]
    c374:	4605      	mov	r5, r0
    c376:	460c      	mov	r4, r1
    c378:	b913      	cbnz	r3, c380 <_fflush_r+0x10>
    c37a:	2500      	movs	r5, #0
    c37c:	4628      	mov	r0, r5
    c37e:	bd38      	pop	{r3, r4, r5, pc}
    c380:	b118      	cbz	r0, c38a <_fflush_r+0x1a>
    c382:	6983      	ldr	r3, [r0, #24]
    c384:	b90b      	cbnz	r3, c38a <_fflush_r+0x1a>
    c386:	f000 f887 	bl	c498 <__sinit>
    c38a:	4b14      	ldr	r3, [pc, #80]	; (c3dc <_fflush_r+0x6c>)
    c38c:	429c      	cmp	r4, r3
    c38e:	d11b      	bne.n	c3c8 <_fflush_r+0x58>
    c390:	686c      	ldr	r4, [r5, #4]
    c392:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
    c396:	2b00      	cmp	r3, #0
    c398:	d0ef      	beq.n	c37a <_fflush_r+0xa>
    c39a:	6e62      	ldr	r2, [r4, #100]	; 0x64
    c39c:	07d0      	lsls	r0, r2, #31
    c39e:	d404      	bmi.n	c3aa <_fflush_r+0x3a>
    c3a0:	0599      	lsls	r1, r3, #22
    c3a2:	d402      	bmi.n	c3aa <_fflush_r+0x3a>
    c3a4:	6da0      	ldr	r0, [r4, #88]	; 0x58
    c3a6:	f000 f915 	bl	c5d4 <__retarget_lock_acquire_recursive>
    c3aa:	4628      	mov	r0, r5
    c3ac:	4621      	mov	r1, r4
    c3ae:	f7ff ff5d 	bl	c26c <__sflush_r>
    c3b2:	6e63      	ldr	r3, [r4, #100]	; 0x64
    c3b4:	07da      	lsls	r2, r3, #31
    c3b6:	4605      	mov	r5, r0
    c3b8:	d4e0      	bmi.n	c37c <_fflush_r+0xc>
    c3ba:	89a3      	ldrh	r3, [r4, #12]
    c3bc:	059b      	lsls	r3, r3, #22
    c3be:	d4dd      	bmi.n	c37c <_fflush_r+0xc>
    c3c0:	6da0      	ldr	r0, [r4, #88]	; 0x58
    c3c2:	f000 f908 	bl	c5d6 <__retarget_lock_release_recursive>
    c3c6:	e7d9      	b.n	c37c <_fflush_r+0xc>
    c3c8:	4b05      	ldr	r3, [pc, #20]	; (c3e0 <_fflush_r+0x70>)
    c3ca:	429c      	cmp	r4, r3
    c3cc:	d101      	bne.n	c3d2 <_fflush_r+0x62>
    c3ce:	68ac      	ldr	r4, [r5, #8]
    c3d0:	e7df      	b.n	c392 <_fflush_r+0x22>
    c3d2:	4b04      	ldr	r3, [pc, #16]	; (c3e4 <_fflush_r+0x74>)
    c3d4:	429c      	cmp	r4, r3
    c3d6:	bf08      	it	eq
    c3d8:	68ec      	ldreq	r4, [r5, #12]
    c3da:	e7da      	b.n	c392 <_fflush_r+0x22>
    c3dc:	0000cdac 	.word	0x0000cdac
    c3e0:	0000cdcc 	.word	0x0000cdcc
    c3e4:	0000cd8c 	.word	0x0000cd8c

0000c3e8 <std>:
    c3e8:	2300      	movs	r3, #0
    c3ea:	b510      	push	{r4, lr}
    c3ec:	4604      	mov	r4, r0
    c3ee:	e9c0 3300 	strd	r3, r3, [r0]
    c3f2:	e9c0 3304 	strd	r3, r3, [r0, #16]
    c3f6:	6083      	str	r3, [r0, #8]
    c3f8:	8181      	strh	r1, [r0, #12]
    c3fa:	6643      	str	r3, [r0, #100]	; 0x64
    c3fc:	81c2      	strh	r2, [r0, #14]
    c3fe:	6183      	str	r3, [r0, #24]
    c400:	4619      	mov	r1, r3
    c402:	2208      	movs	r2, #8
    c404:	305c      	adds	r0, #92	; 0x5c
    c406:	f7ff fe47 	bl	c098 <memset>
    c40a:	4b05      	ldr	r3, [pc, #20]	; (c420 <std+0x38>)
    c40c:	6263      	str	r3, [r4, #36]	; 0x24
    c40e:	4b05      	ldr	r3, [pc, #20]	; (c424 <std+0x3c>)
    c410:	62a3      	str	r3, [r4, #40]	; 0x28
    c412:	4b05      	ldr	r3, [pc, #20]	; (c428 <std+0x40>)
    c414:	62e3      	str	r3, [r4, #44]	; 0x2c
    c416:	4b05      	ldr	r3, [pc, #20]	; (c42c <std+0x44>)
    c418:	6224      	str	r4, [r4, #32]
    c41a:	6323      	str	r3, [r4, #48]	; 0x30
    c41c:	bd10      	pop	{r4, pc}
    c41e:	bf00      	nop
    c420:	0000c811 	.word	0x0000c811
    c424:	0000c833 	.word	0x0000c833
    c428:	0000c86b 	.word	0x0000c86b
    c42c:	0000c88f 	.word	0x0000c88f

0000c430 <_cleanup_r>:
    c430:	4901      	ldr	r1, [pc, #4]	; (c438 <_cleanup_r+0x8>)
    c432:	f000 b8af 	b.w	c594 <_fwalk_reent>
    c436:	bf00      	nop
    c438:	0000c371 	.word	0x0000c371

0000c43c <__sfmoreglue>:
    c43c:	b570      	push	{r4, r5, r6, lr}
    c43e:	2268      	movs	r2, #104	; 0x68
    c440:	1e4d      	subs	r5, r1, #1
    c442:	4355      	muls	r5, r2
    c444:	460e      	mov	r6, r1
    c446:	f105 0174 	add.w	r1, r5, #116	; 0x74
    c44a:	f000 f95d 	bl	c708 <_malloc_r>
    c44e:	4604      	mov	r4, r0
    c450:	b140      	cbz	r0, c464 <__sfmoreglue+0x28>
    c452:	2100      	movs	r1, #0
    c454:	e9c0 1600 	strd	r1, r6, [r0]
    c458:	300c      	adds	r0, #12
    c45a:	60a0      	str	r0, [r4, #8]
    c45c:	f105 0268 	add.w	r2, r5, #104	; 0x68
    c460:	f7ff fe1a 	bl	c098 <memset>
    c464:	4620      	mov	r0, r4
    c466:	bd70      	pop	{r4, r5, r6, pc}

0000c468 <__sfp_lock_acquire>:
    c468:	4801      	ldr	r0, [pc, #4]	; (c470 <__sfp_lock_acquire+0x8>)
    c46a:	f000 b8b3 	b.w	c5d4 <__retarget_lock_acquire_recursive>
    c46e:	bf00      	nop
    c470:	200168b6 	.word	0x200168b6

0000c474 <__sfp_lock_release>:
    c474:	4801      	ldr	r0, [pc, #4]	; (c47c <__sfp_lock_release+0x8>)
    c476:	f000 b8ae 	b.w	c5d6 <__retarget_lock_release_recursive>
    c47a:	bf00      	nop
    c47c:	200168b6 	.word	0x200168b6

0000c480 <__sinit_lock_acquire>:
    c480:	4801      	ldr	r0, [pc, #4]	; (c488 <__sinit_lock_acquire+0x8>)
    c482:	f000 b8a7 	b.w	c5d4 <__retarget_lock_acquire_recursive>
    c486:	bf00      	nop
    c488:	200168b7 	.word	0x200168b7

0000c48c <__sinit_lock_release>:
    c48c:	4801      	ldr	r0, [pc, #4]	; (c494 <__sinit_lock_release+0x8>)
    c48e:	f000 b8a2 	b.w	c5d6 <__retarget_lock_release_recursive>
    c492:	bf00      	nop
    c494:	200168b7 	.word	0x200168b7

0000c498 <__sinit>:
    c498:	b510      	push	{r4, lr}
    c49a:	4604      	mov	r4, r0
    c49c:	f7ff fff0 	bl	c480 <__sinit_lock_acquire>
    c4a0:	69a3      	ldr	r3, [r4, #24]
    c4a2:	b11b      	cbz	r3, c4ac <__sinit+0x14>
    c4a4:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    c4a8:	f7ff bff0 	b.w	c48c <__sinit_lock_release>
    c4ac:	e9c4 3312 	strd	r3, r3, [r4, #72]	; 0x48
    c4b0:	6523      	str	r3, [r4, #80]	; 0x50
    c4b2:	4b13      	ldr	r3, [pc, #76]	; (c500 <__sinit+0x68>)
    c4b4:	4a13      	ldr	r2, [pc, #76]	; (c504 <__sinit+0x6c>)
    c4b6:	681b      	ldr	r3, [r3, #0]
    c4b8:	62a2      	str	r2, [r4, #40]	; 0x28
    c4ba:	42a3      	cmp	r3, r4
    c4bc:	bf04      	itt	eq
    c4be:	2301      	moveq	r3, #1
    c4c0:	61a3      	streq	r3, [r4, #24]
    c4c2:	4620      	mov	r0, r4
    c4c4:	f000 f820 	bl	c508 <__sfp>
    c4c8:	6060      	str	r0, [r4, #4]
    c4ca:	4620      	mov	r0, r4
    c4cc:	f000 f81c 	bl	c508 <__sfp>
    c4d0:	60a0      	str	r0, [r4, #8]
    c4d2:	4620      	mov	r0, r4
    c4d4:	f000 f818 	bl	c508 <__sfp>
    c4d8:	2200      	movs	r2, #0
    c4da:	60e0      	str	r0, [r4, #12]
    c4dc:	2104      	movs	r1, #4
    c4de:	6860      	ldr	r0, [r4, #4]
    c4e0:	f7ff ff82 	bl	c3e8 <std>
    c4e4:	68a0      	ldr	r0, [r4, #8]
    c4e6:	2201      	movs	r2, #1
    c4e8:	2109      	movs	r1, #9
    c4ea:	f7ff ff7d 	bl	c3e8 <std>
    c4ee:	68e0      	ldr	r0, [r4, #12]
    c4f0:	2202      	movs	r2, #2
    c4f2:	2112      	movs	r1, #18
    c4f4:	f7ff ff78 	bl	c3e8 <std>
    c4f8:	2301      	movs	r3, #1
    c4fa:	61a3      	str	r3, [r4, #24]
    c4fc:	e7d2      	b.n	c4a4 <__sinit+0xc>
    c4fe:	bf00      	nop
    c500:	0000cd88 	.word	0x0000cd88
    c504:	0000c431 	.word	0x0000c431

0000c508 <__sfp>:
    c508:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    c50a:	4607      	mov	r7, r0
    c50c:	f7ff ffac 	bl	c468 <__sfp_lock_acquire>
    c510:	4b1e      	ldr	r3, [pc, #120]	; (c58c <__sfp+0x84>)
    c512:	681e      	ldr	r6, [r3, #0]
    c514:	69b3      	ldr	r3, [r6, #24]
    c516:	b913      	cbnz	r3, c51e <__sfp+0x16>
    c518:	4630      	mov	r0, r6
    c51a:	f7ff ffbd 	bl	c498 <__sinit>
    c51e:	3648      	adds	r6, #72	; 0x48
    c520:	e9d6 3401 	ldrd	r3, r4, [r6, #4]
    c524:	3b01      	subs	r3, #1
    c526:	d503      	bpl.n	c530 <__sfp+0x28>
    c528:	6833      	ldr	r3, [r6, #0]
    c52a:	b30b      	cbz	r3, c570 <__sfp+0x68>
    c52c:	6836      	ldr	r6, [r6, #0]
    c52e:	e7f7      	b.n	c520 <__sfp+0x18>
    c530:	f9b4 500c 	ldrsh.w	r5, [r4, #12]
    c534:	b9d5      	cbnz	r5, c56c <__sfp+0x64>
    c536:	4b16      	ldr	r3, [pc, #88]	; (c590 <__sfp+0x88>)
    c538:	60e3      	str	r3, [r4, #12]
    c53a:	f104 0058 	add.w	r0, r4, #88	; 0x58
    c53e:	6665      	str	r5, [r4, #100]	; 0x64
    c540:	f000 f847 	bl	c5d2 <__retarget_lock_init_recursive>
    c544:	f7ff ff96 	bl	c474 <__sfp_lock_release>
    c548:	e9c4 5501 	strd	r5, r5, [r4, #4]
    c54c:	e9c4 5504 	strd	r5, r5, [r4, #16]
    c550:	6025      	str	r5, [r4, #0]
    c552:	61a5      	str	r5, [r4, #24]
    c554:	2208      	movs	r2, #8
    c556:	4629      	mov	r1, r5
    c558:	f104 005c 	add.w	r0, r4, #92	; 0x5c
    c55c:	f7ff fd9c 	bl	c098 <memset>
    c560:	e9c4 550d 	strd	r5, r5, [r4, #52]	; 0x34
    c564:	e9c4 5512 	strd	r5, r5, [r4, #72]	; 0x48
    c568:	4620      	mov	r0, r4
    c56a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    c56c:	3468      	adds	r4, #104	; 0x68
    c56e:	e7d9      	b.n	c524 <__sfp+0x1c>
    c570:	2104      	movs	r1, #4
    c572:	4638      	mov	r0, r7
    c574:	f7ff ff62 	bl	c43c <__sfmoreglue>
    c578:	4604      	mov	r4, r0
    c57a:	6030      	str	r0, [r6, #0]
    c57c:	2800      	cmp	r0, #0
    c57e:	d1d5      	bne.n	c52c <__sfp+0x24>
    c580:	f7ff ff78 	bl	c474 <__sfp_lock_release>
    c584:	230c      	movs	r3, #12
    c586:	603b      	str	r3, [r7, #0]
    c588:	e7ee      	b.n	c568 <__sfp+0x60>
    c58a:	bf00      	nop
    c58c:	0000cd88 	.word	0x0000cd88
    c590:	ffff0001 	.word	0xffff0001

0000c594 <_fwalk_reent>:
    c594:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    c598:	4606      	mov	r6, r0
    c59a:	4688      	mov	r8, r1
    c59c:	f100 0448 	add.w	r4, r0, #72	; 0x48
    c5a0:	2700      	movs	r7, #0
    c5a2:	e9d4 9501 	ldrd	r9, r5, [r4, #4]
    c5a6:	f1b9 0901 	subs.w	r9, r9, #1
    c5aa:	d505      	bpl.n	c5b8 <_fwalk_reent+0x24>
    c5ac:	6824      	ldr	r4, [r4, #0]
    c5ae:	2c00      	cmp	r4, #0
    c5b0:	d1f7      	bne.n	c5a2 <_fwalk_reent+0xe>
    c5b2:	4638      	mov	r0, r7
    c5b4:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    c5b8:	89ab      	ldrh	r3, [r5, #12]
    c5ba:	2b01      	cmp	r3, #1
    c5bc:	d907      	bls.n	c5ce <_fwalk_reent+0x3a>
    c5be:	f9b5 300e 	ldrsh.w	r3, [r5, #14]
    c5c2:	3301      	adds	r3, #1
    c5c4:	d003      	beq.n	c5ce <_fwalk_reent+0x3a>
    c5c6:	4629      	mov	r1, r5
    c5c8:	4630      	mov	r0, r6
    c5ca:	47c0      	blx	r8
    c5cc:	4307      	orrs	r7, r0
    c5ce:	3568      	adds	r5, #104	; 0x68
    c5d0:	e7e9      	b.n	c5a6 <_fwalk_reent+0x12>

0000c5d2 <__retarget_lock_init_recursive>:
    c5d2:	4770      	bx	lr

0000c5d4 <__retarget_lock_acquire_recursive>:
    c5d4:	4770      	bx	lr

0000c5d6 <__retarget_lock_release_recursive>:
    c5d6:	4770      	bx	lr

0000c5d8 <__swhatbuf_r>:
    c5d8:	b570      	push	{r4, r5, r6, lr}
    c5da:	460e      	mov	r6, r1
    c5dc:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
    c5e0:	2900      	cmp	r1, #0
    c5e2:	b096      	sub	sp, #88	; 0x58
    c5e4:	4614      	mov	r4, r2
    c5e6:	461d      	mov	r5, r3
    c5e8:	da08      	bge.n	c5fc <__swhatbuf_r+0x24>
    c5ea:	f9b6 300c 	ldrsh.w	r3, [r6, #12]
    c5ee:	2200      	movs	r2, #0
    c5f0:	602a      	str	r2, [r5, #0]
    c5f2:	061a      	lsls	r2, r3, #24
    c5f4:	d410      	bmi.n	c618 <__swhatbuf_r+0x40>
    c5f6:	f44f 6380 	mov.w	r3, #1024	; 0x400
    c5fa:	e00e      	b.n	c61a <__swhatbuf_r+0x42>
    c5fc:	466a      	mov	r2, sp
    c5fe:	f000 f96d 	bl	c8dc <_fstat_r>
    c602:	2800      	cmp	r0, #0
    c604:	dbf1      	blt.n	c5ea <__swhatbuf_r+0x12>
    c606:	9a01      	ldr	r2, [sp, #4]
    c608:	f402 4270 	and.w	r2, r2, #61440	; 0xf000
    c60c:	f5a2 5300 	sub.w	r3, r2, #8192	; 0x2000
    c610:	425a      	negs	r2, r3
    c612:	415a      	adcs	r2, r3
    c614:	602a      	str	r2, [r5, #0]
    c616:	e7ee      	b.n	c5f6 <__swhatbuf_r+0x1e>
    c618:	2340      	movs	r3, #64	; 0x40
    c61a:	2000      	movs	r0, #0
    c61c:	6023      	str	r3, [r4, #0]
    c61e:	b016      	add	sp, #88	; 0x58
    c620:	bd70      	pop	{r4, r5, r6, pc}
	...

0000c624 <malloc>:
    c624:	4b02      	ldr	r3, [pc, #8]	; (c630 <malloc+0xc>)
    c626:	4601      	mov	r1, r0
    c628:	6818      	ldr	r0, [r3, #0]
    c62a:	f000 b86d 	b.w	c708 <_malloc_r>
    c62e:	bf00      	nop
    c630:	2000001c 	.word	0x2000001c

0000c634 <_free_r>:
    c634:	b538      	push	{r3, r4, r5, lr}
    c636:	4605      	mov	r5, r0
    c638:	2900      	cmp	r1, #0
    c63a:	d041      	beq.n	c6c0 <_free_r+0x8c>
    c63c:	f851 3c04 	ldr.w	r3, [r1, #-4]
    c640:	1f0c      	subs	r4, r1, #4
    c642:	2b00      	cmp	r3, #0
    c644:	bfb8      	it	lt
    c646:	18e4      	addlt	r4, r4, r3
    c648:	f000 f96c 	bl	c924 <__malloc_lock>
    c64c:	4a1d      	ldr	r2, [pc, #116]	; (c6c4 <_free_r+0x90>)
    c64e:	6813      	ldr	r3, [r2, #0]
    c650:	b933      	cbnz	r3, c660 <_free_r+0x2c>
    c652:	6063      	str	r3, [r4, #4]
    c654:	6014      	str	r4, [r2, #0]
    c656:	4628      	mov	r0, r5
    c658:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
    c65c:	f000 b968 	b.w	c930 <__malloc_unlock>
    c660:	42a3      	cmp	r3, r4
    c662:	d908      	bls.n	c676 <_free_r+0x42>
    c664:	6820      	ldr	r0, [r4, #0]
    c666:	1821      	adds	r1, r4, r0
    c668:	428b      	cmp	r3, r1
    c66a:	bf01      	itttt	eq
    c66c:	6819      	ldreq	r1, [r3, #0]
    c66e:	685b      	ldreq	r3, [r3, #4]
    c670:	1809      	addeq	r1, r1, r0
    c672:	6021      	streq	r1, [r4, #0]
    c674:	e7ed      	b.n	c652 <_free_r+0x1e>
    c676:	461a      	mov	r2, r3
    c678:	685b      	ldr	r3, [r3, #4]
    c67a:	b10b      	cbz	r3, c680 <_free_r+0x4c>
    c67c:	42a3      	cmp	r3, r4
    c67e:	d9fa      	bls.n	c676 <_free_r+0x42>
    c680:	6811      	ldr	r1, [r2, #0]
    c682:	1850      	adds	r0, r2, r1
    c684:	42a0      	cmp	r0, r4
    c686:	d10b      	bne.n	c6a0 <_free_r+0x6c>
    c688:	6820      	ldr	r0, [r4, #0]
    c68a:	4401      	add	r1, r0
    c68c:	1850      	adds	r0, r2, r1
    c68e:	4283      	cmp	r3, r0
    c690:	6011      	str	r1, [r2, #0]
    c692:	d1e0      	bne.n	c656 <_free_r+0x22>
    c694:	6818      	ldr	r0, [r3, #0]
    c696:	685b      	ldr	r3, [r3, #4]
    c698:	6053      	str	r3, [r2, #4]
    c69a:	4401      	add	r1, r0
    c69c:	6011      	str	r1, [r2, #0]
    c69e:	e7da      	b.n	c656 <_free_r+0x22>
    c6a0:	d902      	bls.n	c6a8 <_free_r+0x74>
    c6a2:	230c      	movs	r3, #12
    c6a4:	602b      	str	r3, [r5, #0]
    c6a6:	e7d6      	b.n	c656 <_free_r+0x22>
    c6a8:	6820      	ldr	r0, [r4, #0]
    c6aa:	1821      	adds	r1, r4, r0
    c6ac:	428b      	cmp	r3, r1
    c6ae:	bf04      	itt	eq
    c6b0:	6819      	ldreq	r1, [r3, #0]
    c6b2:	685b      	ldreq	r3, [r3, #4]
    c6b4:	6063      	str	r3, [r4, #4]
    c6b6:	bf04      	itt	eq
    c6b8:	1809      	addeq	r1, r1, r0
    c6ba:	6021      	streq	r1, [r4, #0]
    c6bc:	6054      	str	r4, [r2, #4]
    c6be:	e7ca      	b.n	c656 <_free_r+0x22>
    c6c0:	bd38      	pop	{r3, r4, r5, pc}
    c6c2:	bf00      	nop
    c6c4:	200168b8 	.word	0x200168b8

0000c6c8 <sbrk_aligned>:
    c6c8:	b570      	push	{r4, r5, r6, lr}
    c6ca:	4e0e      	ldr	r6, [pc, #56]	; (c704 <sbrk_aligned+0x3c>)
    c6cc:	460c      	mov	r4, r1
    c6ce:	6831      	ldr	r1, [r6, #0]
    c6d0:	4605      	mov	r5, r0
    c6d2:	b911      	cbnz	r1, c6da <sbrk_aligned+0x12>
    c6d4:	f000 f88c 	bl	c7f0 <_sbrk_r>
    c6d8:	6030      	str	r0, [r6, #0]
    c6da:	4621      	mov	r1, r4
    c6dc:	4628      	mov	r0, r5
    c6de:	f000 f887 	bl	c7f0 <_sbrk_r>
    c6e2:	1c43      	adds	r3, r0, #1
    c6e4:	d00a      	beq.n	c6fc <sbrk_aligned+0x34>
    c6e6:	1cc4      	adds	r4, r0, #3
    c6e8:	f024 0403 	bic.w	r4, r4, #3
    c6ec:	42a0      	cmp	r0, r4
    c6ee:	d007      	beq.n	c700 <sbrk_aligned+0x38>
    c6f0:	1a21      	subs	r1, r4, r0
    c6f2:	4628      	mov	r0, r5
    c6f4:	f000 f87c 	bl	c7f0 <_sbrk_r>
    c6f8:	3001      	adds	r0, #1
    c6fa:	d101      	bne.n	c700 <sbrk_aligned+0x38>
    c6fc:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
    c700:	4620      	mov	r0, r4
    c702:	bd70      	pop	{r4, r5, r6, pc}
    c704:	200168bc 	.word	0x200168bc

0000c708 <_malloc_r>:
    c708:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    c70c:	1ccd      	adds	r5, r1, #3
    c70e:	f025 0503 	bic.w	r5, r5, #3
    c712:	3508      	adds	r5, #8
    c714:	2d0c      	cmp	r5, #12
    c716:	bf38      	it	cc
    c718:	250c      	movcc	r5, #12
    c71a:	2d00      	cmp	r5, #0
    c71c:	4607      	mov	r7, r0
    c71e:	db01      	blt.n	c724 <_malloc_r+0x1c>
    c720:	42a9      	cmp	r1, r5
    c722:	d905      	bls.n	c730 <_malloc_r+0x28>
    c724:	230c      	movs	r3, #12
    c726:	603b      	str	r3, [r7, #0]
    c728:	2600      	movs	r6, #0
    c72a:	4630      	mov	r0, r6
    c72c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    c730:	4e2e      	ldr	r6, [pc, #184]	; (c7ec <_malloc_r+0xe4>)
    c732:	f000 f8f7 	bl	c924 <__malloc_lock>
    c736:	6833      	ldr	r3, [r6, #0]
    c738:	461c      	mov	r4, r3
    c73a:	bb34      	cbnz	r4, c78a <_malloc_r+0x82>
    c73c:	4629      	mov	r1, r5
    c73e:	4638      	mov	r0, r7
    c740:	f7ff ffc2 	bl	c6c8 <sbrk_aligned>
    c744:	1c43      	adds	r3, r0, #1
    c746:	4604      	mov	r4, r0
    c748:	d14d      	bne.n	c7e6 <_malloc_r+0xde>
    c74a:	6834      	ldr	r4, [r6, #0]
    c74c:	4626      	mov	r6, r4
    c74e:	2e00      	cmp	r6, #0
    c750:	d140      	bne.n	c7d4 <_malloc_r+0xcc>
    c752:	6823      	ldr	r3, [r4, #0]
    c754:	4631      	mov	r1, r6
    c756:	4638      	mov	r0, r7
    c758:	eb04 0803 	add.w	r8, r4, r3
    c75c:	f000 f848 	bl	c7f0 <_sbrk_r>
    c760:	4580      	cmp	r8, r0
    c762:	d13a      	bne.n	c7da <_malloc_r+0xd2>
    c764:	6821      	ldr	r1, [r4, #0]
    c766:	3503      	adds	r5, #3
    c768:	1a6d      	subs	r5, r5, r1
    c76a:	f025 0503 	bic.w	r5, r5, #3
    c76e:	3508      	adds	r5, #8
    c770:	2d0c      	cmp	r5, #12
    c772:	bf38      	it	cc
    c774:	250c      	movcc	r5, #12
    c776:	4629      	mov	r1, r5
    c778:	4638      	mov	r0, r7
    c77a:	f7ff ffa5 	bl	c6c8 <sbrk_aligned>
    c77e:	3001      	adds	r0, #1
    c780:	d02b      	beq.n	c7da <_malloc_r+0xd2>
    c782:	6823      	ldr	r3, [r4, #0]
    c784:	442b      	add	r3, r5
    c786:	6023      	str	r3, [r4, #0]
    c788:	e00e      	b.n	c7a8 <_malloc_r+0xa0>
    c78a:	6822      	ldr	r2, [r4, #0]
    c78c:	1b52      	subs	r2, r2, r5
    c78e:	d41e      	bmi.n	c7ce <_malloc_r+0xc6>
    c790:	2a0b      	cmp	r2, #11
    c792:	d916      	bls.n	c7c2 <_malloc_r+0xba>
    c794:	1961      	adds	r1, r4, r5
    c796:	42a3      	cmp	r3, r4
    c798:	6025      	str	r5, [r4, #0]
    c79a:	bf18      	it	ne
    c79c:	6059      	strne	r1, [r3, #4]
    c79e:	6863      	ldr	r3, [r4, #4]
    c7a0:	bf08      	it	eq
    c7a2:	6031      	streq	r1, [r6, #0]
    c7a4:	5162      	str	r2, [r4, r5]
    c7a6:	604b      	str	r3, [r1, #4]
    c7a8:	4638      	mov	r0, r7
    c7aa:	f104 060b 	add.w	r6, r4, #11
    c7ae:	f000 f8bf 	bl	c930 <__malloc_unlock>
    c7b2:	f026 0607 	bic.w	r6, r6, #7
    c7b6:	1d23      	adds	r3, r4, #4
    c7b8:	1af2      	subs	r2, r6, r3
    c7ba:	d0b6      	beq.n	c72a <_malloc_r+0x22>
    c7bc:	1b9b      	subs	r3, r3, r6
    c7be:	50a3      	str	r3, [r4, r2]
    c7c0:	e7b3      	b.n	c72a <_malloc_r+0x22>
    c7c2:	6862      	ldr	r2, [r4, #4]
    c7c4:	42a3      	cmp	r3, r4
    c7c6:	bf0c      	ite	eq
    c7c8:	6032      	streq	r2, [r6, #0]
    c7ca:	605a      	strne	r2, [r3, #4]
    c7cc:	e7ec      	b.n	c7a8 <_malloc_r+0xa0>
    c7ce:	4623      	mov	r3, r4
    c7d0:	6864      	ldr	r4, [r4, #4]
    c7d2:	e7b2      	b.n	c73a <_malloc_r+0x32>
    c7d4:	4634      	mov	r4, r6
    c7d6:	6876      	ldr	r6, [r6, #4]
    c7d8:	e7b9      	b.n	c74e <_malloc_r+0x46>
    c7da:	230c      	movs	r3, #12
    c7dc:	603b      	str	r3, [r7, #0]
    c7de:	4638      	mov	r0, r7
    c7e0:	f000 f8a6 	bl	c930 <__malloc_unlock>
    c7e4:	e7a1      	b.n	c72a <_malloc_r+0x22>
    c7e6:	6025      	str	r5, [r4, #0]
    c7e8:	e7de      	b.n	c7a8 <_malloc_r+0xa0>
    c7ea:	bf00      	nop
    c7ec:	200168b8 	.word	0x200168b8

0000c7f0 <_sbrk_r>:
    c7f0:	b538      	push	{r3, r4, r5, lr}
    c7f2:	4d06      	ldr	r5, [pc, #24]	; (c80c <_sbrk_r+0x1c>)
    c7f4:	2300      	movs	r3, #0
    c7f6:	4604      	mov	r4, r0
    c7f8:	4608      	mov	r0, r1
    c7fa:	602b      	str	r3, [r5, #0]
    c7fc:	f7f4 f9a8 	bl	b50 <_sbrk>
    c800:	1c43      	adds	r3, r0, #1
    c802:	d102      	bne.n	c80a <_sbrk_r+0x1a>
    c804:	682b      	ldr	r3, [r5, #0]
    c806:	b103      	cbz	r3, c80a <_sbrk_r+0x1a>
    c808:	6023      	str	r3, [r4, #0]
    c80a:	bd38      	pop	{r3, r4, r5, pc}
    c80c:	200168c0 	.word	0x200168c0

0000c810 <__sread>:
    c810:	b510      	push	{r4, lr}
    c812:	460c      	mov	r4, r1
    c814:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
    c818:	f000 f890 	bl	c93c <_read_r>
    c81c:	2800      	cmp	r0, #0
    c81e:	bfab      	itete	ge
    c820:	6d63      	ldrge	r3, [r4, #84]	; 0x54
    c822:	89a3      	ldrhlt	r3, [r4, #12]
    c824:	181b      	addge	r3, r3, r0
    c826:	f423 5380 	biclt.w	r3, r3, #4096	; 0x1000
    c82a:	bfac      	ite	ge
    c82c:	6563      	strge	r3, [r4, #84]	; 0x54
    c82e:	81a3      	strhlt	r3, [r4, #12]
    c830:	bd10      	pop	{r4, pc}

0000c832 <__swrite>:
    c832:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    c836:	461f      	mov	r7, r3
    c838:	898b      	ldrh	r3, [r1, #12]
    c83a:	05db      	lsls	r3, r3, #23
    c83c:	4605      	mov	r5, r0
    c83e:	460c      	mov	r4, r1
    c840:	4616      	mov	r6, r2
    c842:	d505      	bpl.n	c850 <__swrite+0x1e>
    c844:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
    c848:	2302      	movs	r3, #2
    c84a:	2200      	movs	r2, #0
    c84c:	f000 f858 	bl	c900 <_lseek_r>
    c850:	89a3      	ldrh	r3, [r4, #12]
    c852:	f9b4 100e 	ldrsh.w	r1, [r4, #14]
    c856:	f423 5380 	bic.w	r3, r3, #4096	; 0x1000
    c85a:	81a3      	strh	r3, [r4, #12]
    c85c:	4632      	mov	r2, r6
    c85e:	463b      	mov	r3, r7
    c860:	4628      	mov	r0, r5
    c862:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
    c866:	f000 b817 	b.w	c898 <_write_r>

0000c86a <__sseek>:
    c86a:	b510      	push	{r4, lr}
    c86c:	460c      	mov	r4, r1
    c86e:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
    c872:	f000 f845 	bl	c900 <_lseek_r>
    c876:	1c43      	adds	r3, r0, #1
    c878:	89a3      	ldrh	r3, [r4, #12]
    c87a:	bf15      	itete	ne
    c87c:	6560      	strne	r0, [r4, #84]	; 0x54
    c87e:	f423 5380 	biceq.w	r3, r3, #4096	; 0x1000
    c882:	f443 5380 	orrne.w	r3, r3, #4096	; 0x1000
    c886:	81a3      	strheq	r3, [r4, #12]
    c888:	bf18      	it	ne
    c88a:	81a3      	strhne	r3, [r4, #12]
    c88c:	bd10      	pop	{r4, pc}

0000c88e <__sclose>:
    c88e:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
    c892:	f000 b813 	b.w	c8bc <_close_r>
	...

0000c898 <_write_r>:
    c898:	b538      	push	{r3, r4, r5, lr}
    c89a:	4d07      	ldr	r5, [pc, #28]	; (c8b8 <_write_r+0x20>)
    c89c:	4604      	mov	r4, r0
    c89e:	4608      	mov	r0, r1
    c8a0:	4611      	mov	r1, r2
    c8a2:	2200      	movs	r2, #0
    c8a4:	602a      	str	r2, [r5, #0]
    c8a6:	461a      	mov	r2, r3
    c8a8:	f7fc f888 	bl	89bc <_write>
    c8ac:	1c43      	adds	r3, r0, #1
    c8ae:	d102      	bne.n	c8b6 <_write_r+0x1e>
    c8b0:	682b      	ldr	r3, [r5, #0]
    c8b2:	b103      	cbz	r3, c8b6 <_write_r+0x1e>
    c8b4:	6023      	str	r3, [r4, #0]
    c8b6:	bd38      	pop	{r3, r4, r5, pc}
    c8b8:	200168c0 	.word	0x200168c0

0000c8bc <_close_r>:
    c8bc:	b538      	push	{r3, r4, r5, lr}
    c8be:	4d06      	ldr	r5, [pc, #24]	; (c8d8 <_close_r+0x1c>)
    c8c0:	2300      	movs	r3, #0
    c8c2:	4604      	mov	r4, r0
    c8c4:	4608      	mov	r0, r1
    c8c6:	602b      	str	r3, [r5, #0]
    c8c8:	f7f4 f950 	bl	b6c <_close>
    c8cc:	1c43      	adds	r3, r0, #1
    c8ce:	d102      	bne.n	c8d6 <_close_r+0x1a>
    c8d0:	682b      	ldr	r3, [r5, #0]
    c8d2:	b103      	cbz	r3, c8d6 <_close_r+0x1a>
    c8d4:	6023      	str	r3, [r4, #0]
    c8d6:	bd38      	pop	{r3, r4, r5, pc}
    c8d8:	200168c0 	.word	0x200168c0

0000c8dc <_fstat_r>:
    c8dc:	b538      	push	{r3, r4, r5, lr}
    c8de:	4d07      	ldr	r5, [pc, #28]	; (c8fc <_fstat_r+0x20>)
    c8e0:	2300      	movs	r3, #0
    c8e2:	4604      	mov	r4, r0
    c8e4:	4608      	mov	r0, r1
    c8e6:	4611      	mov	r1, r2
    c8e8:	602b      	str	r3, [r5, #0]
    c8ea:	f7f4 f942 	bl	b72 <_fstat>
    c8ee:	1c43      	adds	r3, r0, #1
    c8f0:	d102      	bne.n	c8f8 <_fstat_r+0x1c>
    c8f2:	682b      	ldr	r3, [r5, #0]
    c8f4:	b103      	cbz	r3, c8f8 <_fstat_r+0x1c>
    c8f6:	6023      	str	r3, [r4, #0]
    c8f8:	bd38      	pop	{r3, r4, r5, pc}
    c8fa:	bf00      	nop
    c8fc:	200168c0 	.word	0x200168c0

0000c900 <_lseek_r>:
    c900:	b538      	push	{r3, r4, r5, lr}
    c902:	4d07      	ldr	r5, [pc, #28]	; (c920 <_lseek_r+0x20>)
    c904:	4604      	mov	r4, r0
    c906:	4608      	mov	r0, r1
    c908:	4611      	mov	r1, r2
    c90a:	2200      	movs	r2, #0
    c90c:	602a      	str	r2, [r5, #0]
    c90e:	461a      	mov	r2, r3
    c910:	f7f4 f934 	bl	b7c <_lseek>
    c914:	1c43      	adds	r3, r0, #1
    c916:	d102      	bne.n	c91e <_lseek_r+0x1e>
    c918:	682b      	ldr	r3, [r5, #0]
    c91a:	b103      	cbz	r3, c91e <_lseek_r+0x1e>
    c91c:	6023      	str	r3, [r4, #0]
    c91e:	bd38      	pop	{r3, r4, r5, pc}
    c920:	200168c0 	.word	0x200168c0

0000c924 <__malloc_lock>:
    c924:	4801      	ldr	r0, [pc, #4]	; (c92c <__malloc_lock+0x8>)
    c926:	f7ff be55 	b.w	c5d4 <__retarget_lock_acquire_recursive>
    c92a:	bf00      	nop
    c92c:	200168b5 	.word	0x200168b5

0000c930 <__malloc_unlock>:
    c930:	4801      	ldr	r0, [pc, #4]	; (c938 <__malloc_unlock+0x8>)
    c932:	f7ff be50 	b.w	c5d6 <__retarget_lock_release_recursive>
    c936:	bf00      	nop
    c938:	200168b5 	.word	0x200168b5

0000c93c <_read_r>:
    c93c:	b538      	push	{r3, r4, r5, lr}
    c93e:	4d07      	ldr	r5, [pc, #28]	; (c95c <_read_r+0x20>)
    c940:	4604      	mov	r4, r0
    c942:	4608      	mov	r0, r1
    c944:	4611      	mov	r1, r2
    c946:	2200      	movs	r2, #0
    c948:	602a      	str	r2, [r5, #0]
    c94a:	461a      	mov	r2, r3
    c94c:	f7f4 fb10 	bl	f70 <_read>
    c950:	1c43      	adds	r3, r0, #1
    c952:	d102      	bne.n	c95a <_read_r+0x1e>
    c954:	682b      	ldr	r3, [r5, #0]
    c956:	b103      	cbz	r3, c95a <_read_r+0x1e>
    c958:	6023      	str	r3, [r4, #0]
    c95a:	bd38      	pop	{r3, r4, r5, pc}
    c95c:	200168c0 	.word	0x200168c0
    c960:	682f2e2e 	.word	0x682f2e2e
    c964:	732f6c61 	.word	0x732f6c61
    c968:	682f6372 	.word	0x682f6372
    c96c:	755f6c61 	.word	0x755f6c61
    c970:	74726173 	.word	0x74726173
    c974:	6e79735f 	.word	0x6e79735f
    c978:	00632e63 	.word	0x00632e63
    c97c:	652f2e2e 	.word	0x652f2e2e
    c980:	72656874 	.word	0x72656874
    c984:	5f74656e 	.word	0x5f74656e
    c988:	2f796870 	.word	0x2f796870
    c98c:	65687465 	.word	0x65687465
    c990:	74656e72 	.word	0x74656e72
    c994:	7968705f 	.word	0x7968705f
    c998:	632e      	.short	0x632e
	...

0000c99b <CSWTCH.10>:
    c99b:	2438 0010 5049 415f 4444 2052 2020 3a20     8$..IP_ADDR    :
    c9ab:	2520 0d73 000a 454e 5f54 414d 4b53 2020      %s...NET_MASK  
    c9bb:	3a20 2520 0d73 000a 4147 4554 4157 5f59      : %s...GATEWAY_
    c9cb:	5049 3a20 2520 0d73 000a 0a0d 6f53 6b63     IP : %s.....Sock
    c9db:	7465 4120 4950 6920 706d 656c 656d 746e     et API implement
    c9eb:	7461 6f69 0d6e 000a                          ation....

0000c9f4 <memp_num>:
    c9f4:	0004 0005 0008 0010 0005 000f 0002 0004     ................
    ca04:	0008 0008 0005 0010 0010                    ..........

0000ca0e <memp_sizes>:
    ca0e:	0020 0098 001c 0010 0020 0018 0010 002c      ....... .....,.
    ca1e:	0014 0014 0010 0010 05fc 2e2e 682f 6c61     ............/hal
    ca2e:	732f 6372 682f 6c61 6d5f 6361 615f 7973     /src/hal_mac_asy
    ca3e:	636e 632e ff00 ffff ffff 00ff 0000 0000     nc.c............
	...

0000ca50 <ethbroadcast>:
    ca50:	ffff ffff ffff                              ......

0000ca56 <ethzero>:
    ca56:	0000 0000 0000 2e2e 682f 6c61 732f 6372     ......../hal/src
    ca66:	682f 6c61 695f 2e6f 0063 4c43 534f 4445     /hal_io.c.CLOSED
    ca76:	4c00 5349 4554 004e 5953 5f4e 4553 544e     .LISTEN.SYN_SENT
    ca86:	5300 4e59 525f 5643 0044 5345 4154 4c42     .SYN_RCVD.ESTABL
    ca96:	5349 4548 0044 4946 5f4e 4157 5449 315f     ISHED.FIN_WAIT_1
    caa6:	4600 4e49 575f 4941 5f54 0032 4c43 534f     .FIN_WAIT_2.CLOS
    cab6:	5f45 4157 5449 4300 4f4c 4953 474e 4c00     E_WAIT.CLOSING.L
    cac6:	5341 5f54 4341 004b 4954 454d 575f 4941     AST_ACK.TIME_WAI
    cad6:	0054                                        T.

0000cad8 <tcp_pcb_lists>:
    cad8:	4944 2001 493c 2001 4950 2001 4958 2001     DI. <I. PI. XI. 

0000cae8 <tcp_persist_backoff>:
    cae8:	0603 180c 6030                               ....0`x

0000caef <tcp_backoff>:
    caef:	0201 0403 0605 0707 0707 0707                .............

0000cafc <tcp_state_str>:
    cafc:	ca70 0000 ca77 0000 ca7e 0000 ca87 0000     p...w...~.......
    cb0c:	ca90 0000 ca9c 0000 caa7 0000 cab2 0000     ................
    cb1c:	cabd 0000 cac5 0000 cace 0000 2e2e 682f     ............../h
    cb2c:	6c70 732f 7265 6f63 2f6d 7068 5f6c 6573     pl/sercom/hpl_se
    cb3c:	6372 6d6f 632e 0000 3000 4000 3400 4000     rcom.c...0.@.4.@
    cb4c:	2000 4101 4000 4101 0000 4300 0400 4300     . .A.@.A...C...C
    cb5c:	0800 4300 0c00 4300                         ...C...C

0000cb64 <_i2cms>:
	...

0000cb7c <sercomspi_regs>:
	...
    cb8c:	0d00 450a 6874 7265 656e 2074 696c 6b6e     ...Ethernet link
    cb9c:	7520 0d70 0d0a 000a 4d47 4341 4c00 6465      up.....GMAC.Led
    cbac:	0000 0000 2000 5476 726d 5320 6376 4700     ..... vTmr Svc.G
    cbbc:	5445 4500 6874 7265 656e 5f74 6162 6973     ET.Ethernet_basi
    cbcc:	0063                                        c.

0000cbce <http_html_hdr>:
    cbce:	5448 5054 312f 302e 3220 3030 4f20 0d4b     HTTP/1.0 200 OK.
    cbde:	430a 6e6f 6574 746e 742d 7079 3a65 7420     .Content-type: t
    cbee:	7865 2f74 7468 6c6d 0a0d 0a0d                ext/html.....

0000cbfb <socket_webpage>:
    cbfb:	683c 6d74 3e6c 3c20 6568 6461 3c3e 6974     <html> <head><ti
    cc0b:	6c74 3e65 6142 6973 2063 6577 7062 6761     tle>Basic webpag
    cc1b:	3c65 742f 7469 656c 3c3e 682f 6165 3e64     e</title></head>
    cc2b:	3c20 6f62 7964 203e 6557 636c 6d6f 2065      <body> Welcome 
    cc3b:	6f74 7920 756f 2072 6162 6973 2063 6577     to your basic we
    cc4b:	7062 6761 2065 7375 6e69 2067 6f53 6b63     bpage using Sock
    cc5b:	7465 4120 4950 202e 2f3c 6f62 7964 203e     et API. </body> 
    cc6b:	2f3c 7468 6c6d 003e 2e2e 682f 6c70 672f     </html>.../hpl/g
    cc7b:	616d 2f63 7068 5f6c 6d67 6361 632e 0000     mac/hpl_gmac.c..
	...

0000cc8c <ip_addr_broadcast>:
    cc8c:	ffff ffff                                   ....

0000cc90 <ip_addr_any>:
    cc90:	0000 0000 4449 454c 0900 6325 2509 0975     ....IDLE..%c.%u.
    cca0:	7525 2509 0d75 000a                         %u.%u...

0000cca8 <err_to_errno_table>:
    cca8:	0000 0000 000c 0000 0069 0000 000b 0000     ........i.......
    ccb8:	0071 0000 0073 0000 0016 0000 000b 0000     q...s...........
    ccc8:	0062 0000 0072 0000 0067 0000 0068 0000     b...r...g...h...
    ccd8:	006b 0000 006b 0000 0005 0000 ffff ffff     k...k...........
    cce8:	6374 6970 5f70 6874 6572 6461 5400 7265     tcpip_thread.Ter
    ccf8:	696d 616e 006c                              minal.

0000ccfe <_aInitStr.0>:
    ccfe:	0000 0000 0000 5454 2052 4552 4747 5345     ......TTR REGGES
	...

0000cd0f <_aTerminalId>:
    cd0f:	3130 3332 3534 3736 3938 4241 4443 4645     0123456789ABCDEF
    cd1f:	6e66 0069 6e66 2b69 6e00 6e61 6600 696e     fni.fni+.nan.fni
    cd2f:	002d 0000 0000 0000                          -........

0000cd38 <pow10.0>:
    cd38:	0000 0000 0000 3ff0 0000 0000 0000 4024     .......?......$@
    cd48:	0000 0000 0000 4059 0000 0000 4000 408f     ......Y@.....@.@
    cd58:	0000 0000 8800 40c3 0000 0000 6a00 40f8     .......@.....j.@
    cd68:	0000 0000 8480 412e 0000 0000 12d0 4163     .......A......cA
    cd78:	0000 0000 d784 4197 0000 0000 cd65 41cd     .......A....e..A

0000cd88 <_global_impure_ptr>:
    cd88:	0020 2000                                    .. 

0000cd8c <__sf_fake_stderr>:
	...

0000cdac <__sf_fake_stdin>:
	...

0000cdcc <__sf_fake_stdout>:
	...

0000cdec <_init>:
    cdec:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    cdee:	bf00      	nop
    cdf0:	bcf8      	pop	{r3, r4, r5, r6, r7}
    cdf2:	bc08      	pop	{r3}
    cdf4:	469e      	mov	lr, r3
    cdf6:	4770      	bx	lr

0000cdf8 <__frame_dummy_init_array_entry>:
    cdf8:	0289 0000                                   ....

0000cdfc <_fini>:
    cdfc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    cdfe:	bf00      	nop
    ce00:	bcf8      	pop	{r3, r4, r5, r6, r7}
    ce02:	bc08      	pop	{r3}
    ce04:	469e      	mov	lr, r3
    ce06:	4770      	bx	lr

0000ce08 <__do_global_dtors_aux_fini_array_entry>:
    ce08:	0265 0000                                   e...
